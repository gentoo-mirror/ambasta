From 30a5acc12e7600b434e1af96fc6811e501b1a6a5 Mon Sep 17 00:00:00 2001
From: Amit Prakash Ambasta <amit.prakash.ambasta@gmail.com>
Date: Fri, 9 Jun 2023 13:12:19 +0530
Subject: [PATCH] C++23 fixes

Signed-off-by: Amit Prakash Ambasta <amit.prakash.ambasta@gmail.com>
---
 CMakeLists.txt                    |    2 +-
 src/soplex/changesoplex.hpp       | 1159 ++--
 src/soplex/clufactor.hpp          | 9450 +++++++++++++----------------
 src/soplex/clufactor_rational.hpp | 8979 +++++++++++++--------------
 src/soplex/dsvectorbase.h         |  518 +-
 src/soplex/enter.hpp              | 2622 ++++----
 src/soplex/islist.h               |  721 +--
 src/soplex/leave.hpp              | 2037 +++----
 src/soplex/lpcolbase.h            |  255 +-
 src/soplex/lpcolsetbase.h         | 1030 ++--
 src/soplex/lprowbase.h            |  454 +-
 src/soplex/lprowsetbase.h         | 1212 ++--
 src/soplex/ratrecon.hpp           |  376 +-
 src/soplex/slufactor.h            |  490 +-
 src/soplex/slufactor.hpp          | 2481 ++++----
 src/soplex/slufactor_rational.hpp | 1416 +++--
 src/soplex/solbase.h              |  390 +-
 src/soplex/solvedbds.hpp          | 7640 ++++++++++++-----------
 src/soplex/solverational.hpp      | 7916 ++++++++++++------------
 src/soplex/solvereal.hpp          | 1366 +++--
 src/soplex/spxautopr.hpp          |  125 +-
 src/soplex/spxbasis.h             | 1664 +++--
 src/soplex/spxbasis.hpp           | 2243 ++++---
 src/soplex/spxboundflippingrt.hpp | 2219 ++++---
 src/soplex/spxbounds.hpp          |  653 +-
 src/soplex/spxchangebasis.hpp     |  728 +--
 src/soplex/spxdantzigpr.hpp       |  348 +-
 src/soplex/spxdefaultrt.hpp       |  627 +-
 src/soplex/spxdefines.hpp         |   93 +-
 src/soplex/spxdesc.hpp            |  240 +-
 src/soplex/spxdevexpr.hpp         | 1494 +++--
 src/soplex/spxequilisc.hpp        |  355 +-
 src/soplex/spxfastrt.hpp          | 2477 ++++----
 src/soplex/spxfileio.hpp          |   46 +-
 src/soplex/spxgeometsc.hpp        |  393 +-
 src/soplex/spxharrisrt.hpp        | 1297 ++--
 src/soplex/spxhybridpr.hpp        |  162 +-
 src/soplex/spxleastsqsc.hpp       |  676 +--
 src/soplex/spxlpbase.h            | 4622 +++++++-------
 src/soplex/spxlpbase_rational.hpp | 3661 ++++++-----
 src/soplex/spxlpbase_real.hpp     | 4605 +++++++-------
 src/soplex/spxmainsm.hpp          | 8947 +++++++++++++--------------
 src/soplex/spxparmultpr.hpp       |  308 +-
 src/soplex/spxquality.hpp         |  213 +-
 src/soplex/spxscaler.hpp          | 1128 ++--
 src/soplex/spxshift.hpp           | 1358 ++---
 src/soplex/spxsolve.hpp           | 4058 ++++++-------
 src/soplex/spxsolver.h            | 4325 +++++++------
 src/soplex/spxsolver.hpp          | 4024 ++++++------
 src/soplex/spxstarter.hpp         |   12 +-
 src/soplex/spxsteeppr.hpp         | 1810 +++---
 src/soplex/spxsumst.hpp           |  126 +-
 src/soplex/spxvecs.hpp            |  860 ++-
 src/soplex/spxvectorst.hpp        |  159 +-
 src/soplex/spxweightpr.hpp        |  608 +-
 src/soplex/spxweightst.hpp        | 1042 ++--
 src/soplex/spxwritestate.hpp      |  157 +-
 src/soplex/ssvectorbase.h         | 1409 ++---
 src/soplex/statistics.hpp         |  520 +-
 src/soplex/svectorbase.h          | 1320 ++--
 src/soplex/svsetbase.h            | 1783 +++---
 src/soplex/testsoplex.hpp         |  426 +-
 src/soplex/unitvectorbase.h       |  158 +-
 src/soplex/updatevector.h         |  214 +-
 src/soplex/updatevector.hpp       |   43 +-
 src/soplex/validation.hpp         |  249 +-
 src/soplex/vectorbase.h           |  870 ++-
 67 files changed, 54057 insertions(+), 61312 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index c1e0117..25fe2fe 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -9,7 +9,7 @@ project(SOPLEX
   LANGUAGES CXX)
 
 if(CMAKE_CXX_COMPILER_ID MATCHES "GNU")
-   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-psabi")
+   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-psabi -Werror")
    # require at least gcc 5
    if (CMAKE_CXX_COMPILER_VERSION VERSION_LESS 5)
      message(WARNING "GCC version not supported, should be at least 5!")
diff --git a/src/soplex/changesoplex.hpp b/src/soplex/changesoplex.hpp
index 15384e5..38eb812 100644
--- a/src/soplex/changesoplex.hpp
+++ b/src/soplex/changesoplex.hpp
@@ -21,876 +21,781 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <assert.h>
 #include <iostream>
 
+#include "soplex/exceptions.h"
 #include "soplex/spxdefines.h"
-#include "soplex/spxsolver.h"
 #include "soplex/spxpricer.h"
 #include "soplex/spxratiotester.h"
-#include "soplex/exceptions.h"
+#include "soplex/spxsolver.h"
 
-namespace soplex
-{
+namespace soplex {
 
-template <class R>
-void SPxSolverBase<R>::addedRows(int n)
-{
+template <class R> void SPxSolverBase<R>::addedRows(int n) {
 
-   if(n > 0)
-   {
-      SPxLPBase<R>::addedRows(n);
+  if (n > 0) {
+    SPxLPBase<R>::addedRows(n);
 
-      unInit();
-      reDim();
+    unInit();
+    reDim();
 
-      if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-         SPxBasisBase<R>::addedRows(n);
-   }
+    if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
+      SPxBasisBase<R>::addedRows(n);
+  }
 
-   /* we must not assert consistency here, since addedCols() might be still necessary to obtain a consistent basis */
+  /* we must not assert consistency here, since addedCols() might be still
+   * necessary to obtain a consistent basis */
 }
 
-template <class R>
-void SPxSolverBase<R>::addedCols(int n)
-{
+template <class R> void SPxSolverBase<R>::addedCols(int n) {
 
-   if(n > 0)
-   {
-      SPxLPBase<R>::addedCols(n);
+  if (n > 0) {
+    SPxLPBase<R>::addedCols(n);
 
-      unInit();
-      reDim();
+    unInit();
+    reDim();
 
-      if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-         SPxBasisBase<R>::addedCols(n);
-   }
+    if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
+      SPxBasisBase<R>::addedCols(n);
+  }
 
-   /* we must not assert consistency here, since addedRows() might be still necessary to obtain a consistent basis */
+  /* we must not assert consistency here, since addedRows() might be still
+   * necessary to obtain a consistent basis */
 }
 
-template <class R>
-void SPxSolverBase<R>::doRemoveRow(int i)
-{
+template <class R> void SPxSolverBase<R>::doRemoveRow(int i) {
 
-   SPxLPBase<R>::doRemoveRow(i);
+  SPxLPBase<R>::doRemoveRow(i);
 
-   unInit();
+  unInit();
 
-   if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-   {
-      this->removedRow(i);
+  if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM) {
+    this->removedRow(i);
 
-      switch(SPxBasisBase<R>::status())
-      {
-      case SPxBasisBase<R>::DUAL:
-      case SPxBasisBase<R>::INFEASIBLE:
-         setBasisStatus(SPxBasisBase<R>::REGULAR);
-         break;
+    switch (SPxBasisBase<R>::status()) {
+    case SPxBasisBase<R>::DUAL:
+    case SPxBasisBase<R>::INFEASIBLE:
+      setBasisStatus(SPxBasisBase<R>::REGULAR);
+      break;
 
-      case SPxBasisBase<R>::OPTIMAL:
-         setBasisStatus(SPxBasisBase<R>::PRIMAL);
-         break;
+    case SPxBasisBase<R>::OPTIMAL:
+      setBasisStatus(SPxBasisBase<R>::PRIMAL);
+      break;
 
-      default:
-         break;
-      }
-   }
+    default:
+      break;
+    }
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::doRemoveRows(int perm[])
-{
+template <class R> void SPxSolverBase<R>::doRemoveRows(int perm[]) {
 
-   SPxLPBase<R>::doRemoveRows(perm);
+  SPxLPBase<R>::doRemoveRows(perm);
 
-   unInit();
+  unInit();
 
-   if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-   {
-      this->removedRows(perm);
+  if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM) {
+    this->removedRows(perm);
 
-      switch(SPxBasisBase<R>::status())
-      {
-      case SPxBasisBase<R>::DUAL:
-      case SPxBasisBase<R>::INFEASIBLE:
-         setBasisStatus(SPxBasisBase<R>::REGULAR);
-         break;
+    switch (SPxBasisBase<R>::status()) {
+    case SPxBasisBase<R>::DUAL:
+    case SPxBasisBase<R>::INFEASIBLE:
+      setBasisStatus(SPxBasisBase<R>::REGULAR);
+      break;
 
-      case SPxBasisBase<R>::OPTIMAL:
-         setBasisStatus(SPxBasisBase<R>::PRIMAL);
-         break;
+    case SPxBasisBase<R>::OPTIMAL:
+      setBasisStatus(SPxBasisBase<R>::PRIMAL);
+      break;
 
-      default:
-         break;
-      }
-   }
+    default:
+      break;
+    }
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::doRemoveCol(int i)
-{
-   forceRecompNonbasicValue();
+template <class R> void SPxSolverBase<R>::doRemoveCol(int i) {
+  forceRecompNonbasicValue();
 
-   SPxLPBase<R>::doRemoveCol(i);
+  SPxLPBase<R>::doRemoveCol(i);
 
-   unInit();
+  unInit();
 
-   if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-   {
-      this->removedCol(i);
+  if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM) {
+    this->removedCol(i);
 
-      switch(SPxBasisBase<R>::status())
-      {
-      case SPxBasisBase<R>::PRIMAL:
-      case SPxBasisBase<R>::UNBOUNDED:
-         setBasisStatus(SPxBasisBase<R>::REGULAR);
-         break;
+    switch (SPxBasisBase<R>::status()) {
+    case SPxBasisBase<R>::PRIMAL:
+    case SPxBasisBase<R>::UNBOUNDED:
+      setBasisStatus(SPxBasisBase<R>::REGULAR);
+      break;
 
-      case SPxBasisBase<R>::OPTIMAL:
-         setBasisStatus(SPxBasisBase<R>::DUAL);
-         break;
+    case SPxBasisBase<R>::OPTIMAL:
+      setBasisStatus(SPxBasisBase<R>::DUAL);
+      break;
 
-      default:
-         break;
-      }
-   }
+    default:
+      break;
+    }
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::doRemoveCols(int perm[])
-{
-   forceRecompNonbasicValue();
+template <class R> void SPxSolverBase<R>::doRemoveCols(int perm[]) {
+  forceRecompNonbasicValue();
 
-   SPxLPBase<R>::doRemoveCols(perm);
+  SPxLPBase<R>::doRemoveCols(perm);
 
-   unInit();
+  unInit();
 
-   if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-   {
-      this->removedCols(perm);
+  if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM) {
+    this->removedCols(perm);
 
-      switch(SPxBasisBase<R>::status())
-      {
-      case SPxBasisBase<R>::PRIMAL:
-      case SPxBasisBase<R>::UNBOUNDED:
-         setBasisStatus(SPxBasisBase<R>::REGULAR);
-         break;
+    switch (SPxBasisBase<R>::status()) {
+    case SPxBasisBase<R>::PRIMAL:
+    case SPxBasisBase<R>::UNBOUNDED:
+      setBasisStatus(SPxBasisBase<R>::REGULAR);
+      break;
 
-      case SPxBasisBase<R>::OPTIMAL:
-         setBasisStatus(SPxBasisBase<R>::DUAL);
-         break;
+    case SPxBasisBase<R>::OPTIMAL:
+      setBasisStatus(SPxBasisBase<R>::DUAL);
+      break;
 
-      default:
-         break;
-      }
-   }
+    default:
+      break;
+    }
+  }
 }
 
 template <class R>
-void SPxSolverBase<R>::changeObj(const VectorBase<R>& newObj, bool scale)
-{
-   forceRecompNonbasicValue();
+void SPxSolverBase<R>::changeObj(const VectorBase<R> &newObj, bool scale) {
+  forceRecompNonbasicValue();
 
-   SPxLPBase<R>::changeObj(newObj, scale);
+  SPxLPBase<R>::changeObj(newObj, scale);
 
-   /**@todo Factorization remains valid, we do not need a reDim()
-    *       pricing vectors should be recomputed.
-    */
-   unInit();
+  /**@todo Factorization remains valid, we do not need a reDim()
+   *       pricing vectors should be recomputed.
+   */
+  unInit();
 }
 
 template <class R>
-void SPxSolverBase<R>::changeObj(int i, const R& newVal, bool scale)
-{
-   forceRecompNonbasicValue();
-
-   SPxLPBase<R>::changeObj(i, newVal, scale);
+void SPxSolverBase<R>::changeObj(int i, const R &newVal, bool scale) {
+  forceRecompNonbasicValue();
 
+  SPxLPBase<R>::changeObj(i, newVal, scale);
 
-   /**@todo Factorization remains valid, we do not need a reDim()
-    *       pricing vectors should be recomputed.
-    */
-   unInit();
+  /**@todo Factorization remains valid, we do not need a reDim()
+   *       pricing vectors should be recomputed.
+   */
+  unInit();
 }
 
 template <class R>
-void SPxSolverBase<R>::changeMaxObj(const VectorBase<R>& newObj, bool scale)
-{
-   forceRecompNonbasicValue();
+void SPxSolverBase<R>::changeMaxObj(const VectorBase<R> &newObj, bool scale) {
+  forceRecompNonbasicValue();
 
-   SPxLPBase<R>::changeMaxObj(newObj, scale);
+  SPxLPBase<R>::changeMaxObj(newObj, scale);
 
-   /**@todo Factorization remains valid, we do not need a reDim()
-    *       pricing vectors should be recomputed.
-    */
-   unInit();
+  /**@todo Factorization remains valid, we do not need a reDim()
+   *       pricing vectors should be recomputed.
+   */
+  unInit();
 }
 
 template <class R>
-void SPxSolverBase<R>::changeMaxObj(int i, const R& newVal, bool scale)
-{
-   forceRecompNonbasicValue();
+void SPxSolverBase<R>::changeMaxObj(int i, const R &newVal, bool scale) {
+  forceRecompNonbasicValue();
 
-   SPxLPBase<R>::changeMaxObj(i, newVal, scale);
+  SPxLPBase<R>::changeMaxObj(i, newVal, scale);
 
-   /**@todo Factorization remains valid, we do not need a reDim()
-    *       pricing vectors should be recomputed.
-    */
-   unInit();
+  /**@todo Factorization remains valid, we do not need a reDim()
+   *       pricing vectors should be recomputed.
+   */
+  unInit();
 }
 
 template <class R>
-void SPxSolverBase<R>::changeRowObj(const VectorBase<R>& newObj, bool scale)
-{
-   forceRecompNonbasicValue();
+void SPxSolverBase<R>::changeRowObj(const VectorBase<R> &newObj, bool scale) {
+  forceRecompNonbasicValue();
 
-   SPxLPBase<R>::changeRowObj(newObj, scale);
+  SPxLPBase<R>::changeRowObj(newObj, scale);
 
-   /**@todo Factorization remains valid, we do not need a reDim()
-    *       pricing vectors should be recomputed.
-    */
-   unInit();
+  /**@todo Factorization remains valid, we do not need a reDim()
+   *       pricing vectors should be recomputed.
+   */
+  unInit();
 }
 
 template <class R>
-void SPxSolverBase<R>::changeRowObj(int i, const R& newVal, bool scale)
-{
-   forceRecompNonbasicValue();
+void SPxSolverBase<R>::changeRowObj(int i, const R &newVal, bool scale) {
+  forceRecompNonbasicValue();
 
-   SPxLPBase<R>::changeRowObj(i, newVal, scale);
+  SPxLPBase<R>::changeRowObj(i, newVal, scale);
 
-   /**@todo Factorization remains valid, we do not need a reDim()
-    *       pricing vectors should be recomputed.
-    */
-   unInit();
+  /**@todo Factorization remains valid, we do not need a reDim()
+   *       pricing vectors should be recomputed.
+   */
+  unInit();
 }
 
 template <class R>
-void SPxSolverBase<R>::changeLowerStatus(int i, R newLower, R oldLower)
-{
-   typename SPxBasisBase<R>::Desc::Status& stat      = this->desc().colStatus(i);
-   R                    currUpper = this->upper(i);
-   R                    objChange = 0.0;
-
-   MSG_DEBUG(std::cout << "DCHANG01 changeLowerStatus(): col " << i
-             << "[" << newLower << ":" << currUpper << "] " << stat;)
-
-   switch(stat)
-   {
-   case SPxBasisBase<R>::Desc::P_ON_LOWER:
-      if(newLower <= R(-infinity))
-      {
-         if(currUpper >= R(infinity))
-         {
-            stat = SPxBasisBase<R>::Desc::P_FREE;
-
-            if(m_nonbasicValueUpToDate && rep() == COLUMN)
-               objChange = -theLCbound[i] * oldLower;
-         }
-         else
-         {
-            stat = SPxBasisBase<R>::Desc::P_ON_UPPER;
-
-            if(m_nonbasicValueUpToDate && rep() == COLUMN)
-               objChange = (theUCbound[i] * currUpper) - (theLCbound[i] * oldLower);
-         }
-      }
-      else if(EQ(newLower, currUpper))
-      {
-         stat = SPxBasisBase<R>::Desc::P_FIXED;
+void SPxSolverBase<R>::changeLowerStatus(int i, R newLower, R oldLower) {
+  typename SPxBasisBase<R>::Desc::Status &stat = this->desc().colStatus(i);
+  R currUpper = this->upper(i);
+  R objChange = 0.0;
+
+  MSG_DEBUG(std::cout << "DCHANG01 changeLowerStatus(): col " << i << "["
+                      << newLower << ":" << currUpper << "] " << stat;)
 
-         if(m_nonbasicValueUpToDate && rep() == COLUMN)
-            objChange = this->maxObj(i) * (newLower - oldLower);
+  switch (stat) {
+  case SPxBasisBase<R>::Desc::P_ON_LOWER:
+    if (newLower <= R(-infinity)) {
+      if (currUpper >= R(infinity)) {
+        stat = SPxBasisBase<R>::Desc::P_FREE;
+
+        if (m_nonbasicValueUpToDate && rep() == COLUMN)
+          objChange = -theLCbound[i] * oldLower;
+      } else {
+        stat = SPxBasisBase<R>::Desc::P_ON_UPPER;
+
+        if (m_nonbasicValueUpToDate && rep() == COLUMN)
+          objChange = (theUCbound[i] * currUpper) - (theLCbound[i] * oldLower);
       }
-      else if(m_nonbasicValueUpToDate && rep() == COLUMN)
-         objChange = theLCbound[i] * (newLower - oldLower);
+    } else if (EQ(newLower, currUpper)) {
+      stat = SPxBasisBase<R>::Desc::P_FIXED;
 
-      break;
+      if (m_nonbasicValueUpToDate && rep() == COLUMN)
+        objChange = this->maxObj(i) * (newLower - oldLower);
+    } else if (m_nonbasicValueUpToDate && rep() == COLUMN)
+      objChange = theLCbound[i] * (newLower - oldLower);
 
-   case SPxBasisBase<R>::Desc::P_ON_UPPER:
-      if(EQ(newLower, currUpper))
-         stat = SPxBasisBase<R>::Desc::P_FIXED;
+    break;
 
-      break;
+  case SPxBasisBase<R>::Desc::P_ON_UPPER:
+    if (EQ(newLower, currUpper))
+      stat = SPxBasisBase<R>::Desc::P_FIXED;
 
-   case SPxBasisBase<R>::Desc::P_FREE:
-      if(newLower > R(-infinity))
-      {
-         stat = SPxBasisBase<R>::Desc::P_ON_LOWER;
+    break;
 
-         if(m_nonbasicValueUpToDate && rep() == COLUMN)
-            objChange = theLCbound[i] * newLower;
-      }
+  case SPxBasisBase<R>::Desc::P_FREE:
+    if (newLower > R(-infinity)) {
+      stat = SPxBasisBase<R>::Desc::P_ON_LOWER;
 
-      break;
+      if (m_nonbasicValueUpToDate && rep() == COLUMN)
+        objChange = theLCbound[i] * newLower;
+    }
 
-   case SPxBasisBase<R>::Desc::P_FIXED:
-      if(NE(newLower, currUpper))
-      {
-         stat = SPxBasisBase<R>::Desc::P_ON_UPPER;
+    break;
 
-         if(isInitialized())
-            theUCbound[i] = this->maxObj(i);
-      }
+  case SPxBasisBase<R>::Desc::P_FIXED:
+    if (NE(newLower, currUpper)) {
+      stat = SPxBasisBase<R>::Desc::P_ON_UPPER;
 
-      break;
+      if (isInitialized())
+        theUCbound[i] = this->maxObj(i);
+    }
 
-   case SPxBasisBase<R>::Desc::D_FREE:
-   case SPxBasisBase<R>::Desc::D_ON_UPPER:
-   case SPxBasisBase<R>::Desc::D_ON_LOWER:
-   case SPxBasisBase<R>::Desc::D_ON_BOTH:
-   case SPxBasisBase<R>::Desc::D_UNDEFINED:
-      if(rep() == ROW && theShift > 0.0)
-         forceRecompNonbasicValue();
+    break;
 
-      stat = this->dualColStatus(i);
-      break;
+  case SPxBasisBase<R>::Desc::D_FREE:
+  case SPxBasisBase<R>::Desc::D_ON_UPPER:
+  case SPxBasisBase<R>::Desc::D_ON_LOWER:
+  case SPxBasisBase<R>::Desc::D_ON_BOTH:
+  case SPxBasisBase<R>::Desc::D_UNDEFINED:
+    if (rep() == ROW && theShift > 0.0)
+      forceRecompNonbasicValue();
+
+    stat = this->dualColStatus(i);
+    break;
 
-   default:
-      throw SPxInternalCodeException("XCHANG01 This should never happen.");
-   }
+  default:
+    throw SPxInternalCodeException("XCHANG01 This should never happen.");
+  }
 
-   MSG_DEBUG(std::cout << " -> " << stat << std::endl;)
+  MSG_DEBUG(std::cout << " -> " << stat << std::endl;)
 
-   // we only need to update the nonbasic value in column representation (see nonbasicValue() for comparison/explanation)
-   if(rep() == COLUMN)
-      updateNonbasicValue(objChange);
+  // we only need to update the nonbasic value in column representation (see
+  // nonbasicValue() for comparison/explanation)
+  if (rep() == COLUMN)
+    updateNonbasicValue(objChange);
 }
 
 template <class R>
-void SPxSolverBase<R>::changeLower(const VectorBase<R>& newLower, bool scale)
-{
-   // we better recompute the nonbasic value when changing all lower bounds
-   forceRecompNonbasicValue();
+void SPxSolverBase<R>::changeLower(const VectorBase<R> &newLower, bool scale) {
+  // we better recompute the nonbasic value when changing all lower bounds
+  forceRecompNonbasicValue();
 
-   SPxLPBase<R>::changeLower(newLower, scale);
+  SPxLPBase<R>::changeLower(newLower, scale);
 
-   if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-   {
-      for(int i = 0; i < newLower.dim(); ++i)
-         changeLowerStatus(i, this->lower(i));
+  if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM) {
+    for (int i = 0; i < newLower.dim(); ++i)
+      changeLowerStatus(i, this->lower(i));
 
-      unInit();
-   }
+    unInit();
+  }
 }
 
 template <class R>
-void SPxSolverBase<R>::changeLower(int i, const R& newLower, bool scale)
-{
-   if(newLower != (scale ? this->lowerUnscaled(i) : this->lower(i)))
-   {
-      forceRecompNonbasicValue();
+void SPxSolverBase<R>::changeLower(int i, const R &newLower, bool scale) {
+  if (newLower != (scale ? this->lowerUnscaled(i) : this->lower(i))) {
+    forceRecompNonbasicValue();
 
-      R oldLower = this->lower(i);
-      // This has to be done before calling changeLowerStatus() because that is calling
-      // basis.dualColStatus() which calls lower() and needs the changed value.
-      SPxLPBase<R>::changeLower(i, newLower, scale);
+    R oldLower = this->lower(i);
+    // This has to be done before calling changeLowerStatus() because that is
+    // calling basis.dualColStatus() which calls lower() and needs the changed
+    // value.
+    SPxLPBase<R>::changeLower(i, newLower, scale);
 
-      if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-      {
-         changeLowerStatus(i, this->lower(i), oldLower);
-         unInit();
-      }
-   }
+    if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM) {
+      changeLowerStatus(i, this->lower(i), oldLower);
+      unInit();
+    }
+  }
 }
 
 template <class R>
-void SPxSolverBase<R>::changeUpperStatus(int i, R newUpper, R oldUpper)
-{
-   typename SPxBasisBase<R>::Desc::Status& stat      = this->desc().colStatus(i);
-   R                    currLower = this->lower(i);
-   R                    objChange = 0.0;
+void SPxSolverBase<R>::changeUpperStatus(int i, R newUpper, R oldUpper) {
+  typename SPxBasisBase<R>::Desc::Status &stat = this->desc().colStatus(i);
+  R currLower = this->lower(i);
+  R objChange = 0.0;
 
-   MSG_DEBUG(std::cout << "DCHANG02 changeUpperStatus(): col " << i
-             << "[" << currLower << ":" << newUpper << "] " << stat;)
+  MSG_DEBUG(std::cout << "DCHANG02 changeUpperStatus(): col " << i << "["
+                      << currLower << ":" << newUpper << "] " << stat;)
 
-   switch(stat)
-   {
-   case SPxBasisBase<R>::Desc::P_ON_LOWER:
-      if(newUpper == currLower)
-         stat = SPxBasisBase<R>::Desc::P_FIXED;
+  switch (stat) {
+  case SPxBasisBase<R>::Desc::P_ON_LOWER:
+    if (newUpper == currLower)
+      stat = SPxBasisBase<R>::Desc::P_FIXED;
 
-      break;
+    break;
 
-   case SPxBasisBase<R>::Desc::P_ON_UPPER:
-      if(newUpper >= R(infinity))
-      {
-         if(currLower <= R(-infinity))
-         {
-            stat = SPxBasisBase<R>::Desc::P_FREE;
-
-            if(m_nonbasicValueUpToDate && rep() == COLUMN)
-               objChange = -theUCbound[i] * oldUpper;
-         }
-         else
-         {
-            stat = SPxBasisBase<R>::Desc::P_ON_LOWER;
-
-            if(m_nonbasicValueUpToDate && rep() == COLUMN)
-               objChange = (theLCbound[i] * currLower) - (theUCbound[i] * oldUpper);
-         }
-      }
-      else if(EQ(newUpper, currLower))
-      {
-         stat = SPxBasisBase<R>::Desc::P_FIXED;
+  case SPxBasisBase<R>::Desc::P_ON_UPPER:
+    if (newUpper >= R(infinity)) {
+      if (currLower <= R(-infinity)) {
+        stat = SPxBasisBase<R>::Desc::P_FREE;
+
+        if (m_nonbasicValueUpToDate && rep() == COLUMN)
+          objChange = -theUCbound[i] * oldUpper;
+      } else {
+        stat = SPxBasisBase<R>::Desc::P_ON_LOWER;
 
-         if(m_nonbasicValueUpToDate && rep() == COLUMN)
-            objChange = this->maxObj(i) * (newUpper - oldUpper);
+        if (m_nonbasicValueUpToDate && rep() == COLUMN)
+          objChange = (theLCbound[i] * currLower) - (theUCbound[i] * oldUpper);
       }
-      else if(m_nonbasicValueUpToDate && rep() == COLUMN)
-         objChange = theUCbound[i] * (newUpper - oldUpper);
+    } else if (EQ(newUpper, currLower)) {
+      stat = SPxBasisBase<R>::Desc::P_FIXED;
 
-      break;
+      if (m_nonbasicValueUpToDate && rep() == COLUMN)
+        objChange = this->maxObj(i) * (newUpper - oldUpper);
+    } else if (m_nonbasicValueUpToDate && rep() == COLUMN)
+      objChange = theUCbound[i] * (newUpper - oldUpper);
 
-   case SPxBasisBase<R>::Desc::P_FREE:
-      if(newUpper < R(infinity))
-      {
-         stat = SPxBasisBase<R>::Desc::P_ON_UPPER;
+    break;
 
-         if(m_nonbasicValueUpToDate && rep() == COLUMN)
-            objChange = theUCbound[i] * newUpper;
-      }
+  case SPxBasisBase<R>::Desc::P_FREE:
+    if (newUpper < R(infinity)) {
+      stat = SPxBasisBase<R>::Desc::P_ON_UPPER;
 
-      break;
+      if (m_nonbasicValueUpToDate && rep() == COLUMN)
+        objChange = theUCbound[i] * newUpper;
+    }
 
-   case SPxBasisBase<R>::Desc::P_FIXED:
-      if(NE(newUpper, currLower))
-      {
-         stat = SPxBasisBase<R>::Desc::P_ON_LOWER;
+    break;
 
-         if(isInitialized())
-            theLCbound[i] = this->maxObj(i);
-      }
+  case SPxBasisBase<R>::Desc::P_FIXED:
+    if (NE(newUpper, currLower)) {
+      stat = SPxBasisBase<R>::Desc::P_ON_LOWER;
 
-      break;
+      if (isInitialized())
+        theLCbound[i] = this->maxObj(i);
+    }
 
-   case SPxBasisBase<R>::Desc::D_FREE:
-   case SPxBasisBase<R>::Desc::D_ON_UPPER:
-   case SPxBasisBase<R>::Desc::D_ON_LOWER:
-   case SPxBasisBase<R>::Desc::D_ON_BOTH:
-   case SPxBasisBase<R>::Desc::D_UNDEFINED:
-      if(rep() == ROW && theShift > 0.0)
-         forceRecompNonbasicValue();
+    break;
 
-      stat = this->dualColStatus(i);
-      break;
+  case SPxBasisBase<R>::Desc::D_FREE:
+  case SPxBasisBase<R>::Desc::D_ON_UPPER:
+  case SPxBasisBase<R>::Desc::D_ON_LOWER:
+  case SPxBasisBase<R>::Desc::D_ON_BOTH:
+  case SPxBasisBase<R>::Desc::D_UNDEFINED:
+    if (rep() == ROW && theShift > 0.0)
+      forceRecompNonbasicValue();
+
+    stat = this->dualColStatus(i);
+    break;
 
-   default:
-      throw SPxInternalCodeException("XCHANG02 This should never happen.");
-   }
+  default:
+    throw SPxInternalCodeException("XCHANG02 This should never happen.");
+  }
 
-   MSG_DEBUG(std::cout << " -> " << stat << std::endl;);
+  MSG_DEBUG(std::cout << " -> " << stat << std::endl;);
 
-   // we only need to update the nonbasic value in column representation (see nonbasicValue() for comparison/explanation)
-   if(rep() == COLUMN)
-      updateNonbasicValue(objChange);
+  // we only need to update the nonbasic value in column representation (see
+  // nonbasicValue() for comparison/explanation)
+  if (rep() == COLUMN)
+    updateNonbasicValue(objChange);
 }
 
 template <class R>
-void SPxSolverBase<R>::changeUpper(const VectorBase<R>& newUpper, bool scale)
-{
-   // we better recompute the nonbasic value when changing all upper bounds
-   forceRecompNonbasicValue();
+void SPxSolverBase<R>::changeUpper(const VectorBase<R> &newUpper, bool scale) {
+  // we better recompute the nonbasic value when changing all upper bounds
+  forceRecompNonbasicValue();
 
-   SPxLPBase<R>::changeUpper(newUpper, scale);
+  SPxLPBase<R>::changeUpper(newUpper, scale);
 
-   if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-   {
-      for(int i = 0; i < newUpper.dim(); ++i)
-         changeUpperStatus(i, this->upper(i));
+  if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM) {
+    for (int i = 0; i < newUpper.dim(); ++i)
+      changeUpperStatus(i, this->upper(i));
 
-      unInit();
-   }
+    unInit();
+  }
 }
 
 template <class R>
-void SPxSolverBase<R>::changeUpper(int i, const R& newUpper, bool scale)
-{
-   if(newUpper != (scale ? this->upperUnscaled(i) : this->upper(i)))
-   {
-      forceRecompNonbasicValue();
+void SPxSolverBase<R>::changeUpper(int i, const R &newUpper, bool scale) {
+  if (newUpper != (scale ? this->upperUnscaled(i) : this->upper(i))) {
+    forceRecompNonbasicValue();
 
-      R oldUpper = this->upper(i);
-      SPxLPBase<R>::changeUpper(i, newUpper, scale);
+    R oldUpper = this->upper(i);
+    SPxLPBase<R>::changeUpper(i, newUpper, scale);
 
-      if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-      {
-         changeUpperStatus(i, this->upper(i), oldUpper);
-         unInit();
-      }
-   }
+    if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM) {
+      changeUpperStatus(i, this->upper(i), oldUpper);
+      unInit();
+    }
+  }
 }
 
 template <class R>
-void SPxSolverBase<R>::changeBounds(const VectorBase<R>& newLower, const VectorBase<R>& newUpper,
-                                    bool scale)
-{
-   changeLower(newLower, scale);
-   changeUpper(newUpper, scale);
+void SPxSolverBase<R>::changeBounds(const VectorBase<R> &newLower,
+                                    const VectorBase<R> &newUpper, bool scale) {
+  changeLower(newLower, scale);
+  changeUpper(newUpper, scale);
 }
 
 template <class R>
-void SPxSolverBase<R>::changeBounds(int i, const R& newLower, const R& newUpper, bool scale)
-{
-   changeLower(i, newLower, scale);
-
-   if(EQ(newLower, newUpper))
-      changeUpper(i, newLower, scale);
-   else
-      changeUpper(i, newUpper, scale);
+void SPxSolverBase<R>::changeBounds(int i, const R &newLower, const R &newUpper,
+                                    bool scale) {
+  changeLower(i, newLower, scale);
 
+  if (EQ(newLower, newUpper))
+    changeUpper(i, newLower, scale);
+  else
+    changeUpper(i, newUpper, scale);
 }
 
 template <class R>
-void SPxSolverBase<R>::changeLhsStatus(int i, R newLhs, R oldLhs)
-{
-   typename SPxBasisBase<R>::Desc::Status& stat      = this->desc().rowStatus(i);
-   R                    currRhs   = this->rhs(i);
-   R                    objChange = 0.0;
-
-   MSG_DEBUG(std::cout << "DCHANG03 changeLhsStatus()  : row " << i
-             << ": " << stat;)
-
-   switch(stat)
-   {
-   case SPxBasisBase<R>::Desc::P_ON_LOWER:
-      if(newLhs <= R(-infinity))
-      {
-         if(currRhs >= R(infinity))
-         {
-            stat = SPxBasisBase<R>::Desc::P_FREE;
-
-            if(m_nonbasicValueUpToDate && rep() == COLUMN)
-               objChange = -theURbound[i] * oldLhs;
-         }
-         else
-         {
-            stat = SPxBasisBase<R>::Desc::P_ON_UPPER;
-
-            if(m_nonbasicValueUpToDate && rep() == COLUMN)
-               objChange = (theLRbound[i] * currRhs) - (theURbound[i] * oldLhs);
-         }
-      }
-      else if(EQ(newLhs, currRhs))
-      {
-         stat = SPxBasisBase<R>::Desc::P_FIXED;
+void SPxSolverBase<R>::changeLhsStatus(int i, R newLhs, R oldLhs) {
+  typename SPxBasisBase<R>::Desc::Status &stat = this->desc().rowStatus(i);
+  R currRhs = this->rhs(i);
+  R objChange = 0.0;
+
+  MSG_DEBUG(std::cout << "DCHANG03 changeLhsStatus()  : row " << i << ": "
+                      << stat;)
 
-         if(m_nonbasicValueUpToDate && rep() == COLUMN)
-            objChange = this->maxRowObj(i) * (newLhs - oldLhs);
+  switch (stat) {
+  case SPxBasisBase<R>::Desc::P_ON_LOWER:
+    if (newLhs <= R(-infinity)) {
+      if (currRhs >= R(infinity)) {
+        stat = SPxBasisBase<R>::Desc::P_FREE;
+
+        if (m_nonbasicValueUpToDate && rep() == COLUMN)
+          objChange = -theURbound[i] * oldLhs;
+      } else {
+        stat = SPxBasisBase<R>::Desc::P_ON_UPPER;
+
+        if (m_nonbasicValueUpToDate && rep() == COLUMN)
+          objChange = (theLRbound[i] * currRhs) - (theURbound[i] * oldLhs);
       }
-      else if(m_nonbasicValueUpToDate && rep() == COLUMN)
-         objChange = theURbound[i] * (newLhs - oldLhs);
+    } else if (EQ(newLhs, currRhs)) {
+      stat = SPxBasisBase<R>::Desc::P_FIXED;
 
-      break;
+      if (m_nonbasicValueUpToDate && rep() == COLUMN)
+        objChange = this->maxRowObj(i) * (newLhs - oldLhs);
+    } else if (m_nonbasicValueUpToDate && rep() == COLUMN)
+      objChange = theURbound[i] * (newLhs - oldLhs);
 
-   case SPxBasisBase<R>::Desc::P_ON_UPPER:
-      if(EQ(newLhs, currRhs))
-         stat = SPxBasisBase<R>::Desc::P_FIXED;
+    break;
 
-      break;
+  case SPxBasisBase<R>::Desc::P_ON_UPPER:
+    if (EQ(newLhs, currRhs))
+      stat = SPxBasisBase<R>::Desc::P_FIXED;
 
-   case SPxBasisBase<R>::Desc::P_FREE:
-      if(newLhs > R(-infinity))
-      {
-         stat = SPxBasisBase<R>::Desc::P_ON_LOWER;
+    break;
 
-         if(m_nonbasicValueUpToDate && rep() == COLUMN)
-            objChange = theURbound[i] * newLhs;
-      }
+  case SPxBasisBase<R>::Desc::P_FREE:
+    if (newLhs > R(-infinity)) {
+      stat = SPxBasisBase<R>::Desc::P_ON_LOWER;
 
-      break;
+      if (m_nonbasicValueUpToDate && rep() == COLUMN)
+        objChange = theURbound[i] * newLhs;
+    }
 
-   case SPxBasisBase<R>::Desc::P_FIXED:
-      if(NE(newLhs, currRhs))
-      {
-         stat = SPxBasisBase<R>::Desc::P_ON_UPPER;
+    break;
 
-         if(isInitialized())
-            theLRbound[i] = this->maxRowObj(i);
-      }
+  case SPxBasisBase<R>::Desc::P_FIXED:
+    if (NE(newLhs, currRhs)) {
+      stat = SPxBasisBase<R>::Desc::P_ON_UPPER;
 
-      break;
+      if (isInitialized())
+        theLRbound[i] = this->maxRowObj(i);
+    }
 
-   case SPxBasisBase<R>::Desc::D_FREE:
-   case SPxBasisBase<R>::Desc::D_ON_UPPER:
-   case SPxBasisBase<R>::Desc::D_ON_LOWER:
-   case SPxBasisBase<R>::Desc::D_ON_BOTH:
-   case SPxBasisBase<R>::Desc::D_UNDEFINED:
-      if(rep() == ROW && theShift > 0.0)
-         forceRecompNonbasicValue();
+    break;
 
-      stat = this->dualRowStatus(i);
-      break;
+  case SPxBasisBase<R>::Desc::D_FREE:
+  case SPxBasisBase<R>::Desc::D_ON_UPPER:
+  case SPxBasisBase<R>::Desc::D_ON_LOWER:
+  case SPxBasisBase<R>::Desc::D_ON_BOTH:
+  case SPxBasisBase<R>::Desc::D_UNDEFINED:
+    if (rep() == ROW && theShift > 0.0)
+      forceRecompNonbasicValue();
 
-   default:
-      throw SPxInternalCodeException("XCHANG03 This should never happen.");
-   }
+    stat = this->dualRowStatus(i);
+    break;
 
-   MSG_DEBUG(std::cout << " -> " << stat << std::endl;)
+  default:
+    throw SPxInternalCodeException("XCHANG03 This should never happen.");
+  }
 
-   // we only need to update the nonbasic value in column representation (see nonbasicValue() for comparison/explanation)
-   if(rep() == COLUMN)
-      updateNonbasicValue(objChange);
+  MSG_DEBUG(std::cout << " -> " << stat << std::endl;)
+
+  // we only need to update the nonbasic value in column representation (see
+  // nonbasicValue() for comparison/explanation)
+  if (rep() == COLUMN)
+    updateNonbasicValue(objChange);
 }
 
 template <class R>
-void SPxSolverBase<R>::changeLhs(const VectorBase<R>& newLhs, bool scale)
-{
-   // we better recompute the nonbasic value when changing all lhs
-   forceRecompNonbasicValue();
+void SPxSolverBase<R>::changeLhs(const VectorBase<R> &newLhs, bool scale) {
+  // we better recompute the nonbasic value when changing all lhs
+  forceRecompNonbasicValue();
 
-   SPxLPBase<R>::changeLhs(newLhs, scale);
+  SPxLPBase<R>::changeLhs(newLhs, scale);
 
-   if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-   {
-      for(int i = 0; i < this->nRows(); ++i)
-         changeLhsStatus(i, this->lhs(i));
+  if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM) {
+    for (int i = 0; i < this->nRows(); ++i)
+      changeLhsStatus(i, this->lhs(i));
 
-      unInit();
-   }
+    unInit();
+  }
 }
 
 template <class R>
-void SPxSolverBase<R>::changeLhs(int i, const R& newLhs, bool scale)
-{
-   if(newLhs != (scale ? this->lhsUnscaled(i) : this->lhs(i)))
-   {
-      forceRecompNonbasicValue();
+void SPxSolverBase<R>::changeLhs(int i, const R &newLhs, bool scale) {
+  if (newLhs != (scale ? this->lhsUnscaled(i) : this->lhs(i))) {
+    forceRecompNonbasicValue();
 
-      R oldLhs = this->lhs(i);
-      SPxLPBase<R>::changeLhs(i, newLhs, scale);
+    R oldLhs = this->lhs(i);
+    SPxLPBase<R>::changeLhs(i, newLhs, scale);
 
-      if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-      {
-         changeLhsStatus(i, this->lhs(i), oldLhs);
-         unInit();
-      }
-   }
+    if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM) {
+      changeLhsStatus(i, this->lhs(i), oldLhs);
+      unInit();
+    }
+  }
 }
 
 template <class R>
-void SPxSolverBase<R>::changeRhsStatus(int i, R newRhs, R oldRhs)
-{
-   typename SPxBasisBase<R>::Desc::Status& stat      = this->desc().rowStatus(i);
-   R                    currLhs   = this->lhs(i);
-   R                    objChange = 0.0;
-
-   MSG_DEBUG(std::cout << "DCHANG04 changeRhsStatus()  : row " << i
-             << ": " << stat;)
-
-   switch(stat)
-   {
-   case SPxBasisBase<R>::Desc::P_ON_UPPER:
-      if(newRhs >= R(infinity))
-      {
-         if(currLhs <= R(-infinity))
-         {
-            stat = SPxBasisBase<R>::Desc::P_FREE;
-
-            if(m_nonbasicValueUpToDate && rep() == COLUMN)
-               objChange = -theLRbound[i] * oldRhs;
-         }
-         else
-         {
-            stat = SPxBasisBase<R>::Desc::P_ON_LOWER;
-
-            if(m_nonbasicValueUpToDate && rep() == COLUMN)
-               objChange = (theURbound[i] * currLhs) - (theLRbound[i] * oldRhs);
-         }
-      }
-      else if(EQ(newRhs, currLhs))
-      {
-         stat = SPxBasisBase<R>::Desc::P_FIXED;
+void SPxSolverBase<R>::changeRhsStatus(int i, R newRhs, R oldRhs) {
+  typename SPxBasisBase<R>::Desc::Status &stat = this->desc().rowStatus(i);
+  R currLhs = this->lhs(i);
+  R objChange = 0.0;
+
+  MSG_DEBUG(std::cout << "DCHANG04 changeRhsStatus()  : row " << i << ": "
+                      << stat;)
+
+  switch (stat) {
+  case SPxBasisBase<R>::Desc::P_ON_UPPER:
+    if (newRhs >= R(infinity)) {
+      if (currLhs <= R(-infinity)) {
+        stat = SPxBasisBase<R>::Desc::P_FREE;
+
+        if (m_nonbasicValueUpToDate && rep() == COLUMN)
+          objChange = -theLRbound[i] * oldRhs;
+      } else {
+        stat = SPxBasisBase<R>::Desc::P_ON_LOWER;
 
-         if(m_nonbasicValueUpToDate && rep() == COLUMN)
-            objChange = this->maxRowObj(i) * (newRhs - oldRhs);
+        if (m_nonbasicValueUpToDate && rep() == COLUMN)
+          objChange = (theURbound[i] * currLhs) - (theLRbound[i] * oldRhs);
       }
-      else if(m_nonbasicValueUpToDate && rep() == COLUMN)
-         objChange = theLRbound[i] * (newRhs - oldRhs);
+    } else if (EQ(newRhs, currLhs)) {
+      stat = SPxBasisBase<R>::Desc::P_FIXED;
 
-      break;
+      if (m_nonbasicValueUpToDate && rep() == COLUMN)
+        objChange = this->maxRowObj(i) * (newRhs - oldRhs);
+    } else if (m_nonbasicValueUpToDate && rep() == COLUMN)
+      objChange = theLRbound[i] * (newRhs - oldRhs);
 
-   case SPxBasisBase<R>::Desc::P_ON_LOWER:
-      if(EQ(newRhs, currLhs))
-         stat = SPxBasisBase<R>::Desc::P_FIXED;
+    break;
 
-      break;
+  case SPxBasisBase<R>::Desc::P_ON_LOWER:
+    if (EQ(newRhs, currLhs))
+      stat = SPxBasisBase<R>::Desc::P_FIXED;
 
-   case SPxBasisBase<R>::Desc::P_FREE:
-      if(newRhs < R(infinity))
-      {
-         stat = SPxBasisBase<R>::Desc::P_ON_UPPER;
+    break;
 
-         if(m_nonbasicValueUpToDate && rep() == COLUMN)
-            objChange = theLRbound[i] * newRhs;
-      }
+  case SPxBasisBase<R>::Desc::P_FREE:
+    if (newRhs < R(infinity)) {
+      stat = SPxBasisBase<R>::Desc::P_ON_UPPER;
 
-      break;
+      if (m_nonbasicValueUpToDate && rep() == COLUMN)
+        objChange = theLRbound[i] * newRhs;
+    }
 
-   case SPxBasisBase<R>::Desc::P_FIXED:
-      if(NE(newRhs, currLhs))
-      {
-         stat = SPxBasisBase<R>::Desc::P_ON_LOWER;
+    break;
 
-         if(isInitialized())
-            theURbound[i] = this->maxRowObj(i);
-      }
+  case SPxBasisBase<R>::Desc::P_FIXED:
+    if (NE(newRhs, currLhs)) {
+      stat = SPxBasisBase<R>::Desc::P_ON_LOWER;
 
-      break;
+      if (isInitialized())
+        theURbound[i] = this->maxRowObj(i);
+    }
 
-   case SPxBasisBase<R>::Desc::D_FREE:
-   case SPxBasisBase<R>::Desc::D_ON_UPPER:
-   case SPxBasisBase<R>::Desc::D_ON_LOWER:
-   case SPxBasisBase<R>::Desc::D_ON_BOTH:
-   case SPxBasisBase<R>::Desc::D_UNDEFINED:
-      if(rep() == ROW && theShift > 0.0)
-         forceRecompNonbasicValue();
+    break;
 
-      stat = this->dualRowStatus(i);
-      break;
+  case SPxBasisBase<R>::Desc::D_FREE:
+  case SPxBasisBase<R>::Desc::D_ON_UPPER:
+  case SPxBasisBase<R>::Desc::D_ON_LOWER:
+  case SPxBasisBase<R>::Desc::D_ON_BOTH:
+  case SPxBasisBase<R>::Desc::D_UNDEFINED:
+    if (rep() == ROW && theShift > 0.0)
+      forceRecompNonbasicValue();
 
-   default:
-      throw SPxInternalCodeException("XCHANG04 This should never happen.");
-   }
+    stat = this->dualRowStatus(i);
+    break;
 
-   MSG_DEBUG(std::cout << " -> " << stat << std::endl;)
+  default:
+    throw SPxInternalCodeException("XCHANG04 This should never happen.");
+  }
 
-   // we only need to update the nonbasic value in column representation (see nonbasicValue() for comparison/explanation)
-   if(rep() == COLUMN)
-      updateNonbasicValue(objChange);
-}
+  MSG_DEBUG(std::cout << " -> " << stat << std::endl;)
 
+  // we only need to update the nonbasic value in column representation (see
+  // nonbasicValue() for comparison/explanation)
+  if (rep() == COLUMN)
+    updateNonbasicValue(objChange);
+}
 
 template <class R>
-void SPxSolverBase<R>::changeRhs(const VectorBase<R>& newRhs, bool scale)
-{
-   // we better recompute the nonbasic value when changing all rhs
-   forceRecompNonbasicValue();
+void SPxSolverBase<R>::changeRhs(const VectorBase<R> &newRhs, bool scale) {
+  // we better recompute the nonbasic value when changing all rhs
+  forceRecompNonbasicValue();
 
-   SPxLPBase<R>::changeRhs(newRhs, scale);
+  SPxLPBase<R>::changeRhs(newRhs, scale);
 
-   if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-   {
-      for(int i = 0; i < this->nRows(); ++i)
-         changeRhsStatus(i, this->rhs(i));
+  if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM) {
+    for (int i = 0; i < this->nRows(); ++i)
+      changeRhsStatus(i, this->rhs(i));
 
-      unInit();
-   }
+    unInit();
+  }
 }
 
 template <class R>
-void SPxSolverBase<R>::changeRhs(int i, const R& newRhs, bool scale)
-{
-   if(newRhs != (scale ? this->rhsUnscaled(i) : this->rhs(i)))
-   {
-      forceRecompNonbasicValue();
+void SPxSolverBase<R>::changeRhs(int i, const R &newRhs, bool scale) {
+  if (newRhs != (scale ? this->rhsUnscaled(i) : this->rhs(i))) {
+    forceRecompNonbasicValue();
 
-      R oldRhs = this->rhs(i);
-      SPxLPBase<R>::changeRhs(i, newRhs, scale);
+    R oldRhs = this->rhs(i);
+    SPxLPBase<R>::changeRhs(i, newRhs, scale);
 
-      if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-      {
-         changeRhsStatus(i, this->rhs(i), oldRhs);
-         unInit();
-      }
-   }
+    if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM) {
+      changeRhsStatus(i, this->rhs(i), oldRhs);
+      unInit();
+    }
+  }
 }
 
 template <class R>
-void SPxSolverBase<R>::changeRange(const VectorBase<R>& newLhs, const VectorBase<R>& newRhs,
-                                   bool scale)
-{
-   // we better recompute the nonbasic value when changing all ranges
-   forceRecompNonbasicValue();
-
-   SPxLPBase<R>::changeLhs(newLhs, scale);
-   SPxLPBase<R>::changeRhs(newRhs, scale);
-
-   if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-   {
-      for(int i = this->nRows() - 1; i >= 0; --i)
-      {
-         changeLhsStatus(i, this->lhs(i));
-         changeRhsStatus(i, this->rhs(i));
-      }
+void SPxSolverBase<R>::changeRange(const VectorBase<R> &newLhs,
+                                   const VectorBase<R> &newRhs, bool scale) {
+  // we better recompute the nonbasic value when changing all ranges
+  forceRecompNonbasicValue();
 
-      unInit();
-   }
+  SPxLPBase<R>::changeLhs(newLhs, scale);
+  SPxLPBase<R>::changeRhs(newRhs, scale);
+
+  if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM) {
+    for (int i = this->nRows() - 1; i >= 0; --i) {
+      changeLhsStatus(i, this->lhs(i));
+      changeRhsStatus(i, this->rhs(i));
+    }
+
+    unInit();
+  }
 }
 
 template <class R>
-void SPxSolverBase<R>::changeRange(int i, const R& newLhs, const R& newRhs, bool scale)
-{
-   R oldLhs = this->lhs(i);
-   R oldRhs = this->rhs(i);
+void SPxSolverBase<R>::changeRange(int i, const R &newLhs, const R &newRhs,
+                                   bool scale) {
+  R oldLhs = this->lhs(i);
+  R oldRhs = this->rhs(i);
 
-   SPxLPBase<R>::changeLhs(i, newLhs, scale);
+  SPxLPBase<R>::changeLhs(i, newLhs, scale);
 
-   if(EQ(newLhs, newRhs))
-      SPxLPBase<R>::changeRhs(i, newLhs, scale);
-   else
-      SPxLPBase<R>::changeRhs(i, newRhs, scale);
+  if (EQ(newLhs, newRhs))
+    SPxLPBase<R>::changeRhs(i, newLhs, scale);
+  else
+    SPxLPBase<R>::changeRhs(i, newRhs, scale);
 
-   if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-   {
-      changeLhsStatus(i, this->lhs(i), oldLhs);
-      changeRhsStatus(i, this->rhs(i), oldRhs);
-      unInit();
-   }
+  if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM) {
+    changeLhsStatus(i, this->lhs(i), oldLhs);
+    changeRhsStatus(i, this->rhs(i), oldRhs);
+    unInit();
+  }
 }
 
 template <class R>
-void SPxSolverBase<R>::changeRow(int i, const LPRowBase<R>& newRow, bool scale)
-{
-   forceRecompNonbasicValue();
+void SPxSolverBase<R>::changeRow(int i, const LPRowBase<R> &newRow,
+                                 bool scale) {
+  forceRecompNonbasicValue();
 
-   SPxLPBase<R>::changeRow(i, newRow, scale);
+  SPxLPBase<R>::changeRow(i, newRow, scale);
 
-   if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-      SPxBasisBase<R>::changedRow(i);
+  if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
+    SPxBasisBase<R>::changedRow(i);
 
-   unInit();
+  unInit();
 }
 
 template <class R>
-void SPxSolverBase<R>::changeCol(int i, const LPColBase<R>& newCol, bool scale)
-{
-   if(i < 0)
-      return;
+void SPxSolverBase<R>::changeCol(int i, const LPColBase<R> &newCol,
+                                 bool scale) {
+  if (i < 0)
+    return;
 
-   forceRecompNonbasicValue();
+  forceRecompNonbasicValue();
 
-   SPxLPBase<R>::changeCol(i, newCol, scale);
+  SPxLPBase<R>::changeCol(i, newCol, scale);
 
-   if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-      SPxBasisBase<R>::changedCol(i);
+  if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
+    SPxBasisBase<R>::changedCol(i);
 
-   unInit();
+  unInit();
 }
 
 template <class R>
-void SPxSolverBase<R>::changeElement(int i, int j, const R& val, bool scale)
-{
-   if(i < 0 || j < 0)
-      return;
+void SPxSolverBase<R>::changeElement(int i, int j, const R &val, bool scale) {
+  if (i < 0 || j < 0)
+    return;
 
-   forceRecompNonbasicValue();
+  forceRecompNonbasicValue();
 
-   SPxLPBase<R>::changeElement(i, j, val, scale);
+  SPxLPBase<R>::changeElement(i, j, val, scale);
 
-   if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-      SPxBasisBase<R>::changedElement(i, j);
+  if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
+    SPxBasisBase<R>::changedElement(i, j);
 
-   unInit();
+  unInit();
 }
 
 template <class R>
-void SPxSolverBase<R>::changeSense(typename SPxLPBase<R>::SPxSense sns)
-{
+void SPxSolverBase<R>::changeSense(typename SPxLPBase<R>::SPxSense sns) {
 
-   SPxLPBase<R>::changeSense(sns);
-   unInit();
+  SPxLPBase<R>::changeSense(sns);
+  unInit();
 }
 } // namespace soplex
diff --git a/src/soplex/clufactor.hpp b/src/soplex/clufactor.hpp
index ba7db4c..09ed021 100644
--- a/src/soplex/clufactor.hpp
+++ b/src/soplex/clufactor.hpp
@@ -21,690 +21,600 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
-#include <assert.h>
 #include "soplex/cring.h"
+#include <assert.h>
 
-namespace soplex
-{
+namespace soplex {
 
 /* Macro to print a warning message for huge values */
 #ifndef NDEBUG
-#define DEBUG_CHECK_HUGE_VALUE( prefix, value )                                                    \
-   if(spxAbs(value) >= 1e40 && this->hugeValues < 3)                                               \
-   {                                                                                               \
-      this->hugeValues++;                                                                          \
-      std::cout << prefix                                                                          \
-                << " Huge value during triangular solve: "                                         \
-                << value << std::endl;                                                             \
-      if(this->hugeValues >= 3)                                                                    \
-         std::cout << "Skipping further warnings of this type during current solve." << std::endl; \
-   }
+#define DEBUG_CHECK_HUGE_VALUE(prefix, value)                                  \
+  if (spxAbs(value) >= 1e40 && this->hugeValues < 3) {                         \
+    this->hugeValues++;                                                        \
+    std::cout << prefix << " Huge value during triangular solve: " << value    \
+              << std::endl;                                                    \
+    if (this->hugeValues >= 3)                                                 \
+      std::cout                                                                \
+          << "Skipping further warnings of this type during current solve."    \
+          << std::endl;                                                        \
+  }
 #else
-#define DEBUG_CHECK_HUGE_VALUE( prefix, value ) /**/
+#define DEBUG_CHECK_HUGE_VALUE(prefix, value) /**/
 #endif
 
 /* This number is used to decide wether a value is zero
  * or was explicitly set to zero.
  */
-#define SOPLEX_FACTOR_MARKER     1e-100
+#define SOPLEX_FACTOR_MARKER 1e-100
 
 static const Real verySparseFactor = 0.001;
 static const Real verySparseFactor4right = 0.2;
-static const Real verySparseFactor4left  = 0.1;
+static const Real verySparseFactor4left = 0.1;
 
 /* generic heap management */
-static inline void enQueueMax(int* heap, int* size, int elem)
-{
-   int i, j;
+static inline void enQueueMax(int *heap, int *size, int elem) {
+  int i, j;
 
-   j = (*size)++;
+  j = (*size)++;
 
-   while(j > 0)
-   {
-      i = (j - 1) / 2;
+  while (j > 0) {
+    i = (j - 1) / 2;
 
-      if(elem > heap[i])
-      {
-         heap[j] = heap[i];
-         j = i;
-      }
-      else
-         break;
-   }
+    if (elem > heap[i]) {
+      heap[j] = heap[i];
+      j = i;
+    } else
+      break;
+  }
 
-   heap[j] = elem;
+  heap[j] = elem;
 
 #ifdef SOPLEX_DEBUG
 
-   // no NDEBUG define, since this block is really expensive
-   for(i = 1; i < *size; ++i)
-      for(j = 0; j < i; ++j)
-         assert(heap[i] != heap[j]);
+  // no NDEBUG define, since this block is really expensive
+  for (i = 1; i < *size; ++i)
+    for (j = 0; j < i; ++j)
+      assert(heap[i] != heap[j]);
 
-#endif  /* SOPLEX_DEBUG */
+#endif /* SOPLEX_DEBUG */
 }
 
-static inline int deQueueMax(int* heap, int* size)
-{
-   int e, elem;
-   int i, j, s;
-   int e1, e2;
-
-   elem = *heap;
-   e = heap[s = --(*size)];
-   --s;
-
-   for(j = 0, i = 1; i < s; i = 2 * j + 1)
-   {
-      e1 = heap[i];
-      e2 = heap[i + 1];
-
-      if(e1 > e2)
-      {
-         if(e < e1)
-         {
-            heap[j] = e1;
-            j = i;
-         }
-         else
-         {
-            heap[j] = e;
-            return elem;
-         }
+static inline int deQueueMax(int *heap, int *size) {
+  int e, elem;
+  int i, j, s;
+  int e1, e2;
+
+  elem = *heap;
+  e = heap[s = --(*size)];
+  --s;
+
+  for (j = 0, i = 1; i < s; i = 2 * j + 1) {
+    e1 = heap[i];
+    e2 = heap[i + 1];
+
+    if (e1 > e2) {
+      if (e < e1) {
+        heap[j] = e1;
+        j = i;
+      } else {
+        heap[j] = e;
+        return elem;
       }
-      else
-      {
-         if(e < e2)
-         {
-            heap[j] = e2;
-            j = i + 1;
-         }
-         else
-         {
-            heap[j] = e;
-            return elem;
-         }
+    } else {
+      if (e < e2) {
+        heap[j] = e2;
+        j = i + 1;
+      } else {
+        heap[j] = e;
+        return elem;
       }
-   }
+    }
+  }
 
-   if(i < *size && e < heap[i])
-   {
-      heap[j] = heap[i];
-      j = i;
-   }
+  if (i < *size && e < heap[i]) {
+    heap[j] = heap[i];
+    j = i;
+  }
 
-   heap[j] = e;
+  heap[j] = e;
 
-   return elem;
+  return elem;
 }
 
-static inline void enQueueMin(int* heap, int* size, int elem)
-{
-   int i, j;
+static inline void enQueueMin(int *heap, int *size, int elem) {
+  int i, j;
 
-   j = (*size)++;
+  j = (*size)++;
 
-   while(j > 0)
-   {
-      i = (j - 1) / 2;
+  while (j > 0) {
+    i = (j - 1) / 2;
 
-      if(elem < heap[i])
-      {
-         heap[j] = heap[i];
-         j = i;
-      }
-      else
-         break;
-   }
+    if (elem < heap[i]) {
+      heap[j] = heap[i];
+      j = i;
+    } else
+      break;
+  }
 
-   heap[j] = elem;
+  heap[j] = elem;
 
 #ifdef SOPLEX_DEBUG
 
-   // no NDEBUG define, since this block is really expensive
-   for(i = 1; i < *size; ++i)
-      for(j = 0; j < i; ++j)
-         assert(heap[i] != heap[j]);
+  // no NDEBUG define, since this block is really expensive
+  for (i = 1; i < *size; ++i)
+    for (j = 0; j < i; ++j)
+      assert(heap[i] != heap[j]);
 
-#endif  /* SOPLEX_DEBUG */
+#endif /* SOPLEX_DEBUG */
 }
 
-static inline int deQueueMin(int* heap, int* size)
-{
-   int e, elem;
-   int i, j, s;
-   int e1, e2;
-
-   elem = *heap;
-   e = heap[s = --(*size)];
-   --s;
-
-   for(j = 0, i = 1; i < s; i = 2 * j + 1)
-   {
-      e1 = heap[i];
-      e2 = heap[i + 1];
-
-      if(e1 < e2)
-      {
-         if(e > e1)
-         {
-            heap[j] = e1;
-            j = i;
-         }
-         else
-         {
-            heap[j] = e;
-            return elem;
-         }
+static inline int deQueueMin(int *heap, int *size) {
+  int e, elem;
+  int i, j, s;
+  int e1, e2;
+
+  elem = *heap;
+  e = heap[s = --(*size)];
+  --s;
+
+  for (j = 0, i = 1; i < s; i = 2 * j + 1) {
+    e1 = heap[i];
+    e2 = heap[i + 1];
+
+    if (e1 < e2) {
+      if (e > e1) {
+        heap[j] = e1;
+        j = i;
+      } else {
+        heap[j] = e;
+        return elem;
       }
-      else
-      {
-         if(e > e2)
-         {
-            heap[j] = e2;
-            j = i + 1;
-         }
-         else
-         {
-            heap[j] = e;
-            return elem;
-         }
+    } else {
+      if (e > e2) {
+        heap[j] = e2;
+        j = i + 1;
+      } else {
+        heap[j] = e;
+        return elem;
       }
-   }
+    }
+  }
 
-   if(i < *size && e > heap[i])
-   {
-      heap[j] = heap[i];
-      j = i;
-   }
+  if (i < *size && e > heap[i]) {
+    heap[j] = heap[i];
+    j = i;
+  }
 
-   heap[j] = e;
+  heap[j] = e;
 
-   return elem;
+  return elem;
 }
 
 /************************************************************/
 template <class R>
 CLUFactor<R>::Temp::Temp()
-   : s_mark(0)
-   , s_cact(0)
-   , stage(0)
-   , pivot_col(0)
-   , pivot_colNZ(0)
-   , pivot_row(0)
-   , pivot_rowNZ(0)
-{}
-
-template <class R>
-void CLUFactor<R>::Temp::init(int p_dim)
-{
-   s_max.resize(p_dim);
-   spx_realloc(s_cact, p_dim);
-   spx_realloc(s_mark, p_dim);
-   stage = 0;
+    : s_mark(0), s_cact(0), stage(0), pivot_col(0), pivot_colNZ(0),
+      pivot_row(0), pivot_rowNZ(0) {}
+
+template <class R> void CLUFactor<R>::Temp::init(int p_dim) {
+  s_max.resize(p_dim);
+  spx_realloc(s_cact, p_dim);
+  spx_realloc(s_mark, p_dim);
+  stage = 0;
 }
 
-template <class R>
-void CLUFactor<R>::Temp::clear()
-{
-   if(s_mark != nullptr)
-      spx_free(s_mark);
+template <class R> void CLUFactor<R>::Temp::clear() {
+  if (s_mark != nullptr)
+    spx_free(s_mark);
 
-   if(s_cact != nullptr)
-      spx_free(s_cact);
+  if (s_cact != nullptr)
+    spx_free(s_cact);
 
-   if(!s_max.empty())
-      s_max.clear();
+  if (!s_max.empty())
+    s_max.clear();
 
-   if(pivot_col != nullptr)
-      spx_free(pivot_col);
+  if (pivot_col != nullptr)
+    spx_free(pivot_col);
 
-   if(pivot_colNZ != nullptr)
-      spx_free(pivot_colNZ);
+  if (pivot_colNZ != nullptr)
+    spx_free(pivot_colNZ);
 
-   if(pivot_row != nullptr)
-      spx_free(pivot_row);
+  if (pivot_row != nullptr)
+    spx_free(pivot_row);
 
-   if(pivot_rowNZ != nullptr)
-      spx_free(pivot_rowNZ);
+  if (pivot_rowNZ != nullptr)
+    spx_free(pivot_rowNZ);
 }
 
-template <class R>
-CLUFactor<R>::Temp::~Temp()
-{
-   clear();
-}
+template <class R> CLUFactor<R>::Temp::~Temp() { clear(); }
 
 /************************************************************/
-template <class R>
-void CLUFactor<R>::initPerm()
-{
+template <class R> void CLUFactor<R>::initPerm() {
 
-   for(int i = 0; i < thedim; ++i)
-      row.orig[i] = row.perm[i] = col.orig[i] = col.perm[i] = -1;
+  for (int i = 0; i < thedim; ++i)
+    row.orig[i] = row.perm[i] = col.orig[i] = col.perm[i] = -1;
 }
 
 /*****************************************************************************/
 
 template <class R>
-void CLUFactor<R>::setPivot(const int p_stage,
-                            const int p_col,
-                            const int p_row,
-                            const R val)
-{
-   assert(row.perm[p_row] < 0);
-   assert(col.perm[p_col] < 0);
-
-   row.orig[p_stage] = p_row;
-   col.orig[p_stage] = p_col;
-   row.perm[p_row]   = p_stage;
-   col.perm[p_col]   = p_stage;
-   diag[p_row]       = R(1.0) / val;
-
-   if(spxAbs(val) < Param::epsilonPivot())
-   {
+void CLUFactor<R>::setPivot(const int p_stage, const int p_col, const int p_row,
+                            const R val) {
+  assert(row.perm[p_row] < 0);
+  assert(col.perm[p_col] < 0);
+
+  row.orig[p_stage] = p_row;
+  col.orig[p_stage] = p_col;
+  row.perm[p_row] = p_stage;
+  col.perm[p_col] = p_stage;
+  diag[p_row] = R(1.0) / val;
+
+  if (spxAbs(val) < Param::epsilonPivot()) {
 #ifndef NDEBUG
-      MSG_ERROR(std::cerr
-                << "LU pivot element is almost zero (< "
-                << Param::epsilonPivot()
-                << ") - Basis is numerically singular"
-                << std::endl;
-               )
+    MSG_ERROR(std::cerr << "LU pivot element is almost zero (< "
+                        << Param::epsilonPivot()
+                        << ") - Basis is numerically singular" << std::endl;)
 #endif
-      this->stat = SLinSolver<R>::SINGULAR;
-   }
+    this->stat = SLinSolver<R>::SINGULAR;
+  }
 
-   if(spxAbs(diag[p_row]) > maxabs)
-      maxabs = spxAbs(diag[p_row]);
+  if (spxAbs(diag[p_row]) > maxabs)
+    maxabs = spxAbs(diag[p_row]);
 }
 
 /*****************************************************************************/
 /*
  *      Perform garbage collection on row file
  */
-template <class R>
-void CLUFactor<R>::packRows()
-{
-   int n, i, j, l_row;
-   Dring* ring, *list;
-
-   int* l_ridx = u.row.idx;
-   R* l_rval = u.row.val.data();
-   int* l_rlen = u.row.len;
-   int* l_rmax = u.row.max;
-   int* l_rbeg = u.row.start;
-
-   n = 0;
-   list = &(u.row.list);
-
-   for(ring = list->next; ring != list; ring = ring->next)
-   {
-      l_row = ring->idx;
-
-      if(l_rbeg[l_row] != n)
-      {
-         do
-         {
-            l_row = ring->idx;
-            i = l_rbeg[l_row];
-            assert(l_rlen[l_row] <= l_rmax[l_row]);
-            l_rbeg[l_row] = n;
-            l_rmax[l_row] = l_rlen[l_row];
-            j = i + l_rlen[l_row];
-
-            for(; i < j; ++i, ++n)
-            {
-               assert(n <= i);
-               l_ridx[n] = l_ridx[i];
-               l_rval[n] = l_rval[i];
-            }
-
-            ring = ring->next;
-         }
-         while(ring != list);
-
-         goto terminatePackRows;
-      }
+template <class R> void CLUFactor<R>::packRows() {
+  int n, i, j, l_row;
+  Dring *ring, *list;
+
+  int *l_ridx = u.row.idx;
+  R *l_rval = u.row.val.data();
+  int *l_rlen = u.row.len;
+  int *l_rmax = u.row.max;
+  int *l_rbeg = u.row.start;
+
+  n = 0;
+  list = &(u.row.list);
+
+  for (ring = list->next; ring != list; ring = ring->next) {
+    l_row = ring->idx;
+
+    if (l_rbeg[l_row] != n) {
+      do {
+        l_row = ring->idx;
+        i = l_rbeg[l_row];
+        assert(l_rlen[l_row] <= l_rmax[l_row]);
+        l_rbeg[l_row] = n;
+        l_rmax[l_row] = l_rlen[l_row];
+        j = i + l_rlen[l_row];
+
+        for (; i < j; ++i, ++n) {
+          assert(n <= i);
+          l_ridx[n] = l_ridx[i];
+          l_rval[n] = l_rval[i];
+        }
+
+        ring = ring->next;
+      } while (ring != list);
+
+      goto terminatePackRows;
+    }
 
-      n += l_rlen[l_row];
+    n += l_rlen[l_row];
 
-      l_rmax[l_row] = l_rlen[l_row];
-   }
+    l_rmax[l_row] = l_rlen[l_row];
+  }
 
 terminatePackRows:
 
-   u.row.max[thedim] = 0;
-   u.row.used = n;
+  u.row.max[thedim] = 0;
+  u.row.used = n;
 }
 
 /*****************************************************************************/
 /*
  *      Perform garbage collection on column file
  */
-template <class R>
-void CLUFactor<R>::forestPackColumns()
-{
-   int n, i, j, colno;
-   Dring* ring, *list;
-
-   R* cval = u.col.val.data();
-   int* cidx = u.col.idx;
-   int* clen = u.col.len;
-   int* cmax = u.col.max;
-   int* cbeg = u.col.start;
-
-   n = 0;
-   list = &u.col.list;
-
-   for(ring = list->next; ring != list; ring = ring->next)
-   {
-      colno = ring->idx;
-
-      if(cbeg[colno] != n)
-      {
-         do
-         {
-            colno = ring->idx;
-            i = cbeg[colno];
-            cbeg[colno] = n;
-            cmax[colno] = clen[colno];
-            j = i + clen[colno];
-
-            for(; i < j; ++i)
-            {
-               cval[n] = cval[i];
-               cidx[n++] = cidx[i];
-            }
-
-            ring = ring->next;
-         }
-         while(ring != list);
-
-         goto terminatePackColumns;
-      }
+template <class R> void CLUFactor<R>::forestPackColumns() {
+  int n, i, j, colno;
+  Dring *ring, *list;
+
+  R *cval = u.col.val.data();
+  int *cidx = u.col.idx;
+  int *clen = u.col.len;
+  int *cmax = u.col.max;
+  int *cbeg = u.col.start;
+
+  n = 0;
+  list = &u.col.list;
+
+  for (ring = list->next; ring != list; ring = ring->next) {
+    colno = ring->idx;
+
+    if (cbeg[colno] != n) {
+      do {
+        colno = ring->idx;
+        i = cbeg[colno];
+        cbeg[colno] = n;
+        cmax[colno] = clen[colno];
+        j = i + clen[colno];
+
+        for (; i < j; ++i) {
+          cval[n] = cval[i];
+          cidx[n++] = cidx[i];
+        }
+
+        ring = ring->next;
+      } while (ring != list);
+
+      goto terminatePackColumns;
+    }
 
-      n += clen[colno];
+    n += clen[colno];
 
-      cmax[colno] = clen[colno];
-   }
+    cmax[colno] = clen[colno];
+  }
 
-terminatePackColumns :
+terminatePackColumns:
 
-   u.col.used = n;
-   u.col.max[thedim] = 0;
+  u.col.used = n;
+  u.col.max[thedim] = 0;
 }
 
 /*
  *      Make row of fac large enough to hold len nonzeros.
  */
-template <class R>
-void CLUFactor<R>::remaxRow(int p_row, int len)
-{
-   assert(u.row.max[p_row] < len);
+template <class R> void CLUFactor<R>::remaxRow(int p_row, int len) {
+  assert(u.row.max[p_row] < len);
 
-   if(u.row.elem[p_row].next == &(u.row.list))      /* last in row file */
-   {
-      int delta = len - u.row.max[p_row];
+  if (u.row.elem[p_row].next == &(u.row.list)) /* last in row file */
+  {
+    int delta = len - u.row.max[p_row];
 
-      if(delta > u.row.size - u.row.used)
-      {
-         packRows();
-         delta = len - u.row.max[p_row];  // packRows() changes u.row.max[] !
+    if (delta > u.row.size - u.row.used) {
+      packRows();
+      delta = len - u.row.max[p_row]; // packRows() changes u.row.max[] !
 
-         if(u.row.size < rowMemMult * u.row.used + len)
-            minRowMem(2 * u.row.used + len);
+      if (u.row.size < rowMemMult * u.row.used + len)
+        minRowMem(2 * u.row.used + len);
 
-         /* minRowMem(rowMemMult * u.row.used + len); */
-      }
+      /* minRowMem(rowMemMult * u.row.used + len); */
+    }
 
-      assert(delta <= u.row.size - u.row.used
+    assert(delta <= u.row.size - u.row.used
 
-             && "ERROR: could not allocate memory for row file");
+           && "ERROR: could not allocate memory for row file");
 
-      u.row.used += delta;
-      u.row.max[p_row] = len;
-   }
-   else                        /* row must be moved to end of row file */
-   {
-      int i, j, k;
-      int* idx;
-      R* val;
-      Dring* ring;
-
-      if(len > u.row.size - u.row.used)
-      {
-         packRows();
+    u.row.used += delta;
+    u.row.max[p_row] = len;
+  } else /* row must be moved to end of row file */
+  {
+    int i, j, k;
+    int *idx;
+    R *val;
+    Dring *ring;
 
-         if(u.row.size < rowMemMult * u.row.used + len)
-            minRowMem(2 * u.row.used + len);
+    if (len > u.row.size - u.row.used) {
+      packRows();
 
-         /* minRowMem(rowMemMult * u.row.used + len);*/
-      }
+      if (u.row.size < rowMemMult * u.row.used + len)
+        minRowMem(2 * u.row.used + len);
+
+      /* minRowMem(rowMemMult * u.row.used + len);*/
+    }
 
-      assert(len <= u.row.size - u.row.used
+    assert(len <= u.row.size - u.row.used
 
-             && "ERROR: could not allocate memory for row file");
+           && "ERROR: could not allocate memory for row file");
 
-      j = u.row.used;
-      i = u.row.start[p_row];
-      k = u.row.len[p_row] + i;
-      u.row.start[p_row] = j;
-      u.row.used += len;
+    j = u.row.used;
+    i = u.row.start[p_row];
+    k = u.row.len[p_row] + i;
+    u.row.start[p_row] = j;
+    u.row.used += len;
 
-      u.row.max[u.row.elem[p_row].prev->idx] += u.row.max[p_row];
-      u.row.max[p_row] = len;
-      removeDR(u.row.elem[p_row]);
-      ring = u.row.list.prev;
-      init2DR(u.row.elem[p_row], *ring);
+    u.row.max[u.row.elem[p_row].prev->idx] += u.row.max[p_row];
+    u.row.max[p_row] = len;
+    removeDR(u.row.elem[p_row]);
+    ring = u.row.list.prev;
+    init2DR(u.row.elem[p_row], *ring);
 
-      idx = u.row.idx;
-      val = u.row.val.data();
+    idx = u.row.idx;
+    val = u.row.val.data();
 
-      for(; i < k; ++i, ++j)
-      {
-         val[j] = val[i];
-         idx[j] = idx[i];
-      }
-   }
+    for (; i < k; ++i, ++j) {
+      val[j] = val[i];
+      idx[j] = idx[i];
+    }
+  }
 
-   assert(u.row.start[u.row.list.prev->idx] + u.row.max[u.row.list.prev->idx]
+  assert(u.row.start[u.row.list.prev->idx] + u.row.max[u.row.list.prev->idx]
 
-          == u.row.used);
+         == u.row.used);
 }
 
 /*************************************************************************/
 /*
  *      Perform garbage collection on column file
  */
-template <class R>
-void CLUFactor<R>::packColumns()
-{
-   int n, i, j, l_col;
-   Dring* ring, *list;
+template <class R> void CLUFactor<R>::packColumns() {
+  int n, i, j, l_col;
+  Dring *ring, *list;
 
-   int* l_cidx = u.col.idx;
-   int* l_clen = u.col.len;
-   int* l_cmax = u.col.max;
-   int* l_cbeg = u.col.start;
+  int *l_cidx = u.col.idx;
+  int *l_clen = u.col.len;
+  int *l_cmax = u.col.max;
+  int *l_cbeg = u.col.start;
 
-   n = 0;
-   list = &(u.col.list);
+  n = 0;
+  list = &(u.col.list);
 
-   for(ring = list->next; ring != list; ring = ring->next)
-   {
-      l_col = ring->idx;
+  for (ring = list->next; ring != list; ring = ring->next) {
+    l_col = ring->idx;
 
-      if(l_cbeg[l_col] != n)
-      {
-         do
-         {
-            l_col = ring->idx;
-            i = l_cbeg[l_col];
-            l_cbeg[l_col] = n;
-            l_cmax[l_col] = l_clen[l_col];
-            j = i + l_clen[l_col];
-
-            for(; i < j; ++i)
-               l_cidx[n++] = l_cidx[i];
-
-            ring = ring->next;
-         }
-         while(ring != list);
-
-         goto terminatePackColumns;
-      }
+    if (l_cbeg[l_col] != n) {
+      do {
+        l_col = ring->idx;
+        i = l_cbeg[l_col];
+        l_cbeg[l_col] = n;
+        l_cmax[l_col] = l_clen[l_col];
+        j = i + l_clen[l_col];
 
-      n += l_clen[l_col];
+        for (; i < j; ++i)
+          l_cidx[n++] = l_cidx[i];
 
-      l_cmax[l_col] = l_clen[l_col];
-   }
+        ring = ring->next;
+      } while (ring != list);
+
+      goto terminatePackColumns;
+    }
 
-terminatePackColumns :
+    n += l_clen[l_col];
 
-   u.col.used = n;
-   u.col.max[thedim] = 0;
+    l_cmax[l_col] = l_clen[l_col];
+  }
+
+terminatePackColumns:
+
+  u.col.used = n;
+  u.col.max[thedim] = 0;
 }
 
 /*
  *      Make column col of fac large enough to hold len nonzeros.
  */
-template <class R>
-void CLUFactor<R>::remaxCol(int p_col, int len)
-{
-   assert(u.col.max[p_col] < len);
+template <class R> void CLUFactor<R>::remaxCol(int p_col, int len) {
+  assert(u.col.max[p_col] < len);
 
-   if(u.col.elem[p_col].next == &(u.col.list))      /* last in column file */
-   {
-      int delta = len - u.col.max[p_col];
+  if (u.col.elem[p_col].next == &(u.col.list)) /* last in column file */
+  {
+    int delta = len - u.col.max[p_col];
 
-      if(delta > u.col.size - u.col.used)
-      {
-         packColumns();
-         delta = len - u.col.max[p_col];
+    if (delta > u.col.size - u.col.used) {
+      packColumns();
+      delta = len - u.col.max[p_col];
 
-         if(u.col.size < colMemMult * u.col.used + len)
-            minColMem(2 * u.col.used + len);
+      if (u.col.size < colMemMult * u.col.used + len)
+        minColMem(2 * u.col.used + len);
 
-         /* minColMem(colMemMult * u.col.used + len); */
-      }
+      /* minColMem(colMemMult * u.col.used + len); */
+    }
 
-      assert(delta <= u.col.size - u.col.used
+    assert(delta <= u.col.size - u.col.used
 
-             && "ERROR: could not allocate memory for column file");
+           && "ERROR: could not allocate memory for column file");
 
-      u.col.used += delta;
-      u.col.max[p_col] = len;
-   }
+    u.col.used += delta;
+    u.col.max[p_col] = len;
+  }
 
-   else                        /* column must be moved to end of column file */
-   {
-      int i, j, k;
-      int* idx;
-      Dring* ring;
+  else /* column must be moved to end of column file */
+  {
+    int i, j, k;
+    int *idx;
+    Dring *ring;
 
-      if(len > u.col.size - u.col.used)
-      {
-         packColumns();
+    if (len > u.col.size - u.col.used) {
+      packColumns();
 
-         if(u.col.size < colMemMult * u.col.used + len)
-            minColMem(2 * u.col.used + len);
+      if (u.col.size < colMemMult * u.col.used + len)
+        minColMem(2 * u.col.used + len);
 
-         /* minColMem(colMemMult * u.col.used + len); */
-      }
+      /* minColMem(colMemMult * u.col.used + len); */
+    }
 
-      assert(len <= u.col.size - u.col.used
+    assert(len <= u.col.size - u.col.used
 
-             && "ERROR: could not allocate memory for column file");
+           && "ERROR: could not allocate memory for column file");
 
-      j = u.col.used;
-      i = u.col.start[p_col];
-      k = u.col.len[p_col] + i;
-      u.col.start[p_col] = j;
-      u.col.used += len;
+    j = u.col.used;
+    i = u.col.start[p_col];
+    k = u.col.len[p_col] + i;
+    u.col.start[p_col] = j;
+    u.col.used += len;
 
-      u.col.max[u.col.elem[p_col].prev->idx] += u.col.max[p_col];
-      u.col.max[p_col] = len;
-      removeDR(u.col.elem[p_col]);
-      ring = u.col.list.prev;
-      init2DR(u.col.elem[p_col], *ring);
+    u.col.max[u.col.elem[p_col].prev->idx] += u.col.max[p_col];
+    u.col.max[p_col] = len;
+    removeDR(u.col.elem[p_col]);
+    ring = u.col.list.prev;
+    init2DR(u.col.elem[p_col], *ring);
 
-      idx = u.col.idx;
+    idx = u.col.idx;
 
-      for(; i < k; ++i)
-         idx[j++] = idx[i];
-   }
+    for (; i < k; ++i)
+      idx[j++] = idx[i];
+  }
 }
 
 /*
  *      Make column col of fac large enough to hold len nonzeros.
  */
-template <class R>
-void CLUFactor<R>::forestReMaxCol(int p_col, int len)
-{
-   assert(u.col.max[p_col] < len);
+template <class R> void CLUFactor<R>::forestReMaxCol(int p_col, int len) {
+  assert(u.col.max[p_col] < len);
 
-   if(u.col.elem[p_col].next == &(u.col.list))      /* last in column file */
-   {
-      int delta = len - u.col.max[p_col];
+  if (u.col.elem[p_col].next == &(u.col.list)) /* last in column file */
+  {
+    int delta = len - u.col.max[p_col];
 
-      if(delta > u.col.size - u.col.used)
-      {
-         forestPackColumns();
-         delta = len - u.col.max[p_col];
+    if (delta > u.col.size - u.col.used) {
+      forestPackColumns();
+      delta = len - u.col.max[p_col];
 
-         if(u.col.size < colMemMult * u.col.used + len)
-            forestMinColMem(int(colMemMult * u.col.used + len));
-      }
+      if (u.col.size < colMemMult * u.col.used + len)
+        forestMinColMem(int(colMemMult * u.col.used + len));
+    }
 
-      assert(delta <= u.col.size - u.col.used
+    assert(delta <= u.col.size - u.col.used
 
-             && "ERROR: could not allocate memory for column file");
+           && "ERROR: could not allocate memory for column file");
 
-      u.col.used += delta;
-      u.col.max[p_col] = len;
-   }
+    u.col.used += delta;
+    u.col.max[p_col] = len;
+  }
 
-   else                        /* column must be moved to end of column file */
-   {
-      int i, j, k;
-      int* idx;
-      R* val;
-      Dring* ring;
+  else /* column must be moved to end of column file */
+  {
+    int i, j, k;
+    int *idx;
+    R *val;
+    Dring *ring;
 
-      if(len > u.col.size - u.col.used)
-      {
-         forestPackColumns();
+    if (len > u.col.size - u.col.used) {
+      forestPackColumns();
 
-         if(u.col.size < colMemMult * u.col.used + len)
-            forestMinColMem(int(colMemMult * u.col.used + len));
-      }
+      if (u.col.size < colMemMult * u.col.used + len)
+        forestMinColMem(int(colMemMult * u.col.used + len));
+    }
 
-      assert(len <= u.col.size - u.col.used
+    assert(len <= u.col.size - u.col.used
 
-             && "ERROR: could not allocate memory for column file");
+           && "ERROR: could not allocate memory for column file");
 
-      j = u.col.used;
-      i = u.col.start[p_col];
-      k = u.col.len[p_col] + i;
-      u.col.start[p_col] = j;
-      u.col.used += len;
+    j = u.col.used;
+    i = u.col.start[p_col];
+    k = u.col.len[p_col] + i;
+    u.col.start[p_col] = j;
+    u.col.used += len;
 
-      u.col.max[u.col.elem[p_col].prev->idx] += u.col.max[p_col];
-      u.col.max[p_col] = len;
-      removeDR(u.col.elem[p_col]);
-      ring = u.col.list.prev;
-      init2DR(u.col.elem[p_col], *ring);
+    u.col.max[u.col.elem[p_col].prev->idx] += u.col.max[p_col];
+    u.col.max[p_col] = len;
+    removeDR(u.col.elem[p_col]);
+    ring = u.col.list.prev;
+    init2DR(u.col.elem[p_col], *ring);
 
-      idx = u.col.idx;
-      val = u.col.val.data();
+    idx = u.col.idx;
+    val = u.col.val.data();
 
-      for(; i < k; ++i)
-      {
-         val[j] = val[i];
-         idx[j++] = idx[i];
-      }
-   }
+    for (; i < k; ++i) {
+      val[j] = val[i];
+      idx[j++] = idx[i];
+    }
+  }
 }
 
 /*****************************************************************************/
@@ -712,686 +622,639 @@ void CLUFactor<R>::forestReMaxCol(int p_col, int len)
 /**
  *   \brief Performs the Forrest-Tomlin update of the LU factorization.
  *
- *   BH: I suppose this is implemented as described in UH Suhl, LM Suhl: A fast LU
- *       update for linear programming, Annals of OR 43, p. 33-47, 1993.
+ *   BH: I suppose this is implemented as described in UH Suhl, LM Suhl: A fast
+ * LU update for linear programming, Annals of OR 43, p. 33-47, 1993.
  *
  *   @param  p_col      Index of basis column to replace.
  *   @param  p_work     Dense VectorBase<R> to substitute in the basis.
- *   @param  num        Number of nonzeros in VectorBase<R> represented by p_work.
+ *   @param  num        Number of nonzeros in VectorBase<R> represented by
+ * p_work.
  *   @param  nonz       Indices of nonzero elements in VectorBase<R> p_work.
  *
- *   The parameters num and nonz are used for the following optimization: If both
- *   are nonzero, indices of the nonzero elements provided in nonz (num giving
- *   their number) allow to access only those nonzero entries.  Otherwise we have
- *   to go through the entire dense VectorBase<R> element by element.
+ *   The parameters num and nonz are used for the following optimization: If
+ * both are nonzero, indices of the nonzero elements provided in nonz (num
+ * giving their number) allow to access only those nonzero entries.  Otherwise
+ * we have to go through the entire dense VectorBase<R> element by element.
  *
  *   After copying p_work into U, p_work is used to expand the row r, which is
  *   needed to restore the triangular structure of U.
  *
  *   Also num and nonz are used to maintain a heap if there are only very few
- *   nonzeros to be eliminated. This is plainly wrong if the method is called with
- *   nonz==0, see todo at the corresponding place below.
+ *   nonzeros to be eliminated. This is plainly wrong if the method is called
+ * with nonz==0, see todo at the corresponding place below.
  *
  *   @throw SPxStatusException if the loaded matrix is singular
  *
  *   @todo Use an extra member variable as a buffer for working with the dense
- *         row instead of misusing p_work. I think that should be as efficient and
- *         much cleaner.
+ *         row instead of misusing p_work. I think that should be as efficient
+ * and much cleaner.
  */
 template <class R>
-void CLUFactor<R>::forestUpdate(int p_col, R* p_work, int num, int* nonz)
-{
-   int i, j, k, h, m, n;
-   int ll, c, r, rowno;
-   R x;
-
-   R* lval;
-   int* lidx;
-   int* lbeg = l.start;
-
-   R* cval;
-   int* cidx = u.col.idx;
-   int* cmax = u.col.max;
-   int* clen = u.col.len;
-   int* cbeg = u.col.start;
-
-   R* rval = u.row.val.data();
-   int* ridx = u.row.idx;
-   int* rmax = u.row.max;
-   int* rlen = u.row.len;
-   int* rbeg = u.row.start;
-
-   int* rperm = row.perm;
-   int* rorig = row.orig;
-   int* cperm = col.perm;
-   int* corig = col.orig;
-
-   R l_maxabs = maxabs;
-   int dim = thedim;
-
-   /*  Remove column p_col from U
-    */
-   j = cbeg[p_col];
-   i = clen[p_col];
-   nzCnt -= i;
-
-   for(i += j - 1; i >= j; --i)
-   {
-      m = cidx[i];          // remove column p_col from row m
-      k = rbeg[m];
-      h = --(rlen[m]) + k;    // decrease length of row m
-
-      while(ridx[k] != p_col)
-         ++k;
-
-      assert(k <= h);       // k is the position of p_col, h is last position
-
-      ridx[k] = ridx[h];    // store last index at the position of p_col
-
-      rval[k] = rval[h];
-   }
+void CLUFactor<R>::forestUpdate(int p_col, R *p_work, int num, int *nonz) {
+  int i, j, k, h, m, n;
+  int ll, c, r, rowno;
+  R x;
 
-   /*  Insert new VectorBase<R> column p_col thereby determining the highest permuted
-    *       row index r.
-    *
-    *       Distinguish between optimized call (num > 0, nonz != 0) and
-    *       non-optimized one.
-    */
-   assert(num);   // otherwise the assert( nonz != 0 ) below should fail
-
-   if(num)
-   {
-      // Optimized call.
-      assert(nonz != 0);
+  R *lval;
+  int *lidx;
+  int *lbeg = l.start;
 
-      clen[p_col] = 0;
+  R *cval;
+  int *cidx = u.col.idx;
+  int *cmax = u.col.max;
+  int *clen = u.col.len;
+  int *cbeg = u.col.start;
 
-      if(num > cmax[p_col])
-         forestReMaxCol(p_col, num);
+  R *rval = u.row.val.data();
+  int *ridx = u.row.idx;
+  int *rmax = u.row.max;
+  int *rlen = u.row.len;
+  int *rbeg = u.row.start;
 
-      cidx = u.col.idx;
+  int *rperm = row.perm;
+  int *rorig = row.orig;
+  int *cperm = col.perm;
+  int *corig = col.orig;
 
-      cval = u.col.val.data();
+  R l_maxabs = maxabs;
+  int dim = thedim;
 
-      k = cbeg[p_col];
+  /*  Remove column p_col from U
+   */
+  j = cbeg[p_col];
+  i = clen[p_col];
+  nzCnt -= i;
 
-      r = 0;
+  for (i += j - 1; i >= j; --i) {
+    m = cidx[i]; // remove column p_col from row m
+    k = rbeg[m];
+    h = --(rlen[m]) + k; // decrease length of row m
 
-      for(j = 0; j < num; ++j)
-      {
-         i = nonz[j];
-         x = p_work[i];
-         p_work[i] = 0.0;
+    while (ridx[k] != p_col)
+      ++k;
 
-         if(isNotZero(x, R(Param::epsilonUpdate())))
-         {
-            if(spxAbs(x) > l_maxabs)
-               l_maxabs = spxAbs(x);
+    assert(k <= h); // k is the position of p_col, h is last position
 
-            /* insert to column file */
-            assert(k - cbeg[p_col] < cmax[p_col]);
+    ridx[k] = ridx[h]; // store last index at the position of p_col
 
-            cval[k] = x;
+    rval[k] = rval[h];
+  }
 
-            cidx[k++] = i;
+  /*  Insert new VectorBase<R> column p_col thereby determining the highest
+   * permuted row index r.
+   *
+   *       Distinguish between optimized call (num > 0, nonz != 0) and
+   *       non-optimized one.
+   */
+  assert(num); // otherwise the assert( nonz != 0 ) below should fail
 
-            /* insert to row file */
-            if(rmax[i] <= rlen[i])
-            {
-               remaxRow(i, rlen[i] + 1);
-               rval = u.row.val.data();
-               ridx = u.row.idx;
-            }
+  if (num) {
+    // Optimized call.
+    assert(nonz != 0);
 
-            h = rbeg[i] + (rlen[i])++;
+    clen[p_col] = 0;
 
-            rval[h] = x;
-            ridx[h] = p_col;
+    if (num > cmax[p_col])
+      forestReMaxCol(p_col, num);
 
-            /* check permuted row index */
+    cidx = u.col.idx;
 
-            if(rperm[i] > r)
-               r = rperm[i];
-         }
-      }
+    cval = u.col.val.data();
 
-      nzCnt += (clen[p_col] = k - cbeg[p_col]);
-   }
-   else
-   {
-      // Non-optimized call: We have to access all elements of p_work.
-      assert(nonz == 0);
-
-      /*
-       *      clen[col] = 0;
-       *      reMaxCol(fac, col, dim);
-       */
-      cidx = u.col.idx;
-      cval = u.col.val.data();
-      k = cbeg[p_col];
-      j = k + cmax[p_col];
-      r = 0;
+    k = cbeg[p_col];
 
-      for(i = 0; i < dim; ++i)
-      {
-         x = p_work[i];
-         p_work[i] = 0.0;
-
-         if(isNotZero(x, R(Param::epsilonUpdate())))
-         {
-            if(spxAbs(x) > l_maxabs)
-               l_maxabs = spxAbs(x);
-
-            /* insert to column file */
-            if(k >= j)
-            {
-               clen[p_col] = k - cbeg[p_col];
-               forestReMaxCol(p_col, dim - i);
-               cidx = u.col.idx;
-               cval = u.col.val.data();
-               k = cbeg[p_col];
-               j = k + cmax[p_col];
-               k += clen[p_col];
-            }
+    r = 0;
 
-            assert(k - cbeg[p_col] < cmax[p_col]);
+    for (j = 0; j < num; ++j) {
+      i = nonz[j];
+      x = p_work[i];
+      p_work[i] = 0.0;
 
-            cval[k] = x;
-            cidx[k++] = i;
+      if (isNotZero(x, R(Param::epsilonUpdate()))) {
+        if (spxAbs(x) > l_maxabs)
+          l_maxabs = spxAbs(x);
 
-            /* insert to row file */
+        /* insert to column file */
+        assert(k - cbeg[p_col] < cmax[p_col]);
 
-            if(rmax[i] <= rlen[i])
-            {
-               remaxRow(i, rlen[i] + 1);
-               rval = u.row.val.data();
-               ridx = u.row.idx;
-            }
+        cval[k] = x;
 
-            h = rbeg[i] + (rlen[i])++;
+        cidx[k++] = i;
 
-            rval[h] = x;
-            ridx[h] = p_col;
+        /* insert to row file */
+        if (rmax[i] <= rlen[i]) {
+          remaxRow(i, rlen[i] + 1);
+          rval = u.row.val.data();
+          ridx = u.row.idx;
+        }
 
-            /* check permuted row index */
+        h = rbeg[i] + (rlen[i])++;
 
-            if(rperm[i] > r)
-               r = rperm[i];
-         }
-      }
+        rval[h] = x;
+        ridx[h] = p_col;
 
-      nzCnt += (clen[p_col] = k - cbeg[p_col]);
+        /* check permuted row index */
 
-      if(cbeg[p_col] + cmax[p_col] == u.col.used)
-      {
-         u.col.used -= cmax[p_col];
-         cmax[p_col] = clen[p_col];
-         u.col.used += cmax[p_col];
+        if (rperm[i] > r)
+          r = rperm[i];
       }
-   }
+    }
 
-   c = cperm[p_col];
+    nzCnt += (clen[p_col] = k - cbeg[p_col]);
+  } else {
+    // Non-optimized call: We have to access all elements of p_work.
+    assert(nonz == 0);
+
+    /*
+     *      clen[col] = 0;
+     *      reMaxCol(fac, col, dim);
+     */
+    cidx = u.col.idx;
+    cval = u.col.val.data();
+    k = cbeg[p_col];
+    j = k + cmax[p_col];
+    r = 0;
+
+    for (i = 0; i < dim; ++i) {
+      x = p_work[i];
+      p_work[i] = 0.0;
+
+      if (isNotZero(x, R(Param::epsilonUpdate()))) {
+        if (spxAbs(x) > l_maxabs)
+          l_maxabs = spxAbs(x);
+
+        /* insert to column file */
+        if (k >= j) {
+          clen[p_col] = k - cbeg[p_col];
+          forestReMaxCol(p_col, dim - i);
+          cidx = u.col.idx;
+          cval = u.col.val.data();
+          k = cbeg[p_col];
+          j = k + cmax[p_col];
+          k += clen[p_col];
+        }
+
+        assert(k - cbeg[p_col] < cmax[p_col]);
+
+        cval[k] = x;
+        cidx[k++] = i;
+
+        /* insert to row file */
+
+        if (rmax[i] <= rlen[i]) {
+          remaxRow(i, rlen[i] + 1);
+          rval = u.row.val.data();
+          ridx = u.row.idx;
+        }
+
+        h = rbeg[i] + (rlen[i])++;
+
+        rval[h] = x;
+        ridx[h] = p_col;
+
+        /* check permuted row index */
+
+        if (rperm[i] > r)
+          r = rperm[i];
+      }
+    }
 
-   if(r > c)                          /* Forest Tomlin update */
-   {
-      /*      update permutations
-       */
-      j = rorig[c];
+    nzCnt += (clen[p_col] = k - cbeg[p_col]);
+
+    if (cbeg[p_col] + cmax[p_col] == u.col.used) {
+      u.col.used -= cmax[p_col];
+      cmax[p_col] = clen[p_col];
+      u.col.used += cmax[p_col];
+    }
+  }
 
-      // memmove is more efficient than a for loop
-      // for ( i = c; i < r; ++i )
-      //    rorig[i] = rorig[i + 1];
-      memmove(&rorig[c], &rorig[c + 1], (unsigned int)(r - c) * sizeof(int));
+  c = cperm[p_col];
 
-      rorig[r] = j;
+  if (r > c) /* Forest Tomlin update */
+  {
+    /*      update permutations
+     */
+    j = rorig[c];
 
-      for(i = c; i <= r; ++i)
-         rperm[rorig[i]] = i;
+    // memmove is more efficient than a for loop
+    // for ( i = c; i < r; ++i )
+    //    rorig[i] = rorig[i + 1];
+    memmove(&rorig[c], &rorig[c + 1], (unsigned int)(r - c) * sizeof(int));
 
-      j = corig[c];
+    rorig[r] = j;
 
-      // memmove is more efficient than a for loop
-      // for ( i = c; i < r; ++i )
-      //    corig[i] = corig[i + 1];
-      memmove(&corig[c], &corig[c + 1], (unsigned int)(r - c) * sizeof(int));
+    for (i = c; i <= r; ++i)
+      rperm[rorig[i]] = i;
 
-      corig[r] = j;
+    j = corig[c];
 
-      for(i = c; i <= r; ++i)
-         cperm[corig[i]] = i;
+    // memmove is more efficient than a for loop
+    // for ( i = c; i < r; ++i )
+    //    corig[i] = corig[i + 1];
+    memmove(&corig[c], &corig[c + 1], (unsigned int)(r - c) * sizeof(int));
 
+    corig[r] = j;
 
-      rowno = rorig[r];
+    for (i = c; i <= r; ++i)
+      cperm[corig[i]] = i;
 
-      j = rbeg[rowno];
+    rowno = rorig[r];
 
-      i = rlen[rowno];
+    j = rbeg[rowno];
 
-      nzCnt -= i;
+    i = rlen[rowno];
 
-      if(i < verySparseFactor * (dim - c))      // few nonzeros to be eliminated
-      {
-         /**
-          *          The following assert is obviously violated if this method is called
-          *          with nonzero==0.
-          *
-          *          @todo Use an extra member variable as a buffer for the heap instead of
-          *                misusing nonz and num. The method enQueueMin() seems to
-          *                sort the nonzeros or something, for which it only needs
-          *                some empty VectorBase<R> of size num.
-          */
-         assert(nonz != 0);
+    nzCnt -= i;
 
-         /*  move row r from U to p_work
-          */
-         num = 0;
+    if (i < verySparseFactor * (dim - c)) // few nonzeros to be eliminated
+    {
+      /**
+       *          The following assert is obviously violated if this method is
+       * called with nonzero==0.
+       *
+       *          @todo Use an extra member variable as a buffer for the heap
+       * instead of misusing nonz and num. The method enQueueMin() seems to sort
+       * the nonzeros or something, for which it only needs some empty
+       * VectorBase<R> of size num.
+       */
+      assert(nonz != 0);
 
-         for(i += j - 1; i >= j; --i)
-         {
-            k = ridx[i];
-            p_work[k] = rval[i];
-            enQueueMin(nonz, &num, cperm[k]);
-            m = --(clen[k]) + cbeg[k];
+      /*  move row r from U to p_work
+       */
+      num = 0;
 
-            for(h = m; cidx[h] != rowno; --h)
-               ;
+      for (i += j - 1; i >= j; --i) {
+        k = ridx[i];
+        p_work[k] = rval[i];
+        enQueueMin(nonz, &num, cperm[k]);
+        m = --(clen[k]) + cbeg[k];
 
-            cidx[h] = cidx[m];
+        for (h = m; cidx[h] != rowno; --h)
+          ;
 
-            cval[h] = cval[m];
-         }
+        cidx[h] = cidx[m];
 
+        cval[h] = cval[m];
+      }
 
-         /*  Eliminate row r from U to L file
-          */
-         ll = makeLvec(r - c, rowno);
+      /*  Eliminate row r from U to L file
+       */
+      ll = makeLvec(r - c, rowno);
 
-         lval = l.val.data();
+      lval = l.val.data();
 
-         lidx = l.idx;
+      lidx = l.idx;
 
-         assert((num == 0) || (nonz != 0));
+      assert((num == 0) || (nonz != 0));
 
-         /* for(i = c; i < r; ++i)       */
-         while(num)
-         {
+      /* for(i = c; i < r; ++i)       */
+      while (num) {
 #ifndef NDEBUG
-            // The numbers seem to be often 1e-100, is this ok ?
+        // The numbers seem to be often 1e-100, is this ok ?
 
-            for(i = 0; i < num; ++i)
-               assert(p_work[corig[nonz[i]]] != 0.0);
+        for (i = 0; i < num; ++i)
+          assert(p_work[corig[nonz[i]]] != 0.0);
 
 #endif // NDEBUG
-            i = deQueueMin(nonz, &num);
-
-            if(i == r)
-               break;
+        i = deQueueMin(nonz, &num);
 
-            k = corig[i];
+        if (i == r)
+          break;
 
-            assert(p_work[k] != 0.0);
+        k = corig[i];
 
-            n = rorig[i];
+        assert(p_work[k] != 0.0);
 
-            x = p_work[k] * diag[n];
+        n = rorig[i];
 
-            lidx[ll] = n;
+        x = p_work[k] * diag[n];
 
-            lval[ll] = x;
+        lidx[ll] = n;
 
-            p_work[k] = 0.0;
+        lval[ll] = x;
 
-            ll++;
+        p_work[k] = 0.0;
 
-            if(spxAbs(x) > l_maxabs)
-               l_maxabs = spxAbs(x);
+        ll++;
 
-            j = rbeg[n];
+        if (spxAbs(x) > l_maxabs)
+          l_maxabs = spxAbs(x);
 
-            m = rlen[n] + j;
+        j = rbeg[n];
 
-            for(; j < m; ++j)
-            {
-               int jj = ridx[j];
-               R y = p_work[jj];
+        m = rlen[n] + j;
 
-               if(y == 0)
-                  enQueueMin(nonz, &num, cperm[jj]);
+        for (; j < m; ++j) {
+          int jj = ridx[j];
+          R y = p_work[jj];
 
-               y -= x * rval[j];
+          if (y == 0)
+            enQueueMin(nonz, &num, cperm[jj]);
 
-               p_work[jj] = y + ((y == 0) ? SOPLEX_FACTOR_MARKER : 0.0);
-            }
-         }
-
-         if(lbeg[l.firstUnused - 1] == ll)
-            (l.firstUnused)--;
-         else
-            lbeg[l.firstUnused] = ll;
+          y -= x * rval[j];
 
+          p_work[jj] = y + ((y == 0) ? SOPLEX_FACTOR_MARKER : 0.0);
+        }
+      }
 
-         /*  Set diagonal value
-          */
-         if(i != r)
-         {
-            this->stat = SLinSolver<R>::SINGULAR;
-            throw SPxStatusException("XFORE01 The loaded matrix is singular");
-         }
-
-         k = corig[r];
+      if (lbeg[l.firstUnused - 1] == ll)
+        (l.firstUnused)--;
+      else
+        lbeg[l.firstUnused] = ll;
 
-         x = p_work[k];
-         diag[rowno] = 1 / x;
-         p_work[k] = 0.0;
+      /*  Set diagonal value
+       */
+      if (i != r) {
+        this->stat = SLinSolver<R>::SINGULAR;
+        throw SPxStatusException("XFORE01 The loaded matrix is singular");
+      }
 
+      k = corig[r];
 
-         /*  make row large enough to fit all nonzeros.
-          */
+      x = p_work[k];
+      diag[rowno] = 1 / x;
+      p_work[k] = 0.0;
 
-         if(rmax[rowno] < num)
-         {
-            rlen[rowno] = 0;
-            remaxRow(rowno, num);
-            rval = u.row.val.data();
-            ridx = u.row.idx;
-         }
+      /*  make row large enough to fit all nonzeros.
+       */
 
-         nzCnt += num;
+      if (rmax[rowno] < num) {
+        rlen[rowno] = 0;
+        remaxRow(rowno, num);
+        rval = u.row.val.data();
+        ridx = u.row.idx;
+      }
 
-         /*  Insert work to updated row thereby clearing work;
-          */
-         n = rbeg[rowno];
+      nzCnt += num;
 
-         for(i = 0; i < num; ++i)
-         {
-            j = corig[nonz[i]];
-            x = p_work[j];
+      /*  Insert work to updated row thereby clearing work;
+       */
+      n = rbeg[rowno];
 
-            // BH 2005-08-24: This if is very important. It may well happen that
-            // during the elimination of row r a nonzero elements cancels out
-            // and becomes zero. This would lead to an infinite loop in the
-            // above elimination code, since the corresponding column index would
-            // be enqueued for further elimination again and agian.
+      for (i = 0; i < num; ++i) {
+        j = corig[nonz[i]];
+        x = p_work[j];
 
-            if(x != 0.0)
-            {
-               if(spxAbs(x) > l_maxabs)
-                  l_maxabs = spxAbs(x);
+        // BH 2005-08-24: This if is very important. It may well happen that
+        // during the elimination of row r a nonzero elements cancels out
+        // and becomes zero. This would lead to an infinite loop in the
+        // above elimination code, since the corresponding column index would
+        // be enqueued for further elimination again and agian.
 
-               ridx[n] = j;
+        if (x != 0.0) {
+          if (spxAbs(x) > l_maxabs)
+            l_maxabs = spxAbs(x);
 
-               rval[n] = x;
+          ridx[n] = j;
 
-               p_work[j] = 0.0;
+          rval[n] = x;
 
-               ++n;
+          p_work[j] = 0.0;
 
-               if(clen[j] >= cmax[j])
-               {
-                  forestReMaxCol(j, clen[j] + 1);
-                  cidx = u.col.idx;
-                  cval = u.col.val.data();
-               }
+          ++n;
 
-               cval[cbeg[j] + clen[j]] = x;
+          if (clen[j] >= cmax[j]) {
+            forestReMaxCol(j, clen[j] + 1);
+            cidx = u.col.idx;
+            cval = u.col.val.data();
+          }
 
-               cidx[cbeg[j] + clen[j]++] = rowno;
-            }
-         }
+          cval[cbeg[j] + clen[j]] = x;
 
-         rlen[rowno] = n - rbeg[rowno];
+          cidx[cbeg[j] + clen[j]++] = rowno;
+        }
       }
-      else            /* few nonzeros to be eliminated        */
-      {
-         /*  move row r from U to p_work
-          */
-         for(i += j - 1; i >= j; --i)
-         {
-            k = ridx[i];
-            p_work[k] = rval[i];
-            m = --(clen[k]) + cbeg[k];
-
-            for(h = m; cidx[h] != rowno; --h)
-               ;
-
-            cidx[h] = cidx[m];
-
-            cval[h] = cval[m];
-         }
 
+      rlen[rowno] = n - rbeg[rowno];
+    } else /* few nonzeros to be eliminated        */
+    {
+      /*  move row r from U to p_work
+       */
+      for (i += j - 1; i >= j; --i) {
+        k = ridx[i];
+        p_work[k] = rval[i];
+        m = --(clen[k]) + cbeg[k];
 
-         /*  Eliminate row r from U to L file
-          */
-         ll = makeLvec(r - c, rowno);
+        for (h = m; cidx[h] != rowno; --h)
+          ;
 
-         lval = l.val.data();
+        cidx[h] = cidx[m];
 
-         lidx = l.idx;
+        cval[h] = cval[m];
+      }
 
-         for(i = c; i < r; ++i)
-         {
-            k = corig[i];
+      /*  Eliminate row r from U to L file
+       */
+      ll = makeLvec(r - c, rowno);
 
-            if(p_work[k] != 0.0)
-            {
-               n = rorig[i];
-               x = p_work[k] * diag[n];
-               lidx[ll] = n;
-               lval[ll] = x;
-               p_work[k] = 0.0;
-               ll++;
+      lval = l.val.data();
 
-               if(spxAbs(x) > l_maxabs)
-                  l_maxabs = spxAbs(x);
+      lidx = l.idx;
 
-               j = rbeg[n];
+      for (i = c; i < r; ++i) {
+        k = corig[i];
 
-               m = rlen[n] + j;
+        if (p_work[k] != 0.0) {
+          n = rorig[i];
+          x = p_work[k] * diag[n];
+          lidx[ll] = n;
+          lval[ll] = x;
+          p_work[k] = 0.0;
+          ll++;
 
-               for(; j < m; ++j)
-                  p_work[ridx[j]] -= x * rval[j];
-            }
-         }
+          if (spxAbs(x) > l_maxabs)
+            l_maxabs = spxAbs(x);
 
-         if(lbeg[l.firstUnused - 1] == ll)
-            (l.firstUnused)--;
-         else
-            lbeg[l.firstUnused] = ll;
+          j = rbeg[n];
 
+          m = rlen[n] + j;
 
-         /*  Set diagonal value
-          */
-         k = corig[r];
+          for (; j < m; ++j)
+            p_work[ridx[j]] -= x * rval[j];
+        }
+      }
 
-         x = p_work[k];
+      if (lbeg[l.firstUnused - 1] == ll)
+        (l.firstUnused)--;
+      else
+        lbeg[l.firstUnused] = ll;
 
-         if(x == 0.0)
-         {
-            this->stat = SLinSolver<R>::SINGULAR;
-            throw SPxStatusException("XFORE02 The loaded matrix is singular");
-            //            return;
-         }
+      /*  Set diagonal value
+       */
+      k = corig[r];
 
-         diag[rowno] = 1 / x;
+      x = p_work[k];
 
-         p_work[k] = 0.0;
+      if (x == 0.0) {
+        this->stat = SLinSolver<R>::SINGULAR;
+        throw SPxStatusException("XFORE02 The loaded matrix is singular");
+        //            return;
+      }
 
+      diag[rowno] = 1 / x;
 
-         /*  count remaining nonzeros in work and make row large enough
-          *  to fit them all.
-          */
-         n = 0;
+      p_work[k] = 0.0;
 
-         for(i = r + 1; i < dim; ++i)
-            if(p_work[corig[i]] != 0.0)
-               n++;
+      /*  count remaining nonzeros in work and make row large enough
+       *  to fit them all.
+       */
+      n = 0;
 
-         if(rmax[rowno] < n)
-         {
-            rlen[rowno] = 0;
-            remaxRow(rowno, n);
-            rval = u.row.val.data();
-            ridx = u.row.idx;
-         }
+      for (i = r + 1; i < dim; ++i)
+        if (p_work[corig[i]] != 0.0)
+          n++;
 
-         nzCnt += n;
+      if (rmax[rowno] < n) {
+        rlen[rowno] = 0;
+        remaxRow(rowno, n);
+        rval = u.row.val.data();
+        ridx = u.row.idx;
+      }
 
-         /*  Insert p_work to updated row thereby clearing p_work;
-          */
-         n = rbeg[rowno];
+      nzCnt += n;
 
-         for(i = r + 1; i < dim; ++i)
-         {
-            j = corig[i];
-            x = p_work[j];
+      /*  Insert p_work to updated row thereby clearing p_work;
+       */
+      n = rbeg[rowno];
 
-            if(x != 0.0)
-            {
-               if(spxAbs(x) > l_maxabs)
-                  l_maxabs = spxAbs(x);
+      for (i = r + 1; i < dim; ++i) {
+        j = corig[i];
+        x = p_work[j];
 
-               ridx[n] = j;
+        if (x != 0.0) {
+          if (spxAbs(x) > l_maxabs)
+            l_maxabs = spxAbs(x);
 
-               rval[n] = x;
+          ridx[n] = j;
 
-               p_work[j] = 0.0;
+          rval[n] = x;
 
-               ++n;
+          p_work[j] = 0.0;
 
-               if(clen[j] >= cmax[j])
-               {
-                  forestReMaxCol(j, clen[j] + 1);
-                  cidx = u.col.idx;
-                  cval = u.col.val.data();
-               }
+          ++n;
 
-               cval[cbeg[j] + clen[j]] = x;
+          if (clen[j] >= cmax[j]) {
+            forestReMaxCol(j, clen[j] + 1);
+            cidx = u.col.idx;
+            cval = u.col.val.data();
+          }
 
-               cidx[cbeg[j] + clen[j]++] = rowno;
-            }
-         }
+          cval[cbeg[j] + clen[j]] = x;
 
-         rlen[rowno] = n - rbeg[rowno];
+          cidx[cbeg[j] + clen[j]++] = rowno;
+        }
       }
-   }
 
-   else if(r == c)
-   {
-      /*  Move diagonal element to diag.  Note, that it must be the last
-       *  element, since it has just been inserted above.
-       */
-      rowno = rorig[r];
-      i = rbeg[rowno] + --(rlen[rowno]);
-      diag[rowno] = 1 / rval[i];
+      rlen[rowno] = n - rbeg[rowno];
+    }
+  }
 
-      for(j = i = --(clen[p_col]) + cbeg[p_col]; cidx[i] != rowno; --i)
-         ;
+  else if (r == c) {
+    /*  Move diagonal element to diag.  Note, that it must be the last
+     *  element, since it has just been inserted above.
+     */
+    rowno = rorig[r];
+    i = rbeg[rowno] + --(rlen[rowno]);
+    diag[rowno] = 1 / rval[i];
 
-      cidx[i] = cidx[j];
+    for (j = i = --(clen[p_col]) + cbeg[p_col]; cidx[i] != rowno; --i)
+      ;
 
-      cval[i] = cval[j];
-   }
-   else /* r < c */
-   {
-      this->stat = SLinSolver<R>::SINGULAR;
-      throw SPxStatusException("XFORE03 The loaded matrix is singular");
-      //      return;
-   }
+    cidx[i] = cidx[j];
 
-   maxabs = l_maxabs;
+    cval[i] = cval[j];
+  } else /* r < c */
+  {
+    this->stat = SLinSolver<R>::SINGULAR;
+    throw SPxStatusException("XFORE03 The loaded matrix is singular");
+    //      return;
+  }
 
-   assert(isConsistent());
-   this->stat = SLinSolver<R>::OK;
+  maxabs = l_maxabs;
+
+  assert(isConsistent());
+  this->stat = SLinSolver<R>::OK;
 }
 
 template <class R>
-void CLUFactor<R>::update(int p_col, R* p_work, const int* p_idx, int num)
-{
-   int ll, i, j;
-   int* lidx;
-   R* lval;
-   R x, rezi;
-
-   assert(p_work[p_col] != 0.0);
-   rezi = 1 / p_work[p_col];
-   p_work[p_col] = 0.0;
-
-   ll = makeLvec(num, p_col);
-   //   ll = fac->makeLvec(num, col);
-   lval = l.val.data();
-   lidx = l.idx;
-
-   for(i = num - 1; (j = p_idx[i]) != p_col; --i)
-   {
-      lidx[ll] = j;
-      lval[ll] = rezi * p_work[j];
-      p_work[j] = 0.0;
-      ++ll;
-   }
-
-   lidx[ll] = p_col;
-
-   lval[ll] = 1 - rezi;
-   ++ll;
-
-   for(--i; i >= 0; --i)
-   {
-      j = p_idx[i];
-      lidx[ll] = j;
-      lval[ll] = x = rezi * p_work[j];
-      p_work[j] = 0.0;
-      ++ll;
-
-      if(spxAbs(x) > maxabs)
-         maxabs = spxAbs(x);
-   }
-
-   this->stat = SLinSolver<R>::OK;
+void CLUFactor<R>::update(int p_col, R *p_work, const int *p_idx, int num) {
+  int ll, i, j;
+  int *lidx;
+  R *lval;
+  R x, rezi;
+
+  assert(p_work[p_col] != 0.0);
+  rezi = 1 / p_work[p_col];
+  p_work[p_col] = 0.0;
+
+  ll = makeLvec(num, p_col);
+  //   ll = fac->makeLvec(num, col);
+  lval = l.val.data();
+  lidx = l.idx;
+
+  for (i = num - 1; (j = p_idx[i]) != p_col; --i) {
+    lidx[ll] = j;
+    lval[ll] = rezi * p_work[j];
+    p_work[j] = 0.0;
+    ++ll;
+  }
+
+  lidx[ll] = p_col;
+
+  lval[ll] = 1 - rezi;
+  ++ll;
+
+  for (--i; i >= 0; --i) {
+    j = p_idx[i];
+    lidx[ll] = j;
+    lval[ll] = x = rezi * p_work[j];
+    p_work[j] = 0.0;
+    ++ll;
+
+    if (spxAbs(x) > maxabs)
+      maxabs = spxAbs(x);
+  }
+
+  this->stat = SLinSolver<R>::OK;
 }
 
 template <class R>
-void CLUFactor<R>::updateNoClear(
-   int p_col,
-   const R* p_work,
-   const int* p_idx,
-   int num)
-{
-   int ll, i, j;
-   int* lidx;
-   R* lval;
-   R x, rezi;
-
-   assert(p_work[p_col] != 0.0);
-   rezi = 1 / p_work[p_col];
-   ll = makeLvec(num, p_col);
-   //ll = fac->makeLvec(num, col);
-   lval = l.val.data();
-   lidx = l.idx;
-
-   for(i = num - 1; (j = p_idx[i]) != p_col; --i)
-   {
-      lidx[ll] = j;
-      lval[ll] = rezi * p_work[j];
-      ++ll;
-   }
-
-   lidx[ll] = p_col;
-
-   lval[ll] = 1 - rezi;
-   ++ll;
-
-   for(--i; i >= 0; --i)
-   {
-      j = p_idx[i];
-      lidx[ll] = j;
-      lval[ll] = x = rezi * p_work[j];
-      ++ll;
-
-      if(spxAbs(x) > maxabs)
-         maxabs = spxAbs(x);
-   }
-
-   this->stat = SLinSolver<R>::OK;
+void CLUFactor<R>::updateNoClear(int p_col, const R *p_work, const int *p_idx,
+                                 int num) {
+  int ll, i, j;
+  int *lidx;
+  R *lval;
+  R x, rezi;
+
+  assert(p_work[p_col] != 0.0);
+  rezi = 1 / p_work[p_col];
+  ll = makeLvec(num, p_col);
+  // ll = fac->makeLvec(num, col);
+  lval = l.val.data();
+  lidx = l.idx;
+
+  for (i = num - 1; (j = p_idx[i]) != p_col; --i) {
+    lidx[ll] = j;
+    lval[ll] = rezi * p_work[j];
+    ++ll;
+  }
+
+  lidx[ll] = p_col;
+
+  lval[ll] = 1 - rezi;
+  ++ll;
+
+  for (--i; i >= 0; --i) {
+    j = p_idx[i];
+    lidx[ll] = j;
+    lval[ll] = x = rezi * p_work[j];
+    ++ll;
+
+    if (spxAbs(x) > maxabs)
+      maxabs = spxAbs(x);
+  }
+
+  this->stat = SLinSolver<R>::OK;
 }
 
 /*****************************************************************************/
@@ -1421,1394 +1284,1266 @@ void CLUFactor<R>::updateNoClear(
  *      mark column singletons.
  */
 template <class R>
-void CLUFactor<R>::initFactorMatrix(const SVectorBase<R>** vec, const R eps)
-{
+void CLUFactor<R>::initFactorMatrix(const SVectorBase<R> **vec, const R eps) {
 
-   R x;
-   int m;
-   int tot;
-   Dring* rring, *lastrring;
-   Dring* cring, *lastcring;
-   const SVectorBase<R>* psv;
-   int* sing = temp.s_mark;
+  R x;
+  int m;
+  int tot;
+  Dring *rring, *lastrring;
+  Dring *cring, *lastcring;
+  const SVectorBase<R> *psv;
+  int *sing = temp.s_mark;
 
-   /*  Initialize:
-    *  - column file thereby remembering column singletons in |sing|.
-    *  - nonzeros counts per row
-    *  - total number of nonzeros
-    */
+  /*  Initialize:
+   *  - column file thereby remembering column singletons in |sing|.
+   *  - nonzeros counts per row
+   *  - total number of nonzeros
+   */
 
-   for(int i = 0; i < thedim; i++)
-      u.row.max[i] = u.row.len[i] = 0;
+  for (int i = 0; i < thedim; i++)
+    u.row.max[i] = u.row.len[i] = 0;
 
-   tot = 0;
+  tot = 0;
 
-   for(int i = 0; i < thedim; i++)
-   {
-      int k;
-
-      psv = vec[i];
-      k = psv->size();
-
-      if(k > 1)
-      {
-         tot += k;
-
-         for(int j = 0; j < k; ++j)
-            u.row.max[psv->index(j)]++;
-      }
-      else if(k == 0)
-      {
-         this->stat = SLinSolver<R>::SINGULAR;
-         return;
-      }
-   }
+  for (int i = 0; i < thedim; i++) {
+    int k;
 
-   /*  Resize nonzero memory if necessary
-    */
-   minRowMem(int(rowMemMult * tot));
+    psv = vec[i];
+    k = psv->size();
 
-   minColMem(int(colMemMult * tot));
+    if (k > 1) {
+      tot += k;
 
-   minLMem(int(lMemMult * tot));
+      for (int j = 0; j < k; ++j)
+        u.row.max[psv->index(j)]++;
+    } else if (k == 0) {
+      this->stat = SLinSolver<R>::SINGULAR;
+      return;
+    }
+  }
 
+  /*  Resize nonzero memory if necessary
+   */
+  minRowMem(int(rowMemMult * tot));
 
-   /*  Initialize:
-    *  - row ring lists
-    *  - row vectors in file
-    *  - column ring lists
-    */
-   u.row.start[0] = 0;
+  minColMem(int(colMemMult * tot));
 
-   rring = u.row.elem;
+  minLMem(int(lMemMult * tot));
 
-   lastrring = &(u.row.list);
+  /*  Initialize:
+   *  - row ring lists
+   *  - row vectors in file
+   *  - column ring lists
+   */
+  u.row.start[0] = 0;
 
-   lastrring->idx = thedim;
+  rring = u.row.elem;
 
-   lastrring->next = rring;
+  lastrring = &(u.row.list);
 
-   cring = u.col.elem;
+  lastrring->idx = thedim;
 
-   lastcring = &(u.col.list);
+  lastrring->next = rring;
 
-   lastcring->idx = thedim;
+  cring = u.col.elem;
 
-   lastcring->next = cring;
+  lastcring = &(u.col.list);
 
-   m = 0;
+  lastcring->idx = thedim;
 
-   for(int i = 0; i < thedim; i++)
-   {
-      u.row.start[i] = m;
-      m += u.row.max[i];
+  lastcring->next = cring;
 
-      rring->idx = i;
-      rring->prev = lastrring;
-      lastrring->next = rring;
-      lastrring = rring;
-      ++rring;
+  m = 0;
 
-      cring->idx = i;
-      cring->prev = lastcring;
-      lastcring->next = cring;
-      lastcring = cring;
-      ++cring;
-   }
+  for (int i = 0; i < thedim; i++) {
+    u.row.start[i] = m;
+    m += u.row.max[i];
 
-   u.row.start[thedim]       = 0;
+    rring->idx = i;
+    rring->prev = lastrring;
+    lastrring->next = rring;
+    lastrring = rring;
+    ++rring;
 
-   u.row.max[thedim]       = 0;
-   u.row.used = m;
+    cring->idx = i;
+    cring->prev = lastcring;
+    lastcring->next = cring;
+    lastcring = cring;
+    ++cring;
+  }
 
-   lastrring->next = &(u.row.list);
-   lastrring->next->prev = lastrring;
+  u.row.start[thedim] = 0;
 
-   lastcring->next = &(u.col.list);
-   lastcring->next->prev = lastcring;
+  u.row.max[thedim] = 0;
+  u.row.used = m;
 
-   /*  Copy matrix to row and column file
-    *  excluding and marking column singletons!
-    */
-   m = 0;
-   temp.stage = 0;
+  lastrring->next = &(u.row.list);
+  lastrring->next->prev = lastrring;
 
-   initMaxabs = 0;
+  lastcring->next = &(u.col.list);
+  lastcring->next->prev = lastcring;
 
-   for(int i = 0; i < thedim; i++)
-   {
-      int nnonzeros;
+  /*  Copy matrix to row and column file
+   *  excluding and marking column singletons!
+   */
+  m = 0;
+  temp.stage = 0;
 
-      psv = vec[i];
-      u.col.start[i] = m;
+  initMaxabs = 0;
 
-      /* check whether number of nonzeros above tolerance is 0, 1 or >= 2 */
-      nnonzeros = 0;
+  for (int i = 0; i < thedim; i++) {
+    int nnonzeros;
 
-      for(int j = 0; j < psv->size() && nnonzeros <= 1; j++)
-      {
-         if(isNotZero(psv->value(j), eps))
-            nnonzeros++;
-      }
+    psv = vec[i];
+    u.col.start[i] = m;
 
-      /* basis is singular due to empty column */
-      if(nnonzeros == 0)
-      {
-         this->stat = SLinSolver<R>::SINGULAR;
-         return;
-      }
+    /* check whether number of nonzeros above tolerance is 0, 1 or >= 2 */
+    nnonzeros = 0;
 
-      /* exclude column singletons */
-      else if(nnonzeros == 1)
-      {
-         int j = 0;
+    for (int j = 0; j < psv->size() && nnonzeros <= 1; j++) {
+      if (isNotZero(psv->value(j), eps))
+        nnonzeros++;
+    }
 
-         /* find nonzero */
+    /* basis is singular due to empty column */
+    if (nnonzeros == 0) {
+      this->stat = SLinSolver<R>::SINGULAR;
+      return;
+    }
 
-         for(j = 0; isZero(psv->value(j), eps); j++)
-            ;
+    /* exclude column singletons */
+    else if (nnonzeros == 1) {
+      int j = 0;
 
-         assert(j < psv->size());
+      /* find nonzero */
 
-         /* basis is singular due to two linearly dependent column singletons */
-         if(row.perm[psv->index(j)] >= 0)
-         {
-            this->stat = SLinSolver<R>::SINGULAR;
-            return;
-         }
+      for (j = 0; isZero(psv->value(j), eps); j++)
+        ;
 
-         /* update maximum absolute nonzero value */
-         x = psv->value(j);
+      assert(j < psv->size());
 
-         if(spxAbs(x) > initMaxabs)
-            initMaxabs = spxAbs(x);
+      /* basis is singular due to two linearly dependent column singletons */
+      if (row.perm[psv->index(j)] >= 0) {
+        this->stat = SLinSolver<R>::SINGULAR;
+        return;
+      }
 
-         /* permute to front and mark as singleton */
-         setPivot(temp.stage, i, psv->index(j), x);
+      /* update maximum absolute nonzero value */
+      x = psv->value(j);
 
-         sing[temp.stage] = i;
+      if (spxAbs(x) > initMaxabs)
+        initMaxabs = spxAbs(x);
 
-         temp.stage++;
+      /* permute to front and mark as singleton */
+      setPivot(temp.stage, i, psv->index(j), x);
 
-         /* set column length to zero */
-         temp.s_cact[i] = u.col.len[i] = u.col.max[i] = 0;
-      }
+      sing[temp.stage] = i;
 
-      /* add to active matrix if not a column singleton */
-      else
-      {
-         int end;
-         int k;
+      temp.stage++;
 
-         /* go through all nonzeros in column */
-         assert(nnonzeros >= 2);
-         nnonzeros = 0;
+      /* set column length to zero */
+      temp.s_cact[i] = u.col.len[i] = u.col.max[i] = 0;
+    }
 
-         for(int j = 0; j < psv->size(); j++)
-         {
-            x = psv->value(j);
+    /* add to active matrix if not a column singleton */
+    else {
+      int end;
+      int k;
 
-            if(isNotZero(x, eps))
-            {
-               /* add to column array */
-               k = psv->index(j);
-               u.col.idx[m] = k;
-               m++;
+      /* go through all nonzeros in column */
+      assert(nnonzeros >= 2);
+      nnonzeros = 0;
 
-               /* add to row array */
-               end = u.row.start[k] + u.row.len[k];
-               u.row.idx[end] = i;
-               u.row.val[end] = x;
-               u.row.len[k]++;
+      for (int j = 0; j < psv->size(); j++) {
+        x = psv->value(j);
 
-               /* update maximum absolute nonzero value */
+        if (isNotZero(x, eps)) {
+          /* add to column array */
+          k = psv->index(j);
+          u.col.idx[m] = k;
+          m++;
 
-               if(spxAbs(x) > initMaxabs)
-                  initMaxabs = spxAbs(x);
+          /* add to row array */
+          end = u.row.start[k] + u.row.len[k];
+          u.row.idx[end] = i;
+          u.row.val[end] = x;
+          u.row.len[k]++;
 
-               nnonzeros++;
-            }
-         }
+          /* update maximum absolute nonzero value */
 
-         assert(nnonzeros >= 2);
+          if (spxAbs(x) > initMaxabs)
+            initMaxabs = spxAbs(x);
 
-         /* set column length */
-         temp.s_cact[i] = u.col.len[i] = u.col.max[i] = nnonzeros;
+          nnonzeros++;
+        }
       }
-   }
 
-   u.col.used = m;
-}
+      assert(nnonzeros >= 2);
 
+      /* set column length */
+      temp.s_cact[i] = u.col.len[i] = u.col.max[i] = nnonzeros;
+    }
+  }
 
+  u.col.used = m;
+}
 
 /*****************************************************************************/
 /*
  *      Remove column singletons
  */
-template <class R>
-void CLUFactor<R>::colSingletons()
-{
-   int i, j, k, n;
-   int len;
-   int p_col, p_row, newrow;
-   int* idx;
-   int* rorig = row.orig;
-   int* rperm = row.perm;
-   int* sing = temp.s_mark;
-
-
-   /*  Iteratively update column counts due to removed column singletons
-    *  thereby removing new arising columns singletons
-    *  and computing the index of the first row singleton (-1)
-    *  until no more can be found.
-    */
-
-   for(i = 0; i < temp.stage; ++i)
-   {
-      p_row = rorig[i];
-      assert(p_row >= 0);
-      idx = &(u.row.idx[u.row.start[p_row]]);
-      len = u.row.len[p_row];
-
-      for(j = 0; j < len; ++j)
-      {
-         /*  Move pivotal nonzeros to front of column.
-          */
-         p_col = idx[j];
-         assert(temp.s_cact[p_col] > 0);
+template <class R> void CLUFactor<R>::colSingletons() {
+  int i, j, k, n;
+  int len;
+  int p_col, p_row, newrow;
+  int *idx;
+  int *rorig = row.orig;
+  int *rperm = row.perm;
+  int *sing = temp.s_mark;
+
+  /*  Iteratively update column counts due to removed column singletons
+   *  thereby removing new arising columns singletons
+   *  and computing the index of the first row singleton (-1)
+   *  until no more can be found.
+   */
+
+  for (i = 0; i < temp.stage; ++i) {
+    p_row = rorig[i];
+    assert(p_row >= 0);
+    idx = &(u.row.idx[u.row.start[p_row]]);
+    len = u.row.len[p_row];
+
+    for (j = 0; j < len; ++j) {
+      /*  Move pivotal nonzeros to front of column.
+       */
+      p_col = idx[j];
+      assert(temp.s_cact[p_col] > 0);
 
-         n = u.col.start[p_col] + u.col.len[p_col] - temp.s_cact[p_col];
+      n = u.col.start[p_col] + u.col.len[p_col] - temp.s_cact[p_col];
 
-         for(k = n; u.col.idx[k] != p_row; ++k)
-            ;
+      for (k = n; u.col.idx[k] != p_row; ++k)
+        ;
 
-         assert(k < u.col.start[p_col] + u.col.len[p_col]);
+      assert(k < u.col.start[p_col] + u.col.len[p_col]);
 
-         u.col.idx[k] = u.col.idx[n];
+      u.col.idx[k] = u.col.idx[n];
 
-         u.col.idx[n] = p_row;
+      u.col.idx[n] = p_row;
 
-         n = --(temp.s_cact[p_col]);          /* column nonzeros of ACTIVE matrix */
+      n = --(temp.s_cact[p_col]); /* column nonzeros of ACTIVE matrix */
 
-         if(n == 1)                   /* Here is another singleton */
-         {
-            newrow = u.col.idx[--u.col.len[p_col] + u.col.start[p_col]];
+      if (n == 1) /* Here is another singleton */
+      {
+        newrow = u.col.idx[--u.col.len[p_col] + u.col.start[p_col]];
 
-            /*      Ensure, matrix not singular
-             */
+        /*      Ensure, matrix not singular
+         */
 
-            if(rperm[newrow] >= 0)
-            {
-               this->stat = SLinSolver<R>::SINGULAR;
-               return;
-            }
+        if (rperm[newrow] >= 0) {
+          this->stat = SLinSolver<R>::SINGULAR;
+          return;
+        }
 
-            /*      Find singleton in row.
-             */
-            n = u.row.start[newrow] + (--(u.row.len[newrow]));
+        /*      Find singleton in row.
+         */
+        n = u.row.start[newrow] + (--(u.row.len[newrow]));
 
-            for(k = n; u.row.idx[k] != p_col; --k)
-               ;
+        for (k = n; u.row.idx[k] != p_col; --k)
+          ;
 
-            /*      Remove singleton from column.
-             */
-            setPivot(temp.stage, p_col, newrow, u.row.val[k]);
+        /*      Remove singleton from column.
+         */
+        setPivot(temp.stage, p_col, newrow, u.row.val[k]);
 
-            sing[temp.stage++] = p_col;
+        sing[temp.stage++] = p_col;
 
-            /*      Move pivot element to diag.
-             */
-            u.row.val[k] = u.row.val[n];
-
-            u.row.idx[k] = u.row.idx[n];
-         }
-         else if(n == 0)
-         {
-            this->stat = SLinSolver<R>::SINGULAR;
-            return;
-         }
+        /*      Move pivot element to diag.
+         */
+        u.row.val[k] = u.row.val[n];
+
+        u.row.idx[k] = u.row.idx[n];
+      } else if (n == 0) {
+        this->stat = SLinSolver<R>::SINGULAR;
+        return;
       }
-   }
+    }
+  }
 
-   assert(temp.stage <= thedim);
+  assert(temp.stage <= thedim);
 }
 
-
 /*****************************************************************************/
 /*
  *      Remove row singletons
  */
-template <class R>
-void CLUFactor<R>::rowSingletons()
-{
-   R pval;
-   int i, j, k, ll, r;
-   int p_row, p_col, len, rs, lk;
-   int* idx;
-   int* rperm = row.perm;
-   int* sing = temp.s_mark;
-
-   /*  Mark row singletons
-    */
-   rs = temp.stage;
-
-   for(i = 0; i < thedim; ++i)
-   {
-      if(rperm[i] < 0 && u.row.len[i] == 1)
-         sing[temp.stage++] = i;
-   }
-
-   /*  Eliminate row singletons
-    *  thereby marking newly arising ones
-    *  until no more can be found.
-    */
-   for(; rs < temp.stage; ++rs)
-   {
-      /*      Move pivot element from row file to diag
-       */
-      p_row = sing[rs];
-      j = u.row.start[p_row];
-      p_col = u.row.idx[j];
-      pval = u.row.val[j];
-      setPivot(rs, p_col, p_row, pval);
-      u.row.len[p_row] = 0;
-
-      /*      Remove pivot column form workingmatrix
-       *      thereby building up L VectorBase<R>.
-       */
-      idx = &(u.col.idx[u.col.start[p_col]]);
-      i = temp.s_cact[p_col];                /* nr. nonzeros of new L VectorBase<R> */
-      lk = makeLvec(i - 1, p_row);
-      len = u.col.len[p_col];
-      i = (u.col.len[p_col] -= i);         /* remove pivot column from U */
-
-      for(; i < len; ++i)
-      {
-         r = idx[i];
-
-         if(r != p_row)
-         {
-            /*      Find pivot column in row.
-             */
-            ll = --(u.row.len[r]);
-            k = u.row.start[r] + ll;
-
-            for(j = k; u.row.idx[j] != p_col; --j)
-               ;
-
-            assert(k >= u.row.start[r]);
-
-            /*      Initialize L VectorBase<R>
-             */
-            l.idx[lk] = r;
-
-            l.val[lk] = u.row.val[j] / pval;
-
-            ++lk;
-
-            /*      Remove pivot column from row.
-             */
-            u.row.idx[j] = u.row.idx[k];
-
-            u.row.val[j] = u.row.val[k];
-
-            /*      Check new row length.
-             */
-            if(ll == 1)
-               sing[temp.stage++] = r;
-            else if(ll == 0)
-            {
-               this->stat = SLinSolver<R>::SINGULAR;
-               return;
-            }
-         }
+template <class R> void CLUFactor<R>::rowSingletons() {
+  R pval;
+  int i, j, k, ll, r;
+  int p_row, p_col, len, rs, lk;
+  int *idx;
+  int *rperm = row.perm;
+  int *sing = temp.s_mark;
+
+  /*  Mark row singletons
+   */
+  rs = temp.stage;
+
+  for (i = 0; i < thedim; ++i) {
+    if (rperm[i] < 0 && u.row.len[i] == 1)
+      sing[temp.stage++] = i;
+  }
+
+  /*  Eliminate row singletons
+   *  thereby marking newly arising ones
+   *  until no more can be found.
+   */
+  for (; rs < temp.stage; ++rs) {
+    /*      Move pivot element from row file to diag
+     */
+    p_row = sing[rs];
+    j = u.row.start[p_row];
+    p_col = u.row.idx[j];
+    pval = u.row.val[j];
+    setPivot(rs, p_col, p_row, pval);
+    u.row.len[p_row] = 0;
+
+    /*      Remove pivot column form workingmatrix
+     *      thereby building up L VectorBase<R>.
+     */
+    idx = &(u.col.idx[u.col.start[p_col]]);
+    i = temp.s_cact[p_col]; /* nr. nonzeros of new L VectorBase<R> */
+    lk = makeLvec(i - 1, p_row);
+    len = u.col.len[p_col];
+    i = (u.col.len[p_col] -= i); /* remove pivot column from U */
+
+    for (; i < len; ++i) {
+      r = idx[i];
+
+      if (r != p_row) {
+        /*      Find pivot column in row.
+         */
+        ll = --(u.row.len[r]);
+        k = u.row.start[r] + ll;
+
+        for (j = k; u.row.idx[j] != p_col; --j)
+          ;
+
+        assert(k >= u.row.start[r]);
+
+        /*      Initialize L VectorBase<R>
+         */
+        l.idx[lk] = r;
+
+        l.val[lk] = u.row.val[j] / pval;
+
+        ++lk;
+
+        /*      Remove pivot column from row.
+         */
+        u.row.idx[j] = u.row.idx[k];
+
+        u.row.val[j] = u.row.val[k];
+
+        /*      Check new row length.
+         */
+        if (ll == 1)
+          sing[temp.stage++] = r;
+        else if (ll == 0) {
+          this->stat = SLinSolver<R>::SINGULAR;
+          return;
+        }
       }
-   }
+    }
+  }
 }
 
-
 /*****************************************************************************/
 /*
  *      Init nonzero number Ring lists
  *      and required entries of arrays max and mark
  */
 
-template <class R>
-void CLUFactor<R>::initFactorRings()
-{
-   int i;
-   int* rperm = row.perm;
-   int* cperm = col.perm;
-   CLUFactor<R>::Pring* ring;
-
-   assert(thedim >= 0);
-   spx_alloc(temp.pivot_col,   thedim + 1);
-   spx_alloc(temp.pivot_colNZ, thedim + 1);
-   spx_alloc(temp.pivot_row,   thedim + 1);
-   spx_alloc(temp.pivot_rowNZ, thedim + 1);
-
-   for(i = thedim - temp.stage; i >= 0; --i)
-   {
-      initDR(temp.pivot_colNZ[i]);
-      initDR(temp.pivot_rowNZ[i]);
-   }
+template <class R> void CLUFactor<R>::initFactorRings() {
+  int i;
+  int *rperm = row.perm;
+  int *cperm = col.perm;
+  CLUFactor<R>::Pring *ring;
+
+  assert(thedim >= 0);
+  spx_alloc(temp.pivot_col, thedim + 1);
+  spx_alloc(temp.pivot_colNZ, thedim + 1);
+  spx_alloc(temp.pivot_row, thedim + 1);
+  spx_alloc(temp.pivot_rowNZ, thedim + 1);
+
+  for (i = thedim - temp.stage; i >= 0; --i) {
+    initDR(temp.pivot_colNZ[i]);
+    initDR(temp.pivot_rowNZ[i]);
+  }
+
+  for (i = 0; i < thedim; ++i) {
+    if (rperm[i] < 0) {
+      if (u.row.len[i] <= 0) {
+        this->stat = SLinSolver<R>::SINGULAR;
+        return;
+      }
 
-   for(i = 0; i < thedim; ++i)
-   {
-      if(rperm[i] < 0)
-      {
-         if(u.row.len[i] <= 0)
-         {
-            this->stat = SLinSolver<R>::SINGULAR;
-            return;
-         }
+      ring = &(temp.pivot_rowNZ[u.row.len[i]]);
 
-         ring = &(temp.pivot_rowNZ[u.row.len[i]]);
+      init2DR(temp.pivot_row[i], *ring);
+      temp.pivot_row[i].idx = i;
+      temp.s_max[i] = -1;
+    }
 
-         init2DR(temp.pivot_row[i], *ring);
-         temp.pivot_row[i].idx = i;
-         temp.s_max[i] = -1;
+    if (cperm[i] < 0) {
+      if (temp.s_cact[i] <= 0) {
+        this->stat = SLinSolver<R>::SINGULAR;
+        return;
       }
 
-      if(cperm[i] < 0)
-      {
-         if(temp.s_cact[i] <= 0)
-         {
-            this->stat = SLinSolver<R>::SINGULAR;
-            return;
-         }
-
-         ring = &(temp.pivot_colNZ[temp.s_cact[i]]);
+      ring = &(temp.pivot_colNZ[temp.s_cact[i]]);
 
-         init2DR(temp.pivot_col[i], *ring);
-         temp.pivot_col[i].idx = i;
-         temp.s_mark[i] = 0;
-      }
-   }
+      init2DR(temp.pivot_col[i], *ring);
+      temp.pivot_col[i].idx = i;
+      temp.s_mark[i] = 0;
+    }
+  }
 }
 
-template <class R>
-void CLUFactor<R>::freeFactorRings(void)
-{
+template <class R> void CLUFactor<R>::freeFactorRings(void) {
 
-   if(temp.pivot_col)
-      spx_free(temp.pivot_col);
+  if (temp.pivot_col)
+    spx_free(temp.pivot_col);
 
-   if(temp.pivot_colNZ)
-      spx_free(temp.pivot_colNZ);
+  if (temp.pivot_colNZ)
+    spx_free(temp.pivot_colNZ);
 
-   if(temp.pivot_row)
-      spx_free(temp.pivot_row);
+  if (temp.pivot_row)
+    spx_free(temp.pivot_row);
 
-   if(temp.pivot_rowNZ)
-      spx_free(temp.pivot_rowNZ);
+  if (temp.pivot_rowNZ)
+    spx_free(temp.pivot_rowNZ);
 }
 
-
 /*
  *      Eliminate all row singletons from nucleus.
  *      A row singleton may well be column singleton at the same time!
  */
-template <class R>
-void CLUFactor<R>::eliminateRowSingletons()
-{
-   int i, j, k, ll, r;
-   int len, lk;
-   int pcol, prow;
-   R pval;
-   int* idx;
-   CLUFactor<R>::Pring* sing;
-
-   for(sing = temp.pivot_rowNZ[1].prev; sing != &(temp.pivot_rowNZ[1]); sing = sing->prev)
-   {
-      prow = sing->idx;
-      i = u.row.start[prow];
-      pcol = u.row.idx[i];
-      pval = u.row.val[i];
-      setPivot(temp.stage++, pcol, prow, pval);
-      u.row.len[prow] = 0;
-      removeDR(temp.pivot_col[pcol]);
-
-      /*      Eliminate pivot column and build L VectorBase<R>.
-       */
-      i = temp.s_cact[pcol];
+template <class R> void CLUFactor<R>::eliminateRowSingletons() {
+  int i, j, k, ll, r;
+  int len, lk;
+  int pcol, prow;
+  R pval;
+  int *idx;
+  CLUFactor<R>::Pring *sing;
 
-      if(i > 1)
-      {
-         idx = &(u.col.idx[u.col.start[pcol]]);
-         len = u.col.len[pcol];
-         lk = makeLvec(i - 1, prow);
-         i = u.col.len[pcol] -= i;
-
-         for(; (r = idx[i]) != prow; ++i)
-         {
-            /*      Find pivot column in row.
-             */
-            ll = --(u.row.len[r]);
-            k = u.row.start[r] + ll;
+  for (sing = temp.pivot_rowNZ[1].prev; sing != &(temp.pivot_rowNZ[1]);
+       sing = sing->prev) {
+    prow = sing->idx;
+    i = u.row.start[prow];
+    pcol = u.row.idx[i];
+    pval = u.row.val[i];
+    setPivot(temp.stage++, pcol, prow, pval);
+    u.row.len[prow] = 0;
+    removeDR(temp.pivot_col[pcol]);
 
-            for(j = k; u.row.idx[j] != pcol; --j)
-               ;
+    /*      Eliminate pivot column and build L VectorBase<R>.
+     */
+    i = temp.s_cact[pcol];
 
-            assert(j >= u.row.start[r]);
+    if (i > 1) {
+      idx = &(u.col.idx[u.col.start[pcol]]);
+      len = u.col.len[pcol];
+      lk = makeLvec(i - 1, prow);
+      i = u.col.len[pcol] -= i;
 
-            /*      Initialize L VectorBase<R>
-             */
-            l.idx[lk] = r;
+      for (; (r = idx[i]) != prow; ++i) {
+        /*      Find pivot column in row.
+         */
+        ll = --(u.row.len[r]);
+        k = u.row.start[r] + ll;
 
-            l.val[lk] = u.row.val[j] / pval;
+        for (j = k; u.row.idx[j] != pcol; --j)
+          ;
 
-            ++lk;
+        assert(j >= u.row.start[r]);
 
-            /*      Remove pivot column from row.
-             */
-            u.row.idx[j] = u.row.idx[k];
+        /*      Initialize L VectorBase<R>
+         */
+        l.idx[lk] = r;
 
-            u.row.val[j] = u.row.val[k];
+        l.val[lk] = u.row.val[j] / pval;
 
-            /*      Move column to appropriate nonzero ring.
-             */
-            removeDR(temp.pivot_row[r]);
+        ++lk;
 
-            init2DR(temp.pivot_row[r], temp.pivot_rowNZ[ll]);
+        /*      Remove pivot column from row.
+         */
+        u.row.idx[j] = u.row.idx[k];
 
-            assert(row.perm[r] < 0);
+        u.row.val[j] = u.row.val[k];
 
-            temp.s_max[r] = -1;
-         }
+        /*      Move column to appropriate nonzero ring.
+         */
+        removeDR(temp.pivot_row[r]);
 
-         /* skip pivot element */
-         assert(i < len && "ERROR: pivot column does not contain pivot row");
+        init2DR(temp.pivot_row[r], temp.pivot_rowNZ[ll]);
 
-         for(++i; i < len; ++i)
-         {
-            /*      Find pivot column in row.
-             */
-            r = idx[i];
-            ll = --(u.row.len[r]);
-            k = u.row.start[r] + ll;
+        assert(row.perm[r] < 0);
 
-            for(j = k; u.row.idx[j] != pcol; --j)
-               ;
+        temp.s_max[r] = -1;
+      }
 
-            assert(j >= u.row.start[r]);
+      /* skip pivot element */
+      assert(i < len && "ERROR: pivot column does not contain pivot row");
 
-            /*      Initialize L VectorBase<R>
-             */
-            l.idx[lk] = r;
+      for (++i; i < len; ++i) {
+        /*      Find pivot column in row.
+         */
+        r = idx[i];
+        ll = --(u.row.len[r]);
+        k = u.row.start[r] + ll;
 
-            l.val[lk] = u.row.val[j] / pval;
+        for (j = k; u.row.idx[j] != pcol; --j)
+          ;
 
-            ++lk;
+        assert(j >= u.row.start[r]);
 
-            /*      Remove pivot column from row.
-             */
-            u.row.idx[j] = u.row.idx[k];
+        /*      Initialize L VectorBase<R>
+         */
+        l.idx[lk] = r;
 
-            u.row.val[j] = u.row.val[k];
+        l.val[lk] = u.row.val[j] / pval;
 
-            /*      Move column to appropriate nonzero ring.
-             */
-            removeDR(temp.pivot_row[r]);
+        ++lk;
 
-            init2DR(temp.pivot_row[r], temp.pivot_rowNZ[ll]);
+        /*      Remove pivot column from row.
+         */
+        u.row.idx[j] = u.row.idx[k];
 
-            assert(row.perm[r] < 0);
+        u.row.val[j] = u.row.val[k];
 
-            temp.s_max[r] = -1;
-         }
-      }
-      else
-         u.col.len[pcol] -= i;
-   }
+        /*      Move column to appropriate nonzero ring.
+         */
+        removeDR(temp.pivot_row[r]);
 
-   initDR(temp.pivot_rowNZ[1]);    /* Remove all row singletons from list */
-}
+        init2DR(temp.pivot_row[r], temp.pivot_rowNZ[ll]);
+
+        assert(row.perm[r] < 0);
 
+        temp.s_max[r] = -1;
+      }
+    } else
+      u.col.len[pcol] -= i;
+  }
 
+  initDR(temp.pivot_rowNZ[1]); /* Remove all row singletons from list */
+}
 
 /*
  *      Eliminate all column singletons from nucleus.
  *      A column singleton must not be row singleton at the same time!
  */
-template <class R>
-void CLUFactor<R>::eliminateColSingletons()
-{
-   int i, j, k, m, c;
-   int pcol, prow;
-   CLUFactor<R>::Pring* sing;
-
-   for(sing = temp.pivot_colNZ[1].prev;
-         sing != &(temp.pivot_colNZ[1]);
-         sing = sing->prev)
-   {
-      /*      Find pivot value
-       */
-      pcol = sing->idx;
-      j = --(u.col.len[pcol]) + u.col.start[pcol];   /* remove pivot column */
-      prow = u.col.idx[j];
-      removeDR(temp.pivot_row[prow]);
+template <class R> void CLUFactor<R>::eliminateColSingletons() {
+  int i, j, k, m, c;
+  int pcol, prow;
+  CLUFactor<R>::Pring *sing;
 
-      j = --(u.row.len[prow]) + u.row.start[prow];
+  for (sing = temp.pivot_colNZ[1].prev; sing != &(temp.pivot_colNZ[1]);
+       sing = sing->prev) {
+    /*      Find pivot value
+     */
+    pcol = sing->idx;
+    j = --(u.col.len[pcol]) + u.col.start[pcol]; /* remove pivot column */
+    prow = u.col.idx[j];
+    removeDR(temp.pivot_row[prow]);
 
-      for(i = j; (c = u.row.idx[i]) != pcol; --i)
-      {
-         m = u.col.len[c] + u.col.start[c] - (temp.s_cact[c])--;
+    j = --(u.row.len[prow]) + u.row.start[prow];
 
-         for(k = m; u.col.idx[k] != prow; ++k)
-            ;
+    for (i = j; (c = u.row.idx[i]) != pcol; --i) {
+      m = u.col.len[c] + u.col.start[c] - (temp.s_cact[c])--;
 
-         u.col.idx[k] = u.col.idx[m];
+      for (k = m; u.col.idx[k] != prow; ++k)
+        ;
 
-         u.col.idx[m] = prow;
+      u.col.idx[k] = u.col.idx[m];
 
-         m = temp.s_cact[c];
+      u.col.idx[m] = prow;
 
-         removeDR(temp.pivot_col[c]);
+      m = temp.s_cact[c];
 
-         init2DR(temp.pivot_col[c], temp.pivot_colNZ[m]);
+      removeDR(temp.pivot_col[c]);
 
-         assert(col.perm[c] < 0);
-      }
+      init2DR(temp.pivot_col[c], temp.pivot_colNZ[m]);
 
-      /*      remove pivot element from pivot row
-       */
-      setPivot(temp.stage++, pcol, prow, u.row.val[i]);
+      assert(col.perm[c] < 0);
+    }
 
-      u.row.idx[i] = u.row.idx[j];
+    /*      remove pivot element from pivot row
+     */
+    setPivot(temp.stage++, pcol, prow, u.row.val[i]);
 
-      u.row.val[i] = u.row.val[j];
+    u.row.idx[i] = u.row.idx[j];
 
-      j = u.row.start[prow];
+    u.row.val[i] = u.row.val[j];
 
-      for(--i; i >= j; --i)
-      {
-         c = u.row.idx[i];
-         m = u.col.len[c] + u.col.start[c] - (temp.s_cact[c])--;
+    j = u.row.start[prow];
 
-         for(k = m; u.col.idx[k] != prow; ++k)
-            ;
+    for (--i; i >= j; --i) {
+      c = u.row.idx[i];
+      m = u.col.len[c] + u.col.start[c] - (temp.s_cact[c])--;
 
-         u.col.idx[k] = u.col.idx[m];
+      for (k = m; u.col.idx[k] != prow; ++k)
+        ;
 
-         u.col.idx[m] = prow;
+      u.col.idx[k] = u.col.idx[m];
 
-         m = temp.s_cact[c];
+      u.col.idx[m] = prow;
 
-         removeDR(temp.pivot_col[c]);
+      m = temp.s_cact[c];
 
-         init2DR(temp.pivot_col[c], temp.pivot_colNZ[m]);
+      removeDR(temp.pivot_col[c]);
 
-         assert(col.perm[c] < 0);
-      }
-   }
+      init2DR(temp.pivot_col[c], temp.pivot_colNZ[m]);
 
-   initDR(temp.pivot_colNZ[1]);    /* Remove all column singletons from list */
+      assert(col.perm[c] < 0);
+    }
+  }
+
+  initDR(temp.pivot_colNZ[1]); /* Remove all column singletons from list */
 }
 
 /*
  * No singletons available: Select pivot elements.
  */
-template <class R>
-void CLUFactor<R>::selectPivots(R threshold)
-{
-   int ii;
-   int i;
-   int j;
-   int k;
-   int ll = -1; // This value should never be used.
-   int kk;
-   int m;
-   int count;
-   int num;
-   int rw = -1; // This value should never be used.
-   int cl = -1; // This value should never be used.
-   int len;
-   int beg;
-   R l_maxabs;
-   R x = R(0.0);   // This value should never be used.
-   int mkwtz;
-   int candidates;
-
-   candidates = thedim - temp.stage - 1;
-
-   if(candidates > 4)
-      candidates = 4;
-
-   num = 0;
-
-   count = 2;
-
-   for(;;)
-   {
-      ii = -1;
-
-      if(temp.pivot_rowNZ[count].next != &(temp.pivot_rowNZ[count]))
-      {
-         rw = temp.pivot_rowNZ[count].next->idx;
-         beg = u.row.start[rw];
-         len = u.row.len[rw] + beg - 1;
+template <class R> void CLUFactor<R>::selectPivots(R threshold) {
+  int ii;
+  int i;
+  int j;
+  int k;
+  int ll = -1; // This value should never be used.
+  int kk;
+  int m;
+  int count;
+  int num;
+  int rw = -1; // This value should never be used.
+  int cl = -1; // This value should never be used.
+  int len;
+  int beg;
+  R l_maxabs;
+  R x = R(0.0); // This value should never be used.
+  int mkwtz;
+  int candidates;
+
+  candidates = thedim - temp.stage - 1;
+
+  if (candidates > 4)
+    candidates = 4;
+
+  num = 0;
+
+  count = 2;
+
+  for (;;) {
+    ii = -1;
+
+    if (temp.pivot_rowNZ[count].next != &(temp.pivot_rowNZ[count])) {
+      rw = temp.pivot_rowNZ[count].next->idx;
+      beg = u.row.start[rw];
+      len = u.row.len[rw] + beg - 1;
+
+      /*  set l_maxabs to maximum absolute value in row
+       *  (compute it if necessary).
+       */
 
-         /*  set l_maxabs to maximum absolute value in row
-          *  (compute it if necessary).
-          */
+      if ((l_maxabs = temp.s_max[rw]) < 0) {
+        l_maxabs = spxAbs(u.row.val[len]);
 
-         if((l_maxabs = temp.s_max[rw]) < 0)
-         {
-            l_maxabs = spxAbs(u.row.val[len]);
+        for (i = len - 1; i >= beg; --i)
+          if (l_maxabs < spxAbs(u.row.val[i]))
+            l_maxabs = spxAbs(u.row.val[i]);
+
+        temp.s_max[rw] = l_maxabs; /* ##### */
+      }
 
-            for(i = len - 1; i >= beg; --i)
-               if(l_maxabs < spxAbs(u.row.val[i]))
-                  l_maxabs = spxAbs(u.row.val[i]);
+      l_maxabs *= threshold;
 
-            temp.s_max[rw] = l_maxabs;               /* ##### */
-         }
+      /*  select pivot element with lowest markowitz number in row
+       */
+      mkwtz = thedim + 1;
 
-         l_maxabs *= threshold;
+      for (i = len; i >= beg; --i) {
+        k = u.row.idx[i];
+        j = temp.s_cact[k];
+        x = u.row.val[i];
 
-         /*  select pivot element with lowest markowitz number in row
-          */
-         mkwtz = thedim + 1;
+        if (j < mkwtz && spxAbs(x) > l_maxabs) {
+          mkwtz = j;
+          cl = k;
+          ii = i;
 
-         for(i = len; i >= beg; --i)
-         {
-            k = u.row.idx[i];
-            j = temp.s_cact[k];
-            x = u.row.val[i];
+          if (j <= count) /* ##### */
+            break;
+        }
+      }
+    } else if (temp.pivot_colNZ[count].next != &(temp.pivot_colNZ[count])) {
+      cl = temp.pivot_colNZ[count].next->idx;
+      beg = u.col.start[cl];
+      len = u.col.len[cl] + beg - 1;
+      beg = len - temp.s_cact[cl] + 1;
+      assert(count == temp.s_cact[cl]);
+
+      /*  select pivot element with lowest markowitz number in column
+       */
+      mkwtz = thedim + 1;
 
-            if(j < mkwtz && spxAbs(x) > l_maxabs)
-            {
-               mkwtz = j;
-               cl = k;
-               ii = i;
+      for (i = len; i >= beg; --i) {
+        k = u.col.idx[i];
+        j = u.row.len[k];
 
-               if(j <= count)               /* ##### */
-                  break;
+        if (j < mkwtz) {
+          /*  ensure that element (cl,k) is stable.
+           */
+          if (temp.s_max[k] > 0) {
+            /*  case 1: l_maxabs is known
+             */
+            for (m = u.row.start[k], kk = m + u.row.len[k] - 1; kk >= m; --kk) {
+              if (u.row.idx[kk] == cl) {
+                x = u.row.val[kk];
+                ll = kk;
+                break;
+              }
             }
-         }
-      }
-      else if(temp.pivot_colNZ[count].next != &(temp.pivot_colNZ[count]))
-      {
-         cl = temp.pivot_colNZ[count].next->idx;
-         beg = u.col.start[cl];
-         len = u.col.len[cl] + beg - 1;
-         beg = len - temp.s_cact[cl] + 1;
-         assert(count == temp.s_cact[cl]);
-
-         /*  select pivot element with lowest markowitz number in column
-          */
-         mkwtz = thedim + 1;
-
-         for(i = len; i >= beg; --i)
-         {
-            k = u.col.idx[i];
-            j = u.row.len[k];
-
-            if(j < mkwtz)
-            {
-               /*  ensure that element (cl,k) is stable.
-                */
-               if(temp.s_max[k] > 0)
-               {
-                  /*  case 1: l_maxabs is known
-                   */
-                  for(m = u.row.start[k], kk = m + u.row.len[k] - 1;
-                        kk >= m; --kk)
-                  {
-                     if(u.row.idx[kk] == cl)
-                     {
-                        x = u.row.val[kk];
-                        ll = kk;
-                        break;
-                     }
-                  }
-
-                  l_maxabs = temp.s_max[k];
-               }
-               else
-               {
-                  /*  case 2: l_maxabs needs to be computed
-                   */
-                  m = u.row.start[k];
-                  l_maxabs = spxAbs(u.row.val[m]);
-
-                  for(kk = m + u.row.len[k] - 1; kk >= m; --kk)
-                  {
-                     if(l_maxabs < spxAbs(u.row.val[kk]))
-                        l_maxabs = spxAbs(u.row.val[kk]);
-
-                     if(u.row.idx[kk] == cl)
-                     {
-                        x = u.row.val[kk];
-                        ll = kk;
-                        break;
-                     }
-                  }
-
-                  for(--kk; kk > m; --kk)
-                  {
-                     if(l_maxabs < spxAbs(u.row.val[kk]))
-                        l_maxabs = spxAbs(u.row.val[kk]);
-                  }
-
-                  temp.s_max[k] = l_maxabs;
-               }
-
-               l_maxabs *= threshold;
-
-               if(spxAbs(x) > l_maxabs)
-               {
-                  mkwtz = j;
-                  rw = k;
-                  ii = ll;
-
-                  if(j <= count + 1)
-                     break;
-               }
+
+            l_maxabs = temp.s_max[k];
+          } else {
+            /*  case 2: l_maxabs needs to be computed
+             */
+            m = u.row.start[k];
+            l_maxabs = spxAbs(u.row.val[m]);
+
+            for (kk = m + u.row.len[k] - 1; kk >= m; --kk) {
+              if (l_maxabs < spxAbs(u.row.val[kk]))
+                l_maxabs = spxAbs(u.row.val[kk]);
+
+              if (u.row.idx[kk] == cl) {
+                x = u.row.val[kk];
+                ll = kk;
+                break;
+              }
             }
-         }
-      }
-      else
-      {
-         ++count;
-         continue;
+
+            for (--kk; kk > m; --kk) {
+              if (l_maxabs < spxAbs(u.row.val[kk]))
+                l_maxabs = spxAbs(u.row.val[kk]);
+            }
+
+            temp.s_max[k] = l_maxabs;
+          }
+
+          l_maxabs *= threshold;
+
+          if (spxAbs(x) > l_maxabs) {
+            mkwtz = j;
+            rw = k;
+            ii = ll;
+
+            if (j <= count + 1)
+              break;
+          }
+        }
       }
+    } else {
+      ++count;
+      continue;
+    }
 
-      assert(cl >= 0);
+    assert(cl >= 0);
 
-      removeDR(temp.pivot_col[cl]);
-      initDR(temp.pivot_col[cl]);
+    removeDR(temp.pivot_col[cl]);
+    initDR(temp.pivot_col[cl]);
 
-      if(ii >= 0)
-      {
-         /*  Initialize selected pivot element
-          */
-         CLUFactor<R>::Pring* pr;
-         temp.pivot_row[rw].pos = ii - u.row.start[rw];
-         temp.pivot_row[rw].mkwtz = mkwtz = (mkwtz - 1) * (count - 1);
-         // ??? mkwtz originally was long,
-         // maybe to avoid an overflow in this instruction?
-
-         for(pr = temp.pivots.next; pr->idx >= 0; pr = pr->next)
-         {
-            if(pr->idx == rw || pr->mkwtz >= mkwtz)
-               break;
-         }
-
-         pr = pr->prev;
-
-         if(pr->idx != rw)
-         {
-            removeDR(temp.pivot_row[rw]);
-            init2DR(temp.pivot_row[rw], *pr);
-         }
-
-         num++;
-
-         if(num >= candidates)
-            break;
+    if (ii >= 0) {
+      /*  Initialize selected pivot element
+       */
+      CLUFactor<R>::Pring *pr;
+      temp.pivot_row[rw].pos = ii - u.row.start[rw];
+      temp.pivot_row[rw].mkwtz = mkwtz = (mkwtz - 1) * (count - 1);
+      // ??? mkwtz originally was long,
+      // maybe to avoid an overflow in this instruction?
+
+      for (pr = temp.pivots.next; pr->idx >= 0; pr = pr->next) {
+        if (pr->idx == rw || pr->mkwtz >= mkwtz)
+          break;
       }
-   }
 
-   /*
-    *     while(temp.temp.next->mkwtz < temp.temp.prev->mkwtz)
-    *     {
-    *     Pring   *pr;
-    *     pr = temp.temp.prev;
-    *     removeDR(*pr);
-    *     init2DR (*pr, rowNZ[u.row.len[pr->idx]]);
+      pr = pr->prev;
+
+      if (pr->idx != rw) {
+        removeDR(temp.pivot_row[rw]);
+        init2DR(temp.pivot_row[rw], *pr);
+      }
+
+      num++;
+
+      if (num >= candidates)
+        break;
     }
-    */
+  }
+
+  /*
+   *     while(temp.temp.next->mkwtz < temp.temp.prev->mkwtz)
+   *     {
+   *     Pring   *pr;
+   *     pr = temp.temp.prev;
+   *     removeDR(*pr);
+   *     init2DR (*pr, rowNZ[u.row.len[pr->idx]]);
+   }
+   */
 
-   assert(row.perm[rw] < 0);
+  assert(row.perm[rw] < 0);
 
-   assert(col.perm[cl] < 0);
+  assert(col.perm[cl] < 0);
 }
 
-
 /*
  *      Perform L and update loop for row r
  */
 template <class R>
-int CLUFactor<R>::updateRow(int r,
-                            int lv,
-                            int prow,
-                            int pcol,
-                            R pval,
-                            R eps)
-{
-   int fill;
-   R x, lx;
-   int c, i, j, k, ll, m, n;
+int CLUFactor<R>::updateRow(int r, int lv, int prow, int pcol, R pval, R eps) {
+  int fill;
+  R x, lx;
+  int c, i, j, k, ll, m, n;
 
-   n = u.row.start[r];
-   m = --(u.row.len[r]) + n;
+  n = u.row.start[r];
+  m = --(u.row.len[r]) + n;
 
-   /*  compute L VectorBase<R> entry and
-    *  and remove pivot column form row file
-    */
+  /*  compute L VectorBase<R> entry and
+   *  and remove pivot column form row file
+   */
 
-   for(j = m; u.row.idx[j] != pcol; --j)
-      ;
+  for (j = m; u.row.idx[j] != pcol; --j)
+    ;
 
-   lx = u.row.val[j] / pval;
+  lx = u.row.val[j] / pval;
 
-   l.val[lv] = lx;
+  l.val[lv] = lx;
 
-   l.idx[lv] = r;
+  l.idx[lv] = r;
 
-   ++lv;
+  ++lv;
 
-   u.row.idx[j] = u.row.idx[m];
+  u.row.idx[j] = u.row.idx[m];
 
-   u.row.val[j] = u.row.val[m];
+  u.row.val[j] = u.row.val[m];
 
+  /*  update loop (I) and
+   *  computing expected fill
+   */
+  fill = u.row.len[prow];
 
-   /*  update loop (I) and
-    *  computing expected fill
-    */
-   fill = u.row.len[prow];
+  for (j = m - 1; j >= n; --j) {
+    c = u.row.idx[j];
 
-   for(j = m - 1; j >= n; --j)
-   {
-      c = u.row.idx[j];
+    if (temp.s_mark[c]) {
+      /*  count fill elements.
+       */
+      temp.s_mark[c] = 0;
+      --fill;
 
-      if(temp.s_mark[c])
-      {
-         /*  count fill elements.
-          */
-         temp.s_mark[c] = 0;
-         --fill;
-
-         /*  update row values
-          */
-         x = u.row.val[j] -= work[c] * lx;
-
-         if(isZero(x, eps))
-         {
-            /* Eliminate zero from row r
-             */
-            --u.row.len[r];
-            --m;
-            u.row.val[j] = u.row.val[m];
-            u.row.idx[j] = u.row.idx[m];
+      /*  update row values
+       */
+      x = u.row.val[j] -= work[c] * lx;
 
-            /* Eliminate zero from column c
-             */
-            --(temp.s_cact[c]);
-            k = --(u.col.len[c]) + u.col.start[c];
+      if (isZero(x, eps)) {
+        /* Eliminate zero from row r
+         */
+        --u.row.len[r];
+        --m;
+        u.row.val[j] = u.row.val[m];
+        u.row.idx[j] = u.row.idx[m];
 
-            for(i = k; u.col.idx[i] != r; --i)
-               ;
+        /* Eliminate zero from column c
+         */
+        --(temp.s_cact[c]);
+        k = --(u.col.len[c]) + u.col.start[c];
 
-            u.col.idx[i] = u.col.idx[k];
-         }
-      }
-   }
+        for (i = k; u.col.idx[i] != r; --i)
+          ;
 
+        u.col.idx[i] = u.col.idx[k];
+      }
+    }
+  }
 
-   /*  create space for fill in row file
-    */
-   ll = u.row.len[r];
+  /*  create space for fill in row file
+   */
+  ll = u.row.len[r];
 
-   if(ll + fill > u.row.max[r])
-      remaxRow(r, ll + fill);
+  if (ll + fill > u.row.max[r])
+    remaxRow(r, ll + fill);
 
-   ll += u.row.start[r];
+  ll += u.row.start[r];
 
-   /*  fill creating update loop (II)
-    */
-   for(j = u.row.start[prow], m = j + u.row.len[prow]; j < m; ++j)
-   {
-      c = u.row.idx[j];
+  /*  fill creating update loop (II)
+   */
+  for (j = u.row.start[prow], m = j + u.row.len[prow]; j < m; ++j) {
+    c = u.row.idx[j];
 
-      if(temp.s_mark[c])
-      {
-         x = - work[c] * lx;
+    if (temp.s_mark[c]) {
+      x = -work[c] * lx;
 
-         if(isNotZero(x, eps))
-         {
-            /* produce fill element in row r
-             */
-            u.row.val[ll] = x;
-            u.row.idx[ll] = c;
-            ll++;
-            u.row.len[r]++;
+      if (isNotZero(x, eps)) {
+        /* produce fill element in row r
+         */
+        u.row.val[ll] = x;
+        u.row.idx[ll] = c;
+        ll++;
+        u.row.len[r]++;
 
-            /* produce fill element in column c
-             */
+        /* produce fill element in column c
+         */
 
-            if(u.col.len[c] >= u.col.max[c])
-               remaxCol(c, u.col.len[c] + 1);
+        if (u.col.len[c] >= u.col.max[c])
+          remaxCol(c, u.col.len[c] + 1);
 
-            u.col.idx[u.col.start[c] + (u.col.len[c])++] = r;
+        u.col.idx[u.col.start[c] + (u.col.len[c])++] = r;
 
-            temp.s_cact[c]++;
-         }
+        temp.s_cact[c]++;
       }
-      else
-         temp.s_mark[c] = 1;
-   }
+    } else
+      temp.s_mark[c] = 1;
+  }
 
-   /*  move row to appropriate list.
-    */
-   removeDR(temp.pivot_row[r]);
+  /*  move row to appropriate list.
+   */
+  removeDR(temp.pivot_row[r]);
 
-   init2DR(temp.pivot_row[r], temp.pivot_rowNZ[u.row.len[r]]);
+  init2DR(temp.pivot_row[r], temp.pivot_rowNZ[u.row.len[r]]);
 
-   assert(row.perm[r] < 0);
+  assert(row.perm[r] < 0);
 
-   temp.s_max[r] = -1;
+  temp.s_max[r] = -1;
 
-   return lv;
+  return lv;
 }
 
 /*
  *      Eliminate pivot element
  */
-template <class R>
-void CLUFactor<R>::eliminatePivot(int prow, int pos, R eps)
-{
-   int i, j, k, m = -1;
-   int lv = -1;  // This value should never be used.
-   int pcol;
-   R pval;
-   int pbeg = u.row.start[prow];
-   int plen = --(u.row.len[prow]);
-   int pend = pbeg + plen;
-
-
-   /*  extract pivot element   */
-   i = pbeg + pos;
-   pcol = u.row.idx[i];
-   pval = u.row.val[i];
-   removeDR(temp.pivot_col[pcol]);
-   initDR(temp.pivot_col[pcol]);
-
-   /*  remove pivot from pivot row     */
-   u.row.idx[i] = u.row.idx[pend];
-   u.row.val[i] = u.row.val[pend];
-
-   /*  set pivot element and construct L VectorBase<R> */
-   setPivot(temp.stage++, pcol, prow, pval);
-
-   /**@todo If this test failes, lv has no value. I suppose that in this
-    *       case none of the loops below that uses lv is executed.
-    *       But this is unproven.
-    */
-
-   if(temp.s_cact[pcol] - 1 > 0)
-      lv = makeLvec(temp.s_cact[pcol] - 1, prow);
-
-   /*  init working VectorBase<R>,
-    *  remove pivot row from working matrix
-    *  and remove columns from list.
-    */
-   for(i = pbeg; i < pend; ++i)
-   {
-      j = u.row.idx[i];
-      temp.s_mark[j] = 1;
-      work[j] = u.row.val[i];
-      removeDR(temp.pivot_col[j]);
-      m = u.col.start[j] + u.col.len[j] - temp.s_cact[j];
-
-      for(k = m; u.col.idx[k] != prow; ++k)
-         ;
-
-      u.col.idx[k] = u.col.idx[m];
-
-      u.col.idx[m] = prow;
-
-      temp.s_cact[j]--;
-   }
-
-   /*  perform L and update loop
-    */
-   for(i = u.col.len[pcol] - temp.s_cact[pcol];
-         (m = u.col.idx[u.col.start[pcol] + i]) != prow;
-         ++i)
-   {
-      assert(row.perm[m] < 0);
-      assert(lv >= 0);
-      /* coverity[negative_returns] */
-      updateRow(m, lv++, prow, pcol, pval, eps);
-   }
-
-   /*  skip pivot row  */
-
-   m = u.col.len[pcol];
-
-   for(++i; i < m; ++i)
-   {
-      assert(lv >= 0);
-      /* coverity[negative_returns] */
-      updateRow(u.col.idx[u.col.start[pcol] + i], lv++, prow, pcol, pval, eps);
-   }
+template <class R> void CLUFactor<R>::eliminatePivot(int prow, int pos, R eps) {
+  int i, j, k, m = -1;
+  int lv = -1; // This value should never be used.
+  int pcol;
+  R pval;
+  int pbeg = u.row.start[prow];
+  int plen = --(u.row.len[prow]);
+  int pend = pbeg + plen;
+
+  /*  extract pivot element   */
+  i = pbeg + pos;
+  pcol = u.row.idx[i];
+  pval = u.row.val[i];
+  removeDR(temp.pivot_col[pcol]);
+  initDR(temp.pivot_col[pcol]);
+
+  /*  remove pivot from pivot row     */
+  u.row.idx[i] = u.row.idx[pend];
+  u.row.val[i] = u.row.val[pend];
+
+  /*  set pivot element and construct L VectorBase<R> */
+  setPivot(temp.stage++, pcol, prow, pval);
+
+  /**@todo If this test failes, lv has no value. I suppose that in this
+   *       case none of the loops below that uses lv is executed.
+   *       But this is unproven.
+   */
+
+  if (temp.s_cact[pcol] - 1 > 0)
+    lv = makeLvec(temp.s_cact[pcol] - 1, prow);
+
+  /*  init working VectorBase<R>,
+   *  remove pivot row from working matrix
+   *  and remove columns from list.
+   */
+  for (i = pbeg; i < pend; ++i) {
+    j = u.row.idx[i];
+    temp.s_mark[j] = 1;
+    work[j] = u.row.val[i];
+    removeDR(temp.pivot_col[j]);
+    m = u.col.start[j] + u.col.len[j] - temp.s_cact[j];
+
+    for (k = m; u.col.idx[k] != prow; ++k)
+      ;
 
-   /*  remove pivot column from column file.
-    */
-   u.col.len[pcol] -= temp.s_cact[pcol];
-
-   /*  clear working VectorBase<R> and reinsert columns to lists
-    */
-   for(i = u.row.start[prow], pend = i + plen; i < pend; ++i)
-   {
-      j = u.row.idx[i];
-      work[j] = 0;
-      temp.s_mark[j] = 0;
-      init2DR(temp.pivot_col[j], temp.pivot_colNZ[temp.s_cact[j]]);
-      assert(col.perm[j] < 0);
-   }
+    u.col.idx[k] = u.col.idx[m];
+
+    u.col.idx[m] = prow;
+
+    temp.s_cact[j]--;
+  }
+
+  /*  perform L and update loop
+   */
+  for (i = u.col.len[pcol] - temp.s_cact[pcol];
+       (m = u.col.idx[u.col.start[pcol] + i]) != prow; ++i) {
+    assert(row.perm[m] < 0);
+    assert(lv >= 0);
+    /* coverity[negative_returns] */
+    updateRow(m, lv++, prow, pcol, pval, eps);
+  }
+
+  /*  skip pivot row  */
+
+  m = u.col.len[pcol];
+
+  for (++i; i < m; ++i) {
+    assert(lv >= 0);
+    /* coverity[negative_returns] */
+    updateRow(u.col.idx[u.col.start[pcol] + i], lv++, prow, pcol, pval, eps);
+  }
+
+  /*  remove pivot column from column file.
+   */
+  u.col.len[pcol] -= temp.s_cact[pcol];
+
+  /*  clear working VectorBase<R> and reinsert columns to lists
+   */
+  for (i = u.row.start[prow], pend = i + plen; i < pend; ++i) {
+    j = u.row.idx[i];
+    work[j] = 0;
+    temp.s_mark[j] = 0;
+    init2DR(temp.pivot_col[j], temp.pivot_colNZ[temp.s_cact[j]]);
+    assert(col.perm[j] < 0);
+  }
 }
 
-
 /*
  *      Factorize nucleus.
  */
 template <class R>
-void CLUFactor<R>::eliminateNucleus(const R eps,
-                                    const R threshold)
-{
-   int r, c;
-   CLUFactor<R>::Pring* pivot;
+void CLUFactor<R>::eliminateNucleus(const R eps, const R threshold) {
+  int r, c;
+  CLUFactor<R>::Pring *pivot;
 
-   if(this->stat == SLinSolver<R>::SINGULAR)
-      return;
+  if (this->stat == SLinSolver<R>::SINGULAR)
+    return;
 
-   temp.pivots.mkwtz = -1;
+  temp.pivots.mkwtz = -1;
 
-   temp.pivots.idx = -1;
+  temp.pivots.idx = -1;
 
-   temp.pivots.pos = -1;
+  temp.pivots.pos = -1;
 
-   while(temp.stage < thedim - 1)
-   {
+  while (temp.stage < thedim - 1) {
 #ifndef NDEBUG
-      int i;
-      // CLUFactorIsConsistent(fac);
+    int i;
+    // CLUFactorIsConsistent(fac);
 
-      for(i = 0; i < thedim; ++i)
-         if(col.perm[i] < 0)
-            assert(temp.s_mark[i] == 0);
+    for (i = 0; i < thedim; ++i)
+      if (col.perm[i] < 0)
+        assert(temp.s_mark[i] == 0);
 
 #endif
 
-      if(temp.pivot_rowNZ[1].next != &(temp.pivot_rowNZ[1]))
-         /* row singleton available */
-         eliminateRowSingletons();
-      else if(temp.pivot_colNZ[1].next != &(temp.pivot_colNZ[1]))
-         /* column singleton available */
-         eliminateColSingletons();
-      else
-      {
-         initDR(temp.pivots);
-         selectPivots(threshold);
-
-         assert(temp.pivots.next != &temp.pivots &&
-                "ERROR: no pivot element selected");
-
-         for(pivot = temp.pivots.next; pivot != &temp.pivots;
-               pivot = pivot->next)
-         {
-            eliminatePivot(pivot->idx, pivot->pos, eps);
-         }
-      }
-
-      if(temp.pivot_rowNZ->next != temp.pivot_rowNZ ||
-            temp.pivot_colNZ->next != temp.pivot_colNZ)
-      {
-         this->stat = SLinSolver<R>::SINGULAR;
-         return;
+    if (temp.pivot_rowNZ[1].next != &(temp.pivot_rowNZ[1]))
+      /* row singleton available */
+      eliminateRowSingletons();
+    else if (temp.pivot_colNZ[1].next != &(temp.pivot_colNZ[1]))
+      /* column singleton available */
+      eliminateColSingletons();
+    else {
+      initDR(temp.pivots);
+      selectPivots(threshold);
+
+      assert(temp.pivots.next != &temp.pivots &&
+             "ERROR: no pivot element selected");
+
+      for (pivot = temp.pivots.next; pivot != &temp.pivots;
+           pivot = pivot->next) {
+        eliminatePivot(pivot->idx, pivot->pos, eps);
       }
-   }
+    }
 
-   if(temp.stage < thedim)
-   {
-      /*      Eliminate remaining element.
-       *      Note, that this must be both, column and row singleton.
-       */
-      assert(temp.pivot_rowNZ[1].next != &(temp.pivot_rowNZ[1]) &&
-             "ERROR: one row must be left");
-      assert(temp.pivot_colNZ[1].next != &(temp.pivot_colNZ[1]) &&
-             "ERROR: one col must be left");
-      r = temp.pivot_rowNZ[1].next->idx;
-      c = temp.pivot_colNZ[1].next->idx;
-      u.row.len[r] = 0;
-      u.col.len[c]--;
-      setPivot(temp.stage, c, r, u.row.val[u.row.start[r]]);
-   }
+    if (temp.pivot_rowNZ->next != temp.pivot_rowNZ ||
+        temp.pivot_colNZ->next != temp.pivot_colNZ) {
+      this->stat = SLinSolver<R>::SINGULAR;
+      return;
+    }
+  }
+
+  if (temp.stage < thedim) {
+    /*      Eliminate remaining element.
+     *      Note, that this must be both, column and row singleton.
+     */
+    assert(temp.pivot_rowNZ[1].next != &(temp.pivot_rowNZ[1]) &&
+           "ERROR: one row must be left");
+    assert(temp.pivot_colNZ[1].next != &(temp.pivot_colNZ[1]) &&
+           "ERROR: one col must be left");
+    r = temp.pivot_rowNZ[1].next->idx;
+    c = temp.pivot_colNZ[1].next->idx;
+    u.row.len[r] = 0;
+    u.col.len[c]--;
+    setPivot(temp.stage, c, r, u.row.val[u.row.start[r]]);
+  }
 }
 
 /*****************************************************************************/
 
-template <class R>
-int CLUFactor<R>::setupColVals()
-{
-   int i;
-   int n = thedim;
+template <class R> int CLUFactor<R>::setupColVals() {
+  int i;
+  int n = thedim;
 
-   if(!u.col.val.empty())
-      u.col.val.clear();
+  if (!u.col.val.empty())
+    u.col.val.clear();
 
-   u.col.val.reserve(u.col.size); // small performance improvement before the insertion
-   u.col.val.insert(u.col.val.begin(), u.col.size, 0);
+  u.col.val.reserve(
+      u.col.size); // small performance improvement before the insertion
+  u.col.val.insert(u.col.val.begin(), u.col.size, 0);
 
-   for(i = 0; i < thedim; i++)
-      u.col.len[i] = 0;
+  for (i = 0; i < thedim; i++)
+    u.col.len[i] = 0;
 
-   maxabs = R(0.0);
+  maxabs = R(0.0);
 
-   for(i = 0; i < thedim; i++)
-   {
-      int     k   = u.row.start[i];
-      int*    idx = &u.row.idx[k];
-      R*   val = &u.row.val[k];
-      int     len = u.row.len[i];
+  for (i = 0; i < thedim; i++) {
+    int k = u.row.start[i];
+    int *idx = &u.row.idx[k];
+    R *val = &u.row.val[k];
+    int len = u.row.len[i];
 
-      n += len;
+    n += len;
 
-      while(len-- > 0)
-      {
-         assert((*idx >= 0) && (*idx < thedim));
+    while (len-- > 0) {
+      assert((*idx >= 0) && (*idx < thedim));
 
-         k = u.col.start[*idx] + u.col.len[*idx];
+      k = u.col.start[*idx] + u.col.len[*idx];
 
-         assert((k >= 0) && (k < u.col.size));
+      assert((k >= 0) && (k < u.col.size));
 
-         u.col.len[*idx]++;
+      u.col.len[*idx]++;
 
-         assert(u.col.len[*idx] <= u.col.max[*idx]);
+      assert(u.col.len[*idx] <= u.col.max[*idx]);
 
-         u.col.idx[k] = i;
-         u.col.val[k] = *val;
+      u.col.idx[k] = i;
+      u.col.val[k] = *val;
 
-         if(spxAbs(*val) > maxabs)
-            maxabs = spxAbs(*val);
+      if (spxAbs(*val) > maxabs)
+        maxabs = spxAbs(*val);
 
-         idx++;
+      idx++;
 
-         val++;
-      }
-   }
+      val++;
+    }
+  }
 
-   return n;
+  return n;
 }
 
 /*****************************************************************************/
 
 #ifdef WITH_L_ROWS
-template <class R>
-void CLUFactor<R>::setupRowVals()
-{
-   int   i, j, k, m;
-   int   vecs, mem;
-   int*  l_row;
-   int*  idx;
-   R* val;
-   int*  beg;
-   int*  l_ridx;
-   R* l_rval;
-   int*  l_rbeg;
-   int*  rorig;
-   int*  rrorig;
-   int*  rperm;
-   int*  rrperm;
-
-   vecs  = l.firstUpdate;
-   l_row = l.row;
-   idx   = l.idx;
-   val   = l.val.data();
-   beg   = l.start;
-   mem   = beg[vecs];
-
-   if(!l.rval.empty())
-   {
-      l.rval.clear();
-   }
+template <class R> void CLUFactor<R>::setupRowVals() {
+  int i, j, k, m;
+  int vecs, mem;
+  int *l_row;
+  int *idx;
+  R *val;
+  int *beg;
+  int *l_ridx;
+  R *l_rval;
+  int *l_rbeg;
+  int *rorig;
+  int *rrorig;
+  int *rperm;
+  int *rrperm;
 
+  vecs = l.firstUpdate;
+  l_row = l.row;
+  idx = l.idx;
+  val = l.val.data();
+  beg = l.start;
+  mem = beg[vecs];
 
-   if(l.ridx)
-      spx_free(l.ridx);
+  if (!l.rval.empty()) {
+    l.rval.clear();
+  }
 
-   if(l.rbeg)
-      spx_free(l.rbeg);
+  if (l.ridx)
+    spx_free(l.ridx);
 
-   if(l.rorig)
-      spx_free(l.rorig);
+  if (l.rbeg)
+    spx_free(l.rbeg);
 
-   if(l.rperm)
-      spx_free(l.rperm);
+  if (l.rorig)
+    spx_free(l.rorig);
 
-   l.rval.reserve(mem);         // small performance improvement before the insertion
-   // Insert mem number of zeros.
-   l.rval.insert(l.rval.begin(), mem, 0);
+  if (l.rperm)
+    spx_free(l.rperm);
 
-   spx_alloc(l.ridx, mem);
+  l.rval.reserve(mem); // small performance improvement before the insertion
+  // Insert mem number of zeros.
+  l.rval.insert(l.rval.begin(), mem, 0);
 
-   spx_alloc(l.rbeg, thedim + 1);
+  spx_alloc(l.ridx, mem);
 
-   spx_alloc(l.rorig, thedim);
+  spx_alloc(l.rbeg, thedim + 1);
 
-   spx_alloc(l.rperm, thedim);
+  spx_alloc(l.rorig, thedim);
 
-   l_ridx = l.ridx;
+  spx_alloc(l.rperm, thedim);
 
-   l_rval = l.rval.data();
+  l_ridx = l.ridx;
 
-   l_rbeg = l.rbeg;
+  l_rval = l.rval.data();
 
-   rorig  = l.rorig;
+  l_rbeg = l.rbeg;
 
-   rrorig = row.orig;
+  rorig = l.rorig;
 
-   rperm  = l.rperm;
+  rrorig = row.orig;
 
-   rrperm = row.perm;
+  rperm = l.rperm;
 
-   for(i = thedim; i--; *l_rbeg++ = 0)
-   {
-      *rorig++ = *rrorig++;
-      *rperm++ = *rrperm++;
-   }
+  rrperm = row.perm;
 
-   *l_rbeg = 0;
+  for (i = thedim; i--; *l_rbeg++ = 0) {
+    *rorig++ = *rrorig++;
+    *rperm++ = *rrperm++;
+  }
 
-   l_rbeg = l.rbeg + 1;
+  *l_rbeg = 0;
 
-   for(i = mem; i--;)
-      l_rbeg[*idx++]++;
+  l_rbeg = l.rbeg + 1;
 
-   idx = l.idx;
+  for (i = mem; i--;)
+    l_rbeg[*idx++]++;
 
-   for(m = 0, i = thedim; i--; l_rbeg++)
-   {
-      j = *l_rbeg;
-      *l_rbeg = m;
-      m += j;
-   }
+  idx = l.idx;
 
-   assert(m == mem);
+  for (m = 0, i = thedim; i--; l_rbeg++) {
+    j = *l_rbeg;
+    *l_rbeg = m;
+    m += j;
+  }
 
-   l_rbeg = l.rbeg + 1;
+  assert(m == mem);
 
-   for(i = j = 0; i < vecs; ++i)
-   {
-      m = l_row[i];
-      assert(idx == &l.idx[l.start[i]]);
+  l_rbeg = l.rbeg + 1;
 
-      for(; j < beg[i + 1]; j++)
-      {
-         k = l_rbeg[*idx++]++;
-         assert(k < mem);
-         l_ridx[k] = m;
-         l_rval[k] = *val++;
-      }
-   }
+  for (i = j = 0; i < vecs; ++i) {
+    m = l_row[i];
+    assert(idx == &l.idx[l.start[i]]);
+
+    for (; j < beg[i + 1]; j++) {
+      k = l_rbeg[*idx++]++;
+      assert(k < mem);
+      l_ridx[k] = m;
+      l_rval[k] = *val++;
+    }
+  }
 
-   assert(l.rbeg[thedim] == mem);
+  assert(l.rbeg[thedim] == mem);
 
-   assert(l.rbeg[0] == 0);
+  assert(l.rbeg[0] == 0);
 }
 
 #endif
@@ -2816,3554 +2551,3083 @@ void CLUFactor<R>::setupRowVals()
 /*****************************************************************************/
 
 template <class R>
-void CLUFactor<R>::factor(const SVectorBase<R>**
-                          vec,          ///< Array of column VectorBase<R> pointers
-                          R            threshold,    ///< pivoting threshold
-                          R            eps)          ///< epsilon for zero detection
+void CLUFactor<R>::factor(
+    const SVectorBase<R> **vec, ///< Array of column VectorBase<R> pointers
+    R threshold,                ///< pivoting threshold
+    R eps)                      ///< epsilon for zero detection
 {
 
-   factorTime->start();
+  factorTime->start();
 
-   this->stat = SLinSolver<R>::OK;
+  this->stat = SLinSolver<R>::OK;
 
-   l.start[0]    = 0;
-   l.firstUpdate = 0;
-   l.firstUnused = 0;
+  l.start[0] = 0;
+  l.firstUpdate = 0;
+  l.firstUnused = 0;
 
-   temp.init(thedim);
-   initPerm();
+  temp.init(thedim);
+  initPerm();
 
-   initFactorMatrix(vec, eps);
+  initFactorMatrix(vec, eps);
 
-   if(this->stat)
-      goto TERMINATE;
+  if (this->stat)
+    goto TERMINATE;
 
-   //   initMaxabs = initMaxabs;
+  //   initMaxabs = initMaxabs;
 
-   colSingletons();
+  colSingletons();
 
-   if(this->stat != SLinSolver<R>::OK)
-      goto TERMINATE;
+  if (this->stat != SLinSolver<R>::OK)
+    goto TERMINATE;
 
-   rowSingletons();
+  rowSingletons();
 
-   if(this->stat != SLinSolver<R>::OK)
-      goto TERMINATE;
+  if (this->stat != SLinSolver<R>::OK)
+    goto TERMINATE;
 
-   if(temp.stage < thedim)
-   {
-      initFactorRings();
-      eliminateNucleus(eps, threshold);
-      freeFactorRings();
-   }
+  if (temp.stage < thedim) {
+    initFactorRings();
+    eliminateNucleus(eps, threshold);
+    freeFactorRings();
+  }
 
 TERMINATE:
 
-   l.firstUpdate = l.firstUnused;
+  l.firstUpdate = l.firstUnused;
 
-   if(this->stat == SLinSolver<R>::OK)
-   {
+  if (this->stat == SLinSolver<R>::OK) {
 #ifdef WITH_L_ROWS
-      setupRowVals();
+    setupRowVals();
 #endif
-      nzCnt = setupColVals();
-   }
+    nzCnt = setupColVals();
+  }
 
-   factorTime->stop();
+  factorTime->stop();
 
-   factorCount++;
+  factorCount++;
 }
 
-template <class R>
-void CLUFactor<R>::dump() const
-{
-   int i, j, k;
+template <class R> void CLUFactor<R>::dump() const {
+  int i, j, k;
 
-   // Dump regardless of the verbosity level if this method is called;
+  // Dump regardless of the verbosity level if this method is called;
 
-   /*  Dump U:
-    */
+  /*  Dump U:
+   */
 
-   for(i = 0; i < thedim; ++i)
-   {
-      if(row.perm[i] >= 0)
-         std::cout << "DCLUFA01 diag[" << i << "]: [" << col.orig[row.perm[i]]
-                   << "] = " << diag[i] << std::endl;
+  for (i = 0; i < thedim; ++i) {
+    if (row.perm[i] >= 0)
+      std::cout << "DCLUFA01 diag[" << i << "]: [" << col.orig[row.perm[i]]
+                << "] = " << diag[i] << std::endl;
 
-      for(j = 0; j < u.row.len[i]; ++j)
-         std::cout << "DCLUFA02   u[" << i << "]: ["
-                   << u.row.idx[u.row.start[i] + j] << "] = "
-                   << u.row.val[u.row.start[i] + j] << std::endl;
-   }
+    for (j = 0; j < u.row.len[i]; ++j)
+      std::cout << "DCLUFA02   u[" << i << "]: ["
+                << u.row.idx[u.row.start[i] + j]
+                << "] = " << u.row.val[u.row.start[i] + j] << std::endl;
+  }
 
-   /*  Dump L:
-    */
-   for(i = 0; i < thedim; ++i)
-   {
-      for(j = 0; j < l.firstUnused; ++j)
-         if(col.orig[row.perm[l.row[j]]] == i)
-         {
-            std::cout << "DCLUFA03 l[" << i << "]" << std::endl;
+  /*  Dump L:
+   */
+  for (i = 0; i < thedim; ++i) {
+    for (j = 0; j < l.firstUnused; ++j)
+      if (col.orig[row.perm[l.row[j]]] == i) {
+        std::cout << "DCLUFA03 l[" << i << "]" << std::endl;
 
-            for(k = l.start[j]; k < l.start[j + 1]; ++k)
-               std::cout << "DCLUFA04   l[" << k - l.start[j]
-                         << "]:  [" << l.idx[k]
-                         << "] = "  << l.val[k] << std::endl;
+        for (k = l.start[j]; k < l.start[j + 1]; ++k)
+          std::cout << "DCLUFA04   l[" << k - l.start[j] << "]:  [" << l.idx[k]
+                    << "] = " << l.val[k] << std::endl;
 
-            break;
-         }
-   }
+        break;
+      }
+  }
 
-   return;
+  return;
 }
 
 /*****************************************************************************/
 /*
  *      Ensure that row memory is at least size.
  */
-template <class R>
-void CLUFactor<R>::minRowMem(int size)
-{
+template <class R> void CLUFactor<R>::minRowMem(int size) {
 
-   if(u.row.size < size)
-   {
-      u.row.size = size;
-      u.row.val.resize(size);
-      spx_realloc(u.row.idx, size);
-   }
+  if (u.row.size < size) {
+    u.row.size = size;
+    u.row.val.resize(size);
+    spx_realloc(u.row.idx, size);
+  }
 }
 
 /*****************************************************************************/
 /*
  *      Ensure that column memory is at least size.
  */
-template <class R>
-void CLUFactor<R>::minColMem(int size)
-{
+template <class R> void CLUFactor<R>::minColMem(int size) {
 
-   if(u.col.size < size)
-   {
-      u.col.size = size;
-      spx_realloc(u.col.idx, size);
-   }
+  if (u.col.size < size) {
+    u.col.size = size;
+    spx_realloc(u.col.idx, size);
+  }
 }
 
-template <class R>
-void CLUFactor<R>::forestMinColMem(int size)
-{
+template <class R> void CLUFactor<R>::forestMinColMem(int size) {
 
-   if(u.col.size < size)
-   {
-      u.col.size = size;
-      spx_realloc(u.col.idx, size);
-      u.col.val.resize(size);
-   }
+  if (u.col.size < size) {
+    u.col.size = size;
+    spx_realloc(u.col.idx, size);
+    u.col.val.resize(size);
+  }
 }
 
-template <class R>
-void CLUFactor<R>::minLMem(int size)
-{
+template <class R> void CLUFactor<R>::minLMem(int size) {
 
-   if(size > l.size)
-   {
-      l.size = int(0.2 * l.size + size);
-      l.val.resize(l.size);
-      spx_realloc(l.idx, l.size);
-   }
+  if (size > l.size) {
+    l.size = int(0.2 * l.size + size);
+    l.val.resize(l.size);
+    spx_realloc(l.idx, l.size);
+  }
 }
 
+template <class R> int CLUFactor<R>::makeLvec(int p_len, int p_row) {
 
-template <class R>
-int CLUFactor<R>::makeLvec(int p_len, int p_row)
-{
-
-   if(l.firstUnused >= l.startSize)
-   {
-      l.startSize += 100;
-      spx_realloc(l.start, l.startSize);
-   }
+  if (l.firstUnused >= l.startSize) {
+    l.startSize += 100;
+    spx_realloc(l.start, l.startSize);
+  }
 
-   int* p_lrow = l.row;
+  int *p_lrow = l.row;
 
-   int* p_lbeg = l.start;
-   int first   = p_lbeg[l.firstUnused];
+  int *p_lbeg = l.start;
+  int first = p_lbeg[l.firstUnused];
 
-   assert(p_len > 0 && "ERROR: no empty columns allowed in L vectors");
+  assert(p_len > 0 && "ERROR: no empty columns allowed in L vectors");
 
-   minLMem(first + p_len);
-   p_lrow[l.firstUnused] = p_row;
-   l.start[++(l.firstUnused)] = first + p_len;
+  minLMem(first + p_len);
+  p_lrow[l.firstUnused] = p_row;
+  l.start[++(l.firstUnused)] = first + p_len;
 
-   assert(l.start[l.firstUnused] <= l.size);
-   assert(l.firstUnused <= l.startSize);
-   return first;
+  assert(l.start[l.firstUnused] <= l.size);
+  assert(l.firstUnused <= l.startSize);
+  return first;
 }
 
-
 /*****************************************************************************/
 
-template <class R>
-bool CLUFactor<R>::isConsistent() const
-{
+template <class R> bool CLUFactor<R>::isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
-   int              i, j, k, ll;
-   Dring*            ring;
-   CLUFactor<R>::Pring* pring;
+  int i, j, k, ll;
+  Dring *ring;
+  CLUFactor<R>::Pring *pring;
 
-   /*  Consistency only relevant for R factorizations
-    */
+  /*  Consistency only relevant for R factorizations
+   */
 
-   if(this->stat)
-      return true;
+  if (this->stat)
+    return true;
 
-   /*  Test column ring list consistency.
-    */
-   i = 0;
+  /*  Test column ring list consistency.
+   */
+  i = 0;
 
-   for(ring = u.col.list.next; ring != &(u.col.list); ring = ring->next)
-   {
-      assert(ring->idx >= 0);
-      assert(ring->idx < thedim);
-      assert(ring->prev->next == ring);
+  for (ring = u.col.list.next; ring != &(u.col.list); ring = ring->next) {
+    assert(ring->idx >= 0);
+    assert(ring->idx < thedim);
+    assert(ring->prev->next == ring);
 
-      if(ring != u.col.list.next)
-      {
-         assert(u.col.start[ring->prev->idx] + u.col.max[ring->prev->idx]
-                == u.col.start[ring->idx]);
-      }
+    if (ring != u.col.list.next) {
+      assert(u.col.start[ring->prev->idx] + u.col.max[ring->prev->idx] ==
+             u.col.start[ring->idx]);
+    }
 
-      ++i;
-   }
+    ++i;
+  }
 
-   assert(i == thedim);
+  assert(i == thedim);
 
-   assert(u.col.start[ring->prev->idx] + u.col.max[ring->prev->idx]
-          == u.col.used);
+  assert(u.col.start[ring->prev->idx] + u.col.max[ring->prev->idx] ==
+         u.col.used);
 
+  /*  Test row ring list consistency.
+   */
+  i = 0;
 
-   /*  Test row ring list consistency.
-    */
-   i = 0;
+  for (ring = u.row.list.next; ring != &(u.row.list); ring = ring->next) {
+    assert(ring->idx >= 0);
+    assert(ring->idx < thedim);
+    assert(ring->prev->next == ring);
+    assert(u.row.start[ring->prev->idx] + u.row.max[ring->prev->idx] ==
+           u.row.start[ring->idx]);
+    ++i;
+  }
 
-   for(ring = u.row.list.next; ring != &(u.row.list); ring = ring->next)
-   {
-      assert(ring->idx >= 0);
-      assert(ring->idx < thedim);
-      assert(ring->prev->next == ring);
-      assert(u.row.start[ring->prev->idx] + u.row.max[ring->prev->idx]
-             == u.row.start[ring->idx]);
-      ++i;
-   }
+  assert(i == thedim);
 
-   assert(i == thedim);
+  assert(u.row.start[ring->prev->idx] + u.row.max[ring->prev->idx] ==
+         u.row.used);
 
-   assert(u.row.start[ring->prev->idx] + u.row.max[ring->prev->idx]
-          == u.row.used);
+  /*  Test consistency of individual svectors.
+   */
 
+  for (i = 0; i < thedim; ++i) {
+    assert(u.row.max[i] >= u.row.len[i]);
+    assert(u.col.max[i] >= u.col.len[i]);
+  }
 
-   /*  Test consistency of individual svectors.
-    */
+  /*  Test consistency of column file to row file of U
+   */
+  for (i = 0; i < thedim; ++i) {
+    for (j = u.row.start[i] + u.row.len[i] - 1; j >= u.row.start[i]; j--) {
+      k = u.row.idx[j];
 
-   for(i = 0; i < thedim; ++i)
-   {
-      assert(u.row.max[i] >= u.row.len[i]);
-      assert(u.col.max[i] >= u.col.len[i]);
-   }
+      for (ll = u.col.start[k] + u.col.len[k] - 1; ll >= u.col.start[k]; ll--) {
+        if (u.col.idx[ll] == i)
+          break;
+      }
 
+      assert(u.col.idx[ll] == i);
 
-   /*  Test consistency of column file to row file of U
-    */
-   for(i = 0; i < thedim; ++i)
-   {
-      for(j = u.row.start[i] + u.row.len[i] - 1; j >= u.row.start[i]; j--)
-      {
-         k = u.row.idx[j];
-
-         for(ll = u.col.start[k] + u.col.len[k] - 1; ll >= u.col.start[k]; ll--)
-         {
-            if(u.col.idx[ll] == i)
-               break;
-         }
-
-         assert(u.col.idx[ll] == i);
-
-         if(row.perm[i] < 0)
-         {
-            assert(col.perm[k] < 0);
-         }
-         else
-         {
-            assert(col.perm[k] < 0 || col.perm[k] > row.perm[i]);
-         }
+      if (row.perm[i] < 0) {
+        assert(col.perm[k] < 0);
+      } else {
+        assert(col.perm[k] < 0 || col.perm[k] > row.perm[i]);
       }
-   }
+    }
+  }
 
-   /*  Test consistency of row file to column file of U
-    */
-   for(i = 0; i < thedim; ++i)
-   {
-      for(j = u.col.start[i] + u.col.len[i] - 1; j >= u.col.start[i]; j--)
-      {
-         k = u.col.idx[j];
+  /*  Test consistency of row file to column file of U
+   */
+  for (i = 0; i < thedim; ++i) {
+    for (j = u.col.start[i] + u.col.len[i] - 1; j >= u.col.start[i]; j--) {
+      k = u.col.idx[j];
 
-         for(ll = u.row.start[k] + u.row.len[k] - 1; ll >= u.row.start[k]; ll--)
-         {
-            if(u.row.idx[ll] == i)
-               break;
-         }
+      for (ll = u.row.start[k] + u.row.len[k] - 1; ll >= u.row.start[k]; ll--) {
+        if (u.row.idx[ll] == i)
+          break;
+      }
 
-         assert(u.row.idx[ll] == i);
+      assert(u.row.idx[ll] == i);
 
-         assert(col.perm[i] < 0 || row.perm[k] < col.perm[i]);
+      assert(col.perm[i] < 0 || row.perm[k] < col.perm[i]);
+    }
+  }
+
+  /*  Test consistency of nonzero count lists
+   */
+  if (temp.pivot_colNZ && temp.pivot_rowNZ) {
+    for (i = 0; i < thedim - temp.stage; ++i) {
+      for (pring = temp.pivot_rowNZ[i].next; pring != &(temp.pivot_rowNZ[i]);
+           pring = pring->next) {
+        assert(row.perm[pring->idx] < 0);
       }
-   }
 
-   /*  Test consistency of nonzero count lists
-    */
-   if(temp.pivot_colNZ && temp.pivot_rowNZ)
-   {
-      for(i = 0; i < thedim - temp.stage; ++i)
-      {
-         for(pring = temp.pivot_rowNZ[i].next; pring != &(temp.pivot_rowNZ[i]); pring = pring->next)
-         {
-            assert(row.perm[pring->idx] < 0);
-         }
-
-         for(pring = temp.pivot_colNZ[i].next; pring != &(temp.pivot_colNZ[i]); pring = pring->next)
-         {
-            assert(col.perm[pring->idx] < 0);
-         }
+      for (pring = temp.pivot_colNZ[i].next; pring != &(temp.pivot_colNZ[i]);
+           pring = pring->next) {
+        assert(col.perm[pring->idx] < 0);
       }
-   }
+    }
+  }
 
 #endif // CONSISTENCY_CHECKS
 
-   return true;
+  return true;
 }
 
-template <class R>
-void CLUFactor<R>::solveUright(R* wrk, R* vec) const
-{
+template <class R> void CLUFactor<R>::solveUright(R *wrk, R *vec) const {
 
-   for(int i = thedim - 1; i >= 0; i--)
-   {
-      int  r = row.orig[i];
-      int  c = col.orig[i];
-      R x = wrk[c] = diag[r] * vec[r];
+  for (int i = thedim - 1; i >= 0; i--) {
+    int r = row.orig[i];
+    int c = col.orig[i];
+    R x = wrk[c] = diag[r] * vec[r];
 
-      vec[r] = 0.0;
+    vec[r] = 0.0;
 
-      if(x != 0.0)
-         //if (isNotZero(x))
-      {
-         for(int j = u.col.start[c]; j < u.col.start[c] + u.col.len[c]; j++)
-            vec[u.col.idx[j]] -= x * u.col.val[j];
-      }
-   }
+    if (x != 0.0)
+    // if (isNotZero(x))
+    {
+      for (int j = u.col.start[c]; j < u.col.start[c] + u.col.len[c]; j++)
+        vec[u.col.idx[j]] -= x * u.col.val[j];
+    }
+  }
 }
 
 template <class R>
-int CLUFactor<R>::solveUrightEps(R* vec, int* nonz, R eps, R* rhs)
-{
-   int i, j, r, c, n;
-   int* rorig, *corig;
-   int* cidx, *clen, *cbeg;
-   R* cval;
-   R x;
+int CLUFactor<R>::solveUrightEps(R *vec, int *nonz, R eps, R *rhs) {
+  int i, j, r, c, n;
+  int *rorig, *corig;
+  int *cidx, *clen, *cbeg;
+  R *cval;
+  R x;
 
-   int* idx;
-   R* val;
+  int *idx;
+  R *val;
 
-   rorig = row.orig;
-   corig = col.orig;
+  rorig = row.orig;
+  corig = col.orig;
 
-   cidx = u.col.idx;
-   cval = u.col.val.data();
-   clen = u.col.len;
-   cbeg = u.col.start;
+  cidx = u.col.idx;
+  cval = u.col.val.data();
+  clen = u.col.len;
+  cbeg = u.col.start;
 
-   n = 0;
+  n = 0;
 
-   for(i = thedim - 1; i >= 0; --i)
-   {
-      r = rorig[i];
-      x = diag[r] * rhs[r];
+  for (i = thedim - 1; i >= 0; --i) {
+    r = rorig[i];
+    x = diag[r] * rhs[r];
 
-      if(isNotZero(x, eps))
-      {
-         c = corig[i];
-         vec[c] = x;
-         nonz[n++] = c;
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
-
-         while(j-- > 0)
-            rhs[*idx++] -= x * (*val++);
-      }
-   }
+    if (isNotZero(x, eps)) {
+      c = corig[i];
+      vec[c] = x;
+      nonz[n++] = c;
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0)
+        rhs[*idx++] -= x * (*val++);
+    }
+  }
 
-   return n;
+  return n;
 }
 
 template <class R>
-void CLUFactor<R>::solveUright2(
-   R* p_work1, R* vec1, R* p_work2, R* vec2)
-{
-   int i, j, r, c;
-   int* rorig, *corig;
-   int* cidx, *clen, *cbeg;
-   R* cval;
-   R x1, x2;
-
-   int* idx;
-   R* val;
-
-   rorig = row.orig;
-   corig = col.orig;
-
-   cidx = u.col.idx;
-   cval = u.col.val.data();
-   clen = u.col.len;
-   cbeg = u.col.start;
-
-   for(i = thedim - 1; i >= 0; --i)
-   {
-      r = rorig[i];
-      c = corig[i];
-      p_work1[c] = x1 = diag[r] * vec1[r];
-      p_work2[c] = x2 = diag[r] * vec2[r];
-      vec1[r] = vec2[r] = 0;
-
-      if(x1 != 0.0 && x2 != 0.0)
-      {
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
-
-         while(j-- > 0)
-         {
-            vec1[*idx] -= x1 * (*val);
-            vec2[*idx++] -= x2 * (*val++);
-         }
+void CLUFactor<R>::solveUright2(R *p_work1, R *vec1, R *p_work2, R *vec2) {
+  int i, j, r, c;
+  int *rorig, *corig;
+  int *cidx, *clen, *cbeg;
+  R *cval;
+  R x1, x2;
+
+  int *idx;
+  R *val;
+
+  rorig = row.orig;
+  corig = col.orig;
+
+  cidx = u.col.idx;
+  cval = u.col.val.data();
+  clen = u.col.len;
+  cbeg = u.col.start;
+
+  for (i = thedim - 1; i >= 0; --i) {
+    r = rorig[i];
+    c = corig[i];
+    p_work1[c] = x1 = diag[r] * vec1[r];
+    p_work2[c] = x2 = diag[r] * vec2[r];
+    vec1[r] = vec2[r] = 0;
+
+    if (x1 != 0.0 && x2 != 0.0) {
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0) {
+        vec1[*idx] -= x1 * (*val);
+        vec2[*idx++] -= x2 * (*val++);
       }
-      else if(x1 != 0.0)
-      {
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
+    } else if (x1 != 0.0) {
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0)
+        vec1[*idx++] -= x1 * (*val++);
+    } else if (x2 != 0.0) {
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0)
+        vec2[*idx++] -= x2 * (*val++);
+    }
+  }
+}
 
-         while(j-- > 0)
-            vec1[*idx++] -= x1 * (*val++);
+template <class R>
+int CLUFactor<R>::solveUright2eps(R *p_work1, R *vec1, R *p_work2, R *vec2,
+                                  int *nonz, R eps) {
+  int i, j, r, c, n;
+  int *rorig, *corig;
+  int *cidx, *clen, *cbeg;
+  bool notzero1, notzero2;
+  R *cval;
+  R x1, x2;
+
+  int *idx;
+  R *val;
+
+  rorig = row.orig;
+  corig = col.orig;
+
+  cidx = u.col.idx;
+  cval = u.col.val.data();
+  clen = u.col.len;
+  cbeg = u.col.start;
+
+  n = 0;
+
+  for (i = thedim - 1; i >= 0; --i) {
+    c = corig[i];
+    r = rorig[i];
+    p_work1[c] = x1 = diag[r] * vec1[r];
+    p_work2[c] = x2 = diag[r] * vec2[r];
+    vec1[r] = vec2[r] = 0;
+    notzero1 = isNotZero(x1, eps);
+    notzero2 = isNotZero(x2, eps);
+
+    if (notzero1 && notzero2) {
+      *nonz++ = c;
+      n++;
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0) {
+        vec1[*idx] -= x1 * (*val);
+        vec2[*idx++] -= x2 * (*val++);
       }
-      else if(x2 != 0.0)
-      {
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
+    } else if (notzero1) {
+      p_work2[c] = 0.0;
+      *nonz++ = c;
+      n++;
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0)
+        vec1[*idx++] -= x1 * (*val++);
+    } else if (notzero2) {
+      p_work1[c] = 0.0;
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0)
+        vec2[*idx++] -= x2 * (*val++);
+    } else {
+      p_work1[c] = 0.0;
+      p_work2[c] = 0.0;
+    }
+  }
 
-         while(j-- > 0)
-            vec2[*idx++] -= x2 * (*val++);
-      }
-   }
+  return n;
 }
 
-template <class R>
-int CLUFactor<R>::solveUright2eps(
-   R* p_work1, R* vec1, R* p_work2, R* vec2,
-   int* nonz, R eps)
-{
-   int i, j, r, c, n;
-   int* rorig, *corig;
-   int* cidx, *clen, *cbeg;
-   bool notzero1, notzero2;
-   R* cval;
-   R x1, x2;
+template <class R> void CLUFactor<R>::solveLright(R *vec) {
+  int i, j, k;
+  int end;
+  R x;
+  R *lval, *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
 
-   int* idx;
-   R* val;
+  lval = l.val.data();
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
 
-   rorig = row.orig;
-   corig = col.orig;
+  end = l.firstUpdate;
 
-   cidx = u.col.idx;
-   cval = u.col.val.data();
-   clen = u.col.len;
-   cbeg = u.col.start;
+  for (i = 0; i < end; ++i) {
+    if ((x = vec[lrow[i]]) != 0.0) {
+      MSG_DEBUG(std::cout << "y" << lrow[i] << "=" << vec[lrow[i]]
+                          << std::endl;)
 
-   n = 0;
-
-   for(i = thedim - 1; i >= 0; --i)
-   {
-      c = corig[i];
-      r = rorig[i];
-      p_work1[c] = x1 = diag[r] * vec1[r];
-      p_work2[c] = x2 = diag[r] * vec2[r];
-      vec1[r] = vec2[r] = 0;
-      notzero1 = isNotZero(x1, eps);
-      notzero2 = isNotZero(x2, eps);
-
-      if(notzero1 && notzero2)
-      {
-         *nonz++ = c;
-         n++;
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
-
-         while(j-- > 0)
-         {
-            vec1[*idx] -= x1 * (*val);
-            vec2[*idx++] -= x2 * (*val++);
-         }
-      }
-      else if(notzero1)
-      {
-         p_work2[c] = 0.0;
-         *nonz++ = c;
-         n++;
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
-
-         while(j-- > 0)
-            vec1[*idx++] -= x1 * (*val++);
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
+
+      for (j = lbeg[i + 1]; j > k; --j) {
+        MSG_DEBUG(std::cout << "                         -> y" << *idx
+                            << " -= " << x << " * " << *val << " = "
+                            << x * (*val) << "    -> " << vec[*idx] - x * (*val)
+                            << std::endl;)
+        vec[*idx++] -= x * (*val++);
       }
-      else if(notzero2)
-      {
-         p_work1[c] = 0.0;
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
+    }
+  }
 
-         while(j-- > 0)
-            vec2[*idx++] -= x2 * (*val++);
-      }
-      else
-      {
-         p_work1[c] = 0.0;
-         p_work2[c] = 0.0;
-      }
-   }
+  if (l.updateType) /* Forest-Tomlin Updates */
+  {
+    MSG_DEBUG(std::cout << "performing FT updates..." << std::endl;)
 
-   return n;
-}
+    end = l.firstUnused;
 
-template <class R>
-void CLUFactor<R>::solveLright(R* vec)
-{
-   int i, j, k;
-   int end;
-   R x;
-   R* lval, *val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
-
-   lval = l.val.data();
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-
-   end = l.firstUpdate;
-
-   for(i = 0; i < end; ++i)
-   {
-      if((x = vec[lrow[i]]) != 0.0)
-      {
-         MSG_DEBUG(std::cout << "y" << lrow[i] << "=" << vec[lrow[i]] << std::endl;)
-
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            MSG_DEBUG(std::cout << "                         -> y" << *idx << " -= " << x << " * " << *val <<
-                      " = " << x * (*val) << "    -> " << vec[*idx] - x * (*val) << std::endl;)
-            vec[*idx++] -= x * (*val++);
-         }
-      }
-   }
+    for (; i < end; ++i) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
+      StableSum<R> tmp(-vec[lrow[i]]);
 
-   if(l.updateType)                      /* Forest-Tomlin Updates */
-   {
-      MSG_DEBUG(std::cout << "performing FT updates..." << std::endl;)
+      for (j = lbeg[i + 1]; j > k; --j)
+        tmp += vec[*idx++] * (*val++);
 
-      end = l.firstUnused;
+      vec[lrow[i]] = -R(tmp);
 
-      for(; i < end; ++i)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-         StableSum<R> tmp(-vec[lrow[i]]);
+      MSG_DEBUG(std::cout << "y" << lrow[i] << "=" << vec[lrow[i]]
+                          << std::endl;)
+    }
 
-         for(j = lbeg[i + 1]; j > k; --j)
-            tmp += vec[*idx++] * (*val++);
+    MSG_DEBUG(std::cout << "finished FT updates." << std::endl;)
+  }
+}
 
-         vec[lrow[i]] = -R(tmp);
+template <class R> void CLUFactor<R>::solveLright2(R *vec1, R *vec2) {
+  int i, j, k;
+  int end;
+  R x2;
+  R x1;
+  R *lval, *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
 
-         MSG_DEBUG(std::cout << "y" << lrow[i] << "=" << vec[lrow[i]] << std::endl;)
-      }
+  lval = l.val.data();
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
 
-      MSG_DEBUG(std::cout << "finished FT updates." << std::endl;)
-   }
-}
+  end = l.firstUpdate;
 
-template <class R>
-void CLUFactor<R>::solveLright2(R* vec1, R* vec2)
-{
-   int i, j, k;
-   int end;
-   R x2;
-   R x1;
-   R* lval, *val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
-
-   lval = l.val.data();
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-
-   end = l.firstUpdate;
-
-   for(i = 0; i < end; ++i)
-   {
-      x1 = vec1[lrow[i]];
-      x2 = vec2[lrow[i]];
-
-      if(x1 != 0 && x2 != 0.0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            vec1[*idx] -= x1 * (*val);
-            vec2[*idx++] -= x2 * (*val++);
-         }
-      }
-      else if(x1 != 0.0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+  for (i = 0; i < end; ++i) {
+    x1 = vec1[lrow[i]];
+    x2 = vec2[lrow[i]];
 
-         for(j = lbeg[i + 1]; j > k; --j)
-            vec1[*idx++] -= x1 * (*val++);
-      }
-      else if(x2 != 0.0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+    if (x1 != 0 && x2 != 0.0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-         for(j = lbeg[i + 1]; j > k; --j)
-            vec2[*idx++] -= x2 * (*val++);
+      for (j = lbeg[i + 1]; j > k; --j) {
+        vec1[*idx] -= x1 * (*val);
+        vec2[*idx++] -= x2 * (*val++);
       }
-   }
+    } else if (x1 != 0.0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-   if(l.updateType)                      /* Forest-Tomlin Updates */
-   {
-      end = l.firstUnused;
+      for (j = lbeg[i + 1]; j > k; --j)
+        vec1[*idx++] -= x1 * (*val++);
+    } else if (x2 != 0.0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-      for(; i < end; ++i)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+      for (j = lbeg[i + 1]; j > k; --j)
+        vec2[*idx++] -= x2 * (*val++);
+    }
+  }
 
-         StableSum<Real> tmp1(-vec1[lrow[i]]);
-         StableSum<Real> tmp2(-vec2[lrow[i]]);
+  if (l.updateType) /* Forest-Tomlin Updates */
+  {
+    end = l.firstUnused;
 
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            tmp1 += vec1[*idx] * (*val);
-            tmp2 += vec2[*idx++] * (*val++);
-         }
+    for (; i < end; ++i) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-         vec1[lrow[i]] = -tmp1;
+      StableSum<Real> tmp1(-vec1[lrow[i]]);
+      StableSum<Real> tmp2(-vec2[lrow[i]]);
 
-         vec2[lrow[i]] = -tmp2;
+      for (j = lbeg[i + 1]; j > k; --j) {
+        tmp1 += vec1[*idx] * (*val);
+        tmp2 += vec2[*idx++] * (*val++);
       }
-   }
+
+      vec1[lrow[i]] = -tmp1;
+
+      vec2[lrow[i]] = -tmp2;
+    }
+  }
 }
 
-template <class R>
-void CLUFactor<R>::solveUpdateRight(R* vec)
-{
-   int i, j, k;
-   int end;
-   R x;
-   R* lval, *val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
+template <class R> void CLUFactor<R>::solveUpdateRight(R *vec) {
+  int i, j, k;
+  int end;
+  R x;
+  R *lval, *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
 
-   assert(!l.updateType);               /* no Forest-Tomlin Updates */
+  assert(!l.updateType); /* no Forest-Tomlin Updates */
 
-   lval = l.val.data();
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
+  lval = l.val.data();
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
 
-   end = l.firstUnused;
+  end = l.firstUnused;
 
-   for(i = l.firstUpdate; i < end; ++i)
-   {
-      if((x = vec[lrow[i]]) != 0.0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+  for (i = l.firstUpdate; i < end; ++i) {
+    if ((x = vec[lrow[i]]) != 0.0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-         for(j = lbeg[i + 1]; j > k; --j)
-            vec[*idx++] -= x * (*val++);
-      }
-   }
+      for (j = lbeg[i + 1]; j > k; --j)
+        vec[*idx++] -= x * (*val++);
+    }
+  }
 }
 
-template <class R>
-void CLUFactor<R>::solveUpdateRight2(R* vec1, R* vec2)
-{
-   int i, j, k;
-   int end;
-   R x1, x2;
-   R* lval;
-   int* lrow, *lidx;
-   int* lbeg;
+template <class R> void CLUFactor<R>::solveUpdateRight2(R *vec1, R *vec2) {
+  int i, j, k;
+  int end;
+  R x1, x2;
+  R *lval;
+  int *lrow, *lidx;
+  int *lbeg;
 
-   int* idx;
-   R* val;
+  int *idx;
+  R *val;
 
-   assert(!l.updateType);               /* no Forest-Tomlin Updates */
+  assert(!l.updateType); /* no Forest-Tomlin Updates */
 
-   lval = l.val.data();
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
+  lval = l.val.data();
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
 
-   end = l.firstUnused;
+  end = l.firstUnused;
 
-   for(i = l.firstUpdate; i < end; ++i)
-   {
-      x1 = vec1[lrow[i]];
-      x2 = vec2[lrow[i]];
+  for (i = l.firstUpdate; i < end; ++i) {
+    x1 = vec1[lrow[i]];
+    x2 = vec2[lrow[i]];
 
-      if(x1 != 0.0 && x2 != 0.0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            vec1[*idx] -= x1 * (*val);
-            vec2[*idx++] -= x2 * (*val++);
-         }
-      }
-      else if(x1 != 0.0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+    if (x1 != 0.0 && x2 != 0.0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-         for(j = lbeg[i + 1]; j > k; --j)
-            vec1[*idx++] -= x1 * (*val++);
+      for (j = lbeg[i + 1]; j > k; --j) {
+        vec1[*idx] -= x1 * (*val);
+        vec2[*idx++] -= x2 * (*val++);
       }
-      else if(x2 != 0.0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+    } else if (x1 != 0.0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-         for(j = lbeg[i + 1]; j > k; --j)
-            vec2[*idx++] -= x2 * (*val++);
-      }
-   }
+      for (j = lbeg[i + 1]; j > k; --j)
+        vec1[*idx++] -= x1 * (*val++);
+    } else if (x2 != 0.0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
+
+      for (j = lbeg[i + 1]; j > k; --j)
+        vec2[*idx++] -= x2 * (*val++);
+    }
+  }
 }
 
 template <class R>
-int CLUFactor<R>::solveRight4update(R* vec, int* nonz, R eps,
-                                    R* rhs, R* forest, int* forestNum, int* forestIdx)
-{
-   solveLright(rhs);
+int CLUFactor<R>::solveRight4update(R *vec, int *nonz, R eps, R *rhs, R *forest,
+                                    int *forestNum, int *forestIdx) {
+  solveLright(rhs);
 
-   if(forest)
-   {
-      int n = 0;
+  if (forest) {
+    int n = 0;
 
-      for(int i = 0; i < thedim; i++)
-      {
-         forestIdx[n] = i;
-         forest[i]    = rhs[i];
-         n           += rhs[i] != 0.0 ? 1 : 0;
-      }
+    for (int i = 0; i < thedim; i++) {
+      forestIdx[n] = i;
+      forest[i] = rhs[i];
+      n += rhs[i] != 0.0 ? 1 : 0;
+    }
 
-      *forestNum = n;
-   }
+    *forestNum = n;
+  }
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      solveUright(vec, rhs);
-      solveUpdateRight(vec);
-      return 0;
-   }
-   else
-      return solveUrightEps(vec, nonz, eps, rhs);
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    solveUright(vec, rhs);
+    solveUpdateRight(vec);
+    return 0;
+  } else
+    return solveUrightEps(vec, nonz, eps, rhs);
 }
 
-template <class R>
-void CLUFactor<R>::solveRight(R* vec, R* rhs)
-{
-   solveLright(rhs);
-   solveUright(vec, rhs);
+template <class R> void CLUFactor<R>::solveRight(R *vec, R *rhs) {
+  solveLright(rhs);
+  solveUright(vec, rhs);
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-      solveUpdateRight(vec);
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+    solveUpdateRight(vec);
 }
 
 template <class R>
-int CLUFactor<R>::solveRight2update(R* vec1,
-                                    R* vec2,
-                                    R* rhs1,
-                                    R* rhs2,
-                                    int* nonz,
-                                    R eps,
-                                    R* forest,
-                                    int* forestNum,
-                                    int* forestIdx)
-{
-   solveLright2(rhs1, rhs2);
-
-   if(forest)
-   {
-      int n = 0;
-
-      for(int i = 0; i < thedim; i++)
-      {
-         forestIdx[n] = i;
-         forest[i]    = rhs1[i];
-         n           += rhs1[i] != 0.0 ? 1 : 0;
-      }
+int CLUFactor<R>::solveRight2update(R *vec1, R *vec2, R *rhs1, R *rhs2,
+                                    int *nonz, R eps, R *forest, int *forestNum,
+                                    int *forestIdx) {
+  solveLright2(rhs1, rhs2);
+
+  if (forest) {
+    int n = 0;
+
+    for (int i = 0; i < thedim; i++) {
+      forestIdx[n] = i;
+      forest[i] = rhs1[i];
+      n += rhs1[i] != 0.0 ? 1 : 0;
+    }
 
-      *forestNum = n;
-   }
+    *forestNum = n;
+  }
 
-   if(!l.updateType)            /* no Forest-Tomlin Updates */
-   {
-      solveUright2(vec1, rhs1, vec2, rhs2);
-      solveUpdateRight2(vec1, vec2);
-      return 0;
-   }
-   else
-      return solveUright2eps(vec1, rhs1, vec2, rhs2, nonz, eps);
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    solveUright2(vec1, rhs1, vec2, rhs2);
+    solveUpdateRight2(vec1, vec2);
+    return 0;
+  } else
+    return solveUright2eps(vec1, rhs1, vec2, rhs2, nonz, eps);
 }
 
 template <class R>
-void CLUFactor<R>::solveRight2(
-   R* vec1,
-   R* vec2,
-   R* rhs1,
-   R* rhs2)
-{
-   solveLright2(rhs1, rhs2);
-
-   if(l.updateType)              /* Forest-Tomlin Updates */
-      solveUright2(vec1, rhs1, vec2, rhs2);
-   else
-   {
-      solveUright2(vec1, rhs1, vec2, rhs2);
-      solveUpdateRight2(vec1, vec2);
-   }
+void CLUFactor<R>::solveRight2(R *vec1, R *vec2, R *rhs1, R *rhs2) {
+  solveLright2(rhs1, rhs2);
+
+  if (l.updateType) /* Forest-Tomlin Updates */
+    solveUright2(vec1, rhs1, vec2, rhs2);
+  else {
+    solveUright2(vec1, rhs1, vec2, rhs2);
+    solveUpdateRight2(vec1, vec2);
+  }
 }
 
 /*****************************************************************************/
-template <class R>
-void CLUFactor<R>::solveUleft(R* p_work, R* vec)
-{
-   for(int i = 0; i < thedim; ++i)
-   {
-      int  c  = col.orig[i];
-      int  r  = row.orig[i];
+template <class R> void CLUFactor<R>::solveUleft(R *p_work, R *vec) {
+  for (int i = 0; i < thedim; ++i) {
+    int c = col.orig[i];
+    int r = row.orig[i];
 
-      assert(c >= 0);    // Inna/Tobi: otherwise, vec[c] would be strange...
-      assert(r >= 0);    // Inna/Tobi: otherwise, diag[r] would be strange...
+    assert(c >= 0); // Inna/Tobi: otherwise, vec[c] would be strange...
+    assert(r >= 0); // Inna/Tobi: otherwise, diag[r] would be strange...
 
-      R x  = vec[c];
+    R x = vec[c];
 
+    vec[c] = 0.0;
 
-      vec[c]  = 0.0;
-
-      if(x != 0.0)
-      {
-         DEBUG_CHECK_HUGE_VALUE("WSOLVE01", x);
-         DEBUG_CHECK_HUGE_VALUE("WSOLVE02", diag[r]);
+    if (x != 0.0) {
+      DEBUG_CHECK_HUGE_VALUE("WSOLVE01", x);
+      DEBUG_CHECK_HUGE_VALUE("WSOLVE02", diag[r]);
 
-         x        *= diag[r];
-         p_work[r] = x;
+      x *= diag[r];
+      p_work[r] = x;
 
-         int end = u.row.start[r] + u.row.len[r];
+      int end = u.row.start[r] + u.row.len[r];
 
-         for(int m = u.row.start[r]; m < end; m++)
-         {
-            vec[u.row.idx[m]] -= x * u.row.val[m];
-            DEBUG_CHECK_HUGE_VALUE("WSOLVE03", vec[u.row.idx[m]]);
-         }
+      for (int m = u.row.start[r]; m < end; m++) {
+        vec[u.row.idx[m]] -= x * u.row.val[m];
+        DEBUG_CHECK_HUGE_VALUE("WSOLVE03", vec[u.row.idx[m]]);
       }
-   }
+    }
+  }
 }
 
 template <class R>
-void CLUFactor<R>::solveUleft2(
-   R* p_work1, R* vec1, R* p_work2, R* vec2)
-{
-   R x1;
-   R x2;
-   int i, k, r, c;
-   int* rorig, *corig;
-   int* ridx, *rlen, *rbeg, *idx;
-   R* rval, *val;
-
-   rorig = row.orig;
-   corig = col.orig;
-
-   ridx = u.row.idx;
-   rval = u.row.val.data();
-   rlen = u.row.len;
-   rbeg = u.row.start;
-
-   for(i = 0; i < thedim; ++i)
-   {
-      c = corig[i];
-      r = rorig[i];
-      x1 = vec1[c];
-      x2 = vec2[c];
-
-      if((x1 != 0.0) && (x2 != 0.0))
-      {
-         DEBUG_CHECK_HUGE_VALUE("WSOLVE04", x1);
-         DEBUG_CHECK_HUGE_VALUE("WSOLVE05", x2);
-         DEBUG_CHECK_HUGE_VALUE("WSOLVE06", diag[r]);
-         x1 *= diag[r];
-         x2 *= diag[r];
-         p_work1[r] = x1;
-         p_work2[r] = x2;
-         k = rbeg[r];
-         idx = &ridx[k];
-         val = &rval[k];
-
-         for(int m = rlen[r]; m != 0; --m)
-         {
-            vec1[*idx] -= x1 * (*val);
-            vec2[*idx] -= x2 * (*val++);
-            DEBUG_CHECK_HUGE_VALUE("WSOLVE07", vec1[*idx]);
-            DEBUG_CHECK_HUGE_VALUE("WSOLVE08", vec2[*idx]);
-            idx++;
-         }
+void CLUFactor<R>::solveUleft2(R *p_work1, R *vec1, R *p_work2, R *vec2) {
+  R x1;
+  R x2;
+  int i, k, r, c;
+  int *rorig, *corig;
+  int *ridx, *rlen, *rbeg, *idx;
+  R *rval, *val;
+
+  rorig = row.orig;
+  corig = col.orig;
+
+  ridx = u.row.idx;
+  rval = u.row.val.data();
+  rlen = u.row.len;
+  rbeg = u.row.start;
+
+  for (i = 0; i < thedim; ++i) {
+    c = corig[i];
+    r = rorig[i];
+    x1 = vec1[c];
+    x2 = vec2[c];
+
+    if ((x1 != 0.0) && (x2 != 0.0)) {
+      DEBUG_CHECK_HUGE_VALUE("WSOLVE04", x1);
+      DEBUG_CHECK_HUGE_VALUE("WSOLVE05", x2);
+      DEBUG_CHECK_HUGE_VALUE("WSOLVE06", diag[r]);
+      x1 *= diag[r];
+      x2 *= diag[r];
+      p_work1[r] = x1;
+      p_work2[r] = x2;
+      k = rbeg[r];
+      idx = &ridx[k];
+      val = &rval[k];
+
+      for (int m = rlen[r]; m != 0; --m) {
+        vec1[*idx] -= x1 * (*val);
+        vec2[*idx] -= x2 * (*val++);
+        DEBUG_CHECK_HUGE_VALUE("WSOLVE07", vec1[*idx]);
+        DEBUG_CHECK_HUGE_VALUE("WSOLVE08", vec2[*idx]);
+        idx++;
       }
-      else if(x1 != 0.0)
-      {
-         DEBUG_CHECK_HUGE_VALUE("WSOLVE09", x1);
-         DEBUG_CHECK_HUGE_VALUE("WSOLVE10", diag[r]);
-         x1 *= diag[r];
-         p_work1[r] = x1;
-         k = rbeg[r];
-         idx = &ridx[k];
-         val = &rval[k];
-
-         for(int m = rlen[r]; m != 0; --m)
-         {
-            vec1[*idx] -= x1 * (*val++);
-            DEBUG_CHECK_HUGE_VALUE("WSOLVE11", vec1[*idx]);
-            idx++;
-         }
+    } else if (x1 != 0.0) {
+      DEBUG_CHECK_HUGE_VALUE("WSOLVE09", x1);
+      DEBUG_CHECK_HUGE_VALUE("WSOLVE10", diag[r]);
+      x1 *= diag[r];
+      p_work1[r] = x1;
+      k = rbeg[r];
+      idx = &ridx[k];
+      val = &rval[k];
+
+      for (int m = rlen[r]; m != 0; --m) {
+        vec1[*idx] -= x1 * (*val++);
+        DEBUG_CHECK_HUGE_VALUE("WSOLVE11", vec1[*idx]);
+        idx++;
       }
-      else if(x2 != 0.0)
-      {
-         DEBUG_CHECK_HUGE_VALUE("WSOLVE12", x2);
-         DEBUG_CHECK_HUGE_VALUE("WSOLVE13", diag[r]);
-         x2 *= diag[r];
-         p_work2[r] = x2;
-         k = rbeg[r];
-         idx = &ridx[k];
-         val = &rval[k];
-
-         for(int m = rlen[r]; m != 0; --m)
-         {
-            vec2[*idx] -= x2 * (*val++);
-            DEBUG_CHECK_HUGE_VALUE("WSOLVE14", vec2[*idx]);
-            idx++;
-         }
+    } else if (x2 != 0.0) {
+      DEBUG_CHECK_HUGE_VALUE("WSOLVE12", x2);
+      DEBUG_CHECK_HUGE_VALUE("WSOLVE13", diag[r]);
+      x2 *= diag[r];
+      p_work2[r] = x2;
+      k = rbeg[r];
+      idx = &ridx[k];
+      val = &rval[k];
+
+      for (int m = rlen[r]; m != 0; --m) {
+        vec2[*idx] -= x2 * (*val++);
+        DEBUG_CHECK_HUGE_VALUE("WSOLVE14", vec2[*idx]);
+        idx++;
       }
-   }
+    }
+  }
 }
 
 template <class R>
-int CLUFactor<R>::solveLleft2forest(
-   R* vec1,
-   int* /* nonz */,
-   R* vec2,
-   R /* eps */)
-{
-   int i;
-   int j;
-   int k;
-   int end;
-   R x1, x2;
-   R* lval, *val;
-   int* lidx, *idx, *lrow;
-   int* lbeg;
-
-   lval = l.val.data();
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-
-   end = l.firstUpdate;
-
-   for(i = l.firstUnused - 1; i >= end; --i)
-   {
-      j = lrow[i];
-      x1 = vec1[j];
-      x2 = vec2[j];
-
-      if(x1 != 0.0)
-      {
-         if(x2 != 0.0)
-         {
-            k = lbeg[i];
-            val = &lval[k];
-            idx = &lidx[k];
-
-            for(j = lbeg[i + 1]; j > k; --j)
-            {
-               vec1[*idx] -= x1 * (*val);
-               vec2[*idx++] -= x2 * (*val++);
-            }
-         }
-         else
-         {
-            k = lbeg[i];
-            val = &lval[k];
-            idx = &lidx[k];
-
-            for(j = lbeg[i + 1]; j > k; --j)
-               vec1[*idx++] -= x1 * (*val++);
-         }
+int CLUFactor<R>::solveLleft2forest(R *vec1, int * /* nonz */, R *vec2,
+                                    R /* eps */) {
+  int i;
+  int j;
+  int k;
+  int end;
+  R x1, x2;
+  R *lval, *val;
+  int *lidx, *idx, *lrow;
+  int *lbeg;
+
+  lval = l.val.data();
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
+
+  end = l.firstUpdate;
+
+  for (i = l.firstUnused - 1; i >= end; --i) {
+    j = lrow[i];
+    x1 = vec1[j];
+    x2 = vec2[j];
+
+    if (x1 != 0.0) {
+      if (x2 != 0.0) {
+        k = lbeg[i];
+        val = &lval[k];
+        idx = &lidx[k];
+
+        for (j = lbeg[i + 1]; j > k; --j) {
+          vec1[*idx] -= x1 * (*val);
+          vec2[*idx++] -= x2 * (*val++);
+        }
+      } else {
+        k = lbeg[i];
+        val = &lval[k];
+        idx = &lidx[k];
+
+        for (j = lbeg[i + 1]; j > k; --j)
+          vec1[*idx++] -= x1 * (*val++);
       }
-      else if(x2 != 0.0)
-      {
-         k = lbeg[i];
-         val = &lval[k];
-         idx = &lidx[k];
+    } else if (x2 != 0.0) {
+      k = lbeg[i];
+      val = &lval[k];
+      idx = &lidx[k];
 
-         for(j = lbeg[i + 1]; j > k; --j)
-            vec2[*idx++] -= x2 * (*val++);
-      }
-   }
+      for (j = lbeg[i + 1]; j > k; --j)
+        vec2[*idx++] -= x2 * (*val++);
+    }
+  }
 
-   return 0;
+  return 0;
 }
 
 template <class R>
-void CLUFactor<R>::solveLleft2(
-   R* vec1,
-   int* /* nonz */,
-   R* vec2,
-   R /* eps */)
-{
-   int i, j, k, r;
-   int x1not0, x2not0;
-   R x1, x2;
-
-   R* rval, *val;
-   int* ridx, *idx;
-   int* rbeg;
-   int* rorig;
-
-   ridx  = l.ridx;
-   rval  = l.rval.data();
-   rbeg  = l.rbeg;
-   rorig = l.rorig;
+void CLUFactor<R>::solveLleft2(R *vec1, int * /* nonz */, R *vec2,
+                               R /* eps */) {
+  int i, j, k, r;
+  int x1not0, x2not0;
+  R x1, x2;
+
+  R *rval, *val;
+  int *ridx, *idx;
+  int *rbeg;
+  int *rorig;
+
+  ridx = l.ridx;
+  rval = l.rval.data();
+  rbeg = l.rbeg;
+  rorig = l.rorig;
 
 #ifndef WITH_L_ROWS
-   R*   lval  = l.val.data();
-   int*    lidx  = l.idx;
-   int*    lrow  = l.row;
-   int*    lbeg  = l.start;
-
-   i = l.firstUpdate - 1;
-
-   for(; i >= 0; --i)
-   {
-      k = lbeg[i];
-      val = &lval[k];
-      idx = &lidx[k];
-      x1 = 0;
-      x2 = 0;
-
-      for(j = lbeg[i + 1]; j > k; --j)
-      {
-         x1 += vec1[*idx] * (*val);
-         x2 += vec2[*idx++] * (*val++);
-      }
+  R *lval = l.val.data();
+  int *lidx = l.idx;
+  int *lrow = l.row;
+  int *lbeg = l.start;
+
+  i = l.firstUpdate - 1;
+
+  for (; i >= 0; --i) {
+    k = lbeg[i];
+    val = &lval[k];
+    idx = &lidx[k];
+    x1 = 0;
+    x2 = 0;
+
+    for (j = lbeg[i + 1]; j > k; --j) {
+      x1 += vec1[*idx] * (*val);
+      x2 += vec2[*idx++] * (*val++);
+    }
 
-      vec1[lrow[i]] -= x1;
+    vec1[lrow[i]] -= x1;
 
-      vec2[lrow[i]] -= x2;
-   }
+    vec2[lrow[i]] -= x2;
+  }
 
 #else
 
-   for(i = thedim; i--;)
-   {
-      r = rorig[i];
-      x1 = vec1[r];
-      x2 = vec2[r];
-      x1not0 = (x1 != 0);
-      x2not0 = (x2 != 0);
-
-      if(x1not0 && x2not0)
-      {
-         k = rbeg[r];
-         j = rbeg[r + 1] - k;
-         val = &rval[k];
-         idx = &ridx[k];
-
-         while(j-- > 0)
-         {
-            assert(row.perm[*idx] < i);
-            vec1[*idx] -= x1 * *val;
-            vec2[*idx++] -= x2 * *val++;
-         }
+  for (i = thedim; i--;) {
+    r = rorig[i];
+    x1 = vec1[r];
+    x2 = vec2[r];
+    x1not0 = (x1 != 0);
+    x2not0 = (x2 != 0);
+
+    if (x1not0 && x2not0) {
+      k = rbeg[r];
+      j = rbeg[r + 1] - k;
+      val = &rval[k];
+      idx = &ridx[k];
+
+      while (j-- > 0) {
+        assert(row.perm[*idx] < i);
+        vec1[*idx] -= x1 * *val;
+        vec2[*idx++] -= x2 * *val++;
       }
-      else if(x1not0)
-      {
-         k = rbeg[r];
-         j = rbeg[r + 1] - k;
-         val = &rval[k];
-         idx = &ridx[k];
-
-         while(j-- > 0)
-         {
-            assert(row.perm[*idx] < i);
-            vec1[*idx++] -= x1 * *val++;
-         }
+    } else if (x1not0) {
+      k = rbeg[r];
+      j = rbeg[r + 1] - k;
+      val = &rval[k];
+      idx = &ridx[k];
+
+      while (j-- > 0) {
+        assert(row.perm[*idx] < i);
+        vec1[*idx++] -= x1 * *val++;
       }
-      else if(x2not0)
-      {
-         k = rbeg[r];
-         j = rbeg[r + 1] - k;
-         val = &rval[k];
-         idx = &ridx[k];
-
-         while(j-- > 0)
-         {
-            assert(row.perm[*idx] < i);
-            vec2[*idx++] -= x2 * *val++;
-         }
+    } else if (x2not0) {
+      k = rbeg[r];
+      j = rbeg[r + 1] - k;
+      val = &rval[k];
+      idx = &ridx[k];
+
+      while (j-- > 0) {
+        assert(row.perm[*idx] < i);
+        vec2[*idx++] -= x2 * *val++;
       }
-   }
+    }
+  }
 
 #endif
 }
 
 template <class R>
-int CLUFactor<R>::solveLleftForest(R* vec, int* /* nonz */, R /* eps */)
-{
-   int i, j, k, end;
-   R x;
-   R* val, *lval;
-   int* idx, *lidx, *lrow, *lbeg;
+int CLUFactor<R>::solveLleftForest(R *vec, int * /* nonz */, R /* eps */) {
+  int i, j, k, end;
+  R x;
+  R *val, *lval;
+  int *idx, *lidx, *lrow, *lbeg;
 
-   lval = l.val.data();
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
+  lval = l.val.data();
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
 
-   end = l.firstUpdate;
+  end = l.firstUpdate;
 
-   for(i = l.firstUnused - 1; i >= end; --i)
-   {
-      if((x = vec[lrow[i]]) != 0.0)
-      {
-         k = lbeg[i];
-         val = &lval[k];
-         idx = &lidx[k];
+  for (i = l.firstUnused - 1; i >= end; --i) {
+    if ((x = vec[lrow[i]]) != 0.0) {
+      k = lbeg[i];
+      val = &lval[k];
+      idx = &lidx[k];
 
-         for(j = lbeg[i + 1]; j > k; --j)
-            vec[*idx++] -= x * (*val++);
-      }
-   }
+      for (j = lbeg[i + 1]; j > k; --j)
+        vec[*idx++] -= x * (*val++);
+    }
+  }
 
-   return 0;
+  return 0;
 }
 
-template <class R>
-void CLUFactor<R>::solveLleft(R* vec) const
-{
+template <class R> void CLUFactor<R>::solveLleft(R *vec) const {
 
 #ifndef WITH_L_ROWS
-   int*  idx;
-   R* val;
-   R* lval  = l.val.data();
-   int*  lidx  = l.idx;
-   int*  lrow  = l.row;
-   int*  lbeg  = l.start;
-
-   for(int i = l.firstUpdate - 1; i >= 0; --i)
-   {
-      int k = lbeg[i];
-      val = &lval[k];
-      idx = &lidx[k];
-      x = 0;
+  int *idx;
+  R *val;
+  R *lval = l.val.data();
+  int *lidx = l.idx;
+  int *lrow = l.row;
+  int *lbeg = l.start;
 
-      for(int j = lbeg[i + 1]; j > k; --j)
-         x += vec[*idx++] * (*val++);
+  for (int i = l.firstUpdate - 1; i >= 0; --i) {
+    int k = lbeg[i];
+    val = &lval[k];
+    idx = &lidx[k];
+    x = 0;
 
-      vec[lrow[i]] -= x;
-   }
+    for (int j = lbeg[i + 1]; j > k; --j)
+      x += vec[*idx++] * (*val++);
+
+    vec[lrow[i]] -= x;
+  }
 
 #else
 
-   for(int i = thedim - 1; i >= 0; --i)
-   {
-      int  r = l.rorig[i];
-      R x = vec[r];
+  for (int i = thedim - 1; i >= 0; --i) {
+    int r = l.rorig[i];
+    R x = vec[r];
 
-      if(x != 0.0)
-      {
-         for(int k = l.rbeg[r]; k < l.rbeg[r + 1]; k++)
-         {
-            int j = l.ridx[k];
+    if (x != 0.0) {
+      for (int k = l.rbeg[r]; k < l.rbeg[r + 1]; k++) {
+        int j = l.ridx[k];
 
-            assert(l.rperm[j] < i);
+        assert(l.rperm[j] < i);
 
-            vec[j] -= x * l.rval[k];
-         }
+        vec[j] -= x * l.rval[k];
       }
-   }
+    }
+  }
 
 #endif // WITH_L_ROWS
 }
 
-template <class R>
-int CLUFactor<R>::solveLleftEps(R* vec, int* nonz, R eps)
-{
-   int i, j, k, n;
-   int r;
-   R x;
-   R* rval, *val;
-   int* ridx, *idx;
-   int* rbeg;
-   int* rorig;
-
-   ridx = l.ridx;
-   rval = l.rval.data();
-   rbeg = l.rbeg;
-   rorig = l.rorig;
-   n = 0;
+template <class R> int CLUFactor<R>::solveLleftEps(R *vec, int *nonz, R eps) {
+  int i, j, k, n;
+  int r;
+  R x;
+  R *rval, *val;
+  int *ridx, *idx;
+  int *rbeg;
+  int *rorig;
+
+  ridx = l.ridx;
+  rval = l.rval.data();
+  rbeg = l.rbeg;
+  rorig = l.rorig;
+  n = 0;
 #ifndef WITH_L_ROWS
-   R* lval = l.val.data();
-   int*  lidx = l.idx;
-   int*  lrow = l.row;
-   int*  lbeg = l.start;
+  R *lval = l.val.data();
+  int *lidx = l.idx;
+  int *lrow = l.row;
+  int *lbeg = l.start;
 
-   for(i = l.firstUpdate - 1; i >= 0; --i)
-   {
-      k = lbeg[i];
-      val = &lval[k];
-      idx = &lidx[k];
-      x = 0;
+  for (i = l.firstUpdate - 1; i >= 0; --i) {
+    k = lbeg[i];
+    val = &lval[k];
+    idx = &lidx[k];
+    x = 0;
 
-      for(j = lbeg[i + 1]; j > k; --j)
-         x += vec[*idx++] * (*val++);
+    for (j = lbeg[i + 1]; j > k; --j)
+      x += vec[*idx++] * (*val++);
 
-      vec[lrow[i]] -= x;
-   }
+    vec[lrow[i]] -= x;
+  }
 
 #else
 
-   for(i = thedim; i--;)
-   {
-      r = rorig[i];
-      x = vec[r];
-
-      if(isNotZero(x, eps))
-      {
-         *nonz++ = r;
-         n++;
-         k = rbeg[r];
-         j = rbeg[r + 1] - k;
-         val = &rval[k];
-         idx = &ridx[k];
-
-         while(j-- > 0)
-         {
-            assert(row.perm[*idx] < i);
-            vec[*idx++] -= x * *val++;
-         }
+  for (i = thedim; i--;) {
+    r = rorig[i];
+    x = vec[r];
+
+    if (isNotZero(x, eps)) {
+      *nonz++ = r;
+      n++;
+      k = rbeg[r];
+      j = rbeg[r + 1] - k;
+      val = &rval[k];
+      idx = &ridx[k];
+
+      while (j-- > 0) {
+        assert(row.perm[*idx] < i);
+        vec[*idx++] -= x * *val++;
       }
-      else
-         vec[r] = 0;
-   }
+    } else
+      vec[r] = 0;
+  }
 
 #endif
 
-   return n;
+  return n;
 }
 
-template <class R>
-void CLUFactor<R>::solveUpdateLeft(R* vec)
-{
-   int i, j, k, end;
-   R* lval, *val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
+template <class R> void CLUFactor<R>::solveUpdateLeft(R *vec) {
+  int i, j, k, end;
+  R *lval, *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
 
-   lval = l.val.data();
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
+  lval = l.val.data();
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
 
-   assert(!l.updateType);               /* Forest-Tomlin Updates */
+  assert(!l.updateType); /* Forest-Tomlin Updates */
 
-   end = l.firstUpdate;
+  end = l.firstUpdate;
 
-   for(i = l.firstUnused - 1; i >= end; --i)
-   {
-      k = lbeg[i];
-      val = &lval[k];
-      idx = &lidx[k];
-      StableSum<R> tmp(-vec[lrow[i]]);
+  for (i = l.firstUnused - 1; i >= end; --i) {
+    k = lbeg[i];
+    val = &lval[k];
+    idx = &lidx[k];
+    StableSum<R> tmp(-vec[lrow[i]]);
 
-      for(j = lbeg[i + 1]; j > k; --j)
-         tmp += vec[*idx++] * (*val++);
+    for (j = lbeg[i + 1]; j > k; --j)
+      tmp += vec[*idx++] * (*val++);
 
-      vec[lrow[i]] = -R(tmp);
-   }
+    vec[lrow[i]] = -R(tmp);
+  }
 }
 
-template <class R>
-void CLUFactor<R>::solveUpdateLeft2(R* vec1, R* vec2)
-{
-   int i, j, k, end;
-   R* lval, *val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
+template <class R> void CLUFactor<R>::solveUpdateLeft2(R *vec1, R *vec2) {
+  int i, j, k, end;
+  R *lval, *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
 
-   lval = l.val.data();
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
+  lval = l.val.data();
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
 
-   assert(!l.updateType);               /* Forest-Tomlin Updates */
+  assert(!l.updateType); /* Forest-Tomlin Updates */
 
-   end = l.firstUpdate;
+  end = l.firstUpdate;
 
-   for(i = l.firstUnused - 1; i >= end; --i)
-   {
-      k = lbeg[i];
-      val = &lval[k];
-      idx = &lidx[k];
+  for (i = l.firstUnused - 1; i >= end; --i) {
+    k = lbeg[i];
+    val = &lval[k];
+    idx = &lidx[k];
 
-      StableSum<R> tmp1(-vec1[lrow[i]]);
-      StableSum<R> tmp2(-vec2[lrow[i]]);
+    StableSum<R> tmp1(-vec1[lrow[i]]);
+    StableSum<R> tmp2(-vec2[lrow[i]]);
 
-      for(j = lbeg[i + 1]; j > k; --j)
-      {
-         tmp1 += vec1[*idx] * (*val);
-         tmp2 += vec2[*idx++] * (*val++);
-      }
+    for (j = lbeg[i + 1]; j > k; --j) {
+      tmp1 += vec1[*idx] * (*val);
+      tmp2 += vec2[*idx++] * (*val++);
+    }
 
-      vec1[lrow[i]] = -tmp1;
-      vec2[lrow[i]] = -tmp2;
-   }
+    vec1[lrow[i]] = -tmp1;
+    vec2[lrow[i]] = -tmp2;
+  }
 }
 
 template <class R>
-int CLUFactor<R>::solveUpdateLeft(R eps, R* vec, int* nonz, int n)
-{
-   int i, j, k, end;
-   R y;
-   R* lval, *val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
+int CLUFactor<R>::solveUpdateLeft(R eps, R *vec, int *nonz, int n) {
+  int i, j, k, end;
+  R y;
+  R *lval, *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
 
-   assert(!l.updateType);               /* no Forest-Tomlin Updates! */
+  assert(!l.updateType); /* no Forest-Tomlin Updates! */
 
-   lval = l.val.data();
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
+  lval = l.val.data();
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
 
-   end = l.firstUpdate;
+  end = l.firstUpdate;
 
-   for(i = l.firstUnused - 1; i >= end; --i)
-   {
-      k = lbeg[i];
-      assert(k >= 0 && k < l.size);
-      val = &lval[k];
-      idx = &lidx[k];
+  for (i = l.firstUnused - 1; i >= end; --i) {
+    k = lbeg[i];
+    assert(k >= 0 && k < l.size);
+    val = &lval[k];
+    idx = &lidx[k];
 
-      k = lrow[i];
+    k = lrow[i];
 
-      y = vec[k];
-      StableSum<R> tmp(-y);
+    y = vec[k];
+    StableSum<R> tmp(-y);
 
-      for(j = lbeg[i + 1]; j > k; --j)
-      {
-         assert(*idx >= 0 && *idx < thedim);
-         tmp += vec[*idx++] * (*val++);
-      }
+    for (j = lbeg[i + 1]; j > k; --j) {
+      assert(*idx >= 0 && *idx < thedim);
+      tmp += vec[*idx++] * (*val++);
+    }
 
-      if(y == 0)
-      {
-         y = -R(tmp);
+    if (y == 0) {
+      y = -R(tmp);
 
-         if(isNotZero(y, eps))
-         {
-            nonz[n++] = k;
-            vec[k] = y;
-         }
-      }
-      else
-      {
-         y = -R(tmp);
-         vec[k] = (y != 0) ? y : SOPLEX_FACTOR_MARKER;
+      if (isNotZero(y, eps)) {
+        nonz[n++] = k;
+        vec[k] = y;
       }
-   }
+    } else {
+      y = -R(tmp);
+      vec[k] = (y != 0) ? y : SOPLEX_FACTOR_MARKER;
+    }
+  }
 
-   return n;
+  return n;
 }
 
-template <class R>
-void CLUFactor<R>::solveLeft(R* vec, R* rhs)
-{
-
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      solveUpdateLeft(rhs);
-      solveUleft(vec, rhs);
-      solveLleft(vec);
-   }
-   else
-   {
-      solveUleft(vec, rhs);
-      //@todo is 0.0 the right value for eps here ?
-      solveLleftForest(vec, 0, 0.0);
-      solveLleft(vec);
-   }
+template <class R> void CLUFactor<R>::solveLeft(R *vec, R *rhs) {
+
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    solveUpdateLeft(rhs);
+    solveUleft(vec, rhs);
+    solveLleft(vec);
+  } else {
+    solveUleft(vec, rhs);
+    //@todo is 0.0 the right value for eps here ?
+    solveLleftForest(vec, 0, 0.0);
+    solveLleft(vec);
+  }
 }
 
 template <class R>
-int CLUFactor<R>::solveLeftEps(R* vec, R* rhs, int* nonz, R eps)
-{
-
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      solveUpdateLeft(rhs);
-      solveUleft(vec, rhs);
-      return solveLleftEps(vec, nonz, eps);
-   }
-   else
-   {
-      solveUleft(vec, rhs);
-      solveLleftForest(vec, nonz, eps);
-      return solveLleftEps(vec, nonz, eps);
-   }
+int CLUFactor<R>::solveLeftEps(R *vec, R *rhs, int *nonz, R eps) {
+
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    solveUpdateLeft(rhs);
+    solveUleft(vec, rhs);
+    return solveLleftEps(vec, nonz, eps);
+  } else {
+    solveUleft(vec, rhs);
+    solveLleftForest(vec, nonz, eps);
+    return solveLleftEps(vec, nonz, eps);
+  }
 }
 
 template <class R>
-int CLUFactor<R>::solveLeft2(
-   R* vec1,
-   int* nonz,
-   R* vec2,
-   R eps,
-   R* rhs1,
-   R* rhs2)
-{
-
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      solveUpdateLeft2(rhs1, rhs2);
-      solveUleft2(vec1, rhs1, vec2, rhs2);
-      solveLleft2(vec1, nonz, vec2, eps);
-      return 0;
-   }
-   else
-   {
-      solveUleft2(vec1, rhs1, vec2, rhs2);
-      solveLleft2forest(vec1, nonz, vec2, eps);
-      solveLleft2(vec1, nonz, vec2, eps);
-      return 0;
-   }
+int CLUFactor<R>::solveLeft2(R *vec1, int *nonz, R *vec2, R eps, R *rhs1,
+                             R *rhs2) {
+
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    solveUpdateLeft2(rhs1, rhs2);
+    solveUleft2(vec1, rhs1, vec2, rhs2);
+    solveLleft2(vec1, nonz, vec2, eps);
+    return 0;
+  } else {
+    solveUleft2(vec1, rhs1, vec2, rhs2);
+    solveLleft2forest(vec1, nonz, vec2, eps);
+    solveLleft2(vec1, nonz, vec2, eps);
+    return 0;
+  }
 }
 
 template <class R>
-int CLUFactor<R>::solveUleft(R eps,
-                             R* vec, int* vecidx,
-                             R* rhs, int* rhsidx, int rhsn)
-{
-   R x, y;
-   int i, j, k, n, r, c;
-   int* rorig, *corig, *cperm;
-   int* ridx, *rlen, *rbeg, *idx;
-   R* rval, *val;
+int CLUFactor<R>::solveUleft(R eps, R *vec, int *vecidx, R *rhs, int *rhsidx,
+                             int rhsn) {
+  R x, y;
+  int i, j, k, n, r, c;
+  int *rorig, *corig, *cperm;
+  int *ridx, *rlen, *rbeg, *idx;
+  R *rval, *val;
 
-   rorig = row.orig;
-   corig = col.orig;
-   cperm = col.perm;
+  rorig = row.orig;
+  corig = col.orig;
+  cperm = col.perm;
 
-   /*  move rhsidx to a heap
-    */
+  /*  move rhsidx to a heap
+   */
 
-   for(i = 0; i < rhsn;)
-      enQueueMin(rhsidx, &i, cperm[rhsidx[i]]);
+  for (i = 0; i < rhsn;)
+    enQueueMin(rhsidx, &i, cperm[rhsidx[i]]);
 
-   ridx = u.row.idx;
+  ridx = u.row.idx;
 
-   rval = u.row.val.data();
+  rval = u.row.val.data();
 
-   rlen = u.row.len;
+  rlen = u.row.len;
 
-   rbeg = u.row.start;
+  rbeg = u.row.start;
 
-   n = 0;
+  n = 0;
 
-   while(rhsn > 0)
-   {
-      i = deQueueMin(rhsidx, &rhsn);
-      assert(i >= 0 && i < thedim);
-      c = corig[i];
-      assert(c >= 0 && c < thedim);
-      x = rhs[c];
-      rhs[c] = 0;
+  while (rhsn > 0) {
+    i = deQueueMin(rhsidx, &rhsn);
+    assert(i >= 0 && i < thedim);
+    c = corig[i];
+    assert(c >= 0 && c < thedim);
+    x = rhs[c];
+    rhs[c] = 0;
 
-      if(isNotZero(x, eps))
-      {
-         r = rorig[i];
-         assert(r >= 0 && r < thedim);
-         vecidx[n++] = r;
-         x *= diag[r];
-         vec[r] = x;
-         k = rbeg[r];
-         assert(k >= 0 && k < u.row.size);
-         idx = &ridx[k];
-         val = &rval[k];
-
-         for(int m = rlen[r]; m; --m)
-         {
-            j = *idx++;
-            assert(j >= 0 && j < thedim);
-            y = rhs[j];
-
-            if(y == 0)
-            {
-               y = -x * (*val++);
-
-               if(isNotZero(y, eps))
-               {
-                  rhs[j] = y;
-                  enQueueMin(rhsidx, &rhsn, cperm[j]);
-               }
-            }
-            else
-            {
-               y -= x * (*val++);
-               rhs[j] = (y != 0) ? y : SOPLEX_FACTOR_MARKER;
-            }
-         }
+    if (isNotZero(x, eps)) {
+      r = rorig[i];
+      assert(r >= 0 && r < thedim);
+      vecidx[n++] = r;
+      x *= diag[r];
+      vec[r] = x;
+      k = rbeg[r];
+      assert(k >= 0 && k < u.row.size);
+      idx = &ridx[k];
+      val = &rval[k];
+
+      for (int m = rlen[r]; m; --m) {
+        j = *idx++;
+        assert(j >= 0 && j < thedim);
+        y = rhs[j];
+
+        if (y == 0) {
+          y = -x * (*val++);
+
+          if (isNotZero(y, eps)) {
+            rhs[j] = y;
+            enQueueMin(rhsidx, &rhsn, cperm[j]);
+          }
+        } else {
+          y -= x * (*val++);
+          rhs[j] = (y != 0) ? y : SOPLEX_FACTOR_MARKER;
+        }
       }
-   }
+    }
+  }
 
-   return n;
+  return n;
 }
 
-
 template <class R>
-void CLUFactor<R>::solveUleftNoNZ(R eps, R* vec,
-                                  R* rhs, int* rhsidx, int rhsn)
-{
-   R x, y;
-   int i, j, k, r, c;
-   int* rorig, *corig, *cperm;
-   int* ridx, *rlen, *rbeg, *idx;
-   R* rval, *val;
+void CLUFactor<R>::solveUleftNoNZ(R eps, R *vec, R *rhs, int *rhsidx,
+                                  int rhsn) {
+  R x, y;
+  int i, j, k, r, c;
+  int *rorig, *corig, *cperm;
+  int *ridx, *rlen, *rbeg, *idx;
+  R *rval, *val;
 
-   rorig = row.orig;
-   corig = col.orig;
-   cperm = col.perm;
+  rorig = row.orig;
+  corig = col.orig;
+  cperm = col.perm;
 
-   /*  move rhsidx to a heap
-    */
+  /*  move rhsidx to a heap
+   */
 
-   for(i = 0; i < rhsn;)
-      enQueueMin(rhsidx, &i, cperm[rhsidx[i]]);
+  for (i = 0; i < rhsn;)
+    enQueueMin(rhsidx, &i, cperm[rhsidx[i]]);
 
-   ridx = u.row.idx;
+  ridx = u.row.idx;
 
-   rval = u.row.val.data();
+  rval = u.row.val.data();
 
-   rlen = u.row.len;
+  rlen = u.row.len;
 
-   rbeg = u.row.start;
+  rbeg = u.row.start;
 
-   while(rhsn > 0)
-   {
-      i = deQueueMin(rhsidx, &rhsn);
-      assert(i >= 0 && i < thedim);
-      c = corig[i];
-      assert(c >= 0 && c < thedim);
-      x = rhs[c];
-      rhs[c] = 0;
+  while (rhsn > 0) {
+    i = deQueueMin(rhsidx, &rhsn);
+    assert(i >= 0 && i < thedim);
+    c = corig[i];
+    assert(c >= 0 && c < thedim);
+    x = rhs[c];
+    rhs[c] = 0;
 
-      if(isNotZero(x, eps))
-      {
-         r = rorig[i];
-         assert(r >= 0 && r < thedim);
-         x *= diag[r];
-         vec[r] = x;
-         k = rbeg[r];
-         assert(k >= 0 && k < u.row.size);
-         idx = &ridx[k];
-         val = &rval[k];
-
-         for(int m = rlen[r]; m; --m)
-         {
-            j = *idx++;
-            assert(j >= 0 && j < thedim);
-            y = rhs[j];
-
-            if(y == 0)
-            {
-               y = -x * (*val++);
-
-               if(isNotZero(y, eps))
-               {
-                  rhs[j] = y;
-                  enQueueMin(rhsidx, &rhsn, cperm[j]);
-               }
-            }
-            else
-            {
-               y -= x * (*val++);
-               rhs[j] = (y != 0) ? y : SOPLEX_FACTOR_MARKER;
-            }
-         }
+    if (isNotZero(x, eps)) {
+      r = rorig[i];
+      assert(r >= 0 && r < thedim);
+      x *= diag[r];
+      vec[r] = x;
+      k = rbeg[r];
+      assert(k >= 0 && k < u.row.size);
+      idx = &ridx[k];
+      val = &rval[k];
+
+      for (int m = rlen[r]; m; --m) {
+        j = *idx++;
+        assert(j >= 0 && j < thedim);
+        y = rhs[j];
+
+        if (y == 0) {
+          y = -x * (*val++);
+
+          if (isNotZero(y, eps)) {
+            rhs[j] = y;
+            enQueueMin(rhsidx, &rhsn, cperm[j]);
+          }
+        } else {
+          y -= x * (*val++);
+          rhs[j] = (y != 0) ? y : SOPLEX_FACTOR_MARKER;
+        }
       }
-   }
+    }
+  }
 }
 
-
 template <class R>
-int CLUFactor<R>::solveLleftForest(R eps, R* vec, int* nonz, int n)
-{
-   int i, j, k, end;
-   R x, y;
-   R* val, *lval;
-   int* idx, *lidx, *lrow, *lbeg;
-
-   lval = l.val.data();
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-   end = l.firstUpdate;
-
-   for(i = l.firstUnused - 1; i >= end; --i)
-   {
-      assert(i >= 0 && i < l.size);
+int CLUFactor<R>::solveLleftForest(R eps, R *vec, int *nonz, int n) {
+  int i, j, k, end;
+  R x, y;
+  R *val, *lval;
+  int *idx, *lidx, *lrow, *lbeg;
+
+  lval = l.val.data();
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
+  end = l.firstUpdate;
+
+  for (i = l.firstUnused - 1; i >= end; --i) {
+    assert(i >= 0 && i < l.size);
+
+    if ((x = vec[lrow[i]]) != 0.0) {
+      k = lbeg[i];
+      assert(k >= 0 && k < l.size);
+      val = &lval[k];
+      idx = &lidx[k];
 
-      if((x = vec[lrow[i]]) != 0.0)
-      {
-         k = lbeg[i];
-         assert(k >= 0 && k < l.size);
-         val = &lval[k];
-         idx = &lidx[k];
-
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            int m = *idx++;
-            assert(m >= 0 && m < thedim);
-            y = vec[m];
-
-            if(y == 0)
-            {
-               y = -x * (*val++);
-
-               if(isNotZero(y, eps))
-               {
-                  vec[m] = y;
-                  nonz[n++] = m;
-               }
-            }
-            else
-            {
-               y -= x * (*val++);
-               vec[m] = (y != 0) ? y : SOPLEX_FACTOR_MARKER;
-            }
-         }
+      for (j = lbeg[i + 1]; j > k; --j) {
+        int m = *idx++;
+        assert(m >= 0 && m < thedim);
+        y = vec[m];
+
+        if (y == 0) {
+          y = -x * (*val++);
+
+          if (isNotZero(y, eps)) {
+            vec[m] = y;
+            nonz[n++] = m;
+          }
+        } else {
+          y -= x * (*val++);
+          vec[m] = (y != 0) ? y : SOPLEX_FACTOR_MARKER;
+        }
       }
-   }
+    }
+  }
 
-   return n;
+  return n;
 }
 
+template <class R> void CLUFactor<R>::solveLleftForestNoNZ(R *vec) {
+  int i, j, k, end;
+  R x;
+  R *val, *lval;
+  int *idx, *lidx, *lrow, *lbeg;
 
-template <class R>
-void CLUFactor<R>::solveLleftForestNoNZ(R* vec)
-{
-   int i, j, k, end;
-   R x;
-   R* val, *lval;
-   int* idx, *lidx, *lrow, *lbeg;
-
-   lval = l.val.data();
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-   end = l.firstUpdate;
-
-   for(i = l.firstUnused - 1; i >= end; --i)
-   {
-      if((x = vec[lrow[i]]) != 0.0)
-      {
-         assert(i >= 0 && i < l.size);
-         k = lbeg[i];
-         assert(k >= 0 && k < l.size);
-         val = &lval[k];
-         idx = &lidx[k];
-
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            assert(*idx >= 0 && *idx < thedim);
-            vec[*idx++] -= x * (*val++);
-         }
+  lval = l.val.data();
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
+  end = l.firstUpdate;
+
+  for (i = l.firstUnused - 1; i >= end; --i) {
+    if ((x = vec[lrow[i]]) != 0.0) {
+      assert(i >= 0 && i < l.size);
+      k = lbeg[i];
+      assert(k >= 0 && k < l.size);
+      val = &lval[k];
+      idx = &lidx[k];
+
+      for (j = lbeg[i + 1]; j > k; --j) {
+        assert(*idx >= 0 && *idx < thedim);
+        vec[*idx++] -= x * (*val++);
       }
-   }
+    }
+  }
 }
 
-
 template <class R>
-int CLUFactor<R>::solveLleft(R eps, R* vec, int* nonz, int rn)
-{
-   int i, j, k, n;
-   int r;
-   R x, y;
-   R* rval, *val;
-   int* ridx, *idx;
-   int* rbeg;
-   int* rorig, *rperm;
-   int* last;
-
-   ridx  = l.ridx;
-   rval  = l.rval.data();
-   rbeg  = l.rbeg;
-   rorig = l.rorig;
-   rperm = l.rperm;
-   n     = 0;
-
-   i = l.firstUpdate - 1;
+int CLUFactor<R>::solveLleft(R eps, R *vec, int *nonz, int rn) {
+  int i, j, k, n;
+  int r;
+  R x, y;
+  R *rval, *val;
+  int *ridx, *idx;
+  int *rbeg;
+  int *rorig, *rperm;
+  int *last;
+
+  ridx = l.ridx;
+  rval = l.rval.data();
+  rbeg = l.rbeg;
+  rorig = l.rorig;
+  rperm = l.rperm;
+  n = 0;
+
+  i = l.firstUpdate - 1;
 #ifndef WITH_L_ROWS
 #pragma warn "Not yet implemented, define WITH_L_ROWS"
-   R*   lval = l.val.data();
-   int*    lidx = l.idx;
-   int*    lrow = l.row;
-   int*    lbeg = l.start;
-
-   for(; i >= 0; --i)
-   {
-      k   = lbeg[i];
-      val = &lval[k];
-      idx = &lidx[k];
-      x   = 0;
+  R *lval = l.val.data();
+  int *lidx = l.idx;
+  int *lrow = l.row;
+  int *lbeg = l.start;
 
-      for(j = lbeg[i + 1]; j > k; --j)
-         x += vec[*idx++] * (*val++);
+  for (; i >= 0; --i) {
+    k = lbeg[i];
+    val = &lval[k];
+    idx = &lidx[k];
+    x = 0;
 
-      vec[lrow[i]] -= x;
-   }
-
-#else
+    for (j = lbeg[i + 1]; j > k; --j)
+      x += vec[*idx++] * (*val++);
 
-   /*  move rhsidx to a heap
-    */
-   for(i = 0; i < rn;)
-      enQueueMax(nonz, &i, rperm[nonz[i]]);
+    vec[lrow[i]] -= x;
+  }
 
-   last = nonz + thedim;
-
-   while(rn > 0)
-   {
-      i = deQueueMax(nonz, &rn);
-      r = rorig[i];
-      x = vec[r];
+#else
 
-      if(isNotZero(x, eps))
-      {
-         *(--last) = r;
-         n++;
-         k = rbeg[r];
-         j = rbeg[r + 1] - k;
-         val = &rval[k];
-         idx = &ridx[k];
-
-         while(j-- > 0)
-         {
-            assert(l.rperm[*idx] < i);
-            int m = *idx++;
-            y = vec[m];
-
-            if(y == 0)
-            {
-               y = -x * *val++;
-
-               if(isNotZero(y, eps))
-               {
-                  vec[m] = y;
-                  enQueueMax(nonz, &rn, rperm[m]);
-               }
-            }
-            else
-            {
-               y -= x * *val++;
-               vec[m] = (y != 0) ? y : SOPLEX_FACTOR_MARKER;
-            }
-         }
+  /*  move rhsidx to a heap
+   */
+  for (i = 0; i < rn;)
+    enQueueMax(nonz, &i, rperm[nonz[i]]);
+
+  last = nonz + thedim;
+
+  while (rn > 0) {
+    i = deQueueMax(nonz, &rn);
+    r = rorig[i];
+    x = vec[r];
+
+    if (isNotZero(x, eps)) {
+      *(--last) = r;
+      n++;
+      k = rbeg[r];
+      j = rbeg[r + 1] - k;
+      val = &rval[k];
+      idx = &ridx[k];
+
+      while (j-- > 0) {
+        assert(l.rperm[*idx] < i);
+        int m = *idx++;
+        y = vec[m];
+
+        if (y == 0) {
+          y = -x * *val++;
+
+          if (isNotZero(y, eps)) {
+            vec[m] = y;
+            enQueueMax(nonz, &rn, rperm[m]);
+          }
+        } else {
+          y -= x * *val++;
+          vec[m] = (y != 0) ? y : SOPLEX_FACTOR_MARKER;
+        }
       }
-      else
-         vec[r] = 0;
-   }
+    } else
+      vec[r] = 0;
+  }
 
-   for(i = 0; i < n; ++i)
-      *nonz++ = *last++;
+  for (i = 0; i < n; ++i)
+    *nonz++ = *last++;
 
 #endif
 
-   return n;
+  return n;
 }
 
+template <class R> void CLUFactor<R>::solveLleftNoNZ(R *vec) {
+  int i, j, k;
+  int r;
+  R x;
+  R *rval, *val;
+  int *ridx, *idx;
+  int *rbeg;
+  int *rorig;
 
-template <class R>
-void CLUFactor<R>::solveLleftNoNZ(R* vec)
-{
-   int i, j, k;
-   int r;
-   R x;
-   R* rval, *val;
-   int* ridx, *idx;
-   int* rbeg;
-   int* rorig;
-
-   ridx = l.ridx;
-   rval = l.rval.data();
-   rbeg = l.rbeg;
-   rorig = l.rorig;
+  ridx = l.ridx;
+  rval = l.rval.data();
+  rbeg = l.rbeg;
+  rorig = l.rorig;
 
 #ifndef WITH_L_ROWS
-   R* lval = l.val.data();
-   int*    lidx = l.idx;
-   int*    lrow = l.row;
-   int*    lbeg = l.start;
-
-   i = l.firstUpdate - 1;
-   assert(i < thedim);
-
-   for(; i >= 0; --i)
-   {
-      k = lbeg[i];
-      assert(k >= 0 && k < l.size);
-      val = &lval[k];
-      idx = &lidx[k];
-      x = 0;
-
-      for(j = lbeg[i + 1]; j > k; --j)
-      {
-         assert(*idx >= 0 && *idx < thedim);
-         x += vec[*idx++] * (*val++);
-      }
+  R *lval = l.val.data();
+  int *lidx = l.idx;
+  int *lrow = l.row;
+  int *lbeg = l.start;
+
+  i = l.firstUpdate - 1;
+  assert(i < thedim);
+
+  for (; i >= 0; --i) {
+    k = lbeg[i];
+    assert(k >= 0 && k < l.size);
+    val = &lval[k];
+    idx = &lidx[k];
+    x = 0;
+
+    for (j = lbeg[i + 1]; j > k; --j) {
+      assert(*idx >= 0 && *idx < thedim);
+      x += vec[*idx++] * (*val++);
+    }
 
-      vec[lrow[i]] -= x;
-   }
+    vec[lrow[i]] -= x;
+  }
 
 #else
 
-   for(i = thedim; i--;)
-   {
-      r = rorig[i];
-      x = vec[r];
+  for (i = thedim; i--;) {
+    r = rorig[i];
+    x = vec[r];
 
-      if(x != 0.0)
-      {
-         k = rbeg[r];
-         j = rbeg[r + 1] - k;
-         val = &rval[k];
-         idx = &ridx[k];
-
-         while(j-- > 0)
-         {
-            assert(l.rperm[*idx] < i);
-            vec[*idx++] -= x * *val++;
-         }
+    if (x != 0.0) {
+      k = rbeg[r];
+      j = rbeg[r + 1] - k;
+      val = &rval[k];
+      idx = &ridx[k];
+
+      while (j-- > 0) {
+        assert(l.rperm[*idx] < i);
+        vec[*idx++] -= x * *val++;
       }
-   }
+    }
+  }
 
 #endif
 }
 
 template <class R>
-void inline CLUFactor<R>::updateSolutionVectorLright(R change, int j, R& vec, int* idx, int& nnz)
-{
-   // create a new entry in #ridx
-   if(vec == 0.0)
-   {
-      assert(nnz < thedim);
-      idx[nnz] = j;
-      ++nnz;
-   }
-
-   vec -= change;
-
-   // mark the entry where exact eliminiation occurred
-   if(vec == 0.0)
-      vec = SOPLEX_FACTOR_MARKER;
+void inline CLUFactor<R>::updateSolutionVectorLright(R change, int j, R &vec,
+                                                     int *idx, int &nnz) {
+  // create a new entry in #ridx
+  if (vec == 0.0) {
+    assert(nnz < thedim);
+    idx[nnz] = j;
+    ++nnz;
+  }
+
+  vec -= change;
+
+  // mark the entry where exact eliminiation occurred
+  if (vec == 0.0)
+    vec = SOPLEX_FACTOR_MARKER;
 }
 
-// solve Lz = b, inplace, using and preserving sparisity structure in the rhs and solution VectorBase<R>
-// arrays #vec and #ridx must be large enough to hold #thedim entries!
+// solve Lz = b, inplace, using and preserving sparisity structure in the rhs
+// and solution VectorBase<R> arrays #vec and #ridx must be large enough to hold
+// #thedim entries!
 template <class R>
-void CLUFactor<R>::vSolveLright(R* vec, int* ridx, int& rn, R eps)
-{
-   int i, j, k, n;
-   int end;
-   R x;
-   R* lval, *val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
-
-   lval = l.val.data();
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-
-   end = l.firstUpdate;
-
-   // loop through columns of L
-   for(i = 0; i < end; ++i)
-   {
-      x = vec[lrow[i]];
-
-      // check whether there is a corresponding value in the rhs VectorBase<R>; skipping/ignoring FACTOR_MARKER
-      if(isNotZero(x, eps))
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-
-         // apply \f$- x * L_{k,i}\f$ to all corresponding values in rhs/solution VectorBase<R>
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            assert(*idx >= 0 && *idx < thedim);
-            n = *idx++;
-            updateSolutionVectorLright(x * (*val), n, vec[n], ridx, rn);
-            ++val;
-         }
+void CLUFactor<R>::vSolveLright(R *vec, int *ridx, int &rn, R eps) {
+  int i, j, k, n;
+  int end;
+  R x;
+  R *lval, *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
+
+  lval = l.val.data();
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
+
+  end = l.firstUpdate;
+
+  // loop through columns of L
+  for (i = 0; i < end; ++i) {
+    x = vec[lrow[i]];
+
+    // check whether there is a corresponding value in the rhs VectorBase<R>;
+    // skipping/ignoring FACTOR_MARKER
+    if (isNotZero(x, eps)) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
+
+      // apply \f$- x * L_{k,i}\f$ to all corresponding values in rhs/solution
+      // VectorBase<R>
+      for (j = lbeg[i + 1]; j > k; --j) {
+        assert(*idx >= 0 && *idx < thedim);
+        n = *idx++;
+        updateSolutionVectorLright(x * (*val), n, vec[n], ridx, rn);
+        ++val;
       }
-   }
+    }
+  }
 
-   if(l.updateType)                     /* Forest-Tomlin Updates */
-   {
-      end = l.firstUnused;
+  if (l.updateType) /* Forest-Tomlin Updates */
+  {
+    end = l.firstUnused;
 
-      for(; i < end; ++i)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+    for (; i < end; ++i) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-         StableSum<R> tmp;
+      StableSum<R> tmp;
 
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            assert(*idx >= 0 && *idx < thedim);
-            tmp += vec[*idx++] * (*val++);
-         }
+      for (j = lbeg[i + 1]; j > k; --j) {
+        assert(*idx >= 0 && *idx < thedim);
+        tmp += vec[*idx++] * (*val++);
+      }
 
-         j = lrow[i];
-         x = R(tmp);
+      j = lrow[i];
+      x = R(tmp);
 
-         if(isNotZero(x, eps))
-            updateSolutionVectorLright(x, j, vec[j], ridx, rn);
-      }
-   }
+      if (isNotZero(x, eps))
+        updateSolutionVectorLright(x, j, vec[j], ridx, rn);
+    }
+  }
 }
 
 // solve with L for two right hand sides
 // see above methods for documentation
 template <class R>
-void CLUFactor<R>::vSolveLright2(
-   R* vec, int* ridx, int& rn, R eps,
-   R* vec2, int* ridx2, int& rn2, R eps2)
-{
-   int i, j, k, n;
-   int end;
-   R x, x2;
-   R* lval, *val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
-
-   lval = l.val.data();
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-
-   end = l.firstUpdate;
-
-   // loop through columns of L
-   for(i = 0; i < end; ++i)
-   {
-      j = lrow[i];
-      x2 = vec2[j];
-      x = vec[j];
-
-      // check whether there is a corresponding value in the first rhs VectorBase<R>; skipping/ignoring FACTOR_MARKER
-      if(isNotZero(x, eps))
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-
-         // check whether there is  also a corresponding value in the second rhs VectorBase<R>; skipping/ignoring FACTOR_MARKER
-         if(isNotZero(x2, eps2))
-         {
-            for(j = lbeg[i + 1]; j > k; --j)
-            {
-               assert(*idx >= 0 && *idx < thedim);
-               n = *idx++;
-               updateSolutionVectorLright(x * (*val), n, vec[n], ridx, rn);
-               updateSolutionVectorLright(x2 * (*val), n, vec2[n], ridx2, rn2);
-               ++val;
-            }
-         }
-         // only the first VectorBase<R> needs to be modified
-         else
-         {
-            for(j = lbeg[i + 1]; j > k; --j)
-            {
-               assert(*idx >= 0 && *idx < thedim);
-               n = *idx++;
-               updateSolutionVectorLright(x * (*val), n, vec[n], ridx, rn);
-               ++val;
-            }
-         }
+void CLUFactor<R>::vSolveLright2(R *vec, int *ridx, int &rn, R eps, R *vec2,
+                                 int *ridx2, int &rn2, R eps2) {
+  int i, j, k, n;
+  int end;
+  R x, x2;
+  R *lval, *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
+
+  lval = l.val.data();
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
+
+  end = l.firstUpdate;
+
+  // loop through columns of L
+  for (i = 0; i < end; ++i) {
+    j = lrow[i];
+    x2 = vec2[j];
+    x = vec[j];
+
+    // check whether there is a corresponding value in the first rhs
+    // VectorBase<R>; skipping/ignoring FACTOR_MARKER
+    if (isNotZero(x, eps)) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
+
+      // check whether there is  also a corresponding value in the second rhs
+      // VectorBase<R>; skipping/ignoring FACTOR_MARKER
+      if (isNotZero(x2, eps2)) {
+        for (j = lbeg[i + 1]; j > k; --j) {
+          assert(*idx >= 0 && *idx < thedim);
+          n = *idx++;
+          updateSolutionVectorLright(x * (*val), n, vec[n], ridx, rn);
+          updateSolutionVectorLright(x2 * (*val), n, vec2[n], ridx2, rn2);
+          ++val;
+        }
       }
-      // only the second VectorBase<R> needs to be modified
-      else if(isNotZero(x2, eps2))
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            assert(*idx >= 0 && *idx < thedim);
-            n = *idx++;
-            updateSolutionVectorLright(x2 * (*val), n, vec2[n], ridx2, rn2);
-            ++val;
-         }
+      // only the first VectorBase<R> needs to be modified
+      else {
+        for (j = lbeg[i + 1]; j > k; --j) {
+          assert(*idx >= 0 && *idx < thedim);
+          n = *idx++;
+          updateSolutionVectorLright(x * (*val), n, vec[n], ridx, rn);
+          ++val;
+        }
       }
-   }
+    }
+    // only the second VectorBase<R> needs to be modified
+    else if (isNotZero(x2, eps2)) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
+
+      for (j = lbeg[i + 1]; j > k; --j) {
+        assert(*idx >= 0 && *idx < thedim);
+        n = *idx++;
+        updateSolutionVectorLright(x2 * (*val), n, vec2[n], ridx2, rn2);
+        ++val;
+      }
+    }
+  }
 
-   if(l.updateType)                     /* Forest-Tomlin Updates */
-   {
-      end = l.firstUnused;
+  if (l.updateType) /* Forest-Tomlin Updates */
+  {
+    end = l.firstUnused;
 
-      for(; i < end; ++i)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+    for (; i < end; ++i) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-         StableSum<R> tmp1, tmp2;
+      StableSum<R> tmp1, tmp2;
 
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            assert(*idx >= 0 && *idx < thedim);
-            tmp1 += vec[*idx] * (*val);
-            tmp2 += vec2[*idx++] * (*val++);
-         }
+      for (j = lbeg[i + 1]; j > k; --j) {
+        assert(*idx >= 0 && *idx < thedim);
+        tmp1 += vec[*idx] * (*val);
+        tmp2 += vec2[*idx++] * (*val++);
+      }
 
-         x = R(tmp1);
-         x2 = R(tmp2);
+      x = R(tmp1);
+      x2 = R(tmp2);
 
-         j = lrow[i];
+      j = lrow[i];
 
-         if(isNotZero(x, eps))
-            updateSolutionVectorLright(x, j, vec[j], ridx, rn);
+      if (isNotZero(x, eps))
+        updateSolutionVectorLright(x, j, vec[j], ridx, rn);
 
-         if(isNotZero(x2, eps2))
-            updateSolutionVectorLright(x2, j, vec2[j], ridx2, rn2);
-      }
-   }
+      if (isNotZero(x2, eps2))
+        updateSolutionVectorLright(x2, j, vec2[j], ridx2, rn2);
+    }
+  }
 }
 
 // solve with L for three right hand sides
 // see above methods for documentation
 template <class R>
-void CLUFactor<R>::vSolveLright3(
-   R* vec, int* ridx, int& rn, R eps,
-   R* vec2, int* ridx2, int& rn2, R eps2,
-   R* vec3, int* ridx3, int& rn3, R eps3)
-{
-   int i, j, k, n;
-   int end;
-   R x, x2, x3;
-   R* lval, *val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
-
-   lval = l.val.data();
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-
-   end = l.firstUpdate;
-
-   for(i = 0; i < end; ++i)
-   {
-      j = lrow[i];
-      x = vec[j];
-      x2 = vec2[j];
-      x3 = vec3[j];
-
-      if(isNotZero(x, eps))
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-
-         if(isNotZero(x2, eps2))
-         {
-            if(isNotZero(x3, eps3))
-            {
-               // case 1: all three vectors are nonzero at j
-               for(j = lbeg[i + 1]; j > k; --j)
-               {
-                  assert(*idx >= 0 && *idx < thedim);
-                  n = *idx++;
-                  updateSolutionVectorLright(x * (*val), n, vec[n], ridx, rn);
-                  updateSolutionVectorLright(x2 * (*val), n, vec2[n], ridx2, rn2);
-                  updateSolutionVectorLright(x3 * (*val), n, vec3[n], ridx3, rn3);
-                  ++val;
-               }
-            }
-            else
-            {
-               // case 2: 1 and 2 are nonzero at j
-               for(j = lbeg[i + 1]; j > k; --j)
-               {
-                  assert(*idx >= 0 && *idx < thedim);
-                  n = *idx++;
-                  updateSolutionVectorLright(x * (*val), n, vec[n], ridx, rn);
-                  updateSolutionVectorLright(x2 * (*val), n, vec2[n], ridx2, rn2);
-                  ++val;
-               }
-            }
-         }
-         else if(isNotZero(x3, eps3))
-         {
-            // case 3: 1 and 3 are nonzero at j
-            for(j = lbeg[i + 1]; j > k; --j)
-            {
-               assert(*idx >= 0 && *idx < thedim);
-               n = *idx++;
-               updateSolutionVectorLright(x * (*val), n, vec[n], ridx, rn);
-               updateSolutionVectorLright(x3 * (*val), n, vec3[n], ridx3, rn3);
-               ++val;
-            }
-         }
-         else
-         {
-            // case 4: only 1 is nonzero at j
-            for(j = lbeg[i + 1]; j > k; --j)
-            {
-               assert(*idx >= 0 && *idx < thedim);
-               n = *idx++;
-               updateSolutionVectorLright(x * (*val), n, vec[n], ridx, rn);
-               ++val;
-            }
-         }
-      }
-      else if(isNotZero(x2, eps2))
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-
-         if(isNotZero(x3, eps3))
-         {
-            // case 5: 2 and 3 are nonzero at j
-            for(j = lbeg[i + 1]; j > k; --j)
-            {
-               assert(*idx >= 0 && *idx < thedim);
-               n = *idx++;
-               updateSolutionVectorLright(x2 * (*val), n, vec2[n], ridx2, rn2);
-               updateSolutionVectorLright(x3 * (*val), n, vec3[n], ridx3, rn3);
-               ++val;
-            }
-         }
-         else
-         {
-            // case 6: only 2 is nonzero at j
-            for(j = lbeg[i + 1]; j > k; --j)
-            {
-               assert(*idx >= 0 && *idx < thedim);
-               n = *idx++;
-               updateSolutionVectorLright(x2 * (*val), n, vec2[n], ridx2, rn2);
-               ++val;
-            }
-         }
-      }
-      else if(isNotZero(x3, eps3))
-      {
-         // case 7: only 3 is nonzero at j
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+void CLUFactor<R>::vSolveLright3(R *vec, int *ridx, int &rn, R eps, R *vec2,
+                                 int *ridx2, int &rn2, R eps2, R *vec3,
+                                 int *ridx3, int &rn3, R eps3) {
+  int i, j, k, n;
+  int end;
+  R x, x2, x3;
+  R *lval, *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
+
+  lval = l.val.data();
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
+
+  end = l.firstUpdate;
+
+  for (i = 0; i < end; ++i) {
+    j = lrow[i];
+    x = vec[j];
+    x2 = vec2[j];
+    x3 = vec3[j];
+
+    if (isNotZero(x, eps)) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
+      if (isNotZero(x2, eps2)) {
+        if (isNotZero(x3, eps3)) {
+          // case 1: all three vectors are nonzero at j
+          for (j = lbeg[i + 1]; j > k; --j) {
             assert(*idx >= 0 && *idx < thedim);
             n = *idx++;
+            updateSolutionVectorLright(x * (*val), n, vec[n], ridx, rn);
+            updateSolutionVectorLright(x2 * (*val), n, vec2[n], ridx2, rn2);
             updateSolutionVectorLright(x3 * (*val), n, vec3[n], ridx3, rn3);
             ++val;
-         }
+          }
+        } else {
+          // case 2: 1 and 2 are nonzero at j
+          for (j = lbeg[i + 1]; j > k; --j) {
+            assert(*idx >= 0 && *idx < thedim);
+            n = *idx++;
+            updateSolutionVectorLright(x * (*val), n, vec[n], ridx, rn);
+            updateSolutionVectorLright(x2 * (*val), n, vec2[n], ridx2, rn2);
+            ++val;
+          }
+        }
+      } else if (isNotZero(x3, eps3)) {
+        // case 3: 1 and 3 are nonzero at j
+        for (j = lbeg[i + 1]; j > k; --j) {
+          assert(*idx >= 0 && *idx < thedim);
+          n = *idx++;
+          updateSolutionVectorLright(x * (*val), n, vec[n], ridx, rn);
+          updateSolutionVectorLright(x3 * (*val), n, vec3[n], ridx3, rn3);
+          ++val;
+        }
+      } else {
+        // case 4: only 1 is nonzero at j
+        for (j = lbeg[i + 1]; j > k; --j) {
+          assert(*idx >= 0 && *idx < thedim);
+          n = *idx++;
+          updateSolutionVectorLright(x * (*val), n, vec[n], ridx, rn);
+          ++val;
+        }
       }
-   }
+    } else if (isNotZero(x2, eps2)) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
+
+      if (isNotZero(x3, eps3)) {
+        // case 5: 2 and 3 are nonzero at j
+        for (j = lbeg[i + 1]; j > k; --j) {
+          assert(*idx >= 0 && *idx < thedim);
+          n = *idx++;
+          updateSolutionVectorLright(x2 * (*val), n, vec2[n], ridx2, rn2);
+          updateSolutionVectorLright(x3 * (*val), n, vec3[n], ridx3, rn3);
+          ++val;
+        }
+      } else {
+        // case 6: only 2 is nonzero at j
+        for (j = lbeg[i + 1]; j > k; --j) {
+          assert(*idx >= 0 && *idx < thedim);
+          n = *idx++;
+          updateSolutionVectorLright(x2 * (*val), n, vec2[n], ridx2, rn2);
+          ++val;
+        }
+      }
+    } else if (isNotZero(x3, eps3)) {
+      // case 7: only 3 is nonzero at j
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
+
+      for (j = lbeg[i + 1]; j > k; --j) {
+        assert(*idx >= 0 && *idx < thedim);
+        n = *idx++;
+        updateSolutionVectorLright(x3 * (*val), n, vec3[n], ridx3, rn3);
+        ++val;
+      }
+    }
+  }
 
-   if(l.updateType)                      /* Forest-Tomlin Updates */
-   {
-      end = l.firstUnused;
+  if (l.updateType) /* Forest-Tomlin Updates */
+  {
+    end = l.firstUnused;
 
-      for(; i < end; ++i)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+    for (; i < end; ++i) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-         StableSum<R> tmp1, tmp2, tmp3;
+      StableSum<R> tmp1, tmp2, tmp3;
 
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            assert(*idx >= 0 && *idx < thedim);
-            tmp1 += vec[*idx] * (*val);
-            tmp2 += vec2[*idx] * (*val);
-            tmp3 += vec3[*idx++] * (*val++);
-         }
+      for (j = lbeg[i + 1]; j > k; --j) {
+        assert(*idx >= 0 && *idx < thedim);
+        tmp1 += vec[*idx] * (*val);
+        tmp2 += vec2[*idx] * (*val);
+        tmp3 += vec3[*idx++] * (*val++);
+      }
 
-         x = R(tmp1);
-         x2 = R(tmp2);
-         x3 = R(tmp3);
+      x = R(tmp1);
+      x2 = R(tmp2);
+      x3 = R(tmp3);
 
-         j = lrow[i];
+      j = lrow[i];
 
-         if(isNotZero(x, eps))
-            updateSolutionVectorLright(x, j, vec[j], ridx, rn);
+      if (isNotZero(x, eps))
+        updateSolutionVectorLright(x, j, vec[j], ridx, rn);
 
-         if(isNotZero(x2, eps2))
-            updateSolutionVectorLright(x2, j, vec2[j], ridx2, rn2);
+      if (isNotZero(x2, eps2))
+        updateSolutionVectorLright(x2, j, vec2[j], ridx2, rn2);
 
-         if(isNotZero(x3, eps3))
-            updateSolutionVectorLright(x3, j, vec3[j], ridx3, rn3);
-      }
-   }
+      if (isNotZero(x3, eps3))
+        updateSolutionVectorLright(x3, j, vec3[j], ridx3, rn3);
+    }
+  }
 }
 
 template <class R>
-int CLUFactor<R>::vSolveUright(R* vec, int* vidx,
-                               R* rhs, int* ridx, int rn, R eps)
-{
-   int i, j, k, r, c, n;
-   int* rorig, *corig;
-   int* rperm;
-   int* cidx, *clen, *cbeg;
-   R* cval;
-   R x, y;
-
-   int* idx;
-   R* val;
-
-   rorig = row.orig;
-   corig = col.orig;
-   rperm = row.perm;
-
-   cidx = u.col.idx;
-   cval = u.col.val.data();
-   clen = u.col.len;
-   cbeg = u.col.start;
-
-   n = 0;
-
-   while(rn > 0)
-   {
-      /*      Find nonzero with highest permuted row index and setup i and r
-       */
-      i = deQueueMax(ridx, &rn);
-      assert(i >= 0 && i < thedim);
-      r = rorig[i];
-      assert(r >= 0 && r < thedim);
-
-      x = diag[r] * rhs[r];
-      rhs[r] = 0;
+int CLUFactor<R>::vSolveUright(R *vec, int *vidx, R *rhs, int *ridx, int rn,
+                               R eps) {
+  int i, j, k, r, c, n;
+  int *rorig, *corig;
+  int *rperm;
+  int *cidx, *clen, *cbeg;
+  R *cval;
+  R x, y;
+
+  int *idx;
+  R *val;
+
+  rorig = row.orig;
+  corig = col.orig;
+  rperm = row.perm;
+
+  cidx = u.col.idx;
+  cval = u.col.val.data();
+  clen = u.col.len;
+  cbeg = u.col.start;
+
+  n = 0;
+
+  while (rn > 0) {
+    /*      Find nonzero with highest permuted row index and setup i and r
+     */
+    i = deQueueMax(ridx, &rn);
+    assert(i >= 0 && i < thedim);
+    r = rorig[i];
+    assert(r >= 0 && r < thedim);
+
+    x = diag[r] * rhs[r];
+    rhs[r] = 0;
+
+    if (isNotZero(x, eps)) {
+      c = corig[i];
+      assert(c >= 0 && c < thedim);
+      vidx[n++] = c;
+      vec[c] = x;
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0) {
+        assert(*idx >= 0 && *idx < thedim);
+        k = *idx++;
+        assert(k >= 0 && k < thedim);
+        y = rhs[k];
+
+        if (y == 0) {
+          y = -x * (*val++);
+
+          if (isNotZero(y, eps)) {
+            rhs[k] = y;
+            enQueueMax(ridx, &rn, rperm[k]);
+          }
+        } else {
+          y -= x * (*val++);
+          y += (y == 0) ? SOPLEX_FACTOR_MARKER : 0;
+          rhs[k] = y;
+        }
+      }
 
-      if(isNotZero(x, eps))
-      {
-         c = corig[i];
-         assert(c >= 0 && c < thedim);
-         vidx[n++] = c;
-         vec[c] = x;
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
-
-         while(j-- > 0)
-         {
-            assert(*idx >= 0 && *idx < thedim);
-            k = *idx++;
-            assert(k >= 0 && k < thedim);
-            y = rhs[k];
-
-            if(y == 0)
-            {
-               y = -x * (*val++);
-
-               if(isNotZero(y, eps))
-               {
-                  rhs[k] = y;
-                  enQueueMax(ridx, &rn, rperm[k]);
-               }
-            }
-            else
-            {
-               y -= x * (*val++);
-               y += (y == 0) ? SOPLEX_FACTOR_MARKER : 0;
-               rhs[k] = y;
-            }
-         }
-
-         if(rn > i * verySparseFactor4right)
-         {
-            /* continue with dense case */
-            for(i = *ridx; i >= 0; --i)
-            {
-               r = rorig[i];
-               assert(r >= 0 && r < thedim);
-               x = diag[r] * rhs[r];
-               rhs[r] = 0;
-
-               if(isNotZero(x, eps))
-               {
-                  c = corig[i];
-                  assert(c >= 0 && c < thedim);
-                  vidx[n++] = c;
-                  vec[c] = x;
-                  val = &cval[cbeg[c]];
-                  idx = &cidx[cbeg[c]];
-                  j = clen[c];
-
-                  while(j-- > 0)
-                  {
-                     assert(*idx >= 0 && *idx < thedim);
-                     rhs[*idx++] -= x * (*val++);
-                  }
-               }
+      if (rn > i * verySparseFactor4right) {
+        /* continue with dense case */
+        for (i = *ridx; i >= 0; --i) {
+          r = rorig[i];
+          assert(r >= 0 && r < thedim);
+          x = diag[r] * rhs[r];
+          rhs[r] = 0;
+
+          if (isNotZero(x, eps)) {
+            c = corig[i];
+            assert(c >= 0 && c < thedim);
+            vidx[n++] = c;
+            vec[c] = x;
+            val = &cval[cbeg[c]];
+            idx = &cidx[cbeg[c]];
+            j = clen[c];
+
+            while (j-- > 0) {
+              assert(*idx >= 0 && *idx < thedim);
+              rhs[*idx++] -= x * (*val++);
             }
+          }
+        }
 
-            break;
-         }
+        break;
       }
-   }
+    }
+  }
 
-   return n;
+  return n;
 }
 
 template <class R>
-void CLUFactor<R>::vSolveUrightNoNZ(R* vec,
-                                    R* rhs, int* ridx, int rn, R eps)
-{
-   int i, j, k, r, c;
-   int* rorig, *corig;
-   int* rperm;
-   int* cidx, *clen, *cbeg;
-   R* cval;
-   R x, y;
-
-   int* idx;
-   R* val;
-
-   rorig = row.orig;
-   corig = col.orig;
-   rperm = row.perm;
-
-   cidx = u.col.idx;
-   cval = u.col.val.data();
-   clen = u.col.len;
-   cbeg = u.col.start;
-
-   while(rn > 0)
-   {
-      if(rn > *ridx * verySparseFactor4right)
-      {
-         /* continue with dense case */
-         for(i = *ridx; i >= 0; --i)
-         {
-            assert(i >= 0 && i < thedim);
-            r = rorig[i];
-            assert(r >= 0 && r < thedim);
-            x = diag[r] * rhs[r];
-            rhs[r] = 0;
-
-            if(isNotZero(x, eps))
-            {
-               c = corig[i];
-               vec[c] = x;
-               val = &cval[cbeg[c]];
-               idx = &cidx[cbeg[c]];
-               j = clen[c];
-
-               while(j-- > 0)
-               {
-                  assert(*idx >= 0 && *idx < thedim);
-                  rhs[*idx++] -= x * (*val++);
-               }
-            }
-         }
-
-         break;
+void CLUFactor<R>::vSolveUrightNoNZ(R *vec, R *rhs, int *ridx, int rn, R eps) {
+  int i, j, k, r, c;
+  int *rorig, *corig;
+  int *rperm;
+  int *cidx, *clen, *cbeg;
+  R *cval;
+  R x, y;
+
+  int *idx;
+  R *val;
+
+  rorig = row.orig;
+  corig = col.orig;
+  rperm = row.perm;
+
+  cidx = u.col.idx;
+  cval = u.col.val.data();
+  clen = u.col.len;
+  cbeg = u.col.start;
+
+  while (rn > 0) {
+    if (rn > *ridx * verySparseFactor4right) {
+      /* continue with dense case */
+      for (i = *ridx; i >= 0; --i) {
+        assert(i >= 0 && i < thedim);
+        r = rorig[i];
+        assert(r >= 0 && r < thedim);
+        x = diag[r] * rhs[r];
+        rhs[r] = 0;
+
+        if (isNotZero(x, eps)) {
+          c = corig[i];
+          vec[c] = x;
+          val = &cval[cbeg[c]];
+          idx = &cidx[cbeg[c]];
+          j = clen[c];
+
+          while (j-- > 0) {
+            assert(*idx >= 0 && *idx < thedim);
+            rhs[*idx++] -= x * (*val++);
+          }
+        }
       }
 
-      /*      Find nonzero with highest permuted row index and setup i and r
-       */
-      i = deQueueMax(ridx, &rn);
+      break;
+    }
 
-      assert(i >= 0 && i < thedim);
+    /*      Find nonzero with highest permuted row index and setup i and r
+     */
+    i = deQueueMax(ridx, &rn);
 
-      r = rorig[i];
+    assert(i >= 0 && i < thedim);
 
-      assert(r >= 0 && r < thedim);
+    r = rorig[i];
 
-      x = diag[r] * rhs[r];
+    assert(r >= 0 && r < thedim);
 
-      rhs[r] = 0;
+    x = diag[r] * rhs[r];
 
-      if(isNotZero(x, eps))
-      {
-         c = corig[i];
-         vec[c] = x;
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
-
-         while(j-- > 0)
-         {
-            k = *idx++;
-            assert(k >= 0 && k < thedim);
-            y = rhs[k];
-
-            if(y == 0)
-            {
-               y = -x * (*val++);
-
-               if(isNotZero(y, eps))
-               {
-                  rhs[k] = y;
-                  enQueueMax(ridx, &rn, rperm[k]);
-               }
-            }
-            else
-            {
-               y -= x * (*val++);
-               y += (y == 0) ? SOPLEX_FACTOR_MARKER : 0;
-               rhs[k] = y;
-            }
-         }
+    rhs[r] = 0;
+
+    if (isNotZero(x, eps)) {
+      c = corig[i];
+      vec[c] = x;
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0) {
+        k = *idx++;
+        assert(k >= 0 && k < thedim);
+        y = rhs[k];
+
+        if (y == 0) {
+          y = -x * (*val++);
+
+          if (isNotZero(y, eps)) {
+            rhs[k] = y;
+            enQueueMax(ridx, &rn, rperm[k]);
+          }
+        } else {
+          y -= x * (*val++);
+          y += (y == 0) ? SOPLEX_FACTOR_MARKER : 0;
+          rhs[k] = y;
+        }
       }
-   }
+    }
+  }
 }
 
-
 template <class R>
-int CLUFactor<R>::vSolveUright2(
-   R* vec, int* vidx, R* rhs, int* ridx, int rn, R eps,
-   R* vec2, R* rhs2, int* ridx2, int rn2, R eps2)
-{
-   int i, j, k, r, c, n;
-   int* rorig, *corig;
-   int* rperm;
-   int* cidx, *clen, *cbeg;
-   R* cval;
-   R x, y;
-   R x2, y2;
-
-   int* idx;
-   R* val;
-
-   rorig = row.orig;
-   corig = col.orig;
-   rperm = row.perm;
-
-   cidx = u.col.idx;
-   cval = u.col.val.data();
-   clen = u.col.len;
-   cbeg = u.col.start;
-
-   n = 0;
-
-   while(rn + rn2 > 0)
-   {
-      /*      Find nonzero with highest permuted row index and setup i and r
-       */
-      if(rn <= 0)
-         i = deQueueMax(ridx2, &rn2);
-      else if(rn2 <= 0)
-         i = deQueueMax(ridx, &rn);
-      else if(*ridx2 > *ridx)
-         i = deQueueMax(ridx2, &rn2);
-      else if(*ridx2 < *ridx)
-         i = deQueueMax(ridx, &rn);
-      else
-      {
-         (void) deQueueMax(ridx, &rn);
-         i = deQueueMax(ridx2, &rn2);
-      }
+int CLUFactor<R>::vSolveUright2(R *vec, int *vidx, R *rhs, int *ridx, int rn,
+                                R eps, R *vec2, R *rhs2, int *ridx2, int rn2,
+                                R eps2) {
+  int i, j, k, r, c, n;
+  int *rorig, *corig;
+  int *rperm;
+  int *cidx, *clen, *cbeg;
+  R *cval;
+  R x, y;
+  R x2, y2;
+
+  int *idx;
+  R *val;
+
+  rorig = row.orig;
+  corig = col.orig;
+  rperm = row.perm;
+
+  cidx = u.col.idx;
+  cval = u.col.val.data();
+  clen = u.col.len;
+  cbeg = u.col.start;
+
+  n = 0;
+
+  while (rn + rn2 > 0) {
+    /*      Find nonzero with highest permuted row index and setup i and r
+     */
+    if (rn <= 0)
+      i = deQueueMax(ridx2, &rn2);
+    else if (rn2 <= 0)
+      i = deQueueMax(ridx, &rn);
+    else if (*ridx2 > *ridx)
+      i = deQueueMax(ridx2, &rn2);
+    else if (*ridx2 < *ridx)
+      i = deQueueMax(ridx, &rn);
+    else {
+      (void)deQueueMax(ridx, &rn);
+      i = deQueueMax(ridx2, &rn2);
+    }
 
-      assert(i >= 0 && i < thedim);
+    assert(i >= 0 && i < thedim);
 
-      r = rorig[i];
-      assert(r >= 0 && r < thedim);
+    r = rorig[i];
+    assert(r >= 0 && r < thedim);
 
-      x = diag[r] * rhs[r];
-      x2 = diag[r] * rhs2[r];
-      rhs[r] = 0;
-      rhs2[r] = 0;
+    x = diag[r] * rhs[r];
+    x2 = diag[r] * rhs2[r];
+    rhs[r] = 0;
+    rhs2[r] = 0;
 
-      if(isNotZero(x, eps))
-      {
-         c = corig[i];
-         vidx[n++] = c;
-         vec[c] = x;
-         vec2[c] = x2;
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
-
-         if(isNotZero(x2, eps2))
-         {
-            while(j-- > 0)
-            {
-               k = *idx++;
-               assert(k >= 0 && k < thedim);
-               y2 = rhs2[k];
-
-               if(y2 == 0)
-               {
-                  y2 = -x2 * (*val);
-
-                  if(isNotZero(y2, eps2))
-                  {
-                     rhs2[k] = y2;
-                     enQueueMax(ridx2, &rn2, rperm[k]);
-                  }
-               }
-               else
-               {
-                  y2 -= x2 * (*val);
-                  rhs2[k] = (y2 != 0) ? y2 : SOPLEX_FACTOR_MARKER;
-               }
-
-               y = rhs[k];
-
-               if(y == 0)
-               {
-                  y = -x * (*val++);
-
-                  if(isNotZero(y, eps))
-                  {
-                     rhs[k] = y;
-                     enQueueMax(ridx, &rn, rperm[k]);
-                  }
-               }
-               else
-               {
-                  y -= x * (*val++);
-                  y += (y == 0) ? SOPLEX_FACTOR_MARKER : 0;
-                  rhs[k] = y;
-               }
-            }
-         }
-         else
-         {
-            while(j-- > 0)
-            {
-               k = *idx++;
-               assert(k >= 0 && k < thedim);
-               y = rhs[k];
-
-               if(y == 0)
-               {
-                  y = -x * (*val++);
-
-                  if(isNotZero(y, eps))
-                  {
-                     rhs[k] = y;
-                     enQueueMax(ridx, &rn, rperm[k]);
-                  }
-               }
-               else
-               {
-                  y -= x * (*val++);
-                  y += (y == 0) ? SOPLEX_FACTOR_MARKER : 0;
-                  rhs[k] = y;
-               }
+    if (isNotZero(x, eps)) {
+      c = corig[i];
+      vidx[n++] = c;
+      vec[c] = x;
+      vec2[c] = x2;
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      if (isNotZero(x2, eps2)) {
+        while (j-- > 0) {
+          k = *idx++;
+          assert(k >= 0 && k < thedim);
+          y2 = rhs2[k];
+
+          if (y2 == 0) {
+            y2 = -x2 * (*val);
+
+            if (isNotZero(y2, eps2)) {
+              rhs2[k] = y2;
+              enQueueMax(ridx2, &rn2, rperm[k]);
             }
-         }
-      }
-      else if(isNotZero(x2, eps2))
-      {
-         c = corig[i];
-         assert(c >= 0 && c < thedim);
-         vec2[c] = x2;
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
-
-         while(j-- > 0)
-         {
-            k = *idx++;
-            assert(k >= 0 && k < thedim);
-            y2 = rhs2[k];
-
-            if(y2 == 0)
-            {
-               y2 = -x2 * (*val++);
-
-               if(isNotZero(y2, eps2))
-               {
-                  rhs2[k] = y2;
-                  enQueueMax(ridx2, &rn2, rperm[k]);
-               }
+          } else {
+            y2 -= x2 * (*val);
+            rhs2[k] = (y2 != 0) ? y2 : SOPLEX_FACTOR_MARKER;
+          }
+
+          y = rhs[k];
+
+          if (y == 0) {
+            y = -x * (*val++);
+
+            if (isNotZero(y, eps)) {
+              rhs[k] = y;
+              enQueueMax(ridx, &rn, rperm[k]);
             }
-            else
-            {
-               y2 -= x2 * (*val++);
-               rhs2[k] = (y2 != 0) ? y2 : SOPLEX_FACTOR_MARKER;
+          } else {
+            y -= x * (*val++);
+            y += (y == 0) ? SOPLEX_FACTOR_MARKER : 0;
+            rhs[k] = y;
+          }
+        }
+      } else {
+        while (j-- > 0) {
+          k = *idx++;
+          assert(k >= 0 && k < thedim);
+          y = rhs[k];
+
+          if (y == 0) {
+            y = -x * (*val++);
+
+            if (isNotZero(y, eps)) {
+              rhs[k] = y;
+              enQueueMax(ridx, &rn, rperm[k]);
             }
-         }
+          } else {
+            y -= x * (*val++);
+            y += (y == 0) ? SOPLEX_FACTOR_MARKER : 0;
+            rhs[k] = y;
+          }
+        }
+      }
+    } else if (isNotZero(x2, eps2)) {
+      c = corig[i];
+      assert(c >= 0 && c < thedim);
+      vec2[c] = x2;
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0) {
+        k = *idx++;
+        assert(k >= 0 && k < thedim);
+        y2 = rhs2[k];
+
+        if (y2 == 0) {
+          y2 = -x2 * (*val++);
+
+          if (isNotZero(y2, eps2)) {
+            rhs2[k] = y2;
+            enQueueMax(ridx2, &rn2, rperm[k]);
+          }
+        } else {
+          y2 -= x2 * (*val++);
+          rhs2[k] = (y2 != 0) ? y2 : SOPLEX_FACTOR_MARKER;
+        }
       }
+    }
 
-      if(rn + rn2 > i * verySparseFactor4right)
-      {
-         /* continue with dense case */
-         if(*ridx > *ridx2)
-            i = *ridx;
-         else
-            i = *ridx2;
-
-         for(; i >= 0; --i)
-         {
-            assert(i < thedim);
-            r = rorig[i];
-            assert(r >= 0 && r < thedim);
-            x = diag[r] * rhs[r];
-            x2 = diag[r] * rhs2[r];
-            rhs[r] = 0;
-            rhs2[r] = 0;
-
-            if(isNotZero(x2, eps2))
-            {
-               c = corig[i];
-               assert(c >= 0 && c < thedim);
-               vec2[c] = x2;
-               val = &cval[cbeg[c]];
-               idx = &cidx[cbeg[c]];
-               j = clen[c];
-
-               if(isNotZero(x, eps))
-               {
-                  vidx[n++] = c;
-                  vec[c] = x;
-
-                  while(j-- > 0)
-                  {
-                     assert(*idx >= 0 && *idx < thedim);
-                     rhs[*idx] -= x * (*val);
-                     rhs2[*idx++] -= x2 * (*val++);
-                  }
-               }
-               else
-               {
-                  while(j-- > 0)
-                  {
-                     assert(*idx >= 0 && *idx < thedim);
-                     rhs2[*idx++] -= x2 * (*val++);
-                  }
-               }
+    if (rn + rn2 > i * verySparseFactor4right) {
+      /* continue with dense case */
+      if (*ridx > *ridx2)
+        i = *ridx;
+      else
+        i = *ridx2;
+
+      for (; i >= 0; --i) {
+        assert(i < thedim);
+        r = rorig[i];
+        assert(r >= 0 && r < thedim);
+        x = diag[r] * rhs[r];
+        x2 = diag[r] * rhs2[r];
+        rhs[r] = 0;
+        rhs2[r] = 0;
+
+        if (isNotZero(x2, eps2)) {
+          c = corig[i];
+          assert(c >= 0 && c < thedim);
+          vec2[c] = x2;
+          val = &cval[cbeg[c]];
+          idx = &cidx[cbeg[c]];
+          j = clen[c];
+
+          if (isNotZero(x, eps)) {
+            vidx[n++] = c;
+            vec[c] = x;
+
+            while (j-- > 0) {
+              assert(*idx >= 0 && *idx < thedim);
+              rhs[*idx] -= x * (*val);
+              rhs2[*idx++] -= x2 * (*val++);
             }
-            else if(isNotZero(x, eps))
-            {
-               c = corig[i];
-               assert(c >= 0 && c < thedim);
-               vidx[n++] = c;
-               vec[c] = x;
-               val = &cval[cbeg[c]];
-               idx = &cidx[cbeg[c]];
-               j = clen[c];
-
-               while(j-- > 0)
-               {
-                  assert(*idx >= 0 && *idx < thedim);
-                  rhs[*idx++] -= x * (*val++);
-               }
+          } else {
+            while (j-- > 0) {
+              assert(*idx >= 0 && *idx < thedim);
+              rhs2[*idx++] -= x2 * (*val++);
             }
-         }
-
-         break;
+          }
+        } else if (isNotZero(x, eps)) {
+          c = corig[i];
+          assert(c >= 0 && c < thedim);
+          vidx[n++] = c;
+          vec[c] = x;
+          val = &cval[cbeg[c]];
+          idx = &cidx[cbeg[c]];
+          j = clen[c];
+
+          while (j-- > 0) {
+            assert(*idx >= 0 && *idx < thedim);
+            rhs[*idx++] -= x * (*val++);
+          }
+        }
       }
-   }
 
-   return n;
+      break;
+    }
+  }
+
+  return n;
 }
 
 template <class R>
-int CLUFactor<R>::vSolveUpdateRight(R* vec, int* ridx, int n, R eps)
-{
-   int i, j, k;
-   int end;
-   R x, y;
-   R* lval, *val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
-
-   assert(!l.updateType);               /* no Forest-Tomlin Updates */
-
-   lval = l.val.data();
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-   end = l.firstUnused;
-
-   for(i = l.firstUpdate; i < end; ++i)
-   {
-      assert(i >= 0 && i < thedim);
-      x = vec[lrow[i]];
-
-      if(isNotZero(x, eps))
-      {
-         k = lbeg[i];
-         assert(k >= 0 && k < l.size);
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            int m = ridx[n] = *idx++;
-            assert(m >= 0 && m < thedim);
-            y = vec[m];
-            n += (y == 0) ? 1 : 0;
-            y = y - x * (*val++);
-            vec[m] = (y != 0) ? y : SOPLEX_FACTOR_MARKER;
-         }
+int CLUFactor<R>::vSolveUpdateRight(R *vec, int *ridx, int n, R eps) {
+  int i, j, k;
+  int end;
+  R x, y;
+  R *lval, *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
+
+  assert(!l.updateType); /* no Forest-Tomlin Updates */
+
+  lval = l.val.data();
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
+  end = l.firstUnused;
+
+  for (i = l.firstUpdate; i < end; ++i) {
+    assert(i >= 0 && i < thedim);
+    x = vec[lrow[i]];
+
+    if (isNotZero(x, eps)) {
+      k = lbeg[i];
+      assert(k >= 0 && k < l.size);
+      idx = &(lidx[k]);
+      val = &(lval[k]);
+
+      for (j = lbeg[i + 1]; j > k; --j) {
+        int m = ridx[n] = *idx++;
+        assert(m >= 0 && m < thedim);
+        y = vec[m];
+        n += (y == 0) ? 1 : 0;
+        y = y - x * (*val++);
+        vec[m] = (y != 0) ? y : SOPLEX_FACTOR_MARKER;
       }
-   }
+    }
+  }
 
-   return n;
+  return n;
 }
 
-template <class R>
-void CLUFactor<R>::vSolveUpdateRightNoNZ(R* vec, R /*eps*/)
-{
-   int i, j, k;
-   int end;
-   R x;
-   R* lval, *val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
-
-   assert(!l.updateType);               /* no Forest-Tomlin Updates */
-
-   lval = l.val.data();
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-   end = l.firstUnused;
-
-   for(i = l.firstUpdate; i < end; ++i)
-   {
-      assert(i >= 0 && i < thedim);
-
-      if((x = vec[lrow[i]]) != 0.0)
-      {
-         k = lbeg[i];
-         assert(k >= 0 && k < l.size);
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+template <class R> void CLUFactor<R>::vSolveUpdateRightNoNZ(R *vec, R /*eps*/) {
+  int i, j, k;
+  int end;
+  R x;
+  R *lval, *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
 
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            assert(*idx >= 0 && *idx < thedim);
-            vec[*idx++] -= x * (*val++);
-         }
-      }
-   }
-}
+  assert(!l.updateType); /* no Forest-Tomlin Updates */
 
+  lval = l.val.data();
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
+  end = l.firstUnused;
 
-template <class R>
-int CLUFactor<R>::vSolveRight4update(R eps,
-                                     R* vec, int* idx,                       /* result */
-                                     R* rhs, int* ridx, int rn,              /* rhs    */
-                                     R* forest, int* forestNum, int* forestIdx)
-{
-   vSolveLright(rhs, ridx, rn, eps);
-   assert(rn >= 0 && rn <= thedim);
+  for (i = l.firstUpdate; i < end; ++i) {
+    assert(i >= 0 && i < thedim);
 
-   /*  turn index list into a heap
-    */
+    if ((x = vec[lrow[i]]) != 0.0) {
+      k = lbeg[i];
+      assert(k >= 0 && k < l.size);
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-   if(forest)
-   {
-      R x;
-      int i, j, k;
-      int* rperm;
-      int* it = forestIdx;
+      for (j = lbeg[i + 1]; j > k; --j) {
+        assert(*idx >= 0 && *idx < thedim);
+        vec[*idx++] -= x * (*val++);
+      }
+    }
+  }
+}
 
-      rperm = row.perm;
+template <class R>
+int CLUFactor<R>::vSolveRight4update(R eps, R *vec, int *idx,   /* result */
+                                     R *rhs, int *ridx, int rn, /* rhs    */
+                                     R *forest, int *forestNum,
+                                     int *forestIdx) {
+  vSolveLright(rhs, ridx, rn, eps);
+  assert(rn >= 0 && rn <= thedim);
+
+  /*  turn index list into a heap
+   */
+
+  if (forest) {
+    R x;
+    int i, j, k;
+    int *rperm;
+    int *it = forestIdx;
+
+    rperm = row.perm;
+
+    for (i = j = 0; i < rn; ++i) {
+      k = ridx[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs[k];
 
-      for(i = j = 0; i < rn; ++i)
-      {
-         k = ridx[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs[k];
-
-         if(isNotZero(x, eps))
-         {
-            enQueueMax(ridx, &j, rperm[*it++ = k]);
-            forest[k] = x;
-         }
-         else
-            rhs[k] = 0;
-      }
+      if (isNotZero(x, eps)) {
+        enQueueMax(ridx, &j, rperm[ *it++ = k]);
+        forest[k] = x;
+      } else
+        rhs[k] = 0;
+    }
 
-      *forestNum = rn = j;
-   }
-   else
-   {
-      R x;
-      int i, j, k;
-      int* rperm;
+    *forestNum = rn = j;
+  } else {
+    R x;
+    int i, j, k;
+    int *rperm;
 
-      rperm = row.perm;
+    rperm = row.perm;
 
-      for(i = j = 0; i < rn; ++i)
-      {
-         k = ridx[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs[k];
-
-         if(isNotZero(x, eps))
-            enQueueMax(ridx, &j, rperm[k]);
-         else
-            rhs[k] = 0;
-      }
+    for (i = j = 0; i < rn; ++i) {
+      k = ridx[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs[k];
 
-      rn = j;
-   }
+      if (isNotZero(x, eps))
+        enQueueMax(ridx, &j, rperm[k]);
+      else
+        rhs[k] = 0;
+    }
+
+    rn = j;
+  }
 
-   rn = vSolveUright(vec, idx, rhs, ridx, rn, eps);
+  rn = vSolveUright(vec, idx, rhs, ridx, rn, eps);
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-      rn = vSolveUpdateRight(vec, idx, rn, eps);
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+    rn = vSolveUpdateRight(vec, idx, rn, eps);
 
-   return rn;
+  return rn;
 }
 
 template <class R>
-int CLUFactor<R>::vSolveRight4update2(R eps,
-                                      R* vec, int* idx,                  /* result1 */
-                                      R* rhs, int* ridx, int rn,         /* rhs1    */
-                                      R* vec2, R eps2,              /* result2 */
-                                      R* rhs2, int* ridx2, int rn2,      /* rhs2    */
-                                      R* forest, int* forestNum, int* forestIdx)
-{
-   vSolveLright2(rhs, ridx, rn, eps, rhs2, ridx2, rn2, eps2);
-   assert(rn >= 0 && rn <= thedim);
-   assert(rn2 >= 0 && rn2 <= thedim);
-
-   /*  turn index list into a heap
-    */
+int CLUFactor<R>::vSolveRight4update2(R eps, R *vec, int *idx,   /* result1 */
+                                      R *rhs, int *ridx, int rn, /* rhs1    */
+                                      R *vec2, R eps2,           /* result2 */
+                                      R *rhs2, int *ridx2, int rn2, /* rhs2 */
+                                      R *forest, int *forestNum,
+                                      int *forestIdx) {
+  vSolveLright2(rhs, ridx, rn, eps, rhs2, ridx2, rn2, eps2);
+  assert(rn >= 0 && rn <= thedim);
+  assert(rn2 >= 0 && rn2 <= thedim);
+
+  /*  turn index list into a heap
+   */
+
+  if (forest) {
+    R x;
+    int i, j, k;
+    int *rperm;
+    int *it = forestIdx;
+
+    rperm = row.perm;
+
+    for (i = j = 0; i < rn; ++i) {
+      k = ridx[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs[k];
 
-   if(forest)
-   {
-      R x;
-      int i, j, k;
-      int* rperm;
-      int* it = forestIdx;
+      if (isNotZero(x, eps)) {
+        enQueueMax(ridx, &j, rperm[ *it++ = k]);
+        forest[k] = x;
+      } else
+        rhs[k] = 0;
+    }
 
-      rperm = row.perm;
+    *forestNum = rn = j;
+  } else {
+    R x;
+    int i, j, k;
+    int *rperm;
 
-      for(i = j = 0; i < rn; ++i)
-      {
-         k = ridx[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs[k];
-
-         if(isNotZero(x, eps))
-         {
-            enQueueMax(ridx, &j, rperm[*it++ = k]);
-            forest[k] = x;
-         }
-         else
-            rhs[k] = 0;
-      }
+    rperm = row.perm;
 
-      *forestNum = rn = j;
-   }
-   else
-   {
-      R x;
-      int i, j, k;
-      int* rperm;
+    for (i = j = 0; i < rn; ++i) {
+      k = ridx[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs[k];
 
-      rperm = row.perm;
+      if (isNotZero(x, eps))
+        enQueueMax(ridx, &j, rperm[k]);
+      else
+        rhs[k] = 0;
+    }
 
-      for(i = j = 0; i < rn; ++i)
-      {
-         k = ridx[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs[k];
-
-         if(isNotZero(x, eps))
-            enQueueMax(ridx, &j, rperm[k]);
-         else
-            rhs[k] = 0;
-      }
+    rn = j;
+  }
 
-      rn = j;
-   }
+  if (rn2 > thedim * verySparseFactor4right) {
+    ridx2[0] = thedim - 1;
+    /* ridx2[1] = thedim - 2; */
+  } else {
+    R x;
+    /*      R  maxabs; */
+    int i, j, k;
+    int *rperm;
 
-   if(rn2 > thedim * verySparseFactor4right)
-   {
-      ridx2[0] = thedim - 1;
-      /* ridx2[1] = thedim - 2; */
-   }
-   else
-   {
-      R x;
-      /*      R  maxabs; */
-      int i, j, k;
-      int* rperm;
+    /*      maxabs = 1;    */
+    rperm = row.perm;
 
-      /*      maxabs = 1;    */
-      rperm = row.perm;
+    for (i = j = 0; i < rn2; ++i) {
+      k = ridx2[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs2[k];
 
-      for(i = j = 0; i < rn2; ++i)
-      {
-         k = ridx2[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs2[k];
-
-         if(x < -eps2)
-         {
-            /*              maxabs = (maxabs < -x) ? -x : maxabs;  */
-            enQueueMax(ridx2, &j, rperm[k]);
-         }
-         else if(x > eps2)
-         {
-            /*              maxabs = (maxabs < x) ? x : maxabs;    */
-            enQueueMax(ridx2, &j, rperm[k]);
-         }
-         else
-            rhs2[k] = 0;
-      }
+      if (x < -eps2) {
+        /*              maxabs = (maxabs < -x) ? -x : maxabs;  */
+        enQueueMax(ridx2, &j, rperm[k]);
+      } else if (x > eps2) {
+        /*              maxabs = (maxabs < x) ? x : maxabs;    */
+        enQueueMax(ridx2, &j, rperm[k]);
+      } else
+        rhs2[k] = 0;
+    }
 
-      rn2 = j;
+    rn2 = j;
 
-      /*      eps2 = maxabs * eps2;  */
-   }
+    /*      eps2 = maxabs * eps2;  */
+  }
 
-   rn = vSolveUright(vec, idx, rhs, ridx, rn, eps);
+  rn = vSolveUright(vec, idx, rhs, ridx, rn, eps);
 
-   vSolveUrightNoNZ(vec2, rhs2, ridx2, rn2, eps2);
+  vSolveUrightNoNZ(vec2, rhs2, ridx2, rn2, eps2);
 
-   /*
-    *  rn = vSolveUright2(vec, idx, rhs, ridx, rn, eps, vec2, rhs2, ridx2, rn2, eps2);
-    */
+  /*
+   *  rn = vSolveUright2(vec, idx, rhs, ridx, rn, eps, vec2, rhs2, ridx2, rn2,
+   * eps2);
+   */
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      rn = vSolveUpdateRight(vec, idx, rn, eps);
-      vSolveUpdateRightNoNZ(vec2, eps2);
-   }
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    rn = vSolveUpdateRight(vec, idx, rn, eps);
+    vSolveUpdateRightNoNZ(vec2, eps2);
+  }
 
-   return rn;
+  return rn;
 }
 
 template <class R>
-void CLUFactor<R>::vSolveRight4update2sparse(R eps, R* vec, int* idx,         /* result1 */
-      R* rhs, int* ridx, int& rn,        /* rhs1    */
-      R eps2, R* vec2, int* idx2,     /* result2 */
-      R* rhs2, int* ridx2, int& rn2,     /* rhs2    */
-      R* forest, int* forestNum, int* forestIdx)
-{
-   /* solve with L */
-   vSolveLright2(rhs, ridx, rn, eps, rhs2, ridx2, rn2, eps2);
-   assert(rn >= 0 && rn <= thedim);
-   assert(rn2 >= 0 && rn2 <= thedim);
-
-   R x;
-   int i, j, k;
-   int* rperm = row.perm;
+void CLUFactor<R>::vSolveRight4update2sparse(
+    R eps, R *vec, int *idx,       /* result1 */
+    R *rhs, int *ridx, int &rn,    /* rhs1    */
+    R eps2, R *vec2, int *idx2,    /* result2 */
+    R *rhs2, int *ridx2, int &rn2, /* rhs2    */
+    R *forest, int *forestNum, int *forestIdx) {
+  /* solve with L */
+  vSolveLright2(rhs, ridx, rn, eps, rhs2, ridx2, rn2, eps2);
+  assert(rn >= 0 && rn <= thedim);
+  assert(rn2 >= 0 && rn2 <= thedim);
+
+  R x;
+  int i, j, k;
+  int *rperm = row.perm;
+
+  /*  turn index list into a heap for both ridx and ridx2 */
+  if (forest) {
+    int *it = forestIdx;
+
+    for (i = j = 0; i < rn; ++i) {
+      k = ridx[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs[k];
 
-   /*  turn index list into a heap for both ridx and ridx2 */
-   if(forest)
-   {
-      int* it = forestIdx;
+      if (isNotZero(x, eps)) {
+        enQueueMax(ridx, &j, rperm[ *it++ = k]);
+        forest[k] = x;
+      } else
+        rhs[k] = 0;
+    }
 
-      for(i = j = 0; i < rn; ++i)
-      {
-         k = ridx[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs[k];
-
-         if(isNotZero(x, eps))
-         {
-            enQueueMax(ridx, &j, rperm[*it++ = k]);
-            forest[k] = x;
-         }
-         else
-            rhs[k] = 0;
-      }
+    *forestNum = rn = j;
+  } else {
+    for (i = j = 0; i < rn; ++i) {
+      k = ridx[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs[k];
 
-      *forestNum = rn = j;
-   }
-   else
-   {
-      for(i = j = 0; i < rn; ++i)
-      {
-         k = ridx[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs[k];
-
-         if(isNotZero(x, eps))
-            enQueueMax(ridx, &j, rperm[k]);
-         else
-            rhs[k] = 0;
-      }
+      if (isNotZero(x, eps))
+        enQueueMax(ridx, &j, rperm[k]);
+      else
+        rhs[k] = 0;
+    }
 
-      rn = j;
-   }
+    rn = j;
+  }
 
-   for(i = j = 0; i < rn2; ++i)
-   {
-      k = ridx2[i];
-      assert(k >= 0 && k < thedim);
-      x = rhs2[k];
+  for (i = j = 0; i < rn2; ++i) {
+    k = ridx2[i];
+    assert(k >= 0 && k < thedim);
+    x = rhs2[k];
 
-      if(isNotZero(x, eps2))
-         enQueueMax(ridx2, &j, rperm[k]);
-      else
-         rhs2[k] = 0;
-   }
+    if (isNotZero(x, eps2))
+      enQueueMax(ridx2, &j, rperm[k]);
+    else
+      rhs2[k] = 0;
+  }
 
-   rn2 = j;
+  rn2 = j;
 
-   /* solve with U */
-   rn = vSolveUright(vec, idx, rhs, ridx, rn, eps);
-   rn2 = vSolveUright(vec2, idx2, rhs2, ridx2, rn2, eps2);
+  /* solve with U */
+  rn = vSolveUright(vec, idx, rhs, ridx, rn, eps);
+  rn2 = vSolveUright(vec2, idx2, rhs2, ridx2, rn2, eps2);
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      rn = vSolveUpdateRight(vec, idx, rn, eps);
-      rn2 = vSolveUpdateRight(vec2, idx2, rn2, eps2);
-   }
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    rn = vSolveUpdateRight(vec, idx, rn, eps);
+    rn2 = vSolveUpdateRight(vec2, idx2, rn2, eps2);
+  }
 }
 
-
 template <class R>
-int CLUFactor<R>::vSolveRight4update3(R eps,
-                                      R* vec, int* idx,                 /* result1 */
-                                      R* rhs, int* ridx, int rn,        /* rhs1    */
-                                      R* vec2, R eps2,               /* result2 */
-                                      R* rhs2, int* ridx2, int rn2,     /* rhs2    */
-                                      R* vec3, R eps3,               /* result3 */
-                                      R* rhs3, int* ridx3, int rn3,     /* rhs3    */
-                                      R* forest, int* forestNum, int* forestIdx)
-{
-
-   vSolveLright3(rhs, ridx, rn, eps, rhs2, ridx2, rn2, eps2, rhs3, ridx3, rn3, eps3);
-   assert(rn >= 0 && rn <= thedim);
-   assert(rn2 >= 0 && rn2 <= thedim);
-   assert(rn3 >= 0 && rn3 <= thedim);
+int CLUFactor<R>::vSolveRight4update3(R eps, R *vec, int *idx,   /* result1 */
+                                      R *rhs, int *ridx, int rn, /* rhs1    */
+                                      R *vec2, R eps2,           /* result2 */
+                                      R *rhs2, int *ridx2, int rn2, /* rhs2 */
+                                      R *vec3, R eps3, /* result3 */
+                                      R *rhs3, int *ridx3, int rn3, /* rhs3 */
+                                      R *forest, int *forestNum,
+                                      int *forestIdx) {
+
+  vSolveLright3(rhs, ridx, rn, eps, rhs2, ridx2, rn2, eps2, rhs3, ridx3, rn3,
+                eps3);
+  assert(rn >= 0 && rn <= thedim);
+  assert(rn2 >= 0 && rn2 <= thedim);
+  assert(rn3 >= 0 && rn3 <= thedim);
+
+  /*  turn index list into a heap
+   */
+
+  if (forest) {
+    R x;
+    int i, j, k;
+    int *rperm;
+    int *it = forestIdx;
+
+    rperm = row.perm;
+
+    for (i = j = 0; i < rn; ++i) {
+      k = ridx[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs[k];
 
-   /*  turn index list into a heap
-    */
+      if (isNotZero(x, eps)) {
+        enQueueMax(ridx, &j, rperm[ *it++ = k]);
+        forest[k] = x;
+      } else
+        rhs[k] = 0;
+    }
 
-   if(forest)
-   {
-      R x;
-      int i, j, k;
-      int* rperm;
-      int* it = forestIdx;
+    *forestNum = rn = j;
+  } else {
+    R x;
+    int i, j, k;
+    int *rperm;
 
-      rperm = row.perm;
+    rperm = row.perm;
 
-      for(i = j = 0; i < rn; ++i)
-      {
-         k = ridx[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs[k];
-
-         if(isNotZero(x, eps))
-         {
-            enQueueMax(ridx, &j, rperm[*it++ = k]);
-            forest[k] = x;
-         }
-         else
-            rhs[k] = 0;
-      }
+    for (i = j = 0; i < rn; ++i) {
+      k = ridx[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs[k];
 
-      *forestNum = rn = j;
-   }
-   else
-   {
-      R x;
-      int i, j, k;
-      int* rperm;
+      if (isNotZero(x, eps))
+        enQueueMax(ridx, &j, rperm[k]);
+      else
+        rhs[k] = 0;
+    }
 
-      rperm = row.perm;
+    rn = j;
+  }
 
-      for(i = j = 0; i < rn; ++i)
-      {
-         k = ridx[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs[k];
-
-         if(isNotZero(x, eps))
-            enQueueMax(ridx, &j, rperm[k]);
-         else
-            rhs[k] = 0;
-      }
+  if (rn2 > thedim * verySparseFactor4right) {
+    ridx2[0] = thedim - 1;
+  } else {
+    R x;
+    int i, j, k;
+    int *rperm;
 
-      rn = j;
-   }
+    rperm = row.perm;
 
-   if(rn2 > thedim * verySparseFactor4right)
-   {
-      ridx2[0] = thedim - 1;
-   }
-   else
-   {
-      R x;
-      int i, j, k;
-      int* rperm;
+    for (i = j = 0; i < rn2; ++i) {
+      k = ridx2[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs2[k];
 
-      rperm = row.perm;
+      if (x < -eps2) {
+        enQueueMax(ridx2, &j, rperm[k]);
+      } else if (x > eps2) {
+        enQueueMax(ridx2, &j, rperm[k]);
+      } else
+        rhs2[k] = 0;
+    }
 
-      for(i = j = 0; i < rn2; ++i)
-      {
-         k = ridx2[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs2[k];
-
-         if(x < -eps2)
-         {
-            enQueueMax(ridx2, &j, rperm[k]);
-         }
-         else if(x > eps2)
-         {
-            enQueueMax(ridx2, &j, rperm[k]);
-         }
-         else
-            rhs2[k] = 0;
-      }
+    rn2 = j;
+  }
 
-      rn2 = j;
-   }
+  if (rn3 > thedim * verySparseFactor4right) {
+    ridx3[0] = thedim - 1;
+  } else {
+    R x;
+    int i, j, k;
+    int *rperm;
 
-   if(rn3 > thedim * verySparseFactor4right)
-   {
-      ridx3[0] = thedim - 1;
-   }
-   else
-   {
-      R x;
-      int i, j, k;
-      int* rperm;
+    rperm = row.perm;
 
-      rperm = row.perm;
+    for (i = j = 0; i < rn3; ++i) {
+      k = ridx3[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs3[k];
 
-      for(i = j = 0; i < rn3; ++i)
-      {
-         k = ridx3[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs3[k];
-
-         if(x < -eps3)
-         {
-            enQueueMax(ridx3, &j, rperm[k]);
-         }
-         else if(x > eps3)
-         {
-            enQueueMax(ridx3, &j, rperm[k]);
-         }
-         else
-            rhs3[k] = 0;
-      }
+      if (x < -eps3) {
+        enQueueMax(ridx3, &j, rperm[k]);
+      } else if (x > eps3) {
+        enQueueMax(ridx3, &j, rperm[k]);
+      } else
+        rhs3[k] = 0;
+    }
 
-      rn3 = j;
-   }
+    rn3 = j;
+  }
 
-   rn = vSolveUright(vec, idx, rhs, ridx, rn, eps);
+  rn = vSolveUright(vec, idx, rhs, ridx, rn, eps);
 
-   vSolveUrightNoNZ(vec2, rhs2, ridx2, rn2, eps2);
-   vSolveUrightNoNZ(vec3, rhs3, ridx3, rn3, eps3);
+  vSolveUrightNoNZ(vec2, rhs2, ridx2, rn2, eps2);
+  vSolveUrightNoNZ(vec3, rhs3, ridx3, rn3, eps3);
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      rn = vSolveUpdateRight(vec, idx, rn, eps);
-      vSolveUpdateRightNoNZ(vec2, eps2);
-      vSolveUpdateRightNoNZ(vec3, eps3);
-   }
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    rn = vSolveUpdateRight(vec, idx, rn, eps);
+    vSolveUpdateRightNoNZ(vec2, eps2);
+    vSolveUpdateRightNoNZ(vec3, eps3);
+  }
 
-   return rn;
+  return rn;
 }
 
 template <class R>
-void CLUFactor<R>::vSolveRight4update3sparse(R eps, R* vec, int* idx,         /* result1 */
-      R* rhs, int* ridx, int& rn,        /* rhs1    */
-      R eps2, R* vec2, int* idx2,     /* result2 */
-      R* rhs2, int* ridx2, int& rn2,     /* rhs2    */
-      R eps3, R* vec3, int* idx3,     /* result3 */
-      R* rhs3, int* ridx3, int& rn3,     /* rhs3    */
-      R* forest, int* forestNum, int* forestIdx)
-{
-   vSolveLright3(rhs, ridx, rn, eps, rhs2, ridx2, rn2, eps2, rhs3, ridx3, rn3, eps3);
-   assert(rn >= 0 && rn <= thedim);
-   assert(rn2 >= 0 && rn2 <= thedim);
-   assert(rn3 >= 0 && rn3 <= thedim);
-
-   R x;
-   int i, j, k;
-   int* rperm = row.perm;
-
-   /*  turn index list into a heap */
-   if(forest)
-   {
-      int* it = forestIdx;
-
-      for(i = j = 0; i < rn; ++i)
-      {
-         k = ridx[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs[k];
-
-         if(isNotZero(x, eps))
-         {
-            enQueueMax(ridx, &j, rperm[*it++ = k]);
-            forest[k] = x;
-         }
-         else
-            rhs[k] = 0;
-      }
-
-      *forestNum = rn = j;
-   }
-   else
-   {
-      for(i = j = 0; i < rn; ++i)
-      {
-         k = ridx[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs[k];
-
-         if(isNotZero(x, eps))
-            enQueueMax(ridx, &j, rperm[k]);
-         else
-            rhs[k] = 0;
-      }
-
-      rn = j;
-   }
-
-   for(i = j = 0; i < rn2; ++i)
-   {
-      k = ridx2[i];
+void CLUFactor<R>::vSolveRight4update3sparse(
+    R eps, R *vec, int *idx,       /* result1 */
+    R *rhs, int *ridx, int &rn,    /* rhs1    */
+    R eps2, R *vec2, int *idx2,    /* result2 */
+    R *rhs2, int *ridx2, int &rn2, /* rhs2    */
+    R eps3, R *vec3, int *idx3,    /* result3 */
+    R *rhs3, int *ridx3, int &rn3, /* rhs3    */
+    R *forest, int *forestNum, int *forestIdx) {
+  vSolveLright3(rhs, ridx, rn, eps, rhs2, ridx2, rn2, eps2, rhs3, ridx3, rn3,
+                eps3);
+  assert(rn >= 0 && rn <= thedim);
+  assert(rn2 >= 0 && rn2 <= thedim);
+  assert(rn3 >= 0 && rn3 <= thedim);
+
+  R x;
+  int i, j, k;
+  int *rperm = row.perm;
+
+  /*  turn index list into a heap */
+  if (forest) {
+    int *it = forestIdx;
+
+    for (i = j = 0; i < rn; ++i) {
+      k = ridx[i];
       assert(k >= 0 && k < thedim);
-      x = rhs2[k];
-
-      if(isNotZero(x, eps2))
-         enQueueMax(ridx2, &j, rperm[k]);
-      else
-         rhs2[k] = 0;
-   }
+      x = rhs[k];
 
-   rn2 = j;
+      if (isNotZero(x, eps)) {
+        enQueueMax(ridx, &j, rperm[ *it++ = k]);
+        forest[k] = x;
+      } else
+        rhs[k] = 0;
+    }
 
-   for(i = j = 0; i < rn3; ++i)
-   {
-      k = ridx3[i];
+    *forestNum = rn = j;
+  } else {
+    for (i = j = 0; i < rn; ++i) {
+      k = ridx[i];
       assert(k >= 0 && k < thedim);
-      x = rhs3[k];
+      x = rhs[k];
 
-      if(isNotZero(x, eps3))
-         enQueueMax(ridx3, &j, rperm[k]);
+      if (isNotZero(x, eps))
+        enQueueMax(ridx, &j, rperm[k]);
       else
-         rhs3[k] = 0;
-   }
-
-   rn3 = j;
-
-   rn = vSolveUright(vec, idx, rhs, ridx, rn, eps);
-   rn2 = vSolveUright(vec2, idx2, rhs2, ridx2, rn2, eps2);
-   rn3 = vSolveUright(vec3, idx3, rhs3, ridx3, rn3, eps3);
+        rhs[k] = 0;
+    }
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      rn = vSolveUpdateRight(vec, idx, rn, eps);
-      rn2 = vSolveUpdateRight(vec2, idx2, rn2, eps2);
-      rn3 = vSolveUpdateRight(vec3, idx3, rn3, eps3);
-   }
+    rn = j;
+  }
+
+  for (i = j = 0; i < rn2; ++i) {
+    k = ridx2[i];
+    assert(k >= 0 && k < thedim);
+    x = rhs2[k];
+
+    if (isNotZero(x, eps2))
+      enQueueMax(ridx2, &j, rperm[k]);
+    else
+      rhs2[k] = 0;
+  }
+
+  rn2 = j;
+
+  for (i = j = 0; i < rn3; ++i) {
+    k = ridx3[i];
+    assert(k >= 0 && k < thedim);
+    x = rhs3[k];
+
+    if (isNotZero(x, eps3))
+      enQueueMax(ridx3, &j, rperm[k]);
+    else
+      rhs3[k] = 0;
+  }
+
+  rn3 = j;
+
+  rn = vSolveUright(vec, idx, rhs, ridx, rn, eps);
+  rn2 = vSolveUright(vec2, idx2, rhs2, ridx2, rn2, eps2);
+  rn3 = vSolveUright(vec3, idx3, rhs3, ridx3, rn3, eps3);
+
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    rn = vSolveUpdateRight(vec, idx, rn, eps);
+    rn2 = vSolveUpdateRight(vec2, idx2, rn2, eps2);
+    rn3 = vSolveUpdateRight(vec3, idx3, rn3, eps3);
+  }
 }
 
 template <class R>
-void CLUFactor<R>::vSolveRightNoNZ(
-   R* vec, R eps,             /* result */
-   R* rhs, int* ridx, int rn)    /* rhs    */
+void CLUFactor<R>::vSolveRightNoNZ(R *vec, R eps,             /* result */
+                                   R *rhs, int *ridx, int rn) /* rhs    */
 {
-   vSolveLright(rhs, ridx, rn, eps);
-   assert(rn >= 0 && rn <= thedim);
-
-   if(rn > thedim * verySparseFactor4right)
-   {
-      *ridx = thedim - 1;
-   }
-   else
-   {
-      R x;
-      /*      R  maxabs; */
-      int i, j, k;
-      int* rperm;
-
-      /*      maxabs = 1;    */
-      rperm = row.perm;
-
-      for(i = j = 0; i < rn; ++i)
-      {
-         k = ridx[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs[k];
-
-         if(x < -eps)
-         {
-            /*              maxabs = (maxabs < -x) ? -x : maxabs;  */
-            enQueueMax(ridx, &j, rperm[k]);
-         }
-         else if(x > eps)
-         {
-            /*              maxabs = (maxabs < x) ? x : maxabs;    */
-            enQueueMax(ridx, &j, rperm[k]);
-         }
-         else
-            rhs[k] = 0;
-      }
+  vSolveLright(rhs, ridx, rn, eps);
+  assert(rn >= 0 && rn <= thedim);
+
+  if (rn > thedim * verySparseFactor4right) {
+    *ridx = thedim - 1;
+  } else {
+    R x;
+    /*      R  maxabs; */
+    int i, j, k;
+    int *rperm;
+
+    /*      maxabs = 1;    */
+    rperm = row.perm;
+
+    for (i = j = 0; i < rn; ++i) {
+      k = ridx[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs[k];
+
+      if (x < -eps) {
+        /*              maxabs = (maxabs < -x) ? -x : maxabs;  */
+        enQueueMax(ridx, &j, rperm[k]);
+      } else if (x > eps) {
+        /*              maxabs = (maxabs < x) ? x : maxabs;    */
+        enQueueMax(ridx, &j, rperm[k]);
+      } else
+        rhs[k] = 0;
+    }
 
-      rn = j;
+    rn = j;
 
-      /*      eps2 = maxabs * eps2;  */
-   }
+    /*      eps2 = maxabs * eps2;  */
+  }
 
-   vSolveUrightNoNZ(vec, rhs, ridx, rn, eps);
+  vSolveUrightNoNZ(vec, rhs, ridx, rn, eps);
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-      vSolveUpdateRightNoNZ(vec, eps);
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+    vSolveUpdateRightNoNZ(vec, eps);
 }
 
 template <class R>
-int CLUFactor<R>::vSolveLeft(R eps,
-                             R* vec, int* idx,                       /* result */
-                             R* rhs, int* ridx, int rn)            /* rhs    */
+int CLUFactor<R>::vSolveLeft(R eps, R *vec, int *idx,   /* result */
+                             R *rhs, int *ridx, int rn) /* rhs    */
 {
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      rn = solveUpdateLeft(eps, rhs, ridx, rn);
-      rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
-   }
-   else
-   {
-      rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
-      rn = solveLleftForest(eps, vec, idx, rn);
-   }
-
-   // TODO verify the correctness of this check
-   if(rn + l.firstUpdate > verySparseFactor4left * thedim)
-   {
-      // perform the dense solve
-      solveLleftNoNZ(vec);
-      // signal the caller that the nonzero pattern is lost
-      return 0;
-   }
-   else
-      return solveLleft(eps, vec, idx, rn);
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    rn = solveUpdateLeft(eps, rhs, ridx, rn);
+    rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
+  } else {
+    rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
+    rn = solveLleftForest(eps, vec, idx, rn);
+  }
+
+  // TODO verify the correctness of this check
+  if (rn + l.firstUpdate > verySparseFactor4left * thedim) {
+    // perform the dense solve
+    solveLleftNoNZ(vec);
+    // signal the caller that the nonzero pattern is lost
+    return 0;
+  } else
+    return solveLleft(eps, vec, idx, rn);
 }
 
 template <class R>
-int CLUFactor<R>::vSolveLeft2(R eps,
-                              R* vec, int* idx,                      /* result */
-                              R* rhs, int* ridx, int rn,             /* rhs    */
-                              R* vec2,                               /* result2 */
-                              R* rhs2, int* ridx2, int rn2)        /* rhs2    */
+int CLUFactor<R>::vSolveLeft2(R eps, R *vec, int *idx,      /* result */
+                              R *rhs, int *ridx, int rn,    /* rhs    */
+                              R *vec2,                      /* result2 */
+                              R *rhs2, int *ridx2, int rn2) /* rhs2    */
 {
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      rn = solveUpdateLeft(eps, rhs, ridx, rn);
-      rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
-      rn2 = solveUpdateLeft(eps, rhs2, ridx2, rn2);
-      solveUleftNoNZ(eps, vec2, rhs2, ridx2, rn2);
-   }
-   else
-   {
-      rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
-      rn = solveLleftForest(eps, vec, idx, rn);
-      solveUleftNoNZ(eps, vec2, rhs2, ridx2, rn2);
-      solveLleftForestNoNZ(vec2);
-   }
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    rn = solveUpdateLeft(eps, rhs, ridx, rn);
+    rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
+    rn2 = solveUpdateLeft(eps, rhs2, ridx2, rn2);
+    solveUleftNoNZ(eps, vec2, rhs2, ridx2, rn2);
+  } else {
+    rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
+    rn = solveLleftForest(eps, vec, idx, rn);
+    solveUleftNoNZ(eps, vec2, rhs2, ridx2, rn2);
+    solveLleftForestNoNZ(vec2);
+  }
 
-   rn = solveLleft(eps, vec, idx, rn);
+  rn = solveLleft(eps, vec, idx, rn);
 
-   solveLleftNoNZ(vec2);
+  solveLleftNoNZ(vec2);
 
-   return rn;
+  return rn;
 }
 
 template <class R>
-void CLUFactor<R>::vSolveLeft2sparse(R eps,
-                                     R* vec, int* idx,                      /* result */
-                                     R* rhs, int* ridx, int& rn,            /* rhs    */
-                                     R* vec2, int* idx2,                    /* result2 */
-                                     R* rhs2, int* ridx2, int& rn2)         /* rhs2    */
+void CLUFactor<R>::vSolveLeft2sparse(R eps, R *vec, int *idx,    /* result */
+                                     R *rhs, int *ridx, int &rn, /* rhs    */
+                                     R *vec2, int *idx2,         /* result2 */
+                                     R *rhs2, int *ridx2, int &rn2) /* rhs2 */
 {
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      rn = solveUpdateLeft(eps, rhs, ridx, rn);
-      rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
-      rn2 = solveUpdateLeft(eps, rhs2, ridx2, rn2);
-      rn2 = solveUleft(eps, vec2, idx2, rhs2, ridx2, rn2);
-   }
-   else
-   {
-      rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
-      rn = solveLleftForest(eps, vec, idx, rn);
-      rn2 = solveUleft(eps, vec2, idx2, rhs2, ridx2, rn2);
-      rn2 = solveLleftForest(eps, vec2, idx2, rn2);
-
-   }
-
-   rn = solveLleft(eps, vec, idx, rn);
-   rn2 = solveLleft(eps, vec2, idx2, rn2);
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    rn = solveUpdateLeft(eps, rhs, ridx, rn);
+    rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
+    rn2 = solveUpdateLeft(eps, rhs2, ridx2, rn2);
+    rn2 = solveUleft(eps, vec2, idx2, rhs2, ridx2, rn2);
+  } else {
+    rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
+    rn = solveLleftForest(eps, vec, idx, rn);
+    rn2 = solveUleft(eps, vec2, idx2, rhs2, ridx2, rn2);
+    rn2 = solveLleftForest(eps, vec2, idx2, rn2);
+  }
+
+  rn = solveLleft(eps, vec, idx, rn);
+  rn2 = solveLleft(eps, vec2, idx2, rn2);
 }
 
-
 template <class R>
-int CLUFactor<R>::vSolveLeft3(R eps,
-                              R* vec, int* idx,                      /* result */
-                              R* rhs, int* ridx, int rn,             /* rhs    */
-                              R* vec2,                               /* result2 */
-                              R* rhs2, int* ridx2, int rn2,          /* rhs2    */
-                              R* vec3,                               /* result3 */
-                              R* rhs3, int* ridx3, int rn3)          /* rhs3    */
+int CLUFactor<R>::vSolveLeft3(R eps, R *vec, int *idx,      /* result */
+                              R *rhs, int *ridx, int rn,    /* rhs    */
+                              R *vec2,                      /* result2 */
+                              R *rhs2, int *ridx2, int rn2, /* rhs2    */
+                              R *vec3,                      /* result3 */
+                              R *rhs3, int *ridx3, int rn3) /* rhs3    */
 {
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      rn = solveUpdateLeft(eps, rhs, ridx, rn);
-      rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
-      rn2 = solveUpdateLeft(eps, rhs2, ridx2, rn2);
-      solveUleftNoNZ(eps, vec2, rhs2, ridx2, rn2);
-      rn3 = solveUpdateLeft(eps, rhs3, ridx3, rn3);
-      solveUleftNoNZ(eps, vec3, rhs3, ridx3, rn3);
-   }
-   else
-   {
-      rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
-      rn = solveLleftForest(eps, vec, idx, rn);
-      solveUleftNoNZ(eps, vec2, rhs2, ridx2, rn2);
-      solveLleftForestNoNZ(vec2);
-      solveUleftNoNZ(eps, vec3, rhs3, ridx3, rn3);
-      solveLleftForestNoNZ(vec3);
-   }
-
-   rn = solveLleft(eps, vec, idx, rn);
-
-   solveLleftNoNZ(vec2);
-   solveLleftNoNZ(vec3);
-
-   return rn;
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    rn = solveUpdateLeft(eps, rhs, ridx, rn);
+    rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
+    rn2 = solveUpdateLeft(eps, rhs2, ridx2, rn2);
+    solveUleftNoNZ(eps, vec2, rhs2, ridx2, rn2);
+    rn3 = solveUpdateLeft(eps, rhs3, ridx3, rn3);
+    solveUleftNoNZ(eps, vec3, rhs3, ridx3, rn3);
+  } else {
+    rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
+    rn = solveLleftForest(eps, vec, idx, rn);
+    solveUleftNoNZ(eps, vec2, rhs2, ridx2, rn2);
+    solveLleftForestNoNZ(vec2);
+    solveUleftNoNZ(eps, vec3, rhs3, ridx3, rn3);
+    solveLleftForestNoNZ(vec3);
+  }
+
+  rn = solveLleft(eps, vec, idx, rn);
+
+  solveLleftNoNZ(vec2);
+  solveLleftNoNZ(vec3);
+
+  return rn;
 }
 
 template <class R>
-void CLUFactor<R>::vSolveLeft3sparse(R eps,
-                                     R* vec, int* idx,                      /* result */
-                                     R* rhs, int* ridx, int& rn,            /* rhs    */
-                                     R* vec2, int* idx2,                    /* result2 */
-                                     R* rhs2, int* ridx2, int& rn2,         /* rhs2    */
-                                     R* vec3, int* idx3,                    /* result3 */
-                                     R* rhs3, int* ridx3, int& rn3)         /* rhs3    */
+void CLUFactor<R>::vSolveLeft3sparse(R eps, R *vec, int *idx,    /* result */
+                                     R *rhs, int *ridx, int &rn, /* rhs    */
+                                     R *vec2, int *idx2,         /* result2 */
+                                     R *rhs2, int *ridx2, int &rn2, /* rhs2 */
+                                     R *vec3, int *idx3, /* result3 */
+                                     R *rhs3, int *ridx3, int &rn3) /* rhs3 */
 {
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      rn = solveUpdateLeft(eps, rhs, ridx, rn);
-      rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
-      rn2 = solveUpdateLeft(eps, rhs2, ridx2, rn2);
-      rn2 = solveUleft(eps, vec2, idx2, rhs2, ridx2, rn2);
-      rn3 = solveUpdateLeft(eps, rhs3, ridx3, rn3);
-      rn3 = solveUleft(eps, vec3, idx3, rhs3, ridx3, rn3);
-   }
-   else
-   {
-      rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
-      rn = solveLleftForest(eps, vec, idx, rn);
-      rn2 = solveUleft(eps, vec2, idx2, rhs2, ridx2, rn2);
-      rn2 = solveLleftForest(eps, vec2, idx2, rn2);
-      rn3 = solveUleft(eps, vec3, idx3, rhs3, ridx3, rn3);
-      rn3 = solveLleftForest(eps, vec3, idx3, rn3);
-   }
-
-   rn = solveLleft(eps, vec, idx, rn);
-   rn2 = solveLleft(eps, vec2, idx2, rn2);
-   rn3 = solveLleft(eps, vec3, idx3, rn3);
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    rn = solveUpdateLeft(eps, rhs, ridx, rn);
+    rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
+    rn2 = solveUpdateLeft(eps, rhs2, ridx2, rn2);
+    rn2 = solveUleft(eps, vec2, idx2, rhs2, ridx2, rn2);
+    rn3 = solveUpdateLeft(eps, rhs3, ridx3, rn3);
+    rn3 = solveUleft(eps, vec3, idx3, rhs3, ridx3, rn3);
+  } else {
+    rn = solveUleft(eps, vec, idx, rhs, ridx, rn);
+    rn = solveLleftForest(eps, vec, idx, rn);
+    rn2 = solveUleft(eps, vec2, idx2, rhs2, ridx2, rn2);
+    rn2 = solveLleftForest(eps, vec2, idx2, rn2);
+    rn3 = solveUleft(eps, vec3, idx3, rhs3, ridx3, rn3);
+    rn3 = solveLleftForest(eps, vec3, idx3, rn3);
+  }
+
+  rn = solveLleft(eps, vec, idx, rn);
+  rn2 = solveLleft(eps, vec2, idx2, rn2);
+  rn3 = solveLleft(eps, vec3, idx3, rn3);
 }
 
 template <class R>
-void CLUFactor<R>::vSolveLeftNoNZ(R eps,
-                                  R* vec2,                            /* result2 */
-                                  R* rhs2, int* ridx2, int rn2)     /* rhs2    */
+void CLUFactor<R>::vSolveLeftNoNZ(R eps, R *vec2,               /* result2 */
+                                  R *rhs2, int *ridx2, int rn2) /* rhs2    */
 {
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      rn2 = solveUpdateLeft(eps, rhs2, ridx2, rn2);
-      solveUleftNoNZ(eps, vec2, rhs2, ridx2, rn2);
-   }
-   else
-   {
-      solveUleftNoNZ(eps, vec2, rhs2, ridx2, rn2);
-      solveLleftForestNoNZ(vec2);
-   }
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    rn2 = solveUpdateLeft(eps, rhs2, ridx2, rn2);
+    solveUleftNoNZ(eps, vec2, rhs2, ridx2, rn2);
+  } else {
+    solveUleftNoNZ(eps, vec2, rhs2, ridx2, rn2);
+    solveLleftForestNoNZ(vec2);
+  }
 
-   solveLleftNoNZ(vec2);
+  solveLleftNoNZ(vec2);
 }
 } // namespace soplex
diff --git a/src/soplex/clufactor_rational.hpp b/src/soplex/clufactor_rational.hpp
index 6a8d9e8..1ce3061 100644
--- a/src/soplex/clufactor_rational.hpp
+++ b/src/soplex/clufactor_rational.hpp
@@ -21,12 +21,12 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
-#include <assert.h>
 #include "soplex/cring.h"
+#include <assert.h>
 
-namespace soplex
-{
+namespace soplex {
 /* This number is used to decide wether a value is zero
  * or was explicitly set to zero.
  */
@@ -38,632 +38,553 @@ static const Real verySparseFactorRat = 0.001;
 static const Real verySparseFactor4rightRat = 0.2;
 
 /* generic heap management */
-static void enQueueMaxRat(int* heap, int* size, int elem)
-{
-   int i, j;
+static void enQueueMaxRat(int *heap, int *size, int elem) {
+  int i, j;
 
-   j = (*size)++;
+  j = (*size)++;
 
-   while(j > 0)
-   {
-      i = (j - 1) / 2;
+  while (j > 0) {
+    i = (j - 1) / 2;
 
-      if(elem > heap[i])
-      {
-         heap[j] = heap[i];
-         j = i;
-      }
-      else
-         break;
-   }
+    if (elem > heap[i]) {
+      heap[j] = heap[i];
+      j = i;
+    } else
+      break;
+  }
 
-   heap[j] = elem;
+  heap[j] = elem;
 
 #ifdef SOPLEX_DEBUG
 
-   // no NDEBUG define, since this block is really expensive
-   for(i = 1; i < *size; ++i)
-      for(j = 0; j < i; ++j)
-         assert(heap[i] != heap[j]);
+  // no NDEBUG define, since this block is really expensive
+  for (i = 1; i < *size; ++i)
+    for (j = 0; j < i; ++j)
+      assert(heap[i] != heap[j]);
 
-#endif  /* SOPLEX_DEBUG */
+#endif /* SOPLEX_DEBUG */
 }
 
-static int deQueueMaxRat(int* heap, int* size)
-{
-   int e, elem;
-   int i, j, s;
-   int e1, e2;
-
-   elem = *heap;
-   e = heap[s = --(*size)];
-   --s;
-
-   for(j = 0, i = 1; i < s; i = 2 * j + 1)
-   {
-      e1 = heap[i];
-      e2 = heap[i + 1];
-
-      if(e1 > e2)
-      {
-         if(e < e1)
-         {
-            heap[j] = e1;
-            j = i;
-         }
-         else
-         {
-            heap[j] = e;
-            return elem;
-         }
+static int deQueueMaxRat(int *heap, int *size) {
+  int e, elem;
+  int i, j, s;
+  int e1, e2;
+
+  elem = *heap;
+  e = heap[s = --(*size)];
+  --s;
+
+  for (j = 0, i = 1; i < s; i = 2 * j + 1) {
+    e1 = heap[i];
+    e2 = heap[i + 1];
+
+    if (e1 > e2) {
+      if (e < e1) {
+        heap[j] = e1;
+        j = i;
+      } else {
+        heap[j] = e;
+        return elem;
       }
-      else
-      {
-         if(e < e2)
-         {
-            heap[j] = e2;
-            j = i + 1;
-         }
-         else
-         {
-            heap[j] = e;
-            return elem;
-         }
+    } else {
+      if (e < e2) {
+        heap[j] = e2;
+        j = i + 1;
+      } else {
+        heap[j] = e;
+        return elem;
       }
-   }
+    }
+  }
 
-   if(i < *size && e < heap[i])
-   {
-      heap[j] = heap[i];
-      j = i;
-   }
+  if (i < *size && e < heap[i]) {
+    heap[j] = heap[i];
+    j = i;
+  }
 
-   heap[j] = e;
+  heap[j] = e;
 
-   return elem;
+  return elem;
 }
 
-static void enQueueMinRat(int* heap, int* size, int elem)
-{
-   int i, j;
+static void enQueueMinRat(int *heap, int *size, int elem) {
+  int i, j;
 
-   j = (*size)++;
+  j = (*size)++;
 
-   while(j > 0)
-   {
-      i = (j - 1) / 2;
+  while (j > 0) {
+    i = (j - 1) / 2;
 
-      if(elem < heap[i])
-      {
-         heap[j] = heap[i];
-         j = i;
-      }
-      else
-         break;
-   }
+    if (elem < heap[i]) {
+      heap[j] = heap[i];
+      j = i;
+    } else
+      break;
+  }
 
-   heap[j] = elem;
+  heap[j] = elem;
 
 #ifdef SOPLEX_DEBUG
 
-   // no NDEBUG define, since this block is really expensive
-   for(i = 1; i < *size; ++i)
-      for(j = 0; j < i; ++j)
-         assert(heap[i] != heap[j]);
+  // no NDEBUG define, since this block is really expensive
+  for (i = 1; i < *size; ++i)
+    for (j = 0; j < i; ++j)
+      assert(heap[i] != heap[j]);
 
-#endif  /* SOPLEX_DEBUG */
+#endif /* SOPLEX_DEBUG */
 }
 
-static int deQueueMinRat(int* heap, int* size)
-{
-   int e, elem;
-   int i, j, s;
-   int e1, e2;
-
-   elem = *heap;
-   e = heap[s = --(*size)];
-   --s;
-
-   for(j = 0, i = 1; i < s; i = 2 * j + 1)
-   {
-      e1 = heap[i];
-      e2 = heap[i + 1];
-
-      if(e1 < e2)
-      {
-         if(e > e1)
-         {
-            heap[j] = e1;
-            j = i;
-         }
-         else
-         {
-            heap[j] = e;
-            return elem;
-         }
+static int deQueueMinRat(int *heap, int *size) {
+  int e, elem;
+  int i, j, s;
+  int e1, e2;
+
+  elem = *heap;
+  e = heap[s = --(*size)];
+  --s;
+
+  for (j = 0, i = 1; i < s; i = 2 * j + 1) {
+    e1 = heap[i];
+    e2 = heap[i + 1];
+
+    if (e1 < e2) {
+      if (e > e1) {
+        heap[j] = e1;
+        j = i;
+      } else {
+        heap[j] = e;
+        return elem;
       }
-      else
-      {
-         if(e > e2)
-         {
-            heap[j] = e2;
-            j = i + 1;
-         }
-         else
-         {
-            heap[j] = e;
-            return elem;
-         }
+    } else {
+      if (e > e2) {
+        heap[j] = e2;
+        j = i + 1;
+      } else {
+        heap[j] = e;
+        return elem;
       }
-   }
+    }
+  }
 
-   if(i < *size && e > heap[i])
-   {
-      heap[j] = heap[i];
-      j = i;
-   }
+  if (i < *size && e > heap[i]) {
+    heap[j] = heap[i];
+    j = i;
+  }
 
-   heap[j] = e;
+  heap[j] = e;
 
-   return elem;
+  return elem;
 }
 
 /************************************************************/
 inline CLUFactorRational::Temp::Temp()
-   : s_mark(0)
-   , s_cact(0)
-   , stage(0)
-   , pivot_col(0)
-   , pivot_colNZ(0)
-   , pivot_row(0)
-   , pivot_rowNZ(0)
-{}
-
-inline void CLUFactorRational::Temp::init(int p_dim)
-{
-   s_max.reDim(p_dim);
-   spx_realloc(s_cact, p_dim);
-   spx_realloc(s_mark, p_dim);
-   stage = 0;
+    : s_mark(0), s_cact(0), stage(0), pivot_col(0), pivot_colNZ(0),
+      pivot_row(0), pivot_rowNZ(0) {}
+
+inline void CLUFactorRational::Temp::init(int p_dim) {
+  s_max.reDim(p_dim);
+  spx_realloc(s_cact, p_dim);
+  spx_realloc(s_mark, p_dim);
+  stage = 0;
 }
 
-inline void CLUFactorRational::Temp::clear()
-{
-   if(s_mark != 0)
-      spx_free(s_mark);
+inline void CLUFactorRational::Temp::clear() {
+  if (s_mark != 0)
+    spx_free(s_mark);
 
-   if(s_cact != 0)
-      spx_free(s_cact);
+  if (s_cact != 0)
+    spx_free(s_cact);
 
-   if(pivot_col != 0)
-      spx_free(pivot_col);
+  if (pivot_col != 0)
+    spx_free(pivot_col);
 
-   if(pivot_colNZ != 0)
-      spx_free(pivot_colNZ);
+  if (pivot_colNZ != 0)
+    spx_free(pivot_colNZ);
 
-   if(pivot_row != 0)
-      spx_free(pivot_row);
+  if (pivot_row != 0)
+    spx_free(pivot_row);
 
-   if(pivot_rowNZ != 0)
-      spx_free(pivot_rowNZ);
+  if (pivot_rowNZ != 0)
+    spx_free(pivot_rowNZ);
 
-   try
-   {
-      s_max.reDim(0);
-   }
-   catch(const SPxMemoryException& x)
-   {
-      throw x;
-   }
+  try {
+    s_max.reDim(0);
+  } catch (const SPxMemoryException &x) {
+    throw x;
+  }
 }
 
-inline CLUFactorRational::Temp::~Temp()
-{
-   clear();
-}
+inline CLUFactorRational::Temp::~Temp() { clear(); }
 
 /************************************************************/
-inline void CLUFactorRational::initPerm()
-{
+inline void CLUFactorRational::initPerm() {
 
-   for(int i = 0; i < thedim; ++i)
-      row.orig[i] = row.perm[i] = col.orig[i] = col.perm[i] = -1;
+  for (int i = 0; i < thedim; ++i)
+    row.orig[i] = row.perm[i] = col.orig[i] = col.perm[i] = -1;
 }
 
 /*****************************************************************************/
 
-inline void CLUFactorRational::setPivot(const int p_stage,
-                                        const int p_col,
-                                        const int p_row,
-                                        const Rational& val)
-{
-   assert(row.perm[p_row] < 0);
-   assert(col.perm[p_col] < 0);
+inline void CLUFactorRational::setPivot(const int p_stage, const int p_col,
+                                        const int p_row, const Rational &val) {
+  assert(row.perm[p_row] < 0);
+  assert(col.perm[p_col] < 0);
 
-   row.orig[p_stage] = p_row;
-   col.orig[p_stage] = p_col;
-   row.perm[p_row]   = p_stage;
-   col.perm[p_col]   = p_stage;
-   diag[p_row]       = 1.0 / val;
+  row.orig[p_stage] = p_row;
+  col.orig[p_stage] = p_col;
+  row.perm[p_row] = p_stage;
+  col.perm[p_col] = p_stage;
+  diag[p_row] = 1.0 / val;
 
-   if(spxAbs(diag[p_row]) > maxabs)
-      maxabs = spxAbs(diag[p_row]);
+  if (spxAbs(diag[p_row]) > maxabs)
+    maxabs = spxAbs(diag[p_row]);
 }
 
 /*****************************************************************************/
 /*
  *      Perform garbage collection on row file
  */
-inline void CLUFactorRational::packRows()
-{
-   int n, i, j, l_row;
-   Dring* ring, *list;
-
-   int* l_ridx = u.row.idx;
-   VectorRational& l_rval = u.row.val;
-   int* l_rlen = u.row.len;
-   int* l_rmax = u.row.max;
-   int* l_rbeg = u.row.start;
-
-   n = 0;
-   list = &(u.row.list);
-
-   for(ring = list->next; ring != list; ring = ring->next)
-   {
-      l_row = ring->idx;
-
-      if(l_rbeg[l_row] != n)
-      {
-         do
-         {
-            l_row = ring->idx;
-            i = l_rbeg[l_row];
-            assert(l_rlen[l_row] <= l_rmax[l_row]);
-            l_rbeg[l_row] = n;
-            l_rmax[l_row] = l_rlen[l_row];
-            j = i + l_rlen[l_row];
-
-            for(; i < j; ++i, ++n)
-            {
-               assert(n <= i);
-               l_ridx[n] = l_ridx[i];
-               l_rval[n] = l_rval[i];
-            }
-
-            ring = ring->next;
-         }
-         while(ring != list);
-
-         goto terminatePackRows;
-      }
+inline void CLUFactorRational::packRows() {
+  int n, i, j, l_row;
+  Dring *ring, *list;
+
+  int *l_ridx = u.row.idx;
+  VectorRational &l_rval = u.row.val;
+  int *l_rlen = u.row.len;
+  int *l_rmax = u.row.max;
+  int *l_rbeg = u.row.start;
+
+  n = 0;
+  list = &(u.row.list);
+
+  for (ring = list->next; ring != list; ring = ring->next) {
+    l_row = ring->idx;
+
+    if (l_rbeg[l_row] != n) {
+      do {
+        l_row = ring->idx;
+        i = l_rbeg[l_row];
+        assert(l_rlen[l_row] <= l_rmax[l_row]);
+        l_rbeg[l_row] = n;
+        l_rmax[l_row] = l_rlen[l_row];
+        j = i + l_rlen[l_row];
+
+        for (; i < j; ++i, ++n) {
+          assert(n <= i);
+          l_ridx[n] = l_ridx[i];
+          l_rval[n] = l_rval[i];
+        }
+
+        ring = ring->next;
+      } while (ring != list);
+
+      goto terminatePackRows;
+    }
 
-      n += l_rlen[l_row];
+    n += l_rlen[l_row];
 
-      l_rmax[l_row] = l_rlen[l_row];
-   }
+    l_rmax[l_row] = l_rlen[l_row];
+  }
 
 terminatePackRows:
 
-   u.row.max[thedim] = 0;
-   u.row.used = n;
+  u.row.max[thedim] = 0;
+  u.row.used = n;
 }
 
 /*****************************************************************************/
 /*
  *      Perform garbage collection on column file
  */
-inline void CLUFactorRational::forestPackColumns()
-{
-   int n, i, j, colno;
-   Dring* ring, *list;
-
-   VectorRational& cval = u.col.val;
-   int* cidx = u.col.idx;
-   int* clen = u.col.len;
-   int* cmax = u.col.max;
-   int* cbeg = u.col.start;
-
-   n = 0;
-   list = &u.col.list;
-
-   for(ring = list->next; ring != list; ring = ring->next)
-   {
-      colno = ring->idx;
-
-      if(cbeg[colno] != n)
-      {
-         do
-         {
-            colno = ring->idx;
-            i = cbeg[colno];
-            cbeg[colno] = n;
-            cmax[colno] = clen[colno];
-            j = i + clen[colno];
-
-            for(; i < j; ++i)
-            {
-               cval[n] = cval[i];
-               cidx[n++] = cidx[i];
-            }
-
-            ring = ring->next;
-         }
-         while(ring != list);
-
-         goto terminatePackColumns;
-      }
+inline void CLUFactorRational::forestPackColumns() {
+  int n, i, j, colno;
+  Dring *ring, *list;
+
+  VectorRational &cval = u.col.val;
+  int *cidx = u.col.idx;
+  int *clen = u.col.len;
+  int *cmax = u.col.max;
+  int *cbeg = u.col.start;
+
+  n = 0;
+  list = &u.col.list;
+
+  for (ring = list->next; ring != list; ring = ring->next) {
+    colno = ring->idx;
+
+    if (cbeg[colno] != n) {
+      do {
+        colno = ring->idx;
+        i = cbeg[colno];
+        cbeg[colno] = n;
+        cmax[colno] = clen[colno];
+        j = i + clen[colno];
+
+        for (; i < j; ++i) {
+          cval[n] = cval[i];
+          cidx[n++] = cidx[i];
+        }
+
+        ring = ring->next;
+      } while (ring != list);
+
+      goto terminatePackColumns;
+    }
 
-      n += clen[colno];
+    n += clen[colno];
 
-      cmax[colno] = clen[colno];
-   }
+    cmax[colno] = clen[colno];
+  }
 
-terminatePackColumns :
+terminatePackColumns:
 
-   u.col.used = n;
-   u.col.max[thedim] = 0;
+  u.col.used = n;
+  u.col.max[thedim] = 0;
 }
 
 /*
  *      Make row of fac large enough to hold len nonzeros.
  */
-inline void CLUFactorRational::remaxRow(int p_row, int len)
-{
-   assert(u.row.max[p_row] < len);
+inline void CLUFactorRational::remaxRow(int p_row, int len) {
+  assert(u.row.max[p_row] < len);
 
-   if(u.row.elem[p_row].next == &(u.row.list))      /* last in row file */
-   {
-      int delta = len - u.row.max[p_row];
+  if (u.row.elem[p_row].next == &(u.row.list)) /* last in row file */
+  {
+    int delta = len - u.row.max[p_row];
 
-      if(delta > u.row.val.dim() - u.row.used)
-      {
-         packRows();
-         delta = len - u.row.max[p_row];  // packRows() changes u.row.max[] !
+    if (delta > u.row.val.dim() - u.row.used) {
+      packRows();
+      delta = len - u.row.max[p_row]; // packRows() changes u.row.max[] !
 
-         if(u.row.val.dim() < rowMemMult * u.row.used + len)
-            minRowMem(2 * u.row.used + len);
+      if (u.row.val.dim() < rowMemMult * u.row.used + len)
+        minRowMem(2 * u.row.used + len);
 
-         /* minRowMem(rowMemMult * u.row.used + len); */
-      }
+      /* minRowMem(rowMemMult * u.row.used + len); */
+    }
 
-      assert(delta <= u.row.val.dim() - u.row.used
+    assert(delta <= u.row.val.dim() - u.row.used
 
-             && "ERROR: could not allocate memory for row file");
+           && "ERROR: could not allocate memory for row file");
 
-      u.row.used += delta;
-      u.row.max[p_row] = len;
-   }
-   else                        /* row must be moved to end of row file */
-   {
-      int i, j, k;
-      VectorRational& val = u.row.val;
-      Dring* ring;
+    u.row.used += delta;
+    u.row.max[p_row] = len;
+  } else /* row must be moved to end of row file */
+  {
+    int i, j, k;
+    VectorRational &val = u.row.val;
+    Dring *ring;
 
-      if(len > u.row.val.dim() - u.row.used)
-      {
-         packRows();
+    if (len > u.row.val.dim() - u.row.used) {
+      packRows();
 
-         if(u.row.val.dim() < rowMemMult * u.row.used + len)
-            minRowMem(2 * u.row.used + len);
+      if (u.row.val.dim() < rowMemMult * u.row.used + len)
+        minRowMem(2 * u.row.used + len);
 
-         /* minRowMem(rowMemMult * u.row.used + len);*/
-      }
+      /* minRowMem(rowMemMult * u.row.used + len);*/
+    }
 
-      assert(len <= u.row.val.dim() - u.row.used
+    assert(len <= u.row.val.dim() - u.row.used
 
-             && "ERROR: could not allocate memory for row file");
+           && "ERROR: could not allocate memory for row file");
 
-      int* idx = u.row.idx;
-      j = u.row.used;
-      i = u.row.start[p_row];
-      k = u.row.len[p_row] + i;
-      u.row.start[p_row] = j;
-      u.row.used += len;
+    int *idx = u.row.idx;
+    j = u.row.used;
+    i = u.row.start[p_row];
+    k = u.row.len[p_row] + i;
+    u.row.start[p_row] = j;
+    u.row.used += len;
 
-      u.row.max[u.row.elem[p_row].prev->idx] += u.row.max[p_row];
-      u.row.max[p_row] = len;
-      removeDR(u.row.elem[p_row]);
-      ring = u.row.list.prev;
-      init2DR(u.row.elem[p_row], *ring);
+    u.row.max[u.row.elem[p_row].prev->idx] += u.row.max[p_row];
+    u.row.max[p_row] = len;
+    removeDR(u.row.elem[p_row]);
+    ring = u.row.list.prev;
+    init2DR(u.row.elem[p_row], *ring);
 
-      for(; i < k; ++i, ++j)
-      {
-         val[j] = val[i];
-         idx[j] = idx[i];
-      }
-   }
+    for (; i < k; ++i, ++j) {
+      val[j] = val[i];
+      idx[j] = idx[i];
+    }
+  }
 
-   assert(u.row.start[u.row.list.prev->idx] + u.row.max[u.row.list.prev->idx]
+  assert(u.row.start[u.row.list.prev->idx] + u.row.max[u.row.list.prev->idx]
 
-          == u.row.used);
+         == u.row.used);
 }
 
 /*************************************************************************/
 /*
  *      Perform garbage collection on column file
  */
-inline void CLUFactorRational::packColumns()
-{
-   int n, i, j, l_col;
-   Dring* ring, *list;
+inline void CLUFactorRational::packColumns() {
+  int n, i, j, l_col;
+  Dring *ring, *list;
 
-   int* l_cidx = u.col.idx;
-   int* l_clen = u.col.len;
-   int* l_cmax = u.col.max;
-   int* l_cbeg = u.col.start;
+  int *l_cidx = u.col.idx;
+  int *l_clen = u.col.len;
+  int *l_cmax = u.col.max;
+  int *l_cbeg = u.col.start;
 
-   n = 0;
-   list = &(u.col.list);
+  n = 0;
+  list = &(u.col.list);
 
-   for(ring = list->next; ring != list; ring = ring->next)
-   {
-      l_col = ring->idx;
+  for (ring = list->next; ring != list; ring = ring->next) {
+    l_col = ring->idx;
 
-      if(l_cbeg[l_col] != n)
-      {
-         do
-         {
-            l_col = ring->idx;
-            i = l_cbeg[l_col];
-            l_cbeg[l_col] = n;
-            l_cmax[l_col] = l_clen[l_col];
-            j = i + l_clen[l_col];
-
-            for(; i < j; ++i)
-               l_cidx[n++] = l_cidx[i];
-
-            ring = ring->next;
-         }
-         while(ring != list);
-
-         goto terminatePackColumns;
-      }
+    if (l_cbeg[l_col] != n) {
+      do {
+        l_col = ring->idx;
+        i = l_cbeg[l_col];
+        l_cbeg[l_col] = n;
+        l_cmax[l_col] = l_clen[l_col];
+        j = i + l_clen[l_col];
 
-      n += l_clen[l_col];
+        for (; i < j; ++i)
+          l_cidx[n++] = l_cidx[i];
 
-      l_cmax[l_col] = l_clen[l_col];
-   }
+        ring = ring->next;
+      } while (ring != list);
+
+      goto terminatePackColumns;
+    }
+
+    n += l_clen[l_col];
 
-terminatePackColumns :
+    l_cmax[l_col] = l_clen[l_col];
+  }
 
-   u.col.used = n;
-   u.col.max[thedim] = 0;
+terminatePackColumns:
+
+  u.col.used = n;
+  u.col.max[thedim] = 0;
 }
 
 /*
  *      Make column col of fac large enough to hold len nonzeros.
  */
-inline void CLUFactorRational::remaxCol(int p_col, int len)
-{
-   assert(u.col.max[p_col] < len);
+inline void CLUFactorRational::remaxCol(int p_col, int len) {
+  assert(u.col.max[p_col] < len);
 
-   if(u.col.elem[p_col].next == &(u.col.list))      /* last in column file */
-   {
-      int delta = len - u.col.max[p_col];
+  if (u.col.elem[p_col].next == &(u.col.list)) /* last in column file */
+  {
+    int delta = len - u.col.max[p_col];
 
-      if(delta > u.col.size - u.col.used)
-      {
-         packColumns();
-         delta = len - u.col.max[p_col];
+    if (delta > u.col.size - u.col.used) {
+      packColumns();
+      delta = len - u.col.max[p_col];
 
-         if(u.col.size < colMemMult * u.col.used + len)
-            minColMem(2 * u.col.used + len);
+      if (u.col.size < colMemMult * u.col.used + len)
+        minColMem(2 * u.col.used + len);
 
-         /* minColMem(colMemMult * u.col.used + len); */
-      }
+      /* minColMem(colMemMult * u.col.used + len); */
+    }
 
-      assert(delta <= u.col.size - u.col.used
+    assert(delta <= u.col.size - u.col.used
 
-             && "ERROR: could not allocate memory for column file");
+           && "ERROR: could not allocate memory for column file");
 
-      u.col.used += delta;
-      u.col.max[p_col] = len;
-   }
+    u.col.used += delta;
+    u.col.max[p_col] = len;
+  }
 
-   else                        /* column must be moved to end of column file */
-   {
-      int i, j, k;
-      int* idx;
-      Dring* ring;
+  else /* column must be moved to end of column file */
+  {
+    int i, j, k;
+    int *idx;
+    Dring *ring;
 
-      if(len > u.col.size - u.col.used)
-      {
-         packColumns();
+    if (len > u.col.size - u.col.used) {
+      packColumns();
 
-         if(u.col.size < colMemMult * u.col.used + len)
-            minColMem(2 * u.col.used + len);
+      if (u.col.size < colMemMult * u.col.used + len)
+        minColMem(2 * u.col.used + len);
 
-         /* minColMem(colMemMult * u.col.used + len); */
-      }
+      /* minColMem(colMemMult * u.col.used + len); */
+    }
 
-      assert(len <= u.col.size - u.col.used
+    assert(len <= u.col.size - u.col.used
 
-             && "ERROR: could not allocate memory for column file");
+           && "ERROR: could not allocate memory for column file");
 
-      j = u.col.used;
-      i = u.col.start[p_col];
-      k = u.col.len[p_col] + i;
-      u.col.start[p_col] = j;
-      u.col.used += len;
+    j = u.col.used;
+    i = u.col.start[p_col];
+    k = u.col.len[p_col] + i;
+    u.col.start[p_col] = j;
+    u.col.used += len;
 
-      u.col.max[u.col.elem[p_col].prev->idx] += u.col.max[p_col];
-      u.col.max[p_col] = len;
-      removeDR(u.col.elem[p_col]);
-      ring = u.col.list.prev;
-      init2DR(u.col.elem[p_col], *ring);
+    u.col.max[u.col.elem[p_col].prev->idx] += u.col.max[p_col];
+    u.col.max[p_col] = len;
+    removeDR(u.col.elem[p_col]);
+    ring = u.col.list.prev;
+    init2DR(u.col.elem[p_col], *ring);
 
-      idx = u.col.idx;
+    idx = u.col.idx;
 
-      for(; i < k; ++i)
-         idx[j++] = idx[i];
-   }
+    for (; i < k; ++i)
+      idx[j++] = idx[i];
+  }
 }
 
 /*
  *      Make column col of fac large enough to hold len nonzeros.
  */
-inline void CLUFactorRational::forestReMaxCol(int p_col, int len)
-{
-   assert(u.col.max[p_col] < len);
+inline void CLUFactorRational::forestReMaxCol(int p_col, int len) {
+  assert(u.col.max[p_col] < len);
 
-   if(u.col.elem[p_col].next == &(u.col.list))      /* last in column file */
-   {
-      int delta = len - u.col.max[p_col];
+  if (u.col.elem[p_col].next == &(u.col.list)) /* last in column file */
+  {
+    int delta = len - u.col.max[p_col];
 
-      if(delta > u.col.size - u.col.used)
-      {
-         forestPackColumns();
-         delta = len - u.col.max[p_col];
+    if (delta > u.col.size - u.col.used) {
+      forestPackColumns();
+      delta = len - u.col.max[p_col];
 
-         if(u.col.size < colMemMult * u.col.used + len)
-            forestMinColMem(int(colMemMult * u.col.used + len));
-      }
+      if (u.col.size < colMemMult * u.col.used + len)
+        forestMinColMem(int(colMemMult * u.col.used + len));
+    }
 
-      assert(delta <= u.col.size - u.col.used
+    assert(delta <= u.col.size - u.col.used
 
-             && "ERROR: could not allocate memory for column file");
+           && "ERROR: could not allocate memory for column file");
 
-      u.col.used += delta;
-      u.col.max[p_col] = len;
-   }
+    u.col.used += delta;
+    u.col.max[p_col] = len;
+  }
 
-   else                        /* column must be moved to end of column file */
-   {
-      int i, j, k;
-      int* idx = u.col.idx;
-      VectorRational& val = u.col.val;
-      Dring* ring;
+  else /* column must be moved to end of column file */
+  {
+    int i, j, k;
+    int *idx = u.col.idx;
+    VectorRational &val = u.col.val;
+    Dring *ring;
 
-      if(len > u.col.size - u.col.used)
-      {
-         forestPackColumns();
+    if (len > u.col.size - u.col.used) {
+      forestPackColumns();
 
-         if(u.col.size < colMemMult * u.col.used + len)
-            forestMinColMem(int(colMemMult * u.col.used + len));
-      }
+      if (u.col.size < colMemMult * u.col.used + len)
+        forestMinColMem(int(colMemMult * u.col.used + len));
+    }
 
-      assert(len <= u.col.size - u.col.used
+    assert(len <= u.col.size - u.col.used
 
-             && "ERROR: could not allocate memory for column file");
+           && "ERROR: could not allocate memory for column file");
 
-      j = u.col.used;
-      i = u.col.start[p_col];
-      k = u.col.len[p_col] + i;
-      u.col.start[p_col] = j;
-      u.col.used += len;
+    j = u.col.used;
+    i = u.col.start[p_col];
+    k = u.col.len[p_col] + i;
+    u.col.start[p_col] = j;
+    u.col.used += len;
 
-      u.col.max[u.col.elem[p_col].prev->idx] += u.col.max[p_col];
-      u.col.max[p_col] = len;
-      removeDR(u.col.elem[p_col]);
-      ring = u.col.list.prev;
-      init2DR(u.col.elem[p_col], *ring);
+    u.col.max[u.col.elem[p_col].prev->idx] += u.col.max[p_col];
+    u.col.max[p_col] = len;
+    removeDR(u.col.elem[p_col]);
+    ring = u.col.list.prev;
+    init2DR(u.col.elem[p_col], *ring);
 
-      for(; i < k; ++i)
-      {
-         val[j] = val[i];
-         idx[j++] = idx[i];
-      }
-   }
+    for (; i < k; ++i) {
+      val[j] = val[i];
+      idx[j++] = idx[i];
+    }
+  }
 }
 
 /*****************************************************************************/
@@ -671,677 +592,631 @@ inline void CLUFactorRational::forestReMaxCol(int p_col, int len)
 /**
  *   \brief Performs the Forrest-Tomlin update of the LU factorization.
  *
- *   BH: I suppose this is implemented as described in UH Suhl, LM Suhl: A fast LU
- *       update for linear programming, Annals of OR 43, p. 33-47, 1993.
+ *   BH: I suppose this is implemented as described in UH Suhl, LM Suhl: A fast
+ * LU update for linear programming, Annals of OR 43, p. 33-47, 1993.
  *
  *   @param  p_col      Index of basis column to replace.
  *   @param  p_work     Dense vector to substitute in the basis.
  *   @param  num        Number of nonzeros in vector represented by p_work.
  *   @param  nonz       Indices of nonzero elements in vector p_work.
  *
- *   The parameters num and nonz are used for the following optimization: If both
- *   are nonzero, indices of the nonzero elements provided in nonz (num giving
- *   their number) allow to access only those nonzero entries.  Otherwise we have
- *   to go through the entire dense vector element by element.
+ *   The parameters num and nonz are used for the following optimization: If
+ * both are nonzero, indices of the nonzero elements provided in nonz (num
+ * giving their number) allow to access only those nonzero entries.  Otherwise
+ * we have to go through the entire dense vector element by element.
  *
  *   After copying p_work into U, p_work is used to expand the row r, which is
  *   needed to restore the triangular structure of U.
  *
  *   Also num and nonz are used to maintain a heap if there are only very few
- *   nonzeros to be eliminated. This is plainly wrong if the method is called with
- *   nonz==0, see todo at the corresponding place below.
+ *   nonzeros to be eliminated. This is plainly wrong if the method is called
+ * with nonz==0, see todo at the corresponding place below.
  *
  *   @throw SPxStatusException if the loaded matrix is singular
  *
  *   @todo Use an extra member variable as a buffer for working with the dense
- *         row instead of misusing p_work. I think that should be as efficient and
- *         much cleaner.
+ *         row instead of misusing p_work. I think that should be as efficient
+ * and much cleaner.
  */
 
-inline void CLUFactorRational::forestUpdate(int p_col, Rational* p_work, int num, int* nonz)
-{
-   int i, j, k, h, m, n;
-   int ll, c, r, rowno;
-   Rational x;
-
-   int* lbeg = l.start;
-
-   VectorRational& cval = u.col.val;
-   int* cidx = u.col.idx;
-   int* cmax = u.col.max;
-   int* clen = u.col.len;
-   int* cbeg = u.col.start;
-
-   VectorRational& rval = u.row.val;
-   int* ridx = u.row.idx;
-   int* rmax = u.row.max;
-   int* rlen = u.row.len;
-   int* rbeg = u.row.start;
-
-   int* rperm = row.perm;
-   int* rorig = row.orig;
-   int* cperm = col.perm;
-   int* corig = col.orig;
-
-   Rational l_maxabs = maxabs;
-   int dim = thedim;
+inline void CLUFactorRational::forestUpdate(int p_col, Rational *p_work,
+                                            int num, int *nonz) {
+  int i, j, k, h, m, n;
+  int ll, c, r, rowno;
+  Rational x;
 
-   /*  Remove column p_col from U
-    */
-   j = cbeg[p_col];
-   i = clen[p_col];
-   nzCnt -= i;
+  int *lbeg = l.start;
 
-   for(i += j - 1; i >= j; --i)
-   {
-      m = cidx[i];          // remove column p_col from row m
-      k = rbeg[m];
-      h = --(rlen[m]) + k;    // decrease length of row m
+  VectorRational &cval = u.col.val;
+  int *cidx = u.col.idx;
+  int *cmax = u.col.max;
+  int *clen = u.col.len;
+  int *cbeg = u.col.start;
 
-      while(ridx[k] != p_col)
-         ++k;
+  VectorRational &rval = u.row.val;
+  int *ridx = u.row.idx;
+  int *rmax = u.row.max;
+  int *rlen = u.row.len;
+  int *rbeg = u.row.start;
 
-      assert(k <= h);       // k is the position of p_col, h is last position
+  int *rperm = row.perm;
+  int *rorig = row.orig;
+  int *cperm = col.perm;
+  int *corig = col.orig;
 
-      ridx[k] = ridx[h];    // store last index at the position of p_col
+  Rational l_maxabs = maxabs;
+  int dim = thedim;
 
-      rval[k] = rval[h];
-   }
-
-   /*  Insert new vector column p_col thereby determining the highest permuted
-    *       row index r.
-    *
-    *       Distinguish between optimized call (num > 0, nonz != 0) and
-    *       non-optimized one.
-    */
-   assert(num);   // otherwise the assert( nonz != 0 ) below should fail
-
-   if(num)
-   {
-      // Optimized call.
-      assert(nonz != 0);
-
-      clen[p_col] = 0;
+  /*  Remove column p_col from U
+   */
+  j = cbeg[p_col];
+  i = clen[p_col];
+  nzCnt -= i;
 
-      if(num > cmax[p_col])
-         forestReMaxCol(p_col, num);
+  for (i += j - 1; i >= j; --i) {
+    m = cidx[i]; // remove column p_col from row m
+    k = rbeg[m];
+    h = --(rlen[m]) + k; // decrease length of row m
 
-      cidx = u.col.idx;
+    while (ridx[k] != p_col)
+      ++k;
 
-      cval = u.col.val;
+    assert(k <= h); // k is the position of p_col, h is last position
 
-      k = cbeg[p_col];
+    ridx[k] = ridx[h]; // store last index at the position of p_col
 
-      r = 0;
+    rval[k] = rval[h];
+  }
 
-      for(j = 0; j < num; ++j)
-      {
-         i = nonz[j];
-         x = p_work[i];
-         p_work[i] = 0;
-
-         if(x != 0)
-         {
-            if(spxAbs(x) > l_maxabs)
-               l_maxabs = spxAbs(x);
+  /*  Insert new vector column p_col thereby determining the highest permuted
+   *       row index r.
+   *
+   *       Distinguish between optimized call (num > 0, nonz != 0) and
+   *       non-optimized one.
+   */
+  assert(num); // otherwise the assert( nonz != 0 ) below should fail
 
-            /* insert to column file */
-            assert(k - cbeg[p_col] < cmax[p_col]);
+  if (num) {
+    // Optimized call.
+    assert(nonz != 0);
 
-            cval[k] = x;
+    clen[p_col] = 0;
 
-            cidx[k++] = i;
-
-            /* insert to row file */
-            if(rmax[i] <= rlen[i])
-            {
-               remaxRow(i, rlen[i] + 1);
-               rval = u.row.val;
-               ridx = u.row.idx;
-            }
+    if (num > cmax[p_col])
+      forestReMaxCol(p_col, num);
 
-            h = rbeg[i] + (rlen[i])++;
+    cidx = u.col.idx;
 
-            rval[h] = x;
-            ridx[h] = p_col;
+    cval = u.col.val;
 
-            /* check permuted row index */
+    k = cbeg[p_col];
 
-            if(rperm[i] > r)
-               r = rperm[i];
-         }
-      }
+    r = 0;
 
-      nzCnt += (clen[p_col] = k - cbeg[p_col]);
-   }
-   else
-   {
-      // Non-optimized call: We have to access all elements of p_work.
-      assert(nonz == 0);
-
-      /*
-       *      clen[col] = 0;
-       *      reMaxCol(fac, col, dim);
-       */
-      cidx = u.col.idx;
-      cval = u.col.val;
-      k = cbeg[p_col];
-      j = k + cmax[p_col];
-      r = 0;
+    for (j = 0; j < num; ++j) {
+      i = nonz[j];
+      x = p_work[i];
+      p_work[i] = 0;
 
-      for(i = 0; i < dim; ++i)
-      {
-         x = p_work[i];
-         p_work[i] = 0;
-
-         if(x != 0)
-         {
-            if(spxAbs(x) > l_maxabs)
-               l_maxabs = spxAbs(x);
-
-            /* insert to column file */
-            if(k >= j)
-            {
-               clen[p_col] = k - cbeg[p_col];
-               forestReMaxCol(p_col, dim - i);
-               cidx = u.col.idx;
-               cval = u.col.val;
-               k = cbeg[p_col];
-               j = k + cmax[p_col];
-               k += clen[p_col];
-            }
+      if (x != 0) {
+        if (spxAbs(x) > l_maxabs)
+          l_maxabs = spxAbs(x);
 
-            assert(k - cbeg[p_col] < cmax[p_col]);
+        /* insert to column file */
+        assert(k - cbeg[p_col] < cmax[p_col]);
 
-            cval[k] = x;
-            cidx[k++] = i;
+        cval[k] = x;
 
-            /* insert to row file */
+        cidx[k++] = i;
 
-            if(rmax[i] <= rlen[i])
-            {
-               remaxRow(i, rlen[i] + 1);
-               rval = u.row.val;
-               ridx = u.row.idx;
-            }
+        /* insert to row file */
+        if (rmax[i] <= rlen[i]) {
+          remaxRow(i, rlen[i] + 1);
+          rval = u.row.val;
+          ridx = u.row.idx;
+        }
 
-            h = rbeg[i] + (rlen[i])++;
+        h = rbeg[i] + (rlen[i])++;
 
-            rval[h] = x;
-            ridx[h] = p_col;
+        rval[h] = x;
+        ridx[h] = p_col;
 
-            /* check permuted row index */
+        /* check permuted row index */
 
-            if(rperm[i] > r)
-               r = rperm[i];
-         }
+        if (rperm[i] > r)
+          r = rperm[i];
       }
+    }
 
-      nzCnt += (clen[p_col] = k - cbeg[p_col]);
-
-      if(cbeg[p_col] + cmax[p_col] == u.col.used)
-      {
-         u.col.used -= cmax[p_col];
-         cmax[p_col] = clen[p_col];
-         u.col.used += cmax[p_col];
+    nzCnt += (clen[p_col] = k - cbeg[p_col]);
+  } else {
+    // Non-optimized call: We have to access all elements of p_work.
+    assert(nonz == 0);
+
+    /*
+     *      clen[col] = 0;
+     *      reMaxCol(fac, col, dim);
+     */
+    cidx = u.col.idx;
+    cval = u.col.val;
+    k = cbeg[p_col];
+    j = k + cmax[p_col];
+    r = 0;
+
+    for (i = 0; i < dim; ++i) {
+      x = p_work[i];
+      p_work[i] = 0;
+
+      if (x != 0) {
+        if (spxAbs(x) > l_maxabs)
+          l_maxabs = spxAbs(x);
+
+        /* insert to column file */
+        if (k >= j) {
+          clen[p_col] = k - cbeg[p_col];
+          forestReMaxCol(p_col, dim - i);
+          cidx = u.col.idx;
+          cval = u.col.val;
+          k = cbeg[p_col];
+          j = k + cmax[p_col];
+          k += clen[p_col];
+        }
+
+        assert(k - cbeg[p_col] < cmax[p_col]);
+
+        cval[k] = x;
+        cidx[k++] = i;
+
+        /* insert to row file */
+
+        if (rmax[i] <= rlen[i]) {
+          remaxRow(i, rlen[i] + 1);
+          rval = u.row.val;
+          ridx = u.row.idx;
+        }
+
+        h = rbeg[i] + (rlen[i])++;
+
+        rval[h] = x;
+        ridx[h] = p_col;
+
+        /* check permuted row index */
+
+        if (rperm[i] > r)
+          r = rperm[i];
       }
-   }
+    }
 
-   c = cperm[p_col];
+    nzCnt += (clen[p_col] = k - cbeg[p_col]);
 
-   if(r > c)                          /* Forest Tomlin update */
-   {
-      /*      update permutations
-       */
-      j = rorig[c];
+    if (cbeg[p_col] + cmax[p_col] == u.col.used) {
+      u.col.used -= cmax[p_col];
+      cmax[p_col] = clen[p_col];
+      u.col.used += cmax[p_col];
+    }
+  }
 
-      // memmove is more efficient than a for loop
-      // for ( i = c; i < r; ++i )
-      //    rorig[i] = rorig[i + 1];
-      memmove(&rorig[c], &rorig[c + 1], (unsigned int)(r - c) * sizeof(int));
+  c = cperm[p_col];
 
-      rorig[r] = j;
+  if (r > c) /* Forest Tomlin update */
+  {
+    /*      update permutations
+     */
+    j = rorig[c];
 
-      for(i = c; i <= r; ++i)
-         rperm[rorig[i]] = i;
+    // memmove is more efficient than a for loop
+    // for ( i = c; i < r; ++i )
+    //    rorig[i] = rorig[i + 1];
+    memmove(&rorig[c], &rorig[c + 1], (unsigned int)(r - c) * sizeof(int));
 
-      j = corig[c];
+    rorig[r] = j;
 
-      // memmove is more efficient than a for loop
-      // for ( i = c; i < r; ++i )
-      //    corig[i] = corig[i + 1];
-      memmove(&corig[c], &corig[c + 1], (unsigned int)(r - c) * sizeof(int));
+    for (i = c; i <= r; ++i)
+      rperm[rorig[i]] = i;
 
-      corig[r] = j;
+    j = corig[c];
 
-      for(i = c; i <= r; ++i)
-         cperm[corig[i]] = i;
+    // memmove is more efficient than a for loop
+    // for ( i = c; i < r; ++i )
+    //    corig[i] = corig[i + 1];
+    memmove(&corig[c], &corig[c + 1], (unsigned int)(r - c) * sizeof(int));
 
+    corig[r] = j;
 
-      rowno = rorig[r];
+    for (i = c; i <= r; ++i)
+      cperm[corig[i]] = i;
 
-      j = rbeg[rowno];
+    rowno = rorig[r];
 
-      i = rlen[rowno];
+    j = rbeg[rowno];
 
-      nzCnt -= i;
+    i = rlen[rowno];
 
-      if(i < verySparseFactorRat * (dim - c))      // few nonzeros to be eliminated
-      {
-         /**
-          *          The following assert is obviously violated if this method is called
-          *          with nonzero==0.
-          *
-          *          @todo Use an extra member variable as a buffer for the heap instead of
-          *                misusing nonz and num. The method enQueueMinRat() seems to
-          *                sort the nonzeros or something, for which it only needs
-          *                some empty vector of size num.
-          */
-         assert(nonz != 0);
+    nzCnt -= i;
 
-         /*  move row r from U to p_work
-          */
-         num = 0;
+    if (i < verySparseFactorRat * (dim - c)) // few nonzeros to be eliminated
+    {
+      /**
+       *          The following assert is obviously violated if this method is
+       * called with nonzero==0.
+       *
+       *          @todo Use an extra member variable as a buffer for the heap
+       * instead of misusing nonz and num. The method enQueueMinRat() seems to
+       *                sort the nonzeros or something, for which it only needs
+       *                some empty vector of size num.
+       */
+      assert(nonz != 0);
 
-         for(i += j - 1; i >= j; --i)
-         {
-            k = ridx[i];
-            p_work[k] = rval[i];
-            enQueueMinRat(nonz, &num, cperm[k]);
-            m = --(clen[k]) + cbeg[k];
+      /*  move row r from U to p_work
+       */
+      num = 0;
 
-            for(h = m; cidx[h] != rowno; --h)
-               ;
+      for (i += j - 1; i >= j; --i) {
+        k = ridx[i];
+        p_work[k] = rval[i];
+        enQueueMinRat(nonz, &num, cperm[k]);
+        m = --(clen[k]) + cbeg[k];
 
-            cidx[h] = cidx[m];
+        for (h = m; cidx[h] != rowno; --h)
+          ;
 
-            cval[h] = cval[m];
-         }
+        cidx[h] = cidx[m];
 
+        cval[h] = cval[m];
+      }
 
-         /*  Eliminate row r from U to L file
-          */
-         ll = makeLvec(r - c, rowno);
+      /*  Eliminate row r from U to L file
+       */
+      ll = makeLvec(r - c, rowno);
 
-         VectorRational& lval = l.val;
-         int* lidx = l.idx;
+      VectorRational &lval = l.val;
+      int *lidx = l.idx;
 
-         assert((num == 0) || (nonz != 0));
+      assert((num == 0) || (nonz != 0));
 
-         /* for(i = c; i < r; ++i)       */
-         while(num)
-         {
+      /* for(i = c; i < r; ++i)       */
+      while (num) {
 #ifndef NDEBUG
-            // The numbers seem to be often 1e-100, is this ok ?
+        // The numbers seem to be often 1e-100, is this ok ?
 
-            for(i = 0; i < num; ++i)
-               assert(p_work[corig[nonz[i]]] != 0);
+        for (i = 0; i < num; ++i)
+          assert(p_work[corig[nonz[i]]] != 0);
 
 #endif // NDEBUG
-            i = deQueueMinRat(nonz, &num);
+        i = deQueueMinRat(nonz, &num);
 
-            if(i == r)
-               break;
+        if (i == r)
+          break;
 
-            k = corig[i];
+        k = corig[i];
 
-            assert(p_work[k] != 0);
+        assert(p_work[k] != 0);
 
-            n = rorig[i];
+        n = rorig[i];
 
-            x = p_work[k] * diag[n];
+        x = p_work[k] * diag[n];
 
-            lidx[ll] = n;
+        lidx[ll] = n;
 
-            lval[ll] = x;
+        lval[ll] = x;
 
-            p_work[k] = 0;
+        p_work[k] = 0;
 
-            ll++;
+        ll++;
 
-            if(spxAbs(x) > l_maxabs)
-               l_maxabs = spxAbs(x);
+        if (spxAbs(x) > l_maxabs)
+          l_maxabs = spxAbs(x);
 
-            j = rbeg[n];
+        j = rbeg[n];
 
-            m = rlen[n] + j;
+        m = rlen[n] + j;
 
-            for(; j < m; ++j)
-            {
-               int jj = ridx[j];
-               Rational y = p_work[jj];
+        for (; j < m; ++j) {
+          int jj = ridx[j];
+          Rational y = p_work[jj];
 
-               if(y == 0)
-                  enQueueMinRat(nonz, &num, cperm[jj]);
+          if (y == 0)
+            enQueueMinRat(nonz, &num, cperm[jj]);
 
-               y -= x * rval[j];
+          y -= x * rval[j];
 
-               //p_work[jj] = y + (( y == 0 ) ? MARKER : 0 );
-               p_work[jj] = y;
-            }
-         }
+          // p_work[jj] = y + (( y == 0 ) ? MARKER : 0 );
+          p_work[jj] = y;
+        }
+      }
 
-         if(lbeg[l.firstUnused - 1] == ll)
-            (l.firstUnused)--;
-         else
-            lbeg[l.firstUnused] = ll;
+      if (lbeg[l.firstUnused - 1] == ll)
+        (l.firstUnused)--;
+      else
+        lbeg[l.firstUnused] = ll;
 
+      /*  Set diagonal value
+       */
+      if (i != r) {
+        stat = SLinSolverRational::SINGULAR;
+        throw SPxStatusException("XFORE01 The loaded matrix is singular");
+      }
 
-         /*  Set diagonal value
-          */
-         if(i != r)
-         {
-            stat = SLinSolverRational::SINGULAR;
-            throw SPxStatusException("XFORE01 The loaded matrix is singular");
-         }
+      k = corig[r];
 
-         k = corig[r];
+      x = p_work[k];
+      diag[rowno] = 1 / x;
+      p_work[k] = 0;
 
-         x = p_work[k];
-         diag[rowno] = 1 / x;
-         p_work[k] = 0;
+      /*  make row large enough to fit all nonzeros.
+       */
 
+      if (rmax[rowno] < num) {
+        rlen[rowno] = 0;
+        remaxRow(rowno, num);
+        rval = u.row.val;
+        ridx = u.row.idx;
+      }
 
-         /*  make row large enough to fit all nonzeros.
-          */
+      nzCnt += num;
 
-         if(rmax[rowno] < num)
-         {
-            rlen[rowno] = 0;
-            remaxRow(rowno, num);
-            rval = u.row.val;
-            ridx = u.row.idx;
-         }
+      /*  Insert work to updated row thereby clearing work;
+       */
+      n = rbeg[rowno];
 
-         nzCnt += num;
+      for (i = 0; i < num; ++i) {
+        j = corig[nonz[i]];
+        x = p_work[j];
 
-         /*  Insert work to updated row thereby clearing work;
-          */
-         n = rbeg[rowno];
+        // BH 2005-08-24: This if is very important. It may well happen that
+        // during the elimination of row r a nonzero elements cancels out
+        // and becomes zero. This would lead to an infinite loop in the
+        // above elimination code, since the corresponding column index would
+        // be enqueued for further elimination again and agian.
 
-         for(i = 0; i < num; ++i)
-         {
-            j = corig[nonz[i]];
-            x = p_work[j];
+        if (x != 0) {
+          if (spxAbs(x) > l_maxabs)
+            l_maxabs = spxAbs(x);
 
-            // BH 2005-08-24: This if is very important. It may well happen that
-            // during the elimination of row r a nonzero elements cancels out
-            // and becomes zero. This would lead to an infinite loop in the
-            // above elimination code, since the corresponding column index would
-            // be enqueued for further elimination again and agian.
+          ridx[n] = j;
 
-            if(x != 0)
-            {
-               if(spxAbs(x) > l_maxabs)
-                  l_maxabs = spxAbs(x);
+          rval[n] = x;
 
-               ridx[n] = j;
+          p_work[j] = 0;
 
-               rval[n] = x;
+          ++n;
 
-               p_work[j] = 0;
+          if (clen[j] >= cmax[j]) {
+            forestReMaxCol(j, clen[j] + 1);
+            cidx = u.col.idx;
+            cval = u.col.val;
+          }
 
-               ++n;
+          cval[cbeg[j] + clen[j]] = x;
 
-               if(clen[j] >= cmax[j])
-               {
-                  forestReMaxCol(j, clen[j] + 1);
-                  cidx = u.col.idx;
-                  cval = u.col.val;
-               }
+          cidx[cbeg[j] + clen[j]++] = rowno;
+        }
+      }
 
-               cval[cbeg[j] + clen[j]] = x;
+      rlen[rowno] = n - rbeg[rowno];
+    } else /* few nonzeros to be eliminated        */
+    {
+      /*  move row r from U to p_work
+       */
+      for (i += j - 1; i >= j; --i) {
+        k = ridx[i];
+        p_work[k] = rval[i];
+        m = --(clen[k]) + cbeg[k];
 
-               cidx[cbeg[j] + clen[j]++] = rowno;
-            }
-         }
+        for (h = m; cidx[h] != rowno; --h)
+          ;
 
-         rlen[rowno] = n - rbeg[rowno];
-      }
-      else            /* few nonzeros to be eliminated        */
-      {
-         /*  move row r from U to p_work
-          */
-         for(i += j - 1; i >= j; --i)
-         {
-            k = ridx[i];
-            p_work[k] = rval[i];
-            m = --(clen[k]) + cbeg[k];
+        cidx[h] = cidx[m];
 
-            for(h = m; cidx[h] != rowno; --h)
-               ;
+        cval[h] = cval[m];
+      }
 
-            cidx[h] = cidx[m];
+      /*  Eliminate row r from U to L file
+       */
+      ll = makeLvec(r - c, rowno);
 
-            cval[h] = cval[m];
-         }
+      VectorRational &lval = l.val;
+      int *lidx = l.idx;
 
+      for (i = c; i < r; ++i) {
+        k = corig[i];
 
-         /*  Eliminate row r from U to L file
-          */
-         ll = makeLvec(r - c, rowno);
+        if (p_work[k] != 0) {
+          n = rorig[i];
+          x = p_work[k] * diag[n];
+          lidx[ll] = n;
+          lval[ll] = x;
+          p_work[k] = 0;
+          ll++;
 
-         VectorRational& lval = l.val;
-         int* lidx = l.idx;
+          if (spxAbs(x) > l_maxabs)
+            l_maxabs = spxAbs(x);
 
-         for(i = c; i < r; ++i)
-         {
-            k = corig[i];
+          j = rbeg[n];
 
-            if(p_work[k] != 0)
-            {
-               n = rorig[i];
-               x = p_work[k] * diag[n];
-               lidx[ll] = n;
-               lval[ll] = x;
-               p_work[k] = 0;
-               ll++;
+          m = rlen[n] + j;
 
-               if(spxAbs(x) > l_maxabs)
-                  l_maxabs = spxAbs(x);
+          for (; j < m; ++j)
+            p_work[ridx[j]] -= x * rval[j];
+        }
+      }
 
-               j = rbeg[n];
+      if (lbeg[l.firstUnused - 1] == ll)
+        (l.firstUnused)--;
+      else
+        lbeg[l.firstUnused] = ll;
 
-               m = rlen[n] + j;
+      /*  Set diagonal value
+       */
+      k = corig[r];
 
-               for(; j < m; ++j)
-                  p_work[ridx[j]] -= x * rval[j];
-            }
-         }
+      x = p_work[k];
 
-         if(lbeg[l.firstUnused - 1] == ll)
-            (l.firstUnused)--;
-         else
-            lbeg[l.firstUnused] = ll;
+      if (x == 0) {
+        stat = SLinSolverRational::SINGULAR;
+        throw SPxStatusException("XFORE02 The loaded matrix is singular");
+        //            return;
+      }
 
+      diag[rowno] = 1 / x;
 
-         /*  Set diagonal value
-          */
-         k = corig[r];
+      p_work[k] = 0;
 
-         x = p_work[k];
+      /*  count remaining nonzeros in work and make row large enough
+       *  to fit them all.
+       */
+      n = 0;
 
-         if(x == 0)
-         {
-            stat = SLinSolverRational::SINGULAR;
-            throw SPxStatusException("XFORE02 The loaded matrix is singular");
-            //            return;
-         }
+      for (i = r + 1; i < dim; ++i)
+        if (p_work[corig[i]] != 0)
+          n++;
 
-         diag[rowno] = 1 / x;
+      if (rmax[rowno] < n) {
+        rlen[rowno] = 0;
+        remaxRow(rowno, n);
+        rval = u.row.val;
+        ridx = u.row.idx;
+      }
 
-         p_work[k] = 0;
+      nzCnt += n;
 
+      /*  Insert p_work to updated row thereby clearing p_work;
+       */
+      n = rbeg[rowno];
 
-         /*  count remaining nonzeros in work and make row large enough
-          *  to fit them all.
-          */
-         n = 0;
+      for (i = r + 1; i < dim; ++i) {
+        j = corig[i];
+        x = p_work[j];
 
-         for(i = r + 1; i < dim; ++i)
-            if(p_work[corig[i]] != 0)
-               n++;
+        if (x != 0) {
+          if (spxAbs(x) > l_maxabs)
+            l_maxabs = spxAbs(x);
 
-         if(rmax[rowno] < n)
-         {
-            rlen[rowno] = 0;
-            remaxRow(rowno, n);
-            rval = u.row.val;
-            ridx = u.row.idx;
-         }
+          ridx[n] = j;
 
-         nzCnt += n;
+          rval[n] = x;
 
-         /*  Insert p_work to updated row thereby clearing p_work;
-          */
-         n = rbeg[rowno];
+          p_work[j] = 0;
 
-         for(i = r + 1; i < dim; ++i)
-         {
-            j = corig[i];
-            x = p_work[j];
+          ++n;
 
-            if(x != 0)
-            {
-               if(spxAbs(x) > l_maxabs)
-                  l_maxabs = spxAbs(x);
+          if (clen[j] >= cmax[j]) {
+            forestReMaxCol(j, clen[j] + 1);
+            cidx = u.col.idx;
+            cval = u.col.val;
+          }
 
-               ridx[n] = j;
+          cval[cbeg[j] + clen[j]] = x;
 
-               rval[n] = x;
+          cidx[cbeg[j] + clen[j]++] = rowno;
+        }
+      }
 
-               p_work[j] = 0;
+      rlen[rowno] = n - rbeg[rowno];
+    }
+  }
 
-               ++n;
+  else if (r == c) {
+    /*  Move diagonal element to diag.  Note, that it must be the last
+     *  element, since it has just been inserted above.
+     */
+    rowno = rorig[r];
+    i = rbeg[rowno] + --(rlen[rowno]);
+    diag[rowno] = 1 / rval[i];
 
-               if(clen[j] >= cmax[j])
-               {
-                  forestReMaxCol(j, clen[j] + 1);
-                  cidx = u.col.idx;
-                  cval = u.col.val;
-               }
+    for (j = i = --(clen[p_col]) + cbeg[p_col]; cidx[i] != rowno; --i)
+      ;
 
-               cval[cbeg[j] + clen[j]] = x;
+    cidx[i] = cidx[j];
 
-               cidx[cbeg[j] + clen[j]++] = rowno;
-            }
-         }
+    cval[i] = cval[j];
+  } else /* r < c */
+  {
+    stat = SLinSolverRational::SINGULAR;
+    throw SPxStatusException("XFORE03 The loaded matrix is singular");
+    //      return;
+  }
 
-         rlen[rowno] = n - rbeg[rowno];
-      }
-   }
+  maxabs = l_maxabs;
 
-   else if(r == c)
-   {
-      /*  Move diagonal element to diag.  Note, that it must be the last
-       *  element, since it has just been inserted above.
-       */
-      rowno = rorig[r];
-      i = rbeg[rowno] + --(rlen[rowno]);
-      diag[rowno] = 1 / rval[i];
+  assert(isConsistent());
+  stat = SLinSolverRational::OK;
+}
 
-      for(j = i = --(clen[p_col]) + cbeg[p_col]; cidx[i] != rowno; --i)
-         ;
+inline void CLUFactorRational::update(int p_col, Rational *p_work,
+                                      const int *p_idx, int num) {
+  int ll, i, j;
+  Rational x, rezi;
 
-      cidx[i] = cidx[j];
+  assert(p_work[p_col] != 0);
+  rezi = 1 / p_work[p_col];
+  p_work[p_col] = 0;
 
-      cval[i] = cval[j];
-   }
-   else /* r < c */
-   {
-      stat = SLinSolverRational::SINGULAR;
-      throw SPxStatusException("XFORE03 The loaded matrix is singular");
-      //      return;
-   }
+  ll = makeLvec(num, p_col);
+  //   ll = fac->makeLvec(num, col);
+  VectorRational &lval = l.val;
+  int *lidx = l.idx;
 
-   maxabs = l_maxabs;
+  for (i = num - 1; (j = p_idx[i]) != p_col; --i) {
+    lidx[ll] = j;
+    lval[ll] = rezi * p_work[j];
+    p_work[j] = 0;
+    ++ll;
+  }
 
-   assert(isConsistent());
-   stat = SLinSolverRational::OK;
-}
+  lidx[ll] = p_col;
 
-inline void CLUFactorRational::update(int p_col, Rational* p_work, const int* p_idx, int num)
-{
-   int ll, i, j;
-   Rational x, rezi;
-
-   assert(p_work[p_col] != 0);
-   rezi = 1 / p_work[p_col];
-   p_work[p_col] = 0;
-
-   ll = makeLvec(num, p_col);
-   //   ll = fac->makeLvec(num, col);
-   VectorRational& lval = l.val;
-   int* lidx = l.idx;
-
-   for(i = num - 1; (j = p_idx[i]) != p_col; --i)
-   {
-      lidx[ll] = j;
-      lval[ll] = rezi * p_work[j];
-      p_work[j] = 0;
-      ++ll;
-   }
+  lval[ll] = 1 - rezi;
+  ++ll;
 
-   lidx[ll] = p_col;
+  for (--i; i >= 0; --i) {
+    j = p_idx[i];
+    lidx[ll] = j;
+    lval[ll] = x = rezi * p_work[j];
+    p_work[j] = 0;
+    ++ll;
 
-   lval[ll] = 1 - rezi;
-   ++ll;
+    if (spxAbs(x) > maxabs)
+      maxabs = spxAbs(x);
+  }
 
-   for(--i; i >= 0; --i)
-   {
-      j = p_idx[i];
-      lidx[ll] = j;
-      lval[ll] = x = rezi * p_work[j];
-      p_work[j] = 0;
-      ++ll;
+  stat = SLinSolverRational::OK;
+}
 
-      if(spxAbs(x) > maxabs)
-         maxabs = spxAbs(x);
-   }
+inline void CLUFactorRational::updateNoClear(int p_col, const Rational *p_work,
+                                             const int *p_idx, int num) {
+  int ll, i, j;
+  Rational x, rezi;
 
-   stat = SLinSolverRational::OK;
-}
+  assert(p_work[p_col] != 0);
+  rezi = 1 / p_work[p_col];
+  ll = makeLvec(num, p_col);
+  // ll = fac->makeLvec(num, col);
+  VectorRational &lval = l.val;
+  int *lidx = l.idx;
 
-inline void CLUFactorRational::updateNoClear(
-   int p_col,
-   const Rational* p_work,
-   const int* p_idx,
-   int num)
-{
-   int ll, i, j;
-   Rational x, rezi;
-
-   assert(p_work[p_col] != 0);
-   rezi = 1 / p_work[p_col];
-   ll = makeLvec(num, p_col);
-   //ll = fac->makeLvec(num, col);
-   VectorRational& lval = l.val;
-   int* lidx = l.idx;
-
-   for(i = num - 1; (j = p_idx[i]) != p_col; --i)
-   {
-      lidx[ll] = j;
-      lval[ll] = rezi * p_work[j];
-      ++ll;
-   }
+  for (i = num - 1; (j = p_idx[i]) != p_col; --i) {
+    lidx[ll] = j;
+    lval[ll] = rezi * p_work[j];
+    ++ll;
+  }
 
-   lidx[ll] = p_col;
+  lidx[ll] = p_col;
 
-   lval[ll] = 1 - rezi;
-   ++ll;
+  lval[ll] = 1 - rezi;
+  ++ll;
 
-   for(--i; i >= 0; --i)
-   {
-      j = p_idx[i];
-      lidx[ll] = j;
-      lval[ll] = x = rezi * p_work[j];
-      ++ll;
+  for (--i; i >= 0; --i) {
+    j = p_idx[i];
+    lidx[ll] = j;
+    lval[ll] = x = rezi * p_work[j];
+    ++ll;
 
-      if(spxAbs(x) > maxabs)
-         maxabs = spxAbs(x);
-   }
+    if (spxAbs(x) > maxabs)
+      maxabs = spxAbs(x);
+  }
 
-   stat = SLinSolverRational::OK;
+  stat = SLinSolverRational::OK;
 }
 
 /*****************************************************************************/
@@ -1370,1384 +1245,1265 @@ inline void CLUFactorRational::updateNoClear(
  *      Initialize row and column file of working matrix and
  *      mark column singletons.
  */
-inline void CLUFactorRational::initFactorMatrix(const SVectorRational** vec)
-{
-
-   Rational x;
-   int m;
-   int tot;
-   Dring* rring, *lastrring;
-   Dring* cring, *lastcring;
-   const SVectorRational* psv;
-   int* sing = temp.s_mark;
+inline void CLUFactorRational::initFactorMatrix(const SVectorRational **vec) {
 
-   /*  Initialize:
-    *  - column file thereby remembering column singletons in |sing|.
-    *  - nonzeros counts per row
-    *  - total number of nonzeros
-    */
+  Rational x;
+  int m;
+  int tot;
+  Dring *rring, *lastrring;
+  Dring *cring, *lastcring;
+  const SVectorRational *psv;
+  int *sing = temp.s_mark;
 
-   for(int i = 0; i < thedim; i++)
-      u.row.max[i] = u.row.len[i] = 0;
+  /*  Initialize:
+   *  - column file thereby remembering column singletons in |sing|.
+   *  - nonzeros counts per row
+   *  - total number of nonzeros
+   */
 
-   tot = 0;
+  for (int i = 0; i < thedim; i++)
+    u.row.max[i] = u.row.len[i] = 0;
 
-   for(int i = 0; i < thedim; i++)
-   {
-      int k;
-
-      psv = vec[i];
-      k = psv->size();
-
-      if(k > 1)
-      {
-         tot += k;
+  tot = 0;
 
-         for(int j = 0; j < k; ++j)
-            u.row.max[psv->index(j)]++;
-      }
-      else if(k == 0)
-      {
-         stat = SLinSolverRational::SINGULAR;
-         return;
-      }
-   }
+  for (int i = 0; i < thedim; i++) {
+    int k;
 
-   /*  Resize nonzero memory if necessary
-    */
-   minRowMem(int(rowMemMult * tot));
+    psv = vec[i];
+    k = psv->size();
 
-   minColMem(int(colMemMult * tot));
+    if (k > 1) {
+      tot += k;
 
-   minLMem(int(lMemMult * tot));
+      for (int j = 0; j < k; ++j)
+        u.row.max[psv->index(j)]++;
+    } else if (k == 0) {
+      stat = SLinSolverRational::SINGULAR;
+      return;
+    }
+  }
 
+  /*  Resize nonzero memory if necessary
+   */
+  minRowMem(int(rowMemMult * tot));
 
-   /*  Initialize:
-    *  - row ring lists
-    *  - row vectors in file
-    *  - column ring lists
-    */
-   u.row.start[0] = 0;
+  minColMem(int(colMemMult * tot));
 
-   rring = u.row.elem;
+  minLMem(int(lMemMult * tot));
 
-   lastrring = &(u.row.list);
+  /*  Initialize:
+   *  - row ring lists
+   *  - row vectors in file
+   *  - column ring lists
+   */
+  u.row.start[0] = 0;
 
-   lastrring->idx = thedim;
+  rring = u.row.elem;
 
-   lastrring->next = rring;
+  lastrring = &(u.row.list);
 
-   cring = u.col.elem;
+  lastrring->idx = thedim;
 
-   lastcring = &(u.col.list);
+  lastrring->next = rring;
 
-   lastcring->idx = thedim;
+  cring = u.col.elem;
 
-   lastcring->next = cring;
+  lastcring = &(u.col.list);
 
-   m = 0;
+  lastcring->idx = thedim;
 
-   for(int i = 0; i < thedim; i++)
-   {
-      u.row.start[i] = m;
-      m += u.row.max[i];
+  lastcring->next = cring;
 
-      rring->idx = i;
-      rring->prev = lastrring;
-      lastrring->next = rring;
-      lastrring = rring;
-      ++rring;
+  m = 0;
 
-      cring->idx = i;
-      cring->prev = lastcring;
-      lastcring->next = cring;
-      lastcring = cring;
-      ++cring;
-   }
+  for (int i = 0; i < thedim; i++) {
+    u.row.start[i] = m;
+    m += u.row.max[i];
 
-   u.row.start[thedim]       = 0;
+    rring->idx = i;
+    rring->prev = lastrring;
+    lastrring->next = rring;
+    lastrring = rring;
+    ++rring;
 
-   u.row.max[thedim]       = 0;
-   u.row.used = m;
+    cring->idx = i;
+    cring->prev = lastcring;
+    lastcring->next = cring;
+    lastcring = cring;
+    ++cring;
+  }
 
-   lastrring->next = &(u.row.list);
-   lastrring->next->prev = lastrring;
+  u.row.start[thedim] = 0;
 
-   lastcring->next = &(u.col.list);
-   lastcring->next->prev = lastcring;
+  u.row.max[thedim] = 0;
+  u.row.used = m;
 
-   /*  Copy matrix to row and column file
-    *  excluding and marking column singletons!
-    */
-   m = 0;
-   temp.stage = 0;
+  lastrring->next = &(u.row.list);
+  lastrring->next->prev = lastrring;
 
-   initMaxabs = 0;
+  lastcring->next = &(u.col.list);
+  lastcring->next->prev = lastcring;
 
-   for(int i = 0; i < thedim; i++)
-   {
-      int nnonzeros;
+  /*  Copy matrix to row and column file
+   *  excluding and marking column singletons!
+   */
+  m = 0;
+  temp.stage = 0;
 
-      psv = vec[i];
-      u.col.start[i] = m;
+  initMaxabs = 0;
 
-      /* check whether number of nonzeros above tolerance is 0, 1 or >= 2 */
-      nnonzeros = 0;
+  for (int i = 0; i < thedim; i++) {
+    int nnonzeros;
 
-      for(int j = 0; j < psv->size() && nnonzeros <= 1; j++)
-      {
-         if(psv->value(j) != 0)
-            nnonzeros++;
-      }
+    psv = vec[i];
+    u.col.start[i] = m;
 
-      /* basis is singular due to empty column */
-      if(nnonzeros == 0)
-      {
-         stat = SLinSolverRational::SINGULAR;
-         return;
-      }
+    /* check whether number of nonzeros above tolerance is 0, 1 or >= 2 */
+    nnonzeros = 0;
 
-      /* exclude column singletons */
-      else if(nnonzeros == 1)
-      {
-         int j;
+    for (int j = 0; j < psv->size() && nnonzeros <= 1; j++) {
+      if (psv->value(j) != 0)
+        nnonzeros++;
+    }
 
-         /* find nonzero */
+    /* basis is singular due to empty column */
+    if (nnonzeros == 0) {
+      stat = SLinSolverRational::SINGULAR;
+      return;
+    }
 
-         for(j = 0; psv->value(j) == 0; j++)
-            ;
+    /* exclude column singletons */
+    else if (nnonzeros == 1) {
+      int j;
 
-         assert(j < psv->size());
+      /* find nonzero */
 
-         /* basis is singular due to two linearly dependent column singletons */
-         if(row.perm[psv->index(j)] >= 0)
-         {
-            stat = SLinSolverRational::SINGULAR;
-            return;
-         }
+      for (j = 0; psv->value(j) == 0; j++)
+        ;
 
-         /* update maximum absolute nonzero value */
-         x = psv->value(j);
+      assert(j < psv->size());
 
-         if(spxAbs(x) > initMaxabs)
-            initMaxabs = spxAbs(x);
+      /* basis is singular due to two linearly dependent column singletons */
+      if (row.perm[psv->index(j)] >= 0) {
+        stat = SLinSolverRational::SINGULAR;
+        return;
+      }
 
-         /* permute to front and mark as singleton */
-         setPivot(temp.stage, i, psv->index(j), x);
+      /* update maximum absolute nonzero value */
+      x = psv->value(j);
 
-         sing[temp.stage] = i;
+      if (spxAbs(x) > initMaxabs)
+        initMaxabs = spxAbs(x);
 
-         temp.stage++;
+      /* permute to front and mark as singleton */
+      setPivot(temp.stage, i, psv->index(j), x);
 
-         /* set column length to zero */
-         temp.s_cact[i] = u.col.len[i] = u.col.max[i] = 0;
-      }
+      sing[temp.stage] = i;
 
-      /* add to active matrix if not a column singleton */
-      else
-      {
-         int end;
-         int k;
+      temp.stage++;
 
-         /* go through all nonzeros in column */
-         assert(nnonzeros >= 2);
-         nnonzeros = 0;
+      /* set column length to zero */
+      temp.s_cact[i] = u.col.len[i] = u.col.max[i] = 0;
+    }
 
-         for(int j = 0; j < psv->size(); j++)
-         {
-            x = psv->value(j);
+    /* add to active matrix if not a column singleton */
+    else {
+      int end;
+      int k;
 
-            if(x != 0)
-            {
-               /* add to column array */
-               k = psv->index(j);
-               u.col.idx[m] = k;
-               m++;
+      /* go through all nonzeros in column */
+      assert(nnonzeros >= 2);
+      nnonzeros = 0;
 
-               /* add to row array */
-               end = u.row.start[k] + u.row.len[k];
-               u.row.idx[end] = i;
-               u.row.val[end] = x;
-               u.row.len[k]++;
+      for (int j = 0; j < psv->size(); j++) {
+        x = psv->value(j);
 
-               /* update maximum absolute nonzero value */
+        if (x != 0) {
+          /* add to column array */
+          k = psv->index(j);
+          u.col.idx[m] = k;
+          m++;
 
-               if(spxAbs(x) > initMaxabs)
-                  initMaxabs = spxAbs(x);
+          /* add to row array */
+          end = u.row.start[k] + u.row.len[k];
+          u.row.idx[end] = i;
+          u.row.val[end] = x;
+          u.row.len[k]++;
 
-               nnonzeros++;
-            }
-         }
+          /* update maximum absolute nonzero value */
 
-         assert(nnonzeros >= 2);
+          if (spxAbs(x) > initMaxabs)
+            initMaxabs = spxAbs(x);
 
-         /* set column length */
-         temp.s_cact[i] = u.col.len[i] = u.col.max[i] = nnonzeros;
+          nnonzeros++;
+        }
       }
-   }
 
-   u.col.used = m;
-}
+      assert(nnonzeros >= 2);
 
+      /* set column length */
+      temp.s_cact[i] = u.col.len[i] = u.col.max[i] = nnonzeros;
+    }
+  }
 
+  u.col.used = m;
+}
 
 /*****************************************************************************/
 /*
  *      Remove column singletons
  */
 
-inline void CLUFactorRational::colSingletons()
-{
-   int i, j, k, n;
-   int len;
-   int p_col, p_row, newrow;
-   int* idx;
-   int* rorig = row.orig;
-   int* rperm = row.perm;
-   int* sing = temp.s_mark;
-
-
-   /*  Iteratively update column counts due to removed column singletons
-    *  thereby removing new arising columns singletons
-    *  and computing the index of the first row singleton (-1)
-    *  until no more can be found.
-    */
-
-   for(i = 0; i < temp.stage; ++i)
-   {
-      p_row = rorig[i];
-      assert(p_row >= 0);
-      idx = &(u.row.idx[u.row.start[p_row]]);
-      len = u.row.len[p_row];
-
-      for(j = 0; j < len; ++j)
-      {
-         /*  Move pivotal nonzeros to front of column.
-          */
-         p_col = idx[j];
-         assert(temp.s_cact[p_col] > 0);
+inline void CLUFactorRational::colSingletons() {
+  int i, j, k, n;
+  int len;
+  int p_col, p_row, newrow;
+  int *idx;
+  int *rorig = row.orig;
+  int *rperm = row.perm;
+  int *sing = temp.s_mark;
+
+  /*  Iteratively update column counts due to removed column singletons
+   *  thereby removing new arising columns singletons
+   *  and computing the index of the first row singleton (-1)
+   *  until no more can be found.
+   */
+
+  for (i = 0; i < temp.stage; ++i) {
+    p_row = rorig[i];
+    assert(p_row >= 0);
+    idx = &(u.row.idx[u.row.start[p_row]]);
+    len = u.row.len[p_row];
+
+    for (j = 0; j < len; ++j) {
+      /*  Move pivotal nonzeros to front of column.
+       */
+      p_col = idx[j];
+      assert(temp.s_cact[p_col] > 0);
+
+      n = u.col.start[p_col] + u.col.len[p_col] - temp.s_cact[p_col];
 
-         n = u.col.start[p_col] + u.col.len[p_col] - temp.s_cact[p_col];
+      for (k = n; u.col.idx[k] != p_row; ++k)
+        ;
 
-         for(k = n; u.col.idx[k] != p_row; ++k)
-            ;
+      assert(k < u.col.start[p_col] + u.col.len[p_col]);
 
-         assert(k < u.col.start[p_col] + u.col.len[p_col]);
+      u.col.idx[k] = u.col.idx[n];
 
-         u.col.idx[k] = u.col.idx[n];
+      u.col.idx[n] = p_row;
 
-         u.col.idx[n] = p_row;
+      n = --(temp.s_cact[p_col]); /* column nonzeros of ACTIVE matrix */
 
-         n = --(temp.s_cact[p_col]);          /* column nonzeros of ACTIVE matrix */
+      if (n == 1) /* Here is another singleton */
+      {
+        newrow = u.col.idx[--u.col.len[p_col] + u.col.start[p_col]];
 
-         if(n == 1)                   /* Here is another singleton */
-         {
-            newrow = u.col.idx[--u.col.len[p_col] + u.col.start[p_col]];
+        /*      Ensure, matrix not singular
+         */
 
-            /*      Ensure, matrix not singular
-             */
+        if (rperm[newrow] >= 0) {
+          stat = SLinSolverRational::SINGULAR;
+          return;
+        }
 
-            if(rperm[newrow] >= 0)
-            {
-               stat = SLinSolverRational::SINGULAR;
-               return;
-            }
+        /*      Find singleton in row.
+         */
+        n = u.row.start[newrow] + (--(u.row.len[newrow]));
 
-            /*      Find singleton in row.
-             */
-            n = u.row.start[newrow] + (--(u.row.len[newrow]));
+        for (k = n; u.row.idx[k] != p_col; --k)
+          ;
 
-            for(k = n; u.row.idx[k] != p_col; --k)
-               ;
+        /*      Remove singleton from column.
+         */
+        setPivot(temp.stage, p_col, newrow, u.row.val[k]);
 
-            /*      Remove singleton from column.
-             */
-            setPivot(temp.stage, p_col, newrow, u.row.val[k]);
+        sing[temp.stage++] = p_col;
 
-            sing[temp.stage++] = p_col;
+        /*      Move pivot element to diag.
+         */
+        u.row.val[k] = u.row.val[n];
 
-            /*      Move pivot element to diag.
-             */
-            u.row.val[k] = u.row.val[n];
-
-            u.row.idx[k] = u.row.idx[n];
-         }
-         else if(n == 0)
-         {
-            stat = SLinSolverRational::SINGULAR;
-            return;
-         }
+        u.row.idx[k] = u.row.idx[n];
+      } else if (n == 0) {
+        stat = SLinSolverRational::SINGULAR;
+        return;
       }
-   }
+    }
+  }
 
-   assert(temp.stage <= thedim);
+  assert(temp.stage <= thedim);
 }
 
-
 /*****************************************************************************/
 /*
  *      Remove row singletons
  */
-inline void CLUFactorRational::rowSingletons()
-{
-   Rational pval;
-   int i, j, k, ll, r;
-   int p_row, p_col, len, rs, lk;
-   int* idx;
-   int* rperm = row.perm;
-   int* sing = temp.s_mark;
-
-   /*  Mark row singletons
-    */
-   rs = temp.stage;
-
-   for(i = 0; i < thedim; ++i)
-   {
-      if(rperm[i] < 0 && u.row.len[i] == 1)
-         sing[temp.stage++] = i;
-   }
+inline void CLUFactorRational::rowSingletons() {
+  Rational pval;
+  int i, j, k, ll, r;
+  int p_row, p_col, len, rs, lk;
+  int *idx;
+  int *rperm = row.perm;
+  int *sing = temp.s_mark;
+
+  /*  Mark row singletons
+   */
+  rs = temp.stage;
+
+  for (i = 0; i < thedim; ++i) {
+    if (rperm[i] < 0 && u.row.len[i] == 1)
+      sing[temp.stage++] = i;
+  }
+
+  /*  Eliminate row singletons
+   *  thereby marking newly arising ones
+   *  until no more can be found.
+   */
+  for (; rs < temp.stage; ++rs) {
+    /*      Move pivot element from row file to diag
+     */
+    p_row = sing[rs];
+    j = u.row.start[p_row];
+    p_col = u.row.idx[j];
+    pval = u.row.val[j];
+    setPivot(rs, p_col, p_row, pval);
+    u.row.len[p_row] = 0;
+
+    /*      Remove pivot column form workingmatrix
+     *      thereby building up L vector.
+     */
+    idx = &(u.col.idx[u.col.start[p_col]]);
+    i = temp.s_cact[p_col]; /* nr. nonzeros of new L vector */
+    lk = makeLvec(i - 1, p_row);
+    len = u.col.len[p_col];
+    i = (u.col.len[p_col] -= i); /* remove pivot column from U */
+
+    for (; i < len; ++i) {
+      r = idx[i];
+
+      if (r != p_row) {
+        /*      Find pivot column in row.
+         */
+        ll = --(u.row.len[r]);
+        k = u.row.start[r] + ll;
+
+        for (j = k; u.row.idx[j] != p_col; --j)
+          ;
+
+        assert(k >= u.row.start[r]);
+
+        /*      Initialize L vector
+         */
+        l.idx[lk] = r;
+
+        l.val[lk] = u.row.val[j] / pval;
+
+        ++lk;
+
+        /*      Remove pivot column from row.
+         */
+        u.row.idx[j] = u.row.idx[k];
+
+        u.row.val[j] = u.row.val[k];
+
+        /*      Check new row length.
+         */
+        if (ll == 1)
+          sing[temp.stage++] = r;
+        else if (ll == 0) {
+          stat = SLinSolverRational::SINGULAR;
+          return;
+        }
+      }
+    }
+  }
+}
 
-   /*  Eliminate row singletons
-    *  thereby marking newly arising ones
-    *  until no more can be found.
-    */
-   for(; rs < temp.stage; ++rs)
-   {
-      /*      Move pivot element from row file to diag
-       */
-      p_row = sing[rs];
-      j = u.row.start[p_row];
-      p_col = u.row.idx[j];
-      pval = u.row.val[j];
-      setPivot(rs, p_col, p_row, pval);
-      u.row.len[p_row] = 0;
-
-      /*      Remove pivot column form workingmatrix
-       *      thereby building up L vector.
-       */
-      idx = &(u.col.idx[u.col.start[p_col]]);
-      i = temp.s_cact[p_col];                /* nr. nonzeros of new L vector */
-      lk = makeLvec(i - 1, p_row);
-      len = u.col.len[p_col];
-      i = (u.col.len[p_col] -= i);         /* remove pivot column from U */
+/*****************************************************************************/
+/*
+ *      Init nonzero number Ring lists
+ *      and required entries of arrays max and mark
+ */
 
-      for(; i < len; ++i)
-      {
-         r = idx[i];
+inline void CLUFactorRational::initFactorRings() {
+  int i;
+  int *rperm = row.perm;
+  int *cperm = col.perm;
+  CLUFactorRational::Pring *ring;
+
+  assert(thedim >= 0);
+  spx_alloc(temp.pivot_col, thedim + 1);
+  spx_alloc(temp.pivot_colNZ, thedim + 1);
+  spx_alloc(temp.pivot_row, thedim + 1);
+  spx_alloc(temp.pivot_rowNZ, thedim + 1);
+
+  for (i = thedim - temp.stage; i >= 0; --i) {
+    initDR(temp.pivot_colNZ[i]);
+    initDR(temp.pivot_rowNZ[i]);
+  }
+
+  for (i = 0; i < thedim; ++i) {
+    if (rperm[i] < 0) {
+      if (u.row.len[i] <= 0) {
+        stat = SLinSolverRational::SINGULAR;
+        return;
+      }
 
-         if(r != p_row)
-         {
-            /*      Find pivot column in row.
-             */
-            ll = --(u.row.len[r]);
-            k = u.row.start[r] + ll;
+      ring = &(temp.pivot_rowNZ[u.row.len[i]]);
 
-            for(j = k; u.row.idx[j] != p_col; --j)
-               ;
+      init2DR(temp.pivot_row[i], *ring);
+      temp.pivot_row[i].idx = i;
+      temp.s_max[i] = -1;
+    }
 
-            assert(k >= u.row.start[r]);
+    if (cperm[i] < 0) {
+      if (temp.s_cact[i] <= 0) {
+        stat = SLinSolverRational::SINGULAR;
+        return;
+      }
 
-            /*      Initialize L vector
-             */
-            l.idx[lk] = r;
+      ring = &(temp.pivot_colNZ[temp.s_cact[i]]);
 
-            l.val[lk] = u.row.val[j] / pval;
+      init2DR(temp.pivot_col[i], *ring);
+      temp.pivot_col[i].idx = i;
+      temp.s_mark[i] = 0;
+    }
+  }
+}
 
-            ++lk;
+inline void CLUFactorRational::freeFactorRings(void) {
 
-            /*      Remove pivot column from row.
-             */
-            u.row.idx[j] = u.row.idx[k];
+  if (temp.pivot_col)
+    spx_free(temp.pivot_col);
 
-            u.row.val[j] = u.row.val[k];
+  if (temp.pivot_colNZ)
+    spx_free(temp.pivot_colNZ);
 
-            /*      Check new row length.
-             */
-            if(ll == 1)
-               sing[temp.stage++] = r;
-            else if(ll == 0)
-            {
-               stat = SLinSolverRational::SINGULAR;
-               return;
-            }
-         }
-      }
-   }
-}
+  if (temp.pivot_row)
+    spx_free(temp.pivot_row);
 
+  if (temp.pivot_rowNZ)
+    spx_free(temp.pivot_rowNZ);
+}
 
-/*****************************************************************************/
 /*
- *      Init nonzero number Ring lists
- *      and required entries of arrays max and mark
+ *      Eliminate all row singletons from nucleus.
+ *      A row singleton may well be column singleton at the same time!
  */
+inline void CLUFactorRational::eliminateRowSingletons() {
+  int i, j, k, ll, r;
+  int len, lk;
+  int pcol, prow;
+  Rational pval;
+  int *idx;
+  CLUFactorRational::Pring *sing;
 
-inline void CLUFactorRational::initFactorRings()
-{
-   int i;
-   int* rperm = row.perm;
-   int* cperm = col.perm;
-   CLUFactorRational::Pring* ring;
-
-   assert(thedim >= 0);
-   spx_alloc(temp.pivot_col,   thedim + 1);
-   spx_alloc(temp.pivot_colNZ, thedim + 1);
-   spx_alloc(temp.pivot_row,   thedim + 1);
-   spx_alloc(temp.pivot_rowNZ, thedim + 1);
-
-   for(i = thedim - temp.stage; i >= 0; --i)
-   {
-      initDR(temp.pivot_colNZ[i]);
-      initDR(temp.pivot_rowNZ[i]);
-   }
+  for (sing = temp.pivot_rowNZ[1].prev; sing != &(temp.pivot_rowNZ[1]);
+       sing = sing->prev) {
+    prow = sing->idx;
+    i = u.row.start[prow];
+    pcol = u.row.idx[i];
+    pval = u.row.val[i];
+    setPivot(temp.stage++, pcol, prow, pval);
+    u.row.len[prow] = 0;
+    removeDR(temp.pivot_col[pcol]);
 
-   for(i = 0; i < thedim; ++i)
-   {
-      if(rperm[i] < 0)
-      {
-         if(u.row.len[i] <= 0)
-         {
-            stat = SLinSolverRational::SINGULAR;
-            return;
-         }
+    /*      Eliminate pivot column and build L vector.
+     */
+    i = temp.s_cact[pcol];
 
-         ring = &(temp.pivot_rowNZ[u.row.len[i]]);
+    if (i > 1) {
+      idx = &(u.col.idx[u.col.start[pcol]]);
+      len = u.col.len[pcol];
+      lk = makeLvec(i - 1, prow);
+      i = u.col.len[pcol] -= i;
 
-         init2DR(temp.pivot_row[i], *ring);
-         temp.pivot_row[i].idx = i;
-         temp.s_max[i] = -1;
-      }
+      for (; (r = idx[i]) != prow; ++i) {
+        /*      Find pivot column in row.
+         */
+        ll = --(u.row.len[r]);
+        k = u.row.start[r] + ll;
 
-      if(cperm[i] < 0)
-      {
-         if(temp.s_cact[i] <= 0)
-         {
-            stat = SLinSolverRational::SINGULAR;
-            return;
-         }
+        for (j = k; u.row.idx[j] != pcol; --j)
+          ;
+
+        assert(j >= u.row.start[r]);
+
+        /*      Initialize L vector
+         */
+        l.idx[lk] = r;
 
-         ring = &(temp.pivot_colNZ[temp.s_cact[i]]);
+        l.val[lk] = u.row.val[j] / pval;
 
-         init2DR(temp.pivot_col[i], *ring);
-         temp.pivot_col[i].idx = i;
-         temp.s_mark[i] = 0;
+        ++lk;
+
+        /*      Remove pivot column from row.
+         */
+        u.row.idx[j] = u.row.idx[k];
+
+        u.row.val[j] = u.row.val[k];
+
+        /*      Move column to appropriate nonzero ring.
+         */
+        removeDR(temp.pivot_row[r]);
+
+        init2DR(temp.pivot_row[r], temp.pivot_rowNZ[ll]);
+
+        assert(row.perm[r] < 0);
+
+        temp.s_max[r] = -1;
       }
-   }
-}
 
-inline void CLUFactorRational::freeFactorRings(void)
-{
+      /* skip pivot element */
+      assert(i < len && "ERROR: pivot column does not contain pivot row");
 
-   if(temp.pivot_col)
-      spx_free(temp.pivot_col);
+      for (++i; i < len; ++i) {
+        /*      Find pivot column in row.
+         */
+        r = idx[i];
+        ll = --(u.row.len[r]);
+        k = u.row.start[r] + ll;
 
-   if(temp.pivot_colNZ)
-      spx_free(temp.pivot_colNZ);
+        for (j = k; u.row.idx[j] != pcol; --j)
+          ;
 
-   if(temp.pivot_row)
-      spx_free(temp.pivot_row);
+        assert(j >= u.row.start[r]);
 
-   if(temp.pivot_rowNZ)
-      spx_free(temp.pivot_rowNZ);
-}
+        /*      Initialize L vector
+         */
+        l.idx[lk] = r;
 
+        l.val[lk] = u.row.val[j] / pval;
 
-/*
- *      Eliminate all row singletons from nucleus.
- *      A row singleton may well be column singleton at the same time!
- */
-inline void CLUFactorRational::eliminateRowSingletons()
-{
-   int i, j, k, ll, r;
-   int len, lk;
-   int pcol, prow;
-   Rational pval;
-   int* idx;
-   CLUFactorRational::Pring* sing;
-
-   for(sing = temp.pivot_rowNZ[1].prev; sing != &(temp.pivot_rowNZ[1]); sing = sing->prev)
-   {
-      prow = sing->idx;
-      i = u.row.start[prow];
-      pcol = u.row.idx[i];
-      pval = u.row.val[i];
-      setPivot(temp.stage++, pcol, prow, pval);
-      u.row.len[prow] = 0;
-      removeDR(temp.pivot_col[pcol]);
-
-      /*      Eliminate pivot column and build L vector.
-       */
-      i = temp.s_cact[pcol];
+        ++lk;
 
-      if(i > 1)
-      {
-         idx = &(u.col.idx[u.col.start[pcol]]);
-         len = u.col.len[pcol];
-         lk = makeLvec(i - 1, prow);
-         i = u.col.len[pcol] -= i;
-
-         for(; (r = idx[i]) != prow; ++i)
-         {
-            /*      Find pivot column in row.
-             */
-            ll = --(u.row.len[r]);
-            k = u.row.start[r] + ll;
+        /*      Remove pivot column from row.
+         */
+        u.row.idx[j] = u.row.idx[k];
 
-            for(j = k; u.row.idx[j] != pcol; --j)
-               ;
+        u.row.val[j] = u.row.val[k];
 
-            assert(j >= u.row.start[r]);
+        /*      Move column to appropriate nonzero ring.
+         */
+        removeDR(temp.pivot_row[r]);
 
-            /*      Initialize L vector
-             */
-            l.idx[lk] = r;
+        init2DR(temp.pivot_row[r], temp.pivot_rowNZ[ll]);
 
-            l.val[lk] = u.row.val[j] / pval;
+        assert(row.perm[r] < 0);
 
-            ++lk;
+        temp.s_max[r] = -1;
+      }
+    } else
+      u.col.len[pcol] -= i;
+  }
 
-            /*      Remove pivot column from row.
-             */
-            u.row.idx[j] = u.row.idx[k];
+  initDR(temp.pivot_rowNZ[1]); /* Remove all row singletons from list */
+}
 
-            u.row.val[j] = u.row.val[k];
+/*
+ *      Eliminate all column singletons from nucleus.
+ *      A column singleton must not be row singleton at the same time!
+ */
+inline void CLUFactorRational::eliminateColSingletons() {
+  int i, j, k, m, c;
+  int pcol, prow;
+  CLUFactorRational::Pring *sing;
 
-            /*      Move column to appropriate nonzero ring.
-             */
-            removeDR(temp.pivot_row[r]);
+  for (sing = temp.pivot_colNZ[1].prev; sing != &(temp.pivot_colNZ[1]);
+       sing = sing->prev) {
+    /*      Find pivot value
+     */
+    pcol = sing->idx;
+    j = --(u.col.len[pcol]) + u.col.start[pcol]; /* remove pivot column */
+    prow = u.col.idx[j];
+    removeDR(temp.pivot_row[prow]);
 
-            init2DR(temp.pivot_row[r], temp.pivot_rowNZ[ll]);
+    j = --(u.row.len[prow]) + u.row.start[prow];
 
-            assert(row.perm[r] < 0);
+    for (i = j; (c = u.row.idx[i]) != pcol; --i) {
+      m = u.col.len[c] + u.col.start[c] - (temp.s_cact[c])--;
 
-            temp.s_max[r] = -1;
-         }
+      for (k = m; u.col.idx[k] != prow; ++k)
+        ;
 
-         /* skip pivot element */
-         assert(i < len && "ERROR: pivot column does not contain pivot row");
+      u.col.idx[k] = u.col.idx[m];
 
-         for(++i; i < len; ++i)
-         {
-            /*      Find pivot column in row.
-             */
-            r = idx[i];
-            ll = --(u.row.len[r]);
-            k = u.row.start[r] + ll;
+      u.col.idx[m] = prow;
 
-            for(j = k; u.row.idx[j] != pcol; --j)
-               ;
+      m = temp.s_cact[c];
 
-            assert(j >= u.row.start[r]);
+      removeDR(temp.pivot_col[c]);
 
-            /*      Initialize L vector
-             */
-            l.idx[lk] = r;
+      init2DR(temp.pivot_col[c], temp.pivot_colNZ[m]);
 
-            l.val[lk] = u.row.val[j] / pval;
+      assert(col.perm[c] < 0);
+    }
 
-            ++lk;
+    /*      remove pivot element from pivot row
+     */
+    setPivot(temp.stage++, pcol, prow, u.row.val[i]);
 
-            /*      Remove pivot column from row.
-             */
-            u.row.idx[j] = u.row.idx[k];
+    u.row.idx[i] = u.row.idx[j];
 
-            u.row.val[j] = u.row.val[k];
+    u.row.val[i] = u.row.val[j];
 
-            /*      Move column to appropriate nonzero ring.
-             */
-            removeDR(temp.pivot_row[r]);
+    j = u.row.start[prow];
 
-            init2DR(temp.pivot_row[r], temp.pivot_rowNZ[ll]);
+    for (--i; i >= j; --i) {
+      c = u.row.idx[i];
+      m = u.col.len[c] + u.col.start[c] - (temp.s_cact[c])--;
 
-            assert(row.perm[r] < 0);
+      for (k = m; u.col.idx[k] != prow; ++k)
+        ;
 
-            temp.s_max[r] = -1;
-         }
-      }
-      else
-         u.col.len[pcol] -= i;
-   }
+      u.col.idx[k] = u.col.idx[m];
 
-   initDR(temp.pivot_rowNZ[1]);    /* Remove all row singletons from list */
-}
+      u.col.idx[m] = prow;
 
+      m = temp.s_cact[c];
 
+      removeDR(temp.pivot_col[c]);
+
+      init2DR(temp.pivot_col[c], temp.pivot_colNZ[m]);
+
+      assert(col.perm[c] < 0);
+    }
+  }
+
+  initDR(temp.pivot_colNZ[1]); /* Remove all column singletons from list */
+}
 
 /*
- *      Eliminate all column singletons from nucleus.
- *      A column singleton must not be row singleton at the same time!
+ * No singletons available: Select pivot elements.
  */
-inline void CLUFactorRational::eliminateColSingletons()
-{
-   int i, j, k, m, c;
-   int pcol, prow;
-   CLUFactorRational::Pring* sing;
-
-   for(sing = temp.pivot_colNZ[1].prev;
-         sing != &(temp.pivot_colNZ[1]);
-         sing = sing->prev)
-   {
-      /*      Find pivot value
+inline void CLUFactorRational::selectPivots(const Rational &threshold) {
+  int ii;
+  int i;
+  int j;
+  int k;
+  int ll = -1; // This value should never be used.
+  int kk;
+  int m;
+  int count;
+  int num;
+  int rw = -1; // This value should never be used.
+  int cl = -1; // This value should never be used.
+  int len;
+  int beg;
+  Rational l_maxabs;
+  Rational x = 0; // This value should never be used.
+  int mkwtz;
+  int candidates;
+
+  candidates = thedim - temp.stage - 1;
+
+  if (candidates > 4)
+    candidates = 4;
+
+  num = 0;
+
+  count = 2;
+
+  for (;;) {
+    ii = -1;
+
+    if (temp.pivot_rowNZ[count].next != &(temp.pivot_rowNZ[count])) {
+      rw = temp.pivot_rowNZ[count].next->idx;
+      beg = u.row.start[rw];
+      len = u.row.len[rw] + beg - 1;
+
+      /*  set l_maxabs to maximum absolute value in row
+       *  (compute it if necessary).
        */
-      pcol = sing->idx;
-      j = --(u.col.len[pcol]) + u.col.start[pcol];   /* remove pivot column */
-      prow = u.col.idx[j];
-      removeDR(temp.pivot_row[prow]);
-
-      j = --(u.row.len[prow]) + u.row.start[prow];
 
-      for(i = j; (c = u.row.idx[i]) != pcol; --i)
-      {
-         m = u.col.len[c] + u.col.start[c] - (temp.s_cact[c])--;
+      if (temp.s_max[rw] < 0) {
+        l_maxabs = spxAbs(u.row.val[len]);
 
-         for(k = m; u.col.idx[k] != prow; ++k)
-            ;
+        for (i = len - 1; i >= beg; --i)
+          if (l_maxabs < spxAbs(u.row.val[i]))
+            l_maxabs = spxAbs(u.row.val[i]);
 
-         u.col.idx[k] = u.col.idx[m];
+        temp.s_max[rw] = l_maxabs; /* ##### */
+      } else
+        l_maxabs = temp.s_max[rw];
 
-         u.col.idx[m] = prow;
+      l_maxabs *= threshold;
 
-         m = temp.s_cact[c];
+      /*  select pivot element with lowest markowitz number in row
+       */
+      mkwtz = thedim + 1;
 
-         removeDR(temp.pivot_col[c]);
+      for (i = len; i >= beg; --i) {
+        k = u.row.idx[i];
+        j = temp.s_cact[k];
+        x = u.row.val[i];
 
-         init2DR(temp.pivot_col[c], temp.pivot_colNZ[m]);
+        if (j < mkwtz && spxAbs(x) > l_maxabs) {
+          mkwtz = j;
+          cl = k;
+          ii = i;
 
-         assert(col.perm[c] < 0);
+          if (j <= count) /* ##### */
+            break;
+        }
       }
-
-      /*      remove pivot element from pivot row
+    } else if (temp.pivot_colNZ[count].next != &(temp.pivot_colNZ[count])) {
+      cl = temp.pivot_colNZ[count].next->idx;
+      beg = u.col.start[cl];
+      len = u.col.len[cl] + beg - 1;
+      beg = len - temp.s_cact[cl] + 1;
+      assert(count == temp.s_cact[cl]);
+
+      /*  select pivot element with lowest markowitz number in column
        */
-      setPivot(temp.stage++, pcol, prow, u.row.val[i]);
+      mkwtz = thedim + 1;
 
-      u.row.idx[i] = u.row.idx[j];
+      for (i = len; i >= beg; --i) {
+        k = u.col.idx[i];
+        j = u.row.len[k];
 
-      u.row.val[i] = u.row.val[j];
+        if (j < mkwtz) {
+          /*  ensure that element (cl,k) is stable.
+           */
+          if (temp.s_max[k] > 0) {
+            /*  case 1: l_maxabs is known
+             */
+            for (m = u.row.start[k], kk = m + u.row.len[k] - 1; kk >= m; --kk) {
+              if (u.row.idx[kk] == cl) {
+                x = u.row.val[kk];
+                ll = kk;
+                break;
+              }
+            }
 
-      j = u.row.start[prow];
+            l_maxabs = temp.s_max[k];
+          } else {
+            /*  case 2: l_maxabs needs to be computed
+             */
+            m = u.row.start[k];
+            l_maxabs = spxAbs(u.row.val[m]);
+
+            for (kk = m + u.row.len[k] - 1; kk >= m; --kk) {
+              if (l_maxabs < spxAbs(u.row.val[kk]))
+                l_maxabs = spxAbs(u.row.val[kk]);
+
+              if (u.row.idx[kk] == cl) {
+                x = u.row.val[kk];
+                ll = kk;
+                break;
+              }
+            }
 
-      for(--i; i >= j; --i)
-      {
-         c = u.row.idx[i];
-         m = u.col.len[c] + u.col.start[c] - (temp.s_cact[c])--;
+            for (--kk; kk > m; --kk) {
+              if (l_maxabs < spxAbs(u.row.val[kk]))
+                l_maxabs = spxAbs(u.row.val[kk]);
+            }
 
-         for(k = m; u.col.idx[k] != prow; ++k)
-            ;
+            temp.s_max[k] = l_maxabs;
+          }
 
-         u.col.idx[k] = u.col.idx[m];
+          l_maxabs *= threshold;
 
-         u.col.idx[m] = prow;
+          if (spxAbs(x) > l_maxabs) {
+            mkwtz = j;
+            rw = k;
+            ii = ll;
 
-         m = temp.s_cact[c];
+            if (j <= count + 1)
+              break;
+          }
+        }
+      }
+    } else {
+      ++count;
+      continue;
+    }
 
-         removeDR(temp.pivot_col[c]);
+    assert(cl >= 0);
 
-         init2DR(temp.pivot_col[c], temp.pivot_colNZ[m]);
+    removeDR(temp.pivot_col[cl]);
+    initDR(temp.pivot_col[cl]);
 
-         assert(col.perm[c] < 0);
+    if (ii >= 0) {
+      /*  Initialize selected pivot element
+       */
+      CLUFactorRational::Pring *pr;
+      temp.pivot_row[rw].pos = ii - u.row.start[rw];
+      temp.pivot_row[rw].mkwtz = mkwtz = (mkwtz - 1) * (count - 1);
+      // ??? mkwtz originally was long,
+      // maybe to avoid an overflow in this instruction?
+
+      for (pr = temp.pivots.next; pr->idx >= 0; pr = pr->next) {
+        if (pr->idx == rw || pr->mkwtz >= mkwtz)
+          break;
       }
-   }
 
-   initDR(temp.pivot_colNZ[1]);    /* Remove all column singletons from list */
-}
+      pr = pr->prev;
 
-/*
- * No singletons available: Select pivot elements.
- */
-inline void CLUFactorRational::selectPivots(const Rational& threshold)
-{
-   int ii;
-   int i;
-   int j;
-   int k;
-   int ll = -1; // This value should never be used.
-   int kk;
-   int m;
-   int count;
-   int num;
-   int rw = -1; // This value should never be used.
-   int cl = -1; // This value should never be used.
-   int len;
-   int beg;
-   Rational l_maxabs;
-   Rational x = 0; // This value should never be used.
-   int mkwtz;
-   int candidates;
-
-   candidates = thedim - temp.stage - 1;
-
-   if(candidates > 4)
-      candidates = 4;
-
-   num = 0;
-
-   count = 2;
-
-   for(;;)
-   {
-      ii = -1;
-
-      if(temp.pivot_rowNZ[count].next != &(temp.pivot_rowNZ[count]))
-      {
-         rw = temp.pivot_rowNZ[count].next->idx;
-         beg = u.row.start[rw];
-         len = u.row.len[rw] + beg - 1;
-
-         /*  set l_maxabs to maximum absolute value in row
-          *  (compute it if necessary).
-          */
-
-         if(temp.s_max[rw] < 0)
-         {
-            l_maxabs = spxAbs(u.row.val[len]);
-
-            for(i = len - 1; i >= beg; --i)
-               if(l_maxabs < spxAbs(u.row.val[i]))
-                  l_maxabs = spxAbs(u.row.val[i]);
-
-            temp.s_max[rw] = l_maxabs;               /* ##### */
-         }
-         else
-            l_maxabs = temp.s_max[rw];
-
-         l_maxabs *= threshold;
-
-         /*  select pivot element with lowest markowitz number in row
-          */
-         mkwtz = thedim + 1;
-
-         for(i = len; i >= beg; --i)
-         {
-            k = u.row.idx[i];
-            j = temp.s_cact[k];
-            x = u.row.val[i];
-
-            if(j < mkwtz && spxAbs(x) > l_maxabs)
-            {
-               mkwtz = j;
-               cl = k;
-               ii = i;
-
-               if(j <= count)               /* ##### */
-                  break;
-            }
-         }
-      }
-      else if(temp.pivot_colNZ[count].next != &(temp.pivot_colNZ[count]))
-      {
-         cl = temp.pivot_colNZ[count].next->idx;
-         beg = u.col.start[cl];
-         len = u.col.len[cl] + beg - 1;
-         beg = len - temp.s_cact[cl] + 1;
-         assert(count == temp.s_cact[cl]);
-
-         /*  select pivot element with lowest markowitz number in column
-          */
-         mkwtz = thedim + 1;
-
-         for(i = len; i >= beg; --i)
-         {
-            k = u.col.idx[i];
-            j = u.row.len[k];
-
-            if(j < mkwtz)
-            {
-               /*  ensure that element (cl,k) is stable.
-                */
-               if(temp.s_max[k] > 0)
-               {
-                  /*  case 1: l_maxabs is known
-                   */
-                  for(m = u.row.start[k], kk = m + u.row.len[k] - 1;
-                        kk >= m; --kk)
-                  {
-                     if(u.row.idx[kk] == cl)
-                     {
-                        x = u.row.val[kk];
-                        ll = kk;
-                        break;
-                     }
-                  }
-
-                  l_maxabs = temp.s_max[k];
-               }
-               else
-               {
-                  /*  case 2: l_maxabs needs to be computed
-                   */
-                  m = u.row.start[k];
-                  l_maxabs = spxAbs(u.row.val[m]);
-
-                  for(kk = m + u.row.len[k] - 1; kk >= m; --kk)
-                  {
-                     if(l_maxabs < spxAbs(u.row.val[kk]))
-                        l_maxabs = spxAbs(u.row.val[kk]);
-
-                     if(u.row.idx[kk] == cl)
-                     {
-                        x = u.row.val[kk];
-                        ll = kk;
-                        break;
-                     }
-                  }
-
-                  for(--kk; kk > m; --kk)
-                  {
-                     if(l_maxabs < spxAbs(u.row.val[kk]))
-                        l_maxabs = spxAbs(u.row.val[kk]);
-                  }
-
-                  temp.s_max[k] = l_maxabs;
-               }
-
-               l_maxabs *= threshold;
-
-               if(spxAbs(x) > l_maxabs)
-               {
-                  mkwtz = j;
-                  rw = k;
-                  ii = ll;
-
-                  if(j <= count + 1)
-                     break;
-               }
-            }
-         }
-      }
-      else
-      {
-         ++count;
-         continue;
+      if (pr->idx != rw) {
+        removeDR(temp.pivot_row[rw]);
+        init2DR(temp.pivot_row[rw], *pr);
       }
 
-      assert(cl >= 0);
+      num++;
 
-      removeDR(temp.pivot_col[cl]);
-      initDR(temp.pivot_col[cl]);
+      if (num >= candidates)
+        break;
+    }
+  }
 
-      if(ii >= 0)
-      {
-         /*  Initialize selected pivot element
-          */
-         CLUFactorRational::Pring* pr;
-         temp.pivot_row[rw].pos = ii - u.row.start[rw];
-         temp.pivot_row[rw].mkwtz = mkwtz = (mkwtz - 1) * (count - 1);
-         // ??? mkwtz originally was long,
-         // maybe to avoid an overflow in this instruction?
-
-         for(pr = temp.pivots.next; pr->idx >= 0; pr = pr->next)
-         {
-            if(pr->idx == rw || pr->mkwtz >= mkwtz)
-               break;
-         }
-
-         pr = pr->prev;
-
-         if(pr->idx != rw)
-         {
-            removeDR(temp.pivot_row[rw]);
-            init2DR(temp.pivot_row[rw], *pr);
-         }
-
-         num++;
-
-         if(num >= candidates)
-            break;
-      }
+  /*
+   *     while(temp.temp.next->mkwtz < temp.temp.prev->mkwtz)
+   *     {
+   *     Pring   *pr;
+   *     pr = temp.temp.prev;
+   *     removeDR(*pr);
+   *     init2DR (*pr, rowNZ[u.row.len[pr->idx]]);
    }
+   */
 
-   /*
-    *     while(temp.temp.next->mkwtz < temp.temp.prev->mkwtz)
-    *     {
-    *     Pring   *pr;
-    *     pr = temp.temp.prev;
-    *     removeDR(*pr);
-    *     init2DR (*pr, rowNZ[u.row.len[pr->idx]]);
-    }
-    */
-
-   assert(row.perm[rw] < 0);
+  assert(row.perm[rw] < 0);
 
-   assert(col.perm[cl] < 0);
+  assert(col.perm[cl] < 0);
 }
 
-
 /*
  *      Perform L and update loop for row r
  */
-inline int CLUFactorRational::updateRow(int r,
-                                        int lv,
-                                        int prow,
-                                        int pcol,
-                                        const Rational& pval)
-{
-   int fill;
-   Rational x, lx;
-   int c, i, j, k, ll, m, n;
+inline int CLUFactorRational::updateRow(int r, int lv, int prow, int pcol,
+                                        const Rational &pval) {
+  int fill;
+  Rational x, lx;
+  int c, i, j, k, ll, m, n;
 
-   n = u.row.start[r];
-   m = --(u.row.len[r]) + n;
+  n = u.row.start[r];
+  m = --(u.row.len[r]) + n;
 
-   /*  compute L vector entry and
-    *  and remove pivot column form row file
-    */
+  /*  compute L vector entry and
+   *  and remove pivot column form row file
+   */
 
-   for(j = m; u.row.idx[j] != pcol; --j)
-      ;
+  for (j = m; u.row.idx[j] != pcol; --j)
+    ;
 
-   lx = u.row.val[j] / pval;
+  lx = u.row.val[j] / pval;
 
-   l.val[lv] = lx;
+  l.val[lv] = lx;
 
-   l.idx[lv] = r;
+  l.idx[lv] = r;
 
-   ++lv;
+  ++lv;
 
-   u.row.idx[j] = u.row.idx[m];
+  u.row.idx[j] = u.row.idx[m];
 
-   u.row.val[j] = u.row.val[m];
+  u.row.val[j] = u.row.val[m];
 
+  /*  update loop (I) and
+   *  computing expected fill
+   */
+  fill = u.row.len[prow];
 
-   /*  update loop (I) and
-    *  computing expected fill
-    */
-   fill = u.row.len[prow];
+  for (j = m - 1; j >= n; --j) {
+    c = u.row.idx[j];
 
-   for(j = m - 1; j >= n; --j)
-   {
-      c = u.row.idx[j];
+    if (temp.s_mark[c]) {
+      /*  count fill elements.
+       */
+      temp.s_mark[c] = 0;
+      --fill;
 
-      if(temp.s_mark[c])
-      {
-         /*  count fill elements.
-          */
-         temp.s_mark[c] = 0;
-         --fill;
-
-         /*  update row values
-          */
-         x = u.row.val[j] -= work[c] * lx;
-
-         if(x == 0)
-         {
-            /* Eliminate zero from row r
-             */
-            --u.row.len[r];
-            --m;
-            u.row.val[j] = u.row.val[m];
-            u.row.idx[j] = u.row.idx[m];
+      /*  update row values
+       */
+      x = u.row.val[j] -= work[c] * lx;
 
-            /* Eliminate zero from column c
-             */
-            --(temp.s_cact[c]);
-            k = --(u.col.len[c]) + u.col.start[c];
+      if (x == 0) {
+        /* Eliminate zero from row r
+         */
+        --u.row.len[r];
+        --m;
+        u.row.val[j] = u.row.val[m];
+        u.row.idx[j] = u.row.idx[m];
 
-            for(i = k; u.col.idx[i] != r; --i)
-               ;
+        /* Eliminate zero from column c
+         */
+        --(temp.s_cact[c]);
+        k = --(u.col.len[c]) + u.col.start[c];
 
-            u.col.idx[i] = u.col.idx[k];
-         }
-      }
-   }
+        for (i = k; u.col.idx[i] != r; --i)
+          ;
 
+        u.col.idx[i] = u.col.idx[k];
+      }
+    }
+  }
 
-   /*  create space for fill in row file
-    */
-   ll = u.row.len[r];
+  /*  create space for fill in row file
+   */
+  ll = u.row.len[r];
 
-   if(ll + fill > u.row.max[r])
-      remaxRow(r, ll + fill);
+  if (ll + fill > u.row.max[r])
+    remaxRow(r, ll + fill);
 
-   ll += u.row.start[r];
+  ll += u.row.start[r];
 
-   /*  fill creating update loop (II)
-    */
-   for(j = u.row.start[prow], m = j + u.row.len[prow]; j < m; ++j)
-   {
-      c = u.row.idx[j];
+  /*  fill creating update loop (II)
+   */
+  for (j = u.row.start[prow], m = j + u.row.len[prow]; j < m; ++j) {
+    c = u.row.idx[j];
 
-      if(temp.s_mark[c])
-      {
-         x = - work[c] * lx;
+    if (temp.s_mark[c]) {
+      x = -work[c] * lx;
 
-         if(x != 0)
-         {
-            /* produce fill element in row r
-             */
-            u.row.val[ll] = x;
-            u.row.idx[ll] = c;
-            ll++;
-            u.row.len[r]++;
+      if (x != 0) {
+        /* produce fill element in row r
+         */
+        u.row.val[ll] = x;
+        u.row.idx[ll] = c;
+        ll++;
+        u.row.len[r]++;
 
-            /* produce fill element in column c
-             */
+        /* produce fill element in column c
+         */
 
-            if(u.col.len[c] >= u.col.max[c])
-               remaxCol(c, u.col.len[c] + 1);
+        if (u.col.len[c] >= u.col.max[c])
+          remaxCol(c, u.col.len[c] + 1);
 
-            u.col.idx[u.col.start[c] + (u.col.len[c])++] = r;
+        u.col.idx[u.col.start[c] + (u.col.len[c])++] = r;
 
-            temp.s_cact[c]++;
-         }
+        temp.s_cact[c]++;
       }
-      else
-         temp.s_mark[c] = 1;
-   }
+    } else
+      temp.s_mark[c] = 1;
+  }
 
-   /*  move row to appropriate list.
-    */
-   removeDR(temp.pivot_row[r]);
+  /*  move row to appropriate list.
+   */
+  removeDR(temp.pivot_row[r]);
 
-   init2DR(temp.pivot_row[r], temp.pivot_rowNZ[u.row.len[r]]);
+  init2DR(temp.pivot_row[r], temp.pivot_rowNZ[u.row.len[r]]);
 
-   assert(row.perm[r] < 0);
+  assert(row.perm[r] < 0);
 
-   temp.s_max[r] = -1;
+  temp.s_max[r] = -1;
 
-   return lv;
+  return lv;
 }
 
 /*
  *      Eliminate pivot element
  */
-inline void CLUFactorRational::eliminatePivot(int prow, int pos)
-{
-   int i, j, k, m = -1;
-   int lv = -1;  // This value should never be used.
-   int pcol;
-   Rational pval;
-   int pbeg = u.row.start[prow];
-   int plen = --(u.row.len[prow]);
-   int pend = pbeg + plen;
-
-
-   /*  extract pivot element   */
-   i = pbeg + pos;
-   pcol = u.row.idx[i];
-   pval = u.row.val[i];
-   removeDR(temp.pivot_col[pcol]);
-   initDR(temp.pivot_col[pcol]);
-
-   /*  remove pivot from pivot row     */
-   u.row.idx[i] = u.row.idx[pend];
-   u.row.val[i] = u.row.val[pend];
-
-   /*  set pivot element and construct L vector */
-   setPivot(temp.stage++, pcol, prow, pval);
-
-   /**@todo If this test failes, lv has no value. I suppose that in this
-    *       case none of the loops below that uses lv is executed.
-    *       But this is unproven.
-    */
-
-   if(temp.s_cact[pcol] - 1 > 0)
-      lv = makeLvec(temp.s_cact[pcol] - 1, prow);
-
-   /*  init working vector,
-    *  remove pivot row from working matrix
-    *  and remove columns from list.
-    */
-   for(i = pbeg; i < pend; ++i)
-   {
-      j = u.row.idx[i];
-      temp.s_mark[j] = 1;
-      work[j] = u.row.val[i];
-      removeDR(temp.pivot_col[j]);
-      m = u.col.start[j] + u.col.len[j] - temp.s_cact[j];
-
-      for(k = m; u.col.idx[k] != prow; ++k)
-         ;
-
-      u.col.idx[k] = u.col.idx[m];
-
-      u.col.idx[m] = prow;
-
-      temp.s_cact[j]--;
-   }
-
-   /*  perform L and update loop
-    */
-   for(i = u.col.len[pcol] - temp.s_cact[pcol];
-         (m = u.col.idx[u.col.start[pcol] + i]) != prow;
-         ++i)
-   {
-      assert(row.perm[m] < 0);
-      assert(lv >= 0);
-      /* coverity[negative_returns] */
-      updateRow(m, lv++, prow, pcol, pval);
-   }
-
-   /*  skip pivot row  */
-
-   m = u.col.len[pcol];
-
-   for(++i; i < m; ++i)
-   {
-      assert(lv >= 0);
-      /* coverity[negative_returns] */
-      updateRow(u.col.idx[u.col.start[pcol] + i], lv++, prow, pcol, pval);
-   }
+inline void CLUFactorRational::eliminatePivot(int prow, int pos) {
+  int i, j, k, m = -1;
+  int lv = -1; // This value should never be used.
+  int pcol;
+  Rational pval;
+  int pbeg = u.row.start[prow];
+  int plen = --(u.row.len[prow]);
+  int pend = pbeg + plen;
+
+  /*  extract pivot element   */
+  i = pbeg + pos;
+  pcol = u.row.idx[i];
+  pval = u.row.val[i];
+  removeDR(temp.pivot_col[pcol]);
+  initDR(temp.pivot_col[pcol]);
+
+  /*  remove pivot from pivot row     */
+  u.row.idx[i] = u.row.idx[pend];
+  u.row.val[i] = u.row.val[pend];
+
+  /*  set pivot element and construct L vector */
+  setPivot(temp.stage++, pcol, prow, pval);
+
+  /**@todo If this test failes, lv has no value. I suppose that in this
+   *       case none of the loops below that uses lv is executed.
+   *       But this is unproven.
+   */
+
+  if (temp.s_cact[pcol] - 1 > 0)
+    lv = makeLvec(temp.s_cact[pcol] - 1, prow);
+
+  /*  init working vector,
+   *  remove pivot row from working matrix
+   *  and remove columns from list.
+   */
+  for (i = pbeg; i < pend; ++i) {
+    j = u.row.idx[i];
+    temp.s_mark[j] = 1;
+    work[j] = u.row.val[i];
+    removeDR(temp.pivot_col[j]);
+    m = u.col.start[j] + u.col.len[j] - temp.s_cact[j];
+
+    for (k = m; u.col.idx[k] != prow; ++k)
+      ;
 
-   /*  remove pivot column from column file.
-    */
-   u.col.len[pcol] -= temp.s_cact[pcol];
-
-   /*  clear working vector and reinsert columns to lists
-    */
-   for(i = u.row.start[prow], pend = i + plen; i < pend; ++i)
-   {
-      j = u.row.idx[i];
-      work[j] = 0;
-      temp.s_mark[j] = 0;
-      init2DR(temp.pivot_col[j], temp.pivot_colNZ[temp.s_cact[j]]);
-      assert(col.perm[j] < 0);
-   }
+    u.col.idx[k] = u.col.idx[m];
+
+    u.col.idx[m] = prow;
+
+    temp.s_cact[j]--;
+  }
+
+  /*  perform L and update loop
+   */
+  for (i = u.col.len[pcol] - temp.s_cact[pcol];
+       (m = u.col.idx[u.col.start[pcol] + i]) != prow; ++i) {
+    assert(row.perm[m] < 0);
+    assert(lv >= 0);
+    /* coverity[negative_returns] */
+    updateRow(m, lv++, prow, pcol, pval);
+  }
+
+  /*  skip pivot row  */
+
+  m = u.col.len[pcol];
+
+  for (++i; i < m; ++i) {
+    assert(lv >= 0);
+    /* coverity[negative_returns] */
+    updateRow(u.col.idx[u.col.start[pcol] + i], lv++, prow, pcol, pval);
+  }
+
+  /*  remove pivot column from column file.
+   */
+  u.col.len[pcol] -= temp.s_cact[pcol];
+
+  /*  clear working vector and reinsert columns to lists
+   */
+  for (i = u.row.start[prow], pend = i + plen; i < pend; ++i) {
+    j = u.row.idx[i];
+    work[j] = 0;
+    temp.s_mark[j] = 0;
+    init2DR(temp.pivot_col[j], temp.pivot_colNZ[temp.s_cact[j]]);
+    assert(col.perm[j] < 0);
+  }
 }
 
-
 /*
  *      Factorize nucleus.
  */
-inline void CLUFactorRational::eliminateNucleus(const Rational& threshold)
-{
-   int r, c;
-   CLUFactorRational::Pring* pivot;
+inline void CLUFactorRational::eliminateNucleus(const Rational &threshold) {
+  int r, c;
+  CLUFactorRational::Pring *pivot;
 
-   if(stat == SLinSolverRational::SINGULAR)
-      return;
+  if (stat == SLinSolverRational::SINGULAR)
+    return;
 
-   temp.pivots.mkwtz = -1;
+  temp.pivots.mkwtz = -1;
 
-   temp.pivots.idx = -1;
+  temp.pivots.idx = -1;
 
-   temp.pivots.pos = -1;
+  temp.pivots.pos = -1;
 
-   while(temp.stage < thedim - 1)
-   {
+  while (temp.stage < thedim - 1) {
 #ifndef NDEBUG
-      int i;
-      // CLUFactorRationalIsConsistent(fac);
+    int i;
+    // CLUFactorRationalIsConsistent(fac);
 
-      for(i = 0; i < thedim; ++i)
-         if(col.perm[i] < 0)
-            assert(temp.s_mark[i] == 0);
+    for (i = 0; i < thedim; ++i)
+      if (col.perm[i] < 0)
+        assert(temp.s_mark[i] == 0);
 
 #endif
 
-      if(temp.pivot_rowNZ[1].next != &(temp.pivot_rowNZ[1]))
-      {
-         if(timeLimitReached())
-            return;
-
-         /* row singleton available */
-         eliminateRowSingletons();
-      }
-      else if(temp.pivot_colNZ[1].next != &(temp.pivot_colNZ[1]))
-      {
-         if(timeLimitReached())
-            return;
+    if (temp.pivot_rowNZ[1].next != &(temp.pivot_rowNZ[1])) {
+      if (timeLimitReached())
+        return;
 
-         /* column singleton available */
-         eliminateColSingletons();
-      }
-      else
-      {
-         initDR(temp.pivots);
-         selectPivots(threshold);
+      /* row singleton available */
+      eliminateRowSingletons();
+    } else if (temp.pivot_colNZ[1].next != &(temp.pivot_colNZ[1])) {
+      if (timeLimitReached())
+        return;
 
-         assert(temp.pivots.next != &temp.pivots &&
-                "ERROR: no pivot element selected");
+      /* column singleton available */
+      eliminateColSingletons();
+    } else {
+      initDR(temp.pivots);
+      selectPivots(threshold);
 
-         for(pivot = temp.pivots.next; pivot != &temp.pivots;
-               pivot = pivot->next)
-         {
-            if(timeLimitReached())
-               return;
+      assert(temp.pivots.next != &temp.pivots &&
+             "ERROR: no pivot element selected");
 
-            eliminatePivot(pivot->idx, pivot->pos);
-         }
-      }
+      for (pivot = temp.pivots.next; pivot != &temp.pivots;
+           pivot = pivot->next) {
+        if (timeLimitReached())
+          return;
 
-      if(temp.pivot_rowNZ->next != temp.pivot_rowNZ ||
-            temp.pivot_colNZ->next != temp.pivot_colNZ)
-      {
-         stat = SLinSolverRational::SINGULAR;
-         return;
+        eliminatePivot(pivot->idx, pivot->pos);
       }
-   }
+    }
 
-   if(temp.stage < thedim)
-   {
-      /*      Eliminate remaining element.
-       *      Note, that this must be both, column and row singleton.
-       */
-      assert(temp.pivot_rowNZ[1].next != &(temp.pivot_rowNZ[1]) &&
-             "ERROR: one row must be left");
-      assert(temp.pivot_colNZ[1].next != &(temp.pivot_colNZ[1]) &&
-             "ERROR: one col must be left");
-      r = temp.pivot_rowNZ[1].next->idx;
-      c = temp.pivot_colNZ[1].next->idx;
-      u.row.len[r] = 0;
-      u.col.len[c]--;
-      setPivot(temp.stage, c, r, u.row.val[u.row.start[r]]);
-   }
+    if (temp.pivot_rowNZ->next != temp.pivot_rowNZ ||
+        temp.pivot_colNZ->next != temp.pivot_colNZ) {
+      stat = SLinSolverRational::SINGULAR;
+      return;
+    }
+  }
+
+  if (temp.stage < thedim) {
+    /*      Eliminate remaining element.
+     *      Note, that this must be both, column and row singleton.
+     */
+    assert(temp.pivot_rowNZ[1].next != &(temp.pivot_rowNZ[1]) &&
+           "ERROR: one row must be left");
+    assert(temp.pivot_colNZ[1].next != &(temp.pivot_colNZ[1]) &&
+           "ERROR: one col must be left");
+    r = temp.pivot_rowNZ[1].next->idx;
+    c = temp.pivot_colNZ[1].next->idx;
+    u.row.len[r] = 0;
+    u.col.len[c]--;
+    setPivot(temp.stage, c, r, u.row.val[u.row.start[r]]);
+  }
 }
 
 /*****************************************************************************/
 
-inline int CLUFactorRational::setupColVals()
-{
-   int i;
-   int n = thedim;
+inline int CLUFactorRational::setupColVals() {
+  int i;
+  int n = thedim;
 
-   u.col.val.reDim(u.col.size);
+  u.col.val.reDim(u.col.size);
 
-   for(i = 0; i < thedim; i++)
-      u.col.len[i] = 0;
+  for (i = 0; i < thedim; i++)
+    u.col.len[i] = 0;
 
-   maxabs = 0;
+  maxabs = 0;
 
-   for(i = 0; i < thedim; i++)
-   {
-      int     k   = u.row.start[i];
-      int*    idx = &u.row.idx[k];
-      Rational*   val = &u.row.val[k];
-      int     len = u.row.len[i];
+  for (i = 0; i < thedim; i++) {
+    int k = u.row.start[i];
+    int *idx = &u.row.idx[k];
+    Rational *val = &u.row.val[k];
+    int len = u.row.len[i];
 
-      n += len;
+    n += len;
 
-      while(len-- > 0)
-      {
-         assert((*idx >= 0) && (*idx < thedim));
+    while (len-- > 0) {
+      assert((*idx >= 0) && (*idx < thedim));
 
-         k = u.col.start[*idx] + u.col.len[*idx];
+      k = u.col.start[*idx] + u.col.len[*idx];
 
-         assert((k >= 0) && (k < u.col.size));
+      assert((k >= 0) && (k < u.col.size));
 
-         u.col.len[*idx]++;
+      u.col.len[*idx]++;
 
-         assert(u.col.len[*idx] <= u.col.max[*idx]);
+      assert(u.col.len[*idx] <= u.col.max[*idx]);
 
-         u.col.idx[k] = i;
-         u.col.val[k] = *val;
+      u.col.idx[k] = i;
+      u.col.val[k] = *val;
 
-         if(spxAbs(*val) > maxabs)
-            maxabs = spxAbs(*val);
+      if (spxAbs(*val) > maxabs)
+        maxabs = spxAbs(*val);
 
-         idx++;
+      idx++;
 
-         val++;
-      }
-   }
+      val++;
+    }
+  }
 
-   return n;
+  return n;
 }
 
 /*****************************************************************************/
 
 #ifdef WITH_L_ROWS
-inline void CLUFactorRational::setupRowVals()
-{
-   int   i, j, k, m;
-   int   vecs, mem;
-   int*  l_row;
-   int*  idx;
-   int*  beg;
-   int*  l_ridx;
-   int*  l_rbeg;
-   int*  rorig;
-   int*  rrorig;
-   int*  rperm;
-   int*  rrperm;
+inline void CLUFactorRational::setupRowVals() {
+  int i, j, k, m;
+  int vecs, mem;
+  int *l_row;
+  int *idx;
+  int *beg;
+  int *l_ridx;
+  int *l_rbeg;
+  int *rorig;
+  int *rrorig;
+  int *rperm;
+  int *rrperm;
 
-   vecs  = l.firstUpdate;
-   l_row = l.row;
-   idx   = l.idx;
-   VectorRational& val = l.val;
-   int validx = 0;
-   beg   = l.start;
-   mem   = beg[vecs];
+  vecs = l.firstUpdate;
+  l_row = l.row;
+  idx = l.idx;
+  VectorRational &val = l.val;
+  int validx = 0;
+  beg = l.start;
+  mem = beg[vecs];
 
-   if(l.ridx)
-      spx_free(l.ridx);
+  if (l.ridx)
+    spx_free(l.ridx);
 
-   if(l.rbeg)
-      spx_free(l.rbeg);
+  if (l.rbeg)
+    spx_free(l.rbeg);
 
-   if(l.rorig)
-      spx_free(l.rorig);
+  if (l.rorig)
+    spx_free(l.rorig);
 
-   if(l.rperm)
-      spx_free(l.rperm);
+  if (l.rperm)
+    spx_free(l.rperm);
 
-   l.rval.reDim(mem);
+  l.rval.reDim(mem);
 
-   spx_alloc(l.ridx, mem);
+  spx_alloc(l.ridx, mem);
 
-   spx_alloc(l.rbeg, thedim + 1);
+  spx_alloc(l.rbeg, thedim + 1);
 
-   spx_alloc(l.rorig, thedim);
+  spx_alloc(l.rorig, thedim);
 
-   spx_alloc(l.rperm, thedim);
+  spx_alloc(l.rperm, thedim);
 
-   l_ridx = l.ridx;
+  l_ridx = l.ridx;
 
-   VectorRational& l_rval = l.rval;
+  VectorRational &l_rval = l.rval;
 
-   l_rbeg = l.rbeg;
+  l_rbeg = l.rbeg;
 
-   rorig  = l.rorig;
+  rorig = l.rorig;
 
-   rrorig = row.orig;
+  rrorig = row.orig;
 
-   rperm  = l.rperm;
+  rperm = l.rperm;
 
-   rrperm = row.perm;
+  rrperm = row.perm;
 
-   for(i = thedim; i--; *l_rbeg++ = 0)
-   {
-      *rorig++ = *rrorig++;
-      *rperm++ = *rrperm++;
-   }
+  for (i = thedim; i--; *l_rbeg++ = 0) {
+    *rorig++ = *rrorig++;
+    *rperm++ = *rrperm++;
+  }
 
-   *l_rbeg = 0;
+  *l_rbeg = 0;
 
-   l_rbeg = l.rbeg + 1;
+  l_rbeg = l.rbeg + 1;
 
-   for(i = mem; i--;)
-      l_rbeg[*idx++]++;
+  for (i = mem; i--;)
+    l_rbeg[*idx++]++;
 
-   idx = l.idx;
+  idx = l.idx;
 
-   for(m = 0, i = thedim; i--; l_rbeg++)
-   {
-      j = *l_rbeg;
-      *l_rbeg = m;
-      m += j;
-   }
+  for (m = 0, i = thedim; i--; l_rbeg++) {
+    j = *l_rbeg;
+    *l_rbeg = m;
+    m += j;
+  }
 
-   assert(m == mem);
+  assert(m == mem);
 
-   l_rbeg = l.rbeg + 1;
+  l_rbeg = l.rbeg + 1;
 
-   for(i = j = 0; i < vecs; ++i)
-   {
-      m = l_row[i];
-      assert(idx == &l.idx[l.start[i]]);
+  for (i = j = 0; i < vecs; ++i) {
+    m = l_row[i];
+    assert(idx == &l.idx[l.start[i]]);
 
-      for(; j < beg[i + 1]; j++)
-      {
-         k = l_rbeg[*idx++]++;
-         assert(k < mem);
-         l_ridx[k] = m;
-         l_rval[k] = val[validx];
-         validx++; // was l_rval[k] = *val++; with Rational* val
-      }
-   }
+    for (; j < beg[i + 1]; j++) {
+      k = l_rbeg[*idx++]++;
+      assert(k < mem);
+      l_ridx[k] = m;
+      l_rval[k] = val[validx];
+      validx++; // was l_rval[k] = *val++; with Rational* val
+    }
+  }
 
-   assert(l.rbeg[thedim] == mem);
+  assert(l.rbeg[thedim] == mem);
 
-   assert(l.rbeg[0] == 0);
+  assert(l.rbeg[0] == 0);
 }
 
 #endif
@@ -2755,3255 +2511,2874 @@ inline void CLUFactorRational::setupRowVals()
 /*****************************************************************************/
 
 inline void CLUFactorRational::factor(
-   const SVectorRational** vec,         ///< Array of column vector pointers
-   const Rational& threshold            ///< pivoting threshold
-)
-{
-   MSG_DEBUG(std::cout << "CLUFactorRational::factor()\n");
+    const SVectorRational **vec, ///< Array of column vector pointers
+    const Rational &threshold    ///< pivoting threshold
+) {
+  MSG_DEBUG(std::cout << "CLUFactorRational::factor()\n");
 
-   factorTime->start();
+  factorTime->start();
 
-   stat = SLinSolverRational::OK;
+  stat = SLinSolverRational::OK;
 
-   l.start[0]    = 0;
-   l.firstUpdate = 0;
-   l.firstUnused = 0;
+  l.start[0] = 0;
+  l.firstUpdate = 0;
+  l.firstUnused = 0;
 
-   temp.init(thedim);
-   initPerm();
+  temp.init(thedim);
+  initPerm();
 
-   initFactorMatrix(vec);
+  initFactorMatrix(vec);
 
-   if(stat)
-      goto TERMINATE;
+  if (stat)
+    goto TERMINATE;
 
-   if(timeLimitReached())
-      goto TERMINATE;
+  if (timeLimitReached())
+    goto TERMINATE;
 
-   //   initMaxabs = initMaxabs;
+  //   initMaxabs = initMaxabs;
 
-   colSingletons();
+  colSingletons();
 
-   if(stat != SLinSolverRational::OK)
-      goto TERMINATE;
+  if (stat != SLinSolverRational::OK)
+    goto TERMINATE;
 
-   if(timeLimitReached())
-      goto TERMINATE;
+  if (timeLimitReached())
+    goto TERMINATE;
 
-   rowSingletons();
+  rowSingletons();
 
-   if(stat != SLinSolverRational::OK)
-      goto TERMINATE;
+  if (stat != SLinSolverRational::OK)
+    goto TERMINATE;
 
-   if(temp.stage < thedim)
-   {
-      if(timeLimitReached())
-         goto TERMINATE;
+  if (temp.stage < thedim) {
+    if (timeLimitReached())
+      goto TERMINATE;
 
-      initFactorRings();
-      eliminateNucleus(threshold);
-      freeFactorRings();
-   }
+    initFactorRings();
+    eliminateNucleus(threshold);
+    freeFactorRings();
+  }
 
 TERMINATE:
 
-   l.firstUpdate = l.firstUnused;
+  l.firstUpdate = l.firstUnused;
 
-   if(stat == SLinSolverRational::OK)
-   {
+  if (stat == SLinSolverRational::OK) {
 #ifdef WITH_L_ROWS
-      setupRowVals();
+    setupRowVals();
 #endif
-      nzCnt = setupColVals();
-   }
+    nzCnt = setupColVals();
+  }
 
-   factorTime->stop();
+  factorTime->stop();
 
-   factorCount++;
+  factorCount++;
 }
 
-inline void CLUFactorRational::dump() const
-{
-   int i, j, k;
+inline void CLUFactorRational::dump() const {
+  int i, j, k;
 
-   // Dump regardless of the verbosity level if this method is called;
+  // Dump regardless of the verbosity level if this method is called;
 
-   /*  Dump U:
-    */
+  /*  Dump U:
+   */
 
-   for(i = 0; i < thedim; ++i)
-   {
-      if(row.perm[i] >= 0)
-         std::cout << "DCLUFA01 diag[" << i << "]: [" << col.orig[row.perm[i]]
-                   << "] = " << diag[i] << std::endl;
+  for (i = 0; i < thedim; ++i) {
+    if (row.perm[i] >= 0)
+      std::cout << "DCLUFA01 diag[" << i << "]: [" << col.orig[row.perm[i]]
+                << "] = " << diag[i] << std::endl;
 
-      for(j = 0; j < u.row.len[i]; ++j)
-         std::cout << "DCLUFA02   u[" << i << "]: ["
-                   << u.row.idx[u.row.start[i] + j] << "] = "
-                   << u.row.val[u.row.start[i] + j] << std::endl;
-   }
+    for (j = 0; j < u.row.len[i]; ++j)
+      std::cout << "DCLUFA02   u[" << i << "]: ["
+                << u.row.idx[u.row.start[i] + j]
+                << "] = " << u.row.val[u.row.start[i] + j] << std::endl;
+  }
 
-   /*  Dump L:
-    */
-   for(i = 0; i < thedim; ++i)
-   {
-      for(j = 0; j < l.firstUnused; ++j)
-         if(col.orig[row.perm[l.row[j]]] == i)
-         {
-            std::cout << "DCLUFA03 l[" << i << "]" << std::endl;
+  /*  Dump L:
+   */
+  for (i = 0; i < thedim; ++i) {
+    for (j = 0; j < l.firstUnused; ++j)
+      if (col.orig[row.perm[l.row[j]]] == i) {
+        std::cout << "DCLUFA03 l[" << i << "]" << std::endl;
 
-            for(k = l.start[j]; k < l.start[j + 1]; ++k)
-               std::cout << "DCLUFA04   l[" << k - l.start[j]
-                         << "]:  [" << l.idx[k]
-                         << "] = "  << l.val[k] << std::endl;
+        for (k = l.start[j]; k < l.start[j + 1]; ++k)
+          std::cout << "DCLUFA04   l[" << k - l.start[j] << "]:  [" << l.idx[k]
+                    << "] = " << l.val[k] << std::endl;
 
-            break;
-         }
-   }
+        break;
+      }
+  }
 
-   return;
+  return;
 }
 
 /*****************************************************************************/
 /*
  *      Ensure that row memory is at least size.
  */
-inline void CLUFactorRational::minRowMem(int size)
-{
-   if(u.row.val.dim() < size)
-   {
-      u.row.val.reDim(size);
-      spx_realloc(u.row.idx, size);
-   }
+inline void CLUFactorRational::minRowMem(int size) {
+  if (u.row.val.dim() < size) {
+    u.row.val.reDim(size);
+    spx_realloc(u.row.idx, size);
+  }
 
-   assert(u.row.val.dim() >= size);
+  assert(u.row.val.dim() >= size);
 }
 
 /*****************************************************************************/
 /*
  *      Ensure that column memory is at least size.
  */
-inline void CLUFactorRational::minColMem(int size)
-{
+inline void CLUFactorRational::minColMem(int size) {
 
-   if(u.col.size < size)
-   {
-      u.col.size = size;
-      spx_realloc(u.col.idx, size);
-   }
+  if (u.col.size < size) {
+    u.col.size = size;
+    spx_realloc(u.col.idx, size);
+  }
 }
 
-inline void CLUFactorRational::forestMinColMem(int size)
-{
+inline void CLUFactorRational::forestMinColMem(int size) {
 
-   if(u.col.size < size)
-   {
-      u.col.size = size;
-      spx_realloc(u.col.idx, size);
-      u.col.val.reDim(size);
-   }
+  if (u.col.size < size) {
+    u.col.size = size;
+    spx_realloc(u.col.idx, size);
+    u.col.val.reDim(size);
+  }
 }
 
-inline void CLUFactorRational::minLMem(int size)
-{
+inline void CLUFactorRational::minLMem(int size) {
 
-   if(size > l.val.dim())
-   {
-      int newsize = int(0.2 * l.val.dim() + size);
-      l.val.reDim(newsize);
-      spx_realloc(l.idx, l.val.dim());
-   }
+  if (size > l.val.dim()) {
+    int newsize = int(0.2 * l.val.dim() + size);
+    l.val.reDim(newsize);
+    spx_realloc(l.idx, l.val.dim());
+  }
 }
 
+inline int CLUFactorRational::makeLvec(int p_len, int p_row) {
 
-inline int CLUFactorRational::makeLvec(int p_len, int p_row)
-{
-
-   if(l.firstUnused >= l.startSize)
-   {
-      l.startSize += 100;
-      spx_realloc(l.start, l.startSize);
-   }
+  if (l.firstUnused >= l.startSize) {
+    l.startSize += 100;
+    spx_realloc(l.start, l.startSize);
+  }
 
-   int* p_lrow = l.row;
+  int *p_lrow = l.row;
 
-   int* p_lbeg = l.start;
-   int first   = p_lbeg[l.firstUnused];
+  int *p_lbeg = l.start;
+  int first = p_lbeg[l.firstUnused];
 
-   assert(p_len > 0 && "ERROR: no empty columns allowed in L vectors");
+  assert(p_len > 0 && "ERROR: no empty columns allowed in L vectors");
 
-   minLMem(first + p_len);
-   p_lrow[l.firstUnused] = p_row;
-   l.start[++(l.firstUnused)] = first + p_len;
+  minLMem(first + p_len);
+  p_lrow[l.firstUnused] = p_row;
+  l.start[++(l.firstUnused)] = first + p_len;
 
-   assert(l.start[l.firstUnused] <= l.val.dim());
-   assert(l.firstUnused <= l.startSize);
-   return first;
+  assert(l.start[l.firstUnused] <= l.val.dim());
+  assert(l.firstUnused <= l.startSize);
+  return first;
 }
 
-
 /*****************************************************************************/
 
-inline bool CLUFactorRational::isConsistent() const
-{
+inline bool CLUFactorRational::isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
-   int              i, j, k, ll;
-   Dring*            ring;
-   CLUFactorRational::Pring* pring;
+  int i, j, k, ll;
+  Dring *ring;
+  CLUFactorRational::Pring *pring;
 
-   /*  Consistency only relevant for real factorizations
-    */
+  /*  Consistency only relevant for real factorizations
+   */
 
-   if(stat)
-      return true;
+  if (stat)
+    return true;
 
-   /*  Test column ring list consistency.
-    */
-   i = 0;
+  /*  Test column ring list consistency.
+   */
+  i = 0;
 
-   for(ring = u.col.list.next; ring != &(u.col.list); ring = ring->next)
-   {
-      assert(ring->idx >= 0);
-      assert(ring->idx < thedim);
-      assert(ring->prev->next == ring);
+  for (ring = u.col.list.next; ring != &(u.col.list); ring = ring->next) {
+    assert(ring->idx >= 0);
+    assert(ring->idx < thedim);
+    assert(ring->prev->next == ring);
 
-      if(ring != u.col.list.next)
-      {
-         assert(u.col.start[ring->prev->idx] + u.col.max[ring->prev->idx]
-                == u.col.start[ring->idx]);
-      }
+    if (ring != u.col.list.next) {
+      assert(u.col.start[ring->prev->idx] + u.col.max[ring->prev->idx] ==
+             u.col.start[ring->idx]);
+    }
 
-      ++i;
-   }
+    ++i;
+  }
 
-   assert(i == thedim);
+  assert(i == thedim);
 
-   assert(u.col.start[ring->prev->idx] + u.col.max[ring->prev->idx]
-          == u.col.used);
+  assert(u.col.start[ring->prev->idx] + u.col.max[ring->prev->idx] ==
+         u.col.used);
 
+  /*  Test row ring list consistency.
+   */
+  i = 0;
 
-   /*  Test row ring list consistency.
-    */
-   i = 0;
+  for (ring = u.row.list.next; ring != &(u.row.list); ring = ring->next) {
+    assert(ring->idx >= 0);
+    assert(ring->idx < thedim);
+    assert(ring->prev->next == ring);
+    assert(u.row.start[ring->prev->idx] + u.row.max[ring->prev->idx] ==
+           u.row.start[ring->idx]);
+    ++i;
+  }
 
-   for(ring = u.row.list.next; ring != &(u.row.list); ring = ring->next)
-   {
-      assert(ring->idx >= 0);
-      assert(ring->idx < thedim);
-      assert(ring->prev->next == ring);
-      assert(u.row.start[ring->prev->idx] + u.row.max[ring->prev->idx]
-             == u.row.start[ring->idx]);
-      ++i;
-   }
+  assert(i == thedim);
 
-   assert(i == thedim);
+  assert(u.row.start[ring->prev->idx] + u.row.max[ring->prev->idx] ==
+         u.row.used);
 
-   assert(u.row.start[ring->prev->idx] + u.row.max[ring->prev->idx]
-          == u.row.used);
+  /*  Test consistency of individual svectors.
+   */
 
+  for (i = 0; i < thedim; ++i) {
+    assert(u.row.max[i] >= u.row.len[i]);
+    assert(u.col.max[i] >= u.col.len[i]);
+  }
 
-   /*  Test consistency of individual svectors.
-    */
+  /*  Test consistency of column file to row file of U
+   */
+  for (i = 0; i < thedim; ++i) {
+    for (j = u.row.start[i] + u.row.len[i] - 1; j >= u.row.start[i]; j--) {
+      k = u.row.idx[j];
 
-   for(i = 0; i < thedim; ++i)
-   {
-      assert(u.row.max[i] >= u.row.len[i]);
-      assert(u.col.max[i] >= u.col.len[i]);
-   }
+      for (ll = u.col.start[k] + u.col.len[k] - 1; ll >= u.col.start[k]; ll--) {
+        if (u.col.idx[ll] == i)
+          break;
+      }
 
+      assert(u.col.idx[ll] == i);
 
-   /*  Test consistency of column file to row file of U
-    */
-   for(i = 0; i < thedim; ++i)
-   {
-      for(j = u.row.start[i] + u.row.len[i] - 1; j >= u.row.start[i]; j--)
-      {
-         k = u.row.idx[j];
-
-         for(ll = u.col.start[k] + u.col.len[k] - 1; ll >= u.col.start[k]; ll--)
-         {
-            if(u.col.idx[ll] == i)
-               break;
-         }
-
-         assert(u.col.idx[ll] == i);
-
-         if(row.perm[i] < 0)
-         {
-            assert(col.perm[k] < 0);
-         }
-         else
-         {
-            assert(col.perm[k] < 0 || col.perm[k] > row.perm[i]);
-         }
+      if (row.perm[i] < 0) {
+        assert(col.perm[k] < 0);
+      } else {
+        assert(col.perm[k] < 0 || col.perm[k] > row.perm[i]);
       }
-   }
+    }
+  }
 
-   /*  Test consistency of row file to column file of U
-    */
-   for(i = 0; i < thedim; ++i)
-   {
-      for(j = u.col.start[i] + u.col.len[i] - 1; j >= u.col.start[i]; j--)
-      {
-         k = u.col.idx[j];
+  /*  Test consistency of row file to column file of U
+   */
+  for (i = 0; i < thedim; ++i) {
+    for (j = u.col.start[i] + u.col.len[i] - 1; j >= u.col.start[i]; j--) {
+      k = u.col.idx[j];
 
-         for(ll = u.row.start[k] + u.row.len[k] - 1; ll >= u.row.start[k]; ll--)
-         {
-            if(u.row.idx[ll] == i)
-               break;
-         }
+      for (ll = u.row.start[k] + u.row.len[k] - 1; ll >= u.row.start[k]; ll--) {
+        if (u.row.idx[ll] == i)
+          break;
+      }
 
-         assert(u.row.idx[ll] == i);
+      assert(u.row.idx[ll] == i);
 
-         assert(col.perm[i] < 0 || row.perm[k] < col.perm[i]);
+      assert(col.perm[i] < 0 || row.perm[k] < col.perm[i]);
+    }
+  }
+
+  /*  Test consistency of nonzero count lists
+   */
+  if (temp.pivot_colNZ && temp.pivot_rowNZ) {
+    for (i = 0; i < thedim - temp.stage; ++i) {
+      for (pring = temp.pivot_rowNZ[i].next; pring != &(temp.pivot_rowNZ[i]);
+           pring = pring->next) {
+        assert(row.perm[pring->idx] < 0);
       }
-   }
 
-   /*  Test consistency of nonzero count lists
-    */
-   if(temp.pivot_colNZ && temp.pivot_rowNZ)
-   {
-      for(i = 0; i < thedim - temp.stage; ++i)
-      {
-         for(pring = temp.pivot_rowNZ[i].next; pring != &(temp.pivot_rowNZ[i]); pring = pring->next)
-         {
-            assert(row.perm[pring->idx] < 0);
-         }
-
-         for(pring = temp.pivot_colNZ[i].next; pring != &(temp.pivot_colNZ[i]); pring = pring->next)
-         {
-            assert(col.perm[pring->idx] < 0);
-         }
+      for (pring = temp.pivot_colNZ[i].next; pring != &(temp.pivot_colNZ[i]);
+           pring = pring->next) {
+        assert(col.perm[pring->idx] < 0);
       }
-   }
+    }
+  }
 
 #endif // CONSISTENCY_CHECKS
 
-   return true;
+  return true;
 }
 
-inline void CLUFactorRational::solveUright(Rational* wrk, Rational* vec)
-{
+inline void CLUFactorRational::solveUright(Rational *wrk, Rational *vec) {
 
-   for(int i = thedim - 1; i >= 0; i--)
-   {
-      int  r = row.orig[i];
-      int  c = col.orig[i];
-      Rational x = wrk[c] = diag[r] * vec[r];
+  for (int i = thedim - 1; i >= 0; i--) {
+    int r = row.orig[i];
+    int c = col.orig[i];
+    Rational x = wrk[c] = diag[r] * vec[r];
 
-      vec[r] = 0;
+    vec[r] = 0;
 
-      if(x != 0)
-         //if (isNotZero(x))
-      {
-         if(timeLimitReached())
-            return;
+    if (x != 0)
+    // if (isNotZero(x))
+    {
+      if (timeLimitReached())
+        return;
 
-         for(int j = u.col.start[c]; j < u.col.start[c] + u.col.len[c]; j++)
-            vec[u.col.idx[j]] -= x * u.col.val[j];
-      }
-   }
+      for (int j = u.col.start[c]; j < u.col.start[c] + u.col.len[c]; j++)
+        vec[u.col.idx[j]] -= x * u.col.val[j];
+    }
+  }
 }
 
-inline int CLUFactorRational::solveUrightEps(Rational* vec, int* nonz, Rational* rhs)
-{
-   int i, j, r, c, n;
-   int* rorig, *corig;
-   int* cidx, *clen, *cbeg;
-   Rational x;
+inline int CLUFactorRational::solveUrightEps(Rational *vec, int *nonz,
+                                             Rational *rhs) {
+  int i, j, r, c, n;
+  int *rorig, *corig;
+  int *cidx, *clen, *cbeg;
+  Rational x;
 
-   int* idx;
-   Rational* val;
+  int *idx;
+  Rational *val;
 
-   rorig = row.orig;
-   corig = col.orig;
+  rorig = row.orig;
+  corig = col.orig;
 
-   cidx = u.col.idx;
-   VectorRational& cval = u.col.val;
-   clen = u.col.len;
-   cbeg = u.col.start;
+  cidx = u.col.idx;
+  VectorRational &cval = u.col.val;
+  clen = u.col.len;
+  cbeg = u.col.start;
 
-   n = 0;
+  n = 0;
 
-   for(i = thedim - 1; i >= 0; --i)
-   {
-      r = rorig[i];
-      x = diag[r] * rhs[r];
+  for (i = thedim - 1; i >= 0; --i) {
+    r = rorig[i];
+    x = diag[r] * rhs[r];
 
-      if(x != 0)
-      {
-         c = corig[i];
-         vec[c] = x;
-         nonz[n++] = c;
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
-
-         while(j-- > 0)
-            rhs[*idx++] -= x * (*val++);
+    if (x != 0) {
+      c = corig[i];
+      vec[c] = x;
+      nonz[n++] = c;
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0)
+        rhs[*idx++] -= x * (*val++);
+    }
+  }
+
+  return n;
+}
+
+inline void CLUFactorRational::solveUright2(Rational *p_work1, Rational *vec1,
+                                            Rational *p_work2, Rational *vec2) {
+  int i, j, r, c;
+  int *rorig, *corig;
+  int *cidx, *clen, *cbeg;
+  Rational x1, x2;
+
+  int *idx;
+  Rational *val;
+
+  rorig = row.orig;
+  corig = col.orig;
+
+  cidx = u.col.idx;
+  VectorRational &cval = u.col.val;
+  clen = u.col.len;
+  cbeg = u.col.start;
+
+  for (i = thedim - 1; i >= 0; --i) {
+    r = rorig[i];
+    c = corig[i];
+    p_work1[c] = x1 = diag[r] * vec1[r];
+    p_work2[c] = x2 = diag[r] * vec2[r];
+    vec1[r] = vec2[r] = 0;
+
+    if (x1 != 0 && x2 != 0) {
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0) {
+        vec1[*idx] -= x1 * (*val);
+        vec2[*idx++] -= x2 * (*val++);
       }
-   }
+    } else if (x1 != 0) {
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0)
+        vec1[*idx++] -= x1 * (*val++);
+    } else if (x2 != 0) {
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0)
+        vec2[*idx++] -= x2 * (*val++);
+    }
+  }
+}
 
-   return n;
+inline int CLUFactorRational::solveUright2eps(Rational *p_work1, Rational *vec1,
+                                              Rational *p_work2, Rational *vec2,
+                                              int *nonz) {
+  int i, j, r, c, n;
+  int *rorig, *corig;
+  int *cidx, *clen, *cbeg;
+  bool notzero1, notzero2;
+  Rational x1, x2;
+
+  int *idx;
+  Rational *val;
+
+  rorig = row.orig;
+  corig = col.orig;
+
+  cidx = u.col.idx;
+  VectorRational &cval = u.col.val;
+  clen = u.col.len;
+  cbeg = u.col.start;
+
+  n = 0;
+
+  for (i = thedim - 1; i >= 0; --i) {
+    c = corig[i];
+    r = rorig[i];
+    p_work1[c] = x1 = diag[r] * vec1[r];
+    p_work2[c] = x2 = diag[r] * vec2[r];
+    vec1[r] = vec2[r] = 0;
+    notzero1 = x1 != 0 ? 1 : 0;
+    notzero2 = x2 != 0 ? 1 : 0;
+
+    if (notzero1 && notzero2) {
+      *nonz++ = c;
+      n++;
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0) {
+        vec1[*idx] -= x1 * (*val);
+        vec2[*idx++] -= x2 * (*val++);
+      }
+    } else if (notzero1) {
+      p_work2[c] = 0;
+      *nonz++ = c;
+      n++;
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0)
+        vec1[*idx++] -= x1 * (*val++);
+    } else if (notzero2) {
+      p_work1[c] = 0;
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0)
+        vec2[*idx++] -= x2 * (*val++);
+    } else {
+      p_work1[c] = 0;
+      p_work2[c] = 0;
+    }
+  }
+
+  return n;
 }
 
-inline void CLUFactorRational::solveUright2(Rational* p_work1, Rational* vec1, Rational* p_work2,
-      Rational* vec2)
-{
-   int i, j, r, c;
-   int* rorig, *corig;
-   int* cidx, *clen, *cbeg;
-   Rational x1, x2;
+inline void CLUFactorRational::solveLright(Rational *vec) {
+  int i, j, k;
+  int end;
+  Rational x;
+  Rational *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
 
-   int* idx;
-   Rational* val;
+  VectorRational &lval = l.val;
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
 
-   rorig = row.orig;
-   corig = col.orig;
+  end = l.firstUpdate;
 
-   cidx = u.col.idx;
-   VectorRational& cval = u.col.val;
-   clen = u.col.len;
-   cbeg = u.col.start;
+  for (i = 0; i < end; ++i) {
+    if ((x = vec[lrow[i]]) != 0) {
+      if (timeLimitReached())
+        return;
 
-   for(i = thedim - 1; i >= 0; --i)
-   {
-      r = rorig[i];
-      c = corig[i];
-      p_work1[c] = x1 = diag[r] * vec1[r];
-      p_work2[c] = x2 = diag[r] * vec2[r];
-      vec1[r] = vec2[r] = 0;
+      MSG_DEBUG(std::cout << "y" << lrow[i] << "=" << vec[lrow[i]]
+                          << std::endl;)
 
-      if(x1 != 0 && x2 != 0)
-      {
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
-
-         while(j-- > 0)
-         {
-            vec1[*idx] -= x1 * (*val);
-            vec2[*idx++] -= x2 * (*val++);
-         }
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
+
+      for (j = lbeg[i + 1]; j > k; --j) {
+        MSG_DEBUG(std::cout << "                         -> y" << *idx
+                            << " -= " << x << " * " << *val << " = "
+                            << x * (*val) << "    -> " << vec[*idx] - x * (*val)
+                            << std::endl;)
+        vec[*idx++] -= x * (*val++);
       }
-      else if(x1 != 0)
-      {
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
+    }
+  }
 
-         while(j-- > 0)
-            vec1[*idx++] -= x1 * (*val++);
-      }
-      else if(x2 != 0)
-      {
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
+  if (l.updateType) /* Forest-Tomlin Updates */
+  {
+    MSG_DEBUG(std::cout << "performing FT updates..." << std::endl;)
 
-         while(j-- > 0)
-            vec2[*idx++] -= x2 * (*val++);
-      }
-   }
-}
+    end = l.firstUnused;
 
-inline int CLUFactorRational::solveUright2eps(Rational* p_work1, Rational* vec1, Rational* p_work2,
-      Rational* vec2, int* nonz)
-{
-   int i, j, r, c, n;
-   int* rorig, *corig;
-   int* cidx, *clen, *cbeg;
-   bool notzero1, notzero2;
-   Rational x1, x2;
+    for (; i < end; ++i) {
+      x = 0;
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-   int* idx;
-   Rational* val;
+      for (j = lbeg[i + 1]; j > k; --j)
+        x += vec[*idx++] * (*val++);
 
-   rorig = row.orig;
-   corig = col.orig;
+      vec[lrow[i]] -= x;
 
-   cidx = u.col.idx;
-   VectorRational& cval = u.col.val;
-   clen = u.col.len;
-   cbeg = u.col.start;
+      MSG_DEBUG(std::cout << "y" << lrow[i] << "=" << vec[lrow[i]]
+                          << std::endl;)
+    }
 
-   n = 0;
+    MSG_DEBUG(std::cout << "finished FT updates." << std::endl;)
+  }
+}
 
-   for(i = thedim - 1; i >= 0; --i)
-   {
-      c = corig[i];
-      r = rorig[i];
-      p_work1[c] = x1 = diag[r] * vec1[r];
-      p_work2[c] = x2 = diag[r] * vec2[r];
-      vec1[r] = vec2[r] = 0;
-      notzero1 = x1 != 0 ? 1 : 0;
-      notzero2 = x2 != 0 ? 1 : 0;
+inline void CLUFactorRational::solveLright2(Rational *vec1, Rational *vec2) {
+  int i, j, k;
+  int end;
+  Rational x2;
+  Rational x1;
+  Rational *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
 
-      if(notzero1 && notzero2)
-      {
-         *nonz++ = c;
-         n++;
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
-
-         while(j-- > 0)
-         {
-            vec1[*idx] -= x1 * (*val);
-            vec2[*idx++] -= x2 * (*val++);
-         }
-      }
-      else if(notzero1)
-      {
-         p_work2[c] = 0;
-         *nonz++ = c;
-         n++;
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
-
-         while(j-- > 0)
-            vec1[*idx++] -= x1 * (*val++);
-      }
-      else if(notzero2)
-      {
-         p_work1[c] = 0;
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
-
-         while(j-- > 0)
-            vec2[*idx++] -= x2 * (*val++);
-      }
-      else
-      {
-         p_work1[c] = 0;
-         p_work2[c] = 0;
-      }
-   }
-
-   return n;
-}
+  VectorRational &lval = l.val;
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
 
-inline void CLUFactorRational::solveLright(Rational* vec)
-{
-   int i, j, k;
-   int end;
-   Rational x;
-   Rational* val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
-
-   VectorRational& lval = l.val;
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-
-   end = l.firstUpdate;
-
-   for(i = 0; i < end; ++i)
-   {
-      if((x = vec[lrow[i]]) != 0)
-      {
-         if(timeLimitReached())
-            return;
+  end = l.firstUpdate;
 
-         MSG_DEBUG(std::cout << "y" << lrow[i] << "=" << vec[lrow[i]] << std::endl;)
+  for (i = 0; i < end; ++i) {
+    x1 = vec1[lrow[i]];
+    x2 = vec2[lrow[i]];
 
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+    if (x1 != 0 && x2 != 0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            MSG_DEBUG(std::cout << "                         -> y" << *idx << " -= " << x << " * " << *val <<
-                      " = " << x * (*val) << "    -> " << vec[*idx] - x * (*val) << std::endl;)
-            vec[*idx++] -= x * (*val++);
-         }
+      for (j = lbeg[i + 1]; j > k; --j) {
+        vec1[*idx] -= x1 * (*val);
+        vec2[*idx++] -= x2 * (*val++);
       }
-   }
-
-   if(l.updateType)                      /* Forest-Tomlin Updates */
-   {
-      MSG_DEBUG(std::cout << "performing FT updates..." << std::endl;)
-
-      end = l.firstUnused;
-
-      for(; i < end; ++i)
-      {
-         x = 0;
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-
-         for(j = lbeg[i + 1]; j > k; --j)
-            x += vec[*idx++] * (*val++);
-
-         vec[lrow[i]] -= x;
+    } else if (x1 != 0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-         MSG_DEBUG(std::cout << "y" << lrow[i] << "=" << vec[lrow[i]] << std::endl;)
-      }
+      for (j = lbeg[i + 1]; j > k; --j)
+        vec1[*idx++] -= x1 * (*val++);
+    } else if (x2 != 0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-      MSG_DEBUG(std::cout << "finished FT updates." << std::endl;)
-   }
-}
+      for (j = lbeg[i + 1]; j > k; --j)
+        vec2[*idx++] -= x2 * (*val++);
+    }
+  }
 
-inline void CLUFactorRational::solveLright2(Rational* vec1, Rational* vec2)
-{
-   int i, j, k;
-   int end;
-   Rational x2;
-   Rational x1;
-   Rational* val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
-
-   VectorRational& lval = l.val;
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-
-   end = l.firstUpdate;
-
-   for(i = 0; i < end; ++i)
-   {
-      x1 = vec1[lrow[i]];
-      x2 = vec2[lrow[i]];
-
-      if(x1 != 0 && x2 != 0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            vec1[*idx] -= x1 * (*val);
-            vec2[*idx++] -= x2 * (*val++);
-         }
-      }
-      else if(x1 != 0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+  if (l.updateType) /* Forest-Tomlin Updates */
+  {
+    end = l.firstUnused;
 
-         for(j = lbeg[i + 1]; j > k; --j)
-            vec1[*idx++] -= x1 * (*val++);
-      }
-      else if(x2 != 0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+    for (; i < end; ++i) {
+      x1 = 0;
+      x2 = 0;
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-         for(j = lbeg[i + 1]; j > k; --j)
-            vec2[*idx++] -= x2 * (*val++);
+      for (j = lbeg[i + 1]; j > k; --j) {
+        x1 += vec1[*idx] * (*val);
+        x2 += vec2[*idx++] * (*val++);
       }
-   }
-
-   if(l.updateType)                      /* Forest-Tomlin Updates */
-   {
-      end = l.firstUnused;
-
-      for(; i < end; ++i)
-      {
-         x1 = 0;
-         x2 = 0;
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            x1 += vec1[*idx] * (*val);
-            x2 += vec2[*idx++] * (*val++);
-         }
 
-         vec1[lrow[i]] -= x1;
+      vec1[lrow[i]] -= x1;
 
-         vec2[lrow[i]] -= x2;
-      }
-   }
+      vec2[lrow[i]] -= x2;
+    }
+  }
 }
 
-inline void CLUFactorRational::solveUpdateRight(Rational* vec)
-{
-   int i, j, k;
-   int end;
-   Rational x;
-   Rational* val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
+inline void CLUFactorRational::solveUpdateRight(Rational *vec) {
+  int i, j, k;
+  int end;
+  Rational x;
+  Rational *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
 
-   assert(!l.updateType);               /* no Forest-Tomlin Updates */
+  assert(!l.updateType); /* no Forest-Tomlin Updates */
 
-   VectorRational& lval = l.val;
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
+  VectorRational &lval = l.val;
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
 
-   end = l.firstUnused;
+  end = l.firstUnused;
 
-   for(i = l.firstUpdate; i < end; ++i)
-   {
-      if((x = vec[lrow[i]]) != 0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+  for (i = l.firstUpdate; i < end; ++i) {
+    if ((x = vec[lrow[i]]) != 0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-         for(j = lbeg[i + 1]; j > k; --j)
-            vec[*idx++] -= x * (*val++);
-      }
-   }
+      for (j = lbeg[i + 1]; j > k; --j)
+        vec[*idx++] -= x * (*val++);
+    }
+  }
 }
 
-inline void CLUFactorRational::solveUpdateRight2(Rational* vec1, Rational* vec2)
-{
-   int i, j, k;
-   int end;
-   Rational x1, x2;
-   int* lrow, *lidx;
-   int* lbeg;
+inline void CLUFactorRational::solveUpdateRight2(Rational *vec1,
+                                                 Rational *vec2) {
+  int i, j, k;
+  int end;
+  Rational x1, x2;
+  int *lrow, *lidx;
+  int *lbeg;
 
-   int* idx;
-   Rational* val;
+  int *idx;
+  Rational *val;
 
-   assert(!l.updateType);               /* no Forest-Tomlin Updates */
+  assert(!l.updateType); /* no Forest-Tomlin Updates */
 
-   VectorRational& lval = l.val;
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
+  VectorRational &lval = l.val;
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
 
-   end = l.firstUnused;
+  end = l.firstUnused;
 
-   for(i = l.firstUpdate; i < end; ++i)
-   {
-      x1 = vec1[lrow[i]];
-      x2 = vec2[lrow[i]];
+  for (i = l.firstUpdate; i < end; ++i) {
+    x1 = vec1[lrow[i]];
+    x2 = vec2[lrow[i]];
 
-      if(x1 != 0 && x2 != 0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            vec1[*idx] -= x1 * (*val);
-            vec2[*idx++] -= x2 * (*val++);
-         }
-      }
-      else if(x1 != 0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+    if (x1 != 0 && x2 != 0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-         for(j = lbeg[i + 1]; j > k; --j)
-            vec1[*idx++] -= x1 * (*val++);
+      for (j = lbeg[i + 1]; j > k; --j) {
+        vec1[*idx] -= x1 * (*val);
+        vec2[*idx++] -= x2 * (*val++);
       }
-      else if(x2 != 0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+    } else if (x1 != 0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-         for(j = lbeg[i + 1]; j > k; --j)
-            vec2[*idx++] -= x2 * (*val++);
-      }
-   }
+      for (j = lbeg[i + 1]; j > k; --j)
+        vec1[*idx++] -= x1 * (*val++);
+    } else if (x2 != 0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
+
+      for (j = lbeg[i + 1]; j > k; --j)
+        vec2[*idx++] -= x2 * (*val++);
+    }
+  }
 }
 
-inline int CLUFactorRational::solveRight4update(Rational* vec, int* nonz,
-      Rational* rhs, Rational* forest, int* forestNum, int* forestIdx)
-{
-   solveLright(rhs);
+inline int CLUFactorRational::solveRight4update(Rational *vec, int *nonz,
+                                                Rational *rhs, Rational *forest,
+                                                int *forestNum,
+                                                int *forestIdx) {
+  solveLright(rhs);
 
-   if(forest)
-   {
-      int n = 0;
+  if (forest) {
+    int n = 0;
 
-      for(int i = 0; i < thedim; i++)
-      {
-         forestIdx[n] = i;
-         forest[i]    = rhs[i];
-         n           += rhs[i] != 0 ? 1 : 0;
-      }
+    for (int i = 0; i < thedim; i++) {
+      forestIdx[n] = i;
+      forest[i] = rhs[i];
+      n += rhs[i] != 0 ? 1 : 0;
+    }
 
-      *forestNum = n;
-   }
+    *forestNum = n;
+  }
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      solveUright(vec, rhs);
-      solveUpdateRight(vec);
-      return 0;
-   }
-   else
-      return solveUrightEps(vec, nonz, rhs);
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    solveUright(vec, rhs);
+    solveUpdateRight(vec);
+    return 0;
+  } else
+    return solveUrightEps(vec, nonz, rhs);
 }
 
-inline void CLUFactorRational::solveRight(Rational* vec, Rational* rhs)
-{
-   solveLright(rhs);
-   solveUright(vec, rhs);
+inline void CLUFactorRational::solveRight(Rational *vec, Rational *rhs) {
+  solveLright(rhs);
+  solveUright(vec, rhs);
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-      solveUpdateRight(vec);
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+    solveUpdateRight(vec);
 }
 
-inline int CLUFactorRational::solveRight2update(Rational* vec1,
-      Rational* vec2,
-      Rational* rhs1,
-      Rational* rhs2,
-      int* nonz,
-      Rational* forest,
-      int* forestNum,
-      int* forestIdx)
-{
-   solveLright2(rhs1, rhs2);
+inline int CLUFactorRational::solveRight2update(Rational *vec1, Rational *vec2,
+                                                Rational *rhs1, Rational *rhs2,
+                                                int *nonz, Rational *forest,
+                                                int *forestNum,
+                                                int *forestIdx) {
+  solveLright2(rhs1, rhs2);
 
-   if(forest)
-   {
-      int n = 0;
+  if (forest) {
+    int n = 0;
 
-      for(int i = 0; i < thedim; i++)
-      {
-         forestIdx[n] = i;
-         forest[i]    = rhs1[i];
-         n           += rhs1[i] != 0 ? 1 : 0;
-      }
+    for (int i = 0; i < thedim; i++) {
+      forestIdx[n] = i;
+      forest[i] = rhs1[i];
+      n += rhs1[i] != 0 ? 1 : 0;
+    }
 
-      *forestNum = n;
-   }
+    *forestNum = n;
+  }
 
-   if(!l.updateType)            /* no Forest-Tomlin Updates */
-   {
-      solveUright2(vec1, rhs1, vec2, rhs2);
-      solveUpdateRight2(vec1, vec2);
-      return 0;
-   }
-   else
-      return solveUright2eps(vec1, rhs1, vec2, rhs2, nonz);
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    solveUright2(vec1, rhs1, vec2, rhs2);
+    solveUpdateRight2(vec1, vec2);
+    return 0;
+  } else
+    return solveUright2eps(vec1, rhs1, vec2, rhs2, nonz);
 }
 
-inline void CLUFactorRational::solveRight2(
-   Rational* vec1,
-   Rational* vec2,
-   Rational* rhs1,
-   Rational* rhs2)
-{
-   solveLright2(rhs1, rhs2);
-
-   if(l.updateType)              /* Forest-Tomlin Updates */
-      solveUright2(vec1, rhs1, vec2, rhs2);
-   else
-   {
-      solveUright2(vec1, rhs1, vec2, rhs2);
-      solveUpdateRight2(vec1, vec2);
-   }
+inline void CLUFactorRational::solveRight2(Rational *vec1, Rational *vec2,
+                                           Rational *rhs1, Rational *rhs2) {
+  solveLright2(rhs1, rhs2);
+
+  if (l.updateType) /* Forest-Tomlin Updates */
+    solveUright2(vec1, rhs1, vec2, rhs2);
+  else {
+    solveUright2(vec1, rhs1, vec2, rhs2);
+    solveUpdateRight2(vec1, vec2);
+  }
 }
 
 /*****************************************************************************/
-inline void CLUFactorRational::solveUleft(Rational* p_work, Rational* vec)
-{
-   for(int i = 0; i < thedim; ++i)
-   {
-      int  c  = col.orig[i];
-      int  r  = row.orig[i];
+inline void CLUFactorRational::solveUleft(Rational *p_work, Rational *vec) {
+  for (int i = 0; i < thedim; ++i) {
+    int c = col.orig[i];
+    int r = row.orig[i];
 
-      assert(c >= 0);    // Inna/Tobi: otherwise, vec[c] would be strange...
-      assert(r >= 0);    // Inna/Tobi: otherwise, diag[r] would be strange...
+    assert(c >= 0); // Inna/Tobi: otherwise, vec[c] would be strange...
+    assert(r >= 0); // Inna/Tobi: otherwise, diag[r] would be strange...
 
-      Rational x  = vec[c];
+    Rational x = vec[c];
 
-      vec[c]  = 0;
+    vec[c] = 0;
 
-      if(x != 0)
-      {
-         if(timeLimitReached())
-            return;
+    if (x != 0) {
+      if (timeLimitReached())
+        return;
 
-         x        *= diag[r];
-         p_work[r] = x;
+      x *= diag[r];
+      p_work[r] = x;
 
-         int end = u.row.start[r] + u.row.len[r];
+      int end = u.row.start[r] + u.row.len[r];
 
-         for(int m = u.row.start[r]; m < end; m++)
-         {
-            vec[u.row.idx[m]] -= x * u.row.val[m];
-         }
+      for (int m = u.row.start[r]; m < end; m++) {
+        vec[u.row.idx[m]] -= x * u.row.val[m];
       }
-   }
+    }
+  }
 }
 
-
-
-inline void CLUFactorRational::solveUleft2(Rational* p_work1, Rational* vec1, Rational* p_work2,
-      Rational* vec2)
-{
-   Rational x1;
-   Rational x2;
-   int i, k, r, c;
-   int* rorig, *corig;
-   int* ridx, *rlen, *rbeg, *idx;
-   Rational* val;
-
-   rorig = row.orig;
-   corig = col.orig;
-
-   ridx = u.row.idx;
-   VectorRational& rval = u.row.val;
-   rlen = u.row.len;
-   rbeg = u.row.start;
-
-   for(i = 0; i < thedim; ++i)
-   {
-      c = corig[i];
-      r = rorig[i];
-      x1 = vec1[c];
-      x2 = vec2[c];
-
-      if((x1 != 0) && (x2 != 0))
-      {
-         x1 *= diag[r];
-         x2 *= diag[r];
-         p_work1[r] = x1;
-         p_work2[r] = x2;
-         k = rbeg[r];
-         idx = &ridx[k];
-         val = &rval[k];
-
-         for(int m = rlen[r]; m != 0; --m)
-         {
-            vec1[*idx] -= x1 * (*val);
-            vec2[*idx] -= x2 * (*val++);
-            idx++;
-         }
-      }
-      else if(x1 != 0)
-      {
-         x1 *= diag[r];
-         p_work1[r] = x1;
-         k = rbeg[r];
-         idx = &ridx[k];
-         val = &rval[k];
-
-         for(int m = rlen[r]; m != 0; --m)
-            vec1[*idx++] -= x1 * (*val++);
-      }
-      else if(x2 != 0)
-      {
-         x2 *= diag[r];
-         p_work2[r] = x2;
-         k = rbeg[r];
-         idx = &ridx[k];
-         val = &rval[k];
-
-         for(int m = rlen[r]; m != 0; --m)
-            vec2[*idx++] -= x2 * (*val++);
+inline void CLUFactorRational::solveUleft2(Rational *p_work1, Rational *vec1,
+                                           Rational *p_work2, Rational *vec2) {
+  Rational x1;
+  Rational x2;
+  int i, k, r, c;
+  int *rorig, *corig;
+  int *ridx, *rlen, *rbeg, *idx;
+  Rational *val;
+
+  rorig = row.orig;
+  corig = col.orig;
+
+  ridx = u.row.idx;
+  VectorRational &rval = u.row.val;
+  rlen = u.row.len;
+  rbeg = u.row.start;
+
+  for (i = 0; i < thedim; ++i) {
+    c = corig[i];
+    r = rorig[i];
+    x1 = vec1[c];
+    x2 = vec2[c];
+
+    if ((x1 != 0) && (x2 != 0)) {
+      x1 *= diag[r];
+      x2 *= diag[r];
+      p_work1[r] = x1;
+      p_work2[r] = x2;
+      k = rbeg[r];
+      idx = &ridx[k];
+      val = &rval[k];
+
+      for (int m = rlen[r]; m != 0; --m) {
+        vec1[*idx] -= x1 * (*val);
+        vec2[*idx] -= x2 * (*val++);
+        idx++;
       }
-   }
+    } else if (x1 != 0) {
+      x1 *= diag[r];
+      p_work1[r] = x1;
+      k = rbeg[r];
+      idx = &ridx[k];
+      val = &rval[k];
+
+      for (int m = rlen[r]; m != 0; --m)
+        vec1[*idx++] -= x1 * (*val++);
+    } else if (x2 != 0) {
+      x2 *= diag[r];
+      p_work2[r] = x2;
+      k = rbeg[r];
+      idx = &ridx[k];
+      val = &rval[k];
+
+      for (int m = rlen[r]; m != 0; --m)
+        vec2[*idx++] -= x2 * (*val++);
+    }
+  }
 }
 
-inline int CLUFactorRational::solveLleft2forest(Rational* vec1, int* /* nonz */, Rational* vec2)
-{
-   int i;
-   int j;
-   int k;
-   int end;
-   Rational x1, x2;
-   Rational* val;
-   int* lidx, *idx, *lrow;
-   int* lbeg;
-
-   VectorRational& lval = l.val;
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-
-   end = l.firstUpdate;
-
-   for(i = l.firstUnused - 1; i >= end; --i)
-   {
-      j = lrow[i];
-      x1 = vec1[j];
-      x2 = vec2[j];
-
-      if(x1 != 0)
-      {
-         if(x2 != 0)
-         {
-            k = lbeg[i];
-            val = &lval[k];
-            idx = &lidx[k];
-
-            for(j = lbeg[i + 1]; j > k; --j)
-            {
-               vec1[*idx] -= x1 * (*val);
-               vec2[*idx++] -= x2 * (*val++);
-            }
-         }
-         else
-         {
-            k = lbeg[i];
-            val = &lval[k];
-            idx = &lidx[k];
-
-            for(j = lbeg[i + 1]; j > k; --j)
-               vec1[*idx++] -= x1 * (*val++);
-         }
+inline int CLUFactorRational::solveLleft2forest(Rational *vec1,
+                                                int * /* nonz */,
+                                                Rational *vec2) {
+  int i;
+  int j;
+  int k;
+  int end;
+  Rational x1, x2;
+  Rational *val;
+  int *lidx, *idx, *lrow;
+  int *lbeg;
+
+  VectorRational &lval = l.val;
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
+
+  end = l.firstUpdate;
+
+  for (i = l.firstUnused - 1; i >= end; --i) {
+    j = lrow[i];
+    x1 = vec1[j];
+    x2 = vec2[j];
+
+    if (x1 != 0) {
+      if (x2 != 0) {
+        k = lbeg[i];
+        val = &lval[k];
+        idx = &lidx[k];
+
+        for (j = lbeg[i + 1]; j > k; --j) {
+          vec1[*idx] -= x1 * (*val);
+          vec2[*idx++] -= x2 * (*val++);
+        }
+      } else {
+        k = lbeg[i];
+        val = &lval[k];
+        idx = &lidx[k];
+
+        for (j = lbeg[i + 1]; j > k; --j)
+          vec1[*idx++] -= x1 * (*val++);
       }
-      else if(x2 != 0)
-      {
-         k = lbeg[i];
-         val = &lval[k];
-         idx = &lidx[k];
+    } else if (x2 != 0) {
+      k = lbeg[i];
+      val = &lval[k];
+      idx = &lidx[k];
 
-         for(j = lbeg[i + 1]; j > k; --j)
-            vec2[*idx++] -= x2 * (*val++);
-      }
-   }
+      for (j = lbeg[i + 1]; j > k; --j)
+        vec2[*idx++] -= x2 * (*val++);
+    }
+  }
 
-   return 0;
+  return 0;
 }
 
-inline void CLUFactorRational::solveLleft2(Rational* vec1, int* /* nonz */, Rational* vec2)
-{
-   int i, j, k, r;
-   int x1not0, x2not0;
-   Rational x1, x2;
+inline void CLUFactorRational::solveLleft2(Rational *vec1, int * /* nonz */,
+                                           Rational *vec2) {
+  int i, j, k, r;
+  int x1not0, x2not0;
+  Rational x1, x2;
 
-   Rational* val;
-   int* ridx, *idx;
-   int* rbeg;
-   int* rorig;
+  Rational *val;
+  int *ridx, *idx;
+  int *rbeg;
+  int *rorig;
 
-   ridx  = l.ridx;
-   VectorRational& rval = l.rval;
-   rbeg  = l.rbeg;
-   rorig = l.rorig;
+  ridx = l.ridx;
+  VectorRational &rval = l.rval;
+  rbeg = l.rbeg;
+  rorig = l.rorig;
 
 #ifndef WITH_L_ROWS
-   VectorRational& lval  = l.val;
-   int*    lidx  = l.idx;
-   int*    lrow  = l.row;
-   int*    lbeg  = l.start;
-
-   i = l.firstUpdate - 1;
-
-   for(; i >= 0; --i)
-   {
-      k = lbeg[i];
-      val = &lval[k];
-      idx = &lidx[k];
-      x1 = 0;
-      x2 = 0;
-
-      for(j = lbeg[i + 1]; j > k; --j)
-      {
-         x1 += vec1[*idx] * (*val);
-         x2 += vec2[*idx++] * (*val++);
-      }
+  VectorRational &lval = l.val;
+  int *lidx = l.idx;
+  int *lrow = l.row;
+  int *lbeg = l.start;
+
+  i = l.firstUpdate - 1;
+
+  for (; i >= 0; --i) {
+    k = lbeg[i];
+    val = &lval[k];
+    idx = &lidx[k];
+    x1 = 0;
+    x2 = 0;
+
+    for (j = lbeg[i + 1]; j > k; --j) {
+      x1 += vec1[*idx] * (*val);
+      x2 += vec2[*idx++] * (*val++);
+    }
 
-      vec1[lrow[i]] -= x1;
+    vec1[lrow[i]] -= x1;
 
-      vec2[lrow[i]] -= x2;
-   }
+    vec2[lrow[i]] -= x2;
+  }
 
 #else
 
-   for(i = thedim; i--;)
-   {
-      r = rorig[i];
-      x1 = vec1[r];
-      x2 = vec2[r];
-      x1not0 = (x1 != 0);
-      x2not0 = (x2 != 0);
-
-      if(x1not0 && x2not0)
-      {
-         k = rbeg[r];
-         j = rbeg[r + 1] - k;
-         val = &rval[k];
-         idx = &ridx[k];
-
-         while(j-- > 0)
-         {
-            assert(row.perm[*idx] < i);
-            vec1[*idx] -= x1 * *val;
-            vec2[*idx++] -= x2 * *val++;
-         }
+  for (i = thedim; i--;) {
+    r = rorig[i];
+    x1 = vec1[r];
+    x2 = vec2[r];
+    x1not0 = (x1 != 0);
+    x2not0 = (x2 != 0);
+
+    if (x1not0 && x2not0) {
+      k = rbeg[r];
+      j = rbeg[r + 1] - k;
+      val = &rval[k];
+      idx = &ridx[k];
+
+      while (j-- > 0) {
+        assert(row.perm[*idx] < i);
+        vec1[*idx] -= x1 * *val;
+        vec2[*idx++] -= x2 * *val++;
       }
-      else if(x1not0)
-      {
-         k = rbeg[r];
-         j = rbeg[r + 1] - k;
-         val = &rval[k];
-         idx = &ridx[k];
-
-         while(j-- > 0)
-         {
-            assert(row.perm[*idx] < i);
-            vec1[*idx++] -= x1 * *val++;
-         }
+    } else if (x1not0) {
+      k = rbeg[r];
+      j = rbeg[r + 1] - k;
+      val = &rval[k];
+      idx = &ridx[k];
+
+      while (j-- > 0) {
+        assert(row.perm[*idx] < i);
+        vec1[*idx++] -= x1 * *val++;
       }
-      else if(x2not0)
-      {
-         k = rbeg[r];
-         j = rbeg[r + 1] - k;
-         val = &rval[k];
-         idx = &ridx[k];
-
-         while(j-- > 0)
-         {
-            assert(row.perm[*idx] < i);
-            vec2[*idx++] -= x2 * *val++;
-         }
+    } else if (x2not0) {
+      k = rbeg[r];
+      j = rbeg[r + 1] - k;
+      val = &rval[k];
+      idx = &ridx[k];
+
+      while (j-- > 0) {
+        assert(row.perm[*idx] < i);
+        vec2[*idx++] -= x2 * *val++;
       }
-   }
+    }
+  }
 
 #endif
 }
 
-inline int CLUFactorRational::solveLleftForest(Rational* vec, int* /* nonz */)
-{
-   int i, j, k, end;
-   Rational x;
-   Rational* val;
-   int* idx, *lidx, *lrow, *lbeg;
+inline int CLUFactorRational::solveLleftForest(Rational *vec,
+                                               int * /* nonz */) {
+  int i, j, k, end;
+  Rational x;
+  Rational *val;
+  int *idx, *lidx, *lrow, *lbeg;
 
-   VectorRational& lval = l.val;
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
+  VectorRational &lval = l.val;
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
 
-   end = l.firstUpdate;
+  end = l.firstUpdate;
 
-   for(i = l.firstUnused - 1; i >= end; --i)
-   {
-      if((x = vec[lrow[i]]) != 0)
-      {
-         if(timeLimitReached())
-            return 0;
+  for (i = l.firstUnused - 1; i >= end; --i) {
+    if ((x = vec[lrow[i]]) != 0) {
+      if (timeLimitReached())
+        return 0;
 
-         k = lbeg[i];
-         val = &lval[k];
-         idx = &lidx[k];
+      k = lbeg[i];
+      val = &lval[k];
+      idx = &lidx[k];
 
-         for(j = lbeg[i + 1]; j > k; --j)
-            vec[*idx++] -= x * (*val++);
-      }
-   }
+      for (j = lbeg[i + 1]; j > k; --j)
+        vec[*idx++] -= x * (*val++);
+    }
+  }
 
-   return 0;
+  return 0;
 }
 
-inline void CLUFactorRational::solveLleft(Rational* vec)
-{
+inline void CLUFactorRational::solveLleft(Rational *vec) {
 
 #ifndef WITH_L_ROWS
-   int*  idx;
-   Rational* val;
-   VectorRational& lval  = l.val;
-   int*  lidx  = l.idx;
-   int*  lrow  = l.row;
-   int*  lbeg  = l.start;
-
-   for(int i = l.firstUpdate - 1; i >= 0; --i)
-   {
-      if(timeLimitReached())
-         return;
-
-      int k = lbeg[i];
-      val = &lval[k];
-      idx = &lidx[k];
-      x = 0;
+  int *idx;
+  Rational *val;
+  VectorRational &lval = l.val;
+  int *lidx = l.idx;
+  int *lrow = l.row;
+  int *lbeg = l.start;
+
+  for (int i = l.firstUpdate - 1; i >= 0; --i) {
+    if (timeLimitReached())
+      return;
 
-      for(int j = lbeg[i + 1]; j > k; --j)
-         x += vec[*idx++] * (*val++);
+    int k = lbeg[i];
+    val = &lval[k];
+    idx = &lidx[k];
+    x = 0;
 
-      vec[lrow[i]] -= x;
-   }
+    for (int j = lbeg[i + 1]; j > k; --j)
+      x += vec[*idx++] * (*val++);
+
+    vec[lrow[i]] -= x;
+  }
 
 #else
 
-   for(int i = thedim - 1; i >= 0; --i)
-   {
-      int  r = l.rorig[i];
-      Rational x = vec[r];
+  for (int i = thedim - 1; i >= 0; --i) {
+    int r = l.rorig[i];
+    Rational x = vec[r];
 
-      if(x != 0)
-      {
-         if(timeLimitReached())
-            return;
+    if (x != 0) {
+      if (timeLimitReached())
+        return;
 
-         for(int k = l.rbeg[r]; k < l.rbeg[r + 1]; k++)
-         {
-            int j = l.ridx[k];
+      for (int k = l.rbeg[r]; k < l.rbeg[r + 1]; k++) {
+        int j = l.ridx[k];
 
-            assert(l.rperm[j] < i);
+        assert(l.rperm[j] < i);
 
-            vec[j] -= x * l.rval[k];
-         }
+        vec[j] -= x * l.rval[k];
       }
-   }
+    }
+  }
 
 #endif // WITH_L_ROWS
 }
 
-inline int CLUFactorRational::solveLleftEps(Rational* vec, int* nonz)
-{
-   int i, j, k, n;
-   int r;
-   Rational x;
-   Rational* val;
-   int* ridx, *idx;
-   int* rbeg;
-   int* rorig;
-
-   ridx = l.ridx;
-   VectorRational& rval = l.rval;
-   rbeg = l.rbeg;
-   rorig = l.rorig;
-   n = 0;
+inline int CLUFactorRational::solveLleftEps(Rational *vec, int *nonz) {
+  int i, j, k, n;
+  int r;
+  Rational x;
+  Rational *val;
+  int *ridx, *idx;
+  int *rbeg;
+  int *rorig;
+
+  ridx = l.ridx;
+  VectorRational &rval = l.rval;
+  rbeg = l.rbeg;
+  rorig = l.rorig;
+  n = 0;
 #ifndef WITH_L_ROWS
-   VectorRational& lval = l.val;
-   int*  lidx = l.idx;
-   int*  lrow = l.row;
-   int*  lbeg = l.start;
+  VectorRational &lval = l.val;
+  int *lidx = l.idx;
+  int *lrow = l.row;
+  int *lbeg = l.start;
 
-   for(i = l.firstUpdate - 1; i >= 0; --i)
-   {
-      k = lbeg[i];
-      val = &lval[k];
-      idx = &lidx[k];
-      x = 0;
+  for (i = l.firstUpdate - 1; i >= 0; --i) {
+    k = lbeg[i];
+    val = &lval[k];
+    idx = &lidx[k];
+    x = 0;
 
-      for(j = lbeg[i + 1]; j > k; --j)
-         x += vec[*idx++] * (*val++);
+    for (j = lbeg[i + 1]; j > k; --j)
+      x += vec[*idx++] * (*val++);
 
-      vec[lrow[i]] -= x;
-   }
+    vec[lrow[i]] -= x;
+  }
 
 #else
 
-   for(i = thedim; i--;)
-   {
-      r = rorig[i];
-      x = vec[r];
-
-      if(x != 0)
-      {
-         *nonz++ = r;
-         n++;
-         k = rbeg[r];
-         j = rbeg[r + 1] - k;
-         val = &rval[k];
-         idx = &ridx[k];
-
-         while(j-- > 0)
-         {
-            assert(row.perm[*idx] < i);
-            vec[*idx++] -= x * *val++;
-         }
+  for (i = thedim; i--;) {
+    r = rorig[i];
+    x = vec[r];
+
+    if (x != 0) {
+      *nonz++ = r;
+      n++;
+      k = rbeg[r];
+      j = rbeg[r + 1] - k;
+      val = &rval[k];
+      idx = &ridx[k];
+
+      while (j-- > 0) {
+        assert(row.perm[*idx] < i);
+        vec[*idx++] -= x * *val++;
       }
-      else
-         vec[r] = 0;
-   }
+    } else
+      vec[r] = 0;
+  }
 
 #endif
 
-   return n;
+  return n;
 }
 
-inline void CLUFactorRational::solveUpdateLeft(Rational* vec)
-{
-   int i, j, k, end;
-   Rational x;
-   Rational* val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
+inline void CLUFactorRational::solveUpdateLeft(Rational *vec) {
+  int i, j, k, end;
+  Rational x;
+  Rational *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
 
-   VectorRational& lval = l.val;
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
+  VectorRational &lval = l.val;
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
 
-   assert(!l.updateType);               /* Forest-Tomlin Updates */
+  assert(!l.updateType); /* Forest-Tomlin Updates */
 
-   end = l.firstUpdate;
+  end = l.firstUpdate;
 
-   for(i = l.firstUnused - 1; i >= end; --i)
-   {
-      k = lbeg[i];
-      val = &lval[k];
-      idx = &lidx[k];
-      x = 0;
+  for (i = l.firstUnused - 1; i >= end; --i) {
+    k = lbeg[i];
+    val = &lval[k];
+    idx = &lidx[k];
+    x = 0;
 
-      for(j = lbeg[i + 1]; j > k; --j)
-         x += vec[*idx++] * (*val++);
+    for (j = lbeg[i + 1]; j > k; --j)
+      x += vec[*idx++] * (*val++);
 
-      vec[lrow[i]] -= x;
-   }
+    vec[lrow[i]] -= x;
+  }
 }
 
-inline void CLUFactorRational::solveUpdateLeft2(Rational* vec1, Rational* vec2)
-{
-   int i, j, k, end;
-   Rational x1, x2;
-   Rational* val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
-
-   VectorRational& lval = l.val;
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-
-   assert(!l.updateType);               /* Forest-Tomlin Updates */
-
-   end = l.firstUpdate;
-
-   for(i = l.firstUnused - 1; i >= end; --i)
-   {
-      k = lbeg[i];
-      val = &lval[k];
-      idx = &lidx[k];
-      x1 = 0;
-      x2 = 0;
-
-      for(j = lbeg[i + 1]; j > k; --j)
-      {
-         x1 += vec1[*idx] * (*val);
-         x2 += vec2[*idx++] * (*val++);
-      }
+inline void CLUFactorRational::solveUpdateLeft2(Rational *vec1,
+                                                Rational *vec2) {
+  int i, j, k, end;
+  Rational x1, x2;
+  Rational *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
+
+  VectorRational &lval = l.val;
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
+
+  assert(!l.updateType); /* Forest-Tomlin Updates */
+
+  end = l.firstUpdate;
+
+  for (i = l.firstUnused - 1; i >= end; --i) {
+    k = lbeg[i];
+    val = &lval[k];
+    idx = &lidx[k];
+    x1 = 0;
+    x2 = 0;
+
+    for (j = lbeg[i + 1]; j > k; --j) {
+      x1 += vec1[*idx] * (*val);
+      x2 += vec2[*idx++] * (*val++);
+    }
 
-      vec1[lrow[i]] -= x1;
+    vec1[lrow[i]] -= x1;
 
-      vec2[lrow[i]] -= x2;
-   }
+    vec2[lrow[i]] -= x2;
+  }
 }
 
-inline int CLUFactorRational::solveUpdateLeft(Rational* vec, int* nonz, int n)
-{
-   int i, j, k, end;
-   Rational x, y;
-   Rational* val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
+inline int CLUFactorRational::solveUpdateLeft(Rational *vec, int *nonz, int n) {
+  int i, j, k, end;
+  Rational x, y;
+  Rational *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
 
-   assert(!l.updateType);               /* no Forest-Tomlin Updates! */
+  assert(!l.updateType); /* no Forest-Tomlin Updates! */
 
-   VectorRational& lval = l.val;
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
+  VectorRational &lval = l.val;
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
 
-   end = l.firstUpdate;
+  end = l.firstUpdate;
 
-   for(i = l.firstUnused - 1; i >= end; --i)
-   {
-      k = lbeg[i];
-      assert(k >= 0 && k < l.val.dim());
-      val = &lval[k];
-      idx = &lidx[k];
-      x = 0;
+  for (i = l.firstUnused - 1; i >= end; --i) {
+    k = lbeg[i];
+    assert(k >= 0 && k < l.val.dim());
+    val = &lval[k];
+    idx = &lidx[k];
+    x = 0;
 
-      for(j = lbeg[i + 1]; j > k; --j)
-      {
-         assert(*idx >= 0 && *idx < thedim);
-         x += vec[*idx++] * (*val++);
-      }
+    for (j = lbeg[i + 1]; j > k; --j) {
+      assert(*idx >= 0 && *idx < thedim);
+      x += vec[*idx++] * (*val++);
+    }
 
-      k = lrow[i];
+    k = lrow[i];
 
-      y = vec[k];
+    y = vec[k];
 
-      if(y == 0)
-      {
-         y = -x;
+    if (y == 0) {
+      y = -x;
 
-         if(y != 0)
-         {
-            nonz[n++] = k;
-            vec[k] = y;
-         }
+      if (y != 0) {
+        nonz[n++] = k;
+        vec[k] = y;
       }
-      else
-      {
-         y -= x;
-         //vec[k] = ( y != 0 ) ? y : MARKER;
-         vec[k] = y;
-      }
-   }
+    } else {
+      y -= x;
+      // vec[k] = ( y != 0 ) ? y : MARKER;
+      vec[k] = y;
+    }
+  }
 
-   return n;
+  return n;
 }
 
-inline void CLUFactorRational::solveLeft(Rational* vec, Rational* rhs)
-{
-
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      solveUpdateLeft(rhs);
-      solveUleft(vec, rhs);
-      solveLleft(vec);
-   }
-   else
-   {
-      solveUleft(vec, rhs);
-      solveLleftForest(vec, 0);
-      solveLleft(vec);
-   }
+inline void CLUFactorRational::solveLeft(Rational *vec, Rational *rhs) {
+
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    solveUpdateLeft(rhs);
+    solveUleft(vec, rhs);
+    solveLleft(vec);
+  } else {
+    solveUleft(vec, rhs);
+    solveLleftForest(vec, 0);
+    solveLleft(vec);
+  }
 }
 
-inline int CLUFactorRational::solveLeftEps(Rational* vec, Rational* rhs, int* nonz)
-{
-
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      solveUpdateLeft(rhs);
-      solveUleft(vec, rhs);
-      return solveLleftEps(vec, nonz);
-   }
-   else
-   {
-      solveUleft(vec, rhs);
-      solveLleftForest(vec, nonz);
-      return solveLleftEps(vec, nonz);
-   }
+inline int CLUFactorRational::solveLeftEps(Rational *vec, Rational *rhs,
+                                           int *nonz) {
+
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    solveUpdateLeft(rhs);
+    solveUleft(vec, rhs);
+    return solveLleftEps(vec, nonz);
+  } else {
+    solveUleft(vec, rhs);
+    solveLleftForest(vec, nonz);
+    return solveLleftEps(vec, nonz);
+  }
 }
 
-inline int CLUFactorRational::solveLeft2(
-   Rational* vec1,
-   int* nonz,
-   Rational* vec2,
-   Rational* rhs1,
-   Rational* rhs2)
-{
-
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      solveUpdateLeft2(rhs1, rhs2);
-      solveUleft2(vec1, rhs1, vec2, rhs2);
-      solveLleft2(vec1, nonz, vec2);
-      return 0;
-   }
-   else
-   {
-      solveUleft2(vec1, rhs1, vec2, rhs2);
-      solveLleft2forest(vec1, nonz, vec2);
-      solveLleft2(vec1, nonz, vec2);
-      return 0;
-   }
+inline int CLUFactorRational::solveLeft2(Rational *vec1, int *nonz,
+                                         Rational *vec2, Rational *rhs1,
+                                         Rational *rhs2) {
+
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    solveUpdateLeft2(rhs1, rhs2);
+    solveUleft2(vec1, rhs1, vec2, rhs2);
+    solveLleft2(vec1, nonz, vec2);
+    return 0;
+  } else {
+    solveUleft2(vec1, rhs1, vec2, rhs2);
+    solveLleft2forest(vec1, nonz, vec2);
+    solveLleft2(vec1, nonz, vec2);
+    return 0;
+  }
 }
 
-inline int CLUFactorRational::solveUleft(Rational* vec, int* vecidx,
-      Rational* rhs, int* rhsidx, int rhsn)
-{
-   Rational x, y;
-   int i, j, k, n, r, c;
-   int* rorig, *corig, *cperm;
-   int* ridx, *rlen, *rbeg, *idx;
-   Rational* val;
+inline int CLUFactorRational::solveUleft(Rational *vec, int *vecidx,
+                                         Rational *rhs, int *rhsidx, int rhsn) {
+  Rational x, y;
+  int i, j, k, n, r, c;
+  int *rorig, *corig, *cperm;
+  int *ridx, *rlen, *rbeg, *idx;
+  Rational *val;
 
-   rorig = row.orig;
-   corig = col.orig;
-   cperm = col.perm;
+  rorig = row.orig;
+  corig = col.orig;
+  cperm = col.perm;
 
-   /*  move rhsidx to a heap
-    */
+  /*  move rhsidx to a heap
+   */
 
-   for(i = 0; i < rhsn;)
-      enQueueMinRat(rhsidx, &i, cperm[rhsidx[i]]);
+  for (i = 0; i < rhsn;)
+    enQueueMinRat(rhsidx, &i, cperm[rhsidx[i]]);
 
-   ridx = u.row.idx;
+  ridx = u.row.idx;
 
-   VectorRational& rval = u.row.val;
+  VectorRational &rval = u.row.val;
 
-   rlen = u.row.len;
+  rlen = u.row.len;
 
-   rbeg = u.row.start;
+  rbeg = u.row.start;
 
-   n = 0;
+  n = 0;
 
-   while(rhsn > 0)
-   {
-      i = deQueueMinRat(rhsidx, &rhsn);
-      assert(i >= 0 && i < thedim);
-      c = corig[i];
-      assert(c >= 0 && c < thedim);
-      x = rhs[c];
-      rhs[c] = 0;
+  while (rhsn > 0) {
+    i = deQueueMinRat(rhsidx, &rhsn);
+    assert(i >= 0 && i < thedim);
+    c = corig[i];
+    assert(c >= 0 && c < thedim);
+    x = rhs[c];
+    rhs[c] = 0;
 
-      if(x != 0)
-      {
-         r = rorig[i];
-         assert(r >= 0 && r < thedim);
-         vecidx[n++] = r;
-         x *= diag[r];
-         vec[r] = x;
-         k = rbeg[r];
-         assert(k >= 0 && k < u.row.val.dim());
-         idx = &ridx[k];
-         val = &rval[k];
-
-         for(int m = rlen[r]; m; --m)
-         {
-            j = *idx++;
-            assert(j >= 0 && j < thedim);
-            y = rhs[j];
-
-            if(y == 0)
-            {
-               y = -x * (*val++);
-
-               if(y != 0)
-               {
-                  rhs[j] = y;
-                  enQueueMinRat(rhsidx, &rhsn, cperm[j]);
-               }
-            }
-            else
-            {
-               y -= x * (*val++);
-               //               rhs[j] = ( y != 0 ) ? y : MARKER;
-               rhs[j] = y;
-            }
-         }
+    if (x != 0) {
+      r = rorig[i];
+      assert(r >= 0 && r < thedim);
+      vecidx[n++] = r;
+      x *= diag[r];
+      vec[r] = x;
+      k = rbeg[r];
+      assert(k >= 0 && k < u.row.val.dim());
+      idx = &ridx[k];
+      val = &rval[k];
+
+      for (int m = rlen[r]; m; --m) {
+        j = *idx++;
+        assert(j >= 0 && j < thedim);
+        y = rhs[j];
+
+        if (y == 0) {
+          y = -x * (*val++);
+
+          if (y != 0) {
+            rhs[j] = y;
+            enQueueMinRat(rhsidx, &rhsn, cperm[j]);
+          }
+        } else {
+          y -= x * (*val++);
+          //               rhs[j] = ( y != 0 ) ? y : MARKER;
+          rhs[j] = y;
+        }
       }
-   }
+    }
+  }
 
-   return n;
+  return n;
 }
 
+inline void CLUFactorRational::solveUleftNoNZ(Rational *vec, Rational *rhs,
+                                              int *rhsidx, int rhsn) {
+  Rational x, y;
+  int i, j, k, r, c;
+  int *rorig, *corig, *cperm;
+  int *ridx, *rlen, *rbeg, *idx;
+  Rational *val;
 
-inline void CLUFactorRational::solveUleftNoNZ(Rational* vec, Rational* rhs, int* rhsidx, int rhsn)
-{
-   Rational x, y;
-   int i, j, k, r, c;
-   int* rorig, *corig, *cperm;
-   int* ridx, *rlen, *rbeg, *idx;
-   Rational* val;
-
-   rorig = row.orig;
-   corig = col.orig;
-   cperm = col.perm;
+  rorig = row.orig;
+  corig = col.orig;
+  cperm = col.perm;
 
-   /*  move rhsidx to a heap
-    */
+  /*  move rhsidx to a heap
+   */
 
-   for(i = 0; i < rhsn;)
-      enQueueMinRat(rhsidx, &i, cperm[rhsidx[i]]);
+  for (i = 0; i < rhsn;)
+    enQueueMinRat(rhsidx, &i, cperm[rhsidx[i]]);
 
-   ridx = u.row.idx;
+  ridx = u.row.idx;
 
-   VectorRational& rval = u.row.val;
+  VectorRational &rval = u.row.val;
 
-   rlen = u.row.len;
+  rlen = u.row.len;
 
-   rbeg = u.row.start;
+  rbeg = u.row.start;
 
-   while(rhsn > 0)
-   {
-      i = deQueueMinRat(rhsidx, &rhsn);
-      assert(i >= 0 && i < thedim);
-      c = corig[i];
-      assert(c >= 0 && c < thedim);
-      x = rhs[c];
-      rhs[c] = 0;
+  while (rhsn > 0) {
+    i = deQueueMinRat(rhsidx, &rhsn);
+    assert(i >= 0 && i < thedim);
+    c = corig[i];
+    assert(c >= 0 && c < thedim);
+    x = rhs[c];
+    rhs[c] = 0;
 
-      if(x != 0)
-      {
-         r = rorig[i];
-         assert(r >= 0 && r < thedim);
-         x *= diag[r];
-         vec[r] = x;
-         k = rbeg[r];
-         assert(k >= 0 && k < u.row.val.dim());
-         idx = &ridx[k];
-         val = &rval[k];
-
-         for(int m = rlen[r]; m; --m)
-         {
-            j = *idx++;
-            assert(j >= 0 && j < thedim);
-            y = rhs[j];
-
-            if(y == 0)
-            {
-               y = -x * (*val++);
-
-               if(y != 0)
-               {
-                  rhs[j] = y;
-                  enQueueMinRat(rhsidx, &rhsn, cperm[j]);
-               }
-            }
-            else
-            {
-               y -= x * (*val++);
-               //               rhs[j] = ( y != 0 ) ? y : MARKER;
-               rhs[j] = y;
-            }
-         }
+    if (x != 0) {
+      r = rorig[i];
+      assert(r >= 0 && r < thedim);
+      x *= diag[r];
+      vec[r] = x;
+      k = rbeg[r];
+      assert(k >= 0 && k < u.row.val.dim());
+      idx = &ridx[k];
+      val = &rval[k];
+
+      for (int m = rlen[r]; m; --m) {
+        j = *idx++;
+        assert(j >= 0 && j < thedim);
+        y = rhs[j];
+
+        if (y == 0) {
+          y = -x * (*val++);
+
+          if (y != 0) {
+            rhs[j] = y;
+            enQueueMinRat(rhsidx, &rhsn, cperm[j]);
+          }
+        } else {
+          y -= x * (*val++);
+          //               rhs[j] = ( y != 0 ) ? y : MARKER;
+          rhs[j] = y;
+        }
       }
-   }
+    }
+  }
 }
 
+inline int CLUFactorRational::solveLleftForest(Rational *vec, int *nonz,
+                                               int n) {
+  int i, j, k, end;
+  Rational x, y;
+  Rational *val;
+  int *idx, *lidx, *lrow, *lbeg;
 
-inline int CLUFactorRational::solveLleftForest(Rational* vec, int* nonz, int n)
-{
-   int i, j, k, end;
-   Rational x, y;
-   Rational* val;
-   int* idx, *lidx, *lrow, *lbeg;
-
-   VectorRational& lval = l.val;
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-   end = l.firstUpdate;
-
-   for(i = l.firstUnused - 1; i >= end; --i)
-   {
-      assert(i >= 0 && i < l.val.dim());
+  VectorRational &lval = l.val;
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
+  end = l.firstUpdate;
 
-      if((x = vec[lrow[i]]) != 0)
-      {
-         k = lbeg[i];
-         assert(k >= 0 && k < l.val.dim());
-         val = &lval[k];
-         idx = &lidx[k];
-
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            int m = *idx++;
-            assert(m >= 0 && m < thedim);
-            y = vec[m];
-
-            if(y == 0)
-            {
-               y = -x * (*val++);
-
-               if(y != 0)
-               {
-                  vec[m] = y;
-                  nonz[n++] = m;
-               }
-            }
-            else
-            {
-               y -= x * (*val++);
+  for (i = l.firstUnused - 1; i >= end; --i) {
+    assert(i >= 0 && i < l.val.dim());
 
-            }
-         }
-      }
-   }
+    if ((x = vec[lrow[i]]) != 0) {
+      k = lbeg[i];
+      assert(k >= 0 && k < l.val.dim());
+      val = &lval[k];
+      idx = &lidx[k];
 
-   return n;
-}
+      for (j = lbeg[i + 1]; j > k; --j) {
+        int m = *idx++;
+        assert(m >= 0 && m < thedim);
+        y = vec[m];
 
+        if (y == 0) {
+          y = -x * (*val++);
 
-inline void CLUFactorRational::solveLleftForestNoNZ(Rational* vec)
-{
-   int i, j, k, end;
-   Rational x;
-   Rational* val;
-   int* idx, *lidx, *lrow, *lbeg;
-
-   VectorRational& lval = l.val;
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-   end = l.firstUpdate;
-
-   for(i = l.firstUnused - 1; i >= end; --i)
-   {
-      if((x = vec[lrow[i]]) != 0)
-      {
-         assert(i >= 0 && i < l.val.dim());
-         k = lbeg[i];
-         assert(k >= 0 && k < l.val.dim());
-         val = &lval[k];
-         idx = &lidx[k];
-
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            assert(*idx >= 0 && *idx < thedim);
-            vec[*idx++] -= x * (*val++);
-         }
+          if (y != 0) {
+            vec[m] = y;
+            nonz[n++] = m;
+          }
+        } else {
+          y -= x * (*val++);
+        }
       }
-   }
+    }
+  }
+
+  return n;
 }
 
+inline void CLUFactorRational::solveLleftForestNoNZ(Rational *vec) {
+  int i, j, k, end;
+  Rational x;
+  Rational *val;
+  int *idx, *lidx, *lrow, *lbeg;
 
-inline int CLUFactorRational::solveLleft(Rational* vec, int* nonz, int rn)
-{
-   int i, j, k, n;
-   int r;
-   Rational x, y;
-   Rational* val;
-   int* ridx, *idx;
-   int* rbeg;
-   int* rorig, *rperm;
-   int* last;
-
-   ridx  = l.ridx;
-   VectorRational& rval  = l.rval;
-   rbeg  = l.rbeg;
-   rorig = l.rorig;
-   rperm = l.rperm;
-   n     = 0;
-
-   i = l.firstUpdate - 1;
-#ifndef WITH_L_ROWS
-#pragma warn "Not yet implemented, define WITH_L_ROWS"
-   VectorRational& lval = l.val;
-   int*    lidx = l.idx;
-   int*    lrow = l.row;
-   int*    lbeg = l.start;
-
-   for(; i >= 0; --i)
-   {
-      k   = lbeg[i];
+  VectorRational &lval = l.val;
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
+  end = l.firstUpdate;
+
+  for (i = l.firstUnused - 1; i >= end; --i) {
+    if ((x = vec[lrow[i]]) != 0) {
+      assert(i >= 0 && i < l.val.dim());
+      k = lbeg[i];
+      assert(k >= 0 && k < l.val.dim());
       val = &lval[k];
       idx = &lidx[k];
-      x   = 0;
 
-      for(j = lbeg[i + 1]; j > k; --j)
-         x += vec[*idx++] * (*val++);
+      for (j = lbeg[i + 1]; j > k; --j) {
+        assert(*idx >= 0 && *idx < thedim);
+        vec[*idx++] -= x * (*val++);
+      }
+    }
+  }
+}
 
-      vec[lrow[i]] -= x;
-   }
+inline int CLUFactorRational::solveLleft(Rational *vec, int *nonz, int rn) {
+  int i, j, k, n;
+  int r;
+  Rational x, y;
+  Rational *val;
+  int *ridx, *idx;
+  int *rbeg;
+  int *rorig, *rperm;
+  int *last;
+
+  ridx = l.ridx;
+  VectorRational &rval = l.rval;
+  rbeg = l.rbeg;
+  rorig = l.rorig;
+  rperm = l.rperm;
+  n = 0;
+
+  i = l.firstUpdate - 1;
+#ifndef WITH_L_ROWS
+#pragma warn "Not yet implemented, define WITH_L_ROWS"
+  VectorRational &lval = l.val;
+  int *lidx = l.idx;
+  int *lrow = l.row;
+  int *lbeg = l.start;
+
+  for (; i >= 0; --i) {
+    k = lbeg[i];
+    val = &lval[k];
+    idx = &lidx[k];
+    x = 0;
+
+    for (j = lbeg[i + 1]; j > k; --j)
+      x += vec[*idx++] * (*val++);
+
+    vec[lrow[i]] -= x;
+  }
 
 #else
 
-   /*  move rhsidx to a heap
-    */
-   for(i = 0; i < rn;)
-      enQueueMaxRat(nonz, &i, rperm[nonz[i]]);
+  /*  move rhsidx to a heap
+   */
+  for (i = 0; i < rn;)
+    enQueueMaxRat(nonz, &i, rperm[nonz[i]]);
 
-   last = nonz + thedim;
+  last = nonz + thedim;
 
-   while(rn > 0)
-   {
-      i = deQueueMaxRat(nonz, &rn);
-      r = rorig[i];
-      x = vec[r];
+  while (rn > 0) {
+    i = deQueueMaxRat(nonz, &rn);
+    r = rorig[i];
+    x = vec[r];
 
-      if(x != 0)
-      {
-         *(--last) = r;
-         n++;
-         k = rbeg[r];
-         j = rbeg[r + 1] - k;
-         val = &rval[k];
-         idx = &ridx[k];
-
-         while(j-- > 0)
-         {
-            assert(l.rperm[*idx] < i);
-            int m = *idx++;
-            y = vec[m];
-
-            if(y == 0)
-            {
-               y = -x * *val++;
-
-               if(y != 0)
-               {
-                  vec[m] = y;
-                  enQueueMaxRat(nonz, &rn, rperm[m]);
-               }
-            }
-            else
-            {
-               y -= x * *val++;
-               //               vec[m] = ( y != 0 ) ? y : MARKER;
-               vec[m] = y;
-            }
-         }
+    if (x != 0) {
+      *(--last) = r;
+      n++;
+      k = rbeg[r];
+      j = rbeg[r + 1] - k;
+      val = &rval[k];
+      idx = &ridx[k];
+
+      while (j-- > 0) {
+        assert(l.rperm[*idx] < i);
+        int m = *idx++;
+        y = vec[m];
+
+        if (y == 0) {
+          y = -x * *val++;
+
+          if (y != 0) {
+            vec[m] = y;
+            enQueueMaxRat(nonz, &rn, rperm[m]);
+          }
+        } else {
+          y -= x * *val++;
+          //               vec[m] = ( y != 0 ) ? y : MARKER;
+          vec[m] = y;
+        }
       }
-      else
-         vec[r] = 0;
-   }
+    } else
+      vec[r] = 0;
+  }
 
-   for(i = 0; i < n; ++i)
-      *nonz++ = *last++;
+  for (i = 0; i < n; ++i)
+    *nonz++ = *last++;
 
 #endif
 
-   return n;
+  return n;
 }
 
+inline void CLUFactorRational::solveLleftNoNZ(Rational *vec) {
+  int i, j, k;
+  int r;
+  Rational x;
+  Rational *val;
+  int *ridx, *idx;
+  int *rbeg;
+  int *rorig;
 
-inline void CLUFactorRational::solveLleftNoNZ(Rational* vec)
-{
-   int i, j, k;
-   int r;
-   Rational x;
-   Rational* val;
-   int* ridx, *idx;
-   int* rbeg;
-   int* rorig;
-
-   ridx = l.ridx;
-   VectorRational& rval = l.rval;
-   rbeg = l.rbeg;
-   rorig = l.rorig;
+  ridx = l.ridx;
+  VectorRational &rval = l.rval;
+  rbeg = l.rbeg;
+  rorig = l.rorig;
 
 #ifndef WITH_L_ROWS
-   VectorRational& lval = l.val;
-   int*    lidx = l.idx;
-   int*    lrow = l.row;
-   int*    lbeg = l.start;
-
-   i = l.firstUpdate - 1;
-   assert(i < thedim);
-
-   for(; i >= 0; --i)
-   {
-      k = lbeg[i];
-      assert(k >= 0 && k < l.val.dim());
-      val = &lval[k];
-      idx = &lidx[k];
-      x = 0;
-
-      for(j = lbeg[i + 1]; j > k; --j)
-      {
-         assert(*idx >= 0 && *idx < thedim);
-         x += vec[*idx++] * (*val++);
-      }
+  VectorRational &lval = l.val;
+  int *lidx = l.idx;
+  int *lrow = l.row;
+  int *lbeg = l.start;
+
+  i = l.firstUpdate - 1;
+  assert(i < thedim);
+
+  for (; i >= 0; --i) {
+    k = lbeg[i];
+    assert(k >= 0 && k < l.val.dim());
+    val = &lval[k];
+    idx = &lidx[k];
+    x = 0;
+
+    for (j = lbeg[i + 1]; j > k; --j) {
+      assert(*idx >= 0 && *idx < thedim);
+      x += vec[*idx++] * (*val++);
+    }
 
-      vec[lrow[i]] -= x;
-   }
+    vec[lrow[i]] -= x;
+  }
 
 #else
 
-   for(i = thedim; i--;)
-   {
-      r = rorig[i];
-      x = vec[r];
+  for (i = thedim; i--;) {
+    r = rorig[i];
+    x = vec[r];
 
-      if(x != 0)
-      {
-         k = rbeg[r];
-         j = rbeg[r + 1] - k;
-         val = &rval[k];
-         idx = &ridx[k];
-
-         while(j-- > 0)
-         {
-            assert(l.rperm[*idx] < i);
-            vec[*idx++] -= x * *val++;
-         }
+    if (x != 0) {
+      k = rbeg[r];
+      j = rbeg[r + 1] - k;
+      val = &rval[k];
+      idx = &ridx[k];
+
+      while (j-- > 0) {
+        assert(l.rperm[*idx] < i);
+        vec[*idx++] -= x * *val++;
       }
-   }
+    }
+  }
 
 #endif
 }
 
-inline int CLUFactorRational::vSolveLright(Rational* vec, int* ridx, int rn)
-{
-   int i, j, k, n;
-   int end;
-   Rational x;
-   Rational* val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
-
-   VectorRational& lval = l.val;
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
+inline int CLUFactorRational::vSolveLright(Rational *vec, int *ridx, int rn) {
+  int i, j, k, n;
+  int end;
+  Rational x;
+  Rational *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
 
-   end = l.firstUpdate;
+  VectorRational &lval = l.val;
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
 
-   for(i = 0; i < end; ++i)
-   {
-      x = vec[lrow[i]];
+  end = l.firstUpdate;
 
-      if(x != 0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+  for (i = 0; i < end; ++i) {
+    x = vec[lrow[i]];
 
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            assert(*idx >= 0 && *idx < thedim);
-            ridx[rn] = n = *idx++;
-            rn += (vec[n] == 0) ? 1 : 0;
-            vec[n] -= x * (*val++);
-            //            vec[n] += ( vec[n] == 0 ) ? MARKER : 0;
-         }
+    if (x != 0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
+
+      for (j = lbeg[i + 1]; j > k; --j) {
+        assert(*idx >= 0 && *idx < thedim);
+        ridx[rn] = n = *idx++;
+        rn += (vec[n] == 0) ? 1 : 0;
+        vec[n] -= x * (*val++);
+        //            vec[n] += ( vec[n] == 0 ) ? MARKER : 0;
       }
-   }
+    }
+  }
 
-   if(l.updateType)                      /* Forest-Tomlin Updates */
-   {
-      end = l.firstUnused;
+  if (l.updateType) /* Forest-Tomlin Updates */
+  {
+    end = l.firstUnused;
 
-      for(; i < end; ++i)
-      {
-         x = 0;
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+    for (; i < end; ++i) {
+      x = 0;
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            assert(*idx >= 0 && *idx < thedim);
-            x += vec[*idx++] * (*val++);
-         }
+      for (j = lbeg[i + 1]; j > k; --j) {
+        assert(*idx >= 0 && *idx < thedim);
+        x += vec[*idx++] * (*val++);
+      }
 
-         ridx[rn] = j = lrow[i];
+      ridx[rn] = j = lrow[i];
 
-         rn += (vec[j] == 0) ? 1 : 0;
-         vec[j] -= x;
-         //         vec[j] += ( vec[j] == 0 ) ? MARKER : 0;
-      }
-   }
+      rn += (vec[j] == 0) ? 1 : 0;
+      vec[j] -= x;
+      //         vec[j] += ( vec[j] == 0 ) ? MARKER : 0;
+    }
+  }
 
-   return rn;
+  return rn;
 }
 
-inline void CLUFactorRational::vSolveLright2(Rational* vec, int* ridx, int* rnptr,
-      Rational* vec2, int* ridx2, int* rn2ptr)
-{
-   int i, j, k, n;
-   int end;
-   Rational x, y;
-   Rational x2, y2;
-   Rational* val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
-
-   int rn = *rnptr;
-   int rn2 = *rn2ptr;
-
-   VectorRational& lval = l.val;
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-
-   end = l.firstUpdate;
-
-   for(i = 0; i < end; ++i)
-   {
-      j = lrow[i];
-      x2 = vec2[j];
-      x = vec[j];
-
-      if(x != 0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-
-         if(x2 != 0)
-         {
-            for(j = lbeg[i + 1]; j > k; --j)
-            {
-               assert(*idx >= 0 && *idx < thedim);
-               ridx[rn] = ridx2[rn2] = n = *idx++;
-               y = vec[n];
-               y2 = vec2[n];
-               rn += (y == 0) ? 1 : 0;
-               rn2 += (y2 == 0) ? 1 : 0;
-               y -= x * (*val);
-               y2 -= x2 * (*val++);
-               //               vec[n] = y + ( y == 0 ? MARKER : 0 );
-               //               vec2[n] = y2 + ( y2 == 0 ? MARKER : 0 );
-               vec[n] = y;
-               vec2[n] = y2;
-            }
-         }
-         else
-         {
-            for(j = lbeg[i + 1]; j > k; --j)
-            {
-               assert(*idx >= 0 && *idx < thedim);
-               ridx[rn] = n = *idx++;
-               y = vec[n];
-               rn += (y == 0) ? 1 : 0;
-               y -= x * (*val++);
-               //               vec[n] = y + ( y == 0 ? MARKER : 0 );
-               vec[n] = y;
-            }
-         }
+inline void CLUFactorRational::vSolveLright2(Rational *vec, int *ridx,
+                                             int *rnptr, Rational *vec2,
+                                             int *ridx2, int *rn2ptr) {
+  int i, j, k, n;
+  int end;
+  Rational x, y;
+  Rational x2, y2;
+  Rational *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
+
+  int rn = *rnptr;
+  int rn2 = *rn2ptr;
+
+  VectorRational &lval = l.val;
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
+
+  end = l.firstUpdate;
+
+  for (i = 0; i < end; ++i) {
+    j = lrow[i];
+    x2 = vec2[j];
+    x = vec[j];
+
+    if (x != 0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
+
+      if (x2 != 0) {
+        for (j = lbeg[i + 1]; j > k; --j) {
+          assert(*idx >= 0 && *idx < thedim);
+          ridx[rn] = ridx2[rn2] = n = *idx++;
+          y = vec[n];
+          y2 = vec2[n];
+          rn += (y == 0) ? 1 : 0;
+          rn2 += (y2 == 0) ? 1 : 0;
+          y -= x * (*val);
+          y2 -= x2 * (*val++);
+          //               vec[n] = y + ( y == 0 ? MARKER : 0 );
+          //               vec2[n] = y2 + ( y2 == 0 ? MARKER : 0 );
+          vec[n] = y;
+          vec2[n] = y2;
+        }
+      } else {
+        for (j = lbeg[i + 1]; j > k; --j) {
+          assert(*idx >= 0 && *idx < thedim);
+          ridx[rn] = n = *idx++;
+          y = vec[n];
+          rn += (y == 0) ? 1 : 0;
+          y -= x * (*val++);
+          //               vec[n] = y + ( y == 0 ? MARKER : 0 );
+          vec[n] = y;
+        }
       }
-      else if(x2 != 0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            assert(*idx >= 0 && *idx < thedim);
-            ridx2[rn2] = n = *idx++;
-            y2 = vec2[n];
-            rn2 += (y2 == 0) ? 1 : 0;
-            y2 -= x2 * (*val++);
-            //               vec2[n] = y2 + ( y2 == 0 ? MARKER : 0 );
-            vec2[n] = y2;
-         }
+    } else if (x2 != 0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
+
+      for (j = lbeg[i + 1]; j > k; --j) {
+        assert(*idx >= 0 && *idx < thedim);
+        ridx2[rn2] = n = *idx++;
+        y2 = vec2[n];
+        rn2 += (y2 == 0) ? 1 : 0;
+        y2 -= x2 * (*val++);
+        //               vec2[n] = y2 + ( y2 == 0 ? MARKER : 0 );
+        vec2[n] = y2;
       }
-   }
+    }
+  }
 
-   if(l.updateType)                      /* Forest-Tomlin Updates */
-   {
-      end = l.firstUnused;
+  if (l.updateType) /* Forest-Tomlin Updates */
+  {
+    end = l.firstUnused;
 
-      for(; i < end; ++i)
-      {
-         x = x2 = 0;
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+    for (; i < end; ++i) {
+      x = x2 = 0;
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            assert(*idx >= 0 && *idx < thedim);
-            x += vec[*idx] * (*val);
-            x2 += vec2[*idx++] * (*val++);
-         }
-
-         ridx[rn] = ridx2[rn2] = j = lrow[i];
-
-         rn += (vec[j] == 0) ? 1 : 0;
-         rn2 += (vec2[j] == 0) ? 1 : 0;
-         vec[j] -= x;
-         vec2[j] -= x2;
-         //         vec[j] += ( vec[j] == 0 ) ? MARKER : 0;
-         //         vec2[j] += ( vec2[j] == 0 ) ? MARKER : 0;
+      for (j = lbeg[i + 1]; j > k; --j) {
+        assert(*idx >= 0 && *idx < thedim);
+        x += vec[*idx] * (*val);
+        x2 += vec2[*idx++] * (*val++);
       }
-   }
 
-   *rnptr = rn;
+      ridx[rn] = ridx2[rn2] = j = lrow[i];
+
+      rn += (vec[j] == 0) ? 1 : 0;
+      rn2 += (vec2[j] == 0) ? 1 : 0;
+      vec[j] -= x;
+      vec2[j] -= x2;
+      //         vec[j] += ( vec[j] == 0 ) ? MARKER : 0;
+      //         vec2[j] += ( vec2[j] == 0 ) ? MARKER : 0;
+    }
+  }
+
+  *rnptr = rn;
 
-   *rn2ptr = rn2;
+  *rn2ptr = rn2;
 }
 
-inline void CLUFactorRational::vSolveLright3(Rational* vec, int* ridx, int* rnptr,
-      Rational* vec2, int* ridx2, int* rn2ptr,
-      Rational* vec3, int* ridx3, int* rn3ptr)
-{
-   int i, j, k, n;
-   int end;
-   Rational x, y;
-   Rational x2, y2;
-   Rational x3, y3;
-   Rational* val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
-
-   int rn = *rnptr;
-   int rn2 = *rn2ptr;
-   int rn3 = *rn3ptr;
-
-   VectorRational& lval = l.val;
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-
-   end = l.firstUpdate;
-
-   for(i = 0; i < end; ++i)
-   {
-      j = lrow[i];
-      x3 = vec3[j];
-      x2 = vec2[j];
-      x = vec[j];
-
-      if(x != 0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-
-         if(x2 != 0)
-         {
-            if(x3 != 0)
-            {
-               // case 1: all three vectors are nonzero at j
-               for(j = lbeg[i + 1]; j > k; --j)
-               {
-                  assert(*idx >= 0 && *idx < thedim);
-                  ridx[rn] = ridx2[rn2] = ridx3[rn3] = n = *idx++;
-                  y = vec[n];
-                  y2 = vec2[n];
-                  y3 = vec3[n];
-                  rn += (y == 0) ? 1 : 0;
-                  rn2 += (y2 == 0) ? 1 : 0;
-                  rn3 += (y3 == 0) ? 1 : 0;
-                  y -= x * (*val);
-                  y2 -= x2 * (*val);
-                  y3 -= x3 * (*val++);
-                  //                  vec[n] = y + ( y == 0 ? MARKER : 0 );
-                  //                  vec2[n] = y2 + ( y2 == 0 ? MARKER : 0 );
-                  //                  vec3[n] = y3 + ( y3 == 0 ? MARKER : 0 );
-                  vec[n] = y;
-                  vec2[n] = y2;
-                  vec3[n] = y3;
-               }
-            }
-            else
-            {
-               // case 2: 1 and 2 are nonzero at j
-               for(j = lbeg[i + 1]; j > k; --j)
-               {
-                  assert(*idx >= 0 && *idx < thedim);
-                  ridx[rn] = ridx2[rn2] = n = *idx++;
-                  y = vec[n];
-                  y2 = vec2[n];
-                  rn += (y == 0) ? 1 : 0;
-                  rn2 += (y2 == 0) ? 1 : 0;
-                  y -= x * (*val);
-                  y2 -= x2 * (*val++);
-                  //                  vec[n] = y + ( y == 0 ? MARKER : 0 );
-                  //vec2[n] = y2 + ( y2 == 0 ? MARKER : 0 );
-                  vec[n] = y;
-                  vec2[n] = y2;
-               }
-            }
-         }
-         else if(x3 != 0)
-         {
-            // case 3: 1 and 3 are nonzero at j
-            for(j = lbeg[i + 1]; j > k; --j)
-            {
-               assert(*idx >= 0 && *idx < thedim);
-               ridx[rn] = ridx3[rn3] = n = *idx++;
-               y = vec[n];
-               y3 = vec3[n];
-               rn += (y == 0) ? 1 : 0;
-               rn3 += (y3 == 0) ? 1 : 0;
-               y -= x * (*val);
-               y3 -= x3 * (*val++);
-               //                  vec[n] = y + ( y == 0 ? MARKER : 0 );
-               //                  vec3[n] = y3 + ( y3 == 0 ? MARKER : 0 );
-               vec[n] = y;
-               vec3[n] = y3;
-            }
-         }
-         else
-         {
-            // case 4: only 1 is nonzero at j
-            for(j = lbeg[i + 1]; j > k; --j)
-            {
-               assert(*idx >= 0 && *idx < thedim);
-               ridx[rn] = n = *idx++;
-               y = vec[n];
-               rn += (y == 0) ? 1 : 0;
-               y -= x * (*val++);
-               //                  vec[n] = y + ( y == 0 ? MARKER : 0 );
-               vec[n] = y;
-            }
-         }
-      }
-      else if(x2 != 0)
-      {
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-
-         if(x3 != 0)
-         {
-            // case 5: 2 and 3 are nonzero at j
-            for(j = lbeg[i + 1]; j > k; --j)
-            {
-               assert(*idx >= 0 && *idx < thedim);
-               ridx2[rn2] = ridx3[rn3] = n = *idx++;
-               y2 = vec2[n];
-               y3 = vec3[n];
-               rn2 += (y2 == 0) ? 1 : 0;
-               rn3 += (y3 == 0) ? 1 : 0;
-               y2 -= x2 * (*val);
-               y3 -= x3 * (*val++);
-               //                  vec2[n] = y2 + ( y2 == 0 ? MARKER : 0 );
-               //                  vec3[n] = y3 + ( y3 == 0 ? MARKER : 0 );
-               vec2[n] = y2;
-               vec3[n] = y3;
-            }
-         }
-         else
-         {
-            // case 6: only 2 is nonzero at j
-            for(j = lbeg[i + 1]; j > k; --j)
-            {
-               assert(*idx >= 0 && *idx < thedim);
-               ridx2[rn2] = n = *idx++;
-               y2 = vec2[n];
-               rn2 += (y2 == 0) ? 1 : 0;
-               y2 -= x2 * (*val++);
-               //                  vec2[n] = y2 + ( y2 == 0 ? MARKER : 0 );
-               vec2[n] = y2;
-            }
-         }
-      }
-      else if(x3 != 0)
-      {
-         // case 7: only 3 is nonzero at j
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+inline void CLUFactorRational::vSolveLright3(Rational *vec, int *ridx,
+                                             int *rnptr, Rational *vec2,
+                                             int *ridx2, int *rn2ptr,
+                                             Rational *vec3, int *ridx3,
+                                             int *rn3ptr) {
+  int i, j, k, n;
+  int end;
+  Rational x, y;
+  Rational x2, y2;
+  Rational x3, y3;
+  Rational *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
+
+  int rn = *rnptr;
+  int rn2 = *rn2ptr;
+  int rn3 = *rn3ptr;
+
+  VectorRational &lval = l.val;
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
+
+  end = l.firstUpdate;
+
+  for (i = 0; i < end; ++i) {
+    j = lrow[i];
+    x3 = vec3[j];
+    x2 = vec2[j];
+    x = vec[j];
+
+    if (x != 0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
+      if (x2 != 0) {
+        if (x3 != 0) {
+          // case 1: all three vectors are nonzero at j
+          for (j = lbeg[i + 1]; j > k; --j) {
             assert(*idx >= 0 && *idx < thedim);
-            ridx3[rn3] = n = *idx++;
+            ridx[rn] = ridx2[rn2] = ridx3[rn3] = n = *idx++;
+            y = vec[n];
+            y2 = vec2[n];
             y3 = vec3[n];
+            rn += (y == 0) ? 1 : 0;
+            rn2 += (y2 == 0) ? 1 : 0;
             rn3 += (y3 == 0) ? 1 : 0;
+            y -= x * (*val);
+            y2 -= x2 * (*val);
             y3 -= x3 * (*val++);
+            //                  vec[n] = y + ( y == 0 ? MARKER : 0 );
+            //                  vec2[n] = y2 + ( y2 == 0 ? MARKER : 0 );
             //                  vec3[n] = y3 + ( y3 == 0 ? MARKER : 0 );
+            vec[n] = y;
+            vec2[n] = y2;
             vec3[n] = y3;
-         }
+          }
+        } else {
+          // case 2: 1 and 2 are nonzero at j
+          for (j = lbeg[i + 1]; j > k; --j) {
+            assert(*idx >= 0 && *idx < thedim);
+            ridx[rn] = ridx2[rn2] = n = *idx++;
+            y = vec[n];
+            y2 = vec2[n];
+            rn += (y == 0) ? 1 : 0;
+            rn2 += (y2 == 0) ? 1 : 0;
+            y -= x * (*val);
+            y2 -= x2 * (*val++);
+            //                  vec[n] = y + ( y == 0 ? MARKER : 0 );
+            // vec2[n] = y2 + ( y2 == 0 ? MARKER : 0 );
+            vec[n] = y;
+            vec2[n] = y2;
+          }
+        }
+      } else if (x3 != 0) {
+        // case 3: 1 and 3 are nonzero at j
+        for (j = lbeg[i + 1]; j > k; --j) {
+          assert(*idx >= 0 && *idx < thedim);
+          ridx[rn] = ridx3[rn3] = n = *idx++;
+          y = vec[n];
+          y3 = vec3[n];
+          rn += (y == 0) ? 1 : 0;
+          rn3 += (y3 == 0) ? 1 : 0;
+          y -= x * (*val);
+          y3 -= x3 * (*val++);
+          //                  vec[n] = y + ( y == 0 ? MARKER : 0 );
+          //                  vec3[n] = y3 + ( y3 == 0 ? MARKER : 0 );
+          vec[n] = y;
+          vec3[n] = y3;
+        }
+      } else {
+        // case 4: only 1 is nonzero at j
+        for (j = lbeg[i + 1]; j > k; --j) {
+          assert(*idx >= 0 && *idx < thedim);
+          ridx[rn] = n = *idx++;
+          y = vec[n];
+          rn += (y == 0) ? 1 : 0;
+          y -= x * (*val++);
+          //                  vec[n] = y + ( y == 0 ? MARKER : 0 );
+          vec[n] = y;
+        }
       }
-   }
-
-   if(l.updateType)                      /* Forest-Tomlin Updates */
-   {
-      end = l.firstUnused;
+    } else if (x2 != 0) {
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
+
+      if (x3 != 0) {
+        // case 5: 2 and 3 are nonzero at j
+        for (j = lbeg[i + 1]; j > k; --j) {
+          assert(*idx >= 0 && *idx < thedim);
+          ridx2[rn2] = ridx3[rn3] = n = *idx++;
+          y2 = vec2[n];
+          y3 = vec3[n];
+          rn2 += (y2 == 0) ? 1 : 0;
+          rn3 += (y3 == 0) ? 1 : 0;
+          y2 -= x2 * (*val);
+          y3 -= x3 * (*val++);
+          //                  vec2[n] = y2 + ( y2 == 0 ? MARKER : 0 );
+          //                  vec3[n] = y3 + ( y3 == 0 ? MARKER : 0 );
+          vec2[n] = y2;
+          vec3[n] = y3;
+        }
+      } else {
+        // case 6: only 2 is nonzero at j
+        for (j = lbeg[i + 1]; j > k; --j) {
+          assert(*idx >= 0 && *idx < thedim);
+          ridx2[rn2] = n = *idx++;
+          y2 = vec2[n];
+          rn2 += (y2 == 0) ? 1 : 0;
+          y2 -= x2 * (*val++);
+          //                  vec2[n] = y2 + ( y2 == 0 ? MARKER : 0 );
+          vec2[n] = y2;
+        }
+      }
+    } else if (x3 != 0) {
+      // case 7: only 3 is nonzero at j
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
+
+      for (j = lbeg[i + 1]; j > k; --j) {
+        assert(*idx >= 0 && *idx < thedim);
+        ridx3[rn3] = n = *idx++;
+        y3 = vec3[n];
+        rn3 += (y3 == 0) ? 1 : 0;
+        y3 -= x3 * (*val++);
+        //                  vec3[n] = y3 + ( y3 == 0 ? MARKER : 0 );
+        vec3[n] = y3;
+      }
+    }
+  }
 
-      for(; i < end; ++i)
-      {
-         x = x2 = x3 = 0;
-         k = lbeg[i];
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+  if (l.updateType) /* Forest-Tomlin Updates */
+  {
+    end = l.firstUnused;
 
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            assert(*idx >= 0 && *idx < thedim);
-            x += vec[*idx] * (*val);
-            x2 += vec2[*idx] * (*val);
-            x3 += vec3[*idx++] * (*val++);
-         }
-
-         ridx[rn] = ridx2[rn2] = ridx3[rn3] = j = lrow[i];
-
-         rn += (vec[j] == 0) ? 1 : 0;
-         rn2 += (vec2[j] == 0) ? 1 : 0;
-         rn3 += (vec3[j] == 0) ? 1 : 0;
-         vec[j] -= x;
-         vec2[j] -= x2;
-         vec3[j] -= x3;
-         //         vec[j] += ( vec[j] == 0 ) ? MARKER : 0;
-         //         vec2[j] += ( vec2[j] == 0 ) ? MARKER : 0;
-         //         vec3[j] += ( vec3[j] == 0 ) ? MARKER : 0;
+    for (; i < end; ++i) {
+      x = x2 = x3 = 0;
+      k = lbeg[i];
+      idx = &(lidx[k]);
+      val = &(lval[k]);
+
+      for (j = lbeg[i + 1]; j > k; --j) {
+        assert(*idx >= 0 && *idx < thedim);
+        x += vec[*idx] * (*val);
+        x2 += vec2[*idx] * (*val);
+        x3 += vec3[*idx++] * (*val++);
       }
-   }
 
-   *rnptr = rn;
+      ridx[rn] = ridx2[rn2] = ridx3[rn3] = j = lrow[i];
+
+      rn += (vec[j] == 0) ? 1 : 0;
+      rn2 += (vec2[j] == 0) ? 1 : 0;
+      rn3 += (vec3[j] == 0) ? 1 : 0;
+      vec[j] -= x;
+      vec2[j] -= x2;
+      vec3[j] -= x3;
+      //         vec[j] += ( vec[j] == 0 ) ? MARKER : 0;
+      //         vec2[j] += ( vec2[j] == 0 ) ? MARKER : 0;
+      //         vec3[j] += ( vec3[j] == 0 ) ? MARKER : 0;
+    }
+  }
+
+  *rnptr = rn;
 
-   *rn2ptr = rn2;
-   *rn3ptr = rn3;
+  *rn2ptr = rn2;
+  *rn3ptr = rn3;
 }
 
-inline int CLUFactorRational::vSolveUright(Rational* vec, int* vidx,
-      Rational* rhs, int* ridx, int rn)
-{
-   int i, j, k, r, c, n;
-   int* rorig, *corig;
-   int* rperm;
-   int* cidx, *clen, *cbeg;
-   Rational x, y;
+inline int CLUFactorRational::vSolveUright(Rational *vec, int *vidx,
+                                           Rational *rhs, int *ridx, int rn) {
+  int i, j, k, r, c, n;
+  int *rorig, *corig;
+  int *rperm;
+  int *cidx, *clen, *cbeg;
+  Rational x, y;
 
-   int* idx;
-   Rational* val;
+  int *idx;
+  Rational *val;
 
-   rorig = row.orig;
-   corig = col.orig;
-   rperm = row.perm;
+  rorig = row.orig;
+  corig = col.orig;
+  rperm = row.perm;
 
-   cidx = u.col.idx;
-   VectorRational& cval = u.col.val;
-   clen = u.col.len;
-   cbeg = u.col.start;
+  cidx = u.col.idx;
+  VectorRational &cval = u.col.val;
+  clen = u.col.len;
+  cbeg = u.col.start;
 
-   n = 0;
+  n = 0;
 
-   while(rn > 0)
-   {
-      /*      Find nonzero with highest permuted row index and setup i and r
-       */
-      i = deQueueMaxRat(ridx, &rn);
-      assert(i >= 0 && i < thedim);
-      r = rorig[i];
-      assert(r >= 0 && r < thedim);
+  while (rn > 0) {
+    /*      Find nonzero with highest permuted row index and setup i and r
+     */
+    i = deQueueMaxRat(ridx, &rn);
+    assert(i >= 0 && i < thedim);
+    r = rorig[i];
+    assert(r >= 0 && r < thedim);
 
-      x = diag[r] * rhs[r];
-      rhs[r] = 0;
+    x = diag[r] * rhs[r];
+    rhs[r] = 0;
 
-      if(x != 0)
-      {
-         c = corig[i];
-         assert(c >= 0 && c < thedim);
-         vidx[n++] = c;
-         vec[c] = x;
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
-
-         while(j-- > 0)
-         {
-            assert(*idx >= 0 && *idx < thedim);
-            k = *idx++;
-            assert(k >= 0 && k < thedim);
-            y = rhs[k];
-
-            if(y == 0)
-            {
-               y = -x * (*val++);
-
-               if(y != 0)
-               {
-                  rhs[k] = y;
-                  enQueueMaxRat(ridx, &rn, rperm[k]);
-               }
-            }
-            else
-            {
-               y -= x * (*val++);
-               //               y += ( y == 0 ) ? MARKER : 0;
-               rhs[k] = y;
-            }
-         }
-
-         if(rn > i * verySparseFactor4rightRat)
-         {
-            /* continue with dense case */
-            for(i = *ridx; i >= 0; --i)
-            {
-               r = rorig[i];
-               assert(r >= 0 && r < thedim);
-               x = diag[r] * rhs[r];
-               rhs[r] = 0;
-
-               if(x != 0)
-               {
-                  c = corig[i];
-                  assert(c >= 0 && c < thedim);
-                  vidx[n++] = c;
-                  vec[c] = x;
-                  val = &cval[cbeg[c]];
-                  idx = &cidx[cbeg[c]];
-                  j = clen[c];
-
-                  while(j-- > 0)
-                  {
-                     assert(*idx >= 0 && *idx < thedim);
-                     rhs[*idx++] -= x * (*val++);
-                  }
-               }
+    if (x != 0) {
+      c = corig[i];
+      assert(c >= 0 && c < thedim);
+      vidx[n++] = c;
+      vec[c] = x;
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0) {
+        assert(*idx >= 0 && *idx < thedim);
+        k = *idx++;
+        assert(k >= 0 && k < thedim);
+        y = rhs[k];
+
+        if (y == 0) {
+          y = -x * (*val++);
+
+          if (y != 0) {
+            rhs[k] = y;
+            enQueueMaxRat(ridx, &rn, rperm[k]);
+          }
+        } else {
+          y -= x * (*val++);
+          //               y += ( y == 0 ) ? MARKER : 0;
+          rhs[k] = y;
+        }
+      }
+
+      if (rn > i * verySparseFactor4rightRat) {
+        /* continue with dense case */
+        for (i = *ridx; i >= 0; --i) {
+          r = rorig[i];
+          assert(r >= 0 && r < thedim);
+          x = diag[r] * rhs[r];
+          rhs[r] = 0;
+
+          if (x != 0) {
+            c = corig[i];
+            assert(c >= 0 && c < thedim);
+            vidx[n++] = c;
+            vec[c] = x;
+            val = &cval[cbeg[c]];
+            idx = &cidx[cbeg[c]];
+            j = clen[c];
+
+            while (j-- > 0) {
+              assert(*idx >= 0 && *idx < thedim);
+              rhs[*idx++] -= x * (*val++);
             }
+          }
+        }
 
-            break;
-         }
+        break;
       }
-   }
+    }
+  }
 
-   return n;
+  return n;
 }
 
-
-inline void CLUFactorRational::vSolveUrightNoNZ(Rational* vec, Rational* rhs, int* ridx, int rn)
-{
-   int i, j, k, r, c;
-   int* rorig, *corig;
-   int* rperm;
-   int* cidx, *clen, *cbeg;
-   Rational x, y;
-
-   int* idx;
-   Rational* val;
-
-   rorig = row.orig;
-   corig = col.orig;
-   rperm = row.perm;
-
-   cidx = u.col.idx;
-   VectorRational& cval = u.col.val;
-   clen = u.col.len;
-   cbeg = u.col.start;
-
-   while(rn > 0)
-   {
-      if(rn > *ridx * verySparseFactor4rightRat)
-      {
-         /* continue with dense case */
-         for(i = *ridx; i >= 0; --i)
-         {
-            assert(i >= 0 && i < thedim);
-            r = rorig[i];
-            assert(r >= 0 && r < thedim);
-            x = diag[r] * rhs[r];
-            rhs[r] = 0;
-
-            if(x != 0)
-            {
-               c = corig[i];
-               vec[c] = x;
-               val = &cval[cbeg[c]];
-               idx = &cidx[cbeg[c]];
-               j = clen[c];
-
-               while(j-- > 0)
-               {
-                  assert(*idx >= 0 && *idx < thedim);
-                  rhs[*idx++] -= x * (*val++);
-               }
-            }
-         }
-
-         break;
+inline void CLUFactorRational::vSolveUrightNoNZ(Rational *vec, Rational *rhs,
+                                                int *ridx, int rn) {
+  int i, j, k, r, c;
+  int *rorig, *corig;
+  int *rperm;
+  int *cidx, *clen, *cbeg;
+  Rational x, y;
+
+  int *idx;
+  Rational *val;
+
+  rorig = row.orig;
+  corig = col.orig;
+  rperm = row.perm;
+
+  cidx = u.col.idx;
+  VectorRational &cval = u.col.val;
+  clen = u.col.len;
+  cbeg = u.col.start;
+
+  while (rn > 0) {
+    if (rn > *ridx * verySparseFactor4rightRat) {
+      /* continue with dense case */
+      for (i = *ridx; i >= 0; --i) {
+        assert(i >= 0 && i < thedim);
+        r = rorig[i];
+        assert(r >= 0 && r < thedim);
+        x = diag[r] * rhs[r];
+        rhs[r] = 0;
+
+        if (x != 0) {
+          c = corig[i];
+          vec[c] = x;
+          val = &cval[cbeg[c]];
+          idx = &cidx[cbeg[c]];
+          j = clen[c];
+
+          while (j-- > 0) {
+            assert(*idx >= 0 && *idx < thedim);
+            rhs[*idx++] -= x * (*val++);
+          }
+        }
       }
 
-      /*      Find nonzero with highest permuted row index and setup i and r
-       */
-      i = deQueueMaxRat(ridx, &rn);
+      break;
+    }
 
-      assert(i >= 0 && i < thedim);
+    /*      Find nonzero with highest permuted row index and setup i and r
+     */
+    i = deQueueMaxRat(ridx, &rn);
 
-      r = rorig[i];
+    assert(i >= 0 && i < thedim);
 
-      assert(r >= 0 && r < thedim);
+    r = rorig[i];
 
-      x = diag[r] * rhs[r];
+    assert(r >= 0 && r < thedim);
 
-      rhs[r] = 0;
+    x = diag[r] * rhs[r];
 
-      if(x != 0)
-      {
-         c = corig[i];
-         vec[c] = x;
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
-
-         while(j-- > 0)
-         {
-            k = *idx++;
-            assert(k >= 0 && k < thedim);
-            y = rhs[k];
-
-            if(y == 0)
-            {
-               y = -x * (*val++);
-
-               if(y != 0)
-               {
-                  rhs[k] = y;
-                  enQueueMaxRat(ridx, &rn, rperm[k]);
-               }
-            }
-            else
-            {
-               y -= x * (*val++);
-               //               y += ( y == 0 ) ? MARKER : 0;
-               rhs[k] = y;
-            }
-         }
+    rhs[r] = 0;
+
+    if (x != 0) {
+      c = corig[i];
+      vec[c] = x;
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0) {
+        k = *idx++;
+        assert(k >= 0 && k < thedim);
+        y = rhs[k];
+
+        if (y == 0) {
+          y = -x * (*val++);
+
+          if (y != 0) {
+            rhs[k] = y;
+            enQueueMaxRat(ridx, &rn, rperm[k]);
+          }
+        } else {
+          y -= x * (*val++);
+          //               y += ( y == 0 ) ? MARKER : 0;
+          rhs[k] = y;
+        }
       }
-   }
+    }
+  }
 }
 
+inline int CLUFactorRational::vSolveUright2(Rational *vec, int *vidx,
+                                            Rational *rhs, int *ridx, int rn,
+                                            Rational *vec2, Rational *rhs2,
+                                            int *ridx2, int rn2) {
+  int i, j, k, r, c, n;
+  int *rorig, *corig;
+  int *rperm;
+  int *cidx, *clen, *cbeg;
+  Rational x, y;
+  Rational x2, y2;
+
+  int *idx;
+  Rational *val;
+
+  rorig = row.orig;
+  corig = col.orig;
+  rperm = row.perm;
+
+  cidx = u.col.idx;
+  VectorRational &cval = u.col.val;
+  clen = u.col.len;
+  cbeg = u.col.start;
+
+  n = 0;
+
+  while (rn + rn2 > 0) {
+    /*      Find nonzero with highest permuted row index and setup i and r
+     */
+    if (rn <= 0)
+      i = deQueueMaxRat(ridx2, &rn2);
+    else if (rn2 <= 0)
+      i = deQueueMaxRat(ridx, &rn);
+    else if (*ridx2 > *ridx)
+      i = deQueueMaxRat(ridx2, &rn2);
+    else if (*ridx2 < *ridx)
+      i = deQueueMaxRat(ridx, &rn);
+    else {
+      (void)deQueueMaxRat(ridx, &rn);
+      i = deQueueMaxRat(ridx2, &rn2);
+    }
+
+    assert(i >= 0 && i < thedim);
 
-inline int CLUFactorRational::vSolveUright2(Rational* vec, int* vidx, Rational* rhs, int* ridx,
-      int rn,
-      Rational* vec2, Rational* rhs2, int* ridx2, int rn2)
-{
-   int i, j, k, r, c, n;
-   int* rorig, *corig;
-   int* rperm;
-   int* cidx, *clen, *cbeg;
-   Rational x, y;
-   Rational x2, y2;
-
-   int* idx;
-   Rational* val;
-
-   rorig = row.orig;
-   corig = col.orig;
-   rperm = row.perm;
-
-   cidx = u.col.idx;
-   VectorRational& cval = u.col.val;
-   clen = u.col.len;
-   cbeg = u.col.start;
-
-   n = 0;
-
-   while(rn + rn2 > 0)
-   {
-      /*      Find nonzero with highest permuted row index and setup i and r
-       */
-      if(rn <= 0)
-         i = deQueueMaxRat(ridx2, &rn2);
-      else if(rn2 <= 0)
-         i = deQueueMaxRat(ridx, &rn);
-      else if(*ridx2 > *ridx)
-         i = deQueueMaxRat(ridx2, &rn2);
-      else if(*ridx2 < *ridx)
-         i = deQueueMaxRat(ridx, &rn);
-      else
-      {
-         (void) deQueueMaxRat(ridx, &rn);
-         i = deQueueMaxRat(ridx2, &rn2);
-      }
+    r = rorig[i];
+    assert(r >= 0 && r < thedim);
 
-      assert(i >= 0 && i < thedim);
+    x = diag[r] * rhs[r];
+    x2 = diag[r] * rhs2[r];
+    rhs[r] = 0;
+    rhs2[r] = 0;
 
-      r = rorig[i];
-      assert(r >= 0 && r < thedim);
+    if (x != 0) {
+      c = corig[i];
+      vidx[n++] = c;
+      vec[c] = x;
+      vec2[c] = x2;
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      if (x2 != 0) {
+        while (j-- > 0) {
+          k = *idx++;
+          assert(k >= 0 && k < thedim);
+          y2 = rhs2[k];
+
+          if (y2 == 0) {
+            y2 = -x2 * (*val);
+
+            if (y2 != 0) {
+              rhs2[k] = y2;
+              enQueueMaxRat(ridx2, &rn2, rperm[k]);
+            }
+          } else {
+            y2 -= x2 * (*val);
+            //                  rhs2[k] = ( y2 != 0 ) ? y2 : MARKER;
+            rhs2[k] = y2;
+          }
 
-      x = diag[r] * rhs[r];
-      x2 = diag[r] * rhs2[r];
-      rhs[r] = 0;
-      rhs2[r] = 0;
+          y = rhs[k];
 
-      if(x != 0)
-      {
-         c = corig[i];
-         vidx[n++] = c;
-         vec[c] = x;
-         vec2[c] = x2;
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
-
-         if(x2 != 0)
-         {
-            while(j-- > 0)
-            {
-               k = *idx++;
-               assert(k >= 0 && k < thedim);
-               y2 = rhs2[k];
-
-               if(y2 == 0)
-               {
-                  y2 = -x2 * (*val);
-
-                  if(y2 != 0)
-                  {
-                     rhs2[k] = y2;
-                     enQueueMaxRat(ridx2, &rn2, rperm[k]);
-                  }
-               }
-               else
-               {
-                  y2 -= x2 * (*val);
-                  //                  rhs2[k] = ( y2 != 0 ) ? y2 : MARKER;
-                  rhs2[k] = y2;
-               }
-
-               y = rhs[k];
-
-               if(y == 0)
-               {
-                  y = -x * (*val++);
-
-                  if(y != 0)
-                  {
-                     rhs[k] = y;
-                     enQueueMaxRat(ridx, &rn, rperm[k]);
-                  }
-               }
-               else
-               {
-                  y -= x * (*val++);
-                  //                  y += ( y == 0 ) ? MARKER : 0;
-                  rhs[k] = y;
-               }
+          if (y == 0) {
+            y = -x * (*val++);
+
+            if (y != 0) {
+              rhs[k] = y;
+              enQueueMaxRat(ridx, &rn, rperm[k]);
             }
-         }
-         else
-         {
-            while(j-- > 0)
-            {
-               k = *idx++;
-               assert(k >= 0 && k < thedim);
-               y = rhs[k];
-
-               if(y == 0)
-               {
-                  y = -x * (*val++);
-
-                  if(y != 0)
-                  {
-                     rhs[k] = y;
-                     enQueueMaxRat(ridx, &rn, rperm[k]);
-                  }
-               }
-               else
-               {
-                  y -= x * (*val++);
-                  //                  y += ( y == 0 ) ? MARKER : 0;
-                  rhs[k] = y;
-               }
+          } else {
+            y -= x * (*val++);
+            //                  y += ( y == 0 ) ? MARKER : 0;
+            rhs[k] = y;
+          }
+        }
+      } else {
+        while (j-- > 0) {
+          k = *idx++;
+          assert(k >= 0 && k < thedim);
+          y = rhs[k];
+
+          if (y == 0) {
+            y = -x * (*val++);
+
+            if (y != 0) {
+              rhs[k] = y;
+              enQueueMaxRat(ridx, &rn, rperm[k]);
             }
-         }
+          } else {
+            y -= x * (*val++);
+            //                  y += ( y == 0 ) ? MARKER : 0;
+            rhs[k] = y;
+          }
+        }
       }
-      else if(x2 != 0)
-      {
-         c = corig[i];
-         assert(c >= 0 && c < thedim);
-         vec2[c] = x2;
-         val = &cval[cbeg[c]];
-         idx = &cidx[cbeg[c]];
-         j = clen[c];
-
-         while(j-- > 0)
-         {
-            k = *idx++;
-            assert(k >= 0 && k < thedim);
-            y2 = rhs2[k];
-
-            if(y2 == 0)
-            {
-               y2 = -x2 * (*val++);
-
-               if(y2 != 0)
-               {
-                  rhs2[k] = y2;
-                  enQueueMaxRat(ridx2, &rn2, rperm[k]);
-               }
-            }
-            else
-            {
-               y2 -= x2 * (*val++);
-               //                  rhs2[k] = ( y2 != 0 ) ? y2 : MARKER;
-               rhs2[k] = y2;
-            }
-         }
+    } else if (x2 != 0) {
+      c = corig[i];
+      assert(c >= 0 && c < thedim);
+      vec2[c] = x2;
+      val = &cval[cbeg[c]];
+      idx = &cidx[cbeg[c]];
+      j = clen[c];
+
+      while (j-- > 0) {
+        k = *idx++;
+        assert(k >= 0 && k < thedim);
+        y2 = rhs2[k];
+
+        if (y2 == 0) {
+          y2 = -x2 * (*val++);
+
+          if (y2 != 0) {
+            rhs2[k] = y2;
+            enQueueMaxRat(ridx2, &rn2, rperm[k]);
+          }
+        } else {
+          y2 -= x2 * (*val++);
+          //                  rhs2[k] = ( y2 != 0 ) ? y2 : MARKER;
+          rhs2[k] = y2;
+        }
       }
+    }
 
-      if(rn + rn2 > i * verySparseFactor4rightRat)
-      {
-         /* continue with dense case */
-         if(*ridx > *ridx2)
-            i = *ridx;
-         else
-            i = *ridx2;
-
-         for(; i >= 0; --i)
-         {
-            assert(i < thedim);
-            r = rorig[i];
-            assert(r >= 0 && r < thedim);
-            x = diag[r] * rhs[r];
-            x2 = diag[r] * rhs2[r];
-            rhs[r] = 0;
-            rhs2[r] = 0;
-
-            if(x2 != 0)
-            {
-               c = corig[i];
-               assert(c >= 0 && c < thedim);
-               vec2[c] = x2;
-               val = &cval[cbeg[c]];
-               idx = &cidx[cbeg[c]];
-               j = clen[c];
-
-               if(x != 0)
-               {
-                  vidx[n++] = c;
-                  vec[c] = x;
-
-                  while(j-- > 0)
-                  {
-                     assert(*idx >= 0 && *idx < thedim);
-                     rhs[*idx] -= x * (*val);
-                     rhs2[*idx++] -= x2 * (*val++);
-                  }
-               }
-               else
-               {
-                  while(j-- > 0)
-                  {
-                     assert(*idx >= 0 && *idx < thedim);
-                     rhs2[*idx++] -= x2 * (*val++);
-                  }
-               }
+    if (rn + rn2 > i * verySparseFactor4rightRat) {
+      /* continue with dense case */
+      if (*ridx > *ridx2)
+        i = *ridx;
+      else
+        i = *ridx2;
+
+      for (; i >= 0; --i) {
+        assert(i < thedim);
+        r = rorig[i];
+        assert(r >= 0 && r < thedim);
+        x = diag[r] * rhs[r];
+        x2 = diag[r] * rhs2[r];
+        rhs[r] = 0;
+        rhs2[r] = 0;
+
+        if (x2 != 0) {
+          c = corig[i];
+          assert(c >= 0 && c < thedim);
+          vec2[c] = x2;
+          val = &cval[cbeg[c]];
+          idx = &cidx[cbeg[c]];
+          j = clen[c];
+
+          if (x != 0) {
+            vidx[n++] = c;
+            vec[c] = x;
+
+            while (j-- > 0) {
+              assert(*idx >= 0 && *idx < thedim);
+              rhs[*idx] -= x * (*val);
+              rhs2[*idx++] -= x2 * (*val++);
             }
-            else if(x != 0)
-            {
-               c = corig[i];
-               assert(c >= 0 && c < thedim);
-               vidx[n++] = c;
-               vec[c] = x;
-               val = &cval[cbeg[c]];
-               idx = &cidx[cbeg[c]];
-               j = clen[c];
-
-               while(j-- > 0)
-               {
-                  assert(*idx >= 0 && *idx < thedim);
-                  rhs[*idx++] -= x * (*val++);
-               }
+          } else {
+            while (j-- > 0) {
+              assert(*idx >= 0 && *idx < thedim);
+              rhs2[*idx++] -= x2 * (*val++);
             }
-         }
-
-         break;
-      }
-   }
-
-   return n;
-}
-
-inline int CLUFactorRational::vSolveUpdateRight(Rational* vec, int* ridx, int n)
-{
-   int i, j, k;
-   int end;
-   Rational x, y;
-   Rational* val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
-
-   assert(!l.updateType);               /* no Forest-Tomlin Updates */
-
-   VectorRational& lval = l.val;
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-   end = l.firstUnused;
-
-   for(i = l.firstUpdate; i < end; ++i)
-   {
-      assert(i >= 0 && i < thedim);
-      x = vec[lrow[i]];
-
-      if(x != 0)
-      {
-         k = lbeg[i];
-         assert(k >= 0 && k < l.val.dim());
-         idx = &(lidx[k]);
-         val = &(lval[k]);
-
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            int m = ridx[n] = *idx++;
-            assert(m >= 0 && m < thedim);
-            y = vec[m];
-            n += (y == 0) ? 1 : 0;
-            y = y - x * (*val++);
-            //            vec[m] = ( y != 0 ) ? y : MARKER;
-            vec[m] = y;
-         }
+          }
+        } else if (x != 0) {
+          c = corig[i];
+          assert(c >= 0 && c < thedim);
+          vidx[n++] = c;
+          vec[c] = x;
+          val = &cval[cbeg[c]];
+          idx = &cidx[cbeg[c]];
+          j = clen[c];
+
+          while (j-- > 0) {
+            assert(*idx >= 0 && *idx < thedim);
+            rhs[*idx++] -= x * (*val++);
+          }
+        }
       }
-   }
-
-   return n;
-}
 
-inline void CLUFactorRational::vSolveUpdateRightNoNZ(Rational* vec)
-{
-   int i, j, k;
-   int end;
-   Rational x;
-   Rational* val;
-   int* lrow, *lidx, *idx;
-   int* lbeg;
-
-   assert(!l.updateType);               /* no Forest-Tomlin Updates */
-
-   VectorRational& lval = l.val;
-   lidx = l.idx;
-   lrow = l.row;
-   lbeg = l.start;
-   end = l.firstUnused;
-
-   for(i = l.firstUpdate; i < end; ++i)
-   {
-      assert(i >= 0 && i < thedim);
-
-      if((x = vec[lrow[i]]) != 0)
-      {
-         k = lbeg[i];
-         assert(k >= 0 && k < l.val.dim());
-         idx = &(lidx[k]);
-         val = &(lval[k]);
+      break;
+    }
+  }
 
-         for(j = lbeg[i + 1]; j > k; --j)
-         {
-            assert(*idx >= 0 && *idx < thedim);
-            vec[*idx++] -= x * (*val++);
-         }
-      }
-   }
+  return n;
 }
 
+inline int CLUFactorRational::vSolveUpdateRight(Rational *vec, int *ridx,
+                                                int n) {
+  int i, j, k;
+  int end;
+  Rational x, y;
+  Rational *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
 
-inline int CLUFactorRational::vSolveRight4update(Rational* vec,
-      int* idx,                              /* result */
-      Rational* rhs, int* ridx, int rn,                    /* rhs    */
-      Rational* forest, int* forestNum, int* forestIdx)
-{
-   rn = vSolveLright(rhs, ridx, rn);
-
-   /*  turn index list into a heap
-    */
+  assert(!l.updateType); /* no Forest-Tomlin Updates */
 
-   if(forest)
-   {
-      Rational x;
-      int i, j, k;
-      int* rperm;
-      int* it = forestIdx;
+  VectorRational &lval = l.val;
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
+  end = l.firstUnused;
 
-      rperm = row.perm;
+  for (i = l.firstUpdate; i < end; ++i) {
+    assert(i >= 0 && i < thedim);
+    x = vec[lrow[i]];
 
-      for(i = j = 0; i < rn; ++i)
-      {
-         k = ridx[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs[k];
-
-         if(x != 0)
-         {
-            enQueueMaxRat(ridx, &j, rperm[*it++ = k]);
-            forest[k] = x;
-         }
-         else
-            rhs[k] = 0;
+    if (x != 0) {
+      k = lbeg[i];
+      assert(k >= 0 && k < l.val.dim());
+      idx = &(lidx[k]);
+      val = &(lval[k]);
+
+      for (j = lbeg[i + 1]; j > k; --j) {
+        int m = ridx[n] = *idx++;
+        assert(m >= 0 && m < thedim);
+        y = vec[m];
+        n += (y == 0) ? 1 : 0;
+        y = y - x * (*val++);
+        //            vec[m] = ( y != 0 ) ? y : MARKER;
+        vec[m] = y;
       }
+    }
+  }
 
-      *forestNum = rn = j;
-   }
-   else
-   {
-      Rational x;
-      int i, j, k;
-      int* rperm;
+  return n;
+}
 
-      rperm = row.perm;
+inline void CLUFactorRational::vSolveUpdateRightNoNZ(Rational *vec) {
+  int i, j, k;
+  int end;
+  Rational x;
+  Rational *val;
+  int *lrow, *lidx, *idx;
+  int *lbeg;
 
-      for(i = j = 0; i < rn; ++i)
-      {
-         k = ridx[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs[k];
-
-         if(x != 0)
-            enQueueMaxRat(ridx, &j, rperm[k]);
-         else
-            rhs[k] = 0;
-      }
+  assert(!l.updateType); /* no Forest-Tomlin Updates */
 
-      rn = j;
-   }
+  VectorRational &lval = l.val;
+  lidx = l.idx;
+  lrow = l.row;
+  lbeg = l.start;
+  end = l.firstUnused;
 
-   rn = vSolveUright(vec, idx, rhs, ridx, rn);
+  for (i = l.firstUpdate; i < end; ++i) {
+    assert(i >= 0 && i < thedim);
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-      rn = vSolveUpdateRight(vec, idx, rn);
+    if ((x = vec[lrow[i]]) != 0) {
+      k = lbeg[i];
+      assert(k >= 0 && k < l.val.dim());
+      idx = &(lidx[k]);
+      val = &(lval[k]);
 
-   return rn;
+      for (j = lbeg[i + 1]; j > k; --j) {
+        assert(*idx >= 0 && *idx < thedim);
+        vec[*idx++] -= x * (*val++);
+      }
+    }
+  }
 }
 
-inline int CLUFactorRational::vSolveRight4update2(Rational* vec,
-      int* idx,                              /* result1 */
-      Rational* rhs, int* ridx, int rn,                    /* rhs1    */
-      Rational* vec2,                                      /* result2 */
-      Rational* rhs2, int* ridx2, int rn2,                 /* rhs2    */
-      Rational* forest, int* forestNum, int* forestIdx)
-{
-   vSolveLright2(rhs, ridx, &rn, rhs2, ridx2, &rn2);
+inline int CLUFactorRational::vSolveRight4update(
+    Rational *vec, int *idx,          /* result */
+    Rational *rhs, int *ridx, int rn, /* rhs    */
+    Rational *forest, int *forestNum, int *forestIdx) {
+  rn = vSolveLright(rhs, ridx, rn);
+
+  /*  turn index list into a heap
+   */
+
+  if (forest) {
+    Rational x;
+    int i, j, k;
+    int *rperm;
+    int *it = forestIdx;
+
+    rperm = row.perm;
+
+    for (i = j = 0; i < rn; ++i) {
+      k = ridx[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs[k];
+
+      if (x != 0) {
+        enQueueMaxRat(ridx, &j, rperm[ *it++ = k]);
+        forest[k] = x;
+      } else
+        rhs[k] = 0;
+    }
 
-   /*  turn index list into a heap
-    */
+    *forestNum = rn = j;
+  } else {
+    Rational x;
+    int i, j, k;
+    int *rperm;
 
-   if(forest)
-   {
-      Rational x;
-      int i, j, k;
-      int* rperm;
-      int* it = forestIdx;
+    rperm = row.perm;
 
-      rperm = row.perm;
+    for (i = j = 0; i < rn; ++i) {
+      k = ridx[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs[k];
 
-      for(i = j = 0; i < rn; ++i)
-      {
-         k = ridx[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs[k];
-
-         if(x != 0)
-         {
-            enQueueMaxRat(ridx, &j, rperm[*it++ = k]);
-            forest[k] = x;
-         }
-         else
-            rhs[k] = 0;
-      }
+      if (x != 0)
+        enQueueMaxRat(ridx, &j, rperm[k]);
+      else
+        rhs[k] = 0;
+    }
 
-      *forestNum = rn = j;
-   }
-   else
-   {
-      Rational x;
-      int i, j, k;
-      int* rperm;
+    rn = j;
+  }
 
-      rperm = row.perm;
+  rn = vSolveUright(vec, idx, rhs, ridx, rn);
 
-      for(i = j = 0; i < rn; ++i)
-      {
-         k = ridx[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs[k];
-
-         if(x != 0)
-            enQueueMaxRat(ridx, &j, rperm[k]);
-         else
-            rhs[k] = 0;
-      }
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+    rn = vSolveUpdateRight(vec, idx, rn);
 
-      rn = j;
-   }
+  return rn;
+}
 
-   if(rn2 > thedim * verySparseFactor4rightRat)
-   {
-      ridx2[0] = thedim - 1;
-      /* ridx2[1] = thedim - 2; */
-   }
-   else
-   {
-      Rational x;
-      /*      Rational  maxabs; */
-      int i, j, k;
-      int* rperm;
+inline int CLUFactorRational::vSolveRight4update2(
+    Rational *vec, int *idx,             /* result1 */
+    Rational *rhs, int *ridx, int rn,    /* rhs1    */
+    Rational *vec2,                      /* result2 */
+    Rational *rhs2, int *ridx2, int rn2, /* rhs2    */
+    Rational *forest, int *forestNum, int *forestIdx) {
+  vSolveLright2(rhs, ridx, &rn, rhs2, ridx2, &rn2);
+
+  /*  turn index list into a heap
+   */
+
+  if (forest) {
+    Rational x;
+    int i, j, k;
+    int *rperm;
+    int *it = forestIdx;
+
+    rperm = row.perm;
+
+    for (i = j = 0; i < rn; ++i) {
+      k = ridx[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs[k];
+
+      if (x != 0) {
+        enQueueMaxRat(ridx, &j, rperm[ *it++ = k]);
+        forest[k] = x;
+      } else
+        rhs[k] = 0;
+    }
 
-      /*      maxabs = 1;    */
-      rperm = row.perm;
+    *forestNum = rn = j;
+  } else {
+    Rational x;
+    int i, j, k;
+    int *rperm;
 
-      for(i = j = 0; i < rn2; ++i)
-      {
-         k = ridx2[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs2[k];
-
-         if(x == 0)
-         {
-            /*              maxabs = (maxabs < -x) ? -x : maxabs;  */
-            enQueueMaxRat(ridx2, &j, rperm[k]);
-         }
-         else
-            rhs2[k] = 0;
-      }
+    rperm = row.perm;
 
-      rn2 = j;
+    for (i = j = 0; i < rn; ++i) {
+      k = ridx[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs[k];
 
-   }
+      if (x != 0)
+        enQueueMaxRat(ridx, &j, rperm[k]);
+      else
+        rhs[k] = 0;
+    }
 
-   rn = vSolveUright(vec, idx, rhs, ridx, rn);
+    rn = j;
+  }
+
+  if (rn2 > thedim * verySparseFactor4rightRat) {
+    ridx2[0] = thedim - 1;
+    /* ridx2[1] = thedim - 2; */
+  } else {
+    Rational x;
+    /*      Rational  maxabs; */
+    int i, j, k;
+    int *rperm;
+
+    /*      maxabs = 1;    */
+    rperm = row.perm;
+
+    for (i = j = 0; i < rn2; ++i) {
+      k = ridx2[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs2[k];
+
+      if (x == 0) {
+        /*              maxabs = (maxabs < -x) ? -x : maxabs;  */
+        enQueueMaxRat(ridx2, &j, rperm[k]);
+      } else
+        rhs2[k] = 0;
+    }
 
-   vSolveUrightNoNZ(vec2, rhs2, ridx2, rn2);
+    rn2 = j;
+  }
 
-   /*
-    *  rn = vSolveUright2(vec, idx, rhs, ridx, rn, vec2, rhs2, ridx2, rn2 );
-    */
+  rn = vSolveUright(vec, idx, rhs, ridx, rn);
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      rn = vSolveUpdateRight(vec, idx, rn);
-      vSolveUpdateRightNoNZ(vec2);
-   }
+  vSolveUrightNoNZ(vec2, rhs2, ridx2, rn2);
 
-   return rn;
-}
+  /*
+   *  rn = vSolveUright2(vec, idx, rhs, ridx, rn, vec2, rhs2, ridx2, rn2 );
+   */
 
-inline int CLUFactorRational::vSolveRight4update3(Rational* vec,
-      int* idx,                              /* result1 */
-      Rational* rhs, int* ridx, int rn,                    /* rhs1    */
-      Rational* vec2,                                      /* result2 */
-      Rational* rhs2, int* ridx2, int rn2,                 /* rhs2    */
-      Rational* vec3,                                      /* result3 */
-      Rational* rhs3, int* ridx3, int rn3,                 /* rhs3    */
-      Rational* forest, int* forestNum, int* forestIdx)
-{
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    rn = vSolveUpdateRight(vec, idx, rn);
+    vSolveUpdateRightNoNZ(vec2);
+  }
 
-   vSolveLright3(rhs, ridx, &rn, rhs2, ridx2, &rn2, rhs3, ridx3, &rn3);
-   assert(rn >= 0 && rn <= thedim);
-   assert(rn2 >= 0 && rn2 <= thedim);
-   assert(rn3 >= 0 && rn3 <= thedim);
+  return rn;
+}
 
-   /*  turn index list into a heap
-    */
+inline int CLUFactorRational::vSolveRight4update3(
+    Rational *vec, int *idx,             /* result1 */
+    Rational *rhs, int *ridx, int rn,    /* rhs1    */
+    Rational *vec2,                      /* result2 */
+    Rational *rhs2, int *ridx2, int rn2, /* rhs2    */
+    Rational *vec3,                      /* result3 */
+    Rational *rhs3, int *ridx3, int rn3, /* rhs3    */
+    Rational *forest, int *forestNum, int *forestIdx) {
+
+  vSolveLright3(rhs, ridx, &rn, rhs2, ridx2, &rn2, rhs3, ridx3, &rn3);
+  assert(rn >= 0 && rn <= thedim);
+  assert(rn2 >= 0 && rn2 <= thedim);
+  assert(rn3 >= 0 && rn3 <= thedim);
+
+  /*  turn index list into a heap
+   */
+
+  if (forest) {
+    Rational x;
+    int i, j, k;
+    int *rperm;
+    int *it = forestIdx;
+
+    rperm = row.perm;
+
+    for (i = j = 0; i < rn; ++i) {
+      k = ridx[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs[k];
+
+      if (x != 0) {
+        enQueueMaxRat(ridx, &j, rperm[ *it++ = k]);
+        forest[k] = x;
+      } else
+        rhs[k] = 0;
+    }
 
-   if(forest)
-   {
-      Rational x;
-      int i, j, k;
-      int* rperm;
-      int* it = forestIdx;
+    *forestNum = rn = j;
+  } else {
+    Rational x;
+    int i, j, k;
+    int *rperm;
 
-      rperm = row.perm;
+    rperm = row.perm;
 
-      for(i = j = 0; i < rn; ++i)
-      {
-         k = ridx[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs[k];
-
-         if(x != 0)
-         {
-            enQueueMaxRat(ridx, &j, rperm[*it++ = k]);
-            forest[k] = x;
-         }
-         else
-            rhs[k] = 0;
-      }
+    for (i = j = 0; i < rn; ++i) {
+      k = ridx[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs[k];
 
-      *forestNum = rn = j;
-   }
-   else
-   {
-      Rational x;
-      int i, j, k;
-      int* rperm;
+      if (x != 0)
+        enQueueMaxRat(ridx, &j, rperm[k]);
+      else
+        rhs[k] = 0;
+    }
 
-      rperm = row.perm;
+    rn = j;
+  }
 
-      for(i = j = 0; i < rn; ++i)
-      {
-         k = ridx[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs[k];
-
-         if(x != 0)
-            enQueueMaxRat(ridx, &j, rperm[k]);
-         else
-            rhs[k] = 0;
-      }
+  if (rn2 > thedim * verySparseFactor4rightRat) {
+    ridx2[0] = thedim - 1;
+  } else {
+    Rational x;
+    int i, j, k;
+    int *rperm;
 
-      rn = j;
-   }
+    rperm = row.perm;
 
-   if(rn2 > thedim * verySparseFactor4rightRat)
-   {
-      ridx2[0] = thedim - 1;
-   }
-   else
-   {
-      Rational x;
-      int i, j, k;
-      int* rperm;
+    for (i = j = 0; i < rn2; ++i) {
+      k = ridx2[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs2[k];
 
-      rperm = row.perm;
+      if (x == 0) {
+        enQueueMaxRat(ridx2, &j, rperm[k]);
+      } else
+        rhs2[k] = 0;
+    }
 
-      for(i = j = 0; i < rn2; ++i)
-      {
-         k = ridx2[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs2[k];
-
-         if(x == 0)
-         {
-            enQueueMaxRat(ridx2, &j, rperm[k]);
-         }
-         else
-            rhs2[k] = 0;
-      }
+    rn2 = j;
+  }
 
-      rn2 = j;
-   }
+  if (rn3 > thedim * verySparseFactor4rightRat) {
+    ridx3[0] = thedim - 1;
+  } else {
+    Rational x;
+    int i, j, k;
+    int *rperm;
 
-   if(rn3 > thedim * verySparseFactor4rightRat)
-   {
-      ridx3[0] = thedim - 1;
-   }
-   else
-   {
-      Rational x;
-      int i, j, k;
-      int* rperm;
+    rperm = row.perm;
 
-      rperm = row.perm;
+    for (i = j = 0; i < rn3; ++i) {
+      k = ridx3[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs3[k];
 
-      for(i = j = 0; i < rn3; ++i)
-      {
-         k = ridx3[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs3[k];
-
-         if(x == 0)
-         {
-            enQueueMaxRat(ridx3, &j, rperm[k]);
-         }
-         else
-            rhs3[k] = 0;
-      }
+      if (x == 0) {
+        enQueueMaxRat(ridx3, &j, rperm[k]);
+      } else
+        rhs3[k] = 0;
+    }
 
-      rn3 = j;
-   }
+    rn3 = j;
+  }
 
-   rn = vSolveUright(vec, idx, rhs, ridx, rn);
+  rn = vSolveUright(vec, idx, rhs, ridx, rn);
 
-   vSolveUrightNoNZ(vec2, rhs2, ridx2, rn2);
-   vSolveUrightNoNZ(vec3, rhs3, ridx3, rn3);
+  vSolveUrightNoNZ(vec2, rhs2, ridx2, rn2);
+  vSolveUrightNoNZ(vec3, rhs3, ridx3, rn3);
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      rn = vSolveUpdateRight(vec, idx, rn);
-      vSolveUpdateRightNoNZ(vec2);
-      vSolveUpdateRightNoNZ(vec3);
-   }
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    rn = vSolveUpdateRight(vec, idx, rn);
+    vSolveUpdateRightNoNZ(vec2);
+    vSolveUpdateRightNoNZ(vec3);
+  }
 
-   return rn;
+  return rn;
 }
 
-inline void CLUFactorRational::vSolveRightNoNZ(Rational*
-      vec2,                          /* result2 */
-      Rational* rhs2, int* ridx2, int rn2)    /* rhs2    */
+inline void CLUFactorRational::vSolveRightNoNZ(Rational *vec2, /* result2 */
+                                               Rational *rhs2, int *ridx2,
+                                               int rn2) /* rhs2    */
 {
-   rn2 = vSolveLright(rhs2, ridx2, rn2);
-   assert(rn2 >= 0 && rn2 <= thedim);
-
-   if(rn2 > thedim * verySparseFactor4rightRat)
-   {
-      *ridx2 = thedim - 1;
-   }
-   else
-   {
-      Rational x;
-      /*      Rational  maxabs; */
-      int i, j, k;
-      int* rperm;
-
-      /*      maxabs = 1;    */
-      rperm = row.perm;
-
-      for(i = j = 0; i < rn2; ++i)
-      {
-         k = ridx2[i];
-         assert(k >= 0 && k < thedim);
-         x = rhs2[k];
-
-         if(x == 0)
-         {
-            /*              maxabs = (maxabs < -x) ? -x : maxabs;  */
-            enQueueMaxRat(ridx2, &j, rperm[k]);
-         }
-         else
-            rhs2[k] = 0;
-      }
+  rn2 = vSolveLright(rhs2, ridx2, rn2);
+  assert(rn2 >= 0 && rn2 <= thedim);
+
+  if (rn2 > thedim * verySparseFactor4rightRat) {
+    *ridx2 = thedim - 1;
+  } else {
+    Rational x;
+    /*      Rational  maxabs; */
+    int i, j, k;
+    int *rperm;
+
+    /*      maxabs = 1;    */
+    rperm = row.perm;
+
+    for (i = j = 0; i < rn2; ++i) {
+      k = ridx2[i];
+      assert(k >= 0 && k < thedim);
+      x = rhs2[k];
+
+      if (x == 0) {
+        /*              maxabs = (maxabs < -x) ? -x : maxabs;  */
+        enQueueMaxRat(ridx2, &j, rperm[k]);
+      } else
+        rhs2[k] = 0;
+    }
 
-      rn2 = j;
-   }
+    rn2 = j;
+  }
 
-   vSolveUrightNoNZ(vec2, rhs2, ridx2, rn2);
+  vSolveUrightNoNZ(vec2, rhs2, ridx2, rn2);
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-      vSolveUpdateRightNoNZ(vec2);
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+    vSolveUpdateRightNoNZ(vec2);
 }
 
-inline int CLUFactorRational::vSolveLeft(Rational* vec, int* idx,                      /* result */
-      Rational* rhs, int* ridx, int rn)            /* rhs    */
+inline int CLUFactorRational::vSolveLeft(Rational *vec, int *idx, /* result */
+                                         Rational *rhs, int *ridx,
+                                         int rn) /* rhs    */
 {
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      rn = solveUpdateLeft(rhs, ridx, rn);
-      rn = solveUleft(vec, idx, rhs, ridx, rn);
-   }
-   else
-   {
-      rn = solveUleft(vec, idx, rhs, ridx, rn);
-      rn = solveLleftForest(vec, idx, rn);
-   }
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    rn = solveUpdateLeft(rhs, ridx, rn);
+    rn = solveUleft(vec, idx, rhs, ridx, rn);
+  } else {
+    rn = solveUleft(vec, idx, rhs, ridx, rn);
+    rn = solveLleftForest(vec, idx, rn);
+  }
 
-   return solveLleft(vec, idx, rn);
+  return solveLleft(vec, idx, rn);
 }
 
-inline int CLUFactorRational::vSolveLeft2(Rational* vec,
-      int* idx,                       /* result */
-      Rational* rhs, int* ridx, int rn,             /* rhs    */
-      Rational* vec2,                               /* result2 */
-      Rational* rhs2, int* ridx2, int rn2)          /* rhs2    */
+inline int
+CLUFactorRational::vSolveLeft2(Rational *vec, int *idx,          /* result */
+                               Rational *rhs, int *ridx, int rn, /* rhs    */
+                               Rational *vec2,                   /* result2 */
+                               Rational *rhs2, int *ridx2, int rn2) /* rhs2 */
 {
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      rn = solveUpdateLeft(rhs, ridx, rn);
-      rn = solveUleft(vec, idx, rhs, ridx, rn);
-      rn2 = solveUpdateLeft(rhs2, ridx2, rn2);
-      solveUleftNoNZ(vec2, rhs2, ridx2, rn2);
-   }
-   else
-   {
-      rn = solveUleft(vec, idx, rhs, ridx, rn);
-      rn = solveLleftForest(vec, idx, rn);
-      solveUleftNoNZ(vec2, rhs2, ridx2, rn2);
-      solveLleftForestNoNZ(vec2);
-   }
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    rn = solveUpdateLeft(rhs, ridx, rn);
+    rn = solveUleft(vec, idx, rhs, ridx, rn);
+    rn2 = solveUpdateLeft(rhs2, ridx2, rn2);
+    solveUleftNoNZ(vec2, rhs2, ridx2, rn2);
+  } else {
+    rn = solveUleft(vec, idx, rhs, ridx, rn);
+    rn = solveLleftForest(vec, idx, rn);
+    solveUleftNoNZ(vec2, rhs2, ridx2, rn2);
+    solveLleftForestNoNZ(vec2);
+  }
 
-   rn = solveLleft(vec, idx, rn);
+  rn = solveLleft(vec, idx, rn);
 
-   solveLleftNoNZ(vec2);
+  solveLleftNoNZ(vec2);
 
-   return rn;
+  return rn;
 }
 
-inline int CLUFactorRational::vSolveLeft3(Rational* vec,
-      int* idx,                       /* result */
-      Rational* rhs, int* ridx, int rn,             /* rhs    */
-      Rational* vec2,                               /* result2 */
-      Rational* rhs2, int* ridx2, int rn2,          /* rhs2    */
-      Rational* vec3,                               /* result3 */
-      Rational* rhs3, int* ridx3, int rn3)          /* rhs3    */
+inline int
+CLUFactorRational::vSolveLeft3(Rational *vec, int *idx,          /* result */
+                               Rational *rhs, int *ridx, int rn, /* rhs    */
+                               Rational *vec2,                   /* result2 */
+                               Rational *rhs2, int *ridx2, int rn2, /* rhs2 */
+                               Rational *vec3, /* result3 */
+                               Rational *rhs3, int *ridx3, int rn3) /* rhs3 */
 {
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      rn = solveUpdateLeft(rhs, ridx, rn);
-      rn = solveUleft(vec, idx, rhs, ridx, rn);
-      rn2 = solveUpdateLeft(rhs2, ridx2, rn2);
-      solveUleftNoNZ(vec2, rhs2, ridx2, rn2);
-      rn3 = solveUpdateLeft(rhs3, ridx3, rn3);
-      solveUleftNoNZ(vec3, rhs3, ridx3, rn3);
-   }
-   else
-   {
-      rn = solveUleft(vec, idx, rhs, ridx, rn);
-      rn = solveLleftForest(vec, idx, rn);
-      solveUleftNoNZ(vec2, rhs2, ridx2, rn2);
-      solveLleftForestNoNZ(vec2);
-      solveUleftNoNZ(vec3, rhs3, ridx3, rn3);
-      solveLleftForestNoNZ(vec3);
-   }
-
-   rn = solveLleft(vec, idx, rn);
-
-   solveLleftNoNZ(vec2);
-   solveLleftNoNZ(vec3);
-
-   return rn;
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    rn = solveUpdateLeft(rhs, ridx, rn);
+    rn = solveUleft(vec, idx, rhs, ridx, rn);
+    rn2 = solveUpdateLeft(rhs2, ridx2, rn2);
+    solveUleftNoNZ(vec2, rhs2, ridx2, rn2);
+    rn3 = solveUpdateLeft(rhs3, ridx3, rn3);
+    solveUleftNoNZ(vec3, rhs3, ridx3, rn3);
+  } else {
+    rn = solveUleft(vec, idx, rhs, ridx, rn);
+    rn = solveLleftForest(vec, idx, rn);
+    solveUleftNoNZ(vec2, rhs2, ridx2, rn2);
+    solveLleftForestNoNZ(vec2);
+    solveUleftNoNZ(vec3, rhs3, ridx3, rn3);
+    solveLleftForestNoNZ(vec3);
+  }
+
+  rn = solveLleft(vec, idx, rn);
+
+  solveLleftNoNZ(vec2);
+  solveLleftNoNZ(vec3);
+
+  return rn;
 }
 
-inline void CLUFactorRational::vSolveLeftNoNZ(Rational*
-      vec2,                             /* result2 */
-      Rational* rhs2, int* ridx2, int rn2)       /* rhs2    */
+inline void CLUFactorRational::vSolveLeftNoNZ(Rational *vec2, /* result2 */
+                                              Rational *rhs2, int *ridx2,
+                                              int rn2) /* rhs2    */
 {
 
-   if(!l.updateType)             /* no Forest-Tomlin Updates */
-   {
-      rn2 = solveUpdateLeft(rhs2, ridx2, rn2);
-      solveUleftNoNZ(vec2, rhs2, ridx2, rn2);
-   }
-   else
-   {
-      solveUleftNoNZ(vec2, rhs2, ridx2, rn2);
-      solveLleftForestNoNZ(vec2);
-   }
+  if (!l.updateType) /* no Forest-Tomlin Updates */
+  {
+    rn2 = solveUpdateLeft(rhs2, ridx2, rn2);
+    solveUleftNoNZ(vec2, rhs2, ridx2, rn2);
+  } else {
+    solveUleftNoNZ(vec2, rhs2, ridx2, rn2);
+    solveLleftForestNoNZ(vec2);
+  }
 
-   solveLleftNoNZ(vec2);
+  solveLleftNoNZ(vec2);
 }
 } // namespace soplex
diff --git a/src/soplex/dsvectorbase.h b/src/soplex/dsvectorbase.h
index 367c456..c0c3181 100644
--- a/src/soplex/dsvectorbase.h
+++ b/src/soplex/dsvectorbase.h
@@ -32,328 +32,278 @@
 
 #include "soplex/svectorbase.h"
 
-namespace soplex
-{
-template < class R > class VectorBase;
-template < class S > class SSVectorBase;
-template < class R > class SLinSolver;
+namespace soplex {
+template <class R> class VectorBase;
+template <class S> class SSVectorBase;
+template <class R> class SLinSolver;
 
 /**@brief   Dynamic sparse vectors.
  * @ingroup Algebra
  *
- *  Class DSVectorBase implements dynamic sparse vectors, i.e. #SVectorBase%s with an automatic memory management. This
- *  allows the user to freely add() as many nonzeros to a DSVectorBase as desired, without any precautions.  For saving
- *  memory method setMax() allows to reduce memory consumption to the amount really required.
+ *  Class DSVectorBase implements dynamic sparse vectors, i.e. #SVectorBase%s
+ * with an automatic memory management. This allows the user to freely add() as
+ * many nonzeros to a DSVectorBase as desired, without any precautions.  For
+ * saving memory method setMax() allows to reduce memory consumption to the
+ * amount really required.
  *
- *  @todo Both DSVectorBase and SVectorBase have a member variable that points to allocated memory. This does not seem to
- *        make too much sense.  Why doesn't DSVectorBase use the element of its base class?
+ *  @todo Both DSVectorBase and SVectorBase have a member variable that points
+ * to allocated memory. This does not seem to make too much sense.  Why doesn't
+ * DSVectorBase use the element of its base class?
  */
-template < class R >
-class DSVectorBase : public SVectorBase<R>
-{
-   friend class SLinSolver<R>;
+template <class R> class DSVectorBase : public SVectorBase<R> {
+  friend class SLinSolver<R>;
 
 private:
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Data */
+  ///@{
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Data */
-   ///@{
+  /// Memory.
+  Nonzero<R> *theelem;
 
-   /// Memory.
-   Nonzero<R>* theelem;
+  ///@}
 
-   ///@}
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Private helpers */
+  ///@{
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Private helpers */
-   ///@{
+  /// Allocate memory for \p n nonzeros.
+  void allocMem(int n) {
+    spx_alloc(theelem, n);
 
-   /// Allocate memory for \p n nonzeros.
-   void allocMem(int n)
-   {
-      spx_alloc(theelem, n);
+    for (int i = 0; i < n; i++)
+      new (&(theelem[i])) Nonzero<R>();
 
-      for(int i = 0; i < n; i++)
-         new(&(theelem[i])) Nonzero<R>();
+    SVectorBase<R>::setMem(n, theelem);
+  }
 
-      SVectorBase<R>::setMem(n, theelem);
-   }
+  /// Ensure there is room for \p n new nonzeros.
+  void makeMem(int n) {
+    assert(n >= 0);
 
-   /// Ensure there is room for \p n new nonzeros.
-   void makeMem(int n)
-   {
-      assert(n >= 0);
+    if (SVectorBase<R>::max() - SVectorBase<R>::size() < n) {
+      assert(SVectorBase<R>::size() + n > 0);
+      setMax(SVectorBase<R>::size() + n);
+    }
+  }
 
-      if(SVectorBase<R>::max() - SVectorBase<R>::size() < n)
-      {
-         assert(SVectorBase<R>::size() + n > 0);
-         setMax(SVectorBase<R>::size() + n);
-      }
-   }
-
-   ///@}
+  ///@}
 
 public:
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Construction, assignment, and destruction */
+  ///@{
+
+  /// Default constructor.
+  /** Creates a DSVectorBase ready to hold \p n nonzeros. However, the memory is
+   * automatically enlarged, if more nonzeros are added to the DSVectorBase.
+   */
+  explicit DSVectorBase(int n = 8) : theelem(0) {
+    allocMem((n < 1) ? 2 : n);
+
+    assert(isConsistent());
+  }
+
+  /// Copy constructor.
+  template <class S>
+  explicit DSVectorBase(const SVectorBase<S> &old) : theelem(0) {
+    allocMem(old.size());
+    SVectorBase<R>::operator=(old);
+
+    assert(isConsistent());
+  }
+
+  /// Copy constructor.
+  /** The redundancy with the copy constructor below is necessary since
+   * otherwise the compiler doesn't realize that it could use the more general
+   * one with S = R and generates a shallow copy constructor.
+   */
+  DSVectorBase(const DSVectorBase<R> &old) : SVectorBase<R>(), theelem(0) {
+    allocMem(old.size());
+    SVectorBase<R>::operator=(old);
+
+    assert(isConsistent());
+  }
+
+  /// Copy constructor.
+  template <class S>
+  DSVectorBase(const DSVectorBase<S> &old) : SVectorBase<R>(), theelem(0) {
+    allocMem(old.size());
+    SVectorBase<R>::operator=(old);
+
+    assert(isConsistent());
+  }
+
+  /// Copy constructor.
+  template <class S> explicit DSVectorBase(const VectorBase<S> &vec);
+
+  /// Copy constructor.
+  template <class S> explicit DSVectorBase(const SSVectorBase<S> &old);
+
+  /// Assignment operator.
+  template <class S> DSVectorBase<R> &operator=(const SVectorBase<S> &vec) {
+    if (this != &vec) {
+      SVectorBase<R>::clear();
+      makeMem(vec.size());
+      SVectorBase<R>::operator=(vec);
+    }
+
+    return *this;
+  }
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Construction, assignment, and destruction */
-   ///@{
-
-   /// Default constructor.
-   /** Creates a DSVectorBase ready to hold \p n nonzeros. However, the memory is automatically enlarged, if more
-    *  nonzeros are added to the DSVectorBase.
-    */
-   explicit DSVectorBase<R>(int n = 8)
-      : theelem(0)
-   {
-      allocMem((n < 1) ? 2 : n);
-
-      assert(isConsistent());
-   }
-
-   /// Copy constructor.
-   template < class S >
-   explicit DSVectorBase<R>(const SVectorBase<S>& old)
-      : theelem(0)
-   {
-      allocMem(old.size());
-      SVectorBase<R>::operator=(old);
-
-      assert(isConsistent());
-   }
-
-   /// Copy constructor.
-   /** The redundancy with the copy constructor below is necessary since otherwise the compiler doesn't realize that it
-    *  could use the more general one with S = R and generates a shallow copy constructor.
-    */
-   DSVectorBase<R>(const DSVectorBase<R>& old)
-      : SVectorBase<R>()
-      , theelem(0)
-   {
-      allocMem(old.size());
-      SVectorBase<R>::operator=(old);
-
-      assert(isConsistent());
-   }
-
-   /// Copy constructor.
-   template < class S >
-   DSVectorBase<R>(const DSVectorBase<S>& old)
-      : SVectorBase<R>()
-      , theelem(0)
-   {
-      allocMem(old.size());
-      SVectorBase<R>::operator=(old);
-
-      assert(isConsistent());
-   }
-
-   /// Copy constructor.
-   template < class S >
-   explicit DSVectorBase<R>(const VectorBase<S>& vec);
-
-   /// Copy constructor.
-   template < class S >
-   explicit DSVectorBase<R>(const SSVectorBase<S>& old);
-
-   /// Assignment operator.
-   template < class S >
-   DSVectorBase<R>& operator=(const SVectorBase<S>& vec)
-   {
-      if(this != &vec)
-      {
-         SVectorBase<R>::clear();
-         makeMem(vec.size());
-         SVectorBase<R>::operator=(vec);
-      }
-
-      return *this;
-   }
-
-   /// Assignment operator.
-   DSVectorBase<R>& operator=(const DSVectorBase<R>& vec)
-   {
-      if(this != &vec)
-      {
-         SVectorBase<R>::clear();
-         makeMem(vec.size());
-         SVectorBase<R>::operator=(vec);
-      }
-
-      return *this;
-   }
-
-   /// Assignment operator.
-   template < class S >
-   DSVectorBase<R>& operator=(const DSVectorBase<S>& vec)
-   {
-      if(this != (DSVectorBase<R>*)(&vec))
-      {
-         SVectorBase<R>::clear();
-         makeMem(vec.size());
-         SVectorBase<R>::operator=(vec);
-      }
-
-      return *this;
-   }
-
-   /// Assignment operator.
-   template < class S >
-   DSVectorBase<R>& operator=(const VectorBase<S>& vec);
-
-   /// Assignment operator.
-   template < class S >
-   DSVectorBase<R>& operator=(const SSVectorBase<S>& vec);
-
-   /// Destructor.
-   virtual ~DSVectorBase<R>()
-   {
-      if(theelem)
-      {
-         for(int i = SVectorBase<R>::max() - 1; i >= 0; i--)
-            theelem[i].~Nonzero<R>();
-
-         spx_free(theelem);
-      }
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Modification */
-   ///@{
-
-   /// Append nonzeros of \p sv.
-   template < class S >
-   void add(const SVectorBase<S>& vec)
-   {
+  /// Assignment operator.
+  DSVectorBase<R> &operator=(const DSVectorBase<R> &vec) {
+    if (this != &vec) {
       SVectorBase<R>::clear();
       makeMem(vec.size());
-      SVectorBase<S>::add(vec);
-   }
-
-   /// Append one nonzero \p (i,v).
-   void add(int i, const R& v)
-   {
-      makeMem(1);
-      SVectorBase<R>::add(i, v);
-   }
-
-   /// Append one uninitialized nonzero.
-   void add(int i)
-   {
-      makeMem(1);
-      SVectorBase<R>::add(i);
-   }
-
-   /// Append \p n nonzeros.
-   void add(int n, const int i[], const R v[])
-   {
-      makeMem(n);
-      SVectorBase<R>::add(n, i, v);
-   }
-
-   /// Reset nonzero memory to >= \p newmax.
-   /** This methods resets the memory consumption to \p newmax. However, if \p newmax < size(), it is
-    *  reset to size() only.
-    */
-   void setMax(int newmax = 1)
-   {
-      int siz = SVectorBase<R>::size();
-      int len = (newmax < siz) ? siz : newmax;
-
-      if(len == SVectorBase<R>::max())
-         return;
-
-      Nonzero<R>* newmem = 0;
-
-      /* allocate new memory */
-      spx_alloc(newmem, len);
-
-      /* call copy constructor for first elements */
-      int i;
-
-      for(i = 0; i < siz; i++)
-         new((&newmem[i])) Nonzero<R>(theelem[i]);
-
-      /* call default constructor for remaining elements */
-      for(; i < len; i++)
-         new((&newmem[i])) Nonzero<R>();
-
-      /* free old memory */
-      for(i = SVectorBase<R>::max() - 1; i >= 0; i--)
-         theelem[i].~Nonzero<R>();
-
-      if(theelem != 0)
-         spx_free(theelem);
-
-      /* assign new memory */
-      theelem = newmem;
-      SVectorBase<R>::setMem(len, theelem);
-      SVectorBase<R>::set_size(siz);
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Utilities */
-   ///@{
-
-   /// Consistency check.
-   bool isConsistent() const
-   {
+      SVectorBase<R>::operator=(vec);
+    }
+
+    return *this;
+  }
+
+  /// Assignment operator.
+  template <class S> DSVectorBase<R> &operator=(const DSVectorBase<S> &vec) {
+    if (this != (DSVectorBase<R> *)(&vec)) {
+      SVectorBase<R>::clear();
+      makeMem(vec.size());
+      SVectorBase<R>::operator=(vec);
+    }
+
+    return *this;
+  }
+
+  /// Assignment operator.
+  template <class S> DSVectorBase<R> &operator=(const VectorBase<S> &vec);
+
+  /// Assignment operator.
+  template <class S> DSVectorBase<R> &operator=(const SSVectorBase<S> &vec);
+
+  /// Destructor.
+  virtual ~DSVectorBase() {
+    if (theelem) {
+      for (int i = SVectorBase<R>::max() - 1; i >= 0; i--)
+        theelem[i].~Nonzero<R>();
+
+      spx_free(theelem);
+    }
+  }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Modification */
+  ///@{
+
+  /// Append nonzeros of \p sv.
+  template <class S> void add(const SVectorBase<S> &vec) {
+    SVectorBase<R>::clear();
+    makeMem(vec.size());
+    SVectorBase<S>::add(vec);
+  }
+
+  /// Append one nonzero \p (i,v).
+  void add(int i, const R &v) {
+    makeMem(1);
+    SVectorBase<R>::add(i, v);
+  }
+
+  /// Append one uninitialized nonzero.
+  void add(int i) {
+    makeMem(1);
+    SVectorBase<R>::add(i);
+  }
+
+  /// Append \p n nonzeros.
+  void add(int n, const int i[], const R v[]) {
+    makeMem(n);
+    SVectorBase<R>::add(n, i, v);
+  }
+
+  /// Reset nonzero memory to >= \p newmax.
+  /** This methods resets the memory consumption to \p newmax. However, if \p
+   * newmax < size(), it is reset to size() only.
+   */
+  void setMax(int newmax = 1) {
+    int siz = SVectorBase<R>::size();
+    int len = (newmax < siz) ? siz : newmax;
+
+    if (len == SVectorBase<R>::max())
+      return;
+
+    Nonzero<R> *newmem = 0;
+
+    /* allocate new memory */
+    spx_alloc(newmem, len);
+
+    /* call copy constructor for first elements */
+    int i;
+
+    for (i = 0; i < siz; i++)
+      new ((&newmem[i])) Nonzero<R>(theelem[i]);
+
+    /* call default constructor for remaining elements */
+    for (; i < len; i++)
+      new ((&newmem[i])) Nonzero<R>();
+
+    /* free old memory */
+    for (i = SVectorBase<R>::max() - 1; i >= 0; i--)
+      theelem[i].~Nonzero<R>();
+
+    if (theelem != 0)
+      spx_free(theelem);
+
+    /* assign new memory */
+    theelem = newmem;
+    SVectorBase<R>::setMem(len, theelem);
+    SVectorBase<R>::set_size(siz);
+  }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Utilities */
+  ///@{
+
+  /// Consistency check.
+  bool isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
 
-      if(theelem != 0 && SVectorBase<R>::mem() != theelem)
-         return MSGinconsistent("DSVectorBase");
+    if (theelem != 0 && SVectorBase<R>::mem() != theelem)
+      return MSGinconsistent("DSVectorBase");
 
 #endif
 
-      return true;
-   }
+    return true;
+  }
 
-   ///@}
+  ///@}
 };
 
-
-
 /// Allocate memory for \p n nonzeros (specialization for Real).
-template<>
-inline
-void DSVectorBase<Real>::allocMem(int n)
-{
-   spx_alloc(theelem, n);
-   SVectorBase<Real>::setMem(n, theelem);
+template <> inline void DSVectorBase<Real>::allocMem(int n) {
+  spx_alloc(theelem, n);
+  SVectorBase<Real>::setMem(n, theelem);
 }
 
-
-
 /// Destructor (specialization for Real).
-template<>
-inline
-DSVectorBase<Real>::~DSVectorBase()
-{
-   if(theelem)
-      spx_free(theelem);
+template <> inline DSVectorBase<Real>::~DSVectorBase() {
+  if (theelem)
+    spx_free(theelem);
 }
 
-
-
 /// Reset nonzero memory to >= \p newmax.
-/** This methods resets the memory consumption to \p newmax. However, if \p newmax < size(), it is
- *  reset to size() only (specialization for Real).
+/** This methods resets the memory consumption to \p newmax. However, if \p
+ * newmax < size(), it is reset to size() only (specialization for Real).
  */
-template<>
-inline
-void DSVectorBase<Real>::setMax(int newmax)
-{
-   int siz = size();
-   int len = (newmax < siz) ? siz : newmax;
-
-   spx_realloc(theelem, len);
-   setMem(len, theelem);
-   // reset 'size' to old size since the above call to setMem() sets 'size' to 0
-   set_size(siz);
+template <> inline void DSVectorBase<Real>::setMax(int newmax) {
+  int siz = size();
+  int len = (newmax < siz) ? siz : newmax;
+
+  spx_realloc(theelem, len);
+  setMem(len, theelem);
+  // reset 'size' to old size since the above call to setMem() sets 'size' to 0
+  set_size(siz);
 }
 } // namespace soplex
 #endif // _DSVECTORBASE_H_
diff --git a/src/soplex/enter.hpp b/src/soplex/enter.hpp
index 73d3832..1378a31 100644
--- a/src/soplex/enter.hpp
+++ b/src/soplex/enter.hpp
@@ -21,19 +21,19 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 /*      \SubSection{Updating the Basis for Entering Variables}
  */
 #include <assert.h>
 
+#include "soplex/exceptions.h"
 #include "soplex/spxdefines.h"
-#include "soplex/spxratiotester.h"
-#include "soplex/spxpricer.h"
 #include "soplex/spxout.h"
-#include "soplex/exceptions.h"
+#include "soplex/spxpricer.h"
+#include "soplex/spxratiotester.h"
 
-namespace soplex
-{
+namespace soplex {
 
 /*
   In the entering simplex algorithms (i.e. iteratively a vector is selected to
@@ -64,152 +64,130 @@ namespace soplex
   all $j \ne i^*$ $f^{(i^*)}_j$ remains within its bounds $l_j$ and $u_j$.
 */
 
-
 /*
   Testing all values of |pVec| against its bounds. If $i$, say, is violated
   the violation is saved as negative value in |theTest[i]|.
 */
 
 template <class R>
-R SPxSolverBase<R>::test(int i, typename SPxBasisBase<R>::Desc::Status stat) const
-{
-   assert(type() == ENTER);
-   assert(!isBasic(stat));
-
-   R x;
-
-   switch(stat)
-   {
-   case SPxBasisBase<R>::Desc::D_FREE:
-   case SPxBasisBase<R>::Desc::D_ON_BOTH:
-      assert(rep() == ROW);
-      x = (*thePvec)[i] - this->lhs(i);
-
-      if(x < 0)
-         return x;
-
-   // no break: next is else case
-   //lint -fallthrough
-   case SPxBasisBase<R>::Desc::D_ON_LOWER:
-      assert(rep() == ROW);
-      return this->rhs(i) - (*thePvec)[i];
-
-   case SPxBasisBase<R>::Desc::D_ON_UPPER:
-      assert(rep() == ROW);
-      return (*thePvec)[i] - this->lhs(i);
-
-   case SPxBasisBase<R>::Desc::P_ON_UPPER:
-      assert(rep() == COLUMN);
-      return this->maxObj(i) - (*thePvec)[i];
-
-   case SPxBasisBase<R>::Desc::P_ON_LOWER:
-      assert(rep() == COLUMN);
-      return (*thePvec)[i] - this->maxObj(i);
-
-   case SPxBasisBase<R>::Desc::P_FREE :
-      x = this->maxObj(i) - (*thePvec)[i];
-      return (x < 0) ? x : -x;
-
-   default:
-      return 0;
-   }
+R SPxSolverBase<R>::test(int i,
+                         typename SPxBasisBase<R>::Desc::Status stat) const {
+  assert(type() == ENTER);
+  assert(!isBasic(stat));
+
+  R x;
+
+  switch (stat) {
+  case SPxBasisBase<R>::Desc::D_FREE:
+  case SPxBasisBase<R>::Desc::D_ON_BOTH:
+    assert(rep() == ROW);
+    x = (*thePvec)[i] - this->lhs(i);
+
+    if (x < 0)
+      return x;
+
+  // no break: next is else case
+  // lint -fallthrough
+  case SPxBasisBase<R>::Desc::D_ON_LOWER:
+    assert(rep() == ROW);
+    return this->rhs(i) - (*thePvec)[i];
+
+  case SPxBasisBase<R>::Desc::D_ON_UPPER:
+    assert(rep() == ROW);
+    return (*thePvec)[i] - this->lhs(i);
+
+  case SPxBasisBase<R>::Desc::P_ON_UPPER:
+    assert(rep() == COLUMN);
+    return this->maxObj(i) - (*thePvec)[i];
+
+  case SPxBasisBase<R>::Desc::P_ON_LOWER:
+    assert(rep() == COLUMN);
+    return (*thePvec)[i] - this->maxObj(i);
+
+  case SPxBasisBase<R>::Desc::P_FREE:
+    x = this->maxObj(i) - (*thePvec)[i];
+    return (x < 0) ? x : -x;
+
+  default:
+    return 0;
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::computeTest()
-{
-
-   const typename SPxBasisBase<R>::Desc& ds = this->desc();
-   R pricingTol = leavetol();
-   m_pricingViolCoUpToDate = true;
-   m_pricingViolCo = 0;
-
-   infeasibilitiesCo.clear();
-   int sparsitythreshold = (int)(sparsePricingFactor * coDim());
-
-   for(int i = 0; i < coDim(); ++i)
-   {
-      typename SPxBasisBase<R>::Desc::Status stat = ds.status(i);
-
-      if(isBasic(stat))
-      {
-         theTest[i] = 0.0;
-
-         if(remainingRoundsEnterCo == 0)
-            isInfeasibleCo[i] = SPxPricer<R>::NOT_VIOLATED;
+template <class R> void SPxSolverBase<R>::computeTest() {
+
+  const typename SPxBasisBase<R>::Desc &ds = this->desc();
+  R pricingTol = leavetol();
+  m_pricingViolCoUpToDate = true;
+  m_pricingViolCo = 0;
+
+  infeasibilitiesCo.clear();
+  int sparsitythreshold = (int)(sparsePricingFactor * coDim());
+
+  for (int i = 0; i < coDim(); ++i) {
+    typename SPxBasisBase<R>::Desc::Status stat = ds.status(i);
+
+    if (isBasic(stat)) {
+      theTest[i] = 0.0;
+
+      if (remainingRoundsEnterCo == 0)
+        isInfeasibleCo[i] = SPxPricer<R>::NOT_VIOLATED;
+    } else {
+      assert(!isBasic(stat));
+      theTest[i] = test(i, stat);
+
+      if (remainingRoundsEnterCo == 0) {
+        if (theTest[i] < -pricingTol) {
+          assert(infeasibilitiesCo.size() < infeasibilitiesCo.max());
+          m_pricingViolCo -= theTest[i];
+          infeasibilitiesCo.addIdx(i);
+          isInfeasibleCo[i] = SPxPricer<R>::VIOLATED;
+          ++m_numViol;
+        } else
+          isInfeasibleCo[i] = SPxPricer<R>::NOT_VIOLATED;
+
+        if (infeasibilitiesCo.size() > sparsitythreshold) {
+          MSG_INFO2((*this->spxout),
+                    (*this->spxout) << " --- using dense pricing" << std::endl;)
+          remainingRoundsEnterCo = DENSEROUNDS;
+          sparsePricingEnterCo = false;
+          infeasibilitiesCo.clear();
+        }
+      } else if (theTest[i] < -pricingTol) {
+        m_pricingViolCo -= theTest[i];
+        ++m_numViol;
       }
-      else
-      {
-         assert(!isBasic(stat));
-         theTest[i] = test(i, stat);
-
-         if(remainingRoundsEnterCo == 0)
-         {
-            if(theTest[i] < -pricingTol)
-            {
-               assert(infeasibilitiesCo.size() < infeasibilitiesCo.max());
-               m_pricingViolCo -= theTest[i];
-               infeasibilitiesCo.addIdx(i);
-               isInfeasibleCo[i] = SPxPricer<R>::VIOLATED;
-               ++m_numViol;
-            }
-            else
-               isInfeasibleCo[i] = SPxPricer<R>::NOT_VIOLATED;
-
-            if(infeasibilitiesCo.size() > sparsitythreshold)
-            {
-               MSG_INFO2((*this->spxout), (*this->spxout) << " --- using dense pricing"
-                         << std::endl;)
-               remainingRoundsEnterCo = DENSEROUNDS;
-               sparsePricingEnterCo = false;
-               infeasibilitiesCo.clear();
-            }
-         }
-         else if(theTest[i] < -pricingTol)
-         {
-            m_pricingViolCo -= theTest[i];
-            ++m_numViol;
-         }
-      }
-   }
-
-   if(infeasibilitiesCo.size() == 0 && !sparsePricingEnterCo)
-      --remainingRoundsEnterCo;
-   else if(infeasibilitiesCo.size() <= sparsitythreshold && !sparsePricingEnterCo)
-   {
-      MSG_INFO2((*this->spxout),
-                std::streamsize prec = spxout->precision();
-
-                if(hyperPricingEnter)
-                (*this->spxout) << " --- using hypersparse pricing, ";
-                else
-                   (*this->spxout) << " --- using sparse pricing, ";
-                   (*this->spxout) << "sparsity: "
-                   << std::setw(6) << std::fixed << std::setprecision(4)
-                   << (R) infeasibilitiesCo.size() / coDim()
-                   << std::scientific << std::setprecision(int(prec))
-                   << std::endl;
-                  )
-            sparsePricingEnterCo = true;
-   }
+    }
+  }
+
+  if (infeasibilitiesCo.size() == 0 && !sparsePricingEnterCo)
+    --remainingRoundsEnterCo;
+  else if (infeasibilitiesCo.size() <= sparsitythreshold &&
+           !sparsePricingEnterCo) {
+    MSG_INFO2((*this->spxout), std::streamsize prec = spxout->precision();
+
+              if (hyperPricingEnter)(*this->spxout)
+              << " --- using hypersparse pricing, ";
+              else(*this->spxout) << " --- using sparse pricing, ";
+              (*this->spxout)
+              << "sparsity: " << std::setw(6) << std::fixed
+              << std::setprecision(4) << (R)infeasibilitiesCo.size() / coDim()
+              << std::scientific << std::setprecision(int(prec)) << std::endl;)
+    sparsePricingEnterCo = true;
+  }
 }
 
-template <class R>
-R SPxSolverBase<R>::computePvec(int i)
-{
+template <class R> R SPxSolverBase<R>::computePvec(int i) {
 
-   return (*thePvec)[i] = vector(i) * (*theCoPvec);
+  return (*thePvec)[i] = vector(i) * (*theCoPvec);
 }
 
-template <class R>
-R SPxSolverBase<R>::computeTest(int i)
-{
-   typename SPxBasisBase<R>::Desc::Status stat = this->desc().status(i);
-
-   if(isBasic(stat))
-      return theTest[i] = 0;
-   else
-      return theTest[i] = test(i, stat);
+template <class R> R SPxSolverBase<R>::computeTest(int i) {
+  typename SPxBasisBase<R>::Desc::Status stat = this->desc().status(i);
+
+  if (isBasic(stat))
+    return theTest[i] = 0;
+  else
+    return theTest[i] = test(i, stat);
 }
 
 /*
@@ -217,1373 +195,1231 @@ R SPxSolverBase<R>::computeTest(int i)
   the violation is saved as negative value in |theCoTest[i]|.
 */
 template <class R>
-R SPxSolverBase<R>::coTest(int i, typename SPxBasisBase<R>::Desc::Status stat) const
-{
-   assert(type() == ENTER);
-   assert(!isBasic(stat));
-
-   R x;
-
-   switch(stat)
-   {
-   case SPxBasisBase<R>::Desc::D_FREE:
-   case SPxBasisBase<R>::Desc::D_ON_BOTH :
-      assert(rep() == ROW);
-      x = (*theCoPvec)[i] - SPxLPBase<R>::lower(i);
-
-      if(x < 0)
-         return x;
-
-   // no break: next is else case
-   //lint -fallthrough
-   case SPxBasisBase<R>::Desc::D_ON_LOWER:
-      assert(rep() == ROW);
-      return SPxLPBase<R>::upper(i) - (*theCoPvec)[i];
-
-   case SPxBasisBase<R>::Desc::D_ON_UPPER:
-      assert(rep() == ROW);
-      return (*theCoPvec)[i] - SPxLPBase<R>::lower(i);
-
-   case SPxBasisBase<R>::Desc::P_ON_UPPER:
-      assert(rep() == COLUMN);
-      return (*theCoPvec)[i] - this->maxRowObj(i);             // slacks !
-
-   case SPxBasisBase<R>::Desc::P_ON_LOWER:
-      assert(rep() == COLUMN);
-      return this->maxRowObj(i) - (*theCoPvec)[i];             // slacks !
-
-   default:
-      return 0;
-   }
+R SPxSolverBase<R>::coTest(int i,
+                           typename SPxBasisBase<R>::Desc::Status stat) const {
+  assert(type() == ENTER);
+  assert(!isBasic(stat));
+
+  R x;
+
+  switch (stat) {
+  case SPxBasisBase<R>::Desc::D_FREE:
+  case SPxBasisBase<R>::Desc::D_ON_BOTH:
+    assert(rep() == ROW);
+    x = (*theCoPvec)[i] - SPxLPBase<R>::lower(i);
+
+    if (x < 0)
+      return x;
+
+  // no break: next is else case
+  // lint -fallthrough
+  case SPxBasisBase<R>::Desc::D_ON_LOWER:
+    assert(rep() == ROW);
+    return SPxLPBase<R>::upper(i) - (*theCoPvec)[i];
+
+  case SPxBasisBase<R>::Desc::D_ON_UPPER:
+    assert(rep() == ROW);
+    return (*theCoPvec)[i] - SPxLPBase<R>::lower(i);
+
+  case SPxBasisBase<R>::Desc::P_ON_UPPER:
+    assert(rep() == COLUMN);
+    return (*theCoPvec)[i] - this->maxRowObj(i); // slacks !
+
+  case SPxBasisBase<R>::Desc::P_ON_LOWER:
+    assert(rep() == COLUMN);
+    return this->maxRowObj(i) - (*theCoPvec)[i]; // slacks !
+
+  default:
+    return 0;
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::computeCoTest()
-{
-   int i;
-   R pricingTol = leavetol();
-   m_pricingViolUpToDate = true;
-   m_pricingViol = 0;
-   m_numViol = 0;
-   infeasibilities.clear();
-   int sparsitythreshold = (int)(sparsePricingFactor * dim());
-   const typename SPxBasisBase<R>::Desc& ds = this->desc();
-
-   for(i = dim() - 1; i >= 0; --i)
-   {
-      typename SPxBasisBase<R>::Desc::Status stat = ds.coStatus(i);
-
-      if(isBasic(stat))
-      {
-         theCoTest[i] = 0;
-
-         if(remainingRoundsEnter == 0)
-            isInfeasible[i] = SPxPricer<R>::NOT_VIOLATED;
-      }
-      else
-      {
-         theCoTest[i] = coTest(i, stat);
-
-         if(remainingRoundsEnter == 0)
-         {
-            if(theCoTest[i] < -pricingTol)
-            {
-               assert(infeasibilities.size() < infeasibilities.max());
-               m_pricingViol -= theCoTest[i];
-               infeasibilities.addIdx(i);
-               isInfeasible[i] = SPxPricer<R>::VIOLATED;
-               ++m_numViol;
-            }
-            else
-               isInfeasible[i] = SPxPricer<R>::NOT_VIOLATED;
-
-            if(infeasibilities.size() > sparsitythreshold)
-            {
-               MSG_INFO2((*this->spxout), (*this->spxout) << " --- using dense pricing"
-                         << std::endl;)
-               remainingRoundsEnter = DENSEROUNDS;
-               sparsePricingEnter = false;
-               infeasibilities.clear();
-            }
-         }
-         else if(theCoTest[i] < -pricingTol)
-         {
-            m_pricingViol -= theCoTest[i];
-            ++m_numViol;
-         }
+template <class R> void SPxSolverBase<R>::computeCoTest() {
+  int i;
+  R pricingTol = leavetol();
+  m_pricingViolUpToDate = true;
+  m_pricingViol = 0;
+  m_numViol = 0;
+  infeasibilities.clear();
+  int sparsitythreshold = (int)(sparsePricingFactor * dim());
+  const typename SPxBasisBase<R>::Desc &ds = this->desc();
+
+  for (i = dim() - 1; i >= 0; --i) {
+    typename SPxBasisBase<R>::Desc::Status stat = ds.coStatus(i);
+
+    if (isBasic(stat)) {
+      theCoTest[i] = 0;
+
+      if (remainingRoundsEnter == 0)
+        isInfeasible[i] = SPxPricer<R>::NOT_VIOLATED;
+    } else {
+      theCoTest[i] = coTest(i, stat);
+
+      if (remainingRoundsEnter == 0) {
+        if (theCoTest[i] < -pricingTol) {
+          assert(infeasibilities.size() < infeasibilities.max());
+          m_pricingViol -= theCoTest[i];
+          infeasibilities.addIdx(i);
+          isInfeasible[i] = SPxPricer<R>::VIOLATED;
+          ++m_numViol;
+        } else
+          isInfeasible[i] = SPxPricer<R>::NOT_VIOLATED;
+
+        if (infeasibilities.size() > sparsitythreshold) {
+          MSG_INFO2((*this->spxout),
+                    (*this->spxout) << " --- using dense pricing" << std::endl;)
+          remainingRoundsEnter = DENSEROUNDS;
+          sparsePricingEnter = false;
+          infeasibilities.clear();
+        }
+      } else if (theCoTest[i] < -pricingTol) {
+        m_pricingViol -= theCoTest[i];
+        ++m_numViol;
       }
-   }
-
-   if(infeasibilities.size() == 0 && !sparsePricingEnter)
-      --remainingRoundsEnter;
-   else if(infeasibilities.size() <= sparsitythreshold && !sparsePricingEnter)
-   {
-      MSG_INFO2((*this->spxout),
-                std::streamsize prec = spxout->precision();
-
-                if(hyperPricingEnter)
-                (*this->spxout) << " --- using hypersparse pricing, ";
-                else
-                   (*this->spxout) << " --- using sparse pricing, ";
-                   (*this->spxout) << "sparsity: "
-                   << std::setw(6) << std::fixed << std::setprecision(4)
-                   << (R) infeasibilities.size() / dim()
-                   << std::scientific << std::setprecision(int(prec))
-                   << std::endl;
-                  )
-            sparsePricingEnter = true;
-   }
+    }
+  }
+
+  if (infeasibilities.size() == 0 && !sparsePricingEnter)
+    --remainingRoundsEnter;
+  else if (infeasibilities.size() <= sparsitythreshold && !sparsePricingEnter) {
+    MSG_INFO2((*this->spxout), std::streamsize prec = spxout->precision();
+
+              if (hyperPricingEnter)(*this->spxout)
+              << " --- using hypersparse pricing, ";
+              else(*this->spxout) << " --- using sparse pricing, ";
+              (*this->spxout)
+              << "sparsity: " << std::setw(6) << std::fixed
+              << std::setprecision(4) << (R)infeasibilities.size() / dim()
+              << std::scientific << std::setprecision(int(prec)) << std::endl;)
+    sparsePricingEnter = true;
+  }
 }
 
 /*
   The following methods require propersy initialized vectors |fVec| and
   #coPvec#.
 */
-template <class R>
-void SPxSolverBase<R>::updateTest()
-{
-   thePvec->delta().setup();
-
-   const IdxSet& idx = thePvec->idx();
-   const typename SPxBasisBase<R>::Desc& ds = this->desc();
-   R pricingTol = leavetol();
-
-   int i;
-   updateViolsCo.clear();
-
-   for(i = idx.size() - 1; i >= 0; --i)
-   {
-      int j = idx.index(i);
-      typename SPxBasisBase<R>::Desc::Status stat = ds.status(j);
-
-      if(!isBasic(stat))
-      {
-         if(m_pricingViolCoUpToDate && theTest[j] < -pricingTol)
-            m_pricingViolCo += theTest[j];
-
-         theTest[j] = test(j, stat);
-
-         if(sparsePricingEnterCo)
-         {
-            if(theTest[j] < -pricingTol)
-            {
-               assert(remainingRoundsEnterCo == 0);
-               m_pricingViolCo -= theTest[j];
-
-               if(isInfeasibleCo[j] == SPxPricer<R>::NOT_VIOLATED)
-               {
-                  infeasibilitiesCo.addIdx(j);
-                  isInfeasibleCo[j] = SPxPricer<R>::VIOLATED;
-               }
-
-               if(hyperPricingEnter)
-                  updateViolsCo.addIdx(j);
-            }
-            else
-            {
-               isInfeasibleCo[j] = SPxPricer<R>::NOT_VIOLATED;
-            }
-         }
-         else if(theTest[j] < -pricingTol)
-            m_pricingViolCo -= theTest[j];
-      }
-      else
-      {
-         isInfeasibleCo[j] = SPxPricer<R>::NOT_VIOLATED;
-         theTest[j] = 0;
-      }
-   }
+template <class R> void SPxSolverBase<R>::updateTest() {
+  thePvec->delta().setup();
+
+  const IdxSet &idx = thePvec->idx();
+  const typename SPxBasisBase<R>::Desc &ds = this->desc();
+  R pricingTol = leavetol();
+
+  int i;
+  updateViolsCo.clear();
+
+  for (i = idx.size() - 1; i >= 0; --i) {
+    int j = idx.index(i);
+    typename SPxBasisBase<R>::Desc::Status stat = ds.status(j);
+
+    if (!isBasic(stat)) {
+      if (m_pricingViolCoUpToDate && theTest[j] < -pricingTol)
+        m_pricingViolCo += theTest[j];
+
+      theTest[j] = test(j, stat);
+
+      if (sparsePricingEnterCo) {
+        if (theTest[j] < -pricingTol) {
+          assert(remainingRoundsEnterCo == 0);
+          m_pricingViolCo -= theTest[j];
+
+          if (isInfeasibleCo[j] == SPxPricer<R>::NOT_VIOLATED) {
+            infeasibilitiesCo.addIdx(j);
+            isInfeasibleCo[j] = SPxPricer<R>::VIOLATED;
+          }
+
+          if (hyperPricingEnter)
+            updateViolsCo.addIdx(j);
+        } else {
+          isInfeasibleCo[j] = SPxPricer<R>::NOT_VIOLATED;
+        }
+      } else if (theTest[j] < -pricingTol)
+        m_pricingViolCo -= theTest[j];
+    } else {
+      isInfeasibleCo[j] = SPxPricer<R>::NOT_VIOLATED;
+      theTest[j] = 0;
+    }
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::updateCoTest()
-{
-   theCoPvec->delta().setup();
-
-   const IdxSet& idx = theCoPvec->idx();
-   const typename SPxBasisBase<R>::Desc& ds = this->desc();
-   R pricingTol = leavetol();
-
-   int i;
-   updateViols.clear();
-
-   for(i = idx.size() - 1; i >= 0; --i)
-   {
-      int j = idx.index(i);
-      typename SPxBasisBase<R>::Desc::Status stat = ds.coStatus(j);
-
-      if(!isBasic(stat))
-      {
-         if(m_pricingViolUpToDate && theCoTest[j] < -pricingTol)
-            m_pricingViol += theCoTest[j];
-
-         theCoTest[j] = coTest(j, stat);
-
-         if(sparsePricingEnter)
-         {
-            if(theCoTest[j] < -pricingTol)
-            {
-               assert(remainingRoundsEnter == 0);
-               m_pricingViol -= theCoTest[j];
-
-               if(isInfeasible[j] == SPxPricer<R>::NOT_VIOLATED)
-               {
-                  //                if( !hyperPricingEnter )
-                  infeasibilities.addIdx(j);
-                  isInfeasible[j] = SPxPricer<R>::VIOLATED;
-               }
-
-               if(hyperPricingEnter)
-                  updateViols.addIdx(j);
-            }
-            else
-            {
-               // @todo do we need to remove index j from infeasibilitiesCo?
-               isInfeasible[j] = SPxPricer<R>::NOT_VIOLATED;
-            }
-         }
-         else if(theCoTest[j] < -pricingTol)
-            m_pricingViol -= theCoTest[j];
-      }
-      else
-      {
-         isInfeasible[j] = SPxPricer<R>::NOT_VIOLATED;
-         theCoTest[j] = 0;
-      }
-   }
+template <class R> void SPxSolverBase<R>::updateCoTest() {
+  theCoPvec->delta().setup();
+
+  const IdxSet &idx = theCoPvec->idx();
+  const typename SPxBasisBase<R>::Desc &ds = this->desc();
+  R pricingTol = leavetol();
+
+  int i;
+  updateViols.clear();
+
+  for (i = idx.size() - 1; i >= 0; --i) {
+    int j = idx.index(i);
+    typename SPxBasisBase<R>::Desc::Status stat = ds.coStatus(j);
+
+    if (!isBasic(stat)) {
+      if (m_pricingViolUpToDate && theCoTest[j] < -pricingTol)
+        m_pricingViol += theCoTest[j];
+
+      theCoTest[j] = coTest(j, stat);
+
+      if (sparsePricingEnter) {
+        if (theCoTest[j] < -pricingTol) {
+          assert(remainingRoundsEnter == 0);
+          m_pricingViol -= theCoTest[j];
+
+          if (isInfeasible[j] == SPxPricer<R>::NOT_VIOLATED) {
+            //                if( !hyperPricingEnter )
+            infeasibilities.addIdx(j);
+            isInfeasible[j] = SPxPricer<R>::VIOLATED;
+          }
+
+          if (hyperPricingEnter)
+            updateViols.addIdx(j);
+        } else {
+          // @todo do we need to remove index j from infeasibilitiesCo?
+          isInfeasible[j] = SPxPricer<R>::NOT_VIOLATED;
+        }
+      } else if (theCoTest[j] < -pricingTol)
+        m_pricingViol -= theCoTest[j];
+    } else {
+      isInfeasible[j] = SPxPricer<R>::NOT_VIOLATED;
+      theCoTest[j] = 0;
+    }
+  }
 }
 
-
-
 /*  \Section{Compute statistics on entering variable}
     Here is a list of variables relevant when including |Id| to the basis.
     They are computed by |computeEnterStats()|.
 */
 template <class R>
-void SPxSolverBase<R>::getEnterVals
-(
-   SPxId enterId,
-   R& enterTest,
-   R& enterUB,
-   R& enterLB,
-   R& enterVal,
-   R& enterMax,
-   R& enterPric,
-   typename SPxBasisBase<R>::Desc::Status& enterStat,
-   R& enterRO,
-   StableSum<R>& objChange
-)
-{
-   int enterIdx;
-   typename SPxBasisBase<R>::Desc& ds = this->desc();
-
-   if(enterId.isSPxColId())
-   {
-      enterIdx = this->number(SPxColId(enterId));
-      enterStat = ds.colStatus(enterIdx);
-      assert(!isBasic(enterStat));
-
-      /*      For an #Id# to enter the basis we better recompute the Test value.
-       */
-      if(rep() == COLUMN)
-      {
-         computePvec(enterIdx);
-         enterTest = computeTest(enterIdx);
-         theTest[enterIdx] = 0;
-      }
+void SPxSolverBase<R>::getEnterVals(
+    SPxId enterId, R &enterTest, R &enterUB, R &enterLB, R &enterVal,
+    R &enterMax, R &enterPric,
+    typename SPxBasisBase<R>::Desc::Status &enterStat, R &enterRO,
+    StableSum<R> &objChange) {
+  int enterIdx;
+  typename SPxBasisBase<R>::Desc &ds = this->desc();
+
+  if (enterId.isSPxColId()) {
+    enterIdx = this->number(SPxColId(enterId));
+    enterStat = ds.colStatus(enterIdx);
+    assert(!isBasic(enterStat));
+
+    /*      For an #Id# to enter the basis we better recompute the Test value.
+     */
+    if (rep() == COLUMN) {
+      computePvec(enterIdx);
+      enterTest = computeTest(enterIdx);
+      theTest[enterIdx] = 0;
+    } else {
+      enterTest = coTest()[enterIdx];
+      theCoTest[enterIdx] = 0;
+    }
+
+    switch (enterStat) {
+    // primal/columnwise cases:
+    case SPxBasisBase<R>::Desc::P_ON_UPPER:
+      assert(rep() == COLUMN);
+      enterUB = theUCbound[enterIdx];
+      enterLB = theLCbound[enterIdx];
+      enterVal = enterUB;
+      enterMax = enterLB - enterUB;
+      enterPric = (*thePvec)[enterIdx];
+      enterRO = this->maxObj(enterIdx);
+      objChange -= enterVal * enterRO;
+
+      if (enterLB <= R(-infinity))
+        ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::D_ON_LOWER;
+      else if (EQ(enterLB, enterUB))
+        ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::D_FREE;
       else
-      {
-         enterTest = coTest()[enterIdx];
-         theCoTest[enterIdx] = 0;
-      }
+        ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::D_ON_BOTH;
 
-      switch(enterStat)
-      {
-      // primal/columnwise cases:
-      case SPxBasisBase<R>::Desc::P_ON_UPPER :
-         assert(rep() == COLUMN);
-         enterUB = theUCbound[enterIdx];
-         enterLB = theLCbound[enterIdx];
-         enterVal = enterUB;
-         enterMax = enterLB - enterUB;
-         enterPric = (*thePvec)[enterIdx];
-         enterRO = this->maxObj(enterIdx);
-         objChange -= enterVal * enterRO;
-
-         if(enterLB <= R(-infinity))
-            ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::D_ON_LOWER;
-         else if(EQ(enterLB, enterUB))
-            ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::D_FREE;
-         else
-            ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::D_ON_BOTH;
-
-         break;
-
-      case SPxBasisBase<R>::Desc::P_ON_LOWER :
-         assert(rep() == COLUMN);
-         enterUB = theUCbound[enterIdx];
-         enterLB = theLCbound[enterIdx];
-         enterVal = enterLB;
-         enterMax = enterUB - enterLB;
-         enterPric = (*thePvec)[enterIdx];
-         enterRO = this->maxObj(enterIdx);
-         objChange -= enterVal * enterRO;
-
-         if(enterUB >= R(infinity))
-            ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::D_ON_UPPER;
-         else if(EQ(enterLB, enterUB))
-            ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::D_FREE;
-         else
-            ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::D_ON_BOTH;
-
-         break;
-
-      case SPxBasisBase<R>::Desc::P_FREE :
-         assert(rep() == COLUMN);
-         enterUB = theUCbound[enterIdx];
-         enterLB = theLCbound[enterIdx];
-         enterVal = 0;
-         enterPric = (*thePvec)[enterIdx];
-         enterRO = this->maxObj(enterIdx);
-         ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::D_UNDEFINED;
-         enterMax = (enterRO - enterPric > 0) ? R(infinity) : R(-infinity);
-         break;
-
-      // dual/rowwise cases:
-      case SPxBasisBase<R>::Desc::D_ON_UPPER :
-         assert(rep() == ROW);
-         assert(theUCbound[enterIdx] < R(infinity));
-         enterUB = theUCbound[enterIdx];
-         enterLB = R(-infinity);
-         enterMax = R(-infinity);
-         enterVal = enterUB;
-         enterPric = (*theCoPvec)[enterIdx];
-         enterRO = SPxLPBase<R>::lower(enterIdx);
-         objChange -= enterRO * enterVal;
-         ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_LOWER :
-         assert(rep() == ROW);
-         assert(theLCbound[enterIdx] > R(-infinity));
-         enterLB = theLCbound[enterIdx];
-         enterUB = R(infinity);
-         enterMax = R(infinity);
-         enterVal = enterLB;
-         enterPric = (*theCoPvec)[enterIdx];
-         enterRO = SPxLPBase<R>::upper(enterIdx);
-         objChange -= enterRO * enterVal;
-         ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         break;
-
-      case SPxBasisBase<R>::Desc::D_FREE:
-         assert(rep() == ROW);
-         assert(SPxLPBase<R>::lower(enterIdx) == SPxLPBase<R>::upper(enterIdx));
-         enterUB = R(infinity);
-         enterLB = R(-infinity);
-         enterVal = 0;
-         enterRO = SPxLPBase<R>::upper(enterIdx);
-         enterPric = (*theCoPvec)[enterIdx];
-
-         if(enterPric > enterRO)
-            enterMax = R(infinity);
-         else
-            enterMax = R(-infinity);
-
-         ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::P_FIXED;
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_BOTH :
-         assert(rep() == ROW);
-         enterPric = (*theCoPvec)[enterIdx];
-
-         if(enterPric > SPxLPBase<R>::upper(enterIdx))
-         {
-            enterLB = theLCbound[enterIdx];
-            enterUB = R(infinity);
-            enterMax = R(infinity);
-            enterVal = enterLB;
-            enterRO = SPxLPBase<R>::upper(enterIdx);
-            ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         }
-         else
-         {
-            enterUB = theUCbound[enterIdx];
-            enterVal = enterUB;
-            enterRO = SPxLPBase<R>::lower(enterIdx);
-            enterLB = R(-infinity);
-            enterMax = R(-infinity);
-            ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-         }
-
-         objChange -= theLCbound[enterIdx] * SPxLPBase<R>::upper(enterIdx);
-         objChange -= theUCbound[enterIdx] * SPxLPBase<R>::lower(enterIdx);
-         break;
+      break;
 
-      default:
-         throw SPxInternalCodeException("XENTER01 This should never happen.");
-      }
+    case SPxBasisBase<R>::Desc::P_ON_LOWER:
+      assert(rep() == COLUMN);
+      enterUB = theUCbound[enterIdx];
+      enterLB = theLCbound[enterIdx];
+      enterVal = enterLB;
+      enterMax = enterUB - enterLB;
+      enterPric = (*thePvec)[enterIdx];
+      enterRO = this->maxObj(enterIdx);
+      objChange -= enterVal * enterRO;
+
+      if (enterUB >= R(infinity))
+        ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::D_ON_UPPER;
+      else if (EQ(enterLB, enterUB))
+        ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::D_FREE;
+      else
+        ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::D_ON_BOTH;
 
-      MSG_DEBUG(std::cout << "DENTER03 SPxSolverBase::getEnterVals() : col " << enterIdx
-                << ": " << enterStat
-                << " -> " << ds.colStatus(enterIdx)
-                << " objChange: " << objChange
-                << std::endl;)
-   }
-
-   else
-   {
-      assert(enterId.isSPxRowId());
-      enterIdx = this->number(SPxRowId(enterId));
-      enterStat = ds.rowStatus(enterIdx);
-      assert(!isBasic(enterStat));
-
-      /*      For an #Id# to enter the basis we better recompute the Test value.
-       */
-      if(rep() == ROW)
-      {
-         computePvec(enterIdx);
-         enterTest = computeTest(enterIdx);
-         theTest[enterIdx] = 0;
-      }
+      break;
+
+    case SPxBasisBase<R>::Desc::P_FREE:
+      assert(rep() == COLUMN);
+      enterUB = theUCbound[enterIdx];
+      enterLB = theLCbound[enterIdx];
+      enterVal = 0;
+      enterPric = (*thePvec)[enterIdx];
+      enterRO = this->maxObj(enterIdx);
+      ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::D_UNDEFINED;
+      enterMax = (enterRO - enterPric > 0) ? R(infinity) : R(-infinity);
+      break;
+
+    // dual/rowwise cases:
+    case SPxBasisBase<R>::Desc::D_ON_UPPER:
+      assert(rep() == ROW);
+      assert(theUCbound[enterIdx] < R(infinity));
+      enterUB = theUCbound[enterIdx];
+      enterLB = R(-infinity);
+      enterMax = R(-infinity);
+      enterVal = enterUB;
+      enterPric = (*theCoPvec)[enterIdx];
+      enterRO = SPxLPBase<R>::lower(enterIdx);
+      objChange -= enterRO * enterVal;
+      ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+      break;
+
+    case SPxBasisBase<R>::Desc::D_ON_LOWER:
+      assert(rep() == ROW);
+      assert(theLCbound[enterIdx] > R(-infinity));
+      enterLB = theLCbound[enterIdx];
+      enterUB = R(infinity);
+      enterMax = R(infinity);
+      enterVal = enterLB;
+      enterPric = (*theCoPvec)[enterIdx];
+      enterRO = SPxLPBase<R>::upper(enterIdx);
+      objChange -= enterRO * enterVal;
+      ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      break;
+
+    case SPxBasisBase<R>::Desc::D_FREE:
+      assert(rep() == ROW);
+      assert(SPxLPBase<R>::lower(enterIdx) == SPxLPBase<R>::upper(enterIdx));
+      enterUB = R(infinity);
+      enterLB = R(-infinity);
+      enterVal = 0;
+      enterRO = SPxLPBase<R>::upper(enterIdx);
+      enterPric = (*theCoPvec)[enterIdx];
+
+      if (enterPric > enterRO)
+        enterMax = R(infinity);
       else
-      {
-         enterTest = coTest()[enterIdx];
-         theCoTest[enterIdx] = 0;
+        enterMax = R(-infinity);
+
+      ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::P_FIXED;
+      break;
+
+    case SPxBasisBase<R>::Desc::D_ON_BOTH:
+      assert(rep() == ROW);
+      enterPric = (*theCoPvec)[enterIdx];
+
+      if (enterPric > SPxLPBase<R>::upper(enterIdx)) {
+        enterLB = theLCbound[enterIdx];
+        enterUB = R(infinity);
+        enterMax = R(infinity);
+        enterVal = enterLB;
+        enterRO = SPxLPBase<R>::upper(enterIdx);
+        ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      } else {
+        enterUB = theUCbound[enterIdx];
+        enterVal = enterUB;
+        enterRO = SPxLPBase<R>::lower(enterIdx);
+        enterLB = R(-infinity);
+        enterMax = R(-infinity);
+        ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
       }
 
-      switch(enterStat)
-      {
-      // primal/columnwise cases:
-      case SPxBasisBase<R>::Desc::P_ON_UPPER :
-         assert(rep() == COLUMN);
-         enterUB = theURbound[enterIdx];
-         enterLB = theLRbound[enterIdx];
-         enterVal = enterLB;
-         enterMax = enterUB - enterLB;
-         enterPric = (*theCoPvec)[enterIdx];
-         enterRO = this->maxRowObj(enterIdx);
-         objChange -= enterRO * enterVal;
-
-         if(enterUB >= R(infinity))
-            ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::D_ON_LOWER;
-         else if(EQ(enterLB, enterUB))
-            ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::D_FREE;
-         else
-            ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::D_ON_BOTH;
-
-         break;
-
-      case SPxBasisBase<R>::Desc::P_ON_LOWER :
-         assert(rep() == COLUMN);
-         enterUB = theURbound[enterIdx];
-         enterLB = theLRbound[enterIdx];
-         enterVal = enterUB;
-         enterMax = enterLB - enterUB;
-         enterPric = (*theCoPvec)[enterIdx];
-         enterRO = this->maxRowObj(enterIdx);
-         objChange -= enterRO * enterVal;
-
-         if(enterLB <= R(-infinity))
-            ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::D_ON_UPPER;
-         else if(EQ(enterLB, enterUB))
-            ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::D_FREE;
-         else
-            ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::D_ON_BOTH;
-
-         break;
-
-      case SPxBasisBase<R>::Desc::P_FREE :
-         assert(rep() == COLUMN);
+      objChange -= theLCbound[enterIdx] * SPxLPBase<R>::upper(enterIdx);
+      objChange -= theUCbound[enterIdx] * SPxLPBase<R>::lower(enterIdx);
+      break;
+
+    default:
+      throw SPxInternalCodeException("XENTER01 This should never happen.");
+    }
+
+    MSG_DEBUG(std::cout << "DENTER03 SPxSolverBase::getEnterVals() : col "
+                        << enterIdx << ": " << enterStat << " -> "
+                        << ds.colStatus(enterIdx) << " objChange: " << objChange
+                        << std::endl;)
+  }
+
+  else {
+    assert(enterId.isSPxRowId());
+    enterIdx = this->number(SPxRowId(enterId));
+    enterStat = ds.rowStatus(enterIdx);
+    assert(!isBasic(enterStat));
+
+    /*      For an #Id# to enter the basis we better recompute the Test value.
+     */
+    if (rep() == ROW) {
+      computePvec(enterIdx);
+      enterTest = computeTest(enterIdx);
+      theTest[enterIdx] = 0;
+    } else {
+      enterTest = coTest()[enterIdx];
+      theCoTest[enterIdx] = 0;
+    }
+
+    switch (enterStat) {
+    // primal/columnwise cases:
+    case SPxBasisBase<R>::Desc::P_ON_UPPER:
+      assert(rep() == COLUMN);
+      enterUB = theURbound[enterIdx];
+      enterLB = theLRbound[enterIdx];
+      enterVal = enterLB;
+      enterMax = enterUB - enterLB;
+      enterPric = (*theCoPvec)[enterIdx];
+      enterRO = this->maxRowObj(enterIdx);
+      objChange -= enterRO * enterVal;
+
+      if (enterUB >= R(infinity))
+        ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::D_ON_LOWER;
+      else if (EQ(enterLB, enterUB))
+        ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::D_FREE;
+      else
+        ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::D_ON_BOTH;
+
+      break;
+
+    case SPxBasisBase<R>::Desc::P_ON_LOWER:
+      assert(rep() == COLUMN);
+      enterUB = theURbound[enterIdx];
+      enterLB = theLRbound[enterIdx];
+      enterVal = enterUB;
+      enterMax = enterLB - enterUB;
+      enterPric = (*theCoPvec)[enterIdx];
+      enterRO = this->maxRowObj(enterIdx);
+      objChange -= enterRO * enterVal;
+
+      if (enterLB <= R(-infinity))
+        ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::D_ON_UPPER;
+      else if (EQ(enterLB, enterUB))
+        ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::D_FREE;
+      else
+        ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::D_ON_BOTH;
+
+      break;
+
+    case SPxBasisBase<R>::Desc::P_FREE:
+      assert(rep() == COLUMN);
 #if 1
-         throw SPxInternalCodeException("XENTER02 This should never happen.");
+      throw SPxInternalCodeException("XENTER02 This should never happen.");
 #else
-         MSG_ERROR(std::cerr << "EENTER99 ERROR: not yet debugged!" << std::endl;)
-         enterPric = (*theCoPvec)[enterIdx];
-         enterRO = this->maxRowObj(enterIdx);
-         ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::D_UNDEFINED;
+      MSG_ERROR(std::cerr << "EENTER99 ERROR: not yet debugged!" << std::endl;)
+      enterPric = (*theCoPvec)[enterIdx];
+      enterRO = this->maxRowObj(enterIdx);
+      ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::D_UNDEFINED;
 #endif
-         break;
-
-      // dual/rowwise cases:
-      case SPxBasisBase<R>::Desc::D_ON_UPPER :
-         assert(rep() == ROW);
-         assert(theURbound[enterIdx] < R(infinity));
-         enterUB = theURbound[enterIdx];
-         enterLB = R(-infinity);
-         enterVal = enterUB;
-         enterMax = R(-infinity);
-         enterPric = (*thePvec)[enterIdx];
-         enterRO = this->lhs(enterIdx);
-         objChange -= enterRO * enterVal;
-         ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_LOWER :
-         assert(rep() == ROW);
-         assert(theLRbound[enterIdx] > R(-infinity));
-         enterLB = theLRbound[enterIdx];
-         enterUB = R(infinity);
-         enterVal = enterLB;
-         enterMax = R(infinity);
-         enterPric = (*thePvec)[enterIdx];
-         enterRO = this->rhs(enterIdx);
-         objChange -= enterRO * enterVal;
-         ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         break;
-
-      case SPxBasisBase<R>::Desc::D_FREE:
-         assert(rep() == ROW);
-         assert(this->rhs(enterIdx) == this->lhs(enterIdx));
-         enterUB = R(infinity);
-         enterLB = R(-infinity);
-         enterVal = 0;
-         enterPric = (*thePvec)[enterIdx];
-         enterRO = this->rhs(enterIdx);
-         enterMax = (enterPric > enterRO) ? R(infinity) : R(-infinity);
-         ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::P_FIXED;
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_BOTH :
-         assert(rep() == ROW);
-         enterPric = (*thePvec)[enterIdx];
-
-         if(enterPric > this->rhs(enterIdx))
-         {
-            enterLB = theLRbound[enterIdx];
-            enterVal = enterLB;
-            enterUB = R(infinity);
-            enterMax = R(infinity);
-            enterRO = this->rhs(enterIdx);
-            ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         }
-         else
-         {
-            enterUB = theURbound[enterIdx];
-            enterVal = enterUB;
-            enterLB = R(-infinity);
-            enterMax = R(-infinity);
-            enterRO = this->lhs(enterIdx);
-            ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-         }
-
-         objChange -= theLRbound[enterIdx] * this->rhs(enterIdx);
-         objChange -= theURbound[enterIdx] * this->lhs(enterIdx);
-         break;
+      break;
 
-      default:
-         throw SPxInternalCodeException("XENTER03 This should never happen.");
+    // dual/rowwise cases:
+    case SPxBasisBase<R>::Desc::D_ON_UPPER:
+      assert(rep() == ROW);
+      assert(theURbound[enterIdx] < R(infinity));
+      enterUB = theURbound[enterIdx];
+      enterLB = R(-infinity);
+      enterVal = enterUB;
+      enterMax = R(-infinity);
+      enterPric = (*thePvec)[enterIdx];
+      enterRO = this->lhs(enterIdx);
+      objChange -= enterRO * enterVal;
+      ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+      break;
+
+    case SPxBasisBase<R>::Desc::D_ON_LOWER:
+      assert(rep() == ROW);
+      assert(theLRbound[enterIdx] > R(-infinity));
+      enterLB = theLRbound[enterIdx];
+      enterUB = R(infinity);
+      enterVal = enterLB;
+      enterMax = R(infinity);
+      enterPric = (*thePvec)[enterIdx];
+      enterRO = this->rhs(enterIdx);
+      objChange -= enterRO * enterVal;
+      ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      break;
+
+    case SPxBasisBase<R>::Desc::D_FREE:
+      assert(rep() == ROW);
+      assert(this->rhs(enterIdx) == this->lhs(enterIdx));
+      enterUB = R(infinity);
+      enterLB = R(-infinity);
+      enterVal = 0;
+      enterPric = (*thePvec)[enterIdx];
+      enterRO = this->rhs(enterIdx);
+      enterMax = (enterPric > enterRO) ? R(infinity) : R(-infinity);
+      ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::P_FIXED;
+      break;
+
+    case SPxBasisBase<R>::Desc::D_ON_BOTH:
+      assert(rep() == ROW);
+      enterPric = (*thePvec)[enterIdx];
+
+      if (enterPric > this->rhs(enterIdx)) {
+        enterLB = theLRbound[enterIdx];
+        enterVal = enterLB;
+        enterUB = R(infinity);
+        enterMax = R(infinity);
+        enterRO = this->rhs(enterIdx);
+        ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      } else {
+        enterUB = theURbound[enterIdx];
+        enterVal = enterUB;
+        enterLB = R(-infinity);
+        enterMax = R(-infinity);
+        enterRO = this->lhs(enterIdx);
+        ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
       }
 
-      MSG_DEBUG(std::cout << "DENTER05 SPxSolverBase::getEnterVals() : row "
-                << enterIdx << ": " << enterStat
-                << " -> " << ds.rowStatus(enterIdx)
-                << " objChange: " << objChange
-                << std::endl;)
-   }
+      objChange -= theLRbound[enterIdx] * this->rhs(enterIdx);
+      objChange -= theURbound[enterIdx] * this->lhs(enterIdx);
+      break;
+
+    default:
+      throw SPxInternalCodeException("XENTER03 This should never happen.");
+    }
+
+    MSG_DEBUG(std::cout << "DENTER05 SPxSolverBase::getEnterVals() : row "
+                        << enterIdx << ": " << enterStat << " -> "
+                        << ds.rowStatus(enterIdx) << " objChange: " << objChange
+                        << std::endl;)
+  }
 }
 
 /*      process leaving variable
  */
 template <class R>
-void SPxSolverBase<R>::getEnterVals2
-(
-   int leaveIdx,
-   R enterMax,
-   R& leavebound,
-   StableSum<R>& objChange
-)
-{
-   int idx;
-   typename SPxBasisBase<R>::Desc& ds = this->desc();
-   SPxId leftId = this->baseId(leaveIdx);
-
-   if(leftId.isSPxRowId())
-   {
-      idx = this->number(SPxRowId(leftId));
-      typename SPxBasisBase<R>::Desc::Status leaveStat = ds.rowStatus(idx);
-
-      // coverity[switch_selector_expr_is_constant]
-      switch(leaveStat)
-      {
-      case SPxBasisBase<R>::Desc::P_FIXED :
-         assert(rep() == ROW);
-         throw SPxInternalCodeException("XENTER04 This should never happen.");
-         break;
-
-      case SPxBasisBase<R>::Desc::P_ON_UPPER :
-         assert(rep() == ROW);
-         leavebound = theLBbound[leaveIdx];
-         theLRbound[idx] = leavebound;
-         ds.rowStatus(idx) = this->dualRowStatus(idx);
-
-         switch(ds.rowStatus(idx))
-         {
-         case SPxBasisBase<R>::Desc::D_ON_UPPER :
-            objChange += theURbound[idx] * this->lhs(idx);
-            break;
-
-         case SPxBasisBase<R>::Desc::D_ON_LOWER :
-            objChange += theLRbound[idx] * this->rhs(idx);
-            break;
-
-         case SPxBasisBase<R>::Desc::D_ON_BOTH :
-            objChange += theURbound[idx] * this->lhs(idx);
-            objChange += theLRbound[idx] * this->rhs(idx);
-            break;
-
-         default:
-            break;
-         }
-
-         break;
-
-      case SPxBasisBase<R>::Desc::P_ON_LOWER :
-         assert(rep() == ROW);
-         leavebound = theUBbound[leaveIdx];
-         theURbound[idx] = leavebound;
-         ds.rowStatus(idx) = this->dualRowStatus(idx);
-
-         switch(ds.rowStatus(idx))
-         {
-         case SPxBasisBase<R>::Desc::D_ON_UPPER :
-            objChange += theURbound[idx] * this->lhs(idx);
-            break;
-
-         case SPxBasisBase<R>::Desc::D_ON_LOWER :
-            objChange += theLRbound[idx] * this->rhs(idx);
-            break;
-
-         case SPxBasisBase<R>::Desc::D_ON_BOTH :
-            objChange += theURbound[idx] * this->lhs(idx);
-            objChange += theLRbound[idx] * this->rhs(idx);
-            break;
-
-         default:
-            break;
-         }
-
-         break;
-
-      case SPxBasisBase<R>::Desc::P_FREE :
-         assert(rep() == ROW);
-#if 1
-         throw SPxInternalCodeException("XENTER05 This should never happen.");
-#else
-         MSG_ERROR(std::cerr << "EENTER98 ERROR: not yet debugged!" << std::endl;)
-
-         if((*theCoPvec)[leaveIdx] - theLBbound[leaveIdx] <
-               theUBbound[leaveIdx] - (*theCoPvec)[leaveIdx])
-         {
-            leavebound = theLBbound[leaveIdx];
-            theLRbound[idx] = leavebound;
-         }
-         else
-         {
-            leavebound = theUBbound[leaveIdx];
-            theURbound[idx] = leavebound;
-         }
-
-         ds.rowStatus(idx) = SPxBasisBase<R>::Desc::D_UNDEFINED;
-#endif
-         break;
-
-      // primal/columnwise cases:
-      case SPxBasisBase<R>::Desc::D_UNDEFINED :
-         assert(rep() == COLUMN);
-         throw SPxInternalCodeException("XENTER06 This should never happen.");
-         break;
-
-      case SPxBasisBase<R>::Desc::D_FREE :
-         assert(rep() == COLUMN);
-
-         if(theFvec->delta()[leaveIdx] * enterMax < 0)
-            leavebound = theUBbound[leaveIdx];
-         else
-            leavebound = theLBbound[leaveIdx];
-
-         theLRbound[idx] = leavebound;
-         theURbound[idx] = leavebound;
-         objChange += leavebound * this->maxRowObj(leaveIdx);
-         ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_FIXED;
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_UPPER :
-         assert(rep() == COLUMN);
-         leavebound = theUBbound[leaveIdx];
-         theURbound[idx] = leavebound;
-         objChange += leavebound * this->maxRowObj(leaveIdx);
-         ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_LOWER :
-         assert(rep() == COLUMN);
-         leavebound = theLBbound[leaveIdx];
-         theLRbound[idx] = leavebound;
-         objChange += leavebound * this->maxRowObj(leaveIdx);
-         ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_BOTH :
-         assert(rep() == COLUMN);
-
-         if(enterMax * theFvec->delta()[leaveIdx] < 0)
-         {
-            leavebound = theUBbound[leaveIdx];
-            theURbound[idx] = leavebound;
-            objChange += leavebound * this->maxRowObj(leaveIdx);
-            ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-         }
-         else
-         {
-            leavebound = theLBbound[leaveIdx];
-            theLRbound[idx] = leavebound;
-            objChange += leavebound * this->maxRowObj(leaveIdx);
-            ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         }
-
-         break;
+void SPxSolverBase<R>::getEnterVals2(int leaveIdx, R enterMax, R &leavebound,
+                                     StableSum<R> &objChange) {
+  int idx;
+  typename SPxBasisBase<R>::Desc &ds = this->desc();
+  SPxId leftId = this->baseId(leaveIdx);
+
+  if (leftId.isSPxRowId()) {
+    idx = this->number(SPxRowId(leftId));
+    typename SPxBasisBase<R>::Desc::Status leaveStat = ds.rowStatus(idx);
+
+    // coverity[switch_selector_expr_is_constant]
+    switch (leaveStat) {
+    case SPxBasisBase<R>::Desc::P_FIXED:
+      assert(rep() == ROW);
+      throw SPxInternalCodeException("XENTER04 This should never happen.");
+      break;
+
+    case SPxBasisBase<R>::Desc::P_ON_UPPER:
+      assert(rep() == ROW);
+      leavebound = theLBbound[leaveIdx];
+      theLRbound[idx] = leavebound;
+      ds.rowStatus(idx) = this->dualRowStatus(idx);
+
+      switch (ds.rowStatus(idx)) {
+      case SPxBasisBase<R>::Desc::D_ON_UPPER:
+        objChange += theURbound[idx] * this->lhs(idx);
+        break;
+
+      case SPxBasisBase<R>::Desc::D_ON_LOWER:
+        objChange += theLRbound[idx] * this->rhs(idx);
+        break;
+
+      case SPxBasisBase<R>::Desc::D_ON_BOTH:
+        objChange += theURbound[idx] * this->lhs(idx);
+        objChange += theLRbound[idx] * this->rhs(idx);
+        break;
 
       default:
-         throw SPxInternalCodeException("XENTER07 This should never happen.");
+        break;
       }
 
-      MSG_DEBUG(std::cout << "DENTER06 SPxSolverBase::getEnterVals2(): row "
-                << idx << ": " << leaveStat
-                << " -> " << ds.rowStatus(idx)
-                << " objChange: " << objChange
-                << std::endl;)
-   }
-
-   else
-   {
-      assert(leftId.isSPxColId());
-      idx = this->number(SPxColId(leftId));
-      typename SPxBasisBase<R>::Desc::Status leaveStat = ds.colStatus(idx);
-
-      // coverity[switch_selector_expr_is_constant]
-      switch(leaveStat)
-      {
-      case SPxBasisBase<R>::Desc::P_ON_UPPER :
-         assert(rep() == ROW);
-         leavebound = theLBbound[leaveIdx];
-         theLCbound[idx] = leavebound;
-         ds.colStatus(idx) = this->dualColStatus(idx);
-
-         switch(ds.colStatus(idx))
-         {
-         case SPxBasisBase<R>::Desc::D_ON_UPPER :
-            objChange += theUCbound[idx] * this->lower(idx);
-            break;
-
-         case SPxBasisBase<R>::Desc::D_ON_LOWER :
-            objChange += theLCbound[idx] * this->upper(idx);
-            break;
-
-         case SPxBasisBase<R>::Desc::D_ON_BOTH :
-            objChange += theLCbound[idx] * this->upper(idx);
-            objChange += theUCbound[idx] * this->lower(idx);
-            break;
-
-         default:
-            break;
-         }
-
-         break;
-
-      case SPxBasisBase<R>::Desc::P_ON_LOWER :
-         assert(rep() == ROW);
-         leavebound = theUBbound[leaveIdx];
-         theUCbound[idx] = leavebound;
-         ds.colStatus(idx) = this->dualColStatus(idx);
-
-         switch(ds.colStatus(idx))
-         {
-         case SPxBasisBase<R>::Desc::D_ON_UPPER :
-            objChange += theUCbound[idx] * this->lower(idx);
-            break;
-
-         case SPxBasisBase<R>::Desc::D_ON_LOWER :
-            objChange += theLCbound[idx] * this->upper(idx);
-            break;
-
-         case SPxBasisBase<R>::Desc::D_ON_BOTH :
-            objChange += theLCbound[idx] * this->upper(idx);
-            objChange += theUCbound[idx] * this->lower(idx);
-            break;
-
-         default:
-            break;
-         }
-
-         break;
-
-      case SPxBasisBase<R>::Desc::P_FREE :
-         assert(rep() == ROW);
-
-         if(theFvec->delta()[leaveIdx] * enterMax > 0)
-         {
-            leavebound = theLBbound[leaveIdx];
-            theLCbound[idx] = leavebound;
-         }
-         else
-         {
-            leavebound = theUBbound[leaveIdx];
-            theUCbound[idx] = leavebound;
-         }
-
-         ds.colStatus(idx) = SPxBasisBase<R>::Desc::D_UNDEFINED;
-         break;
-
-      case SPxBasisBase<R>::Desc::P_FIXED:
-         assert(rep() == ROW);
-         throw SPxInternalCodeException("XENTER08 This should never happen.");
-         break;
-
-      // primal/columnwise cases:
-      case SPxBasisBase<R>::Desc::D_FREE :
-         assert(rep() == COLUMN);
-
-         if(theFvec->delta()[leaveIdx] * enterMax > 0)
-            leavebound = theLBbound[leaveIdx];
-         else
-            leavebound = theUBbound[leaveIdx];
-
-         theUCbound[idx] =
-            theLCbound[idx] = leavebound;
-         objChange += this->maxObj(idx) * leavebound;
-         ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_FIXED;
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_UPPER :
-         assert(rep() == COLUMN);
-         leavebound = theLBbound[leaveIdx];
-         theLCbound[idx] = leavebound;
-         objChange += this->maxObj(idx) * leavebound;
-         ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_LOWER :
-         assert(rep() == COLUMN);
-         leavebound = theUBbound[leaveIdx];
-         theUCbound[idx] = leavebound;
-         objChange += this->maxObj(idx) * leavebound;
-         ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_BOTH :
-      case SPxBasisBase<R>::Desc::D_UNDEFINED :
-         assert(rep() == COLUMN);
-
-         if(enterMax * theFvec->delta()[leaveIdx] < 0)
-         {
-            leavebound = theUBbound[leaveIdx];
-            theUCbound[idx] = leavebound;
-            objChange += this->maxObj(idx) * leavebound;
-            ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         }
-         else
-         {
-            leavebound = theLBbound[leaveIdx];
-            theLCbound[idx] = leavebound;
-            objChange += this->maxObj(idx) * leavebound;
-            ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-         }
-
-         break;
+      break;
+
+    case SPxBasisBase<R>::Desc::P_ON_LOWER:
+      assert(rep() == ROW);
+      leavebound = theUBbound[leaveIdx];
+      theURbound[idx] = leavebound;
+      ds.rowStatus(idx) = this->dualRowStatus(idx);
+
+      switch (ds.rowStatus(idx)) {
+      case SPxBasisBase<R>::Desc::D_ON_UPPER:
+        objChange += theURbound[idx] * this->lhs(idx);
+        break;
+
+      case SPxBasisBase<R>::Desc::D_ON_LOWER:
+        objChange += theLRbound[idx] * this->rhs(idx);
+        break;
+
+      case SPxBasisBase<R>::Desc::D_ON_BOTH:
+        objChange += theURbound[idx] * this->lhs(idx);
+        objChange += theLRbound[idx] * this->rhs(idx);
+        break;
 
       default:
-         throw SPxInternalCodeException("XENTER09 This should never happen.");
+        break;
       }
 
-      MSG_DEBUG(std::cout << "DENTER07 SPxSolverBase::getEnterVals2(): col "
-                << idx << ": " << leaveStat
-                << " -> " << ds.colStatus(idx)
-                << " objChange: " << objChange
-                << std::endl;)
-   }
-}
+      break;
 
-template <class R>
-void
-SPxSolverBase<R>::ungetEnterVal(
-   SPxId enterId,
-   typename SPxBasisBase<R>::Desc::Status enterStat,
-   R leaveVal,
-   const SVectorBase<R>& vec,
-   StableSum<R>& objChange
-)
-{
-   assert(rep() == COLUMN);
-   int enterIdx;
-   typename SPxBasisBase<R>::Desc& ds = this->desc();
-
-   if(enterId.isSPxColId())
-   {
-      enterIdx = this->number(SPxColId(enterId));
-
-      if(enterStat == SPxBasisBase<R>::Desc::P_ON_UPPER)
-      {
-         ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-         objChange += theLCbound[enterIdx] * this->maxObj(enterIdx);
-      }
-      else
-      {
-         ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         objChange += theUCbound[enterIdx] * this->maxObj(enterIdx);
+    case SPxBasisBase<R>::Desc::P_FREE:
+      assert(rep() == ROW);
+#if 1
+      throw SPxInternalCodeException("XENTER05 This should never happen.");
+#else
+      MSG_ERROR(std::cerr << "EENTER98 ERROR: not yet debugged!" << std::endl;)
+
+      if ((*theCoPvec)[leaveIdx] - theLBbound[leaveIdx] <
+          theUBbound[leaveIdx] - (*theCoPvec)[leaveIdx]) {
+        leavebound = theLBbound[leaveIdx];
+        theLRbound[idx] = leavebound;
+      } else {
+        leavebound = theUBbound[leaveIdx];
+        theURbound[idx] = leavebound;
       }
 
-      theFrhs->multAdd(leaveVal, vec);
-   }
-   else
-   {
-      enterIdx = this->number(SPxRowId(enterId));
-      assert(enterId.isSPxRowId());
-
-      if(enterStat == SPxBasisBase<R>::Desc::P_ON_UPPER)
-      {
-         ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-         objChange += (theURbound[enterIdx]) * this->maxRowObj(enterIdx);
-      }
+      ds.rowStatus(idx) = SPxBasisBase<R>::Desc::D_UNDEFINED;
+#endif
+      break;
+
+    // primal/columnwise cases:
+    case SPxBasisBase<R>::Desc::D_UNDEFINED:
+      assert(rep() == COLUMN);
+      throw SPxInternalCodeException("XENTER06 This should never happen.");
+      break;
+
+    case SPxBasisBase<R>::Desc::D_FREE:
+      assert(rep() == COLUMN);
+
+      if (theFvec->delta()[leaveIdx] * enterMax < 0)
+        leavebound = theUBbound[leaveIdx];
       else
-      {
-         ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         objChange += (theLRbound[enterIdx]) * this->maxRowObj(enterIdx);
-      }
+        leavebound = theLBbound[leaveIdx];
 
-      (*theFrhs)[enterIdx] += leaveVal;
-   }
+      theLRbound[idx] = leavebound;
+      theURbound[idx] = leavebound;
+      objChange += leavebound * this->maxRowObj(leaveIdx);
+      ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_FIXED;
+      break;
 
-   if(isId(enterId))
-   {
-      theTest[enterIdx] = 0;
-      isInfeasibleCo[enterIdx] = SPxPricer<R>::NOT_VIOLATED;
-   }
-   else
-   {
-      theCoTest[enterIdx] = 0;
-      isInfeasible[enterIdx] = SPxPricer<R>::NOT_VIOLATED;
-   }
-}
+    case SPxBasisBase<R>::Desc::D_ON_UPPER:
+      assert(rep() == COLUMN);
+      leavebound = theUBbound[leaveIdx];
+      theURbound[idx] = leavebound;
+      objChange += leavebound * this->maxRowObj(leaveIdx);
+      ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+      break;
 
-template <class R>
-void SPxSolverBase<R>::rejectEnter(
-   SPxId enterId,
-   R enterTest,
-   typename SPxBasisBase<R>::Desc::Status enterStat
-)
-{
-   int enterIdx = this->number(enterId);
-
-   if(isId(enterId))
-   {
-      theTest[enterIdx] = enterTest;
-      this->desc().status(enterIdx) = enterStat;
-   }
-   else
-   {
-      theCoTest[enterIdx] = enterTest;
-      this->desc().coStatus(enterIdx) = enterStat;
-   }
-}
+    case SPxBasisBase<R>::Desc::D_ON_LOWER:
+      assert(rep() == COLUMN);
+      leavebound = theLBbound[leaveIdx];
+      theLRbound[idx] = leavebound;
+      objChange += leavebound * this->maxRowObj(leaveIdx);
+      ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      break;
 
-template <class R>
-void SPxSolverBase<R>::computePrimalray4Col(R direction, SPxId enterId)
-{
-   R sign = (direction > 0 ? 1.0 : -1.0);
+    case SPxBasisBase<R>::Desc::D_ON_BOTH:
+      assert(rep() == COLUMN);
 
-   primalRay.clear();
-   primalRay.setMax(fVec().delta().size() + 1);
+      if (enterMax * theFvec->delta()[leaveIdx] < 0) {
+        leavebound = theUBbound[leaveIdx];
+        theURbound[idx] = leavebound;
+        objChange += leavebound * this->maxRowObj(leaveIdx);
+        ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+      } else {
+        leavebound = theLBbound[leaveIdx];
+        theLRbound[idx] = leavebound;
+        objChange += leavebound * this->maxRowObj(leaveIdx);
+        ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      }
 
-   for(int j = 0; j < fVec().delta().size(); ++j)
-   {
-      SPxId i = this->baseId(fVec().idx().index(j));
+      break;
 
-      if(i.isSPxColId())
-         primalRay.add(this->number(SPxColId(i)), sign * fVec().delta().value(j));
-   }
+    default:
+      throw SPxInternalCodeException("XENTER07 This should never happen.");
+    }
 
-   if(enterId.isSPxColId())
-      primalRay.add(this->number(SPxColId(enterId)), -sign);
-}
+    MSG_DEBUG(std::cout << "DENTER06 SPxSolverBase::getEnterVals2(): row "
+                        << idx << ": " << leaveStat << " -> "
+                        << ds.rowStatus(idx) << " objChange: " << objChange
+                        << std::endl;)
+  }
 
-template <class R>
-void SPxSolverBase<R>::computeDualfarkas4Row(R direction, SPxId enterId)
-{
-   R sign = (direction > 0 ? -1.0 : 1.0);
+  else {
+    assert(leftId.isSPxColId());
+    idx = this->number(SPxColId(leftId));
+    typename SPxBasisBase<R>::Desc::Status leaveStat = ds.colStatus(idx);
 
-   dualFarkas.clear();
-   dualFarkas.setMax(fVec().delta().size() + 1);
+    // coverity[switch_selector_expr_is_constant]
+    switch (leaveStat) {
+    case SPxBasisBase<R>::Desc::P_ON_UPPER:
+      assert(rep() == ROW);
+      leavebound = theLBbound[leaveIdx];
+      theLCbound[idx] = leavebound;
+      ds.colStatus(idx) = this->dualColStatus(idx);
 
-   for(int j = 0; j < fVec().delta().size(); ++j)
-   {
-      SPxId spxid = this->baseId(fVec().idx().index(j));
+      switch (ds.colStatus(idx)) {
+      case SPxBasisBase<R>::Desc::D_ON_UPPER:
+        objChange += theUCbound[idx] * this->lower(idx);
+        break;
 
-      if(spxid.isSPxRowId())
-         dualFarkas.add(this->number(SPxRowId(spxid)), sign * fVec().delta().value(j));
-   }
+      case SPxBasisBase<R>::Desc::D_ON_LOWER:
+        objChange += theLCbound[idx] * this->upper(idx);
+        break;
 
-   if(enterId.isSPxRowId())
-      dualFarkas.add(this->number(SPxRowId(enterId)), -sign);
-}
+      case SPxBasisBase<R>::Desc::D_ON_BOTH:
+        objChange += theLCbound[idx] * this->upper(idx);
+        objChange += theUCbound[idx] * this->lower(idx);
+        break;
 
-template <class R>
-bool SPxSolverBase<R>::enter(SPxId& enterId, bool polish)
-{
-   assert(enterId.isValid());
-   assert(type() == ENTER);
-   assert(initialized);
-
-   SPxId none;          // invalid id used when enter fails
-   R enterTest;      // correct test value of entering var
-   R enterUB;        // upper bound of entering variable
-   R enterLB;        // lower bound of entering variable
-   R enterVal;       // current value of entering variable
-   R enterMax;       // maximum value for entering shift
-   R enterPric;      // priced value of entering variable
-   typename SPxBasisBase<R>::Desc::Status enterStat;      // status of entering variable
-   R enterRO;        // rhs/obj of entering variable
-   StableSum<R> objChange;
-   const SVectorBase<R>* enterVec = enterVector(enterId);
-
-   bool instable = instableEnter;
-   assert(!instable || instableEnterId.isValid());
-
-   getEnterVals(enterId, enterTest, enterUB, enterLB,
-                enterVal, enterMax, enterPric, enterStat, enterRO, objChange);
-
-   if(!polish && enterTest > -epsilon())
-   {
-      rejectEnter(enterId, enterTest, enterStat);
-      this->change(-1, none, 0);
+      default:
+        break;
+      }
 
-      MSG_DEBUG(std::cout << "DENTER08 rejecting false enter pivot" << std::endl;)
+      break;
 
-      return false;
-   }
+    case SPxBasisBase<R>::Desc::P_ON_LOWER:
+      assert(rep() == ROW);
+      leavebound = theUBbound[leaveIdx];
+      theUCbound[idx] = leavebound;
+      ds.colStatus(idx) = this->dualColStatus(idx);
 
-   /*  Before performing the actual basis update, we must determine, how this
-       is to be accomplished.
-   */
-   // BH 2005-11-15: Obviously solve4update() is only called if theFvec.delta()
-   // is setup (i.e. the indices of the NZEs are stored within it) and there are
-   // 0 NZEs (???).
-   // In that case theFvec->delta() is set such that
-   //   Base * theFvec->delta() = enterVec
-   if(theFvec->delta().isSetup() && theFvec->delta().size() == 0)
-      SPxBasisBase<R>::solve4update(theFvec->delta(), *enterVec);
+      switch (ds.colStatus(idx)) {
+      case SPxBasisBase<R>::Desc::D_ON_UPPER:
+        objChange += theUCbound[idx] * this->lower(idx);
+        break;
 
-#ifdef ENABLE_ADDITIONAL_CHECKS
-   else
-   {
-      // BH 2005-11-29: This code block seems to check the assertion
-      //   || Base * theFvec->delta() - enterVec ||_2 <= entertol()
-      VectorBase<R> tmp(dim());
-      // BH 2005-11-15: This cast is necessary since SSVectorBase<R>  inherits protected from VectorBase<R>.
-      tmp = reinterpret_cast<VectorBase<R>&>(theFvec->delta());
-      this->multBaseWith(tmp);
-      tmp -= *enterVec;
-
-      if(tmp.length() > entertol())
-      {
-         // This happens frequently and does usually not hurt, so print these
-         // warnings only with verbose level INFO2 and higher.
-         MSG_INFO2((*this->spxout), (*this->spxout) << "WENTER09 fVec updated error = "
-                   << tmp.length() << std::endl;)
+      case SPxBasisBase<R>::Desc::D_ON_LOWER:
+        objChange += theLCbound[idx] * this->upper(idx);
+        break;
+
+      case SPxBasisBase<R>::Desc::D_ON_BOTH:
+        objChange += theLCbound[idx] * this->upper(idx);
+        objChange += theUCbound[idx] * this->lower(idx);
+        break;
+
+      default:
+        break;
       }
-   }
 
-#endif  // ENABLE_ADDITIONAL_CHECKS
+      break;
 
-   if(!polish && m_numCycle > m_maxCycle)
-   {
-      if(-enterMax > 0)
-         perturbMaxEnter();
-      else
-         perturbMinEnter();
-   }
+    case SPxBasisBase<R>::Desc::P_FREE:
+      assert(rep() == ROW);
 
-   R leaveVal = -enterMax;
+      if (theFvec->delta()[leaveIdx] * enterMax > 0) {
+        leavebound = theLBbound[leaveIdx];
+        theLCbound[idx] = leavebound;
+      } else {
+        leavebound = theUBbound[leaveIdx];
+        theUCbound[idx] = leavebound;
+      }
 
-   boundflips = 0;
-   int leaveIdx = theratiotester->selectLeave(leaveVal, enterTest, polish);
+      ds.colStatus(idx) = SPxBasisBase<R>::Desc::D_UNDEFINED;
+      break;
 
-   /* in row representation, fixed columns and rows should not leave the basis */
-   assert(leaveIdx < 0 || !this->baseId(leaveIdx).isSPxColId()
-          || this->desc().colStatus(this->number(SPxColId(this->baseId(leaveIdx)))) !=
-          SPxBasisBase<R>::Desc::P_FIXED);
-   assert(leaveIdx < 0 || !this->baseId(leaveIdx).isSPxRowId()
-          || this->desc().rowStatus(this->number(SPxRowId(this->baseId(leaveIdx)))) !=
-          SPxBasisBase<R>::Desc::P_FIXED);
+    case SPxBasisBase<R>::Desc::P_FIXED:
+      assert(rep() == ROW);
+      throw SPxInternalCodeException("XENTER08 This should never happen.");
+      break;
 
-   instableEnterVal = 0;
-   instableEnterId = SPxId();
-   instableEnter = false;
+    // primal/columnwise cases:
+    case SPxBasisBase<R>::Desc::D_FREE:
+      assert(rep() == COLUMN);
 
-   /*
-     We now tried to find a variable to leave the basis. If one has been
-     found, a regular basis update is to be performed.
-   */
-   if(leaveIdx >= 0)
-   {
-      if(spxAbs(leaveVal) < entertol())
-      {
-         if(NE(theUBbound[leaveIdx], theLBbound[leaveIdx])
-               && enterStat != SPxBasisBase<R>::Desc::P_FREE && enterStat != SPxBasisBase<R>::Desc::D_FREE)
-         {
-            m_numCycle++;
-            enterCycles++;
-         }
-      }
-      else
-         m_numCycle /= 2;
-
-      // setup for updating the copricing vector
-      if(coSolveVector3 && coSolveVector2)
-      {
-         assert(coSolveVector2->isConsistent());
-         assert(coSolveVector2rhs->isSetup());
-         assert(coSolveVector3->isConsistent());
-         assert(coSolveVector3rhs->isSetup());
-         assert(boundflips > 0);
-         SPxBasisBase<R>::coSolve(theCoPvec->delta(), *coSolveVector2, *coSolveVector3
-                                  , unitVecs[leaveIdx], *coSolveVector2rhs, *coSolveVector3rhs);
-         (*theCoPvec) -= (*coSolveVector3);
-      }
-      else if(coSolveVector3)
-      {
-         assert(coSolveVector3->isConsistent());
-         assert(coSolveVector3rhs->isSetup());
-         assert(boundflips > 0);
-         SPxBasisBase<R>::coSolve(theCoPvec->delta(), *coSolveVector3, unitVecs[leaveIdx],
-                                  *coSolveVector3rhs);
-         (*theCoPvec) -= (*coSolveVector3);
-      }
-      else if(coSolveVector2)
-         SPxBasisBase<R>::coSolve(theCoPvec->delta(), *coSolveVector2, unitVecs[leaveIdx],
-                                  *coSolveVector2rhs);
+      if (theFvec->delta()[leaveIdx] * enterMax > 0)
+        leavebound = theLBbound[leaveIdx];
       else
-         SPxBasisBase<R>::coSolve(theCoPvec->delta(), unitVecs[leaveIdx]);
-
-      if(boundflips > 0)
-      {
-         for(int i = coSolveVector3->dim() - 1; i >= 0; --i)
-         {
-            if(spxAbs((*coSolveVector3)[i]) > epsilon())
-               (*thePvec).multAdd(-(*coSolveVector3)[i], (*thecovectors)[i]);
-         }
-
-         // we need to update enterPric in case it was changed by bound flips
-         if(enterId.isSPxColId())
-            enterPric = (*theCoPvec)[this->number(SPxColId(enterId))];
-         else
-            enterPric = (*thePvec)[this->number(SPxRowId(enterId))];
-
-         MSG_DEBUG(std::cout << "IEBFRT02 breakpoints passed / bounds flipped = " << boundflips << std::endl;
-                  )
-         totalboundflips += boundflips;
-      }
+        leavebound = theUBbound[leaveIdx];
 
-      (*theCoPrhs)[leaveIdx] = enterRO;
-      theCoPvec->value() = (enterRO - enterPric) / theFvec->delta()[leaveIdx];
+      theUCbound[idx] = theLCbound[idx] = leavebound;
+      objChange += this->maxObj(idx) * leavebound;
+      ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_FIXED;
+      break;
 
-      if(theCoPvec->value() > epsilon() || theCoPvec->value() < -epsilon())
-      {
-         if(pricing() == FULL)
-         {
-            thePvec->value() = theCoPvec->value();
-            setupPupdate();
-         }
+    case SPxBasisBase<R>::Desc::D_ON_UPPER:
+      assert(rep() == COLUMN);
+      leavebound = theLBbound[leaveIdx];
+      theLCbound[idx] = leavebound;
+      objChange += this->maxObj(idx) * leavebound;
+      ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+      break;
+
+    case SPxBasisBase<R>::Desc::D_ON_LOWER:
+      assert(rep() == COLUMN);
+      leavebound = theUBbound[leaveIdx];
+      theUCbound[idx] = leavebound;
+      objChange += this->maxObj(idx) * leavebound;
+      ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      break;
+
+    case SPxBasisBase<R>::Desc::D_ON_BOTH:
+    case SPxBasisBase<R>::Desc::D_UNDEFINED:
+      assert(rep() == COLUMN);
 
-         doPupdate();
+      if (enterMax * theFvec->delta()[leaveIdx] < 0) {
+        leavebound = theUBbound[leaveIdx];
+        theUCbound[idx] = leavebound;
+        objChange += this->maxObj(idx) * leavebound;
+        ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      } else {
+        leavebound = theLBbound[leaveIdx];
+        theLCbound[idx] = leavebound;
+        objChange += this->maxObj(idx) * leavebound;
+        ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
       }
 
-      assert(thePvec->isConsistent());
-      assert(theCoPvec->isConsistent());
+      break;
 
-      assert(!this->baseId(leaveIdx).isSPxRowId()
-             || this->desc().rowStatus(this->number(SPxRowId(this->baseId(leaveIdx)))) !=
-             SPxBasisBase<R>::Desc::P_FIXED);
-      assert(!this->baseId(leaveIdx).isSPxColId()
-             || this->desc().colStatus(this->number(SPxColId(this->baseId(leaveIdx)))) !=
-             SPxBasisBase<R>::Desc::P_FIXED);
+    default:
+      throw SPxInternalCodeException("XENTER09 This should never happen.");
+    }
 
-      R leavebound;             // bound on which leaving variable moves
+    MSG_DEBUG(std::cout << "DENTER07 SPxSolverBase::getEnterVals2(): col "
+                        << idx << ": " << leaveStat << " -> "
+                        << ds.colStatus(idx) << " objChange: " << objChange
+                        << std::endl;)
+  }
+}
 
-      try
-      {
-         getEnterVals2(leaveIdx, enterMax, leavebound, objChange);
-      }
-      catch(const SPxException& F)
-      {
-         rejectEnter(enterId, enterTest, enterStat);
-         this->change(-1, none, 0);
-         throw F;
-      }
+template <class R>
+void SPxSolverBase<R>::ungetEnterVal(
+    SPxId enterId, typename SPxBasisBase<R>::Desc::Status enterStat, R leaveVal,
+    const SVectorBase<R> &vec, StableSum<R> &objChange) {
+  assert(rep() == COLUMN);
+  int enterIdx;
+  typename SPxBasisBase<R>::Desc &ds = this->desc();
+
+  if (enterId.isSPxColId()) {
+    enterIdx = this->number(SPxColId(enterId));
+
+    if (enterStat == SPxBasisBase<R>::Desc::P_ON_UPPER) {
+      ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+      objChange += theLCbound[enterIdx] * this->maxObj(enterIdx);
+    } else {
+      ds.colStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      objChange += theUCbound[enterIdx] * this->maxObj(enterIdx);
+    }
+
+    theFrhs->multAdd(leaveVal, vec);
+  } else {
+    enterIdx = this->number(SPxRowId(enterId));
+    assert(enterId.isSPxRowId());
+
+    if (enterStat == SPxBasisBase<R>::Desc::P_ON_UPPER) {
+      ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+      objChange += (theURbound[enterIdx]) * this->maxRowObj(enterIdx);
+    } else {
+      ds.rowStatus(enterIdx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      objChange += (theLRbound[enterIdx]) * this->maxRowObj(enterIdx);
+    }
+
+    (*theFrhs)[enterIdx] += leaveVal;
+  }
+
+  if (isId(enterId)) {
+    theTest[enterIdx] = 0;
+    isInfeasibleCo[enterIdx] = SPxPricer<R>::NOT_VIOLATED;
+  } else {
+    theCoTest[enterIdx] = 0;
+    isInfeasible[enterIdx] = SPxPricer<R>::NOT_VIOLATED;
+  }
+}
 
-      //  process entering variable
-      theUBbound[leaveIdx] = enterUB;
-      theLBbound[leaveIdx] = enterLB;
+template <class R>
+void SPxSolverBase<R>::rejectEnter(
+    SPxId enterId, R enterTest,
+    typename SPxBasisBase<R>::Desc::Status enterStat) {
+  int enterIdx = this->number(enterId);
+
+  if (isId(enterId)) {
+    theTest[enterIdx] = enterTest;
+    this->desc().status(enterIdx) = enterStat;
+  } else {
+    theCoTest[enterIdx] = enterTest;
+    this->desc().coStatus(enterIdx) = enterStat;
+  }
+}
 
-      //  compute tests:
-      updateCoTest();
+template <class R>
+void SPxSolverBase<R>::computePrimalray4Col(R direction, SPxId enterId) {
+  R sign = (direction > 0 ? 1.0 : -1.0);
 
-      if(pricing() == FULL)
-         updateTest();
+  primalRay.clear();
+  primalRay.setMax(fVec().delta().size() + 1);
 
-      // update feasibility vectors
-      theFvec->value() = leaveVal;
-      theFvec->update();
-      (*theFvec)[leaveIdx] = enterVal - leaveVal;
+  for (int j = 0; j < fVec().delta().size(); ++j) {
+    SPxId i = this->baseId(fVec().idx().index(j));
 
-      if(leavebound > epsilon() || leavebound < -epsilon())
-         theFrhs->multAdd(-leavebound, this->baseVec(leaveIdx));
+    if (i.isSPxColId())
+      primalRay.add(this->number(SPxColId(i)), sign * fVec().delta().value(j));
+  }
 
-      if(enterVal > epsilon() || enterVal < -epsilon())
-         theFrhs->multAdd(enterVal, *enterVec);
+  if (enterId.isSPxColId())
+    primalRay.add(this->number(SPxColId(enterId)), -sign);
+}
 
-      // update objective funtion value
-      updateNonbasicValue(objChange);
+template <class R>
+void SPxSolverBase<R>::computeDualfarkas4Row(R direction, SPxId enterId) {
+  R sign = (direction > 0 ? -1.0 : 1.0);
 
-      //  change basis matrix
-      this->change(leaveIdx, enterId, enterVec, &(theFvec->delta()));
+  dualFarkas.clear();
+  dualFarkas.setMax(fVec().delta().size() + 1);
 
-      return true;
-   }
-   /*  No leaving vector could be found that would yield a stable pivot step.
-    */
-   else if(NE(leaveVal, -enterMax))
-   {
-      /* In the ENTER algorithm, when for a selected entering variable we find only
-         an instable leaving variable, then the basis change is not conducted.
-         Instead, we save the entering variable's id in instableEnterId and set
-         the test value to zero, hoping to find a different leaving
-         variable with a stable leavingvariable.
-         If this fails, however, and no more entering variable is found, we have to
-         perform the instable basis change using instableEnterId. In this (and only
-         in this) case, the flag instableEnter is set to true.
-
-         leaveVal != enterMax is the case that selectLeave has found only an instable leaving
-         variable. We store this leaving variable for later if we are not already in the
-         instable case */
-
-      if(!instable)
-      {
-         instableEnterId = enterId;
-         instableEnterVal = enterTest;
-
-         MSG_DEBUG(std::cout << "DENTER09 rejecting enter pivot and looking for others" << std::endl;)
-
-         rejectEnter(enterId, enterTest / 10.0, enterStat);
-         this->change(-1, none, 0);
+  for (int j = 0; j < fVec().delta().size(); ++j) {
+    SPxId spxid = this->baseId(fVec().idx().index(j));
+
+    if (spxid.isSPxRowId())
+      dualFarkas.add(this->number(SPxRowId(spxid)),
+                     sign * fVec().delta().value(j));
+  }
+
+  if (enterId.isSPxRowId())
+    dualFarkas.add(this->number(SPxRowId(enterId)), -sign);
+}
+
+template <class R> bool SPxSolverBase<R>::enter(SPxId &enterId, bool polish) {
+  assert(enterId.isValid());
+  assert(type() == ENTER);
+  assert(initialized);
+
+  SPxId none;  // invalid id used when enter fails
+  R enterTest; // correct test value of entering var
+  R enterUB;   // upper bound of entering variable
+  R enterLB;   // lower bound of entering variable
+  R enterVal;  // current value of entering variable
+  R enterMax;  // maximum value for entering shift
+  R enterPric; // priced value of entering variable
+  typename SPxBasisBase<R>::Desc::Status
+      enterStat; // status of entering variable
+  R enterRO;     // rhs/obj of entering variable
+  StableSum<R> objChange;
+  const SVectorBase<R> *enterVec = enterVector(enterId);
+
+  bool instable = instableEnter;
+  assert(!instable || instableEnterId.isValid());
+
+  getEnterVals(enterId, enterTest, enterUB, enterLB, enterVal, enterMax,
+               enterPric, enterStat, enterRO, objChange);
+
+  if (!polish && enterTest > -epsilon()) {
+    rejectEnter(enterId, enterTest, enterStat);
+    this->change(-1, none, 0);
+
+    MSG_DEBUG(std::cout << "DENTER08 rejecting false enter pivot" << std::endl;)
+
+    return false;
+  }
+
+  /*  Before performing the actual basis update, we must determine, how this
+      is to be accomplished.
+  */
+  // BH 2005-11-15: Obviously solve4update() is only called if theFvec.delta()
+  // is setup (i.e. the indices of the NZEs are stored within it) and there are
+  // 0 NZEs (???).
+  // In that case theFvec->delta() is set such that
+  //   Base * theFvec->delta() = enterVec
+  if (theFvec->delta().isSetup() && theFvec->delta().size() == 0)
+    SPxBasisBase<R>::solve4update(theFvec->delta(), *enterVec);
+
+#ifdef ENABLE_ADDITIONAL_CHECKS
+  else {
+    // BH 2005-11-29: This code block seems to check the assertion
+    //   || Base * theFvec->delta() - enterVec ||_2 <= entertol()
+    VectorBase<R> tmp(dim());
+    // BH 2005-11-15: This cast is necessary since SSVectorBase<R>  inherits
+    // protected from VectorBase<R>.
+    tmp = reinterpret_cast<VectorBase<R> &>(theFvec->delta());
+    this->multBaseWith(tmp);
+    tmp -= *enterVec;
+
+    if (tmp.length() > entertol()) {
+      // This happens frequently and does usually not hurt, so print these
+      // warnings only with verbose level INFO2 and higher.
+      MSG_INFO2((*this->spxout), (*this->spxout)
+                                     << "WENTER09 fVec updated error = "
+                                     << tmp.length() << std::endl;)
+    }
+  }
+
+#endif // ENABLE_ADDITIONAL_CHECKS
+
+  if (!polish && m_numCycle > m_maxCycle) {
+    if (-enterMax > 0)
+      perturbMaxEnter();
+    else
+      perturbMinEnter();
+  }
+
+  R leaveVal = -enterMax;
+
+  boundflips = 0;
+  int leaveIdx = theratiotester->selectLeave(leaveVal, enterTest, polish);
+
+  /* in row representation, fixed columns and rows should not leave the basis */
+  assert(leaveIdx < 0 || !this->baseId(leaveIdx).isSPxColId() ||
+         this->desc().colStatus(this->number(SPxColId(
+             this->baseId(leaveIdx)))) != SPxBasisBase<R>::Desc::P_FIXED);
+  assert(leaveIdx < 0 || !this->baseId(leaveIdx).isSPxRowId() ||
+         this->desc().rowStatus(this->number(SPxRowId(
+             this->baseId(leaveIdx)))) != SPxBasisBase<R>::Desc::P_FIXED);
+
+  instableEnterVal = 0;
+  instableEnterId = SPxId();
+  instableEnter = false;
+
+  /*
+    We now tried to find a variable to leave the basis. If one has been
+    found, a regular basis update is to be performed.
+  */
+  if (leaveIdx >= 0) {
+    if (spxAbs(leaveVal) < entertol()) {
+      if (NE(theUBbound[leaveIdx], theLBbound[leaveIdx]) &&
+          enterStat != SPxBasisBase<R>::Desc::P_FREE &&
+          enterStat != SPxBasisBase<R>::Desc::D_FREE) {
+        m_numCycle++;
+        enterCycles++;
       }
-      else
-      {
-         MSG_DEBUG(std::cout << "DENTER10 rejecting enter pivot in instable state, resetting values" <<
-                   std::endl;)
-         rejectEnter(enterId, enterTest, enterStat);
-         this->change(-1, none, 0);
+    } else
+      m_numCycle /= 2;
+
+    // setup for updating the copricing vector
+    if (coSolveVector3 && coSolveVector2) {
+      assert(coSolveVector2->isConsistent());
+      assert(coSolveVector2rhs->isSetup());
+      assert(coSolveVector3->isConsistent());
+      assert(coSolveVector3rhs->isSetup());
+      assert(boundflips > 0);
+      SPxBasisBase<R>::coSolve(theCoPvec->delta(), *coSolveVector2,
+                               *coSolveVector3, unitVecs[leaveIdx],
+                               *coSolveVector2rhs, *coSolveVector3rhs);
+      (*theCoPvec) -= (*coSolveVector3);
+    } else if (coSolveVector3) {
+      assert(coSolveVector3->isConsistent());
+      assert(coSolveVector3rhs->isSetup());
+      assert(boundflips > 0);
+      SPxBasisBase<R>::coSolve(theCoPvec->delta(), *coSolveVector3,
+                               unitVecs[leaveIdx], *coSolveVector3rhs);
+      (*theCoPvec) -= (*coSolveVector3);
+    } else if (coSolveVector2)
+      SPxBasisBase<R>::coSolve(theCoPvec->delta(), *coSolveVector2,
+                               unitVecs[leaveIdx], *coSolveVector2rhs);
+    else
+      SPxBasisBase<R>::coSolve(theCoPvec->delta(), unitVecs[leaveIdx]);
+
+    if (boundflips > 0) {
+      for (int i = coSolveVector3->dim() - 1; i >= 0; --i) {
+        if (spxAbs((*coSolveVector3)[i]) > epsilon())
+          (*thePvec).multAdd(-(*coSolveVector3)[i], (*thecovectors)[i]);
       }
 
-      return false;
-   }
-   /*  No leaving vector has been selected from the basis. However, if the
-       shift amount for |fVec| is bounded, we are in the case, that the
-       entering variable is moved from one bound to its other, before any of
-       the basis feasibility variables reaches their bound. This may only
-       happen in primal/columnwise case with upper and lower bounds on
-       variables.
-   */
-   else if(!polish && leaveVal < R(infinity) && leaveVal > R(-infinity))
-   {
-      assert(rep() == COLUMN);
-      assert(EQ(leaveVal, -enterMax));
+      // we need to update enterPric in case it was changed by bound flips
+      if (enterId.isSPxColId())
+        enterPric = (*theCoPvec)[this->number(SPxColId(enterId))];
+      else
+        enterPric = (*thePvec)[this->number(SPxRowId(enterId))];
 
-      this->change(-1, enterId, enterVec);
+      MSG_DEBUG(std::cout << "IEBFRT02 breakpoints passed / bounds flipped = "
+                          << boundflips << std::endl;)
+      totalboundflips += boundflips;
+    }
 
-      theFvec->value() = leaveVal;
-      theFvec->update();
+    (*theCoPrhs)[leaveIdx] = enterRO;
+    theCoPvec->value() = (enterRO - enterPric) / theFvec->delta()[leaveIdx];
 
-      ungetEnterVal(enterId, enterStat, leaveVal, *enterVec, objChange);
+    if (theCoPvec->value() > epsilon() || theCoPvec->value() < -epsilon()) {
+      if (pricing() == FULL) {
+        thePvec->value() = theCoPvec->value();
+        setupPupdate();
+      }
 
-      // update objective funtion value
-      updateNonbasicValue(objChange);
+      doPupdate();
+    }
 
-      MSG_DEBUG(std::cout << "DENTER11 moving entering variable from one bound to the other" << std::endl;
-               )
+    assert(thePvec->isConsistent());
+    assert(theCoPvec->isConsistent());
 
-      return false;
-   }
-   /*  No variable could be selected to leave the basis and even the entering
-       variable is unbounded --- this is a failure.
-   */
-   else
-   {
-      /* The following line originally was in the "lastUpdate() > 1" case;
-         we need it in the INFEASIBLE/UNBOUNDED case, too, to have the
-         basis descriptor at the correct size.
-      */
+    assert(!this->baseId(leaveIdx).isSPxRowId() ||
+           this->desc().rowStatus(this->number(SPxRowId(
+               this->baseId(leaveIdx)))) != SPxBasisBase<R>::Desc::P_FIXED);
+    assert(!this->baseId(leaveIdx).isSPxColId() ||
+           this->desc().colStatus(this->number(SPxColId(
+               this->baseId(leaveIdx)))) != SPxBasisBase<R>::Desc::P_FIXED);
+
+    R leavebound; // bound on which leaving variable moves
+
+    try {
+      getEnterVals2(leaveIdx, enterMax, leavebound, objChange);
+    } catch (const SPxException &F) {
       rejectEnter(enterId, enterTest, enterStat);
       this->change(-1, none, 0);
+      throw F;
+    }
 
-      if(polish)
-         return false;
-
-      else if(this->lastUpdate() > 1)
-      {
-         MSG_INFO3((*this->spxout), (*this->spxout) << "IENTER01 factorization triggered in "
-                   << "enter() for feasibility test" << std::endl;)
-
-         try
-         {
-            factorize();
-         }
-         catch(const SPxStatusException& E)
-         {
-            // don't exit immediately but handle the singularity correctly
-            assert(SPxBasisBase<R>::status() == SPxBasisBase<R>::SINGULAR);
-            MSG_INFO3((*this->spxout), (*this->spxout) << "Caught exception in factorization: " << E.what() <<
-                      std::endl;)
-         }
-
-         /* after a factorization, the entering column/row might not be infeasible or suboptimal anymore, hence we do
-          * not try to call leave(leaveIdx), but rather return to the main solving loop and call the pricer again
-          */
-         return false;
-      }
+    //  process entering variable
+    theUBbound[leaveIdx] = enterUB;
+    theLBbound[leaveIdx] = enterLB;
 
-      /* do not exit with status infeasible or unbounded if there is only a very small violation
-       * ROW: recompute the primal variables and activities for another, more precise, round of pricing
-       */
-      else if(spxAbs(enterTest) < entertol())
-      {
-         MSG_INFO3((*this->spxout), (*this->spxout) << "IENTER11 clean up step to reduce numerical errors" <<
-                   std::endl;)
+    //  compute tests:
+    updateCoTest();
 
-         SPxBasisBase<R>::coSolve(*theCoPvec, *theCoPrhs);
-         computePvec();
-         computeCoTest();
-         computeTest();
+    if (pricing() == FULL)
+      updateTest();
 
-         return false;
-      }
+    // update feasibility vectors
+    theFvec->value() = leaveVal;
+    theFvec->update();
+    (*theFvec)[leaveIdx] = enterVal - leaveVal;
 
-      MSG_INFO3((*this->spxout), (*this->spxout) << "IENTER02 unboundedness/infeasibility found in "
-                << "enter()" << std::endl;)
+    if (leavebound > epsilon() || leavebound < -epsilon())
+      theFrhs->multAdd(-leavebound, this->baseVec(leaveIdx));
 
-      if(rep() == ROW)
-      {
-         computeDualfarkas4Row(leaveVal, enterId);
-         setBasisStatus(SPxBasisBase<R>::INFEASIBLE);
-      }
-      /**@todo if shift() is not zero, we must not conclude primal unboundedness */
-      else
-      {
-         computePrimalray4Col(leaveVal, enterId);
-         setBasisStatus(SPxBasisBase<R>::UNBOUNDED);
+    if (enterVal > epsilon() || enterVal < -epsilon())
+      theFrhs->multAdd(enterVal, *enterVec);
+
+    // update objective funtion value
+    updateNonbasicValue(objChange);
+
+    //  change basis matrix
+    this->change(leaveIdx, enterId, enterVec, &(theFvec->delta()));
+
+    return true;
+  }
+  /*  No leaving vector could be found that would yield a stable pivot step.
+   */
+  else if (NE(leaveVal, -enterMax)) {
+    /* In the ENTER algorithm, when for a selected entering variable we find
+       only an instable leaving variable, then the basis change is not
+       conducted. Instead, we save the entering variable's id in instableEnterId
+       and set the test value to zero, hoping to find a different leaving
+       variable with a stable leavingvariable.
+       If this fails, however, and no more entering variable is found, we have
+       to perform the instable basis change using instableEnterId. In this (and
+       only in this) case, the flag instableEnter is set to true.
+
+       leaveVal != enterMax is the case that selectLeave has found only an
+       instable leaving variable. We store this leaving variable for later if we
+       are not already in the instable case */
+
+    if (!instable) {
+      instableEnterId = enterId;
+      instableEnterVal = enterTest;
+
+      MSG_DEBUG(
+          std::cout << "DENTER09 rejecting enter pivot and looking for others"
+                    << std::endl;)
+
+      rejectEnter(enterId, enterTest / 10.0, enterStat);
+      this->change(-1, none, 0);
+    } else {
+      MSG_DEBUG(std::cout << "DENTER10 rejecting enter pivot in instable "
+                             "state, resetting values"
+                          << std::endl;)
+      rejectEnter(enterId, enterTest, enterStat);
+      this->change(-1, none, 0);
+    }
+
+    return false;
+  }
+  /*  No leaving vector has been selected from the basis. However, if the
+      shift amount for |fVec| is bounded, we are in the case, that the
+      entering variable is moved from one bound to its other, before any of
+      the basis feasibility variables reaches their bound. This may only
+      happen in primal/columnwise case with upper and lower bounds on
+      variables.
+  */
+  else if (!polish && leaveVal < R(infinity) && leaveVal > R(-infinity)) {
+    assert(rep() == COLUMN);
+    assert(EQ(leaveVal, -enterMax));
+
+    this->change(-1, enterId, enterVec);
+
+    theFvec->value() = leaveVal;
+    theFvec->update();
+
+    ungetEnterVal(enterId, enterStat, leaveVal, *enterVec, objChange);
+
+    // update objective funtion value
+    updateNonbasicValue(objChange);
+
+    MSG_DEBUG(
+        std::cout
+            << "DENTER11 moving entering variable from one bound to the other"
+            << std::endl;)
+
+    return false;
+  }
+  /*  No variable could be selected to leave the basis and even the entering
+      variable is unbounded --- this is a failure.
+  */
+  else {
+    /* The following line originally was in the "lastUpdate() > 1" case;
+       we need it in the INFEASIBLE/UNBOUNDED case, too, to have the
+       basis descriptor at the correct size.
+    */
+    rejectEnter(enterId, enterTest, enterStat);
+    this->change(-1, none, 0);
+
+    if (polish)
+      return false;
+
+    else if (this->lastUpdate() > 1) {
+      MSG_INFO3((*this->spxout),
+                (*this->spxout) << "IENTER01 factorization triggered in "
+                                << "enter() for feasibility test" << std::endl;)
+
+      try {
+        factorize();
+      } catch (const SPxStatusException &E) {
+        // don't exit immediately but handle the singularity correctly
+        assert(SPxBasisBase<R>::status() == SPxBasisBase<R>::SINGULAR);
+        MSG_INFO3((*this->spxout), (*this->spxout)
+                                       << "Caught exception in factorization: "
+                                       << E.what() << std::endl;)
       }
 
+      /* after a factorization, the entering column/row might not be infeasible
+       * or suboptimal anymore, hence we do not try to call leave(leaveIdx), but
+       * rather return to the main solving loop and call the pricer again
+       */
+      return false;
+    }
+
+    /* do not exit with status infeasible or unbounded if there is only a very
+     * small violation ROW: recompute the primal variables and activities for
+     * another, more precise, round of pricing
+     */
+    else if (spxAbs(enterTest) < entertol()) {
+      MSG_INFO3((*this->spxout),
+                (*this->spxout)
+                    << "IENTER11 clean up step to reduce numerical errors"
+                    << std::endl;)
+
+      SPxBasisBase<R>::coSolve(*theCoPvec, *theCoPrhs);
+      computePvec();
+      computeCoTest();
+      computeTest();
+
       return false;
-   }
+    }
+
+    MSG_INFO3((*this->spxout),
+              (*this->spxout)
+                  << "IENTER02 unboundedness/infeasibility found in "
+                  << "enter()" << std::endl;)
+
+    if (rep() == ROW) {
+      computeDualfarkas4Row(leaveVal, enterId);
+      setBasisStatus(SPxBasisBase<R>::INFEASIBLE);
+    }
+    /**@todo if shift() is not zero, we must not conclude primal unboundedness
+     */
+    else {
+      computePrimalray4Col(leaveVal, enterId);
+      setBasisStatus(SPxBasisBase<R>::UNBOUNDED);
+    }
+
+    return false;
+  }
 }
 } // namespace soplex
diff --git a/src/soplex/islist.h b/src/soplex/islist.h
index fcdabbc..3738e92 100644
--- a/src/soplex/islist.h
+++ b/src/soplex/islist.h
@@ -29,12 +29,10 @@
 #define _ISLIST_H_
 
 #include <assert.h>
-#include <stddef.h>
 #include <iostream>
+#include <stddef.h>
 
-
-namespace soplex
-{
+namespace soplex {
 
 //---------------------------------------------------------------------
 //  class IsElement<T>
@@ -49,57 +47,39 @@ namespace soplex
    like an instance of T itself, except that method next() has been
    added (thereby overriding any method next() defined in T).
  */
-template < class T >
-class IsElement : public T
-{
+template <class T> class IsElement : public T {
 protected:
-
-   //--------------------------
-   /**@name Data */
-   ///@{
-   IsElement<T>* the_next;       ///< pointer to next element in the IsList.
-   ///@}
+  //--------------------------
+  /**@name Data */
+  ///@{
+  IsElement<T> *the_next; ///< pointer to next element in the IsList.
+                          ///@}
 
 public:
-
-   //---------------------------------
-   /**@name Successor */
-   ///@{
-   ///
-   IsElement<T>*& next()
-   {
-      return the_next;
-   }
-   /// returns the next element in the IsList.
-   IsElement<T>* next() const
-   {
-      return the_next;
-   }
-   ///@}
-
-   //------------------------------------
-   /**@name Constructors / destructors */
-   ///@{
-
-   /// default constructor.
-   IsElement()
-   {}
-
-   ///
-   explicit
-   IsElement(const T& old)
-      : T(old)
-      , the_next(0)
-   {}
-
-   /// copy constructor.
-   /** Only the element itself is copied, while the link to the next list
-       element is set to a zero pointer.
-   */
-   IsElement(const IsElement<T>& old)
-      : T(old)
-      , the_next(0)
-   {}
+  //---------------------------------
+  /**@name Successor */
+  ///@{
+  ///
+  IsElement<T> *&next() { return the_next; }
+  /// returns the next element in the IsList.
+  IsElement<T> *next() const { return the_next; }
+  ///@}
+
+  //------------------------------------
+  /**@name Constructors / destructors */
+  ///@{
+
+  /// default constructor.
+  IsElement() {}
+
+  ///
+  explicit IsElement(const T &old) : T(old), the_next(0) {}
+
+  /// copy constructor.
+  /** Only the element itself is copied, while the link to the next list
+      element is set to a zero pointer.
+  */
+  IsElement(const IsElement<T> &old) : T(old), the_next(0) {}
 };
 
 //---------------------------------------------------------------------
@@ -117,374 +97,325 @@ public:
    the lists integrity. For this, class IsList provides enough methods for
    modifying a list in a save way. See the method list for a description.
  */
-template < class T >
-class IsList
-{
+template <class T> class IsList {
 protected:
-   T* the_first;   ///< the first element in the IsList.
-   T* the_last;    ///< the last element in the IsList.
-   bool destroyElements;
-   ///< should the destructor be called for each element when the list is destroyed?
+  T *the_first; ///< the first element in the IsList.
+  T *the_last;  ///< the last element in the IsList.
+  bool destroyElements;
+  ///< should the destructor be called for each element when the list is
+  ///< destroyed?
 
 public:
-   typedef IsElement<T> Element;
-
-   //--------------------------
-   /**@name Extension */
-   ///@{
-   /// appends \p elem to IsList.
-   void append(T* elem)
-   {
-      if(the_last)
-         the_last->next() = elem;
-      else
-         the_first = elem;
+  typedef IsElement<T> Element;
+
+  //--------------------------
+  /**@name Extension */
+  ///@{
+  /// appends \p elem to IsList.
+  void append(T *elem) {
+    if (the_last)
+      the_last->next() = elem;
+    else
+      the_first = elem;
 
-      the_last = elem;
-   }
+    the_last = elem;
+  }
 
-   /// prepends \p elem to IsList.
-   void prepend(T* elem)
-   {
-      if(the_first)
-         elem->next() = the_first;
-      else
-         the_last = elem;
+  /// prepends \p elem to IsList.
+  void prepend(T *elem) {
+    if (the_first)
+      elem->next() = the_first;
+    else
+      the_last = elem;
 
-      the_first = elem;
-   }
-
-   /// inserts \p elem to IsList after its element \p after.
-   void insert(T* elem, T* after)
-   {
-      assert(find(after));
-
-      if(after == the_last)
-         append(elem);
-      else
-      {
-         elem->next() = after->next();
-         after->next() = elem;
-      }
-   }
-
-   /// appends all elements of \p list to IsList.
-   /** Appending one list to another keeps the appended \p list. Instead,
-       \p list remains an own IsList which is then part of the
-       concatenated list. This means that modifying \p list will modify the
-       concateneted list as well and vice versa. The programmer is
-       responsible for such changes not to yield inconsistent lists.
-    */
-   void append(IsList<T>& list)
-   {
-      if(list.the_first)
-      {
-         append(list.the_first);
-         the_last = list.the_last;
-      }
-   }
-
-   /// prepends all elements of \p list to IsList.
-   /** Appending one list to another keeps the appended \p list.  Instead,
-       \p list remains an own IsList which is then part of the
-       concatenated list. This means that modifying \p list will modify the
-       concateneted list as well and vice versa. The programmer is
-       responsible for such changes not to yield inconsistent lists.
+    the_first = elem;
+  }
+
+  /// inserts \p elem to IsList after its element \p after.
+  void insert(T *elem, T *after) {
+    assert(find(after));
+
+    if (after == the_last)
+      append(elem);
+    else {
+      elem->next() = after->next();
+      after->next() = elem;
+    }
+  }
+
+  /// appends all elements of \p list to IsList.
+  /** Appending one list to another keeps the appended \p list. Instead,
+      \p list remains an own IsList which is then part of the
+      concatenated list. This means that modifying \p list will modify the
+      concateneted list as well and vice versa. The programmer is
+      responsible for such changes not to yield inconsistent lists.
    */
-   void prepend(IsList<T>& list)
-   {
-      if(list.the_first)
-      {
-         prepend(list.the_last);
-         the_first = list.the_first;
-      }
-   }
-
-   /// inserts all elements of \p list after element \p after of an IsList.
-   /** Inserting one list into another keeps the appended \p list. Instead,
-       \p list remains an own IsList which is then part of the
-       concatenated list. This means that modifying \p list will modify the
-       concateneted list as well and vice versa. The programmer is
-       responsible for such changes not to yield inconsistent lists.
-   */
-   void insert(IsList<T>& list, T* after)
-   {
-      assert(find(after));
-
-      if(list.the_first)
-      {
-         list.the_last->next() = after->next();
-         after->next() = list.first();
-
-         if(after == last())
-            the_last = list.last();
+  void append(IsList<T> &list) {
+    if (list.the_first) {
+      append(list.the_first);
+      the_last = list.the_last;
+    }
+  }
+
+  /// prepends all elements of \p list to IsList.
+  /** Appending one list to another keeps the appended \p list.  Instead,
+      \p list remains an own IsList which is then part of the
+      concatenated list. This means that modifying \p list will modify the
+      concateneted list as well and vice versa. The programmer is
+      responsible for such changes not to yield inconsistent lists.
+  */
+  void prepend(IsList<T> &list) {
+    if (list.the_first) {
+      prepend(list.the_last);
+      the_first = list.the_first;
+    }
+  }
+
+  /// inserts all elements of \p list after element \p after of an IsList.
+  /** Inserting one list into another keeps the appended \p list. Instead,
+      \p list remains an own IsList which is then part of the
+      concatenated list. This means that modifying \p list will modify the
+      concateneted list as well and vice versa. The programmer is
+      responsible for such changes not to yield inconsistent lists.
+  */
+  void insert(IsList<T> &list, T *after) {
+    assert(find(after));
+
+    if (list.the_first) {
+      list.the_last->next() = after->next();
+      after->next() = list.first();
+
+      if (after == last())
+        the_last = list.last();
+    }
+  }
+  ///@}
+
+  //--------------------------
+  /**@name Removal */
+  ///@{
+  /// removes the successor of \p after from an IsList.
+  void remove_next(T *after) {
+    assert(find(after));
+
+    if (after->next()) {
+      if (after->next() == last())
+        the_last = after;
+
+      after->next() = after->next()->next();
+    }
+  }
+
+  /// removes element \p elem from an IsList.
+  void remove(const T *elem) {
+    if (the_first) {
+      if (elem == the_first) {
+        the_first = next(elem);
+
+        if (the_first == 0)
+          the_last = 0;
+      } else {
+        T *after = the_first;
+
+        for (; after != the_last; after = after->next())
+          if (after->next() == elem) {
+            remove_next(after);
+            return;
+          }
       }
-   }
-   ///@}
-
-   //--------------------------
-   /**@name Removal */
-   ///@{
-   /// removes the successor of \p after from an IsList.
-   void remove_next(T* after)
-   {
-      assert(find(after));
-
-      if(after->next())
-      {
-         if(after->next() == last())
-            the_last = after;
-
-         after->next() = after->next()->next();
+    }
+  }
+
+  /// removes all elements of \p list from an IsList.
+  /** Removing \p list from an IsList requires \p list to be part of the
+      IsList. Such a situation can be achieved by previously adding
+      (i.e., #append%ing, #insert%ing or #prepend%ing) a list or
+      explicitely constructing a sublist with method sublist().
+  */
+  void remove(IsList<T> &list) {
+    if (the_first != 0 && list.the_first != 0) {
+      assert(find(list.first()));
+      assert(find(list.last()));
+
+      if (the_first == list.the_first) {
+        if (the_last == list.the_last)
+          the_first = the_last = 0;
+        else
+          the_first = list.the_last->next();
+      } else {
+        T *after = the_first;
+
+        for (; after->next() != list.the_first; after = after->next())
+          ;
+
+        if (the_last == list.the_last)
+          the_last = after;
+        else
+          after->next() = list.the_last->next();
       }
-   }
-
-   /// removes element \p elem from an IsList.
-   void remove(const T* elem)
-   {
-      if(the_first)
-      {
-         if(elem == the_first)
-         {
-            the_first = next(elem);
-
-            if(the_first == 0)
-               the_last = 0;
-         }
-         else
-         {
-            T* after = the_first;
-
-            for(; after != the_last; after = after->next())
-               if(after->next() == elem)
-               {
-                  remove_next(after);
-                  return;
-               }
-         }
+    }
+  }
+
+  /// removes all elements from an IsList.
+  void clear(bool pDestroyElements = false) {
+    if (pDestroyElements) {
+      T *nextElement;
+
+      for (T *it = the_first; it; it = nextElement) {
+        nextElement = next(it);
+        it->~T();
+        spx_free(it);
       }
-   }
-
-   /// removes all elements of \p list from an IsList.
-   /** Removing \p list from an IsList requires \p list to be part of the
-       IsList. Such a situation can be achieved by previously adding
-       (i.e., #append%ing, #insert%ing or #prepend%ing) a list or
-       explicitely constructing a sublist with method sublist().
+    }
+
+    the_first = the_last = 0;
+  }
+  ///@}
+
+  //--------------------------
+  /**@name Access */
+  ///@{
+  /// returns the IsList's first element.
+  T *first() const { return the_first; }
+
+  /// returns the IsList's last element.
+  T *last() const { return the_last; }
+
+  /// returns successor of \p elem in an IsList.
+  /** The successor of \p elem in a list generally corresponds to the
+      element returned by elem->next(). However, if \p elem is the last
+      element in an IsList, this method will return 0, whereas
+      elem->next() may yield an arbitrary value. For example, if the
+      current list is actually a sublist of another, larger IsList,
+      elem->next() returns the successor of \p elem in this larger
+      IsList.
    */
-   void remove(IsList<T>& list)
-   {
-      if(the_first != 0 && list.the_first != 0)
-      {
-         assert(find(list.first()));
-         assert(find(list.last()));
-
-         if(the_first == list.the_first)
-         {
-            if(the_last == list.the_last)
-               the_first = the_last = 0;
-            else
-               the_first = list.the_last->next();
-         }
-         else
-         {
-            T* after = the_first;
-
-            for(; after->next() != list.the_first; after = after->next())
-               ;
-
-            if(the_last == list.the_last)
-               the_last = after;
-            else
-               after->next() = list.the_last->next();
-         }
-      }
-   }
-
-   /// removes all elements from an IsList.
-   void clear(bool pDestroyElements = false)
-   {
-      if(pDestroyElements)
-      {
-         T* nextElement;
-
-         for(T* it = the_first; it; it = nextElement)
-         {
-            nextElement = next(it);
-            it->~T();
-            spx_free(it);
-         }
-      }
+  T *next(const T *elem) const { return (elem == the_last) ? 0 : elem->next(); }
 
-      the_first = the_last = 0;
-   }
-   ///@}
-
-   //--------------------------
-   /**@name Access */
-   ///@{
-   /// returns the IsList's first element.
-   T* first() const
-   {
-      return the_first;
-   }
-
-   /// returns the IsList's last element.
-   T* last() const
-   {
-      return the_last;
-   }
-
-   /// returns successor of \p elem in an IsList.
-   /** The successor of \p elem in a list generally corresponds to the
-       element returned by elem->next(). However, if \p elem is the last
-       element in an IsList, this method will return 0, whereas
-       elem->next() may yield an arbitrary value. For example, if the
-       current list is actually a sublist of another, larger IsList,
-       elem->next() returns the successor of \p elem in this larger
-       IsList.
-    */
-   T* next(const T* elem) const
-   {
-      return (elem == the_last) ? 0 : elem->next();
-   }
-
-   /// returns the number of elements in IsList.
-   int length() const
-   {
-      int num;
-
-      if(the_first)
-      {
-         T* test = the_first;
-
-         for(num = 1; test != the_last; test = test->next())
-            ++num;
-
-         return num;
-      }
+  /// returns the number of elements in IsList.
+  int length() const {
+    int num;
 
-      return 0;
-   }
-
-   /// returns the position of element \p elem within IsList.
-   int find(const T* elem) const
-   {
-      const T* test;
-
-      assert(elem != 0);
-
-      for(test = the_first; test != 0; test = next(test))
-         if(test == elem)
-            return 1;
-
-      return 0;
-   }
-
-   /// constructs sublist of an IsList.
-   /** Returns a new IsList containing a sublist of an IsList starting
-       with element \p start and reaching up to element \p end. Both must be
-       members of the IsList or 0, in which case the first and last
-       element are used, respectively.
-    */
-   IsList<T>sublist(const T* start = 0, const T* end = 0) const
-   {
-      IsList<T>part = *this;
-
-      if(start)
-      {
-         assert(find(start));
-         part.the_first = const_cast<T*>(start);
-      }
+    if (the_first) {
+      T *test = the_first;
 
-      if(end)
-      {
-         assert(part.find(end));
-         part.the_last = const_cast<T*>(end);
-      }
+      for (num = 1; test != the_last; test = test->next())
+        ++num;
 
-      return part;
-   }
-   ///@}
-
-   //--------------------------
-   /**@name Miscellaneous */
-   ///@{
-   /// adjusts list pointers to a new memory address.
-   /** This method is of a rather technical nature. If all list elements
-       are taken form one array of elements, in certain circumstances the
-       user may be forced to realloc this array. As a consequence all
-       next() pointers of the list elements would become invalid.
-       However, all addresses will be changed by a constant offset \p delta.
-       Then move( \p delta ) may be called, which adjusts the next()
-       pointers of all elements in the list.
-   */
-   void move(ptrdiff_t delta)
-   {
-      if(the_first)
-      {
-         T* elem;
-         the_last  = reinterpret_cast<T*>(reinterpret_cast<char*>(the_last) + delta);
-         the_first = reinterpret_cast<T*>(reinterpret_cast<char*>(the_first) + delta);
-
-         for(elem = first(); elem; elem = next(elem))
-            if(elem != last())
-               elem->next() = reinterpret_cast<T*>(reinterpret_cast<char*>(elem->next()) + delta);
-      }
-   }
+      return num;
+    }
 
-   /// consistency check.
-   bool isConsistent() const
-   {
-#ifdef ENABLE_CONSISTENCY_CHECKS
+    return 0;
+  }
 
-      if(first() != 0 && last() == 0)
-         return MSGinconsistent("IsList");
+  /// returns the position of element \p elem within IsList.
+  int find(const T *elem) const {
+    const T *test;
 
-      if(first() == 0 && last() != 0)
-         return MSGinconsistent("IsList");
+    assert(elem != 0);
 
-      if(first() && find(last()) == 0)
-         return MSGinconsistent("IsList");
+    for (test = the_first; test != 0; test = next(test))
+      if (test == elem)
+        return 1;
 
-#endif
+    return 0;
+  }
 
-      return true;
-   }
-   ///@}
-
-   //------------------------------------
-   /**@name Constructors / Destructors */
-   ///@{
-   /// default constructor.
-   /** The default constructor may be used to setup a (sub-)list, by
-       specifying a \p first and \p last element. Then \p last must be a
-       successor of \p first.
+  /// constructs sublist of an IsList.
+  /** Returns a new IsList containing a sublist of an IsList starting
+      with element \p start and reaching up to element \p end. Both must be
+      members of the IsList or 0, in which case the first and last
+      element are used, respectively.
    */
-   explicit
-   IsList(T* pfirst = 0, T* plast = 0, bool pDestroyElements = false)
-      : the_first(pfirst)
-      , the_last(plast)
-      , destroyElements(pDestroyElements)
-   {
-      if(pfirst)
-      {
-         assert(plast != 0);
-         assert(find(plast));
-      }
+  IsList<T> sublist(const T *start = 0, const T *end = 0) const {
+    IsList<T> part = *this;
+
+    if (start) {
+      assert(find(start));
+      part.the_first = const_cast<T *>(start);
+    }
+
+    if (end) {
+      assert(part.find(end));
+      part.the_last = const_cast<T *>(end);
+    }
+
+    return part;
+  }
+  ///@}
+
+  //--------------------------
+  /**@name Miscellaneous */
+  ///@{
+  /// adjusts list pointers to a new memory address.
+  /** This method is of a rather technical nature. If all list elements
+      are taken form one array of elements, in certain circumstances the
+      user may be forced to realloc this array. As a consequence all
+      next() pointers of the list elements would become invalid.
+      However, all addresses will be changed by a constant offset \p delta.
+      Then move( \p delta ) may be called, which adjusts the next()
+      pointers of all elements in the list.
+  */
+  void move(ptrdiff_t delta) {
+    if (the_first) {
+      T *elem;
+      the_last =
+          reinterpret_cast<T *>(reinterpret_cast<char *>(the_last) + delta);
+      the_first =
+          reinterpret_cast<T *>(reinterpret_cast<char *>(the_first) + delta);
+
+      for (elem = first(); elem; elem = next(elem))
+        if (elem != last())
+          elem->next() = reinterpret_cast<T *>(
+              reinterpret_cast<char *>(elem->next()) + delta);
+    }
+  }
+
+  /// consistency check.
+  bool isConsistent() const {
+#ifdef ENABLE_CONSISTENCY_CHECKS
 
-      assert(isConsistent());
-   }
+    if (first() != 0 && last() == 0)
+      return MSGinconsistent("IsList");
 
-   /// Assignment operator and copy constructor should be deleted to avoid memory problems
-   IsList<T> (const IsList<T>&) = delete;
-   IsList<T>& operator=(const IsList<T>& old) = delete;
+    if (first() == 0 && last() != 0)
+      return MSGinconsistent("IsList");
+
+    if (first() && find(last()) == 0)
+      return MSGinconsistent("IsList");
+
+#endif
 
-   /// destructor
-   ~IsList()
-   {
-      clear(destroyElements);
-   }
-   ///@}
+    return true;
+  }
+  ///@}
+
+  //------------------------------------
+  /**@name Constructors / Destructors */
+  ///@{
+  /// default constructor.
+  /** The default constructor may be used to setup a (sub-)list, by
+      specifying a \p first and \p last element. Then \p last must be a
+      successor of \p first.
+  */
+  explicit IsList(T *pfirst = 0, T *plast = 0, bool pDestroyElements = false)
+      : the_first(pfirst), the_last(plast), destroyElements(pDestroyElements) {
+    if (pfirst) {
+      assert(plast != 0);
+      assert(find(plast));
+    }
+
+    assert(isConsistent());
+  }
+
+  /// Assignment operator and copy constructor should be deleted to avoid memory
+  /// problems
+  IsList(const IsList<T> &) = delete;
+  IsList<T> &operator=(const IsList<T> &old) = delete;
+
+  /// destructor
+  ~IsList() { clear(destroyElements); }
+  ///@}
 };
 
 } // namespace soplex
diff --git a/src/soplex/leave.hpp b/src/soplex/leave.hpp
index a9c14d1..2446229 100644
--- a/src/soplex/leave.hpp
+++ b/src/soplex/leave.hpp
@@ -21,1176 +21,1065 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 /* Updating the Basis for Leaving Variables
  */
 #include <assert.h>
 #include <stdio.h>
 
+#include "soplex/exceptions.h"
 #include "soplex/spxdefines.h"
+#include "soplex/spxout.h"
 #include "soplex/spxpricer.h"
-#include "soplex/spxsolver.h"
 #include "soplex/spxratiotester.h"
-#include "soplex/spxout.h"
-#include "soplex/exceptions.h"
+#include "soplex/spxsolver.h"
 
-namespace soplex
-{
-static const Real reject_leave_tol = 1e-10; // = LOWSTAB as defined in spxfastrt.hpp
+namespace soplex {
+static const Real reject_leave_tol =
+    1e-10; // = LOWSTAB as defined in spxfastrt.hpp
 
 /*
-  VectorBase<R> |fTest| gives the feasibility test of all basic variables. For its
-  computation |fVec|, |theUBbound| and |theLBbound| must be setup correctly.
+  VectorBase<R> |fTest| gives the feasibility test of all basic variables. For
+  its computation |fVec|, |theUBbound| and |theLBbound| must be setup correctly.
   Values of |fTest| $<0$ represent infeasible variables, which are eligible
   for leaving the basis in the simplex loop.
 */
-template <class R>
-void SPxSolverBase<R>::computeFtest()
-{
-
-   assert(type() == LEAVE);
-
-   R theeps = entertol();
-   m_pricingViolUpToDate = true;
-   m_pricingViolCoUpToDate = true;
-   m_pricingViol = 0;
-   m_pricingViolCo = 0;
-   m_numViol = 0;
-   infeasibilities.clear();
-   int sparsitythreshold = (int)(sparsePricingFactor * dim());
-
-   for(int i = 0; i < dim(); ++i)
-   {
-      theCoTest[i] = ((*theFvec)[i] > theUBbound[i])
-                     ? theUBbound[i] - (*theFvec)[i]
-                     : (*theFvec)[i] - theLBbound[i];
-
-      if(remainingRoundsLeave == 0)
-      {
-         if(theCoTest[i] < -theeps)
-         {
-            m_pricingViol -= theCoTest[i];
-            infeasibilities.addIdx(i);
-            isInfeasible[i] = SPxPricer<R>::VIOLATED;
-            ++m_numViol;
-         }
-         else
-            isInfeasible[i] = SPxPricer<R>::NOT_VIOLATED;
-
-         if(infeasibilities.size() > sparsitythreshold)
-         {
-            MSG_INFO2((*this->spxout), (*this->spxout) << " --- using dense pricing"
-                      << std::endl;)
-            remainingRoundsLeave = DENSEROUNDS;
-            sparsePricingLeave = false;
-            infeasibilities.clear();
-         }
+template <class R> void SPxSolverBase<R>::computeFtest() {
+
+  assert(type() == LEAVE);
+
+  R theeps = entertol();
+  m_pricingViolUpToDate = true;
+  m_pricingViolCoUpToDate = true;
+  m_pricingViol = 0;
+  m_pricingViolCo = 0;
+  m_numViol = 0;
+  infeasibilities.clear();
+  int sparsitythreshold = (int)(sparsePricingFactor * dim());
+
+  for (int i = 0; i < dim(); ++i) {
+    theCoTest[i] = ((*theFvec)[i] > theUBbound[i])
+                       ? theUBbound[i] - (*theFvec)[i]
+                       : (*theFvec)[i] - theLBbound[i];
+
+    if (remainingRoundsLeave == 0) {
+      if (theCoTest[i] < -theeps) {
+        m_pricingViol -= theCoTest[i];
+        infeasibilities.addIdx(i);
+        isInfeasible[i] = SPxPricer<R>::VIOLATED;
+        ++m_numViol;
+      } else
+        isInfeasible[i] = SPxPricer<R>::NOT_VIOLATED;
+
+      if (infeasibilities.size() > sparsitythreshold) {
+        MSG_INFO2((*this->spxout),
+                  (*this->spxout) << " --- using dense pricing" << std::endl;)
+        remainingRoundsLeave = DENSEROUNDS;
+        sparsePricingLeave = false;
+        infeasibilities.clear();
       }
-      else if(theCoTest[i] < -theeps)
-      {
-         m_pricingViol -= theCoTest[i];
-         m_numViol++;
-      }
-   }
-
-   if(infeasibilities.size() == 0 && !sparsePricingLeave)
-   {
-      --remainingRoundsLeave;
-   }
-   else if(infeasibilities.size() <= sparsitythreshold && !sparsePricingLeave)
-   {
-      MSG_INFO2((*this->spxout),
-                std::streamsize prec = spxout->precision();
-
-                if(hyperPricingLeave)
-                (*this->spxout) << " --- using hypersparse pricing, ";
-                else
-                   (*this->spxout) << " --- using sparse pricing, ";
-                   (*this->spxout) << "sparsity: "
-                   << std::setw(6) << std::fixed << std::setprecision(4)
-                   << (R) m_numViol / dim()
-                   << std::scientific << std::setprecision(int(prec))
-                   << std::endl;
-                  )
-            sparsePricingLeave = true;
-   }
+    } else if (theCoTest[i] < -theeps) {
+      m_pricingViol -= theCoTest[i];
+      m_numViol++;
+    }
+  }
+
+  if (infeasibilities.size() == 0 && !sparsePricingLeave) {
+    --remainingRoundsLeave;
+  } else if (infeasibilities.size() <= sparsitythreshold &&
+             !sparsePricingLeave) {
+    MSG_INFO2((*this->spxout), std::streamsize prec = spxout->precision();
+
+              if (hyperPricingLeave)(*this->spxout)
+              << " --- using hypersparse pricing, ";
+              else(*this->spxout) << " --- using sparse pricing, ";
+              (*this->spxout)
+              << "sparsity: " << std::setw(6) << std::fixed
+              << std::setprecision(4) << (R)m_numViol / dim() << std::scientific
+              << std::setprecision(int(prec)) << std::endl;)
+    sparsePricingLeave = true;
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::updateFtest()
-{
-   const IdxSet& idx = theFvec->idx();
-   VectorBase<R>& ftest = theCoTest;      // |== fTest()|
-   assert(&ftest == &fTest());
-
-   assert(type() == LEAVE);
+template <class R> void SPxSolverBase<R>::updateFtest() {
+  const IdxSet &idx = theFvec->idx();
+  VectorBase<R> &ftest = theCoTest; // |== fTest()|
+  assert(&ftest == &fTest());
 
-   updateViols.clear();
-   R theeps = entertol();
+  assert(type() == LEAVE);
 
-   for(int j = idx.size() - 1; j >= 0; --j)
-   {
-      int i = idx.index(j);
+  updateViols.clear();
+  R theeps = entertol();
 
-      if(m_pricingViolUpToDate && ftest[i] < -theeps)
-         // violation was present before this iteration
-         m_pricingViol += ftest[i];
+  for (int j = idx.size() - 1; j >= 0; --j) {
+    int i = idx.index(j);
 
-      ftest[i] = ((*theFvec)[i] > theUBbound[i])
-                 ? theUBbound[i] - (*theFvec)[i]
-                 : (*theFvec)[i] - theLBbound[i];
+    if (m_pricingViolUpToDate && ftest[i] < -theeps)
+      // violation was present before this iteration
+      m_pricingViol += ftest[i];
 
-      if(sparsePricingLeave && ftest[i] < -theeps)
-      {
-         assert(remainingRoundsLeave == 0);
+    ftest[i] = ((*theFvec)[i] > theUBbound[i]) ? theUBbound[i] - (*theFvec)[i]
+                                               : (*theFvec)[i] - theLBbound[i];
 
-         if(m_pricingViolUpToDate)
-            m_pricingViol -= ftest[i];
+    if (sparsePricingLeave && ftest[i] < -theeps) {
+      assert(remainingRoundsLeave == 0);
 
-         if(isInfeasible[i] == SPxPricer<R>::NOT_VIOLATED)
-         {
-            // this can cause problems - we cannot keep on adding indeces to infeasibilities,
-            // because they are not deleted in hyper mode...
-            //             if( !hyperPricingLeave )
-            infeasibilities.addIdx(i);
-            isInfeasible[i] = SPxPricer<R>::VIOLATED;
-         }
+      if (m_pricingViolUpToDate)
+        m_pricingViol -= ftest[i];
 
-         if(hyperPricingLeave)
-            updateViols.addIdx(i);
+      if (isInfeasible[i] == SPxPricer<R>::NOT_VIOLATED) {
+        // this can cause problems - we cannot keep on adding indeces to
+        // infeasibilities, because they are not deleted in hyper mode...
+        //             if( !hyperPricingLeave )
+        infeasibilities.addIdx(i);
+        isInfeasible[i] = SPxPricer<R>::VIOLATED;
       }
-      else if(m_pricingViolUpToDate && ftest[i] < -theeps)
-         m_pricingViol -= ftest[i];
-   }
 
-   // if boundflips were performed, we need to update these indices as well
-   if(boundflips > 0)
-   {
-      R eps = epsilon();
+      if (hyperPricingLeave)
+        updateViols.addIdx(i);
+    } else if (m_pricingViolUpToDate && ftest[i] < -theeps)
+      m_pricingViol -= ftest[i];
+  }
 
-      for(int j = 0; j < solveVector3->size(); ++j)
-      {
-         if(spxAbs(solveVector3->value(j)) > eps)
-         {
-            int i = solveVector3->index(j);
-
-            if(m_pricingViolUpToDate && ftest[i] < -theeps)
-               m_pricingViol += ftest[i];
-
-            ftest[i] = ((*theFvec)[i] > theUBbound[i]) ? theUBbound[i] - (*theFvec)[i] :
-                       (*theFvec)[i] - theLBbound[i];
-
-            if(sparsePricingLeave && ftest[i] < -theeps)
-            {
-               assert(remainingRoundsLeave == 0);
-
-               if(m_pricingViolUpToDate)
-                  m_pricingViol -= ftest[i];
-
-               if(!isInfeasible[i])
-               {
-                  infeasibilities.addIdx(i);
-                  isInfeasible[i] = true;
-               }
-            }
-            else if(m_pricingViolUpToDate && ftest[i] < -theeps)
-               m_pricingViol -= ftest[i];
-         }
+  // if boundflips were performed, we need to update these indices as well
+  if (boundflips > 0) {
+    R eps = epsilon();
+
+    for (int j = 0; j < solveVector3->size(); ++j) {
+      if (spxAbs(solveVector3->value(j)) > eps) {
+        int i = solveVector3->index(j);
+
+        if (m_pricingViolUpToDate && ftest[i] < -theeps)
+          m_pricingViol += ftest[i];
+
+        ftest[i] = ((*theFvec)[i] > theUBbound[i])
+                       ? theUBbound[i] - (*theFvec)[i]
+                       : (*theFvec)[i] - theLBbound[i];
+
+        if (sparsePricingLeave && ftest[i] < -theeps) {
+          assert(remainingRoundsLeave == 0);
+
+          if (m_pricingViolUpToDate)
+            m_pricingViol -= ftest[i];
+
+          if (!isInfeasible[i]) {
+            infeasibilities.addIdx(i);
+            isInfeasible[i] = true;
+          }
+        } else if (m_pricingViolUpToDate && ftest[i] < -theeps)
+          m_pricingViol -= ftest[i];
       }
-   }
+    }
+  }
 }
 
-
 /* compute statistics on leaving variable
    Compute a set of statistical values on the variable selected for leaving the
    basis.
 */
 template <class R>
 void SPxSolverBase<R>::getLeaveVals(
-   int leaveIdx,
-   typename SPxBasisBase<R>::Desc::Status& leaveStat,
-   SPxId& leaveId,
-   R& leaveMax,
-   R& leavebound,
-   int& leaveNum,
-   StableSum<R>& objChange)
-{
-   typename SPxBasisBase<R>::Desc& ds = this->desc();
-   leaveId = this->baseId(leaveIdx);
-
-   if(leaveId.isSPxRowId())
-   {
-      leaveNum = this->number(SPxRowId(leaveId));
-      leaveStat = ds.rowStatus(leaveNum);
-
-      assert(isBasic(leaveStat));
-
-      switch(leaveStat)
-      {
-      case SPxBasisBase<R>::Desc::P_ON_UPPER :
-         assert(rep() == ROW);
-         ds.rowStatus(leaveNum) = this->dualRowStatus(leaveNum);
-         leavebound = 0;
-         leaveMax = R(-infinity);
-         break;
-
-      case SPxBasisBase<R>::Desc::P_ON_LOWER :
-         assert(rep() == ROW);
-         ds.rowStatus(leaveNum) = this->dualRowStatus(leaveNum);
-         leavebound = 0;
-         leaveMax = R(infinity);
-         break;
-
-      case SPxBasisBase<R>::Desc::P_FREE :
-         assert(rep() == ROW);
-         throw SPxInternalCodeException("XLEAVE01 This should never happen.");
-
-      case SPxBasisBase<R>::Desc::D_FREE :
-         assert(rep() == COLUMN);
-         ds.rowStatus(leaveNum) = SPxBasisBase<R>::Desc::P_FIXED;
-         assert(this->lhs(leaveNum) == this->rhs(leaveNum));
-         leavebound = -this->rhs(leaveNum);
-
-         if((*theFvec)[leaveIdx] < theLBbound[leaveIdx])
-            leaveMax = R(infinity);
-         else
-            leaveMax = R(-infinity);
-
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_LOWER :
-         assert(rep() == COLUMN);
-         ds.rowStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         leavebound = -this->rhs(leaveNum);                // slack !!
-         leaveMax = R(infinity);
-         objChange += theLRbound[leaveNum] * this->rhs(leaveNum);
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_UPPER :
-         assert(rep() == COLUMN);
-         ds.rowStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-         leavebound = -this->lhs(leaveNum);                // slack !!
-         leaveMax = R(-infinity);
-         objChange += theURbound[leaveNum] * this->lhs(leaveNum);
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_BOTH :
-         assert(rep() == COLUMN);
-
-         if((*theFvec)[leaveIdx] > theLBbound[leaveIdx])
-         {
-            ds.rowStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-            theLRbound[leaveNum] = R(-infinity);
-            leavebound = -this->lhs(leaveNum);            // slack !!
-            leaveMax = R(-infinity);
-            objChange += theURbound[leaveNum] * this->lhs(leaveNum);
-         }
-         else
-         {
-            ds.rowStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-            theURbound[leaveNum] = R(infinity);
-            leavebound = -this->rhs(leaveNum);            // slack !!
-            leaveMax = R(infinity);
-            objChange += theLRbound[leaveNum] * this->rhs(leaveNum);
-         }
-
-         break;
-
-      default:
-         throw SPxInternalCodeException("XLEAVE02 This should never happen.");
+    int leaveIdx, typename SPxBasisBase<R>::Desc::Status &leaveStat,
+    SPxId &leaveId, R &leaveMax, R &leavebound, int &leaveNum,
+    StableSum<R> &objChange) {
+  typename SPxBasisBase<R>::Desc &ds = this->desc();
+  leaveId = this->baseId(leaveIdx);
+
+  if (leaveId.isSPxRowId()) {
+    leaveNum = this->number(SPxRowId(leaveId));
+    leaveStat = ds.rowStatus(leaveNum);
+
+    assert(isBasic(leaveStat));
+
+    switch (leaveStat) {
+    case SPxBasisBase<R>::Desc::P_ON_UPPER:
+      assert(rep() == ROW);
+      ds.rowStatus(leaveNum) = this->dualRowStatus(leaveNum);
+      leavebound = 0;
+      leaveMax = R(-infinity);
+      break;
+
+    case SPxBasisBase<R>::Desc::P_ON_LOWER:
+      assert(rep() == ROW);
+      ds.rowStatus(leaveNum) = this->dualRowStatus(leaveNum);
+      leavebound = 0;
+      leaveMax = R(infinity);
+      break;
+
+    case SPxBasisBase<R>::Desc::P_FREE:
+      assert(rep() == ROW);
+      throw SPxInternalCodeException("XLEAVE01 This should never happen.");
+
+    case SPxBasisBase<R>::Desc::D_FREE:
+      assert(rep() == COLUMN);
+      ds.rowStatus(leaveNum) = SPxBasisBase<R>::Desc::P_FIXED;
+      assert(this->lhs(leaveNum) == this->rhs(leaveNum));
+      leavebound = -this->rhs(leaveNum);
+
+      if ((*theFvec)[leaveIdx] < theLBbound[leaveIdx])
+        leaveMax = R(infinity);
+      else
+        leaveMax = R(-infinity);
+
+      break;
+
+    case SPxBasisBase<R>::Desc::D_ON_LOWER:
+      assert(rep() == COLUMN);
+      ds.rowStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      leavebound = -this->rhs(leaveNum); // slack !!
+      leaveMax = R(infinity);
+      objChange += theLRbound[leaveNum] * this->rhs(leaveNum);
+      break;
+
+    case SPxBasisBase<R>::Desc::D_ON_UPPER:
+      assert(rep() == COLUMN);
+      ds.rowStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+      leavebound = -this->lhs(leaveNum); // slack !!
+      leaveMax = R(-infinity);
+      objChange += theURbound[leaveNum] * this->lhs(leaveNum);
+      break;
+
+    case SPxBasisBase<R>::Desc::D_ON_BOTH:
+      assert(rep() == COLUMN);
+
+      if ((*theFvec)[leaveIdx] > theLBbound[leaveIdx]) {
+        ds.rowStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+        theLRbound[leaveNum] = R(-infinity);
+        leavebound = -this->lhs(leaveNum); // slack !!
+        leaveMax = R(-infinity);
+        objChange += theURbound[leaveNum] * this->lhs(leaveNum);
+      } else {
+        ds.rowStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+        theURbound[leaveNum] = R(infinity);
+        leavebound = -this->rhs(leaveNum); // slack !!
+        leaveMax = R(infinity);
+        objChange += theLRbound[leaveNum] * this->rhs(leaveNum);
       }
 
-      MSG_DEBUG(std::cout << "DLEAVE51 SPxSolverBase<R>::getLeaveVals() : row " << leaveNum
-                << ": " << leaveStat
-                << " -> " << ds.rowStatus(leaveNum)
-                << " objChange: " << objChange
-                << std::endl;)
-   }
+      break;
+
+    default:
+      throw SPxInternalCodeException("XLEAVE02 This should never happen.");
+    }
+
+    MSG_DEBUG(std::cout << "DLEAVE51 SPxSolverBase<R>::getLeaveVals() : row "
+                        << leaveNum << ": " << leaveStat << " -> "
+                        << ds.rowStatus(leaveNum) << " objChange: " << objChange
+                        << std::endl;)
+  }
+
+  else {
+    assert(leaveId.isSPxColId());
+    leaveNum = this->number(SPxColId(leaveId));
+    leaveStat = ds.colStatus(leaveNum);
+
+    assert(isBasic(leaveStat));
+
+    switch (leaveStat) {
+    case SPxBasisBase<R>::Desc::P_ON_UPPER:
+      assert(rep() == ROW);
+      ds.colStatus(leaveNum) = this->dualColStatus(leaveNum);
+      leavebound = 0;
+      leaveMax = R(-infinity);
+      break;
+
+    case SPxBasisBase<R>::Desc::P_ON_LOWER:
+      assert(rep() == ROW);
+      ds.colStatus(leaveNum) = this->dualColStatus(leaveNum);
+      leavebound = 0;
+      leaveMax = R(infinity);
+      break;
+
+    case SPxBasisBase<R>::Desc::P_FREE:
+      assert(rep() == ROW);
+      ds.colStatus(leaveNum) = this->dualColStatus(leaveNum);
+
+      if ((*theFvec)[leaveIdx] < theLBbound[leaveIdx]) {
+        leavebound = theLBbound[leaveIdx];
+        leaveMax = R(-infinity);
+      } else {
+        leavebound = theUBbound[leaveIdx];
+        leaveMax = R(infinity);
+      }
 
-   else
-   {
-      assert(leaveId.isSPxColId());
-      leaveNum = this->number(SPxColId(leaveId));
-      leaveStat = ds.colStatus(leaveNum);
+      break;
 
-      assert(isBasic(leaveStat));
+    case SPxBasisBase<R>::Desc::D_FREE:
+      assert(rep() == COLUMN);
+      assert(SPxLPBase<R>::upper(leaveNum) == SPxLPBase<R>::lower(leaveNum));
+      ds.colStatus(leaveNum) = SPxBasisBase<R>::Desc::P_FIXED;
+      leavebound = SPxLPBase<R>::upper(leaveNum);
+      objChange += this->maxObj(leaveNum) * leavebound;
 
-      switch(leaveStat)
-      {
-      case SPxBasisBase<R>::Desc::P_ON_UPPER :
-         assert(rep() == ROW);
-         ds.colStatus(leaveNum) = this->dualColStatus(leaveNum);
-         leavebound = 0;
-         leaveMax = R(-infinity);
-         break;
-
-      case SPxBasisBase<R>::Desc::P_ON_LOWER :
-         assert(rep() == ROW);
-         ds.colStatus(leaveNum) = this->dualColStatus(leaveNum);
-         leavebound = 0;
-         leaveMax = R(infinity);
-         break;
-
-      case SPxBasisBase<R>::Desc::P_FREE :
-         assert(rep() == ROW);
-         ds.colStatus(leaveNum) = this->dualColStatus(leaveNum);
-
-         if((*theFvec)[leaveIdx] < theLBbound[leaveIdx])
-         {
-            leavebound = theLBbound[leaveIdx];
-            leaveMax = R(-infinity);
-         }
-         else
-         {
-            leavebound = theUBbound[leaveIdx];
-            leaveMax = R(infinity);
-         }
-
-         break;
-
-      case SPxBasisBase<R>::Desc::D_FREE :
-         assert(rep() == COLUMN);
-         assert(SPxLPBase<R>::upper(leaveNum) == SPxLPBase<R>::lower(leaveNum));
-         ds.colStatus(leaveNum) = SPxBasisBase<R>::Desc::P_FIXED;
-         leavebound = SPxLPBase<R>::upper(leaveNum);
-         objChange += this->maxObj(leaveNum) * leavebound;
-
-         if((*theFvec)[leaveIdx] < theLBbound[leaveIdx])
-            leaveMax = R(infinity);
-         else
-            leaveMax = R(-infinity);
-
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_LOWER :
-         assert(rep() == COLUMN);
-         ds.colStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         leavebound = SPxLPBase<R>::upper(leaveNum);
-         objChange += theUCbound[leaveNum] * leavebound;
-         leaveMax = R(-infinity);
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_UPPER :
-         assert(rep() == COLUMN);
-         ds.colStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-         leavebound = SPxLPBase<R>::lower(leaveNum);
-         objChange += theLCbound[leaveNum] * leavebound;
-         leaveMax = R(infinity);
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_BOTH :
-         assert(rep() == COLUMN);
-
-         if((*theFvec)[leaveIdx] > theUBbound[leaveIdx])
-         {
-            leaveMax = R(-infinity);
-            leavebound = SPxLPBase<R>::upper(leaveNum);
-            objChange += theUCbound[leaveNum] * leavebound;
-            theLCbound[leaveNum] = R(-infinity);
-            ds.colStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         }
-         else
-         {
-            leaveMax = R(infinity);
-            leavebound = SPxLPBase<R>::lower(leaveNum);
-            objChange += theLCbound[leaveNum] * leavebound;
-            theUCbound[leaveNum] = R(infinity);
-            ds.colStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-         }
-
-         break;
-
-      default:
-         throw SPxInternalCodeException("XLEAVE03 This should never happen.");
+      if ((*theFvec)[leaveIdx] < theLBbound[leaveIdx])
+        leaveMax = R(infinity);
+      else
+        leaveMax = R(-infinity);
+
+      break;
+
+    case SPxBasisBase<R>::Desc::D_ON_LOWER:
+      assert(rep() == COLUMN);
+      ds.colStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      leavebound = SPxLPBase<R>::upper(leaveNum);
+      objChange += theUCbound[leaveNum] * leavebound;
+      leaveMax = R(-infinity);
+      break;
+
+    case SPxBasisBase<R>::Desc::D_ON_UPPER:
+      assert(rep() == COLUMN);
+      ds.colStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+      leavebound = SPxLPBase<R>::lower(leaveNum);
+      objChange += theLCbound[leaveNum] * leavebound;
+      leaveMax = R(infinity);
+      break;
+
+    case SPxBasisBase<R>::Desc::D_ON_BOTH:
+      assert(rep() == COLUMN);
+
+      if ((*theFvec)[leaveIdx] > theUBbound[leaveIdx]) {
+        leaveMax = R(-infinity);
+        leavebound = SPxLPBase<R>::upper(leaveNum);
+        objChange += theUCbound[leaveNum] * leavebound;
+        theLCbound[leaveNum] = R(-infinity);
+        ds.colStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      } else {
+        leaveMax = R(infinity);
+        leavebound = SPxLPBase<R>::lower(leaveNum);
+        objChange += theLCbound[leaveNum] * leavebound;
+        theUCbound[leaveNum] = R(infinity);
+        ds.colStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_LOWER;
       }
 
-      MSG_DEBUG(std::cout << "DLEAVE52 SPxSolverBase<R>::getLeaveVals() : col " << leaveNum
-                << ": " << leaveStat
-                << " -> " << ds.colStatus(leaveNum)
-                << " objChange: " << objChange
-                << std::endl;)
-   }
+      break;
+
+    default:
+      throw SPxInternalCodeException("XLEAVE03 This should never happen.");
+    }
+
+    MSG_DEBUG(std::cout << "DLEAVE52 SPxSolverBase<R>::getLeaveVals() : col "
+                        << leaveNum << ": " << leaveStat << " -> "
+                        << ds.colStatus(leaveNum) << " objChange: " << objChange
+                        << std::endl;)
+  }
 }
 
 template <class R>
-void SPxSolverBase<R>::getLeaveVals2(
-   R leaveMax,
-   SPxId enterId,
-   R& enterBound,
-   R& newUBbound,
-   R& newLBbound,
-   R& newCoPrhs,
-   StableSum<R>& objChange
-)
-{
-   typename SPxBasisBase<R>::Desc& ds = this->desc();
-
-   enterBound = 0;
-
-   if(enterId.isSPxRowId())
-   {
-      int idx = this->number(SPxRowId(enterId));
-      typename SPxBasisBase<R>::Desc::Status enterStat = ds.rowStatus(idx);
-
-      // coverity[switch_selector_expr_is_constant]
-      switch(enterStat)
-      {
-      case SPxBasisBase<R>::Desc::D_FREE :
-         assert(rep() == ROW);
-
-         if(thePvec->delta()[idx] * leaveMax < 0)
-            newCoPrhs = theLRbound[idx];
-         else
-            newCoPrhs = theURbound[idx];
-
-         newUBbound = R(infinity);
-         newLBbound = R(-infinity);
-         ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_FIXED;
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_UPPER :
-         assert(rep() == ROW);
-         newUBbound = 0;
-         newLBbound = R(-infinity);
-         ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-         newCoPrhs = theLRbound[idx];
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_LOWER :
-         assert(rep() == ROW);
-         newUBbound = R(infinity);
-         newLBbound = 0;
-         ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         newCoPrhs = theURbound[idx];
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_BOTH :
-         assert(rep() == ROW);
-
-         if(leaveMax * thePvec->delta()[idx] < 0)
-         {
-            newUBbound = 0;
-            newLBbound = R(-infinity);
-            ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-            newCoPrhs = theLRbound[idx];
-         }
-         else
-         {
-            newUBbound = R(infinity);
-            newLBbound = 0;
-            ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-            newCoPrhs = theURbound[idx];
-         }
-
-         break;
-
-      case SPxBasisBase<R>::Desc::P_ON_UPPER :
-         assert(rep() == COLUMN);
-         ds.rowStatus(idx) = this->dualRowStatus(idx);
-
-         if(this->lhs(idx) > R(-infinity))
-            theURbound[idx] = theLRbound[idx];
-
-         newCoPrhs = theLRbound[idx];        // slack !!
-         newUBbound = -this->lhs(idx);
-         newLBbound = -this->rhs(idx);
-         enterBound = -this->rhs(idx);
-         objChange -= newCoPrhs * this->rhs(idx);
-         break;
-
-      case SPxBasisBase<R>::Desc::P_ON_LOWER :
-         assert(rep() == COLUMN);
-         ds.rowStatus(idx) = this->dualRowStatus(idx);
-
-         if(this->rhs(idx) < R(infinity))
-            theLRbound[idx] = theURbound[idx];
-
-         newCoPrhs = theURbound[idx];        // slack !!
-         newLBbound = -this->rhs(idx);
-         newUBbound = -this->lhs(idx);
-         enterBound = -this->lhs(idx);
-         objChange -= newCoPrhs * this->lhs(idx);
-         break;
-
-      case SPxBasisBase<R>::Desc::P_FREE :
-         assert(rep() == COLUMN);
+void SPxSolverBase<R>::getLeaveVals2(R leaveMax, SPxId enterId, R &enterBound,
+                                     R &newUBbound, R &newLBbound, R &newCoPrhs,
+                                     StableSum<R> &objChange) {
+  typename SPxBasisBase<R>::Desc &ds = this->desc();
+
+  enterBound = 0;
+
+  if (enterId.isSPxRowId()) {
+    int idx = this->number(SPxRowId(enterId));
+    typename SPxBasisBase<R>::Desc::Status enterStat = ds.rowStatus(idx);
+
+    // coverity[switch_selector_expr_is_constant]
+    switch (enterStat) {
+    case SPxBasisBase<R>::Desc::D_FREE:
+      assert(rep() == ROW);
+
+      if (thePvec->delta()[idx] * leaveMax < 0)
+        newCoPrhs = theLRbound[idx];
+      else
+        newCoPrhs = theURbound[idx];
+
+      newUBbound = R(infinity);
+      newLBbound = R(-infinity);
+      ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_FIXED;
+      break;
+
+    case SPxBasisBase<R>::Desc::D_ON_UPPER:
+      assert(rep() == ROW);
+      newUBbound = 0;
+      newLBbound = R(-infinity);
+      ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+      newCoPrhs = theLRbound[idx];
+      break;
+
+    case SPxBasisBase<R>::Desc::D_ON_LOWER:
+      assert(rep() == ROW);
+      newUBbound = R(infinity);
+      newLBbound = 0;
+      ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      newCoPrhs = theURbound[idx];
+      break;
+
+    case SPxBasisBase<R>::Desc::D_ON_BOTH:
+      assert(rep() == ROW);
+
+      if (leaveMax * thePvec->delta()[idx] < 0) {
+        newUBbound = 0;
+        newLBbound = R(-infinity);
+        ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+        newCoPrhs = theLRbound[idx];
+      } else {
+        newUBbound = R(infinity);
+        newLBbound = 0;
+        ds.rowStatus(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+        newCoPrhs = theURbound[idx];
+      }
+
+      break;
+
+    case SPxBasisBase<R>::Desc::P_ON_UPPER:
+      assert(rep() == COLUMN);
+      ds.rowStatus(idx) = this->dualRowStatus(idx);
+
+      if (this->lhs(idx) > R(-infinity))
+        theURbound[idx] = theLRbound[idx];
+
+      newCoPrhs = theLRbound[idx]; // slack !!
+      newUBbound = -this->lhs(idx);
+      newLBbound = -this->rhs(idx);
+      enterBound = -this->rhs(idx);
+      objChange -= newCoPrhs * this->rhs(idx);
+      break;
+
+    case SPxBasisBase<R>::Desc::P_ON_LOWER:
+      assert(rep() == COLUMN);
+      ds.rowStatus(idx) = this->dualRowStatus(idx);
+
+      if (this->rhs(idx) < R(infinity))
+        theLRbound[idx] = theURbound[idx];
+
+      newCoPrhs = theURbound[idx]; // slack !!
+      newLBbound = -this->rhs(idx);
+      newUBbound = -this->lhs(idx);
+      enterBound = -this->lhs(idx);
+      objChange -= newCoPrhs * this->lhs(idx);
+      break;
+
+    case SPxBasisBase<R>::Desc::P_FREE:
+      assert(rep() == COLUMN);
 #if 1
-         throw SPxInternalCodeException("XLEAVE04 This should never happen.");
+      throw SPxInternalCodeException("XLEAVE04 This should never happen.");
 #else
-         MSG_ERROR(std::cerr << "ELEAVE53 ERROR: not yet debugged!" << std::endl;)
-         ds.rowStatus(idx) = this->dualRowStatus(idx);
-         newCoPrhs = theURbound[idx];        // slack !!
-         newUBbound = R(infinity);
-         newLBbound = R(-infinity);
-         enterBound = 0;
+      MSG_ERROR(std::cerr << "ELEAVE53 ERROR: not yet debugged!" << std::endl;)
+      ds.rowStatus(idx) = this->dualRowStatus(idx);
+      newCoPrhs = theURbound[idx]; // slack !!
+      newUBbound = R(infinity);
+      newLBbound = R(-infinity);
+      enterBound = 0;
 #endif
-         break;
-
-      case SPxBasisBase<R>::Desc::P_FIXED :
-         assert(rep() == COLUMN);
-         MSG_ERROR(std::cerr << "ELEAVE54 "
-                   << "ERROR! Tried to put a fixed row variable into the basis: "
-                   << "idx="   << idx
-                   << ", lhs=" << this->lhs(idx)
-                   << ", rhs=" << this->rhs(idx) << std::endl;)
-         throw SPxInternalCodeException("XLEAVE05 This should never happen.");
-
-      default:
-         throw SPxInternalCodeException("XLEAVE06 This should never happen.");
+      break;
+
+    case SPxBasisBase<R>::Desc::P_FIXED:
+      assert(rep() == COLUMN);
+      MSG_ERROR(
+          std::cerr
+              << "ELEAVE54 "
+              << "ERROR! Tried to put a fixed row variable into the basis: "
+              << "idx=" << idx << ", lhs=" << this->lhs(idx)
+              << ", rhs=" << this->rhs(idx) << std::endl;)
+      throw SPxInternalCodeException("XLEAVE05 This should never happen.");
+
+    default:
+      throw SPxInternalCodeException("XLEAVE06 This should never happen.");
+    }
+
+    MSG_DEBUG(std::cout << "DLEAVE55 SPxSolverBase<R>::getLeaveVals2(): row "
+                        << idx << ": " << enterStat << " -> "
+                        << ds.rowStatus(idx) << " objChange: " << objChange
+                        << std::endl;)
+  }
+
+  else {
+    assert(enterId.isSPxColId());
+    int idx = this->number(SPxColId(enterId));
+    typename SPxBasisBase<R>::Desc::Status enterStat = ds.colStatus(idx);
+
+    // coverity[switch_selector_expr_is_constant]
+    switch (enterStat) {
+    case SPxBasisBase<R>::Desc::D_ON_UPPER:
+      assert(rep() == ROW);
+      newUBbound = 0;
+      newLBbound = R(-infinity);
+      ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+      newCoPrhs = theLCbound[idx];
+      break;
+
+    case SPxBasisBase<R>::Desc::D_ON_LOWER:
+      assert(rep() == ROW);
+      newUBbound = R(infinity);
+      newLBbound = 0;
+      ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      newCoPrhs = theUCbound[idx];
+      break;
+
+    case SPxBasisBase<R>::Desc::D_FREE:
+      assert(rep() == ROW);
+      newUBbound = R(infinity);
+      newLBbound = R(-infinity);
+      newCoPrhs = theLCbound[idx];
+      ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_FIXED;
+      break;
+
+    case SPxBasisBase<R>::Desc::D_ON_BOTH:
+      assert(rep() == ROW);
+
+      if (leaveMax * theCoPvec->delta()[idx] < 0) {
+        newUBbound = 0;
+        newLBbound = R(-infinity);
+        ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+        newCoPrhs = theLCbound[idx];
+      } else {
+        newUBbound = R(infinity);
+        newLBbound = 0;
+        ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+        newCoPrhs = theUCbound[idx];
       }
 
-      MSG_DEBUG(std::cout << "DLEAVE55 SPxSolverBase<R>::getLeaveVals2(): row " << idx
-                << ": " << enterStat
-                << " -> " << ds.rowStatus(idx)
-                << " objChange: " << objChange
-                << std::endl;)
-   }
-
-   else
-   {
-      assert(enterId.isSPxColId());
-      int idx = this->number(SPxColId(enterId));
-      typename SPxBasisBase<R>::Desc::Status enterStat = ds.colStatus(idx);
-
-      // coverity[switch_selector_expr_is_constant]
-      switch(enterStat)
-      {
-      case SPxBasisBase<R>::Desc::D_ON_UPPER :
-         assert(rep() == ROW);
-         newUBbound = 0;
-         newLBbound = R(-infinity);
-         ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-         newCoPrhs = theLCbound[idx];
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_LOWER :
-         assert(rep() == ROW);
-         newUBbound = R(infinity);
-         newLBbound = 0;
-         ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         newCoPrhs = theUCbound[idx];
-         break;
-
-      case SPxBasisBase<R>::Desc::D_FREE :
-         assert(rep() == ROW);
-         newUBbound = R(infinity);
-         newLBbound = R(-infinity);
-         newCoPrhs = theLCbound[idx];
-         ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_FIXED;
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_BOTH :
-         assert(rep() == ROW);
-
-         if(leaveMax * theCoPvec->delta()[idx] < 0)
-         {
-            newUBbound = 0;
-            newLBbound = R(-infinity);
-            ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-            newCoPrhs = theLCbound[idx];
-         }
-         else
-         {
-            newUBbound = R(infinity);
-            newLBbound = 0;
-            ds.colStatus(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-            newCoPrhs = theUCbound[idx];
-         }
-
-         break;
-
-      case SPxBasisBase<R>::Desc::P_ON_UPPER :
-         assert(rep() == COLUMN);
-         ds.colStatus(idx) = this->dualColStatus(idx);
-
-         if(SPxLPBase<R>::lower(idx) > R(-infinity))
-            theLCbound[idx] = theUCbound[idx];
-
-         newCoPrhs = theUCbound[idx];
-         newUBbound = SPxLPBase<R>::upper(idx);
-         newLBbound = SPxLPBase<R>::lower(idx);
-         enterBound = SPxLPBase<R>::upper(idx);
-         objChange -= newCoPrhs * enterBound;
-         break;
-
-      case SPxBasisBase<R>::Desc::P_ON_LOWER :
-         assert(rep() == COLUMN);
-         ds.colStatus(idx) = this->dualColStatus(idx);
-
-         if(SPxLPBase<R>::upper(idx) < R(infinity))
-            theUCbound[idx] = theLCbound[idx];
-
-         newCoPrhs = theLCbound[idx];
-         newUBbound = SPxLPBase<R>::upper(idx);
-         newLBbound = SPxLPBase<R>::lower(idx);
-         enterBound = SPxLPBase<R>::lower(idx);
-         objChange -= newCoPrhs * enterBound;
-         break;
-
-      case SPxBasisBase<R>::Desc::P_FREE :
-         assert(rep() == COLUMN);
-         ds.colStatus(idx) = this->dualColStatus(idx);
-
-         if(thePvec->delta()[idx] * leaveMax > 0)
-            newCoPrhs = theUCbound[idx];
-         else
-            newCoPrhs = theLCbound[idx];
-
-         newUBbound = SPxLPBase<R>::upper(idx);
-         newLBbound = SPxLPBase<R>::lower(idx);
-         enterBound = 0;
-         break;
-
-      case SPxBasisBase<R>::Desc::P_FIXED :
-         assert(rep() == COLUMN);
-         MSG_ERROR(std::cerr << "ELEAVE56 "
-                   << "ERROR! Tried to put a fixed column variable into the basis. "
-                   << "idx="     << idx
-                   << ", lower=" << this->lower(idx)
-                   << ", upper=" << this->upper(idx) << std::endl;)
-         throw SPxInternalCodeException("XLEAVE07 This should never happen.");
-
-      default:
-         throw SPxInternalCodeException("XLEAVE08 This should never happen.");
-      }
+      break;
 
-      MSG_DEBUG(std::cout << "DLEAVE57 SPxSolverBase<R>::getLeaveVals2(): col " << idx
-                << ": " << enterStat
-                << " -> " << ds.colStatus(idx)
-                << " objChange: " << objChange
-                << std::endl;)
-   }
+    case SPxBasisBase<R>::Desc::P_ON_UPPER:
+      assert(rep() == COLUMN);
+      ds.colStatus(idx) = this->dualColStatus(idx);
 
-}
+      if (SPxLPBase<R>::lower(idx) > R(-infinity))
+        theLCbound[idx] = theUCbound[idx];
 
-template <class R>
-void SPxSolverBase<R>::rejectLeave(
-   int leaveNum,
-   SPxId leaveId,
-   typename SPxBasisBase<R>::Desc::Status leaveStat,
-   const SVectorBase<R>* //newVec
-)
-{
-   typename SPxBasisBase<R>::Desc& ds = this->desc();
-
-   if(leaveId.isSPxRowId())
-   {
-      MSG_DEBUG(std::cout << "DLEAVE58 rejectLeave()  : row " << leaveNum
-                << ": " << ds.rowStatus(leaveNum)
-                << " -> " << leaveStat << std::endl;)
-
-      if(leaveStat == SPxBasisBase<R>::Desc::D_ON_BOTH)
-      {
-         if(ds.rowStatus(leaveNum) == SPxBasisBase<R>::Desc::P_ON_LOWER)
-            theLRbound[leaveNum] = theURbound[leaveNum];
-         else
-            theURbound[leaveNum] = theLRbound[leaveNum];
-      }
+      newCoPrhs = theUCbound[idx];
+      newUBbound = SPxLPBase<R>::upper(idx);
+      newLBbound = SPxLPBase<R>::lower(idx);
+      enterBound = SPxLPBase<R>::upper(idx);
+      objChange -= newCoPrhs * enterBound;
+      break;
 
-      ds.rowStatus(leaveNum) = leaveStat;
-   }
-   else
-   {
-      MSG_DEBUG(std::cout << "DLEAVE59 rejectLeave()  : col " << leaveNum
-                << ": " << ds.colStatus(leaveNum)
-                << " -> " << leaveStat << std::endl;)
+    case SPxBasisBase<R>::Desc::P_ON_LOWER:
+      assert(rep() == COLUMN);
+      ds.colStatus(idx) = this->dualColStatus(idx);
 
-      if(leaveStat == SPxBasisBase<R>::Desc::D_ON_BOTH)
-      {
-         if(ds.colStatus(leaveNum) == SPxBasisBase<R>::Desc::P_ON_UPPER)
-            theLCbound[leaveNum] = theUCbound[leaveNum];
-         else
-            theUCbound[leaveNum] = theLCbound[leaveNum];
-      }
+      if (SPxLPBase<R>::upper(idx) < R(infinity))
+        theUCbound[idx] = theLCbound[idx];
 
-      ds.colStatus(leaveNum) = leaveStat;
-   }
-}
+      newCoPrhs = theLCbound[idx];
+      newUBbound = SPxLPBase<R>::upper(idx);
+      newLBbound = SPxLPBase<R>::lower(idx);
+      enterBound = SPxLPBase<R>::lower(idx);
+      objChange -= newCoPrhs * enterBound;
+      break;
 
+    case SPxBasisBase<R>::Desc::P_FREE:
+      assert(rep() == COLUMN);
+      ds.colStatus(idx) = this->dualColStatus(idx);
 
-template <class R>
-void SPxSolverBase<R>::computePrimalray4Row(R direction)
-{
-   R sign = (direction > 0 ? 1.0 : -1.0);
+      if (thePvec->delta()[idx] * leaveMax > 0)
+        newCoPrhs = theUCbound[idx];
+      else
+        newCoPrhs = theLCbound[idx];
+
+      newUBbound = SPxLPBase<R>::upper(idx);
+      newLBbound = SPxLPBase<R>::lower(idx);
+      enterBound = 0;
+      break;
+
+    case SPxBasisBase<R>::Desc::P_FIXED:
+      assert(rep() == COLUMN);
+      MSG_ERROR(
+          std::cerr
+              << "ELEAVE56 "
+              << "ERROR! Tried to put a fixed column variable into the basis. "
+              << "idx=" << idx << ", lower=" << this->lower(idx)
+              << ", upper=" << this->upper(idx) << std::endl;)
+      throw SPxInternalCodeException("XLEAVE07 This should never happen.");
+
+    default:
+      throw SPxInternalCodeException("XLEAVE08 This should never happen.");
+    }
+
+    MSG_DEBUG(std::cout << "DLEAVE57 SPxSolverBase<R>::getLeaveVals2(): col "
+                        << idx << ": " << enterStat << " -> "
+                        << ds.colStatus(idx) << " objChange: " << objChange
+                        << std::endl;)
+  }
+}
 
-   primalRay.clear();
-   primalRay.setMax(coPvec().delta().size());
+template <class R>
+void SPxSolverBase<R>::rejectLeave(
+    int leaveNum, SPxId leaveId,
+    typename SPxBasisBase<R>::Desc::Status leaveStat,
+    const SVectorBase<R> * // newVec
+) {
+  typename SPxBasisBase<R>::Desc &ds = this->desc();
+
+  if (leaveId.isSPxRowId()) {
+    MSG_DEBUG(std::cout << "DLEAVE58 rejectLeave()  : row " << leaveNum << ": "
+                        << ds.rowStatus(leaveNum) << " -> " << leaveStat
+                        << std::endl;)
+
+    if (leaveStat == SPxBasisBase<R>::Desc::D_ON_BOTH) {
+      if (ds.rowStatus(leaveNum) == SPxBasisBase<R>::Desc::P_ON_LOWER)
+        theLRbound[leaveNum] = theURbound[leaveNum];
+      else
+        theURbound[leaveNum] = theLRbound[leaveNum];
+    }
+
+    ds.rowStatus(leaveNum) = leaveStat;
+  } else {
+    MSG_DEBUG(std::cout << "DLEAVE59 rejectLeave()  : col " << leaveNum << ": "
+                        << ds.colStatus(leaveNum) << " -> " << leaveStat
+                        << std::endl;)
+
+    if (leaveStat == SPxBasisBase<R>::Desc::D_ON_BOTH) {
+      if (ds.colStatus(leaveNum) == SPxBasisBase<R>::Desc::P_ON_UPPER)
+        theLCbound[leaveNum] = theUCbound[leaveNum];
+      else
+        theUCbound[leaveNum] = theLCbound[leaveNum];
+    }
 
-   for(int i = 0; i < coPvec().delta().size(); ++i)
-      primalRay.add(coPvec().delta().index(i), sign * coPvec().delta().value(i));
+    ds.colStatus(leaveNum) = leaveStat;
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::computeDualfarkas4Col(R direction)
-{
-   R sign = (direction > 0 ? -1.0 : 1.0);
+template <class R> void SPxSolverBase<R>::computePrimalray4Row(R direction) {
+  R sign = (direction > 0 ? 1.0 : -1.0);
 
-   dualFarkas.clear();
-   dualFarkas.setMax(coPvec().delta().size());
+  primalRay.clear();
+  primalRay.setMax(coPvec().delta().size());
 
-   for(int i = 0; i < coPvec().delta().size(); ++i)
-      dualFarkas.add(coPvec().delta().index(i), sign * coPvec().delta().value(i));
+  for (int i = 0; i < coPvec().delta().size(); ++i)
+    primalRay.add(coPvec().delta().index(i), sign * coPvec().delta().value(i));
 }
 
-template <class R>
-bool SPxSolverBase<R>::leave(int leaveIdx, bool polish)
-{
-   assert(leaveIdx < dim() && leaveIdx >= 0);
-   assert(type() == LEAVE);
-   assert(initialized);
-
-   bool instable = instableLeave;
-   assert(!instable || instableLeaveNum >= 0);
-
-   /*
-     Before performing the actual basis update, we must determine, how this
-     is to be accomplished.
-     When using steepest edge pricing this solve is already performed by the pricer
-   */
-   if(theCoPvec->delta().isSetup() && theCoPvec->delta().size() == 0)
-   {
-      this->coSolve(theCoPvec->delta(), unitVecs[leaveIdx]);
-   }
+template <class R> void SPxSolverBase<R>::computeDualfarkas4Col(R direction) {
+  R sign = (direction > 0 ? -1.0 : 1.0);
 
-#ifdef ENABLE_ADDITIONAL_CHECKS
-   else
-   {
-      SSVectorBase<R>  tmp(dim(), epsilon());
-      tmp.clear();
-      this->coSolve(tmp, unitVecs[leaveIdx]);
-      tmp -= theCoPvec->delta();
-
-      if(tmp.length() > leavetol())
-      {
-         // This happens very frequently and does usually not hurt, so print
-         // these warnings only with verbose level INFO2 and higher.
-         MSG_INFO2((*this->spxout), (*this->spxout) << "WLEAVE60 iteration=" << basis().iteration()
-                   << ": coPvec.delta error = " << tmp.length()
-                   << std::endl;)
-      }
-   }
+  dualFarkas.clear();
+  dualFarkas.setMax(coPvec().delta().size());
 
-#endif  // ENABLE_ADDITIONAL_CHECKS
+  for (int i = 0; i < coPvec().delta().size(); ++i)
+    dualFarkas.add(coPvec().delta().index(i), sign * coPvec().delta().value(i));
+}
 
-   setupPupdate();
+template <class R> bool SPxSolverBase<R>::leave(int leaveIdx, bool polish) {
+  assert(leaveIdx < dim() && leaveIdx >= 0);
+  assert(type() == LEAVE);
+  assert(initialized);
 
-   assert(thePvec->isConsistent());
-   assert(theCoPvec->isConsistent());
+  bool instable = instableLeave;
+  assert(!instable || instableLeaveNum >= 0);
 
-   typename SPxBasisBase<R>::Desc::Status leaveStat;      // status of leaving var
-   SPxId leaveId;        // id of leaving var
-   SPxId none;           // invalid id used if leave fails
-   R leaveMax;       // maximium lambda of leaving var
-   R leavebound;     // current fVec value of leaving var
-   int  leaveNum;       // number of leaveId in bounds
-   StableSum<R> objChange; // amount of change in the objective function
+  /*
+    Before performing the actual basis update, we must determine, how this
+    is to be accomplished.
+    When using steepest edge pricing this solve is already performed by the
+    pricer
+  */
+  if (theCoPvec->delta().isSetup() && theCoPvec->delta().size() == 0) {
+    this->coSolve(theCoPvec->delta(), unitVecs[leaveIdx]);
+  }
 
-   getLeaveVals(leaveIdx, leaveStat, leaveId, leaveMax, leavebound, leaveNum, objChange);
+#ifdef ENABLE_ADDITIONAL_CHECKS
+  else {
+    SSVectorBase<R> tmp(dim(), epsilon());
+    tmp.clear();
+    this->coSolve(tmp, unitVecs[leaveIdx]);
+    tmp -= theCoPvec->delta();
+
+    if (tmp.length() > leavetol()) {
+      // This happens very frequently and does usually not hurt, so print
+      // these warnings only with verbose level INFO2 and higher.
+      MSG_INFO2((*this->spxout),
+                (*this->spxout)
+                    << "WLEAVE60 iteration=" << basis().iteration()
+                    << ": coPvec.delta error = " << tmp.length() << std::endl;)
+    }
+  }
+
+#endif // ENABLE_ADDITIONAL_CHECKS
+
+  setupPupdate();
+
+  assert(thePvec->isConsistent());
+  assert(theCoPvec->isConsistent());
+
+  typename SPxBasisBase<R>::Desc::Status leaveStat; // status of leaving var
+  SPxId leaveId;                                    // id of leaving var
+  SPxId none;             // invalid id used if leave fails
+  R leaveMax;             // maximium lambda of leaving var
+  R leavebound;           // current fVec value of leaving var
+  int leaveNum;           // number of leaveId in bounds
+  StableSum<R> objChange; // amount of change in the objective function
+
+  getLeaveVals(leaveIdx, leaveStat, leaveId, leaveMax, leavebound, leaveNum,
+               objChange);
+
+  if (!polish && m_numCycle > m_maxCycle) {
+    if (leaveMax > 0)
+      perturbMaxLeave();
+    else
+      perturbMinLeave();
+
+    //@ m_numCycle /= 2;
+    // perturbation invalidates the currently stored nonbasic value
+    forceRecompNonbasicValue();
+  }
+
+  //@ testBounds();
+
+  R enterVal = leaveMax;
+  boundflips = 0;
+  R oldShift = theShift;
+  SPxId enterId = theratiotester->selectEnter(enterVal, leaveIdx, polish);
+
+  if (NE(theShift, oldShift)) {
+    MSG_DEBUG(std::cout << "DLEAVE71 trigger recomputation of nonbasic value "
+                           "due to shifts in ratiotest"
+                        << std::endl;)
+    forceRecompNonbasicValue();
+  }
+
+  assert(!enterId.isValid() || !isBasic(enterId));
+
+  instableLeaveNum = -1;
+  instableLeave = false;
+
+  /*
+    No variable could be selected to enter the basis and even the leaving
+    variable is unbounded.
+  */
+  if (!enterId.isValid()) {
+    /* the following line originally was below in "rejecting leave" case;
+       we need it in the unbounded/infeasible case, too, to have the
+       correct basis size */
+    rejectLeave(leaveNum, leaveId, leaveStat);
+    this->change(-1, none, 0);
+    objChange =
+        R(0.0); // the nonbasicValue is not supposed to be updated in this case
+
+    if (polish)
+      return false;
 
-   if(!polish && m_numCycle > m_maxCycle)
-   {
-      if(leaveMax > 0)
-         perturbMaxLeave();
-      else
-         perturbMinLeave();
-
-      //@ m_numCycle /= 2;
-      // perturbation invalidates the currently stored nonbasic value
-      forceRecompNonbasicValue();
-   }
-
-   //@ testBounds();
-
-   R enterVal = leaveMax;
-   boundflips = 0;
-   R oldShift = theShift;
-   SPxId enterId = theratiotester->selectEnter(enterVal, leaveIdx, polish);
-
-   if(NE(theShift, oldShift))
-   {
-      MSG_DEBUG(std::cout << "DLEAVE71 trigger recomputation of nonbasic value due to shifts in ratiotest"
-                << std::endl;)
-      forceRecompNonbasicValue();
-   }
-
-   assert(!enterId.isValid() || !isBasic(enterId));
-
-   instableLeaveNum = -1;
-   instableLeave = false;
-
-   /*
-     No variable could be selected to enter the basis and even the leaving
-     variable is unbounded.
-   */
-   if(!enterId.isValid())
-   {
-      /* the following line originally was below in "rejecting leave" case;
-         we need it in the unbounded/infeasible case, too, to have the
-         correct basis size */
-      rejectLeave(leaveNum, leaveId, leaveStat);
-      this->change(-1, none, 0);
-      objChange = R(0.0); // the nonbasicValue is not supposed to be updated in this case
-
-      if(polish)
-         return false;
-
-      if(NE(enterVal, leaveMax))
-      {
-         MSG_DEBUG(std::cout << "DLEAVE61 rejecting leave A (leaveIdx=" << leaveIdx
-                   << ", theCoTest=" << theCoTest[leaveIdx] << ")"
-                   << std::endl;)
-
-         /* In the LEAVE algorithm, when for a selected leaving variable we find only
-            an instable entering variable, then the basis change is not conducted.
-            Instead, we save the leaving variable's index in instableLeaveNum and scale
-            theCoTest[leaveIdx] down by some factor, hoping to find a different leaving
-            variable with a stable entering variable.
-            If this fails, however, and no more leaving variable is found, we have to
-            perform the instable basis change using instableLeaveNum. In this (and only
-            in this) case, the flag instableLeave is set to true.
-
-            enterVal != leaveMax is the case that selectEnter has found only an instable entering
-            variable. We store this leaving variable for later -- if we are not already in the
-            instable case: then we continue and conclude unboundedness/infeasibility */
-         if(!instable)
-         {
-            instableLeaveNum = leaveIdx;
-
-            // Note: These changes do not survive a refactorization
-            instableLeaveVal = theCoTest[leaveIdx];
-            theCoTest[leaveIdx] = instableLeaveVal / 10.0;
-
-            return true;
-         }
+    if (NE(enterVal, leaveMax)) {
+      MSG_DEBUG(std::cout << "DLEAVE61 rejecting leave A (leaveIdx=" << leaveIdx
+                          << ", theCoTest=" << theCoTest[leaveIdx] << ")"
+                          << std::endl;)
+
+      /* In the LEAVE algorithm, when for a selected leaving variable we find
+         only an instable entering variable, then the basis change is not
+         conducted. Instead, we save the leaving variable's index in
+         instableLeaveNum and scale theCoTest[leaveIdx] down by some factor,
+         hoping to find a different leaving variable with a stable entering
+         variable. If this fails, however, and no more leaving variable is
+         found, we have to perform the instable basis change using
+         instableLeaveNum. In this (and only in this) case, the flag
+         instableLeave is set to true.
+
+         enterVal != leaveMax is the case that selectEnter has found only an
+         instable entering variable. We store this leaving variable for later --
+         if we are not already in the instable case: then we continue and
+         conclude unboundedness/infeasibility */
+      if (!instable) {
+        instableLeaveNum = leaveIdx;
+
+        // Note: These changes do not survive a refactorization
+        instableLeaveVal = theCoTest[leaveIdx];
+        theCoTest[leaveIdx] = instableLeaveVal / 10.0;
+
+        return true;
       }
-
-      if(this->lastUpdate() > 1)
-      {
-         MSG_INFO3((*this->spxout), (*this->spxout) << "ILEAVE01 factorization triggered in "
-                   << "leave() for feasibility test" << std::endl;)
-
-         try
-         {
-            factorize();
-         }
-         catch(const SPxStatusException& E)
-         {
-            // don't exit immediately but handle the singularity correctly
-            assert(SPxBasisBase<R>::status() == SPxBasisBase<R>::SINGULAR);
-            MSG_INFO3((*this->spxout), (*this->spxout) << "Caught exception in factorization: " << E.what() <<
-                      std::endl;)
-         }
-
-         /* after a factorization, the leaving column/row might not be infeasible or suboptimal anymore, hence we do
-          * not try to call leave(leaveIdx), but rather return to the main solving loop and call the pricer again
-          */
-         return true;
+    }
+
+    if (this->lastUpdate() > 1) {
+      MSG_INFO3((*this->spxout),
+                (*this->spxout) << "ILEAVE01 factorization triggered in "
+                                << "leave() for feasibility test" << std::endl;)
+
+      try {
+        factorize();
+      } catch (const SPxStatusException &E) {
+        // don't exit immediately but handle the singularity correctly
+        assert(SPxBasisBase<R>::status() == SPxBasisBase<R>::SINGULAR);
+        MSG_INFO3((*this->spxout), (*this->spxout)
+                                       << "Caught exception in factorization: "
+                                       << E.what() << std::endl;)
       }
 
-      /* do not exit with status infeasible or unbounded if there is only a very small violation */
-      if(!recomputedVectors && spxAbs(enterVal) < leavetol())
-      {
-         MSG_INFO3((*this->spxout), (*this->spxout) << "ILEAVE11 clean up step to reduce numerical errors" <<
-                   std::endl;)
+      /* after a factorization, the leaving column/row might not be infeasible
+       * or suboptimal anymore, hence we do not try to call leave(leaveIdx), but
+       * rather return to the main solving loop and call the pricer again
+       */
+      return true;
+    }
 
-         computeFrhs();
-         SPxBasisBase<R>::solve(*theFvec, *theFrhs);
-         computeFtest();
+    /* do not exit with status infeasible or unbounded if there is only a very
+     * small violation */
+    if (!recomputedVectors && spxAbs(enterVal) < leavetol()) {
+      MSG_INFO3((*this->spxout),
+                (*this->spxout)
+                    << "ILEAVE11 clean up step to reduce numerical errors"
+                    << std::endl;)
 
-         /* only do this once per solve */
-         recomputedVectors = true;
+      computeFrhs();
+      SPxBasisBase<R>::solve(*theFvec, *theFrhs);
+      computeFtest();
 
-         return true;
-      }
+      /* only do this once per solve */
+      recomputedVectors = true;
 
-      MSG_INFO3((*this->spxout), (*this->spxout) << "ILEAVE02 unboundedness/infeasibility found "
-                << "in leave()" << std::endl;)
+      return true;
+    }
+
+    MSG_INFO3((*this->spxout),
+              (*this->spxout) << "ILEAVE02 unboundedness/infeasibility found "
+                              << "in leave()" << std::endl;)
+
+    if (rep() != COLUMN) {
+      computePrimalray4Row(enterVal);
+      setBasisStatus(SPxBasisBase<R>::UNBOUNDED);
+    } else {
+      computeDualfarkas4Col(enterVal);
+      setBasisStatus(SPxBasisBase<R>::INFEASIBLE);
+    }
+
+    return false;
+  } else {
+    /*
+      If an entering variable has been found, a regular basis update is to
+      be performed.
+    */
+    if (enterId != this->baseId((leaveIdx))) {
+      const SVectorBase<R> &newVector = *enterVector(enterId);
+
+      // update feasibility vectors
+      if (solveVector2 != NULL && solveVector3 != NULL) {
+        assert(solveVector2->isConsistent());
+        assert(solveVector2rhs->isSetup());
+        assert(solveVector3->isConsistent());
+        assert(solveVector3rhs->isSetup());
+        assert(boundflips > 0);
+        SPxBasisBase<R>::solve4update(theFvec->delta(), *solveVector2,
+                                      *solveVector3, newVector,
+                                      *solveVector2rhs, *solveVector3rhs);
+
+        // perform update of basic solution
+        primVec -= (*solveVector3);
+        MSG_DEBUG(std::cout << "ILBFRT02 breakpoints passed / bounds flipped = "
+                            << boundflips << std::endl;)
+        totalboundflips += boundflips;
+      } else if (solveVector2 != NULL) {
+        assert(solveVector2->isConsistent());
+        assert(solveVector2rhs->isSetup());
+
+        SPxBasisBase<R>::solve4update(theFvec->delta(), *solveVector2,
+                                      newVector, *solveVector2rhs);
+      } else if (solveVector3 != NULL) {
+        assert(solveVector3->isConsistent());
+        assert(solveVector3rhs->isSetup());
+        assert(boundflips > 0);
+        SPxBasisBase<R>::solve4update(theFvec->delta(), *solveVector3,
+                                      newVector, *solveVector3rhs);
+
+        // perform update of basic solution
+        primVec -= (*solveVector3);
+        MSG_DEBUG(std::cout << "ILBFRT02 breakpoints passed / bounds flipped = "
+                            << boundflips << std::endl;)
+        totalboundflips += boundflips;
+      } else
+        SPxBasisBase<R>::solve4update(theFvec->delta(), newVector);
 
-      if(rep() != COLUMN)
+#ifdef ENABLE_ADDITIONAL_CHECKS
       {
-         computePrimalray4Row(enterVal);
-         setBasisStatus(SPxBasisBase<R>::UNBOUNDED);
+        SSVectorBase<R> tmp(dim(), epsilon());
+        SPxBasisBase<R>::solve(tmp, newVector);
+        tmp -= fVec().delta();
+
+        if (tmp.length() > entertol()) {
+          // This happens very frequently and does usually not hurt, so print
+          // these warnings only with verbose level INFO2 and higher.
+          MSG_INFO2((*this->spxout),
+                    (*this->spxout) << "WLEAVE62\t(" << tmp.length() << ")\n";)
+        }
       }
-      else
-      {
-         computeDualfarkas4Col(enterVal);
-         setBasisStatus(SPxBasisBase<R>::INFEASIBLE);
+#endif // ENABLE_ADDITIONAL_CHECKS
+
+      if (spxAbs(theFvec->delta()[leaveIdx]) < reject_leave_tol) {
+        if (instable) {
+          /* We are in the case that for all leaving variables only instable
+             entering variables were found: Thus, above we already accepted such
+             an instable entering variable. Now even this seems to be
+             impossible, thus we conclude unboundedness/infeasibility. */
+          MSG_INFO3((*this->spxout),
+                    (*this->spxout)
+                        << "ILEAVE03 unboundedness/infeasibility found "
+                        << "in leave()" << std::endl;)
+
+          rejectLeave(leaveNum, leaveId, leaveStat);
+          this->change(-1, none, 0);
+          objChange = R(0.0); // the nonbasicValue is not supposed to be updated
+                              // in this case
+
+          /**@todo if shift() is not zero we must not conclude unboundedness */
+          if (rep() == ROW) {
+            computePrimalray4Row(enterVal);
+            setBasisStatus(SPxBasisBase<R>::UNBOUNDED);
+          } else {
+            computeDualfarkas4Col(enterVal);
+            setBasisStatus(SPxBasisBase<R>::INFEASIBLE);
+          }
+
+          return false;
+        } else {
+          theFvec->delta().clear();
+          rejectLeave(leaveNum, leaveId, leaveStat, &newVector);
+          this->change(-1, none, 0);
+          objChange = R(0.0); // the nonbasicValue is not supposed to be updated
+                              // in this case
+
+          MSG_DEBUG(std::cout
+                        << "DLEAVE63 rejecting leave B (leaveIdx=" << leaveIdx
+                        << ", theCoTest=" << theCoTest[leaveIdx] << ")"
+                        << std::endl;)
+
+          // Note: These changes do not survive a refactorization
+          theCoTest[leaveIdx] *= 0.01;
+
+          return true;
+        }
       }
 
-      return false;
-   }
-   else
-   {
-      /*
-        If an entering variable has been found, a regular basis update is to
-        be performed.
-      */
-      if(enterId != this->baseId((leaveIdx)))
-      {
-         const SVectorBase<R>& newVector = *enterVector(enterId);
-
-         // update feasibility vectors
-         if(solveVector2 != NULL && solveVector3 != NULL)
-         {
-            assert(solveVector2->isConsistent());
-            assert(solveVector2rhs->isSetup());
-            assert(solveVector3->isConsistent());
-            assert(solveVector3rhs->isSetup());
-            assert(boundflips > 0);
-            SPxBasisBase<R>::solve4update(theFvec->delta(),
-                                          *solveVector2,
-                                          *solveVector3,
-                                          newVector,
-                                          *solveVector2rhs,
-                                          *solveVector3rhs);
-
-            // perform update of basic solution
-            primVec -= (*solveVector3);
-            MSG_DEBUG(std::cout << "ILBFRT02 breakpoints passed / bounds flipped = " << boundflips << std::endl;
-                     )
-            totalboundflips += boundflips;
-         }
-         else if(solveVector2 != NULL)
-         {
-            assert(solveVector2->isConsistent());
-            assert(solveVector2rhs->isSetup());
-
-            SPxBasisBase<R>::solve4update(theFvec->delta(),
-                                          *solveVector2,
-                                          newVector,
-                                          *solveVector2rhs);
-         }
-         else if(solveVector3 != NULL)
-         {
-            assert(solveVector3->isConsistent());
-            assert(solveVector3rhs->isSetup());
-            assert(boundflips > 0);
-            SPxBasisBase<R>::solve4update(theFvec->delta(),
-                                          *solveVector3,
-                                          newVector,
-                                          *solveVector3rhs);
-
-            // perform update of basic solution
-            primVec -= (*solveVector3);
-            MSG_DEBUG(std::cout << "ILBFRT02 breakpoints passed / bounds flipped = " << boundflips << std::endl;
-                     )
-            totalboundflips += boundflips;
-         }
-         else
-            SPxBasisBase<R>::solve4update(theFvec->delta(), newVector);
-
-#ifdef ENABLE_ADDITIONAL_CHECKS
-         {
-            SSVectorBase<R>  tmp(dim(), epsilon());
-            SPxBasisBase<R>::solve(tmp, newVector);
-            tmp -= fVec().delta();
-
-            if(tmp.length() > entertol())
-            {
-               // This happens very frequently and does usually not hurt, so print
-               // these warnings only with verbose level INFO2 and higher.
-               MSG_INFO2((*this->spxout), (*this->spxout) << "WLEAVE62\t(" << tmp.length() << ")\n";)
-            }
-         }
-#endif  // ENABLE_ADDITIONAL_CHECKS
-
-
-         if(spxAbs(theFvec->delta()[leaveIdx]) < reject_leave_tol)
-         {
-            if(instable)
-            {
-               /* We are in the case that for all leaving variables only instable entering
-                  variables were found: Thus, above we already accepted such an instable
-                  entering variable. Now even this seems to be impossible, thus we conclude
-                  unboundedness/infeasibility. */
-               MSG_INFO3((*this->spxout), (*this->spxout) << "ILEAVE03 unboundedness/infeasibility found "
-                         << "in leave()" << std::endl;)
-
-               rejectLeave(leaveNum, leaveId, leaveStat);
-               this->change(-1, none, 0);
-               objChange = R(0.0); // the nonbasicValue is not supposed to be updated in this case
-
-               /**@todo if shift() is not zero we must not conclude unboundedness */
-               if(rep() == ROW)
-               {
-                  computePrimalray4Row(enterVal);
-                  setBasisStatus(SPxBasisBase<R>::UNBOUNDED);
-               }
-               else
-               {
-                  computeDualfarkas4Col(enterVal);
-                  setBasisStatus(SPxBasisBase<R>::INFEASIBLE);
-               }
-
-               return false;
-            }
-            else
-            {
-               theFvec->delta().clear();
-               rejectLeave(leaveNum, leaveId, leaveStat, &newVector);
-               this->change(-1, none, 0);
-               objChange = R(0.0); // the nonbasicValue is not supposed to be updated in this case
-
-               MSG_DEBUG(std::cout << "DLEAVE63 rejecting leave B (leaveIdx=" << leaveIdx
-                         << ", theCoTest=" << theCoTest[leaveIdx]
-                         << ")" << std::endl;)
-
-               // Note: These changes do not survive a refactorization
-               theCoTest[leaveIdx] *= 0.01;
-
-               return true;
-            }
-         }
-
-         //      process leaving variable
-         if(leavebound > epsilon() || leavebound < -epsilon())
-            theFrhs->multAdd(-leavebound, this->baseVec(leaveIdx));
-
-         //      process entering variable
-         R enterBound;
-         R newUBbound;
-         R newLBbound;
-         R newCoPrhs;
-
-         try
-         {
-            getLeaveVals2(leaveMax, enterId, enterBound, newUBbound, newLBbound, newCoPrhs, objChange);
-         }
-         catch(const SPxException& F)
-         {
-            rejectLeave(leaveNum, leaveId, leaveStat);
-            this->change(-1, none, 0);
-            objChange = R(0.0); // the nonbasicValue is not supposed to be updated in this case
-            throw F;
-         }
-
-         theUBbound[leaveIdx] = newUBbound;
-         theLBbound[leaveIdx] = newLBbound;
-         (*theCoPrhs)[leaveIdx] = newCoPrhs;
-
-         if(enterBound > epsilon() || enterBound < -epsilon())
-            theFrhs->multAdd(enterBound, newVector);
-
-         // update pricing vectors
-         theCoPvec->value() = enterVal;
-         thePvec->value() = enterVal;
-
-         if(enterVal > epsilon() || enterVal < -epsilon())
-            doPupdate();
-
-         // update feasibility vector
-         theFvec->value() = -((*theFvec)[leaveIdx] - leavebound)
-                            / theFvec->delta()[leaveIdx];
-         theFvec->update();
-         (*theFvec)[leaveIdx] = enterBound - theFvec->value();
-         updateFtest();
-
-         // update objective funtion value
-         updateNonbasicValue(objChange);
-
-         //  change basis matrix
-         this->change(leaveIdx, enterId, &newVector, &(theFvec->delta()));
+      //      process leaving variable
+      if (leavebound > epsilon() || leavebound < -epsilon())
+        theFrhs->multAdd(-leavebound, this->baseVec(leaveIdx));
+
+      //      process entering variable
+      R enterBound;
+      R newUBbound;
+      R newLBbound;
+      R newCoPrhs;
+
+      try {
+        getLeaveVals2(leaveMax, enterId, enterBound, newUBbound, newLBbound,
+                      newCoPrhs, objChange);
+      } catch (const SPxException &F) {
+        rejectLeave(leaveNum, leaveId, leaveStat);
+        this->change(-1, none, 0);
+        objChange = R(0.0); // the nonbasicValue is not supposed to be updated
+                            // in this case
+        throw F;
       }
 
-      /*
-        No entering vector has been selected from the basis. However, if the
-        shift amount for |coPvec| is bounded, we are in the case, that the
-        entering variable is moved from one bound to its other, before any of
-        the basis feasibility variables reaches their bound. This may only
-        happen in primal/columnwise case with upper and lower bounds on
-        variables.
-      */
-      else
-      {
-         // @todo update obj function value here!!!
-         assert(rep() == ROW);
-         typename SPxBasisBase<R>::Desc& ds = this->desc();
-
-         this->change(leaveIdx, none, 0);
-
-         if(leaveStat == SPxBasisBase<R>::Desc::P_ON_UPPER)
-         {
-            if(leaveId.isSPxRowId())
-            {
-               ds.rowStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-               (*theCoPrhs)[leaveIdx] = theLRbound[leaveNum];
-            }
-            else
-            {
-               ds.colStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-               (*theCoPrhs)[leaveIdx] = theLCbound[leaveNum];
-            }
-
-            theUBbound[leaveIdx] = 0;
-            theLBbound[leaveIdx] = R(-infinity);
-         }
-         else
-         {
-            assert(leaveStat == SPxBasisBase<R>::Desc::P_ON_LOWER);
-
-            if(leaveId.isSPxRowId())
-            {
-               ds.rowStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-               (*theCoPrhs)[leaveIdx] = theURbound[leaveNum];
-            }
-            else
-            {
-               ds.colStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-               (*theCoPrhs)[leaveIdx] = theUCbound[leaveNum];
-            }
-
-            theUBbound[leaveIdx] = R(infinity);
-            theLBbound[leaveIdx] = 0;
-         }
-
-         // update copricing vector
-         theCoPvec->value() = enterVal;
-         thePvec->value() = enterVal;
-
-         if(enterVal > epsilon() || enterVal < -epsilon())
-            doPupdate();
-
-         // update feasibility vectors
-         theFvec->value() = 0;
-         assert(theCoTest[leaveIdx] < 0.0);
-         m_pricingViol += theCoTest[leaveIdx];
-         theCoTest[leaveIdx] *= -1;
+      theUBbound[leaveIdx] = newUBbound;
+      theLBbound[leaveIdx] = newLBbound;
+      (*theCoPrhs)[leaveIdx] = newCoPrhs;
+
+      if (enterBound > epsilon() || enterBound < -epsilon())
+        theFrhs->multAdd(enterBound, newVector);
+
+      // update pricing vectors
+      theCoPvec->value() = enterVal;
+      thePvec->value() = enterVal;
+
+      if (enterVal > epsilon() || enterVal < -epsilon())
+        doPupdate();
+
+      // update feasibility vector
+      theFvec->value() =
+          -((*theFvec)[leaveIdx] - leavebound) / theFvec->delta()[leaveIdx];
+      theFvec->update();
+      (*theFvec)[leaveIdx] = enterBound - theFvec->value();
+      updateFtest();
+
+      // update objective funtion value
+      updateNonbasicValue(objChange);
+
+      //  change basis matrix
+      this->change(leaveIdx, enterId, &newVector, &(theFvec->delta()));
+    }
+
+    /*
+      No entering vector has been selected from the basis. However, if the
+      shift amount for |coPvec| is bounded, we are in the case, that the
+      entering variable is moved from one bound to its other, before any of
+      the basis feasibility variables reaches their bound. This may only
+      happen in primal/columnwise case with upper and lower bounds on
+      variables.
+    */
+    else {
+      // @todo update obj function value here!!!
+      assert(rep() == ROW);
+      typename SPxBasisBase<R>::Desc &ds = this->desc();
+
+      this->change(leaveIdx, none, 0);
+
+      if (leaveStat == SPxBasisBase<R>::Desc::P_ON_UPPER) {
+        if (leaveId.isSPxRowId()) {
+          ds.rowStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+          (*theCoPrhs)[leaveIdx] = theLRbound[leaveNum];
+        } else {
+          ds.colStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+          (*theCoPrhs)[leaveIdx] = theLCbound[leaveNum];
+        }
+
+        theUBbound[leaveIdx] = 0;
+        theLBbound[leaveIdx] = R(-infinity);
+      } else {
+        assert(leaveStat == SPxBasisBase<R>::Desc::P_ON_LOWER);
+
+        if (leaveId.isSPxRowId()) {
+          ds.rowStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+          (*theCoPrhs)[leaveIdx] = theURbound[leaveNum];
+        } else {
+          ds.colStatus(leaveNum) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+          (*theCoPrhs)[leaveIdx] = theUCbound[leaveNum];
+        }
+
+        theUBbound[leaveIdx] = R(infinity);
+        theLBbound[leaveIdx] = 0;
       }
 
-      if((leaveMax > entertol() && enterVal <= entertol()) || (leaveMax < -entertol()
-            && enterVal >= -entertol()))
-      {
-         if((theUBbound[leaveIdx] < R(infinity) || theLBbound[leaveIdx] > R(-infinity))
-               && leaveStat != SPxBasisBase<R>::Desc::P_FREE
-               && leaveStat != SPxBasisBase<R>::Desc::D_FREE)
-         {
-            m_numCycle++;
-            leaveCycles++;
-         }
+      // update copricing vector
+      theCoPvec->value() = enterVal;
+      thePvec->value() = enterVal;
+
+      if (enterVal > epsilon() || enterVal < -epsilon())
+        doPupdate();
+
+      // update feasibility vectors
+      theFvec->value() = 0;
+      assert(theCoTest[leaveIdx] < 0.0);
+      m_pricingViol += theCoTest[leaveIdx];
+      theCoTest[leaveIdx] *= -1;
+    }
+
+    if ((leaveMax > entertol() && enterVal <= entertol()) ||
+        (leaveMax < -entertol() && enterVal >= -entertol())) {
+      if ((theUBbound[leaveIdx] < R(infinity) ||
+           theLBbound[leaveIdx] > R(-infinity)) &&
+          leaveStat != SPxBasisBase<R>::Desc::P_FREE &&
+          leaveStat != SPxBasisBase<R>::Desc::D_FREE) {
+        m_numCycle++;
+        leaveCycles++;
       }
-      else
-         m_numCycle /= 2;
+    } else
+      m_numCycle /= 2;
 
 #ifdef ENABLE_ADDITIONAL_CHECKS
-      {
-         VectorBase<R> tmp = fVec();
-         this->multBaseWith(tmp);
-         tmp -= fRhs();
-
-         if(tmp.length() > entertol())
-         {
-            // This happens very frequently and does usually not hurt, so print
-            // these warnings only with verbose level INFO2 and higher.
-            MSG_INFO2((*this->spxout), (*this->spxout) << "WLEAVE64\t" << basis().iteration()
-                      << ": fVec error = " << tmp.length() << std::endl;)
-            SPxBasisBase<R>::solve(tmp, fRhs());
-            tmp -= fVec();
-            MSG_INFO2((*this->spxout), (*this->spxout) << "WLEAVE65\t(" << tmp.length() << ")\n";)
-         }
+    {
+      VectorBase<R> tmp = fVec();
+      this->multBaseWith(tmp);
+      tmp -= fRhs();
+
+      if (tmp.length() > entertol()) {
+        // This happens very frequently and does usually not hurt, so print
+        // these warnings only with verbose level INFO2 and higher.
+        MSG_INFO2((*this->spxout), (*this->spxout)
+                                       << "WLEAVE64\t" << basis().iteration()
+                                       << ": fVec error = " << tmp.length()
+                                       << std::endl;)
+        SPxBasisBase<R>::solve(tmp, fRhs());
+        tmp -= fVec();
+        MSG_INFO2((*this->spxout),
+                  (*this->spxout) << "WLEAVE65\t(" << tmp.length() << ")\n";)
       }
-#endif  // ENABLE_ADDITIONAL_CHECKS
+    }
+#endif // ENABLE_ADDITIONAL_CHECKS
 
-      return true;
-   }
+    return true;
+  }
 }
 } // namespace soplex
diff --git a/src/soplex/lpcolbase.h b/src/soplex/lpcolbase.h
index ebc4f29..c6a67b3 100644
--- a/src/soplex/lpcolbase.h
+++ b/src/soplex/lpcolbase.h
@@ -30,172 +30,137 @@
 
 #include <assert.h>
 
-#include "soplex/spxdefines.h"
 #include "soplex/basevectors.h"
+#include "soplex/spxdefines.h"
 
-namespace soplex
-{
+namespace soplex {
 /**@brief   LP column.
  * @ingroup Algo
  *
- *  Class LPColBase provides a datatype for storing the column of an LP a the form similar to
- *  \f[
- *     \begin{array}{rl}
+ *  Class LPColBase provides a datatype for storing the column of an LP a the
+ * form similar to \f[ \begin{array}{rl}
  *        \hbox{max}  & c^T x         \\
  *        \hbox{s.t.} & Ax \le b      \\
  *                    & l \le x \le u
  *     \end{array}
  *  \f]
- *  Hence, an LPColBase consists of an objective value, a column DSVector and an upper and lower bound to the corresponding
- *  variable, which may include \f$\pm\infty\f$. However, it depends on the LP code to use, what values are actually
- *  treated as \f$\infty\f$.
+ *  Hence, an LPColBase consists of an objective value, a column DSVector and an
+ * upper and lower bound to the corresponding variable, which may include
+ * \f$\pm\infty\f$. However, it depends on the LP code to use, what values are
+ * actually treated as \f$\infty\f$.
  */
-template < class R >
-class LPColBase
-{
-   template < class S > friend class LPColBase;
+template <class R> class LPColBase {
+  template <class S> friend class LPColBase;
 
 private:
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Data */
+  ///@{
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Data */
-   ///@{
+  R up;                ///< upper bound
+  R low;               ///< lower bound
+  R object;            ///< objective value
+  DSVectorBase<R> vec; ///< the column vector
 
-   R up;                   ///< upper bound
-   R low;                  ///< lower bound
-   R object;               ///< objective value
-   DSVectorBase<R> vec;    ///< the column vector
-
-   ///@}
+  ///@}
 
 public:
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Construction / destruction */
-   ///@{
-
-   /// Default constructor.
-   /** Construct LPColBase with a column vector ready for taking \p defDim nonzeros.
-    */
-   explicit LPColBase<R>(int defDim = 0)
-      : up(R(infinity)), low(0), object(0), vec(defDim)
-   {
-      assert(isConsistent());
-   }
-
-   /// Initializing constructor.
-   /*  Construct LPColBase with the given objective value \p obj, a column %vector \p vec, upper bound \p upper and
-    *  lower bound \p lower.
-    */
-   LPColBase<R>(const R& p_obj, const SVectorBase<R>& p_vector, const R& p_upper, const R& p_lower)
-      : up(p_upper), low(p_lower), object(p_obj), vec(p_vector)
-   {
-      assert(isConsistent());
-   }
-
-   /// Assignment operator.
-   LPColBase<R>& operator=(const LPColBase<R>& old)
-   {
-      if(this != &old)
-      {
-         up = old.up;
-         low = old.low;
-         object = old.object;
-         vec = old.vec;
-      }
-
-      assert(isConsistent());
-   }
-
-   /// Copy constructor.
-   LPColBase<R>(const LPColBase<R>& old)
-      : up(old.up), low(old.low), object(old.object), vec(old.vec)
-   {
-      assert(isConsistent());
-   }
-
-   /// Copy constructor.
-   template < class S >
-   LPColBase<R>(const LPColBase<S>& old)
-      : up(old.up), low(old.low), object(old.object), vec(old.vec)
-   {
-      assert(isConsistent());
-   }
-
-   /// Destructor.
-   ~LPColBase()
-   {}
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Access / modification */
-   ///@{
-
-   /// Gets objective value.
-   R obj() const
-   {
-      return object;
-   }
-
-   /// Sets objective value.
-   void setObj(const R& p_object)
-   {
-      object = p_object;
-   }
-
-   /// Gets upper bound.
-   R upper() const
-   {
-      return up;
-   }
-
-   /// Sets upper bound.
-   void setUpper(const R& p_up)
-   {
-      up = p_up;
-   }
-
-   /// Gets lower bound.
-   R lower() const
-   {
-      return low;
-   }
-   /// Sets lower bound.
-   void setLower(const R& p_low)
-   {
-      low = p_low;
-   }
-
-   /// Gets constraint column vector.
-   const SVectorBase<R>& colVector() const
-   {
-      return vec;
-   }
-
-   /// Sets constraint column vector.
-   void setColVector(const SVectorBase<R>& p_vec)
-   {
-      vec = p_vec;
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Consistency check */
-   ///@{
-
-   /// Checks consistency.
-   bool isConsistent() const
-   {
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Construction / destruction */
+  ///@{
+
+  /// Default constructor.
+  /** Construct LPColBase with a column vector ready for taking \p defDim
+   * nonzeros.
+   */
+  explicit LPColBase(int defDim = 0)
+      : up(R(infinity)), low(0), object(0), vec(defDim) {
+    assert(isConsistent());
+  }
+
+  /// Initializing constructor.
+  /*  Construct LPColBase with the given objective value \p obj, a column
+   * %vector \p vec, upper bound \p upper and lower bound \p lower.
+   */
+  LPColBase(const R &p_obj, const SVectorBase<R> &p_vector, const R &p_upper,
+            const R &p_lower)
+      : up(p_upper), low(p_lower), object(p_obj), vec(p_vector) {
+    assert(isConsistent());
+  }
+
+  /// Assignment operator.
+  LPColBase<R> &operator=(const LPColBase<R> &old) {
+    if (this != &old) {
+      up = old.up;
+      low = old.low;
+      object = old.object;
+      vec = old.vec;
+    }
+
+    assert(isConsistent());
+  }
+
+  /// Copy constructor.
+  LPColBase(const LPColBase<R> &old)
+      : up(old.up), low(old.low), object(old.object), vec(old.vec) {
+    assert(isConsistent());
+  }
+
+  /// Copy constructor.
+  template <class S>
+  LPColBase(const LPColBase<S> &old)
+      : up(old.up), low(old.low), object(old.object), vec(old.vec) {
+    assert(isConsistent());
+  }
+
+  /// Destructor.
+  ~LPColBase() {}
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Access / modification */
+  ///@{
+
+  /// Gets objective value.
+  R obj() const { return object; }
+
+  /// Sets objective value.
+  void setObj(const R &p_object) { object = p_object; }
+
+  /// Gets upper bound.
+  R upper() const { return up; }
+
+  /// Sets upper bound.
+  void setUpper(const R &p_up) { up = p_up; }
+
+  /// Gets lower bound.
+  R lower() const { return low; }
+  /// Sets lower bound.
+  void setLower(const R &p_low) { low = p_low; }
+
+  /// Gets constraint column vector.
+  const SVectorBase<R> &colVector() const { return vec; }
+
+  /// Sets constraint column vector.
+  void setColVector(const SVectorBase<R> &p_vec) { vec = p_vec; }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Consistency check */
+  ///@{
+
+  /// Checks consistency.
+  bool isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
-      return vec.isConsistent();
+    return vec.isConsistent();
 #else
-      return true;
+    return true;
 #endif
-   }
+  }
 
-   ///@}
+  ///@}
 };
 } // namespace soplex
 #endif // _LPCOLBASE_H_
diff --git a/src/soplex/lpcolsetbase.h b/src/soplex/lpcolsetbase.h
index e91ca4c..2e88cca 100644
--- a/src/soplex/lpcolsetbase.h
+++ b/src/soplex/lpcolsetbase.h
@@ -30,645 +30,515 @@
 
 #include <assert.h>
 
-#include "soplex/spxdefines.h"
 #include "soplex/basevectors.h"
 #include "soplex/datakey.h"
 #include "soplex/lpcolbase.h"
+#include "soplex/spxdefines.h"
 
-namespace soplex
-{
+namespace soplex {
 /**@brief   Set of LP columns.
  * @ingroup Algebra
  *
- *  Class LPColSetBase implements a set of \ref LPColBase "LPColBase%s". Unless for memory limitations, any number of LPColBase%s may be
- *  #add%ed to an LPColSetBase. Single or multiple LPColBase%s may be #add%ed to an LPColSetBase, where each method add() comes with
- *  two different signatures. One with and one without a parameter, used for returning the \ref DataKey "DataKeys"
- *  assigned to the new LPColBase%s by the set. See DataKey for a more detailed description of the concept of keys. For the
- *  concept of renumbering LPColBase%s within an LPColSetBase after removal of some LPColBase%s, see DataSet.
+ *  Class LPColSetBase implements a set of \ref LPColBase "LPColBase%s". Unless
+ * for memory limitations, any number of LPColBase%s may be #add%ed to an
+ * LPColSetBase. Single or multiple LPColBase%s may be #add%ed to an
+ * LPColSetBase, where each method add() comes with two different signatures.
+ * One with and one without a parameter, used for returning the \ref DataKey
+ * "DataKeys" assigned to the new LPColBase%s by the set. See DataKey for a more
+ * detailed description of the concept of keys. For the concept of renumbering
+ * LPColBase%s within an LPColSetBase after removal of some LPColBase%s, see
+ * DataSet.
  *
  * @see        DataSet, DataKey
  */
-template < class R >
-class LPColSetBase : protected SVSetBase<R>
-{
-   template < class S > friend class LPColSetBase;
+template <class R> class LPColSetBase : protected SVSetBase<R> {
+  template <class S> friend class LPColSetBase;
 
 private:
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Data */
+  ///@{
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Data */
-   ///@{
+  VectorBase<R> low;    ///< vector of lower bounds.
+  VectorBase<R> up;     ///< vector of upper bounds.
+  VectorBase<R> object; ///< vector of objective coefficients.
 
-   VectorBase<R> low;     ///< vector of lower bounds.
-   VectorBase<R> up;      ///< vector of upper bounds.
-   VectorBase<R> object;  ///< vector of objective coefficients.
-
-   ///@}
+  ///@}
 
 protected:
+  DataArray<int> scaleExp; ///< column scaling factors (stored as bitshift)
 
-   DataArray < int > scaleExp;   ///< column scaling factors (stored as bitshift)
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Protected helpers */
-   ///@{
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Protected helpers */
+  ///@{
 
-   /// Returns the complete SVSetBase.
-   const SVSetBase<R>* colSet() const
-   {
-      return this;
-   }
+  /// Returns the complete SVSetBase.
+  const SVSetBase<R> *colSet() const { return this; }
 
-   ///@}
+  ///@}
 
 public:
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Inquiry */
+  ///@{
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Inquiry */
-   ///@{
-
-   /// Returns the number of LPColBase%s currently in LPColSetBase.
-   int num() const
-   {
-      return SVSetBase<R>::num();
-   }
-
-   /// Returns maximum number of LPColBase%s currently fitting into LPColSetBase.
-   int max() const
-   {
-      return SVSetBase<R>::max();
-   }
-
-   ///
-   const VectorBase<R>& maxObj() const
-   {
-      return object;
-   }
-
-   /// Returns vector of objective values w.r.t. maximization.
-   VectorBase<R>& maxObj_w()
-   {
-      return object;
-   }
-
-   ///
-   const R& maxObj(int i) const
-   {
-      return object[i];
-   }
-
-   /// Returns objective value (w.r.t. maximization) of \p i 'th LPColBase in LPColSetBase.
-   R& maxObj_w(int i)
-   {
-      return object[i];
-   }
-
-   ///
-   const R& maxObj(const DataKey& k) const
-   {
-      return object[number(k)];
-   }
-
-   /// Returns objective value (w.r.t. maximization) of LPColBase with DataKey \p k in LPColSetBase.
-   R& maxObj_w(const DataKey& k)
-   {
-      return object[number(k)];
-   }
-
-   ///
-   const VectorBase<R>& lower() const
-   {
-      return low;
-   }
-
-   /// Returns vector of lower bound values.
-   VectorBase<R>& lower_w()
-   {
-      return low;
-   }
-
-   ///
-   const R& lower(int i) const
-   {
-      return low[i];
-   }
-
-   /// Returns lower bound of \p i 'th LPColBase in LPColSetBase.
-   R& lower_w(int i)
-   {
-      return low[i];
-   }
-
-   ///
-   const R& lower(const DataKey& k) const
-   {
-      return low[number(k)];
-   }
-
-   /// Returns lower bound of LPColBase with DataKey \p k in LPColSetBase.
-   R& lower_w(const DataKey& k)
-   {
-      return low[number(k)];
-   }
-
-   ///
-   const VectorBase<R>& upper() const
-   {
-      return up;
-   }
-
-   /// Returns vector of upper bound values.
-   VectorBase<R>& upper_w()
-   {
-      return up;
-   }
-
-   ///
-   const R& upper(int i) const
-   {
-      return up[i];
-   }
-
-   /// Returns upper bound of \p i 'th LPColBase in LPColSetBase.
-   R& upper_w(int i)
-   {
-      return up[i];
-   }
-
-   ///
-   const R& upper(const DataKey& k) const
-   {
-      return up[number(k)];
-   }
-
-   /// Returns upper bound of LPColBase with DataKey \p k in LPColSetBase.
-   R& upper_w(const DataKey& k)
-   {
-      return up[number(k)];
-   }
-
-   ///
-   SVectorBase<R>& colVector_w(int i)
-   {
-      return SVSetBase<R>::operator[](i);
-   }
-
-   /// Returns colVector of \p i 'th LPColBase in LPColSetBase.
-   const SVectorBase<R>& colVector(int i) const
-   {
-      return SVSetBase<R>::operator[](i);
-   }
-
-   /// Returns writeable colVector of LPColBase with DataKey \p k in LPColSetBase.
-   SVectorBase<R>& colVector_w(const DataKey& k)
-   {
-      return SVSetBase<R>::operator[](k);
-   }
-
-   /// Returns colVector of LPColBase with DataKey \p k in LPColSetBase.
-   const SVectorBase<R>& colVector(const DataKey& k) const
-   {
-      return SVSetBase<R>::operator[](k);
-   }
-
-   /// Returns DataKey of \p i 'th LPColBase in LPColSetBase.
-   DataKey key(int i) const
-   {
-      return SVSetBase<R>::key(i);
-   }
-
-   /// Returns number of LPColBase with DataKey \p k in LPColSetBase.
-   int number(const DataKey& k) const
-   {
-      return SVSetBase<R>::number(k);
-   }
-
-   /// Does DataKey \p k belong to LPColSetBase ?
-   bool has(const DataKey& k) const
-   {
-      return SVSetBase<R>::has(k);
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Extension
-    *
-    *  All extension methods come with two signatures, one of which providing a parameter to return the assigned
-    *  DataKey(s). See DataSet for a more detailed description. All extension methods are designed to automatically
-    *  reallocate memory if required.
-    */
-   ///@{
-
-   ///
-   void add(const LPColBase<R>& pcol)
-   {
-      DataKey k;
-      add(k, pcol);
-   }
-
-   /// Adds p pcol to LPColSetBase.
-   void add(DataKey& pkey, const LPColBase<R>& pcol)
-   {
-      add(pkey, pcol.obj(), pcol.lower(), pcol.colVector(), pcol.upper());
-   }
-
-   ///
-   void add(const R& pobj, const R& plower, const SVectorBase<R>& pcolVector, const R& pupper,
-            const int& pscaleExp = 0)
-   {
-      DataKey k;
-      add(k, pobj, plower, pcolVector, pupper, pscaleExp);
-   }
-
-   /// Adds LPColBase consisting of objective value \p obj, lower bound \p lower, column vector \p colVector and upper bound \p upper to LPColSetBase.
-   void add(DataKey& newkey, const R& obj, const R& newlower, const SVectorBase<R>& newcolVector,
-            const R& newupper, const int& newscaleExp = 0)
-   {
-      SVSetBase<R>::add(newkey, newcolVector);
-
-      if(num() > low.dim())
-      {
-         low.reDim(num());
-         up.reDim(num());
-         object.reDim(num());
-         scaleExp.reSize(num());
-      }
+  /// Returns the number of LPColBase%s currently in LPColSetBase.
+  int num() const { return SVSetBase<R>::num(); }
 
-      low[num() - 1] = newlower;
-      up[num() - 1] = newupper;
-      object[num() - 1] = obj;
-      scaleExp[num() - 1] = newscaleExp;
-   }
-
-   /// Adds LPColBase consisting of left hand side \p lhs, column vector \p colVector, and right hand side \p rhs to LPColSetBase.
-   template < class S >
-   void add(const S* obj, const S* lowerValue, const S* colValues, const int* colIndices, int colSize,
-            const S* upperValue)
-   {
-      DataKey k;
-      add(k, obj, lowerValue, colValues, colIndices, colSize, upperValue);
-   }
-
-   /// Adds LPColBase consisting of left hand side \p lhs, column vector \p colVector, and right hand side \p rhs to
-   /// LPColSetBase, with DataKey \p key.
-   template < class S >
-   void add(DataKey& newkey, const S* objValue, const S* lowerValue, const S* colValues,
-            const int* colIndices, int colSize, const S* upperValue)
-   {
-      SVSetBase<R>::add(newkey, colValues, colIndices, colSize);
-
-      if(num() > low.dim())
-      {
-         low.reDim(num());
-         up.reDim(num());
-         object.reDim(num());
-      }
+  /// Returns maximum number of LPColBase%s currently fitting into LPColSetBase.
+  int max() const { return SVSetBase<R>::max(); }
 
-      low[num() - 1] = *lowerValue;
-      up[num() - 1] = *upperValue;
-      object[num() - 1] = *objValue;
-   }
+  ///
+  const VectorBase<R> &maxObj() const { return object; }
 
-   ///
-   void add(const LPColSetBase<R>& newset)
-   {
-      int i = num();
+  /// Returns vector of objective values w.r.t. maximization.
+  VectorBase<R> &maxObj_w() { return object; }
 
-      SVSetBase<R>::add(newset);
+  ///
+  const R &maxObj(int i) const { return object[i]; }
 
-      if(num() > low.dim())
-      {
-         low.reDim(num());
-         up.reDim(num());
-         object.reDim(num());
-         scaleExp.reSize(num());
-      }
+  /// Returns objective value (w.r.t. maximization) of \p i 'th LPColBase in
+  /// LPColSetBase.
+  R &maxObj_w(int i) { return object[i]; }
 
-      for(int j = 0; i < num(); ++i, ++j)
-      {
-         low[i] = newset.lower(j);
-         up[i] = newset.upper(j);
-         object[i] = newset.maxObj(j);
-         scaleExp[i] = newset.scaleExp[j];
-      }
-   }
-
-   /// Adds all LPColBase%s of \p set to LPColSetBase.
-   void add(DataKey keys[], const LPColSetBase<R>& newset)
-   {
-      int i = num();
-
-      add(newset);
-
-      for(int j = 0; i < num(); ++i, ++j)
-         keys[j] = key(i);
-   }
-
-   /// Extends column \p n to fit \p newmax nonzeros.
-   void xtend(int n, int newmax)
-   {
-      SVSetBase<R>::xtend(colVector_w(n), newmax);
-   }
-
-   /// Extends column with DataKey \p key to fit \p newmax nonzeros.
-   void xtend(const DataKey& pkey, int pnewmax)
-   {
-      SVSetBase<R>::xtend(colVector_w(pkey), pnewmax);
-   }
-
-   ///
-   void add2(const DataKey& k, int n, const int idx[], const R val[])
-   {
-      SVSetBase<R>::add2(colVector_w(k), n, idx, val);
-   }
-
-   /// Adds \p n nonzero (\p idx, \p val)-pairs to \p i 'th colVector.
-   void add2(int i, int n, const int idx[], const R val[])
-   {
-      SVSetBase<R>::add2(colVector_w(i), n, idx, val);
-   }
-
-   /// Adds \p n nonzero (\p idx, \p val)-pairs to \p i 'th colVector.
-   template < class S >
-   void add2(int i, int n, const int idx[], const S val[])
-   {
-      SVSetBase<R>::add2(colVector_w(i), n, idx, val);
-   }
-
-   ///
-   SVectorBase<R>& create(int pnonzeros = 0, const R& pobj = 1, const R& plw = 0, const R& pupp = 1,
-                          const int& pscaleExp = 0)
-   {
-      DataKey k;
-      return create(k, pnonzeros, pobj, plw, pupp, pscaleExp);
-   }
-
-   /// Creates new LPColBase with specified arguments and returns a reference to its column vector.
-   SVectorBase<R>& create(DataKey& newkey, int nonzeros = 0, const R& obj = 1, const R& newlow = 0,
-                          const R& newup = 1, const int& newscaleExp = 0)
-   {
-      if(num() + 1 > low.dim())
-      {
-         low.reDim(num() + 1);
-         up.reDim(num() + 1);
-         object.reDim(num() + 1);
-         scaleExp.reSize(num() + 1);
-      }
+  ///
+  const R &maxObj(const DataKey &k) const { return object[number(k)]; }
+
+  /// Returns objective value (w.r.t. maximization) of LPColBase with DataKey \p
+  /// k in LPColSetBase.
+  R &maxObj_w(const DataKey &k) { return object[number(k)]; }
+
+  ///
+  const VectorBase<R> &lower() const { return low; }
+
+  /// Returns vector of lower bound values.
+  VectorBase<R> &lower_w() { return low; }
+
+  ///
+  const R &lower(int i) const { return low[i]; }
+
+  /// Returns lower bound of \p i 'th LPColBase in LPColSetBase.
+  R &lower_w(int i) { return low[i]; }
+
+  ///
+  const R &lower(const DataKey &k) const { return low[number(k)]; }
+
+  /// Returns lower bound of LPColBase with DataKey \p k in LPColSetBase.
+  R &lower_w(const DataKey &k) { return low[number(k)]; }
+
+  ///
+  const VectorBase<R> &upper() const { return up; }
+
+  /// Returns vector of upper bound values.
+  VectorBase<R> &upper_w() { return up; }
+
+  ///
+  const R &upper(int i) const { return up[i]; }
+
+  /// Returns upper bound of \p i 'th LPColBase in LPColSetBase.
+  R &upper_w(int i) { return up[i]; }
+
+  ///
+  const R &upper(const DataKey &k) const { return up[number(k)]; }
+
+  /// Returns upper bound of LPColBase with DataKey \p k in LPColSetBase.
+  R &upper_w(const DataKey &k) { return up[number(k)]; }
+
+  ///
+  SVectorBase<R> &colVector_w(int i) { return SVSetBase<R>::operator[](i); }
+
+  /// Returns colVector of \p i 'th LPColBase in LPColSetBase.
+  const SVectorBase<R> &colVector(int i) const {
+    return SVSetBase<R>::operator[](i);
+  }
+
+  /// Returns writeable colVector of LPColBase with DataKey \p k in
+  /// LPColSetBase.
+  SVectorBase<R> &colVector_w(const DataKey &k) {
+    return SVSetBase<R>::operator[](k);
+  }
+
+  /// Returns colVector of LPColBase with DataKey \p k in LPColSetBase.
+  const SVectorBase<R> &colVector(const DataKey &k) const {
+    return SVSetBase<R>::operator[](k);
+  }
+
+  /// Returns DataKey of \p i 'th LPColBase in LPColSetBase.
+  DataKey key(int i) const { return SVSetBase<R>::key(i); }
+
+  /// Returns number of LPColBase with DataKey \p k in LPColSetBase.
+  int number(const DataKey &k) const { return SVSetBase<R>::number(k); }
+
+  /// Does DataKey \p k belong to LPColSetBase ?
+  bool has(const DataKey &k) const { return SVSetBase<R>::has(k); }
 
-      low[num()] = newlow;
-      up[num()] = newup;
-      object[num()] = obj;
-      scaleExp[num()] = newscaleExp;
-
-      return *SVSetBase<R>::create(newkey, nonzeros);
-   }
-
-   ///@}
-
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Shrinking
-    *
-    *  See DataSet for a description of the renumbering of the remaining LPColBase%s in a LPColSetBase after the call of
-    *  a removal method.
-    */
-   ///@{
-
-   /// Removes \p i 'th LPColBase.
-   void remove(int i)
-   {
-      SVSetBase<R>::remove(i);
-      low[i] = low[num()];
-      up[i] = up[num()];
-      object[i] = object[num()];
-      scaleExp[i] = scaleExp[num()];
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Extension
+   *
+   *  All extension methods come with two signatures, one of which providing a
+   * parameter to return the assigned DataKey(s). See DataSet for a more
+   * detailed description. All extension methods are designed to automatically
+   *  reallocate memory if required.
+   */
+  ///@{
+
+  ///
+  void add(const LPColBase<R> &pcol) {
+    DataKey k;
+    add(k, pcol);
+  }
+
+  /// Adds p pcol to LPColSetBase.
+  void add(DataKey &pkey, const LPColBase<R> &pcol) {
+    add(pkey, pcol.obj(), pcol.lower(), pcol.colVector(), pcol.upper());
+  }
+
+  ///
+  void add(const R &pobj, const R &plower, const SVectorBase<R> &pcolVector,
+           const R &pupper, const int &pscaleExp = 0) {
+    DataKey k;
+    add(k, pobj, plower, pcolVector, pupper, pscaleExp);
+  }
+
+  /// Adds LPColBase consisting of objective value \p obj, lower bound \p lower,
+  /// column vector \p colVector and upper bound \p upper to LPColSetBase.
+  void add(DataKey &newkey, const R &obj, const R &newlower,
+           const SVectorBase<R> &newcolVector, const R &newupper,
+           const int &newscaleExp = 0) {
+    SVSetBase<R>::add(newkey, newcolVector);
+
+    if (num() > low.dim()) {
       low.reDim(num());
       up.reDim(num());
       object.reDim(num());
       scaleExp.reSize(num());
-   }
-
-   /// Removes LPColBase with DataKey \p k.
-   void remove(const DataKey& k)
-   {
-      remove(number(k));
-   }
-
-   /// Removes multiple elements.
-   void remove(int perm[])
-   {
-      int n = num();
-
-      SVSetBase<R>::remove(perm);
-
-      for(int i = 0; i < n; ++i)
-      {
-         if(perm[i] >= 0 && perm[i] != i)
-         {
-            low[perm[i]] = low[i];
-            up[perm[i]] = up[i];
-            object[perm[i]] = object[i];
-            scaleExp[perm[i]] = scaleExp[i];
-         }
-      }
-
+    }
+
+    low[num() - 1] = newlower;
+    up[num() - 1] = newupper;
+    object[num() - 1] = obj;
+    scaleExp[num() - 1] = newscaleExp;
+  }
+
+  /// Adds LPColBase consisting of left hand side \p lhs, column vector \p
+  /// colVector, and right hand side \p rhs to LPColSetBase.
+  template <class S>
+  void add(const S *obj, const S *lowerValue, const S *colValues,
+           const int *colIndices, int colSize, const S *upperValue) {
+    DataKey k;
+    add(k, obj, lowerValue, colValues, colIndices, colSize, upperValue);
+  }
+
+  /// Adds LPColBase consisting of left hand side \p lhs, column vector \p
+  /// colVector, and right hand side \p rhs to LPColSetBase, with DataKey \p
+  /// key.
+  template <class S>
+  void add(DataKey &newkey, const S *objValue, const S *lowerValue,
+           const S *colValues, const int *colIndices, int colSize,
+           const S *upperValue) {
+    SVSetBase<R>::add(newkey, colValues, colIndices, colSize);
+
+    if (num() > low.dim()) {
       low.reDim(num());
       up.reDim(num());
       object.reDim(num());
-      scaleExp.reSize(num());
-   }
-
-   /// Removes LPColBase%s with numbers \p nums, where \p n is the length of the array \p nums
-   void remove(const int nums[], int n)
-   {
-      DataArray < int > perm(num());
-      remove(nums, n, perm.get_ptr());
-   }
-
-   /// Removes LPColBase%s with numbers \p nums, where \p n is the length of the array \p nums, and stores the index permutation in array \p perm.
-   void remove(const int nums[], int n, int* perm)
-   {
-      SVSetBase<R>::remove(nums, n, perm);
-
-      int j = num();
-
-      for(int i = 0; i < j; ++i)
-      {
-         if(perm[i] >= 0 && perm[i] != i)
-         {
-            low[perm[i]] = low[i];
-            up[perm[i]] = up[i];
-            object[perm[i]] = object[i];
-            scaleExp[perm[i]] = scaleExp[i];
-         }
-      }
+    }
+
+    low[num() - 1] = *lowerValue;
+    up[num() - 1] = *upperValue;
+    object[num() - 1] = *objValue;
+  }
+
+  ///
+  void add(const LPColSetBase<R> &newset) {
+    int i = num();
 
+    SVSetBase<R>::add(newset);
+
+    if (num() > low.dim()) {
       low.reDim(num());
       up.reDim(num());
       object.reDim(num());
       scaleExp.reSize(num());
-   }
+    }
+
+    for (int j = 0; i < num(); ++i, ++j) {
+      low[i] = newset.lower(j);
+      up[i] = newset.upper(j);
+      object[i] = newset.maxObj(j);
+      scaleExp[i] = newset.scaleExp[j];
+    }
+  }
+
+  /// Adds all LPColBase%s of \p set to LPColSetBase.
+  void add(DataKey keys[], const LPColSetBase<R> &newset) {
+    int i = num();
+
+    add(newset);
+
+    for (int j = 0; i < num(); ++i, ++j)
+      keys[j] = key(i);
+  }
+
+  /// Extends column \p n to fit \p newmax nonzeros.
+  void xtend(int n, int newmax) { SVSetBase<R>::xtend(colVector_w(n), newmax); }
+
+  /// Extends column with DataKey \p key to fit \p newmax nonzeros.
+  void xtend(const DataKey &pkey, int pnewmax) {
+    SVSetBase<R>::xtend(colVector_w(pkey), pnewmax);
+  }
+
+  ///
+  void add2(const DataKey &k, int n, const int idx[], const R val[]) {
+    SVSetBase<R>::add2(colVector_w(k), n, idx, val);
+  }
+
+  /// Adds \p n nonzero (\p idx, \p val)-pairs to \p i 'th colVector.
+  void add2(int i, int n, const int idx[], const R val[]) {
+    SVSetBase<R>::add2(colVector_w(i), n, idx, val);
+  }
+
+  /// Adds \p n nonzero (\p idx, \p val)-pairs to \p i 'th colVector.
+  template <class S> void add2(int i, int n, const int idx[], const S val[]) {
+    SVSetBase<R>::add2(colVector_w(i), n, idx, val);
+  }
+
+  ///
+  SVectorBase<R> &create(int pnonzeros = 0, const R &pobj = 1, const R &plw = 0,
+                         const R &pupp = 1, const int &pscaleExp = 0) {
+    DataKey k;
+    return create(k, pnonzeros, pobj, plw, pupp, pscaleExp);
+  }
+
+  /// Creates new LPColBase with specified arguments and returns a reference to
+  /// its column vector.
+  SVectorBase<R> &create(DataKey &newkey, int nonzeros = 0, const R &obj = 1,
+                         const R &newlow = 0, const R &newup = 1,
+                         const int &newscaleExp = 0) {
+    if (num() + 1 > low.dim()) {
+      low.reDim(num() + 1);
+      up.reDim(num() + 1);
+      object.reDim(num() + 1);
+      scaleExp.reSize(num() + 1);
+    }
+
+    low[num()] = newlow;
+    up[num()] = newup;
+    object[num()] = obj;
+    scaleExp[num()] = newscaleExp;
+
+    return *SVSetBase<R>::create(newkey, nonzeros);
+  }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Shrinking
+   *
+   *  See DataSet for a description of the renumbering of the remaining
+   * LPColBase%s in a LPColSetBase after the call of a removal method.
+   */
+  ///@{
+
+  /// Removes \p i 'th LPColBase.
+  void remove(int i) {
+    SVSetBase<R>::remove(i);
+    low[i] = low[num()];
+    up[i] = up[num()];
+    object[i] = object[num()];
+    scaleExp[i] = scaleExp[num()];
+    low.reDim(num());
+    up.reDim(num());
+    object.reDim(num());
+    scaleExp.reSize(num());
+  }
+
+  /// Removes LPColBase with DataKey \p k.
+  void remove(const DataKey &k) { remove(number(k)); }
+
+  /// Removes multiple elements.
+  void remove(int perm[]) {
+    int n = num();
+
+    SVSetBase<R>::remove(perm);
+
+    for (int i = 0; i < n; ++i) {
+      if (perm[i] >= 0 && perm[i] != i) {
+        low[perm[i]] = low[i];
+        up[perm[i]] = up[i];
+        object[perm[i]] = object[i];
+        scaleExp[perm[i]] = scaleExp[i];
+      }
+    }
+
+    low.reDim(num());
+    up.reDim(num());
+    object.reDim(num());
+    scaleExp.reSize(num());
+  }
+
+  /// Removes LPColBase%s with numbers \p nums, where \p n is the length of the
+  /// array \p nums
+  void remove(const int nums[], int n) {
+    DataArray<int> perm(num());
+    remove(nums, n, perm.get_ptr());
+  }
+
+  /// Removes LPColBase%s with numbers \p nums, where \p n is the length of the
+  /// array \p nums, and stores the index permutation in array \p perm.
+  void remove(const int nums[], int n, int *perm) {
+    SVSetBase<R>::remove(nums, n, perm);
+
+    int j = num();
+
+    for (int i = 0; i < j; ++i) {
+      if (perm[i] >= 0 && perm[i] != i) {
+        low[perm[i]] = low[i];
+        up[perm[i]] = up[i];
+        object[perm[i]] = object[i];
+        scaleExp[perm[i]] = scaleExp[i];
+      }
+    }
+
+    low.reDim(num());
+    up.reDim(num());
+    object.reDim(num());
+    scaleExp.reSize(num());
+  }
+
+  /// Removes all LPColBase%s from the set.
+  void clear() {
+    SVSetBase<R>::clear();
+    low.reDim(num());
+    up.reDim(num());
+    object.reDim(num());
+    scaleExp.clear();
+  }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Memory Management
+   *  See SVSet for a description of the memory management methods.
+   */
+  ///@{
 
-   /// Removes all LPColBase%s from the set.
-   void clear()
-   {
-      SVSetBase<R>::clear();
-      low.reDim(num());
-      up.reDim(num());
-      object.reDim(num());
-      scaleExp.clear();
-   }
+  /// Reallocates memory to be able to store \p newmax LPColBase%s.
+  void reMax(int newmax = 0) {
+    SVSetBase<R>::reMax(newmax);
+    up.reSize(max());
+    low.reSize(max());
+    object.reSize(max());
+    scaleExp.reSize(max());
+  }
 
-   ///@}
+  /// Returns used nonzero memory.
+  int memSize() const { return SVSetBase<R>::memSize(); }
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Memory Management
-    *  See SVSet for a description of the memory management methods.
-   */
-   ///@{
-
-   /// Reallocates memory to be able to store \p newmax LPColBase%s.
-   void reMax(int newmax = 0)
-   {
-      SVSetBase<R>::reMax(newmax);
-      up.reSize(max());
-      low.reSize(max());
-      object.reSize(max());
-      scaleExp.reSize(max());
-   }
-
-   /// Returns used nonzero memory.
-   int memSize() const
-   {
-      return SVSetBase<R>::memSize();
-   }
-
-   /// Returns length of nonzero memory.
-   int memMax() const
-   {
-      return SVSetBase<R>::memMax();
-   }
-
-   /// Resets length of nonzero memory.
-   void memRemax(int newmax)
-   {
-      SVSetBase<R>::memRemax(newmax);
-   }
-
-   /// Garbage collection in nonzero memory.
-   void memPack()
-   {
-      SVSetBase<R>::memPack();
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Miscellaneous */
-   ///@{
-
-   /// Checks consistency.
-   bool isConsistent() const
-   {
+  /// Returns length of nonzero memory.
+  int memMax() const { return SVSetBase<R>::memMax(); }
+
+  /// Resets length of nonzero memory.
+  void memRemax(int newmax) { SVSetBase<R>::memRemax(newmax); }
+
+  /// Garbage collection in nonzero memory.
+  void memPack() { SVSetBase<R>::memPack(); }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Miscellaneous */
+  ///@{
+
+  /// Checks consistency.
+  bool isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
 
-      if(low.dim() != object.dim())
-         return MSGinconsistent("LPColSetBase");
+    if (low.dim() != object.dim())
+      return MSGinconsistent("LPColSetBase");
 
-      if(low.dim() != up.dim())
-         return MSGinconsistent("LPColSetBase");
+    if (low.dim() != up.dim())
+      return MSGinconsistent("LPColSetBase");
 
-      if(low.dim() != num())
-         return MSGinconsistent("LPColSetBase");
+    if (low.dim() != num())
+      return MSGinconsistent("LPColSetBase");
 
-      return low.isConsistent() && up.isConsistent() && SVSetBase<R>::isConsistent();
+    return low.isConsistent() && up.isConsistent() &&
+           SVSetBase<R>::isConsistent();
 #else
-      return true;
+    return true;
 #endif
-   }
+  }
 
-   ///@}
+  ///@}
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Constructors / Destructors */
-   ///@{
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Constructors / Destructors */
+  ///@{
 
-   /// Default constructor.
-   /** The user can specify the initial maximum number of columns \p max and the initial maximum number of nonzero
-    *  entries \p memmax. If these parameters are omitted, a default size is used. However, one can add an arbitrary
-    *  number of columns to the LPColSetBase, which may result in automated memory realllocation.
+  /// Default constructor.
+  /** The user can specify the initial maximum number of columns \p max and the
+   * initial maximum number of nonzero entries \p memmax. If these parameters
+   * are omitted, a default size is used. However, one can add an arbitrary
+   *  number of columns to the LPColSetBase, which may result in automated
+   * memory realllocation.
    */
-   explicit
-   LPColSetBase<R>(int pmax = -1, int pmemmax = -1)
-      : SVSetBase<R>(pmax, pmemmax), low(0), up(0), object(0), scaleExp(0)
-   {
-      assert(isConsistent());
-   }
-
-   /// Assignment operator.
-   LPColSetBase<R>& operator=(const LPColSetBase<R>& rs)
-   {
-      if(this != &rs)
-      {
-         SVSetBase<R>::operator=(rs);
-         low = rs.low;
-         up = rs.up;
-         object = rs.object;
-         scaleExp = rs.scaleExp;
-
-         assert(isConsistent());
-      }
-
-      return *this;
-   }
-
-   /// Assignment operator.
-   template < class S >
-   LPColSetBase<R>& operator=(const LPColSetBase<S>& rs)
-   {
-      if(this != (const LPColSetBase<R>*)(&rs))
-      {
-         SVSetBase<R>::operator=(rs);
-         low = rs.low;
-         up = rs.up;
-         object = rs.object;
-         scaleExp = rs.scaleExp;
-
-         assert(isConsistent());
-      }
+  explicit LPColSetBase(int pmax = -1, int pmemmax = -1)
+      : SVSetBase<R>(pmax, pmemmax), low(0), up(0), object(0), scaleExp(0) {
+    assert(isConsistent());
+  }
+
+  /// Assignment operator.
+  LPColSetBase<R> &operator=(const LPColSetBase<R> &rs) {
+    if (this != &rs) {
+      SVSetBase<R>::operator=(rs);
+      low = rs.low;
+      up = rs.up;
+      object = rs.object;
+      scaleExp = rs.scaleExp;
 
-      return *this;
-   }
-
-   /// Copy constructor.
-   LPColSetBase<R>(const LPColSetBase<R>& rs)
-      : SVSetBase<R>(rs)
-      , low(rs.low)
-      , up(rs.up)
-      , object(rs.object)
-      , scaleExp(rs.scaleExp)
-   {
       assert(isConsistent());
-   }
-
-   /// Copy constructor.
-   template < class S >
-   LPColSetBase<R>(const LPColSetBase<S>& rs)
-      : SVSetBase<R>(rs)
-      , low(rs.low)
-      , up(rs.up)
-      , object(rs.object)
-      , scaleExp(rs.scaleExp)
-   {
-      assert(isConsistent());
-   }
+    }
+
+    return *this;
+  }
 
-   /// Destructor.
-   virtual ~LPColSetBase<R>()
-   {}
+  /// Assignment operator.
+  template <class S> LPColSetBase<R> &operator=(const LPColSetBase<S> &rs) {
+    if (this != (const LPColSetBase<R> *)(&rs)) {
+      SVSetBase<R>::operator=(rs);
+      low = rs.low;
+      up = rs.up;
+      object = rs.object;
+      scaleExp = rs.scaleExp;
 
-   ///@}
+      assert(isConsistent());
+    }
+
+    return *this;
+  }
+
+  /// Copy constructor.
+  LPColSetBase(const LPColSetBase<R> &rs)
+      : SVSetBase<R>(rs), low(rs.low), up(rs.up), object(rs.object),
+        scaleExp(rs.scaleExp) {
+    assert(isConsistent());
+  }
+
+  /// Copy constructor.
+  template <class S>
+  LPColSetBase(const LPColSetBase<S> &rs)
+      : SVSetBase<R>(rs), low(rs.low), up(rs.up), object(rs.object),
+        scaleExp(rs.scaleExp) {
+    assert(isConsistent());
+  }
+
+  /// Destructor.
+  virtual ~LPColSetBase() {}
+
+  ///@}
 };
 
 } // namespace soplex
diff --git a/src/soplex/lprowbase.h b/src/soplex/lprowbase.h
index 903d938..69d9eb2 100644
--- a/src/soplex/lprowbase.h
+++ b/src/soplex/lprowbase.h
@@ -30,271 +30,235 @@
 
 #include <assert.h>
 
-#include "soplex/spxdefines.h"
 #include "soplex/basevectors.h"
+#include "soplex/spxdefines.h"
 
-namespace soplex
-{
+namespace soplex {
 /**@brief   (In)equality for LPs.
  * @ingroup Algo
  *
- *  Class LPRowBase provides constraints for linear programs in the form \f[ l \le a^Tx \le r, \f] where \em a is a
- *  DSVector. \em l is referred to as %left hand side, \em r as %right hand side and \em a as \em row \em vector or the
- *  constraint vector. \em l and \em r may also take values \f$\pm\f$ #R(infinity).  This static member is predefined, but
- *  may be overridden to meet the needs of the LP solver to be used.
+ *  Class LPRowBase provides constraints for linear programs in the form \f[ l
+ * \le a^Tx \le r, \f] where \em a is a DSVector. \em l is referred to as %left
+ * hand side, \em r as %right hand side and \em a as \em row \em vector or the
+ *  constraint vector. \em l and \em r may also take values \f$\pm\f$
+ * #R(infinity).  This static member is predefined, but may be overridden to
+ * meet the needs of the LP solver to be used.
  *
- *  LPRowBases allow to specify regular inequalities of the form \f[ a^Tx \sim \alpha, \f] where \f$\sim\f$ can take any
- *  value of \f$\le, =, \ge\f$, by setting rhs and lhs to the same value or setting one of them to \f$\infty\f$.
+ *  LPRowBases allow to specify regular inequalities of the form \f[ a^Tx \sim
+ * \alpha, \f] where \f$\sim\f$ can take any value of \f$\le, =, \ge\f$, by
+ * setting rhs and lhs to the same value or setting one of them to \f$\infty\f$.
  *
- *  Since constraints in the regular form occur often, LPRowBases offers methods type() and value() for retreiving
- *  \f$\sim\f$ and \f$\alpha\f$ of an LPRowBase in this form, respectively. Also, a constructor for LPRowBases given in
+ *  Since constraints in the regular form occur often, LPRowBases offers methods
+ * type() and value() for retreiving \f$\sim\f$ and \f$\alpha\f$ of an LPRowBase
+ * in this form, respectively. Also, a constructor for LPRowBases given in
  *  regular form is provided.
  */
-template < class R >
-class LPRowBase
-{
-   template < class S > friend class LPRowBase;
+template <class R> class LPRowBase {
+  template <class S> friend class LPRowBase;
 
 private:
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Data */
+  ///@{
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Data */
-   ///@{
-
-   R left;                 ///< left-hand side of the constraint
-   R right;                ///< right-hand side of the constraint
-   R object;               ///< objective coefficient of corresponding slack variable s = vec times primal
-   DSVectorBase<R> vec;    ///< the row vector
+  R left;   ///< left-hand side of the constraint
+  R right;  ///< right-hand side of the constraint
+  R object; ///< objective coefficient of corresponding slack variable s = vec
+            ///< times primal
+  DSVectorBase<R> vec; ///< the row vector
 
-   ///@}
+  ///@}
 
 public:
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Types */
+  ///@{
+
+  /// (In)Equality type of an LP row.
+  /** #LPRowBase%s may be of one of the following Types. This datatype may be
+   * used for constructing new #LPRowBase%s in the regular form.
+   */
+  enum Type {
+    LESS_EQUAL,    ///< \f$a^Tx \le \alpha\f$.
+    EQUAL,         ///< \f$a^Tx = \alpha\f$.
+    GREATER_EQUAL, ///< \f$a^Tx \ge \alpha\f$.
+    RANGE          ///< \f$\lambda \le a^Tx \le \rho\f$.
+  };
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Construction / destruction */
+  ///@{
+
+  /// Constructs LPRowBase with a vector ready to hold \p defDim nonzeros.
+  explicit LPRowBase(int defDim = 0)
+      : left(0), right(R(infinity)), object(0), vec(defDim) {
+    assert(isConsistent());
+  }
+
+  /// Assignment operator.
+  LPRowBase<R> &operator=(const LPRowBase<R> &row) {
+    if (this != &row) {
+      left = row.left;
+      right = row.right;
+      object = row.object;
+      vec = row.vec;
+    }
+
+    assert(isConsistent());
+  }
+
+  /// Copy constructor.
+  LPRowBase(const LPRowBase<R> &row)
+      : left(row.left), right(row.right), object(row.object), vec(row.vec) {
+    assert(isConsistent());
+  }
+
+  /// Copy constructor.
+  template <class S>
+  LPRowBase(const LPRowBase<S> &row)
+      : left(row.left), right(row.right), object(row.object), vec(row.vec) {
+    assert(isConsistent());
+  }
+
+  /// Constructs LPRowBase with the given left-hand side, right-hand side and
+  /// rowVector.
+  LPRowBase(const R &p_lhs, const SVectorBase<R> &p_rowVector, const R &p_rhs,
+            const R &p_obj = 0)
+      : left(p_lhs), right(p_rhs), object(p_obj), vec(p_rowVector) {
+    assert(isConsistent());
+  }
+
+  /// Constructs LPRowBase from passed \p rowVector, \p type and \p value.
+  LPRowBase(const SVectorBase<R> &p_rowVector, Type p_type, const R &p_value,
+            const R &p_obj = 0)
+      : object(p_obj), vec(p_rowVector) {
+    switch (p_type) {
+    case LESS_EQUAL:
+      left = R(-infinity);
+      right = p_value;
+      break;
+
+    case EQUAL:
+      left = p_value;
+      right = p_value;
+      break;
+
+    case GREATER_EQUAL:
+      left = p_value;
+      right = R(infinity);
+      break;
+
+    default:
+      throw SPxInternalCodeException("XLPROW03 This should never happen.");
+    }
+
+    assert(isConsistent());
+  }
+
+  /// Destructor.
+  ~LPRowBase() {}
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Access / modification */
+  ///@{
+
+  /// Gets type of row.
+  Type type() const {
+    if (rhs() >= R(infinity))
+      return GREATER_EQUAL;
+
+    if (lhs() <= R(-infinity))
+      return LESS_EQUAL;
+
+    if (lhs() == rhs())
+      return EQUAL;
+
+    return RANGE;
+  }
+
+  /// Sets type of (in)equality.
+  void setType(Type p_type) {
+    switch (p_type) {
+    case LESS_EQUAL:
+      left = R(-infinity);
+      break;
+
+    case EQUAL:
+      if (lhs() > R(-infinity))
+        right = lhs();
+      else
+        left = rhs();
+
+      break;
+
+    case GREATER_EQUAL:
+      right = R(infinity);
+      break;
+
+    case RANGE:
+      MSG_ERROR(std::cerr << "ELPROW01 RANGE not supported in LPRow::setType()"
+                          << std::endl;)
+      throw SPxInternalCodeException("XLPROW01 This should never happen.");
+
+    default:
+      throw SPxInternalCodeException("XLPROW02 This should never happen.");
+    }
+  }
+
+  /// Right hand side value of (in)equality.
+  /** This method returns \f$\alpha\f$ for a LPRowBase in regular form. However,
+   * value() may only be called for LPRowBase%s with type() != \c RANGE.
+   */
+  R value() const {
+    assert(type() != RANGE);
+
+    return (rhs() < R(infinity)) ? rhs() : lhs();
+  }
+
+  /// Left-hand side value.
+  R lhs() const { return left; }
+
+  /// Sets left-hand side value.
+  void setLhs(const R &p_left) { left = p_left; }
+
+  /// Right-hand side value.
+  R rhs() const { return right; }
+
+  /// Sets right-hand side value.
+  void setRhs(const R &p_right) { right = p_right; }
+
+  /// Objective coefficient value.
+  R obj() const { return object; }
+
+  /// Sets objective coefficient value.
+  void setObj(const R &p_obj) { object = p_obj; }
+
+  /// Constraint row vector.
+  const SVectorBase<R> &rowVector() const { return vec; }
+
+  /// access constraint row vector.
+  void setRowVector(const DSVectorBase<R> &p_vec) { vec = p_vec; }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Consistency check */
+  ///@{
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Types */
-   ///@{
-
-   /// (In)Equality type of an LP row.
-   /** #LPRowBase%s may be of one of the following Types. This datatype may be used for constructing new #LPRowBase%s in the
-    *  regular form.
-    */
-   enum Type
-   {
-      LESS_EQUAL,          ///< \f$a^Tx \le \alpha\f$.
-      EQUAL,               ///< \f$a^Tx = \alpha\f$.
-      GREATER_EQUAL,       ///< \f$a^Tx \ge \alpha\f$.
-      RANGE                ///< \f$\lambda \le a^Tx \le \rho\f$.
-   };
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Construction / destruction */
-   ///@{
-
-   /// Constructs LPRowBase with a vector ready to hold \p defDim nonzeros.
-   explicit LPRowBase<R>(int defDim = 0)
-      : left(0), right(R(infinity)), object(0), vec(defDim)
-   {
-      assert(isConsistent());
-   }
-
-   /// Assignment operator.
-   LPRowBase<R>& operator=(const LPRowBase<R>& row)
-   {
-      if(this != &row)
-      {
-         left = row.left;
-         right = row.right;
-         object = row.object;
-         vec = row.vec;
-      }
-
-      assert(isConsistent());
-   }
-
-   /// Copy constructor.
-   LPRowBase<R>(const LPRowBase<R>& row)
-      : left(row.left), right(row.right), object(row.object), vec(row.vec)
-   {
-      assert(isConsistent());
-   }
-
-   /// Copy constructor.
-   template < class S >
-   LPRowBase<R>(const LPRowBase<S>& row)
-      : left(row.left), right(row.right), object(row.object), vec(row.vec)
-   {
-      assert(isConsistent());
-   }
-
-   /// Constructs LPRowBase with the given left-hand side, right-hand side and rowVector.
-   LPRowBase<R>(const R& p_lhs, const SVectorBase<R>& p_rowVector, const R& p_rhs, const R& p_obj = 0)
-      : left(p_lhs), right(p_rhs), object(p_obj), vec(p_rowVector)
-   {
-      assert(isConsistent());
-   }
-
-   /// Constructs LPRowBase from passed \p rowVector, \p type and \p value.
-   LPRowBase<R>(const SVectorBase<R>& p_rowVector, Type p_type, const R& p_value, const R& p_obj = 0)
-      : object(p_obj), vec(p_rowVector)
-   {
-      switch(p_type)
-      {
-      case LESS_EQUAL:
-         left = R(-infinity);
-         right = p_value;
-         break;
-
-      case EQUAL:
-         left = p_value;
-         right = p_value;
-         break;
-
-      case GREATER_EQUAL:
-         left = p_value;
-         right = R(infinity);
-         break;
-
-      default:
-         throw SPxInternalCodeException("XLPROW03 This should never happen.");
-      }
-
-      assert(isConsistent());
-   }
-
-   /// Destructor.
-   ~LPRowBase()
-   {}
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Access / modification */
-   ///@{
-
-   /// Gets type of row.
-   Type type() const
-   {
-      if(rhs() >= R(infinity))
-         return GREATER_EQUAL;
-
-      if(lhs() <= R(-infinity))
-         return LESS_EQUAL;
-
-      if(lhs() == rhs())
-         return EQUAL;
-
-      return RANGE;
-   }
-
-   /// Sets type of (in)equality.
-   void setType(Type p_type)
-   {
-      switch(p_type)
-      {
-      case LESS_EQUAL:
-         left = R(-infinity);
-         break;
-
-      case EQUAL:
-         if(lhs() > R(-infinity))
-            right = lhs();
-         else
-            left = rhs();
-
-         break;
-
-      case GREATER_EQUAL:
-         right = R(infinity);
-         break;
-
-      case RANGE:
-         MSG_ERROR(std::cerr << "ELPROW01 RANGE not supported in LPRow::setType()"
-                   << std::endl;)
-         throw SPxInternalCodeException("XLPROW01 This should never happen.");
-
-      default:
-         throw SPxInternalCodeException("XLPROW02 This should never happen.");
-      }
-   }
-
-   /// Right hand side value of (in)equality.
-   /** This method returns \f$\alpha\f$ for a LPRowBase in regular form.  However, value() may only be called for
-    *  LPRowBase%s with type() != \c RANGE.
-    */
-   R value() const
-   {
-      assert(type() != RANGE);
-
-      return (rhs() < R(infinity)) ? rhs() : lhs();
-   }
-
-   /// Left-hand side value.
-   R lhs() const
-   {
-      return left;
-   }
-
-   /// Sets left-hand side value.
-   void setLhs(const R& p_left)
-   {
-      left = p_left;
-   }
-
-   /// Right-hand side value.
-   R rhs() const
-   {
-      return right;
-   }
-
-   /// Sets right-hand side value.
-   void setRhs(const R& p_right)
-   {
-      right = p_right;
-   }
-
-   /// Objective coefficient value.
-   R obj() const
-   {
-      return object;
-   }
-
-   /// Sets objective coefficient value.
-   void setObj(const R& p_obj)
-   {
-      object = p_obj;
-   }
-
-   /// Constraint row vector.
-   const SVectorBase<R>& rowVector() const
-   {
-      return vec;
-   }
-
-   /// access constraint row vector.
-   void setRowVector(const DSVectorBase<R>& p_vec)
-   {
-      vec = p_vec;
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Consistency check */
-   ///@{
-
-   /// Checks consistency.
-   bool isConsistent() const
-   {
+  /// Checks consistency.
+  bool isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
-      return vec.isConsistent();
+    return vec.isConsistent();
 #else
-      return true;
+    return true;
 #endif
-   }
+  }
 
-   ///@}
+  ///@}
 };
 
 } // namespace soplex
diff --git a/src/soplex/lprowsetbase.h b/src/soplex/lprowsetbase.h
index af17ea1..49facef 100644
--- a/src/soplex/lprowsetbase.h
+++ b/src/soplex/lprowsetbase.h
@@ -28,737 +28,601 @@
 #ifndef _LPROWSETBASE_H_
 #define _LPROWSETBASE_H_
 
-
 #include <assert.h>
 
-#include "soplex/spxdefines.h"
 #include "soplex/basevectors.h"
 #include "soplex/datakey.h"
 #include "soplex/lprowbase.h"
+#include "soplex/spxdefines.h"
 
-namespace soplex
-{
+namespace soplex {
 /**@brief   Set of LP rows.
  * @ingroup Algebra
  *
- *  Class LPRowSetBase implements a set of \ref LPRowBase "LPRowBase%s". Unless for memory limitations, any number of
- *  LPRowBase%s may be #add%ed to an LPRowSetBase. Single or multiple LPRowBase%s may be added to an LPRowSetBase, where
- *  each method add() comes with two different signatures. One with and one without a parameter, used for returning the
- *  Keys assigned to the new LPRowBase%s by the set. See DataKey for a more detailed description of the concept of
- *  keys. For the concept of renumbering LPRowBase%s within an LPRowSetBase after removal of some LPRows see DataSet.
+ *  Class LPRowSetBase implements a set of \ref LPRowBase "LPRowBase%s". Unless
+ * for memory limitations, any number of LPRowBase%s may be #add%ed to an
+ * LPRowSetBase. Single or multiple LPRowBase%s may be added to an LPRowSetBase,
+ * where each method add() comes with two different signatures. One with and one
+ * without a parameter, used for returning the Keys assigned to the new
+ * LPRowBase%s by the set. See DataKey for a more detailed description of the
+ * concept of keys. For the concept of renumbering LPRowBase%s within an
+ * LPRowSetBase after removal of some LPRows see DataSet.
  *
  * @see        DataSet, DataKey
-*/
-template < class R >
-class LPRowSetBase : protected SVSetBase<R>
-{
-   template < class S > friend class LPRowSetBase;
+ */
+template <class R> class LPRowSetBase : protected SVSetBase<R> {
+  template <class S> friend class LPRowSetBase;
 
 private:
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Data */
+  ///@{
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Data */
-   ///@{
-
-   VectorBase<R> left;    ///< vector of left hand sides (lower bounds) of LPRowBase%s.
-   VectorBase<R> right;   ///< vector of right hand sides (upper bounds) of LPRowBase%s.
-   VectorBase<R> object;  ///< vector of objective coefficients.
+  VectorBase<R>
+      left; ///< vector of left hand sides (lower bounds) of LPRowBase%s.
+  VectorBase<R>
+      right; ///< vector of right hand sides (upper bounds) of LPRowBase%s.
+  VectorBase<R> object; ///< vector of objective coefficients.
 
-   ///@}
+  ///@}
 
 protected:
+  DataArray<int> scaleExp; ///< row scaling factors (stored as bitshift)
 
-   DataArray < int > scaleExp;   ///< row scaling factors (stored as bitshift)
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Helpers */
+  ///@{
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Helpers */
-   ///@{
+  /// Returns the complete SVSet.
+  const SVSetBase<R> *rowSet() const { return this; }
 
-   /// Returns the complete SVSet.
-   const SVSetBase<R>* rowSet() const
-   {
-      return this;
-   }
-
-   ///@}
+  ///@}
 
 public:
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Access / modification */
+  ///@{
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Access / modification */
-   ///@{
-
-   /// Returns the number of LPRowBase%s in LPRowSetBase.
-   int num() const
-   {
-      return SVSetBase<R>::num();
-   }
-
-   /// Returns the maximum number of LPRowBase%s that fit.
-   int max() const
-   {
-      return SVSetBase<R>::max();
-   }
-
-   /// Returns the vector of lhs values.
-   const VectorBase<R>& lhs() const
-   {
-      return left;
-   }
-
-   /// Returns the vector of lhs values.
-   VectorBase<R>& lhs_w()
-   {
-      return left;
-   }
-
-   /// Returns the lhs of the \p i 'th LPRowBase.
-   const R& lhs(int i) const
-   {
-      return left[i];
-   }
-
-   /// Returns the lhs of the \p i 'th LPRowBase.
-   R& lhs_w(int i)
-   {
-      return left[i];
-   }
-
-   /// Returns the lhs of the LPRowBase with DataKey \p k in LPRowSetBase.
-   const R& lhs(const DataKey& k) const
-   {
-      return left[number(k)];
-   }
-
-   /// Returns the lhs of the LPRowBase with DataKey \p k in LPRowSetBase.
-   R& lhs_w(const DataKey& k)
-   {
-      return left[number(k)];
-   }
-
-   /// Returns the vector of rhs values.
-   const VectorBase<R>& rhs() const
-   {
-      return right;
-   }
-
-   /// Returns the vector of rhs values (writeable).
-   VectorBase<R>& rhs_w()
-   {
-      return right;
-   }
-
-   /// Returns the rhs of the \p i 'th LPRowBase.
-   const R& rhs(int i) const
-   {
-      return right[i];
-   }
-
-   /// Returns the rhs of the \p i 'th LPRowBase (writeable).
-   R& rhs_w(int i)
-   {
-      return right[i];
-   }
-
-   /// Returns the rhs of the LPRowBase with DataKey \p k in LPRowSetBase.
-   const R& rhs(const DataKey& k) const
-   {
-      return right[number(k)];
-   }
-
-   /// Returns the rhs of the LPRowBase with DataKey \p k in LPRowSetBase (writeable).
-   R& rhs_w(const DataKey& k)
-   {
-      return right[number(k)];
-   }
-
-   /// Returns the vector of objective coefficients.
-   const VectorBase<R>& obj() const
-   {
-      return object;
-   }
-
-   /// Returns the vector of objective coefficients (writeable).
-   VectorBase<R>& obj_w()
-   {
-      return object;
-   }
-
-   /// Returns the objective coefficient of the \p i 'th LPRowBase.
-   const R& obj(int i) const
-   {
-      return object[i];
-   }
-
-   /// Returns the objective coefficient of the \p i 'th LPRowBase (writeable).
-   R& obj_w(int i)
-   {
-      return object[i];
-   }
-
-   /// Returns the objective coefficient of the LPRowBase with DataKey \p k in LPRowSetBase.
-   const R& obj(const DataKey& k) const
-   {
-      return object[number(k)];
-   }
-
-   /// Returns the objective coefficient of the LPRowBase with DataKey \p k in LPRowSetBase (writeable).
-   R& obj_w(const DataKey& k)
-   {
-      return object[number(k)];
-   }
-
-   /// Returns a writable rowVector of the \p i 'th LPRowBase.
-   SVectorBase<R>& rowVector_w(int i)
-   {
-      return SVSetBase<R>::operator[](i);
-   }
-
-   /// Returns the rowVector of the \p i 'th LPRowBase.
-   const SVectorBase<R>& rowVector(int i) const
-   {
-      return SVSetBase<R>::operator[](i);
-   }
-
-   /// Returns a writable rowVector of the LPRowBase with DataKey \p k.
-   SVectorBase<R>& rowVector_w(const DataKey& k)
-   {
-      return SVSetBase<R>::operator[](k);
-   }
-
-   /// Returns the rowVector of the LPRowBase with DataKey \p k.
-   const SVectorBase<R>& rowVector(const DataKey& k) const
-   {
-      return SVSetBase<R>::operator[](k);
-   }
-
-   /// Returns the inequalitiy type of the \p i 'th LPRowBase.
-   typename LPRowBase<R>::Type type(int i) const
-   {
-      if(rhs(i) >= R(infinity))
-         return LPRowBase<R>::GREATER_EQUAL;
-
-      if(lhs(i) <= R(-infinity))
-         return LPRowBase<R>::LESS_EQUAL;
-
-      if(lhs(i) == rhs(i))
-         return LPRowBase<R>::EQUAL;
-
-      return LPRowBase<R>::RANGE;
-   }
-
-   /// Returns the inequality type of the LPRowBase with DataKey \p k.
-   typename LPRowBase<R>::Type type(const DataKey& k) const
-   {
-      return type(number(k));
-   }
-
-   /// Changes the inequality type of row \p i to \p type.
-   void setType(int i, typename LPRowBase<R>::Type t)
-   {
-      switch(t)
-      {
-      case LPRowBase<R>::LESS_EQUAL:
-         lhs_w(i) = R(-infinity);
-         break;
-
-      case LPRowBase<R>::EQUAL:
-         if(lhs_w(i) > R(-infinity))
-            rhs_w(i) = lhs(i);
-         else
-            lhs_w(i) = rhs(i);
-
-         break;
-
-      case LPRowBase<R>::GREATER_EQUAL:
-         rhs_w(i) = R(infinity);
-         break;
-
-      case LPRowBase<R>::RANGE:
-         MSG_ERROR(std::cerr << "EROWST01 RANGE not supported in LPRowSet::setType()" << std::endl);
-         throw SPxInternalCodeException("XROWST01 This should never happen.");
-
-      default:
-         throw SPxInternalCodeException("XROWST02 This should never happen.");
-      }
-   }
+  /// Returns the number of LPRowBase%s in LPRowSetBase.
+  int num() const { return SVSetBase<R>::num(); }
 
-   /// Returns the value of the \p i'th LPRowBase.
-   const R& value(int i) const
-   {
-      if(rhs(i) < R(infinity))
-         return rhs(i);
-      else
-      {
-         assert(lhs(i) > R(-infinity));
-         return lhs(i);
-      }
-   }
+  /// Returns the maximum number of LPRowBase%s that fit.
+  int max() const { return SVSetBase<R>::max(); }
 
-   /// Returns the value of the LPRowBase with DataKey \p k.
-   /** The \em value of a row depends on its type: if the inequality is of type "greater or equal", the value is the lhs
-    *  of the row. Otherwise, the value is the rhs.
-   */
-   const R& value(const DataKey& k) const
-   {
-      return value(number(k));
-   }
-
-   /// Returns the DataKey of the \p i 'th LPRowBase in LPRowSetBase.
-   DataKey key(int i) const
-   {
-      return SVSetBase<R>::key(i);
-   }
-
-   /// Returns the number of the LPRowBase with DataKey \p k in LPRowSetBase.
-   int number(const DataKey& k) const
-   {
-      return SVSetBase<R>::number(k);
-   }
-
-   /// does DataKey \p k belong to LPRowSetBase ?
-   bool has(const DataKey& k) const
-   {
-      return SVSetBase<R>::has(k);
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Extension
-    *
-    *  Extension methods come with two signatures, one of them providing a parameter to return the assigned
-    *  DataKey(s). See DataSet for a more detailed description. All extension methods will automatically rearrange or
-    *  allocate more memory if required.
-   */
-   ///@{
-
-   ///
-   void add(const LPRowBase<R>& row)
-   {
-      DataKey k;
-      add(k, row);
-   }
-
-   /// Adds \p row to LPRowSetBase.
-   void add(DataKey& pkey, const LPRowBase<R>& prow)
-   {
-      add(pkey, prow.lhs(), prow.rowVector(), prow.rhs(), prow.obj());
-   }
-
-   /// Adds LPRowBase consisting of left hand side \p lhs, row vector \p rowVector, and right hand side \p rhs to LPRowSetBase.
-   void add(const R& plhs, const SVectorBase<R>& prowVector, const R& prhs, const R& pobj = 0,
-            const int& pscaleExp = 0)
-   {
-      DataKey k;
-      add(k, plhs, prowVector, prhs, pobj, pscaleExp);
-   }
-
-   /// Adds LPRowBase consisting of left hand side \p lhs, row vector \p rowVector, and right hand side \p rhs to LPRowSetBase.
-   template < class S >
-   void add(const S* lhsValue, const S* rowValues, const int* rowIndices, int rowSize,
-            const S* rhsValue, const S* objValue = 0)
-   {
-      assert(lhsValue != 0);
-      assert(rowSize <= 0 || rowValues != 0);
-      assert(rowSize <= 0 || rowIndices != 0);
-      assert(rhsValue != 0);
-
-      DataKey k;
-      add(k, lhsValue, rowValues, rowIndices, rowSize, rhsValue, objValue);
-   }
-
-   /// Adds LPRowBase consisting of left hand side \p lhs, row vector \p rowVector, and right hand side \p rhs to
-   /// LPRowSetBase, with DataKey \p key.
-   template < class S >
-   void add(DataKey& newkey, const S* lhsValue, const S* rowValues, const int* rowIndices, int rowSize,
-            const S* rhsValue, const S* objValue = 0)
-   {
-      assert(lhsValue != 0);
-      assert(rowSize <= 0 || rowValues != 0);
-      assert(rowSize <= 0 || rowIndices != 0);
-      assert(rhsValue != 0);
-
-      SVSetBase<R>::add(newkey, rowValues, rowIndices, rowSize);
-
-      if(num() > left.dim())
-      {
-         left.reDim(num());
-         right.reDim(num());
-         object.reDim(num());
-      }
+  /// Returns the vector of lhs values.
+  const VectorBase<R> &lhs() const { return left; }
+
+  /// Returns the vector of lhs values.
+  VectorBase<R> &lhs_w() { return left; }
+
+  /// Returns the lhs of the \p i 'th LPRowBase.
+  const R &lhs(int i) const { return left[i]; }
+
+  /// Returns the lhs of the \p i 'th LPRowBase.
+  R &lhs_w(int i) { return left[i]; }
+
+  /// Returns the lhs of the LPRowBase with DataKey \p k in LPRowSetBase.
+  const R &lhs(const DataKey &k) const { return left[number(k)]; }
+
+  /// Returns the lhs of the LPRowBase with DataKey \p k in LPRowSetBase.
+  R &lhs_w(const DataKey &k) { return left[number(k)]; }
+
+  /// Returns the vector of rhs values.
+  const VectorBase<R> &rhs() const { return right; }
+
+  /// Returns the vector of rhs values (writeable).
+  VectorBase<R> &rhs_w() { return right; }
+
+  /// Returns the rhs of the \p i 'th LPRowBase.
+  const R &rhs(int i) const { return right[i]; }
 
-      left[num() - 1] = *lhsValue;
-      right[num() - 1] = *rhsValue;
+  /// Returns the rhs of the \p i 'th LPRowBase (writeable).
+  R &rhs_w(int i) { return right[i]; }
 
-      if(objValue != 0)
-         object[num() - 1] = *objValue;
+  /// Returns the rhs of the LPRowBase with DataKey \p k in LPRowSetBase.
+  const R &rhs(const DataKey &k) const { return right[number(k)]; }
+
+  /// Returns the rhs of the LPRowBase with DataKey \p k in LPRowSetBase
+  /// (writeable).
+  R &rhs_w(const DataKey &k) { return right[number(k)]; }
+
+  /// Returns the vector of objective coefficients.
+  const VectorBase<R> &obj() const { return object; }
+
+  /// Returns the vector of objective coefficients (writeable).
+  VectorBase<R> &obj_w() { return object; }
+
+  /// Returns the objective coefficient of the \p i 'th LPRowBase.
+  const R &obj(int i) const { return object[i]; }
+
+  /// Returns the objective coefficient of the \p i 'th LPRowBase (writeable).
+  R &obj_w(int i) { return object[i]; }
+
+  /// Returns the objective coefficient of the LPRowBase with DataKey \p k in
+  /// LPRowSetBase.
+  const R &obj(const DataKey &k) const { return object[number(k)]; }
+
+  /// Returns the objective coefficient of the LPRowBase with DataKey \p k in
+  /// LPRowSetBase (writeable).
+  R &obj_w(const DataKey &k) { return object[number(k)]; }
+
+  /// Returns a writable rowVector of the \p i 'th LPRowBase.
+  SVectorBase<R> &rowVector_w(int i) { return SVSetBase<R>::operator[](i); }
+
+  /// Returns the rowVector of the \p i 'th LPRowBase.
+  const SVectorBase<R> &rowVector(int i) const {
+    return SVSetBase<R>::operator[](i);
+  }
+
+  /// Returns a writable rowVector of the LPRowBase with DataKey \p k.
+  SVectorBase<R> &rowVector_w(const DataKey &k) {
+    return SVSetBase<R>::operator[](k);
+  }
+
+  /// Returns the rowVector of the LPRowBase with DataKey \p k.
+  const SVectorBase<R> &rowVector(const DataKey &k) const {
+    return SVSetBase<R>::operator[](k);
+  }
+
+  /// Returns the inequalitiy type of the \p i 'th LPRowBase.
+  typename LPRowBase<R>::Type type(int i) const {
+    if (rhs(i) >= R(infinity))
+      return LPRowBase<R>::GREATER_EQUAL;
+
+    if (lhs(i) <= R(-infinity))
+      return LPRowBase<R>::LESS_EQUAL;
+
+    if (lhs(i) == rhs(i))
+      return LPRowBase<R>::EQUAL;
+
+    return LPRowBase<R>::RANGE;
+  }
+
+  /// Returns the inequality type of the LPRowBase with DataKey \p k.
+  typename LPRowBase<R>::Type type(const DataKey &k) const {
+    return type(number(k));
+  }
+
+  /// Changes the inequality type of row \p i to \p type.
+  void setType(int i, typename LPRowBase<R>::Type t) {
+    switch (t) {
+    case LPRowBase<R>::LESS_EQUAL:
+      lhs_w(i) = R(-infinity);
+      break;
+
+    case LPRowBase<R>::EQUAL:
+      if (lhs_w(i) > R(-infinity))
+        rhs_w(i) = lhs(i);
       else
-         object[num() - 1] = 0;
-   }
-
-   /// Adds LPRowBase consisting of left hand side \p lhs, row vector \p rowVector, and right hand side \p rhs to
-   /// LPRowSetBase, with DataKey \p key.
-   void add(DataKey& newkey, const R& newlhs, const SVectorBase<R>& newrowVector, const R& newrhs,
-            const R& newobj = 0, const int& newscaleExp = 0)
-   {
-      SVSetBase<R>::add(newkey, newrowVector);
-
-      if(num() > left.dim())
-      {
-         left.reDim(num());
-         right.reDim(num());
-         object.reDim(num());
-         scaleExp.reSize(num());
-      }
+        lhs_w(i) = rhs(i);
+
+      break;
+
+    case LPRowBase<R>::GREATER_EQUAL:
+      rhs_w(i) = R(infinity);
+      break;
+
+    case LPRowBase<R>::RANGE:
+      MSG_ERROR(
+          std::cerr << "EROWST01 RANGE not supported in LPRowSet::setType()"
+                    << std::endl);
+      throw SPxInternalCodeException("XROWST01 This should never happen.");
+
+    default:
+      throw SPxInternalCodeException("XROWST02 This should never happen.");
+    }
+  }
+
+  /// Returns the value of the \p i'th LPRowBase.
+  const R &value(int i) const {
+    if (rhs(i) < R(infinity))
+      return rhs(i);
+    else {
+      assert(lhs(i) > R(-infinity));
+      return lhs(i);
+    }
+  }
+
+  /// Returns the value of the LPRowBase with DataKey \p k.
+  /** The \em value of a row depends on its type: if the inequality is of type
+   * "greater or equal", the value is the lhs of the row. Otherwise, the value
+   * is the rhs.
+   */
+  const R &value(const DataKey &k) const { return value(number(k)); }
 
-      left[num() - 1] = newlhs;
-      right[num() - 1] = newrhs;
-      object[num() - 1] = newobj;
-      scaleExp[num() - 1] = newscaleExp;
-   }
-
-   ///
-   void add(const LPRowSetBase<R>& newset)
-   {
-      int i = num();
-
-      SVSetBase<R>::add(newset);
-
-      if(num() > left.dim())
-      {
-         left.reDim(num());
-         right.reDim(num());
-         object.reDim(num());
-         scaleExp.reSize(num());
-      }
+  /// Returns the DataKey of the \p i 'th LPRowBase in LPRowSetBase.
+  DataKey key(int i) const { return SVSetBase<R>::key(i); }
 
-      for(int j = 0; i < num(); ++i, ++j)
-      {
-         left[i] = newset.lhs(j);
-         right[i] = newset.rhs(j);
-         object[i] = newset.obj(j);
-         scaleExp[i] = newset.scaleExp[j];
-      }
-   }
-
-   /// Adds all LPRowBase%s of \p set to LPRowSetBase.
-   void add(DataKey keys[], const LPRowSetBase<R>& set)
-   {
-      int i = num();
-
-      add(set);
-
-      for(int j = 0; i < num(); ++i, ++j)
-         keys[j] = key(i);
-   }
-
-   /// Extends row \p n to fit \p newmax nonzeros.
-   void xtend(int n, int newmax)
-   {
-      SVSetBase<R>::xtend(rowVector_w(n), newmax);
-   }
-
-   /// Extends row with DataKey \p key to fit \p newmax nonzeros.
-   void xtend(const DataKey& pkey, int pnewmax)
-   {
-      SVSetBase<R>::xtend(rowVector_w(pkey), pnewmax);
-   }
-
-   /// Adds \p n nonzero (\p idx, \p val)-pairs to rowVector with DataKey \p k.
-   void add2(const DataKey& k, int n, const int idx[], const R val[])
-   {
-      SVSetBase<R>::add2(rowVector_w(k), n, idx, val);
-   }
-
-   /// Adds \p n nonzero (\p idx, \p val)-pairs to \p i 'th rowVector.
-   void add2(int i, int n, const int idx[], const R val[])
-   {
-      SVSetBase<R>::add2(rowVector_w(i), n, idx, val);
-   }
-
-   /// Adds \p n nonzero (\p idx, \p val)-pairs to \p i 'th rowVector.
-   template < class S >
-   void add2(int i, int n, const int idx[], const S val[])
-   {
-      SVSetBase<R>::add2(rowVector_w(i), n, idx, val);
-   }
-
-   /// Creates new LPRowBase with specified parameters and returns a reference to its row vector.
-   SVectorBase<R>& create(int pnonzeros = 0, const R& plhs = 0, const R& prhs = 1, const R& pobj = 0,
-                          const int& pscaleExp = 0)
-   {
-      DataKey k;
-      return create(k, pnonzeros, plhs, prhs, pobj, pscaleExp);
-   }
-
-   /// Creates new LPRowBase with specified parameters and returns a reference to its row vector.
-   SVectorBase<R>& create(DataKey& newkey, int nonzeros = 0, const R& newlhs = 0, const R& newrhs = 1,
-                          const R& newobj = 0, const int& newscaleExp = 0)
-   {
-      if(num() + 1 > left.dim())
-      {
-         left.reDim(num() + 1);
-         right.reDim(num() + 1);
-         object.reDim(num() + 1);
-         scaleExp.reSize(num() + 1);
-      }
+  /// Returns the number of the LPRowBase with DataKey \p k in LPRowSetBase.
+  int number(const DataKey &k) const { return SVSetBase<R>::number(k); }
+
+  /// does DataKey \p k belong to LPRowSetBase ?
+  bool has(const DataKey &k) const { return SVSetBase<R>::has(k); }
 
-      left[num()] = newlhs;
-      right[num()] = newrhs;
-      object[num()] = newobj;
-      scaleExp[num()] = newscaleExp;
-
-      return *SVSetBase<R>::create(newkey, nonzeros);
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Shrinking
-    *
-    *  See DataSet for a description of the renumbering of the remaining LPRowBase%s in a LPRowSetBase after the call of
-    *  a removal method.
-    */
-   ///@{
-
-   /// Removes \p i 'th LPRowBase.
-   void remove(int i)
-   {
-      SVSetBase<R>::remove(i);
-      left[i] = left[num()];
-      right[i] = right[num()];
-      object[i] = object[num()];
-      scaleExp[i] = scaleExp[num()];
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Extension
+   *
+   *  Extension methods come with two signatures, one of them providing a
+   * parameter to return the assigned DataKey(s). See DataSet for a more
+   * detailed description. All extension methods will automatically rearrange or
+   *  allocate more memory if required.
+   */
+  ///@{
+
+  ///
+  void add(const LPRowBase<R> &row) {
+    DataKey k;
+    add(k, row);
+  }
+
+  /// Adds \p row to LPRowSetBase.
+  void add(DataKey &pkey, const LPRowBase<R> &prow) {
+    add(pkey, prow.lhs(), prow.rowVector(), prow.rhs(), prow.obj());
+  }
+
+  /// Adds LPRowBase consisting of left hand side \p lhs, row vector \p
+  /// rowVector, and right hand side \p rhs to LPRowSetBase.
+  void add(const R &plhs, const SVectorBase<R> &prowVector, const R &prhs,
+           const R &pobj = 0, const int &pscaleExp = 0) {
+    DataKey k;
+    add(k, plhs, prowVector, prhs, pobj, pscaleExp);
+  }
+
+  /// Adds LPRowBase consisting of left hand side \p lhs, row vector \p
+  /// rowVector, and right hand side \p rhs to LPRowSetBase.
+  template <class S>
+  void add(const S *lhsValue, const S *rowValues, const int *rowIndices,
+           int rowSize, const S *rhsValue, const S *objValue = 0) {
+    assert(lhsValue != 0);
+    assert(rowSize <= 0 || rowValues != 0);
+    assert(rowSize <= 0 || rowIndices != 0);
+    assert(rhsValue != 0);
+
+    DataKey k;
+    add(k, lhsValue, rowValues, rowIndices, rowSize, rhsValue, objValue);
+  }
+
+  /// Adds LPRowBase consisting of left hand side \p lhs, row vector \p
+  /// rowVector, and right hand side \p rhs to LPRowSetBase, with DataKey \p
+  /// key.
+  template <class S>
+  void add(DataKey &newkey, const S *lhsValue, const S *rowValues,
+           const int *rowIndices, int rowSize, const S *rhsValue,
+           const S *objValue = 0) {
+    assert(lhsValue != 0);
+    assert(rowSize <= 0 || rowValues != 0);
+    assert(rowSize <= 0 || rowIndices != 0);
+    assert(rhsValue != 0);
+
+    SVSetBase<R>::add(newkey, rowValues, rowIndices, rowSize);
+
+    if (num() > left.dim()) {
       left.reDim(num());
       right.reDim(num());
       object.reDim(num());
-      scaleExp.reSize(num());
-   }
-
-   /// Removes LPRowBase with DataKey \p k.
-   void remove(const DataKey& k)
-   {
-      remove(number(k));
-   }
-
-   /// Removes multiple LPRowBase%s.
-   void remove(int perm[])
-   {
-      int j = num();
-
-      SVSetBase<R>::remove(perm);
-
-      for(int i = 0; i < j; ++i)
-      {
-         if(perm[i] >= 0 && perm[i] != i)
-         {
-            left[perm[i]] = left[i];
-            right[perm[i]] = right[i];
-            object[perm[i]] = object[i];
-            scaleExp[perm[i]] = scaleExp[i];
-         }
-      }
+    }
+
+    left[num() - 1] = *lhsValue;
+    right[num() - 1] = *rhsValue;
 
+    if (objValue != 0)
+      object[num() - 1] = *objValue;
+    else
+      object[num() - 1] = 0;
+  }
+
+  /// Adds LPRowBase consisting of left hand side \p lhs, row vector \p
+  /// rowVector, and right hand side \p rhs to LPRowSetBase, with DataKey \p
+  /// key.
+  void add(DataKey &newkey, const R &newlhs, const SVectorBase<R> &newrowVector,
+           const R &newrhs, const R &newobj = 0, const int &newscaleExp = 0) {
+    SVSetBase<R>::add(newkey, newrowVector);
+
+    if (num() > left.dim()) {
       left.reDim(num());
       right.reDim(num());
       object.reDim(num());
       scaleExp.reSize(num());
-   }
-
-   /// Removes \p n LPRowBase%s with row numbers given by \p nums.
-   void remove(const int nums[], int n)
-   {
-      DataArray<int> perm(num());
-      remove(nums, n, perm.get_ptr());
-   }
-
-   /// Removes \p n LPRowBase%s with row numbers given by \p nums,
-   /// Stores permutation of row indices in \p perm.
-   void remove(const int nums[], int n, int* perm)
-   {
-      SVSetBase<R>::remove(nums, n, perm);
-
-      int j = num();
-
-      for(int i = 0; i < j; ++i)
-      {
-         if(perm[i] >= 0 && perm[i] != i)
-         {
-            left[perm[i]] = left[i];
-            right[perm[i]] = right[i];
-            object[perm[i]] = object[i];
-            scaleExp[perm[i]] = scaleExp[i];
-         }
-      }
+    }
+
+    left[num() - 1] = newlhs;
+    right[num() - 1] = newrhs;
+    object[num() - 1] = newobj;
+    scaleExp[num() - 1] = newscaleExp;
+  }
+
+  ///
+  void add(const LPRowSetBase<R> &newset) {
+    int i = num();
 
+    SVSetBase<R>::add(newset);
+
+    if (num() > left.dim()) {
       left.reDim(num());
       right.reDim(num());
       object.reDim(num());
       scaleExp.reSize(num());
-   }
+    }
+
+    for (int j = 0; i < num(); ++i, ++j) {
+      left[i] = newset.lhs(j);
+      right[i] = newset.rhs(j);
+      object[i] = newset.obj(j);
+      scaleExp[i] = newset.scaleExp[j];
+    }
+  }
+
+  /// Adds all LPRowBase%s of \p set to LPRowSetBase.
+  void add(DataKey keys[], const LPRowSetBase<R> &set) {
+    int i = num();
+
+    add(set);
+
+    for (int j = 0; i < num(); ++i, ++j)
+      keys[j] = key(i);
+  }
+
+  /// Extends row \p n to fit \p newmax nonzeros.
+  void xtend(int n, int newmax) { SVSetBase<R>::xtend(rowVector_w(n), newmax); }
+
+  /// Extends row with DataKey \p key to fit \p newmax nonzeros.
+  void xtend(const DataKey &pkey, int pnewmax) {
+    SVSetBase<R>::xtend(rowVector_w(pkey), pnewmax);
+  }
+
+  /// Adds \p n nonzero (\p idx, \p val)-pairs to rowVector with DataKey \p k.
+  void add2(const DataKey &k, int n, const int idx[], const R val[]) {
+    SVSetBase<R>::add2(rowVector_w(k), n, idx, val);
+  }
+
+  /// Adds \p n nonzero (\p idx, \p val)-pairs to \p i 'th rowVector.
+  void add2(int i, int n, const int idx[], const R val[]) {
+    SVSetBase<R>::add2(rowVector_w(i), n, idx, val);
+  }
+
+  /// Adds \p n nonzero (\p idx, \p val)-pairs to \p i 'th rowVector.
+  template <class S> void add2(int i, int n, const int idx[], const S val[]) {
+    SVSetBase<R>::add2(rowVector_w(i), n, idx, val);
+  }
+
+  /// Creates new LPRowBase with specified parameters and returns a reference to
+  /// its row vector.
+  SVectorBase<R> &create(int pnonzeros = 0, const R &plhs = 0,
+                         const R &prhs = 1, const R &pobj = 0,
+                         const int &pscaleExp = 0) {
+    DataKey k;
+    return create(k, pnonzeros, plhs, prhs, pobj, pscaleExp);
+  }
+
+  /// Creates new LPRowBase with specified parameters and returns a reference to
+  /// its row vector.
+  SVectorBase<R> &create(DataKey &newkey, int nonzeros = 0, const R &newlhs = 0,
+                         const R &newrhs = 1, const R &newobj = 0,
+                         const int &newscaleExp = 0) {
+    if (num() + 1 > left.dim()) {
+      left.reDim(num() + 1);
+      right.reDim(num() + 1);
+      object.reDim(num() + 1);
+      scaleExp.reSize(num() + 1);
+    }
+
+    left[num()] = newlhs;
+    right[num()] = newrhs;
+    object[num()] = newobj;
+    scaleExp[num()] = newscaleExp;
+
+    return *SVSetBase<R>::create(newkey, nonzeros);
+  }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Shrinking
+   *
+   *  See DataSet for a description of the renumbering of the remaining
+   * LPRowBase%s in a LPRowSetBase after the call of a removal method.
+   */
+  ///@{
+
+  /// Removes \p i 'th LPRowBase.
+  void remove(int i) {
+    SVSetBase<R>::remove(i);
+    left[i] = left[num()];
+    right[i] = right[num()];
+    object[i] = object[num()];
+    scaleExp[i] = scaleExp[num()];
+    left.reDim(num());
+    right.reDim(num());
+    object.reDim(num());
+    scaleExp.reSize(num());
+  }
+
+  /// Removes LPRowBase with DataKey \p k.
+  void remove(const DataKey &k) { remove(number(k)); }
+
+  /// Removes multiple LPRowBase%s.
+  void remove(int perm[]) {
+    int j = num();
+
+    SVSetBase<R>::remove(perm);
+
+    for (int i = 0; i < j; ++i) {
+      if (perm[i] >= 0 && perm[i] != i) {
+        left[perm[i]] = left[i];
+        right[perm[i]] = right[i];
+        object[perm[i]] = object[i];
+        scaleExp[perm[i]] = scaleExp[i];
+      }
+    }
+
+    left.reDim(num());
+    right.reDim(num());
+    object.reDim(num());
+    scaleExp.reSize(num());
+  }
+
+  /// Removes \p n LPRowBase%s with row numbers given by \p nums.
+  void remove(const int nums[], int n) {
+    DataArray<int> perm(num());
+    remove(nums, n, perm.get_ptr());
+  }
+
+  /// Removes \p n LPRowBase%s with row numbers given by \p nums,
+  /// Stores permutation of row indices in \p perm.
+  void remove(const int nums[], int n, int *perm) {
+    SVSetBase<R>::remove(nums, n, perm);
+
+    int j = num();
+
+    for (int i = 0; i < j; ++i) {
+      if (perm[i] >= 0 && perm[i] != i) {
+        left[perm[i]] = left[i];
+        right[perm[i]] = right[i];
+        object[perm[i]] = object[i];
+        scaleExp[perm[i]] = scaleExp[i];
+      }
+    }
+
+    left.reDim(num());
+    right.reDim(num());
+    object.reDim(num());
+    scaleExp.reSize(num());
+  }
+
+  /// Removes all LPRowBase%s.
+  void clear() {
+    SVSetBase<R>::clear();
+    left.reDim(num());
+    right.reDim(num());
+    object.reDim(num());
+    scaleExp.clear();
+  }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Memory Management
+   *
+   *  For a description of the memory management methods, see the documentation
+   * of SVSet, which has been used for implementating LPRowSetBase.
+   */
+  ///@{
 
-   /// Removes all LPRowBase%s.
-   void clear()
-   {
-      SVSetBase<R>::clear();
-      left.reDim(num());
-      right.reDim(num());
-      object.reDim(num());
-      scaleExp.clear();
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Memory Management
-    *
-    *  For a description of the memory management methods, see the documentation of SVSet, which has been used for
-    *  implementating LPRowSetBase.
-    */
-   ///@{
-
-   /// Reallocates memory to be able to store \p newmax LPRowBase%s.
-   void reMax(int newmax = 0)
-   {
-      SVSetBase<R>::reMax(newmax);
-      left.reSize(max());
-      right.reSize(max());
-      object.reSize(max());
-      scaleExp.reSize(max());
-   }
-
-   /// Returns number of used nonzero entries.
-   int memSize() const
-   {
-      return SVSetBase<R>::memSize();
-   }
-
-   /// Returns length of nonzero memory.
-   int memMax() const
-   {
-      return SVSetBase<R>::memMax();
-   }
-
-   /// Reallocates memory to be able to store \p newmax nonzeros.
-   void memRemax(int newmax)
-   {
-      SVSetBase<R>::memRemax(newmax);
-   }
-
-   /// Garbage collection in nonzero memory.
-   void memPack()
-   {
-      SVSetBase<R>::memPack();
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Consistency check */
-
-   /// Checks consistency.
-   bool isConsistent() const
-   {
+  /// Reallocates memory to be able to store \p newmax LPRowBase%s.
+  void reMax(int newmax = 0) {
+    SVSetBase<R>::reMax(newmax);
+    left.reSize(max());
+    right.reSize(max());
+    object.reSize(max());
+    scaleExp.reSize(max());
+  }
+
+  /// Returns number of used nonzero entries.
+  int memSize() const { return SVSetBase<R>::memSize(); }
+
+  /// Returns length of nonzero memory.
+  int memMax() const { return SVSetBase<R>::memMax(); }
+
+  /// Reallocates memory to be able to store \p newmax nonzeros.
+  void memRemax(int newmax) { SVSetBase<R>::memRemax(newmax); }
+
+  /// Garbage collection in nonzero memory.
+  void memPack() { SVSetBase<R>::memPack(); }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Consistency check */
+
+  /// Checks consistency.
+  bool isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
-      const int ldim = left.dim();
+    const int ldim = left.dim();
 
-      if(ldim != right.dim())
-         return MSGinconsistent("LPRowSetBase");
+    if (ldim != right.dim())
+      return MSGinconsistent("LPRowSetBase");
 
-      if(ldim != object.dim())
-         return MSGinconsistent("LPRowSetBase");
+    if (ldim != object.dim())
+      return MSGinconsistent("LPRowSetBase");
 
-      if(ldim != num())
-         return MSGinconsistent("LPRowSetBase");
+    if (ldim != num())
+      return MSGinconsistent("LPRowSetBase");
 
-      return SVSetBase<R>::isConsistent();
+    return SVSetBase<R>::isConsistent();
 #else
-      return true;
+    return true;
 #endif
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Construction / Destruction */
-   ///@{
-
-   /// Default constructor.
-   /** The user can specify the initial maximum number of rows \p max and the initial maximum number of nonzero entries
-    *  \p memmax. If these parameters are omitted, a default size is used. However, one can add an arbitrary number of
-    *  rows to the LPRowSetBase, which may result in automated memory realllocation.
-    */
-   explicit
-   LPRowSetBase<R>(int pmax = -1, int pmemmax = -1)
-      : SVSetBase<R>(pmax, pmemmax), left(0), right(0), object(0), scaleExp(0)
-   {
-      assert(isConsistent());
-   }
-
-   /// Assignment operator.
-   LPRowSetBase<R>& operator=(const LPRowSetBase<R>& rs)
-   {
-      if(this != &rs)
-      {
-         SVSetBase<R>::operator=(rs);
-         left = rs.left;
-         right = rs.right;
-         object = rs.object;
-         scaleExp = rs.scaleExp;
-
-         assert(isConsistent());
-      }
+  }
 
-      return *this;
-   }
-
-   /// Assignment operator.
-   template < class S >
-   LPRowSetBase<R>& operator=(const LPRowSetBase<S>& rs)
-   {
-      if(this != (const LPRowSetBase<R>*)(&rs))
-      {
-         SVSetBase<R>::operator=(rs);
-         left = rs.left;
-         right = rs.right;
-         object = rs.object;
-         scaleExp = rs.scaleExp;
-
-         assert(isConsistent());
-      }
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Construction / Destruction */
+  ///@{
+
+  /// Default constructor.
+  /** The user can specify the initial maximum number of rows \p max and the
+   * initial maximum number of nonzero entries \p memmax. If these parameters
+   * are omitted, a default size is used. However, one can add an arbitrary
+   * number of rows to the LPRowSetBase, which may result in automated memory
+   * realllocation.
+   */
+  explicit LPRowSetBase(int pmax = -1, int pmemmax = -1)
+      : SVSetBase<R>(pmax, pmemmax), left(0), right(0), object(0), scaleExp(0) {
+    assert(isConsistent());
+  }
+
+  /// Assignment operator.
+  LPRowSetBase<R> &operator=(const LPRowSetBase<R> &rs) {
+    if (this != &rs) {
+      SVSetBase<R>::operator=(rs);
+      left = rs.left;
+      right = rs.right;
+      object = rs.object;
+      scaleExp = rs.scaleExp;
 
-      return *this;
-   }
-
-   /// Copy constructor.
-   LPRowSetBase<R>(const LPRowSetBase<R>& rs)
-      : SVSetBase<R>(rs)
-      , left(rs.left)
-      , right(rs.right)
-      , object(rs.object)
-      , scaleExp(rs.scaleExp)
-   {
-      assert(isConsistent());
-   }
-
-   /// Copy constructor.
-   template < class S >
-   LPRowSetBase<R>(const LPRowSetBase<S>& rs)
-      : SVSetBase<R>(rs)
-      , left(rs.left)
-      , right(rs.right)
-      , object(rs.object)
-      , scaleExp(rs.scaleExp)
-   {
       assert(isConsistent());
-   }
+    }
 
-   /// Destructor.
-   virtual ~LPRowSetBase<R>()
-   {}
+    return *this;
+  }
 
-   ///@}
+  /// Assignment operator.
+  template <class S> LPRowSetBase<R> &operator=(const LPRowSetBase<S> &rs) {
+    if (this != (const LPRowSetBase<R> *)(&rs)) {
+      SVSetBase<R>::operator=(rs);
+      left = rs.left;
+      right = rs.right;
+      object = rs.object;
+      scaleExp = rs.scaleExp;
+
+      assert(isConsistent());
+    }
+
+    return *this;
+  }
+
+  /// Copy constructor.
+  LPRowSetBase(const LPRowSetBase<R> &rs)
+      : SVSetBase<R>(rs), left(rs.left), right(rs.right), object(rs.object),
+        scaleExp(rs.scaleExp) {
+    assert(isConsistent());
+  }
+
+  /// Copy constructor.
+  template <class S>
+  LPRowSetBase(const LPRowSetBase<S> &rs)
+      : SVSetBase<R>(rs), left(rs.left), right(rs.right), object(rs.object),
+        scaleExp(rs.scaleExp) {
+    assert(isConsistent());
+  }
+
+  /// Destructor.
+  virtual ~LPRowSetBase() {}
+
+  ///@}
 };
 } // namespace soplex
 #endif // _LPROWSETBASE_H_
diff --git a/src/soplex/ratrecon.hpp b/src/soplex/ratrecon.hpp
index f62c0b2..d8e5fda 100644
--- a/src/soplex/ratrecon.hpp
+++ b/src/soplex/ratrecon.hpp
@@ -21,228 +21,222 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
-#include <iostream>
 #include <assert.h>
+#include <iostream>
 
-#include "soplex/spxdefines.h"
 #include "soplex/rational.h"
+#include "soplex/spxdefines.h"
 
-namespace soplex
-{
+namespace soplex {
 
-/** this reconstruction routine will set x equal to the mpq vector where each component is the best rational
- *  approximation of xnum / denom with where the GCD of denominators of x is at most Dbound; it will return true on
- *  success and false if more accuracy is required: specifically if componentwise rational reconstruction does not
- *  produce such a vector
+/** this reconstruction routine will set x equal to the mpq vector where each
+ * component is the best rational approximation of xnum / denom with where the
+ * GCD of denominators of x is at most Dbound; it will return true on success
+ * and false if more accuracy is required: specifically if componentwise
+ * rational reconstruction does not produce such a vector
  */
-static int Reconstruct(VectorRational& resvec, Integer* xnum, Integer denom, int dim,
-                       const Rational& denomBoundSquared, const DIdxSet* indexSet = 0)
-{
-   bool rval = true;
-   int done = 0;
-
-   /* denominator must be positive */
-   assert(denom > 0);
-   assert(denomBoundSquared > 0);
-
-   Integer temp = 0;
-   Integer td = 0;
-   Integer tn = 0;
-   Integer Dbound = 0;
-   Integer gcd = 1;
-
-   Dbound = numerator(denomBoundSquared) / denominator(
-               denomBoundSquared); /* this is the working bound on the denominator size */
-
-   Dbound = (Integer) sqrt(Dbound);
-
-   MSG_DEBUG(std::cout << "reconstructing " << dim << " dimensional vector with denominator bound " <<
-             Dbound << "\n");
-
-   /* if Dbound is below 2^24 increase it to this value, this avoids changing input vectors that have low denominator
-    * because they are floating point representable
-    */
-   if(Dbound < 16777216)
-      Dbound = 16777216;
-
-   /* The following represent a_i, the cont frac representation and p_i/q_i, the convergents */
-   Integer a0 = 0;
-   Integer ai = 0;
-
-   /* here we use p[2]=pk, p[1]=pk-1,p[0]=pk-2 and same for q */
-   Integer p[3];
-   Integer q[3];
-
-   for(int c = 0; (indexSet == 0 && c < dim) || (indexSet != 0 && c < indexSet->size()); c++)
-   {
-      int j = (indexSet == 0 ? c : indexSet->index(c));
-
-      assert(j >= 0);
-      assert(j < dim);
-
-      MSG_DEBUG(std::cout << "  --> component " << j << " = " << &xnum[j] << " / denom\n");
-
-      /* if xnum =0 , then just leave x[j] as zero */
-      if(xnum[j] != 0)
-      {
-         /* setup n and d for computing a_i the cont. frac. rep */
-         tn = xnum[j];
-         td = denom;
-
-         /* divide tn and td by gcd */
-         SpxGcd(temp, tn, td);
-         tn = tn / temp;
-         td = td / temp;
-
-         if(td <= Dbound)
-         {
-            MSG_DEBUG(std::cout << "marker 1\n");
-
-            resvec[j] = Rational(tn, td);
-         }
-         else
-         {
-            MSG_DEBUG(std::cout << "marker 2\n");
+static int Reconstruct(VectorRational &resvec, Integer *xnum, Integer denom,
+                       int dim, const Rational &denomBoundSquared,
+                       const DIdxSet *indexSet = 0) {
+  bool rval = true;
+  int done = 0;
 
-            temp = 1;
+  /* denominator must be positive */
+  assert(denom > 0);
+  assert(denomBoundSquared > 0);
 
-            divide_qr(tn, td, a0, temp);
+  Integer temp = 0;
+  Integer td = 0;
+  Integer tn = 0;
+  Integer Dbound = 0;
+  Integer gcd = 1;
+
+  Dbound = numerator(denomBoundSquared) /
+           denominator(denomBoundSquared); /* this is the working bound on the
+                                              denominator size */
+
+  Dbound = (Integer)sqrt(Dbound);
 
-            tn = td;
-            td = temp;
+  MSG_DEBUG(std::cout << "reconstructing " << dim
+                      << " dimensional vector with denominator bound " << Dbound
+                      << "\n");
 
-            divide_qr(tn, td, ai, temp);
-            tn = td;
-            td = temp;
+  /* if Dbound is below 2^24 increase it to this value, this avoids changing
+   * input vectors that have low denominator because they are floating point
+   * representable
+   */
+  if (Dbound < 16777216)
+    Dbound = 16777216;
 
-            p[1] = a0;
-            p[2] = 1;
-            p[2] += a0 * ai;
+  /* The following represent a_i, the cont frac representation and p_i/q_i, the
+   * convergents */
+  Integer a0 = 0;
+  Integer ai = 0;
 
-            q[1] = 1;
-            q[2] = ai;
+  /* here we use p[2]=pk, p[1]=pk-1,p[0]=pk-2 and same for q */
+  Integer p[3];
+  Integer q[3];
 
-            done = 0;
+  for (int c = 0;
+       (indexSet == 0 && c < dim) || (indexSet != 0 && c < indexSet->size());
+       c++) {
+    int j = (indexSet == 0 ? c : indexSet->index(c));
+
+    assert(j >= 0);
+    assert(j < dim);
+
+    MSG_DEBUG(std::cout << "  --> component " << j << " = " << &xnum[j]
+                        << " / denom\n");
+
+    /* if xnum =0 , then just leave x[j] as zero */
+    if (xnum[j] != 0) {
+      /* setup n and d for computing a_i the cont. frac. rep */
+      tn = xnum[j];
+      td = denom;
+
+      /* divide tn and td by gcd */
+      SpxGcd(temp, tn, td);
+      tn = tn / temp;
+      td = td / temp;
+
+      if (td <= Dbound) {
+        MSG_DEBUG(std::cout << "marker 1\n");
+
+        resvec[j] = Rational(tn, td);
+      } else {
+        MSG_DEBUG(std::cout << "marker 2\n");
+
+        temp = 1;
+
+        divide_qr(tn, td, a0, temp);
+
+        tn = td;
+        td = temp;
+
+        divide_qr(tn, td, ai, temp);
+        tn = td;
+        td = temp;
+
+        p[1] = a0;
+        p[2] = 1;
+        p[2] += a0 * ai;
+
+        q[1] = 1;
+        q[2] = ai;
+
+        done = 0;
+
+        /* if q is already big, skip loop */
+        if (q[2] > Dbound) {
+          MSG_DEBUG(std::cout << "marker 3\n");
+          done = 1;
+        }
+
+        int cfcnt = 2;
+
+        while (!done && td != 0) {
+          /* update everything: compute next ai, then update convergents */
+
+          /* update ai */
+          divide_qr(tn, td, ai, temp);
+          tn = td;
+          td = temp;
 
-            /* if q is already big, skip loop */
-            if(q[2] > Dbound)
-            {
-               MSG_DEBUG(std::cout << "marker 3\n");
-               done = 1;
-            }
+          /* shift p,q */
+          q[0] = q[1];
+          q[1] = q[2];
+          p[0] = p[1];
+          p[1] = p[2];
 
-            int cfcnt = 2;
+          /* compute next p,q */
+          p[2] = p[0];
+          p[2] += p[1] * ai;
+          q[2] = q[0];
+          q[2] += q[1] * ai;
 
-            while(!done && td != 0)
-            {
-               /* update everything: compute next ai, then update convergents */
+          if (q[2] > Dbound)
+            done = 1;
 
-               /* update ai */
-               divide_qr(tn, td, ai, temp);
-               tn = td;
-               td = temp;
+          cfcnt++;
 
-               /* shift p,q */
-               q[0] = q[1];
-               q[1] =  q[2];
-               p[0] =  p[1];
-               p[1] =  p[2];
+          MSG_DEBUG(std::cout << "  --> convergent denominator = " << &q[2]
+                              << "\n");
+        }
 
-               /* compute next p,q */
-               p[2] =  p[0];
-               p[2] += p[1] * ai;
-               q[2] =  q[0];
-               q[2] += q[1] * ai;
+        assert(q[1] != 0);
 
-               if(q[2] > Dbound)
-                  done = 1;
+        /* Assign the values */
+        if (q[1] >= 0)
+          resvec[j] = Rational(p[1], q[1]);
+        else
+          resvec[j] = Rational(-p[1], -q[1]);
 
-               cfcnt++;
+        SpxGcd(temp, gcd, denominator(resvec[j]));
+        gcd *= temp;
 
-               MSG_DEBUG(std::cout << "  --> convergent denominator = " << &q[2] << "\n");
-            }
-
-            assert(q[1] != 0);
-
-            /* Assign the values */
-            if(q[1] >= 0)
-               resvec[j] = Rational(p[1], q[1]);
-            else
-               resvec[j] = Rational(-p[1], -q[1]);
-
-            SpxGcd(temp, gcd, denominator(resvec[j]));
-            gcd *= temp;
-
-            if(gcd > Dbound)
-            {
-               MSG_DEBUG(std::cout << "terminating with gcd " << &gcd << " exceeding Dbound " << &Dbound << "\n");
-               rval = false;
-               break;
-            }
-         }
+        if (gcd > Dbound) {
+          MSG_DEBUG(std::cout << "terminating with gcd " << &gcd
+                              << " exceeding Dbound " << &Dbound << "\n");
+          rval = false;
+          break;
+        }
       }
-   }
+    }
+  }
 
-   return rval;
+  return rval;
 }
 
 /** reconstruct a rational vector */
-inline bool reconstructVector(VectorRational& input, const Rational& denomBoundSquared,
-                              const DIdxSet* indexSet)
-{
-   std::vector<Integer> xnum(input.dim()); /* numerator of input vector */
-   Integer denom = 1; /* common denominator of input vector */
-   int rval = true;
-   int dim;
-
-   dim = input.dim();
-
-   /* find common denominator */
-   if(indexSet == 0)
-   {
-      for(int i = 0; i < dim; i++)
-         SpxLcm(denom, denom, denominator(input[i]));
-
-      for(int i = 0; i < dim; i++)
-      {
-         xnum[i] = denom * Integer(numerator(input[i]));
-         xnum[i] = xnum[i] / Integer(denominator(input[i]));
-      }
-   }
-   else
-   {
-      for(int i = 0; i < indexSet->size(); i++)
-      {
-         assert(indexSet->index(i) >= 0);
-         assert(indexSet->index(i) < input.dim());
-         SpxLcm(denom, denom, denominator(input[indexSet->index(i)]));
-      }
-
-      for(int i = 0; i < indexSet->size(); i++)
-      {
-         int k = indexSet->index(i);
-         assert(k >= 0);
-         assert(k < input.dim());
-         xnum[k] = denom * Integer(numerator(input[k]));
-         xnum[k] = xnum[k] / Integer(denominator(input[k]));
-      }
-   }
-
-   MSG_DEBUG(std::cout << "LCM = " << mpz_get_str(0, 10, denom) << "\n");
-
-   /* reconstruct */
-   rval = Reconstruct(input, xnum.data(), denom, dim, denomBoundSquared, indexSet);
-
-   return rval;
+inline bool reconstructVector(VectorRational &input,
+                              const Rational &denomBoundSquared,
+                              const DIdxSet *indexSet) {
+  std::vector<Integer> xnum(input.dim()); /* numerator of input vector */
+  Integer denom = 1; /* common denominator of input vector */
+  int rval = true;
+  int dim;
+
+  dim = input.dim();
+
+  /* find common denominator */
+  if (indexSet == 0) {
+    for (int i = 0; i < dim; i++)
+      SpxLcm(denom, denom, denominator(input[i]));
+
+    for (int i = 0; i < dim; i++) {
+      xnum[i] = denom * Integer(numerator(input[i]));
+      xnum[i] = xnum[i] / Integer(denominator(input[i]));
+    }
+  } else {
+    for (int i = 0; i < indexSet->size(); i++) {
+      assert(indexSet->index(i) >= 0);
+      assert(indexSet->index(i) < input.dim());
+      SpxLcm(denom, denom, denominator(input[indexSet->index(i)]));
+    }
+
+    for (int i = 0; i < indexSet->size(); i++) {
+      int k = indexSet->index(i);
+      assert(k >= 0);
+      assert(k < input.dim());
+      xnum[k] = denom * Integer(numerator(input[k]));
+      xnum[k] = xnum[k] / Integer(denominator(input[k]));
+    }
+  }
+
+  MSG_DEBUG(std::cout << "LCM = " << mpz_get_str(0, 10, denom) << "\n");
+
+  /* reconstruct */
+  rval =
+      Reconstruct(input, xnum.data(), denom, dim, denomBoundSquared, indexSet);
+
+  return rval;
 }
 
-
-
 /** reconstruct a rational solution */
 /**@todo make this a method of class SoPlex */
-inline bool reconstructSol(SolRational& solution)
-{
+inline bool reconstructSol(SolRational &solution) {
 #if 0
    VectorRational buffer;
 
@@ -289,6 +283,6 @@ inline bool reconstructSol(SolRational& solution)
    }
 
 #endif
-   return true;
+  return true;
 }
 } // namespace soplex
diff --git a/src/soplex/slufactor.h b/src/soplex/slufactor.h
index f92f3d3..192efdf 100644
--- a/src/soplex/slufactor.h
+++ b/src/soplex/slufactor.h
@@ -30,15 +30,14 @@
 
 #include <assert.h>
 
+#include "soplex/clufactor.h"
+#include "soplex/slinsolver.h"
 #include "soplex/spxdefines.h"
 #include "soplex/timerfactory.h"
-#include "soplex/slinsolver.h"
-#include "soplex/clufactor.h"
 
-namespace soplex
-{
+namespace soplex {
 /// maximum nr. of factorization updates allowed before refactorization.
-#define MAXUPDATES      1000
+#define MAXUPDATES 1000
 
 /**@brief   Implementation of Sparse Linear Solver.
  * @ingroup Algo
@@ -47,290 +46,251 @@ namespace soplex
  * factorization implemented in CLUFactor.
  */
 template <class R>
-class SLUFactor : public SLinSolver<R>, protected CLUFactor<R>
-{
+class SLUFactor : public SLinSolver<R>, protected CLUFactor<R> {
 public:
-
-   //--------------------------------
-   /**@name Types */
-   ///@{
-   /// Specifies how to perform \ref soplex::SLUFactor<R>::change "change" method.
-   enum UpdateType
-   {
-      ETA = 0,       ///<
-      FOREST_TOMLIN  ///<
-   };
-   /// for convenience
-   using Status = typename SLinSolver<R>::Status;
-   ///@}
+  //--------------------------------
+  /**@name Types */
+  ///@{
+  /// Specifies how to perform \ref soplex::SLUFactor<R>::change "change"
+  /// method.
+  enum UpdateType {
+    ETA = 0,      ///<
+    FOREST_TOMLIN ///<
+  };
+  /// for convenience
+  using Status = typename SLinSolver<R>::Status;
+  ///@}
 
 private:
-
-   //--------------------------------
-   /**@name Private data */
-   ///@{
-   VectorBase<R>    vec;           ///< Temporary VectorBase<R>
-   SSVectorBase<R>    ssvec;         ///< Temporary semi-sparse VectorBase<R>
-   ///@}
+  //--------------------------------
+  /**@name Private data */
+  ///@{
+  VectorBase<R> vec;     ///< Temporary VectorBase<R>
+  SSVectorBase<R> ssvec; ///< Temporary semi-sparse VectorBase<R>
+                         ///@}
 
 protected:
+  //--------------------------------
+  /**@name Protected data */
+  ///@{
+  bool usetup;            ///< TRUE iff update vector has been setup
+  UpdateType uptype;      ///< the current \ref soplex::SLUFactor<R>::UpdateType
+                          ///< "UpdateType".
+  SSVectorBase<R> eta;    ///<
+  SSVectorBase<R> forest; ///< ? Update VectorBase<R> set up by
+                          ///< solveRight4update() and solve2right4update()
+  R lastThreshold;        ///< pivoting threshold of last factorization
+  ///@}
 
-   //--------------------------------
-   /**@name Protected data */
-   ///@{
-   bool       usetup;        ///< TRUE iff update vector has been setup
-   UpdateType uptype;        ///< the current \ref soplex::SLUFactor<R>::UpdateType "UpdateType".
-   SSVectorBase<R>    eta;           ///<
-   SSVectorBase<R>
-   forest;        ///< ? Update VectorBase<R> set up by solveRight4update() and solve2right4update()
-   R       lastThreshold; ///< pivoting threshold of last factorization
-   ///@}
-
-   //--------------------------------
-   /**@name Control Parameters */
-   ///@{
-   /// minimum threshold to use.
-   R minThreshold;
-   /// minimum stability to achieve by setting threshold.
-   R minStability;
-   /// |x| < epsililon is considered to be 0.
-   R epsilon;
-   /// Time spent in solves
-   Timer* solveTime;
-   Timer::TYPE timerType;
-   /// Number of solves
-   int     solveCount;
-   ///@}
+  //--------------------------------
+  /**@name Control Parameters */
+  ///@{
+  /// minimum threshold to use.
+  R minThreshold;
+  /// minimum stability to achieve by setting threshold.
+  R minStability;
+  /// |x| < epsililon is considered to be 0.
+  R epsilon;
+  /// Time spent in solves
+  Timer *solveTime;
+  Timer::TYPE timerType;
+  /// Number of solves
+  int solveCount;
+  ///@}
 
 protected:
-
-   //--------------------------------
-   /**@name Protected helpers */
-   ///@{
-   ///
-   void freeAll();
-   ///
-   void changeEta(int idx, SSVectorBase<R>& eta);
-   ///@}
-
+  //--------------------------------
+  /**@name Protected helpers */
+  ///@{
+  ///
+  void freeAll();
+  ///
+  void changeEta(int idx, SSVectorBase<R> &eta);
+  ///@}
 
 public:
+  //--------------------------------
+  /**@name Update type */
+  ///@{
+  /// returns the current update type uptype.
+  UpdateType utype() const { return uptype; }
 
-   //--------------------------------
-   /**@name Update type */
-   ///@{
-   /// returns the current update type uptype.
-   UpdateType utype() const
-   {
-      return uptype;
-   }
-
-   /// sets update type.
-   /** The new UpdateType becomes valid only after the next call to
-       method load().
-   */
-   void setUtype(UpdateType tp)
-   {
-      uptype = tp;
-   }
+  /// sets update type.
+  /** The new UpdateType becomes valid only after the next call to
+      method load().
+  */
+  void setUtype(UpdateType tp) { uptype = tp; }
 
-   /// sets minimum Markowitz threshold.
-   void setMarkowitz(R m)
-   {
-      if(m < 0.0001)
-         m = 0.0001;
+  /// sets minimum Markowitz threshold.
+  void setMarkowitz(R m) {
+    if (m < 0.0001)
+      m = 0.0001;
 
-      if(m > 0.9999)
-         m = 0.9999;
+    if (m > 0.9999)
+      m = 0.9999;
 
-      minThreshold = m;
-      lastThreshold = m;
-   }
+    minThreshold = m;
+    lastThreshold = m;
+  }
 
-   /// returns Markowitz threshold.
-   R markowitz()
-   {
-      return lastThreshold;
-   }
-   ///@}
+  /// returns Markowitz threshold.
+  R markowitz() { return lastThreshold; }
+  ///@}
 
-   //--------------------------------
-   /**@name Derived from SLinSolver
-      See documentation of \ref soplex::SLinSolver "SLinSolver" for a
-      documentation of these methods.
+  //--------------------------------
+  /**@name Derived from SLinSolver
+     See documentation of \ref soplex::SLinSolver "SLinSolver" for a
+     documentation of these methods.
+  */
+  ///@{
+  ///
+  void clear();
+  ///
+  int dim() const { return this->thedim; }
+  ///
+  int memory() const {
+    return this->nzCnt + this->l.start[this->l.firstUnused];
+  }
+  ///
+  const char *getName() const {
+    return (uptype == SLUFactor<R>::ETA) ? "SLU-Eta" : "SLU-Forest-Tomlin";
+  }
+  ///
+  Status status() const { return Status(this->stat); }
+  ///
+  R stability() const;
+  /** return one of several matrix metrics based on the diagonal of U
+   * 0: condition number estimate by ratio of min/max
+   * 1: trace (sum of diagonal elements)
+   * 2: determinant (product of diagonal elements)
    */
-   ///@{
-   ///
-   void clear();
-   ///
-   int dim() const
-   {
-      return this->thedim;
-   }
-   ///
-   int memory() const
-   {
-      return this->nzCnt + this->l.start[this->l.firstUnused];
-   }
-   ///
-   const char* getName() const
-   {
-      return (uptype == SLUFactor<R>::ETA) ? "SLU-Eta" : "SLU-Forest-Tomlin";
-   }
-   ///
-   Status status() const
-   {
-      return Status(this->stat);
-   }
-   ///
-   R stability() const;
-   /** return one of several matrix metrics based on the diagonal of U
-    * 0: condition number estimate by ratio of min/max
-    * 1: trace (sum of diagonal elements)
-    * 2: determinant (product of diagonal elements)
-    */
-   R matrixMetric(int type = 0) const;
-   ///
-   std::string statistics() const;
-   ///
-   Status load(const SVectorBase<R>* vec[], int dim);
-   ///@}
+  R matrixMetric(int type = 0) const;
+  ///
+  std::string statistics() const;
+  ///
+  Status load(const SVectorBase<R> *vec[], int dim);
+  ///@}
 
 public:
+  //--------------------------------
+  /**@name Solve */
+  ///@{
+  /// Solves \f$Ax=b\f$.
+  void solveRight(VectorBase<R> &x, const VectorBase<R> &b);
+  void solveRight(SSVectorBase<R> &x, const SSVectorBase<R> &b) {
+    x.unSetup();
+    solveRight((VectorBase<R> &)x, (const VectorBase<R> &)b);
+  }
+  /// Solves \f$Ax=b\f$.
+  void solveRight(SSVectorBase<R> &x, const SVectorBase<R> &b);
+  /// Solves \f$Ax=b\f$.
+  void solveRight4update(SSVectorBase<R> &x, const SVectorBase<R> &b);
+  /// Solves \f$Ax=b\f$ and \f$Ay=d\f$.
+  void solve2right4update(SSVectorBase<R> &x, VectorBase<R> &y,
+                          const SVectorBase<R> &b, SSVectorBase<R> &d);
+  /// Sparse version of solving two systems of equations
+  void solve2right4update(SSVectorBase<R> &x, SSVectorBase<R> &y,
+                          const SVectorBase<R> &b, SSVectorBase<R> &d);
+  /// Solves \f$Ax=b\f$, \f$Ay=d\f$ and \f$Az=e\f$.
+  void solve3right4update(SSVectorBase<R> &x, VectorBase<R> &y,
+                          VectorBase<R> &z, const SVectorBase<R> &b,
+                          SSVectorBase<R> &d, SSVectorBase<R> &e);
+  /// sparse version of solving three systems of equations
+  void solve3right4update(SSVectorBase<R> &x, SSVectorBase<R> &y,
+                          SSVectorBase<R> &z, const SVectorBase<R> &b,
+                          SSVectorBase<R> &d, SSVectorBase<R> &e);
+  /// sparse version of solving one system of equations with transposed basis
+  /// matrix
+  void solveLeft(VectorBase<R> &x, const VectorBase<R> &b);
+  void solveLeft(SSVectorBase<R> &x, const SSVectorBase<R> &b) {
+    x.unSetup();
+    solveLeft((VectorBase<R> &)x, (const VectorBase<R> &)b);
+  }
+  /// Solves \f$Ax=b\f$.
+  void solveLeft(SSVectorBase<R> &x, const SVectorBase<R> &b);
+  /// Solves \f$Ax=b\f$ and \f$Ay=d\f$.
+  void solveLeft(SSVectorBase<R> &x, VectorBase<R> &y, const SVectorBase<R> &b,
+                 SSVectorBase<R> &d);
+  /// sparse version of solving two systems of equations with transposed basis
+  /// matrix
+  void solveLeft(SSVectorBase<R> &x, SSVectorBase<R> &two,
+                 const SVectorBase<R> &b, SSVectorBase<R> &rhs2);
+  /// Solves \f$Ax=b\f$, \f$Ay=d\f$ and \f$Az=e\f$.
+  void solveLeft(SSVectorBase<R> &x, VectorBase<R> &y, VectorBase<R> &z,
+                 const SVectorBase<R> &b, SSVectorBase<R> &d,
+                 SSVectorBase<R> &e);
+  /// sparse version of solving three systems of equations with transposed basis
+  /// matrix
+  void solveLeft(SSVectorBase<R> &x, SSVectorBase<R> &y, SSVectorBase<R> &z,
+                 const SVectorBase<R> &b, SSVectorBase<R> &d,
+                 SSVectorBase<R> &e);
+  ///
+  Status change(int idx, const SVectorBase<R> &subst,
+                const SSVectorBase<R> *eta = 0);
+  ///@}
 
-   //--------------------------------
-   /**@name Solve */
-   ///@{
-   /// Solves \f$Ax=b\f$.
-   void solveRight(VectorBase<R>& x, const VectorBase<R>& b);
-   void solveRight(SSVectorBase<R>& x, const SSVectorBase<R>& b)
-   {
-      x.unSetup();
-      solveRight((VectorBase<R>&) x, (const VectorBase<R>&) b);
-   }
-   /// Solves \f$Ax=b\f$.
-   void solveRight(SSVectorBase<R>& x, const SVectorBase<R>& b);
-   /// Solves \f$Ax=b\f$.
-   void solveRight4update(SSVectorBase<R>& x, const SVectorBase<R>& b);
-   /// Solves \f$Ax=b\f$ and \f$Ay=d\f$.
-   void solve2right4update(SSVectorBase<R>& x, VectorBase<R>& y, const SVectorBase<R>& b,
-                           SSVectorBase<R>& d);
-   /// Sparse version of solving two systems of equations
-   void solve2right4update(SSVectorBase<R>& x, SSVectorBase<R>& y, const SVectorBase<R>& b,
-                           SSVectorBase<R>& d);
-   /// Solves \f$Ax=b\f$, \f$Ay=d\f$ and \f$Az=e\f$.
-   void solve3right4update(SSVectorBase<R>& x, VectorBase<R>& y, VectorBase<R>& z,
-                           const SVectorBase<R>& b, SSVectorBase<R>& d, SSVectorBase<R>& e);
-   /// sparse version of solving three systems of equations
-   void solve3right4update(SSVectorBase<R>& x, SSVectorBase<R>& y, SSVectorBase<R>& z,
-                           const SVectorBase<R>& b, SSVectorBase<R>& d, SSVectorBase<R>& e);
-   /// sparse version of solving one system of equations with transposed basis matrix
-   void solveLeft(VectorBase<R>& x, const VectorBase<R>& b);
-   void solveLeft(SSVectorBase<R>& x, const SSVectorBase<R>& b)
-   {
-      x.unSetup();
-      solveLeft((VectorBase<R>&) x, (const VectorBase<R>&) b);
-   }
-   /// Solves \f$Ax=b\f$.
-   void solveLeft(SSVectorBase<R>& x, const SVectorBase<R>& b);
-   /// Solves \f$Ax=b\f$ and \f$Ay=d\f$.
-   void solveLeft(SSVectorBase<R>& x, VectorBase<R>& y, const SVectorBase<R>& b, SSVectorBase<R>& d);
-   /// sparse version of solving two systems of equations with transposed basis matrix
-   void solveLeft(SSVectorBase<R>& x, SSVectorBase<R>& two, const SVectorBase<R>& b,
-                  SSVectorBase<R>& rhs2);
-   /// Solves \f$Ax=b\f$, \f$Ay=d\f$ and \f$Az=e\f$.
-   void solveLeft(SSVectorBase<R>& x, VectorBase<R>& y, VectorBase<R>& z,
-                  const SVectorBase<R>& b, SSVectorBase<R>& d, SSVectorBase<R>& e);
-   /// sparse version of solving three systems of equations with transposed basis matrix
-   void solveLeft(SSVectorBase<R>& x, SSVectorBase<R>& y, SSVectorBase<R>& z,
-                  const SVectorBase<R>& b, SSVectorBase<R>& d, SSVectorBase<R>& e);
-   ///
-   Status change(int idx, const SVectorBase<R>& subst, const SSVectorBase<R>* eta = 0);
-   ///@}
-
-   //--------------------------------
-   /**@name Miscellaneous */
-   ///@{
-   /// time spent in factorizations
-   // @todo fix the return type from of the type form Real to a cpp time (Refactoring) TODO
-   Real getFactorTime() const
-   {
-      return this->factorTime->time();
-   }
-   /// reset FactorTime
-   void resetFactorTime()
-   {
-      this->factorTime->reset();
-   }
-   /// number of factorizations performed
-   int getFactorCount() const
-   {
-      return this->factorCount;
-   }
-   /// time spent in solves
-   // @todo fix the return type of time to a cpp time type TODO
-   Real getSolveTime() const
-   {
-      return solveTime->time();
-   }
-   /// reset SolveTime
-   void resetSolveTime()
-   {
-      solveTime->reset();
-   }
-   /// number of solves performed
-   int getSolveCount() const
-   {
-      return solveCount;
-   }
-   /// reset timers and counters
-   void resetCounters()
-   {
-      this->factorTime->reset();
-      solveTime->reset();
-      this->factorCount = 0;
-      this->hugeValues = 0;
-      solveCount = 0;
-   }
-   void changeTimer(const Timer::TYPE ttype)
-   {
-      solveTime = TimerFactory::switchTimer(solveTime, ttype);
-      this->factorTime = TimerFactory::switchTimer(this->factorTime, ttype);
-      timerType = ttype;
-   }
-   /// prints the LU factorization to stdout.
-   void dump() const;
+  //--------------------------------
+  /**@name Miscellaneous */
+  ///@{
+  /// time spent in factorizations
+  // @todo fix the return type from of the type form Real to a cpp time
+  // (Refactoring) TODO
+  Real getFactorTime() const { return this->factorTime->time(); }
+  /// reset FactorTime
+  void resetFactorTime() { this->factorTime->reset(); }
+  /// number of factorizations performed
+  int getFactorCount() const { return this->factorCount; }
+  /// time spent in solves
+  // @todo fix the return type of time to a cpp time type TODO
+  Real getSolveTime() const { return solveTime->time(); }
+  /// reset SolveTime
+  void resetSolveTime() { solveTime->reset(); }
+  /// number of solves performed
+  int getSolveCount() const { return solveCount; }
+  /// reset timers and counters
+  void resetCounters() {
+    this->factorTime->reset();
+    solveTime->reset();
+    this->factorCount = 0;
+    this->hugeValues = 0;
+    solveCount = 0;
+  }
+  void changeTimer(const Timer::TYPE ttype) {
+    solveTime = TimerFactory::switchTimer(solveTime, ttype);
+    this->factorTime = TimerFactory::switchTimer(this->factorTime, ttype);
+    timerType = ttype;
+  }
+  /// prints the LU factorization to stdout.
+  void dump() const;
 
-   /// consistency check.
-   bool isConsistent() const;
-   ///@}
+  /// consistency check.
+  bool isConsistent() const;
+  ///@}
 
-   //------------------------------------
-   /**@name Constructors / Destructors */
-   ///@{
-   /// default constructor.
-   SLUFactor<R>();
-   /// assignment operator.
-   SLUFactor<R>& operator=(const SLUFactor<R>& old);
-   /// copy constructor.
-   SLUFactor<R>(const SLUFactor<R>& old);
-   /// destructor.
-   virtual ~SLUFactor<R>();
-   /// clone function for polymorphism
-   inline virtual SLinSolver<R>* clone() const
-   {
-      return new SLUFactor<R>(*this);
-   }
-   ///@}
+  //------------------------------------
+  /**@name Constructors / Destructors */
+  ///@{
+  /// default constructor.
+  SLUFactor();
+  /// assignment operator.
+  SLUFactor<R> &operator=(const SLUFactor<R> &old);
+  /// copy constructor.
+  SLUFactor(const SLUFactor<R> &old);
+  /// destructor.
+  virtual ~SLUFactor();
+  /// clone function for polymorphism
+  inline virtual SLinSolver<R> *clone() const {
+    return new SLUFactor<R>(*this);
+  }
+  ///@}
 
 private:
-
-   //------------------------------------
-   /**@name Private helpers */
-   ///@{
-   /// used to implement the assignment operator
-   void assign(const SLUFactor<R>& old);
-   ///@}
+  //------------------------------------
+  /**@name Private helpers */
+  ///@{
+  /// used to implement the assignment operator
+  void assign(const SLUFactor<R> &old);
+  ///@}
 };
 
 } // namespace soplex
diff --git a/src/soplex/slufactor.hpp b/src/soplex/slufactor.hpp
index c2ab615..fc39327 100644
--- a/src/soplex/slufactor.hpp
+++ b/src/soplex/slufactor.hpp
@@ -21,6 +21,7 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 /**@file slufactor.hpp
  * @todo SLUfactor seems to be partly an wrapper for CLUFactor (was C).
@@ -36,1503 +37,1385 @@
 #include <stdio.h>
 #endif
 
-namespace soplex
-{
-#define MINSTABILITY    R(4e-2)
+namespace soplex {
+#define MINSTABILITY R(4e-2)
 
 template <class R>
-void SLUFactor<R>::solveRight(VectorBase<R>& x, const VectorBase<R>& b) //const
+void SLUFactor<R>::solveRight(VectorBase<R> &x, const VectorBase<R> &b) // const
 {
 
-   this->solveTime->start();
+  this->solveTime->start();
 
-   this->vec = b;
-   x.clear();
-   CLUFactor<R>::solveRight(x.get_ptr(), vec.get_ptr());
+  this->vec = b;
+  x.clear();
+  CLUFactor<R>::solveRight(x.get_ptr(), vec.get_ptr());
 
-   solveCount++;
-   solveTime->stop();
+  solveCount++;
+  solveTime->stop();
 }
 
 template <class R>
-void SLUFactor<R>::solveRight(SSVectorBase<R>& x, const SVectorBase<R>& b)  //const
+void SLUFactor<R>::solveRight(SSVectorBase<R> &x,
+                              const SVectorBase<R> &b) // const
 {
 
-   solveTime->start();
+  solveTime->start();
 
-   vec.assign(b);
-   x.clear();
-   CLUFactor<R>::solveRight(x.altValues(), vec.get_ptr());
+  vec.assign(b);
+  x.clear();
+  CLUFactor<R>::solveRight(x.altValues(), vec.get_ptr());
 
-   solveCount++;
-   solveTime->stop();
+  solveCount++;
+  solveTime->stop();
 }
 
 template <class R>
-void SLUFactor<R>::solveRight4update(SSVectorBase<R>& x, const SVectorBase<R>& b)
-{
-
-   solveTime->start();
-
-   int m;
-   int n;
-   int f;
-
-   x.clear();
-   ssvec = b;
-   n = ssvec.size();
-
-   if(this->l.updateType == ETA)
-   {
-      m = this->vSolveRight4update(x.getEpsilon(), x.altValues(), x.altIndexMem(),
-                                   ssvec.altValues(), ssvec.altIndexMem(), n, 0, 0, 0);
-      x.setSize(m);
-      //x.forceSetup();
-      x.unSetup();
-      eta.setup_and_assign(x);
-   }
-   else
-   {
-      forest.clear();
-      m = this->vSolveRight4update(x.getEpsilon(), x.altValues(), x.altIndexMem(),
-                                   ssvec.altValues(), ssvec.altIndexMem(), n,
-                                   forest.altValues(), &f, forest.altIndexMem());
-      forest.setSize(f);
-      forest.forceSetup();
-      x.setSize(m);
-      x.forceSetup();
-   }
-
-   usetup = true;
-   ssvec.setSize(0);
-   ssvec.forceSetup();
-
-   solveCount++;
-   solveTime->stop();
+void SLUFactor<R>::solveRight4update(SSVectorBase<R> &x,
+                                     const SVectorBase<R> &b) {
+
+  solveTime->start();
+
+  int m;
+  int n;
+  int f;
+
+  x.clear();
+  ssvec = b;
+  n = ssvec.size();
+
+  if (this->l.updateType == ETA) {
+    m = this->vSolveRight4update(x.getEpsilon(), x.altValues(), x.altIndexMem(),
+                                 ssvec.altValues(), ssvec.altIndexMem(), n, 0,
+                                 0, 0);
+    x.setSize(m);
+    // x.forceSetup();
+    x.unSetup();
+    eta.setup_and_assign(x);
+  } else {
+    forest.clear();
+    m = this->vSolveRight4update(x.getEpsilon(), x.altValues(), x.altIndexMem(),
+                                 ssvec.altValues(), ssvec.altIndexMem(), n,
+                                 forest.altValues(), &f, forest.altIndexMem());
+    forest.setSize(f);
+    forest.forceSetup();
+    x.setSize(m);
+    x.forceSetup();
+  }
+
+  usetup = true;
+  ssvec.setSize(0);
+  ssvec.forceSetup();
+
+  solveCount++;
+  solveTime->stop();
 }
 
 template <class R>
-void SLUFactor<R>::solve2right4update(
-   SSVectorBase<R>&       x,
-   VectorBase<R>&        y,
-   const SVectorBase<R>& b,
-   SSVectorBase<R>&       rhs)
-{
-
-   solveTime->start();
-
-   int  m;
-   int  n;
-   int  f;
-   int* sidx = ssvec.altIndexMem();
-   ssvec.setSize(0);
-   ssvec.forceSetup();
-   int  rsize = rhs.size();
-   int* ridx = rhs.altIndexMem();
-
-   x.clear();
-   y.clear();
-   usetup = true;
-   ssvec = b;
-
-   if(this->l.updateType == ETA)
-   {
-      n = ssvec.size();
-      m = this->vSolveRight4update2(x.getEpsilon(), x.altValues(), x.altIndexMem(),
-                                    ssvec.get_ptr(), sidx, n, y.get_ptr(),
-                                    rhs.getEpsilon(), rhs.altValues(), ridx, rsize, 0, 0, 0);
-      x.setSize(m);
-      //      x.forceSetup();
-      x.unSetup();
-      eta.setup_and_assign(x);
-   }
-   else
-   {
-      forest.clear();
-      n = ssvec.size();
-      m = this->vSolveRight4update2(x.getEpsilon(), x.altValues(), x.altIndexMem(),
-                                    ssvec.get_ptr(), sidx, n, y.get_ptr(),
-                                    rhs.getEpsilon(), rhs.altValues(), ridx, rsize,
-                                    forest.altValues(), &f, forest.altIndexMem());
-      x.setSize(m);
-      x.forceSetup();
-      forest.setSize(f);
-      forest.forceSetup();
-   }
-
-   rhs.forceSetup();
-   ssvec.setSize(0);
-   ssvec.forceSetup();
-
-   solveCount += 2;
-   solveTime->stop();
+void SLUFactor<R>::solve2right4update(SSVectorBase<R> &x, VectorBase<R> &y,
+                                      const SVectorBase<R> &b,
+                                      SSVectorBase<R> &rhs) {
+
+  solveTime->start();
+
+  int m;
+  int n;
+  int f;
+  int *sidx = ssvec.altIndexMem();
+  ssvec.setSize(0);
+  ssvec.forceSetup();
+  int rsize = rhs.size();
+  int *ridx = rhs.altIndexMem();
+
+  x.clear();
+  y.clear();
+  usetup = true;
+  ssvec = b;
+
+  if (this->l.updateType == ETA) {
+    n = ssvec.size();
+    m = this->vSolveRight4update2(x.getEpsilon(), x.altValues(),
+                                  x.altIndexMem(), ssvec.get_ptr(), sidx, n,
+                                  y.get_ptr(), rhs.getEpsilon(),
+                                  rhs.altValues(), ridx, rsize, 0, 0, 0);
+    x.setSize(m);
+    //      x.forceSetup();
+    x.unSetup();
+    eta.setup_and_assign(x);
+  } else {
+    forest.clear();
+    n = ssvec.size();
+    m = this->vSolveRight4update2(
+        x.getEpsilon(), x.altValues(), x.altIndexMem(), ssvec.get_ptr(), sidx,
+        n, y.get_ptr(), rhs.getEpsilon(), rhs.altValues(), ridx, rsize,
+        forest.altValues(), &f, forest.altIndexMem());
+    x.setSize(m);
+    x.forceSetup();
+    forest.setSize(f);
+    forest.forceSetup();
+  }
+
+  rhs.forceSetup();
+  ssvec.setSize(0);
+  ssvec.forceSetup();
+
+  solveCount += 2;
+  solveTime->stop();
 }
 
 template <class R>
-void SLUFactor<R>::solve2right4update(
-   SSVectorBase<R>&       x,
-   SSVectorBase<R>&       y,
-   const SVectorBase<R>& b,
-   SSVectorBase<R>&       rhs)
-{
-
-   solveTime->start();
-
-   int  n;
-   int  f;
-   int* sidx = ssvec.altIndexMem();
-   ssvec.setSize(0);
-   ssvec.forceSetup();
-   int  rsize = rhs.size();
-   int* ridx = rhs.altIndexMem();
-
-   x.clear();
-   y.clear();
-   usetup = true;
-   ssvec = b;
-
-   if(this->l.updateType == ETA)
-   {
-      n = ssvec.size();
-      this->vSolveRight4update2sparse(x.getEpsilon(), x.altValues(), x.altIndexMem(),
-                                      ssvec.get_ptr(), sidx, n,
-                                      y.getEpsilon(), y.altValues(), y.altIndexMem(),
-                                      rhs.altValues(), ridx, rsize,
-                                      0, 0, 0);
-      x.setSize(n);
-      //      x.forceSetup();
-      x.unSetup();
-      y.setSize(rsize);
-      y.unSetup();
-      eta.setup_and_assign(x);
-   }
-   else
-   {
-      forest.clear();
-      n = ssvec.size();
-      this->vSolveRight4update2sparse(x.getEpsilon(), x.altValues(), x.altIndexMem(),
-                                      ssvec.get_ptr(), sidx, n,
-                                      y.getEpsilon(), y.altValues(), y.altIndexMem(),
-                                      rhs.altValues(), ridx, rsize,
-                                      forest.altValues(), &f, forest.altIndexMem());
-      x.setSize(n);
-      x.forceSetup();
-      y.setSize(rsize);
-      y.forceSetup();
-      forest.setSize(f);
-      forest.forceSetup();
-   }
-
-   rhs.forceSetup();
-   ssvec.setSize(0);
-   ssvec.forceSetup();
+void SLUFactor<R>::solve2right4update(SSVectorBase<R> &x, SSVectorBase<R> &y,
+                                      const SVectorBase<R> &b,
+                                      SSVectorBase<R> &rhs) {
+
+  solveTime->start();
+
+  int n;
+  int f;
+  int *sidx = ssvec.altIndexMem();
+  ssvec.setSize(0);
+  ssvec.forceSetup();
+  int rsize = rhs.size();
+  int *ridx = rhs.altIndexMem();
+
+  x.clear();
+  y.clear();
+  usetup = true;
+  ssvec = b;
+
+  if (this->l.updateType == ETA) {
+    n = ssvec.size();
+    this->vSolveRight4update2sparse(
+        x.getEpsilon(), x.altValues(), x.altIndexMem(), ssvec.get_ptr(), sidx,
+        n, y.getEpsilon(), y.altValues(), y.altIndexMem(), rhs.altValues(),
+        ridx, rsize, 0, 0, 0);
+    x.setSize(n);
+    //      x.forceSetup();
+    x.unSetup();
+    y.setSize(rsize);
+    y.unSetup();
+    eta.setup_and_assign(x);
+  } else {
+    forest.clear();
+    n = ssvec.size();
+    this->vSolveRight4update2sparse(
+        x.getEpsilon(), x.altValues(), x.altIndexMem(), ssvec.get_ptr(), sidx,
+        n, y.getEpsilon(), y.altValues(), y.altIndexMem(), rhs.altValues(),
+        ridx, rsize, forest.altValues(), &f, forest.altIndexMem());
+    x.setSize(n);
+    x.forceSetup();
+    y.setSize(rsize);
+    y.forceSetup();
+    forest.setSize(f);
+    forest.forceSetup();
+  }
+
+  rhs.forceSetup();
+  ssvec.setSize(0);
+  ssvec.forceSetup();
+
+  solveCount += 2;
+  solveTime->stop();
+}
 
-   solveCount += 2;
-   solveTime->stop();
+template <class R>
+void SLUFactor<R>::solve3right4update(SSVectorBase<R> &x, VectorBase<R> &y,
+                                      VectorBase<R> &y2,
+                                      const SVectorBase<R> &b,
+                                      SSVectorBase<R> &rhs,
+                                      SSVectorBase<R> &rhs2) {
+
+  solveTime->start();
+
+  int m;
+  int n;
+  int f;
+  int *sidx = ssvec.altIndexMem();
+  ssvec.setSize(0);
+  ssvec.forceSetup();
+  int rsize = rhs.size();
+  int *ridx = rhs.altIndexMem();
+  int rsize2 = rhs2.size();
+  int *ridx2 = rhs2.altIndexMem();
+
+  x.clear();
+  y.clear();
+  y2.clear();
+  usetup = true;
+  ssvec = b;
+
+  if (this->l.updateType == ETA) {
+    n = ssvec.size();
+    m = this->vSolveRight4update3(
+        x.getEpsilon(), x.altValues(), x.altIndexMem(), ssvec.get_ptr(), sidx,
+        n, y.get_ptr(), rhs.getEpsilon(), rhs.altValues(), ridx, rsize,
+        y2.get_ptr(), rhs2.getEpsilon(), rhs2.altValues(), ridx2, rsize2, 0, 0,
+        0);
+    x.setSize(m);
+    //      x.forceSetup();
+    x.unSetup();
+    eta.setup_and_assign(x);
+  } else {
+    forest.clear();
+    n = ssvec.size();
+    m = this->vSolveRight4update3(
+        x.getEpsilon(), x.altValues(), x.altIndexMem(), ssvec.get_ptr(), sidx,
+        n, y.get_ptr(), rhs.getEpsilon(), rhs.altValues(), ridx, rsize,
+        y2.get_ptr(), rhs2.getEpsilon(), rhs2.altValues(), ridx2, rsize2,
+        forest.altValues(), &f, forest.altIndexMem());
+    x.setSize(m);
+    x.forceSetup();
+    forest.setSize(f);
+    forest.forceSetup();
+  }
+
+  rhs.forceSetup();
+  rhs2.forceSetup();
+  ssvec.setSize(0);
+  ssvec.forceSetup();
+
+  solveCount += 3;
+  solveTime->stop();
 }
 
+template <class R>
+void SLUFactor<R>::solve3right4update(SSVectorBase<R> &x, SSVectorBase<R> &y,
+                                      SSVectorBase<R> &y2,
+                                      const SVectorBase<R> &b,
+                                      SSVectorBase<R> &rhs,
+                                      SSVectorBase<R> &rhs2) {
+  solveTime->start();
+
+  int n;
+  int f;
+  int *sidx = ssvec.altIndexMem();
+  ssvec.setSize(0);
+  ssvec.forceSetup();
+  int rsize = rhs.size();
+  int *ridx = rhs.altIndexMem();
+  int rsize2 = rhs2.size();
+  int *ridx2 = rhs2.altIndexMem();
+
+  x.clear();
+  y.clear();
+  y2.clear();
+  usetup = true;
+  ssvec = b;
+
+  if (this->l.updateType == ETA) {
+    n = ssvec.size();
+    this->vSolveRight4update3sparse(
+        x.getEpsilon(), x.altValues(), x.altIndexMem(), ssvec.get_ptr(), sidx,
+        n, y.getEpsilon(), y.altValues(), y.altIndexMem(), rhs.altValues(),
+        ridx, rsize, y2.getEpsilon(), y2.altValues(), y2.altIndexMem(),
+        rhs2.altValues(), ridx2, rsize2, 0, 0, 0);
+    x.setSize(n);
+    //      x.forceSetup();
+    x.unSetup();
+    y.setSize(rsize);
+    y.unSetup();
+    y2.setSize(rsize2);
+    y2.unSetup();
+    eta.setup_and_assign(x);
+  } else {
+    forest.clear();
+    n = ssvec.size();
+    this->vSolveRight4update3sparse(
+        x.getEpsilon(), x.altValues(), x.altIndexMem(), ssvec.get_ptr(), sidx,
+        n, y.getEpsilon(), y.altValues(), y.altIndexMem(), rhs.altValues(),
+        ridx, rsize, y2.getEpsilon(), y2.altValues(), y2.altIndexMem(),
+        rhs2.altValues(), ridx2, rsize2, forest.altValues(), &f,
+        forest.altIndexMem());
+    x.setSize(n);
+    x.forceSetup();
+    y.setSize(rsize);
+    y.forceSetup();
+    y2.setSize(rsize2);
+    y2.forceSetup();
+
+    forest.setSize(f);
+    forest.forceSetup();
+  }
+
+  rhs.forceSetup();
+  rhs2.forceSetup();
+  ssvec.setSize(0);
+  ssvec.forceSetup();
+
+  solveCount += 3;
+  solveTime->stop();
+}
 
 template <class R>
-void SLUFactor<R>::solve3right4update(
-   SSVectorBase<R>&       x,
-   VectorBase<R>&        y,
-   VectorBase<R>&        y2,
-   const SVectorBase<R>& b,
-   SSVectorBase<R>&       rhs,
-   SSVectorBase<R>&       rhs2)
+void SLUFactor<R>::solveLeft(VectorBase<R> &x, const VectorBase<R> &b) // const
 {
 
-   solveTime->start();
-
-   int  m;
-   int  n;
-   int  f;
-   int* sidx = ssvec.altIndexMem();
-   ssvec.setSize(0);
-   ssvec.forceSetup();
-   int  rsize = rhs.size();
-   int* ridx = rhs.altIndexMem();
-   int  rsize2 = rhs2.size();
-   int* ridx2 = rhs2.altIndexMem();
-
-   x.clear();
-   y.clear();
-   y2.clear();
-   usetup = true;
-   ssvec = b;
-
-   if(this->l.updateType == ETA)
-   {
-      n = ssvec.size();
-      m = this->vSolveRight4update3(x.getEpsilon(),
-                                    x.altValues(), x.altIndexMem(), ssvec.get_ptr(), sidx, n,
-                                    y.get_ptr(), rhs.getEpsilon(), rhs.altValues(), ridx, rsize,
-                                    y2.get_ptr(), rhs2.getEpsilon(), rhs2.altValues(), ridx2, rsize2,
-                                    0, 0, 0);
-      x.setSize(m);
-      //      x.forceSetup();
-      x.unSetup();
-      eta.setup_and_assign(x);
-   }
-   else
-   {
-      forest.clear();
-      n = ssvec.size();
-      m = this->vSolveRight4update3(x.getEpsilon(),
-                                    x.altValues(), x.altIndexMem(), ssvec.get_ptr(), sidx, n,
-                                    y.get_ptr(), rhs.getEpsilon(), rhs.altValues(), ridx, rsize,
-                                    y2.get_ptr(), rhs2.getEpsilon(), rhs2.altValues(), ridx2, rsize2,
-                                    forest.altValues(), &f, forest.altIndexMem());
-      x.setSize(m);
-      x.forceSetup();
-      forest.setSize(f);
-      forest.forceSetup();
-   }
+  solveTime->start();
 
-   rhs.forceSetup();
-   rhs2.forceSetup();
-   ssvec.setSize(0);
-   ssvec.forceSetup();
+  vec = b;
+  x.clear();
+  CLUFactor<R>::solveLeft(x.get_ptr(), vec.get_ptr());
 
-   solveCount += 3;
-   solveTime->stop();
+  solveCount++;
+  solveTime->stop();
 }
 
 template <class R>
-void SLUFactor<R>::solve3right4update(
-   SSVectorBase<R>&       x,
-   SSVectorBase<R>&       y,
-   SSVectorBase<R>&       y2,
-   const SVectorBase<R>& b,
-   SSVectorBase<R>&       rhs,
-   SSVectorBase<R>&       rhs2)
+void SLUFactor<R>::solveLeft(SSVectorBase<R> &x,
+                             const SVectorBase<R> &b) // const
 {
-   solveTime->start();
-
-   int  n;
-   int  f;
-   int* sidx = ssvec.altIndexMem();
-   ssvec.setSize(0);
-   ssvec.forceSetup();
-   int  rsize = rhs.size();
-   int* ridx = rhs.altIndexMem();
-   int  rsize2 = rhs2.size();
-   int* ridx2 = rhs2.altIndexMem();
-
-   x.clear();
-   y.clear();
-   y2.clear();
-   usetup = true;
-   ssvec = b;
-
-   if(this->l.updateType == ETA)
-   {
-      n = ssvec.size();
-      this->vSolveRight4update3sparse(x.getEpsilon(), x.altValues(), x.altIndexMem(),
-                                      ssvec.get_ptr(), sidx, n,
-                                      y.getEpsilon(), y.altValues(), y.altIndexMem(),
-                                      rhs.altValues(), ridx, rsize,
-                                      y2.getEpsilon(), y2.altValues(), y2.altIndexMem(),
-                                      rhs2.altValues(), ridx2, rsize2,
-                                      0, 0, 0);
-      x.setSize(n);
-      //      x.forceSetup();
-      x.unSetup();
-      y.setSize(rsize);
-      y.unSetup();
-      y2.setSize(rsize2);
-      y2.unSetup();
-      eta.setup_and_assign(x);
-   }
-   else
-   {
-      forest.clear();
-      n = ssvec.size();
-      this->vSolveRight4update3sparse(x.getEpsilon(), x.altValues(), x.altIndexMem(),
-                                      ssvec.get_ptr(), sidx, n,
-                                      y.getEpsilon(), y.altValues(), y.altIndexMem(),
-                                      rhs.altValues(), ridx, rsize,
-                                      y2.getEpsilon(), y2.altValues(), y2.altIndexMem(),
-                                      rhs2.altValues(), ridx2, rsize2,
-                                      forest.altValues(), &f, forest.altIndexMem());
-      x.setSize(n);
-      x.forceSetup();
-      y.setSize(rsize);
-      y.forceSetup();
-      y2.setSize(rsize2);
-      y2.forceSetup();
 
-      forest.setSize(f);
-      forest.forceSetup();
-   }
+  solveTime->start();
 
-   rhs.forceSetup();
-   rhs2.forceSetup();
-   ssvec.setSize(0);
-   ssvec.forceSetup();
+  // copy to SSVec is done to avoid having to deal with the Nonzero datatype
+  // TODO change SVec to standard sparse format
+  ssvec.assign(b);
 
-   solveCount += 3;
-   solveTime->stop();
-}
+  x.clear();
+  int sz = ssvec.size(); // see .altValues()
+  int n = this->vSolveLeft(x.getEpsilon(), x.altValues(), x.altIndexMem(),
+                           ssvec.altValues(), ssvec.altIndexMem(), sz);
 
+  if (n > 0) {
+    x.setSize(n);
+    x.forceSetup();
+  } else
+    x.unSetup();
 
-template <class R>
-void SLUFactor<R>::solveLeft(VectorBase<R>& x, const VectorBase<R>& b) //const
-{
+  ssvec.setSize(0);
+  ssvec.forceSetup();
 
-   solveTime->start();
-
-   vec = b;
-   x.clear();
-   CLUFactor<R>::solveLeft(x.get_ptr(), vec.get_ptr());
-
-   solveCount++;
-   solveTime->stop();
+  solveCount++;
+  solveTime->stop();
 }
 
 template <class R>
-void SLUFactor<R>::solveLeft(SSVectorBase<R>& x, const SVectorBase<R>& b)  //const
+void SLUFactor<R>::solveLeft(SSVectorBase<R> &x, VectorBase<R> &y,
+                             const SVectorBase<R> &rhs1,
+                             SSVectorBase<R> &rhs2) // const
 {
 
-   solveTime->start();
+  solveTime->start();
+
+  int n;
+  R *svec = ssvec.altValues();
+  int *sidx = ssvec.altIndexMem();
+  int rn = rhs2.size();
+  int *ridx = rhs2.altIndexMem();
 
-   // copy to SSVec is done to avoid having to deal with the Nonzero datatype
-   // TODO change SVec to standard sparse format
-   ssvec.assign(b);
+  x.clear();
+  y.clear();
+  ssvec.assign(rhs1);
+  n = ssvec.size(); // see altValues();
+  n = this->vSolveLeft2(x.getEpsilon(), x.altValues(), x.altIndexMem(), svec,
+                        sidx, n, y.get_ptr(), rhs2.altValues(), ridx, rn);
 
-   x.clear();
-   int sz = ssvec.size(); // see .altValues()
-   int n = this->vSolveLeft(x.getEpsilon(), x.altValues(), x.altIndexMem(),
-                            ssvec.altValues(), ssvec.altIndexMem(), sz);
+  // this will unsetup x
+  x.setSize(n);
 
-   if(n > 0)
-   {
-      x.setSize(n);
-      x.forceSetup();
-   }
-   else
-      x.unSetup();
+  if (n > 0)
+    x.forceSetup();
 
-   ssvec.setSize(0);
-   ssvec.forceSetup();
+  ssvec.setSize(0);
+  ssvec.forceSetup();
 
-   solveCount++;
-   solveTime->stop();
+  solveCount += 2;
+  solveTime->stop();
 }
 
 template <class R>
-void SLUFactor<R>::solveLeft(
-   SSVectorBase<R>&       x,
-   VectorBase<R>&        y,
-   const SVectorBase<R>& rhs1,
-   SSVectorBase<R>&       rhs2) //const
+void SLUFactor<R>::solveLeft(SSVectorBase<R> &x, SSVectorBase<R> &y,
+                             const SVectorBase<R> &rhs1,
+                             SSVectorBase<R> &rhs2) // const
 {
 
-   solveTime->start();
+  solveTime->start();
 
-   int   n;
-   R* svec = ssvec.altValues();
-   int*  sidx = ssvec.altIndexMem();
-   int   rn   = rhs2.size();
-   int*  ridx = rhs2.altIndexMem();
+  int n1, n2;
+  R *svec = ssvec.altValues();
+  int *sidx = ssvec.altIndexMem();
 
-   x.clear();
-   y.clear();
-   ssvec.assign(rhs1);
-   n = ssvec.size(); // see altValues();
-   n = this->vSolveLeft2(x.getEpsilon(), x.altValues(), x.altIndexMem(), svec, sidx, n,
-                         y.get_ptr(), rhs2.altValues(), ridx, rn);
+  x.clear();
+  y.clear();
+  ssvec.assign(rhs1);
+  n1 = ssvec.size(); // see altValues();
+  n2 = rhs2.size();
 
-   // this will unsetup x
-   x.setSize(n);
+  if (n2 < 10) {
+    this->vSolveLeft2sparse(x.getEpsilon(), x.altValues(), x.altIndexMem(),
+                            svec, sidx, n1, y.altValues(), y.altIndexMem(),
+                            rhs2.altValues(), rhs2.altIndexMem(), n2);
+    y.setSize(n2);
 
-   if(n > 0)
-      x.forceSetup();
+    if (n2 > 0)
+      y.forceSetup();
+  } else {
+    n1 = this->vSolveLeft2(x.getEpsilon(), x.altValues(), x.altIndexMem(), svec,
+                           sidx, n1, y.altValues(), rhs2.altValues(),
+                           rhs2.altIndexMem(), n2);
+    //      y.setup();
+  }
 
-   ssvec.setSize(0);
-   ssvec.forceSetup();
+  x.setSize(n1);
 
-   solveCount += 2;
-   solveTime->stop();
-}
+  if (n1 > 0)
+    x.forceSetup();
 
-template <class R>
-void SLUFactor<R>::solveLeft(
-   SSVectorBase<R>&       x,
-   SSVectorBase<R>&       y,
-   const SVectorBase<R>& rhs1,
-   SSVectorBase<R>&       rhs2) //const
-{
+  //   if (n2 > 0)
+  //      y.forceSetup();
 
-   solveTime->start();
-
-   int   n1, n2;
-   R* svec = ssvec.altValues();
-   int*  sidx = ssvec.altIndexMem();
-
-   x.clear();
-   y.clear();
-   ssvec.assign(rhs1);
-   n1 = ssvec.size(); // see altValues();
-   n2 = rhs2.size();
-
-   if(n2 < 10)
-   {
-      this->vSolveLeft2sparse(x.getEpsilon(),
-                              x.altValues(), x.altIndexMem(),
-                              svec, sidx, n1,
-                              y.altValues(), y.altIndexMem(),
-                              rhs2.altValues(), rhs2.altIndexMem(), n2);
-      y.setSize(n2);
-
-      if(n2 > 0)
-         y.forceSetup();
-   }
-   else
-   {
-      n1 = this->vSolveLeft2(x.getEpsilon(), x.altValues(), x.altIndexMem(), svec, sidx, n1,
-                             y.altValues(), rhs2.altValues(), rhs2.altIndexMem(), n2);
-      //      y.setup();
-   }
-
-   x.setSize(n1);
-
-   if(n1 > 0)
-      x.forceSetup();
-
-   //   if (n2 > 0)
-   //      y.forceSetup();
-
-   ssvec.setSize(0);
-   ssvec.forceSetup();
-
-   solveCount += 2;
-   solveTime->stop();
-}
+  ssvec.setSize(0);
+  ssvec.forceSetup();
 
+  solveCount += 2;
+  solveTime->stop();
+}
 
 template <class R>
-void SLUFactor<R>::solveLeft(
-   SSVectorBase<R>&       x,
-   VectorBase<R>&        y,
-   VectorBase<R>&        z,
-   const SVectorBase<R>& rhs1,
-   SSVectorBase<R>&       rhs2,
-   SSVectorBase<R>&       rhs3)
-{
+void SLUFactor<R>::solveLeft(SSVectorBase<R> &x, VectorBase<R> &y,
+                             VectorBase<R> &z, const SVectorBase<R> &rhs1,
+                             SSVectorBase<R> &rhs2, SSVectorBase<R> &rhs3) {
 
-   solveTime->start();
+  solveTime->start();
 
-   int   n, n2, n3;
-   R* svec = ssvec.altValues();
-   int*  sidx = ssvec.altIndexMem();
+  int n, n2, n3;
+  R *svec = ssvec.altValues();
+  int *sidx = ssvec.altIndexMem();
 
-   x.clear();
-   y.clear();
-   z.clear();
-   ssvec.assign(rhs1);
-   n = ssvec.size(); // see altValues();
-   n2 = rhs2.size();
-   n3 = rhs3.size();
+  x.clear();
+  y.clear();
+  z.clear();
+  ssvec.assign(rhs1);
+  n = ssvec.size(); // see altValues();
+  n2 = rhs2.size();
+  n3 = rhs3.size();
 
-   n = this->vSolveLeft3(x.getEpsilon(), x.altValues(), x.altIndexMem(), svec, sidx, n,
-                         y.get_ptr(), rhs2.altValues(), rhs2.altIndexMem(), n2,
-                         z.get_ptr(), rhs3.altValues(), rhs3.altIndexMem(), n3);
+  n = this->vSolveLeft3(x.getEpsilon(), x.altValues(), x.altIndexMem(), svec,
+                        sidx, n, y.get_ptr(), rhs2.altValues(),
+                        rhs2.altIndexMem(), n2, z.get_ptr(), rhs3.altValues(),
+                        rhs3.altIndexMem(), n3);
 
-   x.setSize(n);
+  x.setSize(n);
 
-   if(n > 0)
-      x.forceSetup();
+  if (n > 0)
+    x.forceSetup();
 
-   ssvec.setSize(0);
-   ssvec.forceSetup();
+  ssvec.setSize(0);
+  ssvec.forceSetup();
 
-   solveCount += 3;
-   solveTime->stop();
+  solveCount += 3;
+  solveTime->stop();
 }
 
 template <class R>
-void SLUFactor<R>::solveLeft(
-   SSVectorBase<R>&       x,
-   SSVectorBase<R>&       y,
-   SSVectorBase<R>&       z,
-   const SVectorBase<R>& rhs1,
-   SSVectorBase<R>&       rhs2,
-   SSVectorBase<R>&       rhs3)
-{
-
-   solveTime->start();
-
-   int   n1, n2, n3;
-   R* svec = ssvec.altValues();
-   int*  sidx = ssvec.altIndexMem();
-
-   x.clear();
-   y.clear();
-   z.clear();
-   ssvec.assign(rhs1);
-   n1 = ssvec.size(); // see altValues();
-   n2 = rhs2.size();
-   n3 = rhs3.size();
-   this->vSolveLeft3sparse(x.getEpsilon(),
-                           x.altValues(), x.altIndexMem(),
-                           svec, sidx, n1,
-                           y.altValues(), y.altIndexMem(),
-                           rhs2.altValues(), rhs2.altIndexMem(), n2,
-                           z.altValues(), z.altIndexMem(),
-                           rhs3.altValues(), rhs3.altIndexMem(), n3);
-   x.setSize(n1);
-   y.setSize(n2);
-   z.setSize(n3);
-
-   if(n1 > 0)
-      x.forceSetup();
-
-   if(n2 > 0)
-      y.forceSetup();
+void SLUFactor<R>::solveLeft(SSVectorBase<R> &x, SSVectorBase<R> &y,
+                             SSVectorBase<R> &z, const SVectorBase<R> &rhs1,
+                             SSVectorBase<R> &rhs2, SSVectorBase<R> &rhs3) {
+
+  solveTime->start();
+
+  int n1, n2, n3;
+  R *svec = ssvec.altValues();
+  int *sidx = ssvec.altIndexMem();
+
+  x.clear();
+  y.clear();
+  z.clear();
+  ssvec.assign(rhs1);
+  n1 = ssvec.size(); // see altValues();
+  n2 = rhs2.size();
+  n3 = rhs3.size();
+  this->vSolveLeft3sparse(
+      x.getEpsilon(), x.altValues(), x.altIndexMem(), svec, sidx, n1,
+      y.altValues(), y.altIndexMem(), rhs2.altValues(), rhs2.altIndexMem(), n2,
+      z.altValues(), z.altIndexMem(), rhs3.altValues(), rhs3.altIndexMem(), n3);
+  x.setSize(n1);
+  y.setSize(n2);
+  z.setSize(n3);
+
+  if (n1 > 0)
+    x.forceSetup();
+
+  if (n2 > 0)
+    y.forceSetup();
+
+  if (n3 > 0)
+    z.forceSetup();
+
+  ssvec.setSize(0);
+  ssvec.forceSetup();
+
+  solveCount += 3;
+  solveTime->stop();
+}
 
-   if(n3 > 0)
-      z.forceSetup();
+template <class R> R SLUFactor<R>::stability() const {
+  if (status() != this->OK)
+    return 0;
 
-   ssvec.setSize(0);
-   ssvec.forceSetup();
+  if (this->maxabs < this->initMaxabs)
+    return 1;
 
-   solveCount += 3;
-   solveTime->stop();
+  assert(this->maxabs != 0.0);
+  return this->initMaxabs / this->maxabs;
 }
 
+template <class R> R SLUFactor<R>::matrixMetric(int type) const {
+  R result = 0.0;
 
-template <class R>
-R SLUFactor<R>::stability() const
-{
-   if(status() != this->OK)
-      return 0;
+  // catch corner case of empty matrix
+  if (dim() == 0)
+    return 1.0;
 
-   if(this->maxabs < this->initMaxabs)
-      return 1;
+  switch (type) {
+  // compute condition estimate by ratio of max/min of elements on the diagonal
+  case 0: {
+    R mindiag = spxAbs(this->diag[0]);
+    R maxdiag = spxAbs(this->diag[0]);
 
-   assert(this->maxabs != 0.0);
-   return this->initMaxabs / this->maxabs;
-}
+    for (int i = 1; i < dim(); ++i) {
+      R absdiag = spxAbs(this->diag[i]);
 
-template <class R>
-R SLUFactor<R>::matrixMetric(int type) const
-{
-   R result = 0.0;
-
-   // catch corner case of empty matrix
-   if(dim() == 0)
-      return 1.0;
-
-   switch(type)
-   {
-   // compute condition estimate by ratio of max/min of elements on the diagonal
-   case 0:
-   {
-      R mindiag = spxAbs(this->diag[0]);
-      R maxdiag = spxAbs(this->diag[0]);
-
-      for(int i = 1; i < dim(); ++i)
-      {
-         R absdiag = spxAbs(this->diag[i]);
-
-         if(absdiag < mindiag)
-            mindiag = absdiag;
-         else if(absdiag > maxdiag)
-            maxdiag = absdiag;
-      }
+      if (absdiag < mindiag)
+        mindiag = absdiag;
+      else if (absdiag > maxdiag)
+        maxdiag = absdiag;
+    }
 
-      result = maxdiag / mindiag;
-      break;
-   }
+    result = maxdiag / mindiag;
+    break;
+  }
 
-   // compute sum of inverses of all elements on the diagonal
-   case 1:
-      result = 0.0;
+  // compute sum of inverses of all elements on the diagonal
+  case 1:
+    result = 0.0;
 
-      for(int i = 0; i < dim(); ++i)
-         result += 1.0 / this->diag[i];
+    for (int i = 0; i < dim(); ++i)
+      result += 1.0 / this->diag[i];
 
-      break;
+    break;
 
-   // compute determinant (product of all diagonal elements of U)
-   case 2:
-      result = 1.0;
+  // compute determinant (product of all diagonal elements of U)
+  case 2:
+    result = 1.0;
 
-      for(int i = 0; i < dim(); ++i)
-         result *= this->diag[i];
+    for (int i = 0; i < dim(); ++i)
+      result *= this->diag[i];
 
-      result = 1.0 / result;
-      break;
-   }
+    result = 1.0 / result;
+    break;
+  }
 
-   return result;
+  return result;
 }
 
-template <class R>
-std::string SLUFactor<R>::statistics() const
-{
-   std::stringstream s;
-   s  << "Factorizations     : " << std::setw(10) << getFactorCount() << std::endl
-      << "  Time spent       : " << std::setw(10) << std::fixed << std::setprecision(
-         2) << getFactorTime() << std::endl
-      << "Solves             : " << std::setw(10) << getSolveCount() << std::endl
-      << "  Time spent       : " << std::setw(10) << getSolveTime() << std::endl;
-
-   return s.str();
+template <class R> std::string SLUFactor<R>::statistics() const {
+  std::stringstream s;
+  s << "Factorizations     : " << std::setw(10) << getFactorCount() << std::endl
+    << "  Time spent       : " << std::setw(10) << std::fixed
+    << std::setprecision(2) << getFactorTime() << std::endl
+    << "Solves             : " << std::setw(10) << getSolveCount() << std::endl
+    << "  Time spent       : " << std::setw(10) << getSolveTime() << std::endl;
+
+  return s.str();
 }
 
-template <class R>
-void SLUFactor<R>::changeEta(int idx, SSVectorBase<R>& et)
-{
+template <class R> void SLUFactor<R>::changeEta(int idx, SSVectorBase<R> &et) {
 
-   int es = et.size(); // see altValues()
-   this->update(idx, et.altValues(), et.altIndexMem(), es);
-   et.setSize(0);
-   et.forceSetup();
+  int es = et.size(); // see altValues()
+  this->update(idx, et.altValues(), et.altIndexMem(), es);
+  et.setSize(0);
+  et.forceSetup();
 }
 
 template <class R>
-typename SLUFactor<R>::Status SLUFactor<R>::change(
-   int             idx,
-   const SVectorBase<R>&  subst,
-   const SSVectorBase<R>* e)
-{
-
-   // BH 2005-08-23: The boolean usetup indicates that an "update VectorBase<R>"
-   // has been set up. I suppose that SSVectorBase<R>  forest is this
-   // update VectorBase<R>, which is set up by solveRight4update() and
-   // solve2right4update() in order to optimize the basis update.
-
-   if(usetup)
-   {
-      if(this->l.updateType == FOREST_TOMLIN)               // FOREST_TOMLIN updates
-      {
-         // BH 2005-08-19: The size of a SSVectorBase<R>  is the size of the
-         // index set, i.e.  the number of nonzeros which is only
-         // defined if the SSVectorBase<R>  is set up.  Since
-         // SSVectorBase<R> ::altValues() calls unSetup() the size needs to be
-         // stored before the following call.
-         int fsize = forest.size(); // see altValues()
-         this->forestUpdate(idx, forest.altValues(), fsize, forest.altIndexMem());
-         forest.setSize(0);
-         forest.forceSetup();
-      }
-      else
-      {
-         assert(this->l.updateType == ETA);
-         changeEta(idx, eta);
-      }
-   }
-   else if(e != 0)                                    // ETA updates
-   {
-      this->l.updateType = ETA;
-      this->updateNoClear(idx, e->values(), e->indexMem(), e->size());
-      this->l.updateType = uptype;
-   }
-   else if(this->l.updateType == FOREST_TOMLIN)             // FOREST_TOMLIN updates
-   {
-      assert(0);  // probably this part is never called.
-      // forestUpdate() with the last parameter set to NULL should fail.
-      forest = subst;
-      CLUFactor<R>::solveLright(forest.altValues());
-      this->forestUpdate(idx, forest.altValues(), 0, nullptr);
+typename SLUFactor<R>::Status SLUFactor<R>::change(int idx,
+                                                   const SVectorBase<R> &subst,
+                                                   const SSVectorBase<R> *e) {
+
+  // BH 2005-08-23: The boolean usetup indicates that an "update VectorBase<R>"
+  // has been set up. I suppose that SSVectorBase<R>  forest is this
+  // update VectorBase<R>, which is set up by solveRight4update() and
+  // solve2right4update() in order to optimize the basis update.
+
+  if (usetup) {
+    if (this->l.updateType == FOREST_TOMLIN) // FOREST_TOMLIN updates
+    {
+      // BH 2005-08-19: The size of a SSVectorBase<R>  is the size of the
+      // index set, i.e.  the number of nonzeros which is only
+      // defined if the SSVectorBase<R>  is set up.  Since
+      // SSVectorBase<R> ::altValues() calls unSetup() the size needs to be
+      // stored before the following call.
+      int fsize = forest.size(); // see altValues()
+      this->forestUpdate(idx, forest.altValues(), fsize, forest.altIndexMem());
       forest.setSize(0);
       forest.forceSetup();
-   }
-   else                                               // ETA updates
-   {
+    } else {
       assert(this->l.updateType == ETA);
-      vec = subst;
-      eta.clear();
-      CLUFactor<R>::solveRight(eta.altValues(), vec.get_ptr());
       changeEta(idx, eta);
-   }
-
-   usetup = false;
-
-   MSG_DEBUG(std::cout << "DSLUFA01\tupdated\t\tstability = " << stability()
-             << std::endl;)
-
-   return status();
+    }
+  } else if (e != 0) // ETA updates
+  {
+    this->l.updateType = ETA;
+    this->updateNoClear(idx, e->values(), e->indexMem(), e->size());
+    this->l.updateType = uptype;
+  } else if (this->l.updateType == FOREST_TOMLIN) // FOREST_TOMLIN updates
+  {
+    assert(0); // probably this part is never called.
+    // forestUpdate() with the last parameter set to NULL should fail.
+    forest = subst;
+    CLUFactor<R>::solveLright(forest.altValues());
+    this->forestUpdate(idx, forest.altValues(), 0, nullptr);
+    forest.setSize(0);
+    forest.forceSetup();
+  } else // ETA updates
+  {
+    assert(this->l.updateType == ETA);
+    vec = subst;
+    eta.clear();
+    CLUFactor<R>::solveRight(eta.altValues(), vec.get_ptr());
+    changeEta(idx, eta);
+  }
+
+  usetup = false;
+
+  MSG_DEBUG(std::cout << "DSLUFA01\tupdated\t\tstability = " << stability()
+                      << std::endl;)
+
+  return status();
 }
 
-template <class R>
-void SLUFactor<R>::clear()
-{
+template <class R> void SLUFactor<R>::clear() {
 
-   this->rowMemMult    = 5;          /* factor of minimum Memory * #of nonzeros */
-   this->colMemMult    = 5;          /* factor of minimum Memory * #of nonzeros */
-   this->lMemMult      = 1;          /* factor of minimum Memory * #of nonzeros */
+  this->rowMemMult = 5; /* factor of minimum Memory * #of nonzeros */
+  this->colMemMult = 5; /* factor of minimum Memory * #of nonzeros */
+  this->lMemMult = 1;   /* factor of minimum Memory * #of nonzeros */
 
-   this->l.firstUpdate = 0;
-   this->l.firstUnused = 0;
-   this->thedim        = 0;
+  this->l.firstUpdate = 0;
+  this->l.firstUnused = 0;
+  this->thedim = 0;
 
-   epsilon       = Param::epsilonFactorization();
-   usetup        = false;
-   this->maxabs        = 1;
-   this->initMaxabs    = 1;
-   lastThreshold = minThreshold;
-   minStability  = MINSTABILITY;
-   this->stat          = this->UNLOADED;
+  epsilon = Param::epsilonFactorization();
+  usetup = false;
+  this->maxabs = 1;
+  this->initMaxabs = 1;
+  lastThreshold = minThreshold;
+  minStability = MINSTABILITY;
+  this->stat = this->UNLOADED;
 
-   vec.clear();
-   eta.clear();
-   ssvec.clear();
-   forest.clear();
+  vec.clear();
+  eta.clear();
+  ssvec.clear();
+  forest.clear();
 
-   this->u.row.size    = 100;
-   this->u.col.size    = 100;
-   this->l.size        = 100;
-   this->l.startSize   = 100;
+  this->u.row.size = 100;
+  this->u.col.size = 100;
+  this->l.size = 100;
+  this->l.startSize = 100;
 
-   if(this->l.ridx)
-      spx_free(this->l.ridx);
+  if (this->l.ridx)
+    spx_free(this->l.ridx);
 
-   if(this->l.rbeg)
-      spx_free(this->l.rbeg);
+  if (this->l.rbeg)
+    spx_free(this->l.rbeg);
 
-   if(this->l.rorig)
-      spx_free(this->l.rorig);
+  if (this->l.rorig)
+    spx_free(this->l.rorig);
 
-   if(this->l.rperm)
-      spx_free(this->l.rperm);
+  if (this->l.rperm)
+    spx_free(this->l.rperm);
 
-   if(!this->u.row.val.empty())
-      this->u.row.val.clear();
+  if (!this->u.row.val.empty())
+    this->u.row.val.clear();
 
-   if(this->u.row.idx)
-      spx_free(this->u.row.idx);
+  if (this->u.row.idx)
+    spx_free(this->u.row.idx);
 
-   if(this->u.col.idx)
-      spx_free(this->u.col.idx);
+  if (this->u.col.idx)
+    spx_free(this->u.col.idx);
 
-   if(this->l.val.empty())
-      this->l.val.clear();
+  if (this->l.val.empty())
+    this->l.val.clear();
 
-   if(this->l.idx)
-      spx_free(this->l.idx);
+  if (this->l.idx)
+    spx_free(this->l.idx);
 
-   if(this->l.start)
-      spx_free(this->l.start);
+  if (this->l.start)
+    spx_free(this->l.start);
 
-   if(this->l.row)
-      spx_free(this->l.row);
+  if (this->l.row)
+    spx_free(this->l.row);
 
-   // G clear() is used in constructor of SLUFactor<R> so we have to
-   // G clean up if anything goes wrong here
-   try
-   {
-      this->u.row.val.resize(this->u.row.size);
-      spx_alloc(this->u.row.idx, this->u.row.size);
-      spx_alloc(this->u.col.idx, this->u.col.size);
+  // G clear() is used in constructor of SLUFactor<R> so we have to
+  // G clean up if anything goes wrong here
+  try {
+    this->u.row.val.resize(this->u.row.size);
+    spx_alloc(this->u.row.idx, this->u.row.size);
+    spx_alloc(this->u.col.idx, this->u.col.size);
 
-      this->l.val.resize(this->l.size);
-      spx_alloc(this->l.idx,   this->l.size);
-      spx_alloc(this->l.start, this->l.startSize);
-      spx_alloc(this->l.row,   this->l.startSize);
-   }
-   catch(const SPxMemoryException& x)
-   {
-      freeAll();
-      throw x;
-   }
+    this->l.val.resize(this->l.size);
+    spx_alloc(this->l.idx, this->l.size);
+    spx_alloc(this->l.start, this->l.startSize);
+    spx_alloc(this->l.row, this->l.startSize);
+  } catch (const SPxMemoryException &x) {
+    freeAll();
+    throw x;
+  }
 }
 
 /** assignment used to implement operator=() and copy constructor.
  *  If this is initialised, freeAll() has to be called before.
  *  Class objects from SLUFactor<R> are not copied here.
  */
-template <class R>
-void SLUFactor<R>::assign(const SLUFactor<R>& old)
-{
-   this->spxout = old.spxout;
-
-   solveTime = TimerFactory::createTimer(old.solveTime->type());
-   this->factorTime = TimerFactory::createTimer(old.factorTime->type());
-
-   // slufactor
-   uptype        = old.uptype;
-   minThreshold  = old.minThreshold;
-   minStability  = old.minStability;
-   epsilon       = old.epsilon;
-   lastThreshold = old.lastThreshold;
-
-   // clufactor
-   this->stat          = old.stat;
-   this->thedim        = old.thedim;
-   this->nzCnt         = old.nzCnt;
-   this->initMaxabs    = old.initMaxabs;
-   this->maxabs        = old.maxabs;
-   this->rowMemMult    = old.rowMemMult;
-   this->colMemMult    = old.colMemMult;
-   this->lMemMult      = old.lMemMult;
-
-   spx_alloc(this->row.perm, this->thedim);
-   spx_alloc(this->row.orig, this->thedim);
-   spx_alloc(this->col.perm, this->thedim);
-   spx_alloc(this->col.orig, this->thedim);
-   // spx_alloc(this->diag,     this->thedim);
-   this->diag.reserve(this->thedim); // small performance improvement before copying
-
-   memcpy(this->row.perm, old.row.perm, (unsigned int)this->thedim * sizeof(*this->row.perm));
-   memcpy(this->row.orig, old.row.orig, (unsigned int)this->thedim * sizeof(*this->row.orig));
-   memcpy(this->col.perm, old.col.perm, (unsigned int)this->thedim * sizeof(*this->col.perm));
-   memcpy(this->col.orig, old.col.orig, (unsigned int)this->thedim * sizeof(*this->col.orig));
-
-   this->diag = old.diag;
-
-   this->work = vec.get_ptr();
-
-   /* setup U
-    */
-   this->u.row.size = old.u.row.size;
-   this->u.row.used = old.u.row.used;
-
-   spx_alloc(this->u.row.elem,  this->thedim);
-   this->u.row.val.reserve(this->u.row.size); // small performance improvement
-   spx_alloc(this->u.row.idx,   this->u.row.size);
-   spx_alloc(this->u.row.start, this->thedim + 1);
-   spx_alloc(this->u.row.len,   this->thedim + 1);
-   spx_alloc(this->u.row.max,   this->thedim + 1);
-
-   memcpy(this->u.row.elem,  old.u.row.elem,
-          (unsigned int)this->thedim       * sizeof(*this->u.row.elem));
-   this->u.row.val = old.u.row.val;
-   memcpy(this->u.row.idx,   old.u.row.idx,
-          (unsigned int)this->u.row.size   * sizeof(*this->u.row.idx));
-   memcpy(this->u.row.start, old.u.row.start,
-          (unsigned int)(this->thedim + 1) * sizeof(*this->u.row.start));
-   memcpy(this->u.row.len,   old.u.row.len,
-          (unsigned int)(this->thedim + 1) * sizeof(*this->u.row.len));
-   memcpy(this->u.row.max,   old.u.row.max,
-          (unsigned int)(this->thedim + 1) * sizeof(*this->u.row.max));
-
-   // need to make row list ok ?
-   if(this->thedim > 0 && this->stat == this->OK)
-   {
-      this->u.row.list.idx = old.u.row.list.idx; // .idx neu
-
-      const typename CLUFactor<R>::Dring* oring = &old.u.row.list;
-      typename CLUFactor<R>::Dring*       ring  = &this->u.row.list;
-
-      while(oring->next != &old.u.row.list)
-      {
-         ring->next       = &this->u.row.elem[oring->next->idx];
-         ring->next->prev = ring;
-         oring            = oring->next;
-         ring             = ring->next;
-      }
-
-      ring->next       = &this->u.row.list;
+template <class R> void SLUFactor<R>::assign(const SLUFactor<R> &old) {
+  this->spxout = old.spxout;
+
+  solveTime = TimerFactory::createTimer(old.solveTime->type());
+  this->factorTime = TimerFactory::createTimer(old.factorTime->type());
+
+  // slufactor
+  uptype = old.uptype;
+  minThreshold = old.minThreshold;
+  minStability = old.minStability;
+  epsilon = old.epsilon;
+  lastThreshold = old.lastThreshold;
+
+  // clufactor
+  this->stat = old.stat;
+  this->thedim = old.thedim;
+  this->nzCnt = old.nzCnt;
+  this->initMaxabs = old.initMaxabs;
+  this->maxabs = old.maxabs;
+  this->rowMemMult = old.rowMemMult;
+  this->colMemMult = old.colMemMult;
+  this->lMemMult = old.lMemMult;
+
+  spx_alloc(this->row.perm, this->thedim);
+  spx_alloc(this->row.orig, this->thedim);
+  spx_alloc(this->col.perm, this->thedim);
+  spx_alloc(this->col.orig, this->thedim);
+  // spx_alloc(this->diag,     this->thedim);
+  this->diag.reserve(
+      this->thedim); // small performance improvement before copying
+
+  memcpy(this->row.perm, old.row.perm,
+         (unsigned int)this->thedim * sizeof(*this->row.perm));
+  memcpy(this->row.orig, old.row.orig,
+         (unsigned int)this->thedim * sizeof(*this->row.orig));
+  memcpy(this->col.perm, old.col.perm,
+         (unsigned int)this->thedim * sizeof(*this->col.perm));
+  memcpy(this->col.orig, old.col.orig,
+         (unsigned int)this->thedim * sizeof(*this->col.orig));
+
+  this->diag = old.diag;
+
+  this->work = vec.get_ptr();
+
+  /* setup U
+   */
+  this->u.row.size = old.u.row.size;
+  this->u.row.used = old.u.row.used;
+
+  spx_alloc(this->u.row.elem, this->thedim);
+  this->u.row.val.reserve(this->u.row.size); // small performance improvement
+  spx_alloc(this->u.row.idx, this->u.row.size);
+  spx_alloc(this->u.row.start, this->thedim + 1);
+  spx_alloc(this->u.row.len, this->thedim + 1);
+  spx_alloc(this->u.row.max, this->thedim + 1);
+
+  memcpy(this->u.row.elem, old.u.row.elem,
+         (unsigned int)this->thedim * sizeof(*this->u.row.elem));
+  this->u.row.val = old.u.row.val;
+  memcpy(this->u.row.idx, old.u.row.idx,
+         (unsigned int)this->u.row.size * sizeof(*this->u.row.idx));
+  memcpy(this->u.row.start, old.u.row.start,
+         (unsigned int)(this->thedim + 1) * sizeof(*this->u.row.start));
+  memcpy(this->u.row.len, old.u.row.len,
+         (unsigned int)(this->thedim + 1) * sizeof(*this->u.row.len));
+  memcpy(this->u.row.max, old.u.row.max,
+         (unsigned int)(this->thedim + 1) * sizeof(*this->u.row.max));
+
+  // need to make row list ok ?
+  if (this->thedim > 0 && this->stat == this->OK) {
+    this->u.row.list.idx = old.u.row.list.idx; // .idx neu
+
+    const typename CLUFactor<R>::Dring *oring = &old.u.row.list;
+    typename CLUFactor<R>::Dring *ring = &this->u.row.list;
+
+    while (oring->next != &old.u.row.list) {
+      ring->next = &this->u.row.elem[oring->next->idx];
       ring->next->prev = ring;
-   }
-
-   this->u.col.size = old.u.col.size;
-   this->u.col.used = old.u.col.used;
-
-   spx_alloc(this->u.col.elem,  this->thedim);
-   spx_alloc(this->u.col.idx,   this->u.col.size);
-   spx_alloc(this->u.col.start, this->thedim + 1);
-   spx_alloc(this->u.col.len,   this->thedim + 1);
-   spx_alloc(this->u.col.max,   this->thedim + 1);
-
-   if(!old.u.col.val.empty())
-   {
-      this->u.col.val.reserve(this->u.col.size); // small performance improvement before copying
-      this->u.col.val = old.u.col.val;
-   }
-   else
-   {
-      this->u.col.val.clear();
-   }
-
-   memcpy(this->u.col.elem,  old.u.col.elem,
-          (unsigned int)this->thedim       * sizeof(*this->u.col.elem));
-   memcpy(this->u.col.idx,   old.u.col.idx,
-          (unsigned int)this->u.col.size   * sizeof(*this->u.col.idx));
-   memcpy(this->u.col.start, old.u.col.start,
-          (unsigned int)(this->thedim + 1) * sizeof(*this->u.col.start));
-   memcpy(this->u.col.len,   old.u.col.len,
-          (unsigned int)(this->thedim + 1) * sizeof(*this->u.col.len));
-   memcpy(this->u.col.max,   old.u.col.max,
-          (unsigned int)(this->thedim + 1) * sizeof(*this->u.col.max));
-
-   // need to make col list ok
-   if(this->thedim > 0 && this->stat == this->OK)
-   {
-      this->u.col.list.idx = old.u.col.list.idx; // .idx neu
-
-      const typename CLUFactor<R>::Dring* oring = &old.u.col.list;
-      typename CLUFactor<R>::Dring*       ring  = &this->u.col.list;
-
-      while(oring->next != &old.u.col.list)
-      {
-         ring->next       = &this->u.col.elem[oring->next->idx];
-         ring->next->prev = ring;
-         oring            = oring->next;
-         ring             = ring->next;
-      }
-
-      ring->next       = &this->u.col.list;
+      oring = oring->next;
+      ring = ring->next;
+    }
+
+    ring->next = &this->u.row.list;
+    ring->next->prev = ring;
+  }
+
+  this->u.col.size = old.u.col.size;
+  this->u.col.used = old.u.col.used;
+
+  spx_alloc(this->u.col.elem, this->thedim);
+  spx_alloc(this->u.col.idx, this->u.col.size);
+  spx_alloc(this->u.col.start, this->thedim + 1);
+  spx_alloc(this->u.col.len, this->thedim + 1);
+  spx_alloc(this->u.col.max, this->thedim + 1);
+
+  if (!old.u.col.val.empty()) {
+    this->u.col.val.reserve(
+        this->u.col.size); // small performance improvement before copying
+    this->u.col.val = old.u.col.val;
+  } else {
+    this->u.col.val.clear();
+  }
+
+  memcpy(this->u.col.elem, old.u.col.elem,
+         (unsigned int)this->thedim * sizeof(*this->u.col.elem));
+  memcpy(this->u.col.idx, old.u.col.idx,
+         (unsigned int)this->u.col.size * sizeof(*this->u.col.idx));
+  memcpy(this->u.col.start, old.u.col.start,
+         (unsigned int)(this->thedim + 1) * sizeof(*this->u.col.start));
+  memcpy(this->u.col.len, old.u.col.len,
+         (unsigned int)(this->thedim + 1) * sizeof(*this->u.col.len));
+  memcpy(this->u.col.max, old.u.col.max,
+         (unsigned int)(this->thedim + 1) * sizeof(*this->u.col.max));
+
+  // need to make col list ok
+  if (this->thedim > 0 && this->stat == this->OK) {
+    this->u.col.list.idx = old.u.col.list.idx; // .idx neu
+
+    const typename CLUFactor<R>::Dring *oring = &old.u.col.list;
+    typename CLUFactor<R>::Dring *ring = &this->u.col.list;
+
+    while (oring->next != &old.u.col.list) {
+      ring->next = &this->u.col.elem[oring->next->idx];
       ring->next->prev = ring;
-   }
-
-   /* Setup L
-    */
-   this->l.size        = old.l.size;
-   this->l.startSize   = old.l.startSize;
-   this->l.firstUpdate = old.l.firstUpdate;
-   this->l.firstUnused = old.l.firstUnused;
-   this->l.updateType  = old.l.updateType;
-
-   this->l.val.reserve(this->l.size); // small performance improvement for copying
-   spx_alloc(this->l.idx,   this->l.size);
-   spx_alloc(this->l.start, this->l.startSize);
-   spx_alloc(this->l.row,   this->l.startSize);
-
-   this->l.val = old.l.val;
-   memcpy(this->l.idx,   old.l.idx, (unsigned int)this->l.size      * sizeof(*this->l.idx));
-   memcpy(this->l.start, old.l.start, (unsigned int)this->l.startSize * sizeof(*this->l.start));
-   memcpy(this->l.row,   old.l.row, (unsigned int)this->l.startSize * sizeof(*this->l.row));
-
-   if(!this->l.rval.empty())
-   {
-      assert(old.l.ridx  != 0);
-      assert(old.l.rbeg  != 0);
-      assert(old.l.rorig != 0);
-      assert(old.l.rperm != 0);
-
-      int memsize = this->l.start[this->l.firstUpdate];
-
-      this->l.rval.reserve(memsize); // small performance improvement for copying
-      spx_alloc(this->l.ridx,  memsize);
-      spx_alloc(this->l.rbeg,  this->thedim + 1);
-      spx_alloc(this->l.rorig, this->thedim);
-      spx_alloc(this->l.rperm, this->thedim);
-
-      this->l.rval = old.l.rval;
-      memcpy(this->l.ridx,  old.l.ridx, (unsigned int)memsize     * sizeof(*this->l.ridx));
-      memcpy(this->l.rbeg,  old.l.rbeg, (unsigned int)(this->thedim + 1) * sizeof(*this->l.rbeg));
-      memcpy(this->l.rorig, old.l.rorig, (unsigned int)this->thedim      * sizeof(*this->l.rorig));
-      memcpy(this->l.rperm, old.l.rperm, (unsigned int)this->thedim      * sizeof(*this->l.rperm));
-   }
-   else
-   {
-      assert(old.l.ridx  == 0);
-      assert(old.l.rbeg  == 0);
-      assert(old.l.rorig == 0);
-      assert(old.l.rperm == 0);
-
-      this->l.ridx  = 0;
-      this->l.rbeg  = 0;
-      this->l.rorig = 0;
-      this->l.rperm = 0;
-   }
-
-   assert(this->row.perm != 0);
-   assert(this->row.orig != 0);
-   assert(this->col.perm != 0);
-   assert(this->col.orig != 0);
-
-   assert(this->u.row.elem  != 0);
-   assert(this->u.row.idx   != 0);
-   assert(this->u.row.start != 0);
-   assert(this->u.row.len   != 0);
-   assert(this->u.row.max   != 0);
-
-   assert(this->u.col.elem  != 0);
-   assert(this->u.col.idx   != 0);
-   assert(this->u.col.start != 0);
-   assert(this->u.col.len   != 0);
-   assert(this->u.col.max   != 0);
-
-   assert(this->l.idx   != 0);
-   assert(this->l.start != 0);
-   assert(this->l.row   != 0);
-
+      oring = oring->next;
+      ring = ring->next;
+    }
+
+    ring->next = &this->u.col.list;
+    ring->next->prev = ring;
+  }
+
+  /* Setup L
+   */
+  this->l.size = old.l.size;
+  this->l.startSize = old.l.startSize;
+  this->l.firstUpdate = old.l.firstUpdate;
+  this->l.firstUnused = old.l.firstUnused;
+  this->l.updateType = old.l.updateType;
+
+  this->l.val.reserve(
+      this->l.size); // small performance improvement for copying
+  spx_alloc(this->l.idx, this->l.size);
+  spx_alloc(this->l.start, this->l.startSize);
+  spx_alloc(this->l.row, this->l.startSize);
+
+  this->l.val = old.l.val;
+  memcpy(this->l.idx, old.l.idx,
+         (unsigned int)this->l.size * sizeof(*this->l.idx));
+  memcpy(this->l.start, old.l.start,
+         (unsigned int)this->l.startSize * sizeof(*this->l.start));
+  memcpy(this->l.row, old.l.row,
+         (unsigned int)this->l.startSize * sizeof(*this->l.row));
+
+  if (!this->l.rval.empty()) {
+    assert(old.l.ridx != 0);
+    assert(old.l.rbeg != 0);
+    assert(old.l.rorig != 0);
+    assert(old.l.rperm != 0);
+
+    int memsize = this->l.start[this->l.firstUpdate];
+
+    this->l.rval.reserve(memsize); // small performance improvement for copying
+    spx_alloc(this->l.ridx, memsize);
+    spx_alloc(this->l.rbeg, this->thedim + 1);
+    spx_alloc(this->l.rorig, this->thedim);
+    spx_alloc(this->l.rperm, this->thedim);
+
+    this->l.rval = old.l.rval;
+    memcpy(this->l.ridx, old.l.ridx,
+           (unsigned int)memsize * sizeof(*this->l.ridx));
+    memcpy(this->l.rbeg, old.l.rbeg,
+           (unsigned int)(this->thedim + 1) * sizeof(*this->l.rbeg));
+    memcpy(this->l.rorig, old.l.rorig,
+           (unsigned int)this->thedim * sizeof(*this->l.rorig));
+    memcpy(this->l.rperm, old.l.rperm,
+           (unsigned int)this->thedim * sizeof(*this->l.rperm));
+  } else {
+    assert(old.l.ridx == 0);
+    assert(old.l.rbeg == 0);
+    assert(old.l.rorig == 0);
+    assert(old.l.rperm == 0);
+
+    this->l.ridx = 0;
+    this->l.rbeg = 0;
+    this->l.rorig = 0;
+    this->l.rperm = 0;
+  }
+
+  assert(this->row.perm != 0);
+  assert(this->row.orig != 0);
+  assert(this->col.perm != 0);
+  assert(this->col.orig != 0);
+
+  assert(this->u.row.elem != 0);
+  assert(this->u.row.idx != 0);
+  assert(this->u.row.start != 0);
+  assert(this->u.row.len != 0);
+  assert(this->u.row.max != 0);
+
+  assert(this->u.col.elem != 0);
+  assert(this->u.col.idx != 0);
+  assert(this->u.col.start != 0);
+  assert(this->u.col.len != 0);
+  assert(this->u.col.max != 0);
+
+  assert(this->l.idx != 0);
+  assert(this->l.start != 0);
+  assert(this->l.row != 0);
 }
 
 template <class R>
-SLUFactor<R>& SLUFactor<R>::operator=(const SLUFactor<R>& old)
-{
+SLUFactor<R> &SLUFactor<R>::operator=(const SLUFactor<R> &old) {
 
-   if(this != &old)
-   {
-      // we don't need to copy them, because they are temporary vectors
-      vec.clear();
-      ssvec.clear();
+  if (this != &old) {
+    // we don't need to copy them, because they are temporary vectors
+    vec.clear();
+    ssvec.clear();
 
-      eta    = old.eta;
-      forest = old.forest;
+    eta = old.eta;
+    forest = old.forest;
 
-      timerType = old.timerType;
+    timerType = old.timerType;
 
-      freeAll();
-
-      try
-      {
-         assign(old);
-      }
-      catch(const SPxMemoryException& x)
-      {
-         freeAll();
-         throw x;
-      }
-
-      assert(isConsistent());
-   }
-
-   return *this;
-}
+    freeAll();
 
-template <class R>
-SLUFactor<R>::SLUFactor()
-   : vec(1)
-   , ssvec(1)
-   , usetup(false)
-   , uptype(FOREST_TOMLIN)
-   , eta(1)
-   , forest(1)
-   , minThreshold(0.01)
-   , timerType(Timer::USER_TIME)
-{
-   this->row.perm    = 0;
-   this->row.orig    = 0;
-   this->col.perm    = 0;
-   this->col.orig    = 0;
-   this->u.row.elem  = 0;
-   this->u.row.idx   = 0;
-   this->u.row.start = 0;
-   this->u.row.len   = 0;
-   this->u.row.max   = 0;
-   this->u.col.elem  = 0;
-   this->u.col.idx   = 0;
-   this->u.col.start = 0;
-   this->u.col.len   = 0;
-   this->u.col.max   = 0;
-   this->l.idx       = 0;
-   this->l.start     = 0;
-   this->l.row       = 0;
-   this->l.ridx      = 0;
-   this->l.rbeg      = 0;
-   this->l.rorig     = 0;
-   this->l.rperm     = 0;
-
-   this->nzCnt  = 0;
-   this->thedim = 0;
-
-   try
-   {
-      solveTime = TimerFactory::createTimer(timerType);
-      this->factorTime = TimerFactory::createTimer(timerType);
-      spx_alloc(this->row.perm, this->thedim);
-      spx_alloc(this->row.orig, this->thedim);
-      spx_alloc(this->col.perm, this->thedim);
-      spx_alloc(this->col.orig, this->thedim);
-
-      this->diag.resize(this->thedim);
-
-      this->work = vec.get_ptr();
-
-      this->u.row.size = 1;
-      this->u.row.used = 0;
-      spx_alloc(this->u.row.elem,  this->thedim);
-      this->u.row.val.resize(this->u.row.size);
-      spx_alloc(this->u.row.idx,   this->u.row.size);
-      spx_alloc(this->u.row.start, this->thedim + 1);
-      spx_alloc(this->u.row.len,   this->thedim + 1);
-      spx_alloc(this->u.row.max,   this->thedim + 1);
-
-      this->u.row.list.idx      = this->thedim;
-      this->u.row.start[this->thedim] = 0;
-      this->u.row.max  [this->thedim] = 0;
-      this->u.row.len  [this->thedim] = 0;
-
-      this->u.col.size = 1;
-      this->u.col.used = 0;
-      spx_alloc(this->u.col.elem,  this->thedim);
-      spx_alloc(this->u.col.idx,   this->u.col.size);
-      spx_alloc(this->u.col.start, this->thedim + 1);
-      spx_alloc(this->u.col.len,   this->thedim + 1);
-      spx_alloc(this->u.col.max,   this->thedim + 1);
-
-      this->u.col.list.idx      = this->thedim;
-      this->u.col.start[this->thedim] = 0;
-      this->u.col.max[this->thedim]   = 0;
-      this->u.col.len[this->thedim]   = 0;
-
-      this->l.size = 1;
-
-      this->l.val.resize(this->l.size);
-      spx_alloc(this->l.idx, this->l.size);
-
-      this->l.startSize   = 1;
-      this->l.firstUpdate = 0;
-      this->l.firstUnused = 0;
-
-      spx_alloc(this->l.start, this->l.startSize);
-      spx_alloc(this->l.row,   this->l.startSize);
-   }
-   catch(const SPxMemoryException& x)
-   {
+    try {
+      assign(old);
+    } catch (const SPxMemoryException &x) {
       freeAll();
       throw x;
-   }
-
-   this->l.ridx  = 0;
-   this->l.rbeg  = 0;
-   this->l.rorig = 0;
-   this->l.rperm = 0;
-
-   SLUFactor<R>::clear(); // clear() is virtual
-
-   this->factorCount = 0;
-   this->hugeValues = 0;
-   solveCount  = 0;
-   assert(this->row.perm != 0);
+    }
 
-   assert(this->row.orig != 0);
-   assert(this->col.perm != 0);
-   assert(this->col.orig != 0);
+    assert(isConsistent());
+  }
 
-   assert(this->u.row.elem  != 0);
-   assert(this->u.row.idx   != 0);
-   assert(this->u.row.start != 0);
-   assert(this->u.row.len   != 0);
-   assert(this->u.row.max   != 0);
-
-   assert(this->u.col.elem  != 0);
-   assert(this->u.col.idx   != 0);
-   assert(this->u.col.start != 0);
-   assert(this->u.col.len   != 0);
-   assert(this->u.col.max   != 0);
-
-   assert(this->l.idx   != 0);
-   assert(this->l.start != 0);
-   assert(this->l.row   != 0);
-
-   assert(SLUFactor<R>::isConsistent());
+  return *this;
 }
 
 template <class R>
-SLUFactor<R>::SLUFactor(const SLUFactor<R>& old)
-   : SLinSolver<R>(old)
-   , vec(1)     // we don't need to copy it, because they are temporary vectors
-   , ssvec(1)   // we don't need to copy it, because they are temporary vectors
-   , usetup(old.usetup)
-   , eta(old.eta)
-   , forest(old.forest)
-   , timerType(old.timerType)
-{
-   this->row.perm    = 0;
-   this->row.orig    = 0;
-   this->col.perm    = 0;
-   this->col.orig    = 0;
-   this->u.row.elem  = 0;
-   this->u.row.val.clear();
-   this->u.row.idx   = 0;
-   this->u.row.start = 0;
-   this->u.row.len   = 0;
-   this->u.row.max   = 0;
-   this->u.col.elem  = 0;
-   this->u.col.idx   = 0;
-   this->u.col.start = 0;
-   this->u.col.len   = 0;
-   this->u.col.max   = 0;
-   this->l.idx       = 0;
-   this->l.start     = 0;
-   this->l.row       = 0;
-   this->l.ridx      = 0;
-   this->l.rbeg      = 0;
-   this->l.rorig     = 0;
-   this->l.rperm     = 0;
-
-   solveCount = 0;
-
-   try
-   {
-      assign(old);
-   }
-   catch(const SPxMemoryException& x)
-   {
-      freeAll();
-      throw x;
-   }
-
-   assert(SLUFactor<R>::isConsistent());
+SLUFactor<R>::SLUFactor()
+    : vec(1), ssvec(1), usetup(false), uptype(FOREST_TOMLIN), eta(1), forest(1),
+      minThreshold(0.01), timerType(Timer::USER_TIME) {
+  this->row.perm = 0;
+  this->row.orig = 0;
+  this->col.perm = 0;
+  this->col.orig = 0;
+  this->u.row.elem = 0;
+  this->u.row.idx = 0;
+  this->u.row.start = 0;
+  this->u.row.len = 0;
+  this->u.row.max = 0;
+  this->u.col.elem = 0;
+  this->u.col.idx = 0;
+  this->u.col.start = 0;
+  this->u.col.len = 0;
+  this->u.col.max = 0;
+  this->l.idx = 0;
+  this->l.start = 0;
+  this->l.row = 0;
+  this->l.ridx = 0;
+  this->l.rbeg = 0;
+  this->l.rorig = 0;
+  this->l.rperm = 0;
+
+  this->nzCnt = 0;
+  this->thedim = 0;
+
+  try {
+    solveTime = TimerFactory::createTimer(timerType);
+    this->factorTime = TimerFactory::createTimer(timerType);
+    spx_alloc(this->row.perm, this->thedim);
+    spx_alloc(this->row.orig, this->thedim);
+    spx_alloc(this->col.perm, this->thedim);
+    spx_alloc(this->col.orig, this->thedim);
+
+    this->diag.resize(this->thedim);
+
+    this->work = vec.get_ptr();
+
+    this->u.row.size = 1;
+    this->u.row.used = 0;
+    spx_alloc(this->u.row.elem, this->thedim);
+    this->u.row.val.resize(this->u.row.size);
+    spx_alloc(this->u.row.idx, this->u.row.size);
+    spx_alloc(this->u.row.start, this->thedim + 1);
+    spx_alloc(this->u.row.len, this->thedim + 1);
+    spx_alloc(this->u.row.max, this->thedim + 1);
+
+    this->u.row.list.idx = this->thedim;
+    this->u.row.start[this->thedim] = 0;
+    this->u.row.max[this->thedim] = 0;
+    this->u.row.len[this->thedim] = 0;
+
+    this->u.col.size = 1;
+    this->u.col.used = 0;
+    spx_alloc(this->u.col.elem, this->thedim);
+    spx_alloc(this->u.col.idx, this->u.col.size);
+    spx_alloc(this->u.col.start, this->thedim + 1);
+    spx_alloc(this->u.col.len, this->thedim + 1);
+    spx_alloc(this->u.col.max, this->thedim + 1);
+
+    this->u.col.list.idx = this->thedim;
+    this->u.col.start[this->thedim] = 0;
+    this->u.col.max[this->thedim] = 0;
+    this->u.col.len[this->thedim] = 0;
+
+    this->l.size = 1;
+
+    this->l.val.resize(this->l.size);
+    spx_alloc(this->l.idx, this->l.size);
+
+    this->l.startSize = 1;
+    this->l.firstUpdate = 0;
+    this->l.firstUnused = 0;
+
+    spx_alloc(this->l.start, this->l.startSize);
+    spx_alloc(this->l.row, this->l.startSize);
+  } catch (const SPxMemoryException &x) {
+    freeAll();
+    throw x;
+  }
+
+  this->l.ridx = 0;
+  this->l.rbeg = 0;
+  this->l.rorig = 0;
+  this->l.rperm = 0;
+
+  SLUFactor<R>::clear(); // clear() is virtual
+
+  this->factorCount = 0;
+  this->hugeValues = 0;
+  solveCount = 0;
+  assert(this->row.perm != 0);
+
+  assert(this->row.orig != 0);
+  assert(this->col.perm != 0);
+  assert(this->col.orig != 0);
+
+  assert(this->u.row.elem != 0);
+  assert(this->u.row.idx != 0);
+  assert(this->u.row.start != 0);
+  assert(this->u.row.len != 0);
+  assert(this->u.row.max != 0);
+
+  assert(this->u.col.elem != 0);
+  assert(this->u.col.idx != 0);
+  assert(this->u.col.start != 0);
+  assert(this->u.col.len != 0);
+  assert(this->u.col.max != 0);
+
+  assert(this->l.idx != 0);
+  assert(this->l.start != 0);
+  assert(this->l.row != 0);
+
+  assert(SLUFactor<R>::isConsistent());
 }
 
 template <class R>
-void SLUFactor<R>::freeAll()
-{
+SLUFactor<R>::SLUFactor(const SLUFactor<R> &old)
+    : SLinSolver<R>(old),
+      vec(1) // we don't need to copy it, because they are temporary vectors
+      ,
+      ssvec(1) // we don't need to copy it, because they are temporary vectors
+      ,
+      usetup(old.usetup), eta(old.eta), forest(old.forest),
+      timerType(old.timerType) {
+  this->row.perm = 0;
+  this->row.orig = 0;
+  this->col.perm = 0;
+  this->col.orig = 0;
+  this->u.row.elem = 0;
+  this->u.row.val.clear();
+  this->u.row.idx = 0;
+  this->u.row.start = 0;
+  this->u.row.len = 0;
+  this->u.row.max = 0;
+  this->u.col.elem = 0;
+  this->u.col.idx = 0;
+  this->u.col.start = 0;
+  this->u.col.len = 0;
+  this->u.col.max = 0;
+  this->l.idx = 0;
+  this->l.start = 0;
+  this->l.row = 0;
+  this->l.ridx = 0;
+  this->l.rbeg = 0;
+  this->l.rorig = 0;
+  this->l.rperm = 0;
+
+  solveCount = 0;
+
+  try {
+    assign(old);
+  } catch (const SPxMemoryException &x) {
+    freeAll();
+    throw x;
+  }
+
+  assert(SLUFactor<R>::isConsistent());
+}
 
-   if(this->row.perm)
-      spx_free(this->row.perm);
+template <class R> void SLUFactor<R>::freeAll() {
 
-   if(this->row.orig)
-      spx_free(this->row.orig);
+  if (this->row.perm)
+    spx_free(this->row.perm);
 
-   if(this->col.perm)
-      spx_free(this->col.perm);
+  if (this->row.orig)
+    spx_free(this->row.orig);
 
-   if(this->col.orig)
-      spx_free(this->col.orig);
+  if (this->col.perm)
+    spx_free(this->col.perm);
 
-   if(this->u.row.elem)
-      spx_free(this->u.row.elem);
+  if (this->col.orig)
+    spx_free(this->col.orig);
 
-   if(!this->u.row.val.empty())
-      this->u.row.val.clear();
+  if (this->u.row.elem)
+    spx_free(this->u.row.elem);
 
-   if(this->u.row.idx)
-      spx_free(this->u.row.idx);
+  if (!this->u.row.val.empty())
+    this->u.row.val.clear();
 
-   if(this->u.row.start)
-      spx_free(this->u.row.start);
+  if (this->u.row.idx)
+    spx_free(this->u.row.idx);
 
-   if(this->u.row.len)
-      spx_free(this->u.row.len);
+  if (this->u.row.start)
+    spx_free(this->u.row.start);
 
-   if(this->u.row.max)
-      spx_free(this->u.row.max);
+  if (this->u.row.len)
+    spx_free(this->u.row.len);
 
-   if(this->u.col.elem)
-      spx_free(this->u.col.elem);
+  if (this->u.row.max)
+    spx_free(this->u.row.max);
 
-   if(this->u.col.idx)
-      spx_free(this->u.col.idx);
+  if (this->u.col.elem)
+    spx_free(this->u.col.elem);
 
-   if(this->u.col.start)
-      spx_free(this->u.col.start);
+  if (this->u.col.idx)
+    spx_free(this->u.col.idx);
 
-   if(this->u.col.len)
-      spx_free(this->u.col.len);
+  if (this->u.col.start)
+    spx_free(this->u.col.start);
 
-   if(this->u.col.max)
-      spx_free(this->u.col.max);
+  if (this->u.col.len)
+    spx_free(this->u.col.len);
 
-   if(!this->l.val.empty())
-      this->l.val.clear();
+  if (this->u.col.max)
+    spx_free(this->u.col.max);
 
-   if(this->l.idx)
-      spx_free(this->l.idx);
+  if (!this->l.val.empty())
+    this->l.val.clear();
 
-   if(this->l.start)
-      spx_free(this->l.start);
+  if (this->l.idx)
+    spx_free(this->l.idx);
 
-   if(this->l.row)
-      spx_free(this->l.row);
+  if (this->l.start)
+    spx_free(this->l.start);
 
+  if (this->l.row)
+    spx_free(this->l.row);
 
-   if(!this->u.col.val.empty())
-      this->u.col.val.clear();
+  if (!this->u.col.val.empty())
+    this->u.col.val.clear();
 
-   if(this->l.ridx)
-      spx_free(this->l.ridx);
+  if (this->l.ridx)
+    spx_free(this->l.ridx);
 
-   if(this->l.rbeg)
-      spx_free(this->l.rbeg);
+  if (this->l.rbeg)
+    spx_free(this->l.rbeg);
 
-   if(this->l.rorig)
-      spx_free(this->l.rorig);
+  if (this->l.rorig)
+    spx_free(this->l.rorig);
 
-   if(this->l.rperm)
-      spx_free(this->l.rperm);
+  if (this->l.rperm)
+    spx_free(this->l.rperm);
 
-   if(solveTime)
-   {
-      solveTime->~Timer();
-      spx_free(solveTime);
-   }
+  if (solveTime) {
+    solveTime->~Timer();
+    spx_free(solveTime);
+  }
 
-   if(this->factorTime)
-   {
-      this->factorTime->~Timer();
-      spx_free(this->factorTime);
-   }
+  if (this->factorTime) {
+    this->factorTime->~Timer();
+    spx_free(this->factorTime);
+  }
 }
 
-template <class R>
-SLUFactor<R>::~SLUFactor<R>()
-{
-   freeAll();
-}
+template <class R> SLUFactor<R>::~SLUFactor() { freeAll(); }
 
-template <class R>
-static R betterThreshold(R th)
-{
-   assert(th < R(1.0));
+template <class R> static R betterThreshold(R th) {
+  assert(th < R(1.0));
 
-   if(LT(th, R(0.1)))
-      th *= R(10.0);
-   else if(LT(th, R(0.9)))
-      th = (th + R(1.0)) / R(2.0);
-   else if(LT(th, R(0.999)))
-      th = R(0.99999);
+  if (LT(th, R(0.1)))
+    th *= R(10.0);
+  else if (LT(th, R(0.9)))
+    th = (th + R(1.0)) / R(2.0);
+  else if (LT(th, R(0.999)))
+    th = R(0.99999);
 
-   assert(th < R(1.0));
+  assert(th < R(1.0));
 
-   return th;
+  return th;
 }
 
 template <class R>
-typename SLUFactor<R>::Status SLUFactor<R>::load(const SVectorBase<R>* matrix[], int dm)
-{
-   assert(dm     >= 0);
-   assert(matrix != 0);
-
-   R lastStability = stability();
-
-   initDR(this->u.row.list);
-   initDR(this->u.col.list);
-
-   usetup        = false;
-   this->l.updateType  = uptype;
-   this->l.firstUpdate = 0;
-   this->l.firstUnused = 0;
-
-   if(dm != this->thedim)
-   {
-      clear();
-
-      this->thedim = dm;
-      vec.reDim(this->thedim);
-      ssvec.reDim(this->thedim);
-      eta.reDim(this->thedim);
-      forest.reDim(this->thedim);
-      this->work = vec.get_ptr();
-
-      spx_realloc(this->row.perm, this->thedim);
-      spx_realloc(this->row.orig, this->thedim);
-      spx_realloc(this->col.perm, this->thedim);
-      spx_realloc(this->col.orig, this->thedim);
-      this->diag.resize(this->thedim);
-
-      spx_realloc(this->u.row.elem,  this->thedim);
-      spx_realloc(this->u.row.len,   this->thedim + 1);
-      spx_realloc(this->u.row.max,   this->thedim + 1);
-      spx_realloc(this->u.row.start, this->thedim + 1);
-
-      spx_realloc(this->u.col.elem,  this->thedim);
-      spx_realloc(this->u.col.len,   this->thedim + 1);
-      spx_realloc(this->u.col.max,   this->thedim + 1);
-      spx_realloc(this->u.col.start, this->thedim + 1);
-
-      this->l.startSize = this->thedim + MAXUPDATES;
-
-      spx_realloc(this->l.row,   this->l.startSize);
-      spx_realloc(this->l.start, this->l.startSize);
-   }
-   // the last factorization was reasonably stable, so we decrease the Markowitz threshold (stored in lastThreshold) in
-   // order to favour sparsity
-   else if(lastStability > 2.0 * minStability)
-   {
-      // we reset lastThreshold to its previous value in the sequence minThreshold, betterThreshold(minThreshold),
-      // betterThreshold(betterThreshold(minThreshold)), ...
-      R last   = minThreshold;
-      R better = betterThreshold(last);
-
-      while(better < lastThreshold)
-      {
-         last   = better;
-         better = betterThreshold(last);
-      }
+typename SLUFactor<R>::Status SLUFactor<R>::load(const SVectorBase<R> *matrix[],
+                                                 int dm) {
+  assert(dm >= 0);
+  assert(matrix != 0);
+
+  R lastStability = stability();
+
+  initDR(this->u.row.list);
+  initDR(this->u.col.list);
+
+  usetup = false;
+  this->l.updateType = uptype;
+  this->l.firstUpdate = 0;
+  this->l.firstUnused = 0;
+
+  if (dm != this->thedim) {
+    clear();
+
+    this->thedim = dm;
+    vec.reDim(this->thedim);
+    ssvec.reDim(this->thedim);
+    eta.reDim(this->thedim);
+    forest.reDim(this->thedim);
+    this->work = vec.get_ptr();
+
+    spx_realloc(this->row.perm, this->thedim);
+    spx_realloc(this->row.orig, this->thedim);
+    spx_realloc(this->col.perm, this->thedim);
+    spx_realloc(this->col.orig, this->thedim);
+    this->diag.resize(this->thedim);
+
+    spx_realloc(this->u.row.elem, this->thedim);
+    spx_realloc(this->u.row.len, this->thedim + 1);
+    spx_realloc(this->u.row.max, this->thedim + 1);
+    spx_realloc(this->u.row.start, this->thedim + 1);
+
+    spx_realloc(this->u.col.elem, this->thedim);
+    spx_realloc(this->u.col.len, this->thedim + 1);
+    spx_realloc(this->u.col.max, this->thedim + 1);
+    spx_realloc(this->u.col.start, this->thedim + 1);
+
+    this->l.startSize = this->thedim + MAXUPDATES;
+
+    spx_realloc(this->l.row, this->l.startSize);
+    spx_realloc(this->l.start, this->l.startSize);
+  }
+  // the last factorization was reasonably stable, so we decrease the Markowitz
+  // threshold (stored in lastThreshold) in order to favour sparsity
+  else if (lastStability > 2.0 * minStability) {
+    // we reset lastThreshold to its previous value in the sequence
+    // minThreshold, betterThreshold(minThreshold),
+    // betterThreshold(betterThreshold(minThreshold)), ...
+    R last = minThreshold;
+    R better = betterThreshold(last);
+
+    while (better < lastThreshold) {
+      last = better;
+      better = betterThreshold(last);
+    }
+
+    lastThreshold = last;
+
+    // we reset the minimum stability (which might have been decreased below) to
+    // ensure that the increased sparsity does not hurt the stability
+    minStability = 2 * MINSTABILITY;
+  }
+
+  this->u.row.list.idx = this->thedim;
+  this->u.row.start[this->thedim] = 0;
+  this->u.row.max[this->thedim] = 0;
+  this->u.row.len[this->thedim] = 0;
+
+  this->u.col.list.idx = this->thedim;
+  this->u.col.start[this->thedim] = 0;
+  this->u.col.max[this->thedim] = 0;
+  this->u.col.len[this->thedim] = 0;
+
+  for (;;) {
+    ///@todo if the factorization fails with stat = SINGULAR, distinuish between
+    /// proven singularity (e.g., because of an empty column) and singularity
+    /// due
+    /// to numerics, that could be avoided by changing minStability and
+    /// lastThreshold; in the first case, we want to abort, otherwise change the
+    /// numerics
+    this->stat = this->OK;
+    this->factor(matrix, lastThreshold, epsilon);
+
+    // finish if the factorization is stable
+    if (stability() >= minStability)
+      break;
+
+    // otherwise, we increase the Markowitz threshold
+    R x = lastThreshold;
+    lastThreshold = betterThreshold(lastThreshold);
+
+    // until it doesn't change anymore at its maximum value
+    if (EQ(x, lastThreshold))
+      break;
 
-      lastThreshold = last;
-
-      // we reset the minimum stability (which might have been decreased below) to ensure that the increased sparsity
-      // does not hurt the stability
-      minStability  = 2 * MINSTABILITY;
-   }
-
-   this->u.row.list.idx      = this->thedim;
-   this->u.row.start[this->thedim] = 0;
-   this->u.row.max[this->thedim]   = 0;
-   this->u.row.len[this->thedim]   = 0;
-
-   this->u.col.list.idx      = this->thedim;
-   this->u.col.start[this->thedim] = 0;
-   this->u.col.max[this->thedim]   = 0;
-   this->u.col.len[this->thedim]   = 0;
-
-   for(;;)
-   {
-      ///@todo if the factorization fails with stat = SINGULAR, distinuish between proven singularity (e.g., because of
-      ///an empty column) and singularity due to numerics, that could be avoided by changing minStability and
-      ///lastThreshold; in the first case, we want to abort, otherwise change the numerics
-      this->stat = this->OK;
-      this->factor(matrix, lastThreshold, epsilon);
-
-      // finish if the factorization is stable
-      if(stability() >= minStability)
-         break;
-
-      // otherwise, we increase the Markowitz threshold
-      R x = lastThreshold;
-      lastThreshold = betterThreshold(lastThreshold);
-
-      // until it doesn't change anymore at its maximum value
-      if(EQ(x, lastThreshold))
-         break;
-
-      // we relax the stability requirement
-      minStability /= 2.0;
-
-      MSG_INFO3((*this->spxout), (*this->spxout) <<
-                "ISLUFA01 refactorizing with increased Markowitz threshold: "
-                << lastThreshold << std::endl;)
-   }
-
-   MSG_DEBUG(std::cout << "DSLUFA02 threshold = " << lastThreshold
-             << "\tstability = " << stability()
-             << "\tminStability = " << minStability << std::endl;)
-   MSG_DEBUG(
-   {
-      int i;
-      FILE* fl = fopen("dump.lp", "w");
-      std::cout << "DSLUFA03 Basis:\n";
-      int j = 0;
-
-      for(i = 0; i < dim(); ++i)
-         j += matrix[i]->size();
-      for(i = 0; i < dim(); ++i)
-      {
-         for(j = 0; j < matrix[i]->size(); ++j)
-         {
-            fprintf(fl, "%8d  %8d  ",
-                    i + 1, matrix[i]->index(j) + 1);
-            std::cout << matrix[i]->value(j) << std::endl;
-         }
+    // we relax the stability requirement
+    minStability /= 2.0;
+
+    MSG_INFO3(
+        (*this->spxout),
+        (*this->spxout)
+            << "ISLUFA01 refactorizing with increased Markowitz threshold: "
+            << lastThreshold << std::endl;)
+  }
+
+  MSG_DEBUG(std::cout << "DSLUFA02 threshold = " << lastThreshold
+                      << "\tstability = " << stability()
+                      << "\tminStability = " << minStability << std::endl;)
+  MSG_DEBUG({
+    int i;
+    FILE *fl = fopen("dump.lp", "w");
+    std::cout << "DSLUFA03 Basis:\n";
+    int j = 0;
+
+    for (i = 0; i < dim(); ++i)
+      j += matrix[i]->size();
+    for (i = 0; i < dim(); ++i) {
+      for (j = 0; j < matrix[i]->size(); ++j) {
+        fprintf(fl, "%8d  %8d  ", i + 1, matrix[i]->index(j) + 1);
+        std::cout << matrix[i]->value(j) << std::endl;
       }
-      fclose(fl);
-      std::cout << "DSLUFA04 LU-Factors:" << std::endl;
-      dump();
+    }
+    fclose(fl);
+    std::cout << "DSLUFA04 LU-Factors:" << std::endl;
+    dump();
 
-      std::cout << "DSLUFA05 threshold = " << lastThreshold
-                << "\tstability = " << stability() << std::endl;
-   }
-   )
+    std::cout << "DSLUFA05 threshold = " << lastThreshold
+              << "\tstability = " << stability() << std::endl;
+  })
 
-   assert(isConsistent());
-   return Status(this->stat);
+  assert(isConsistent());
+  return Status(this->stat);
 }
 
-
-template <class R>
-bool SLUFactor<R>::isConsistent() const
-{
+template <class R> bool SLUFactor<R>::isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
-   return CLUFactor<R>::isConsistent();
+  return CLUFactor<R>::isConsistent();
 #else
-   return true;
+  return true;
 #endif
 }
 
-template <class R>
-void SLUFactor<R>::dump() const
-{
-   CLUFactor<R>::dump();
-}
+template <class R> void SLUFactor<R>::dump() const { CLUFactor<R>::dump(); }
 } // namespace soplex
diff --git a/src/soplex/slufactor_rational.hpp b/src/soplex/slufactor_rational.hpp
index 58b562d..5c3df97 100644
--- a/src/soplex/slufactor_rational.hpp
+++ b/src/soplex/slufactor_rational.hpp
@@ -21,888 +21,830 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 /**@file slufactor_rational.hpp
- * @todo SLUFactorRational seems to be partly an wrapper for CLUFactorRational (was C).
- *       This should be properly integrated and demangled.
+ * @todo SLUFactorRational seems to be partly an wrapper for CLUFactorRational
+ * (was C). This should be properly integrated and demangled.
  * @todo Does is make sense, to call x.clear() when next x.altValues()
  *       is called.
  */
 
-#include <assert.h>
-#include <sstream>
 #include "soplex/cring.h"
 #include "soplex/spxdefines.h"
+#include <assert.h>
+#include <sstream>
 
 #ifdef SOPLEX_DEBUG
 #include <stdio.h>
 #endif
 
-namespace soplex
-{
-#define MINSTABILITYRAT    REAL(4e-2)
+namespace soplex {
+#define MINSTABILITYRAT REAL(4e-2)
 
-inline void SLUFactorRational::solveRight(VectorRational& x, const VectorRational& b) //const
+inline void SLUFactorRational::solveRight(VectorRational &x,
+                                          const VectorRational &b) // const
 {
 
-   solveTime->start();
+  solveTime->start();
 
-   vec = b;
-   CLUFactorRational::solveRight(x.get_ptr(), vec.get_ptr());
+  vec = b;
+  CLUFactorRational::solveRight(x.get_ptr(), vec.get_ptr());
 
-   solveCount++;
-   solveTime->stop();
+  solveCount++;
+  solveTime->stop();
 }
 
-inline void SLUFactorRational::solveRight(SSVectorRational& x, const SVectorRational& b) //const
+inline void SLUFactorRational::solveRight(SSVectorRational &x,
+                                          const SVectorRational &b) // const
 {
 
-   solveTime->start();
+  solveTime->start();
 
-   vec.assign(b);
-   x.clear();
-   CLUFactorRational::solveRight(x.altValues(), vec.get_ptr());
+  vec.assign(b);
+  x.clear();
+  CLUFactorRational::solveRight(x.altValues(), vec.get_ptr());
 
-   solveCount++;
-   solveTime->stop();
+  solveCount++;
+  solveTime->stop();
 }
 
-inline void SLUFactorRational::solveRight4update(SSVectorRational& x, const SVectorRational& b)
-{
-
-   solveTime->start();
-
-   int m;
-   int n;
-   int f = 0;
-
-   x.clear();
-   ssvec = b;
-   n = ssvec.size();
-
-   if(l.updateType == ETA)
-   {
-      m = vSolveRight4update(x.altValues(), x.altIndexMem(),
-                             ssvec.altValues(), ssvec.altIndexMem(), n, 0, 0, 0);
-      x.setSize(m);
-      //x.forceSetup();
-      x.unSetup();
-      eta.setup_and_assign(x);
-   }
-   else
-   {
-      forest.clear();
-      m = vSolveRight4update(x.altValues(), x.altIndexMem(),
-                             ssvec.altValues(), ssvec.altIndexMem(), n,
-                             forest.altValues(), &f, forest.altIndexMem());
-      forest.setSize(f);
-      forest.forceSetup();
-      x.setSize(m);
-      x.forceSetup();
-   }
-
-   usetup = true;
-
-   solveCount++;
-   solveTime->stop();
+inline void SLUFactorRational::solveRight4update(SSVectorRational &x,
+                                                 const SVectorRational &b) {
+
+  solveTime->start();
+
+  int m;
+  int n;
+  int f = 0;
+
+  x.clear();
+  ssvec = b;
+  n = ssvec.size();
+
+  if (l.updateType == ETA) {
+    m = vSolveRight4update(x.altValues(), x.altIndexMem(), ssvec.altValues(),
+                           ssvec.altIndexMem(), n, 0, 0, 0);
+    x.setSize(m);
+    // x.forceSetup();
+    x.unSetup();
+    eta.setup_and_assign(x);
+  } else {
+    forest.clear();
+    m = vSolveRight4update(x.altValues(), x.altIndexMem(), ssvec.altValues(),
+                           ssvec.altIndexMem(), n, forest.altValues(), &f,
+                           forest.altIndexMem());
+    forest.setSize(f);
+    forest.forceSetup();
+    x.setSize(m);
+    x.forceSetup();
+  }
+
+  usetup = true;
+
+  solveCount++;
+  solveTime->stop();
 }
 
-inline void SLUFactorRational::solve2right4update(
-   SSVectorRational&      x,
-   VectorRational&        y,
-   const SVectorRational& b,
-   SSVectorRational&      rhs)
-{
-
-   solveTime->start();
-
-   int  m;
-   int  n;
-   int  f = 0;
-   int* sidx = ssvec.altIndexMem();
-   int  rsize = rhs.size();
-   int* ridx = rhs.altIndexMem();
-
-   x.clear();
-   y.clear();
-   usetup = true;
-   ssvec = b;
-
-   if(l.updateType == ETA)
-   {
-      n = ssvec.size();
-      m = vSolveRight4update2(x.altValues(), x.altIndexMem(),
-                              ssvec.get_ptr(), sidx, n, y.get_ptr(),
-                              rhs.altValues(), ridx, rsize, 0, 0, 0);
-      x.setSize(m);
-      //      x.forceSetup();
-      x.unSetup();
-      eta.setup_and_assign(x);
-   }
-   else
-   {
-      forest.clear();
-      n = ssvec.size();
-      m = vSolveRight4update2(x.altValues(), x.altIndexMem(),
-                              ssvec.get_ptr(), sidx, n, y.get_ptr(),
-                              rhs.altValues(), ridx, rsize,
-                              forest.altValues(), &f, forest.altIndexMem());
-      x.setSize(m);
-      x.forceSetup();
-      forest.setSize(f);
-      forest.forceSetup();
-   }
-
-   solveCount++;
-   solveTime->stop();
+inline void SLUFactorRational::solve2right4update(SSVectorRational &x,
+                                                  VectorRational &y,
+                                                  const SVectorRational &b,
+                                                  SSVectorRational &rhs) {
+
+  solveTime->start();
+
+  int m;
+  int n;
+  int f = 0;
+  int *sidx = ssvec.altIndexMem();
+  int rsize = rhs.size();
+  int *ridx = rhs.altIndexMem();
+
+  x.clear();
+  y.clear();
+  usetup = true;
+  ssvec = b;
+
+  if (l.updateType == ETA) {
+    n = ssvec.size();
+    m = vSolveRight4update2(x.altValues(), x.altIndexMem(), ssvec.get_ptr(),
+                            sidx, n, y.get_ptr(), rhs.altValues(), ridx, rsize,
+                            0, 0, 0);
+    x.setSize(m);
+    //      x.forceSetup();
+    x.unSetup();
+    eta.setup_and_assign(x);
+  } else {
+    forest.clear();
+    n = ssvec.size();
+    m = vSolveRight4update2(x.altValues(), x.altIndexMem(), ssvec.get_ptr(),
+                            sidx, n, y.get_ptr(), rhs.altValues(), ridx, rsize,
+                            forest.altValues(), &f, forest.altIndexMem());
+    x.setSize(m);
+    x.forceSetup();
+    forest.setSize(f);
+    forest.forceSetup();
+  }
+
+  solveCount++;
+  solveTime->stop();
 }
 
 inline void SLUFactorRational::solve3right4update(
-   SSVectorRational&      x,
-   VectorRational&        y,
-   VectorRational&        y2,
-   const SVectorRational& b,
-   SSVectorRational&      rhs,
-   SSVectorRational&      rhs2)
-{
-
-   solveTime->start();
-
-   int  m;
-   int  n;
-   int  f;
-   int* sidx = ssvec.altIndexMem();
-   int  rsize = rhs.size();
-   int* ridx = rhs.altIndexMem();
-   int rsize2 = rhs2.size();
-   int* ridx2 = rhs2.altIndexMem();
-
-   x.clear();
-   y.clear();
-   y2.clear();
-   usetup = true;
-   ssvec = b;
-
-   if(l.updateType == ETA)
-   {
-      n = ssvec.size();
-      m = vSolveRight4update3(x.altValues(), x.altIndexMem(), ssvec.get_ptr(), sidx, n,
-                              y.get_ptr(), rhs.altValues(), ridx, rsize,
-                              y2.get_ptr(), rhs2.altValues(), ridx2, rsize2,
-                              0, 0, 0);
-      x.setSize(m);
-      //      x.forceSetup();
-      x.unSetup();
-      eta.setup_and_assign(x);
-   }
-   else
-   {
-      forest.clear();
-      n = ssvec.size();
-      m = vSolveRight4update3(x.altValues(), x.altIndexMem(), ssvec.get_ptr(), sidx, n,
-                              y.get_ptr(), rhs.altValues(), ridx, rsize,
-                              y2.get_ptr(), rhs2.altValues(), ridx2, rsize2,
-                              forest.altValues(), &f, forest.altIndexMem());
-      x.setSize(m);
-      x.forceSetup();
-      forest.setSize(f);
-      forest.forceSetup();
-   }
-
-   solveCount++;
-   solveTime->stop();
+    SSVectorRational &x, VectorRational &y, VectorRational &y2,
+    const SVectorRational &b, SSVectorRational &rhs, SSVectorRational &rhs2) {
+
+  solveTime->start();
+
+  int m;
+  int n;
+  int f;
+  int *sidx = ssvec.altIndexMem();
+  int rsize = rhs.size();
+  int *ridx = rhs.altIndexMem();
+  int rsize2 = rhs2.size();
+  int *ridx2 = rhs2.altIndexMem();
+
+  x.clear();
+  y.clear();
+  y2.clear();
+  usetup = true;
+  ssvec = b;
+
+  if (l.updateType == ETA) {
+    n = ssvec.size();
+    m = vSolveRight4update3(x.altValues(), x.altIndexMem(), ssvec.get_ptr(),
+                            sidx, n, y.get_ptr(), rhs.altValues(), ridx, rsize,
+                            y2.get_ptr(), rhs2.altValues(), ridx2, rsize2, 0, 0,
+                            0);
+    x.setSize(m);
+    //      x.forceSetup();
+    x.unSetup();
+    eta.setup_and_assign(x);
+  } else {
+    forest.clear();
+    n = ssvec.size();
+    m = vSolveRight4update3(x.altValues(), x.altIndexMem(), ssvec.get_ptr(),
+                            sidx, n, y.get_ptr(), rhs.altValues(), ridx, rsize,
+                            y2.get_ptr(), rhs2.altValues(), ridx2, rsize2,
+                            forest.altValues(), &f, forest.altIndexMem());
+    x.setSize(m);
+    x.forceSetup();
+    forest.setSize(f);
+    forest.forceSetup();
+  }
+
+  solveCount++;
+  solveTime->stop();
 }
 
-inline void SLUFactorRational::solveLeft(VectorRational& x, const VectorRational& b) //const
+inline void SLUFactorRational::solveLeft(VectorRational &x,
+                                         const VectorRational &b) // const
 {
 
-   solveTime->start();
+  solveTime->start();
 
-   vec = b;
-   ///@todo Why is x.clear() here used and not with solveRight() ?
-   x.clear();
-   CLUFactorRational::solveLeft(x.get_ptr(), vec.get_ptr());
+  vec = b;
+  ///@todo Why is x.clear() here used and not with solveRight() ?
+  x.clear();
+  CLUFactorRational::solveLeft(x.get_ptr(), vec.get_ptr());
 
-   solveCount++;
-   solveTime->stop();
+  solveCount++;
+  solveTime->stop();
 }
 
-inline void SLUFactorRational::solveLeft(SSVectorRational& x, const SVectorRational& b) //const
+inline void SLUFactorRational::solveLeft(SSVectorRational &x,
+                                         const SVectorRational &b) // const
 {
 
-   solveTime->start();
+  solveTime->start();
 
-   ssvec.assign(b);
+  ssvec.assign(b);
 
-   x.clear();
-   int sz = ssvec.size(); // see .altValues()
-   int n = vSolveLeft(x.altValues(), x.altIndexMem(),
-                      ssvec.altValues(), ssvec.altIndexMem(), sz);
+  x.clear();
+  int sz = ssvec.size(); // see .altValues()
+  int n = vSolveLeft(x.altValues(), x.altIndexMem(), ssvec.altValues(),
+                     ssvec.altIndexMem(), sz);
 
-   if(n > 0)
-   {
-      x.setSize(n);
-      x.forceSetup();
-   }
-   else
-      x.unSetup();
+  if (n > 0) {
+    x.setSize(n);
+    x.forceSetup();
+  } else
+    x.unSetup();
 
-   ssvec.setSize(0);
-   ssvec.forceSetup();
+  ssvec.setSize(0);
+  ssvec.forceSetup();
 
-   solveCount++;
-   solveTime->stop();
+  solveCount++;
+  solveTime->stop();
 }
 
-inline void SLUFactorRational::solveLeft(
-   SSVectorRational&      x,
-   VectorRational&        y,
-   const SVectorRational& rhs1,
-   SSVectorRational&      rhs2) //const
+inline void SLUFactorRational::solveLeft(SSVectorRational &x, VectorRational &y,
+                                         const SVectorRational &rhs1,
+                                         SSVectorRational &rhs2) // const
 {
 
-   solveTime->start();
+  solveTime->start();
 
-   int   n;
-   Rational* svec = ssvec.altValues();
-   int*  sidx = ssvec.altIndexMem();
-   int   rn   = rhs2.size();
-   int*  ridx = rhs2.altIndexMem();
+  int n;
+  Rational *svec = ssvec.altValues();
+  int *sidx = ssvec.altIndexMem();
+  int rn = rhs2.size();
+  int *ridx = rhs2.altIndexMem();
 
-   x.clear();
-   y.clear();
-   ssvec.assign(rhs1);
-   n = ssvec.size(); // see altValues();
-   n = vSolveLeft2(x.altValues(), x.altIndexMem(), svec, sidx, n,
-                   y.get_ptr(), rhs2.altValues(), ridx, rn);
+  x.clear();
+  y.clear();
+  ssvec.assign(rhs1);
+  n = ssvec.size(); // see altValues();
+  n = vSolveLeft2(x.altValues(), x.altIndexMem(), svec, sidx, n, y.get_ptr(),
+                  rhs2.altValues(), ridx, rn);
 
-   x.setSize(n);
+  x.setSize(n);
 
-   if(n > 0)
-      x.forceSetup();
-   else
-      x.unSetup();
+  if (n > 0)
+    x.forceSetup();
+  else
+    x.unSetup();
 
-   rhs2.setSize(0);
-   rhs2.forceSetup();
-   ssvec.setSize(0);
-   ssvec.forceSetup();
+  rhs2.setSize(0);
+  rhs2.forceSetup();
+  ssvec.setSize(0);
+  ssvec.forceSetup();
 
-   solveCount++;
-   solveTime->stop();
+  solveCount++;
+  solveTime->stop();
 }
 
-inline void SLUFactorRational::solveLeft(
-   SSVectorRational&      x,
-   VectorRational&        y,
-   VectorRational&        z,
-   const SVectorRational& rhs1,
-   SSVectorRational&      rhs2,
-   SSVectorRational&      rhs3)
-{
+inline void SLUFactorRational::solveLeft(SSVectorRational &x, VectorRational &y,
+                                         VectorRational &z,
+                                         const SVectorRational &rhs1,
+                                         SSVectorRational &rhs2,
+                                         SSVectorRational &rhs3) {
 
-   solveTime->start();
+  solveTime->start();
 
-   int   n;
-   Rational* svec = ssvec.altValues();
-   int*  sidx = ssvec.altIndexMem();
+  int n;
+  Rational *svec = ssvec.altValues();
+  int *sidx = ssvec.altIndexMem();
 
-   x.clear();
-   y.clear();
-   z.clear();
-   ssvec.assign(rhs1);
-   n = ssvec.size(); // see altValues();
-   n = vSolveLeft3(x.altValues(), x.altIndexMem(), svec, sidx, n,
-                   y.get_ptr(), rhs2.altValues(), rhs2.altIndexMem(), rhs2.size(),
-                   z.get_ptr(), rhs3.altValues(), rhs3.altIndexMem(), rhs3.size());
+  x.clear();
+  y.clear();
+  z.clear();
+  ssvec.assign(rhs1);
+  n = ssvec.size(); // see altValues();
+  n = vSolveLeft3(x.altValues(), x.altIndexMem(), svec, sidx, n, y.get_ptr(),
+                  rhs2.altValues(), rhs2.altIndexMem(), rhs2.size(),
+                  z.get_ptr(), rhs3.altValues(), rhs3.altIndexMem(),
+                  rhs3.size());
 
-   x.setSize(n);
+  x.setSize(n);
 
-   if(n > 0)
-      x.forceSetup();
-   else
-      x.unSetup();
+  if (n > 0)
+    x.forceSetup();
+  else
+    x.unSetup();
 
-   ssvec.setSize(0);
-   ssvec.forceSetup();
+  ssvec.setSize(0);
+  ssvec.forceSetup();
 
-   solveCount++;
-   solveTime->stop();
+  solveCount++;
+  solveTime->stop();
 }
 
-inline Rational SLUFactorRational::stability() const
-{
+inline Rational SLUFactorRational::stability() const {
 
-   if(status() != OK)
-      return 0;
+  if (status() != OK)
+    return 0;
 
-   if(maxabs < initMaxabs)
-      return 1;
+  if (maxabs < initMaxabs)
+    return 1;
 
-   return initMaxabs / maxabs;
+  return initMaxabs / maxabs;
 }
 
-inline std::string SLUFactorRational::statistics() const
-{
-   std::stringstream s;
-   s  << "Factorizations     : " << std::setw(10) << getFactorCount() << std::endl
-      << "  Time spent       : " << std::setw(10) << std::fixed << std::setprecision(
-         2) << getFactorTime() << std::endl
-      << "Solves             : " << std::setw(10) << getSolveCount() << std::endl
-      << "  Time spent       : " << std::setw(10) << getSolveTime() << std::endl;
-
-   return s.str();
+inline std::string SLUFactorRational::statistics() const {
+  std::stringstream s;
+  s << "Factorizations     : " << std::setw(10) << getFactorCount() << std::endl
+    << "  Time spent       : " << std::setw(10) << std::fixed
+    << std::setprecision(2) << getFactorTime() << std::endl
+    << "Solves             : " << std::setw(10) << getSolveCount() << std::endl
+    << "  Time spent       : " << std::setw(10) << getSolveTime() << std::endl;
+
+  return s.str();
 }
 
-inline void SLUFactorRational::changeEta(int idx, SSVectorRational& et)
-{
+inline void SLUFactorRational::changeEta(int idx, SSVectorRational &et) {
 
-   int es = et.size(); // see altValues()
-   update(idx, et.altValues(), et.altIndexMem(), es);
-   et.setSize(0);
-   et.forceSetup();
+  int es = et.size(); // see altValues()
+  update(idx, et.altValues(), et.altIndexMem(), es);
+  et.setSize(0);
+  et.forceSetup();
 }
 
-inline SLUFactorRational::Status SLUFactorRational::change(
-   int             idx,
-   const SVectorRational&  subst,
-   const SSVectorRational* e)
-{
-
-   // BH 2005-08-23: The boolean usetup indicates that an "update vector"
-   // has been set up. I suppose that SSVectorRational forest is this
-   // update vector, which is set up by solveRight4update() and
-   // solve2right4update() in order to optimize the basis update.
-
-   if(usetup)
-   {
-      if(l.updateType == FOREST_TOMLIN)               // FOREST_TOMLIN updates
-      {
-         // BH 2005-08-19: The size of a SSVectorRational is the size of the
-         // index set, i.e.  the number of nonzeros which is only
-         // defined if the SSVectorRational is set up.  Since
-         // SSVectorRational::altValues() calls unSetup() the size needs to be
-         // stored before the following call.
-         int fsize = forest.size(); // see altValues()
-         forestUpdate(idx, forest.altValues(), fsize, forest.altIndexMem());
-         forest.setSize(0);
-         forest.forceSetup();
-      }
-      else
-      {
-         assert(l.updateType == ETA);
-         changeEta(idx, eta);
-      }
-   }
-   else if(e != 0)                                    // ETA updates
-   {
-      l.updateType = ETA;
-      updateNoClear(idx, e->values(), e->indexMem(), e->size());
-      l.updateType = uptype;
-   }
-   else if(l.updateType == FOREST_TOMLIN)             // FOREST_TOMLIN updates
-   {
-      assert(0);  // probably this part is never called.
-      // forestUpdate() with the last parameter set to NULL should fail.
-      forest = subst;
-      CLUFactorRational::solveLright(forest.altValues());
-      forestUpdate(idx, forest.altValues(), 0, nullptr);
+inline SLUFactorRational::Status
+SLUFactorRational::change(int idx, const SVectorRational &subst,
+                          const SSVectorRational *e) {
+
+  // BH 2005-08-23: The boolean usetup indicates that an "update vector"
+  // has been set up. I suppose that SSVectorRational forest is this
+  // update vector, which is set up by solveRight4update() and
+  // solve2right4update() in order to optimize the basis update.
+
+  if (usetup) {
+    if (l.updateType == FOREST_TOMLIN) // FOREST_TOMLIN updates
+    {
+      // BH 2005-08-19: The size of a SSVectorRational is the size of the
+      // index set, i.e.  the number of nonzeros which is only
+      // defined if the SSVectorRational is set up.  Since
+      // SSVectorRational::altValues() calls unSetup() the size needs to be
+      // stored before the following call.
+      int fsize = forest.size(); // see altValues()
+      forestUpdate(idx, forest.altValues(), fsize, forest.altIndexMem());
       forest.setSize(0);
       forest.forceSetup();
-   }
-   else                                               // ETA updates
-   {
+    } else {
       assert(l.updateType == ETA);
-      vec = subst;
-      eta.clear();
-      CLUFactorRational::solveRight(eta.altValues(), vec.get_ptr());
       changeEta(idx, eta);
-   }
-
-   usetup = false;
-
-   MSG_DEBUG(std::cout << "DSLUFA01\tupdated\t\tstability = " << stability()
-             << std::endl;)
-
-   return status();
+    }
+  } else if (e != 0) // ETA updates
+  {
+    l.updateType = ETA;
+    updateNoClear(idx, e->values(), e->indexMem(), e->size());
+    l.updateType = uptype;
+  } else if (l.updateType == FOREST_TOMLIN) // FOREST_TOMLIN updates
+  {
+    assert(0); // probably this part is never called.
+    // forestUpdate() with the last parameter set to NULL should fail.
+    forest = subst;
+    CLUFactorRational::solveLright(forest.altValues());
+    forestUpdate(idx, forest.altValues(), 0, nullptr);
+    forest.setSize(0);
+    forest.forceSetup();
+  } else // ETA updates
+  {
+    assert(l.updateType == ETA);
+    vec = subst;
+    eta.clear();
+    CLUFactorRational::solveRight(eta.altValues(), vec.get_ptr());
+    changeEta(idx, eta);
+  }
+
+  usetup = false;
+
+  MSG_DEBUG(std::cout << "DSLUFA01\tupdated\t\tstability = " << stability()
+                      << std::endl;)
+
+  return status();
 }
 
-inline void SLUFactorRational::clear()
-{
+inline void SLUFactorRational::clear() {
 
-   rowMemMult    = 5;          /* factor of minimum Memory * #of nonzeros */
-   colMemMult    = 5;          /* factor of minimum Memory * #of nonzeros */
-   lMemMult      = 1;          /* factor of minimum Memory * #of nonzeros */
+  rowMemMult = 5; /* factor of minimum Memory * #of nonzeros */
+  colMemMult = 5; /* factor of minimum Memory * #of nonzeros */
+  lMemMult = 1;   /* factor of minimum Memory * #of nonzeros */
 
-   l.firstUpdate = 0;
-   l.firstUnused = 0;
-   thedim        = 0;
+  l.firstUpdate = 0;
+  l.firstUnused = 0;
+  thedim = 0;
 
-   usetup        = false;
-   maxabs        = 1;
-   initMaxabs    = 1;
-   lastThreshold = minThreshold;
-   minStability  = MINSTABILITYRAT;
-   stat          = UNLOADED;
+  usetup = false;
+  maxabs = 1;
+  initMaxabs = 1;
+  lastThreshold = minThreshold;
+  minStability = MINSTABILITYRAT;
+  stat = UNLOADED;
 
-   vec.clear();
-   eta.clear();
-   ssvec.clear();
-   forest.clear();
+  vec.clear();
+  eta.clear();
+  ssvec.clear();
+  forest.clear();
 
-   u.col.size    = 100;
-   l.startSize   = 100;
+  u.col.size = 100;
+  l.startSize = 100;
 
-   l.rval.reDim(0);
+  l.rval.reDim(0);
 
-   if(l.ridx)
-      spx_free(l.ridx);
+  if (l.ridx)
+    spx_free(l.ridx);
 
-   if(l.rbeg)
-      spx_free(l.rbeg);
+  if (l.rbeg)
+    spx_free(l.rbeg);
 
-   if(l.rorig)
-      spx_free(l.rorig);
+  if (l.rorig)
+    spx_free(l.rorig);
 
-   if(l.rperm)
-      spx_free(l.rperm);
+  if (l.rperm)
+    spx_free(l.rperm);
 
-   if(u.row.idx)
-      spx_free(u.row.idx);
+  if (u.row.idx)
+    spx_free(u.row.idx);
 
-   if(u.col.idx)
-      spx_free(u.col.idx);
+  if (u.col.idx)
+    spx_free(u.col.idx);
 
-   if(l.idx)
-      spx_free(l.idx);
+  if (l.idx)
+    spx_free(l.idx);
 
-   if(l.start)
-      spx_free(l.start);
+  if (l.start)
+    spx_free(l.start);
 
-   if(l.row)
-      spx_free(l.row);
+  if (l.row)
+    spx_free(l.row);
 
-   // G clear() is used in constructor of SLUFactorRational so we have to
-   // G clean up if anything goes wrong here
-   try
-   {
-      u.row.val.reDim(100);
-      spx_alloc(u.row.idx, u.row.val.dim());
-      spx_alloc(u.col.idx, u.col.size);
+  // G clear() is used in constructor of SLUFactorRational so we have to
+  // G clean up if anything goes wrong here
+  try {
+    u.row.val.reDim(100);
+    spx_alloc(u.row.idx, u.row.val.dim());
+    spx_alloc(u.col.idx, u.col.size);
 
-      l.val.reDim(100);
-      spx_alloc(l.idx,   l.val.dim());
-      spx_alloc(l.start, l.startSize);
-      spx_alloc(l.row,   l.startSize);
-   }
-   catch(const SPxMemoryException& x)
-   {
-      freeAll();
-      throw x;
-   }
+    l.val.reDim(100);
+    spx_alloc(l.idx, l.val.dim());
+    spx_alloc(l.start, l.startSize);
+    spx_alloc(l.row, l.startSize);
+  } catch (const SPxMemoryException &x) {
+    freeAll();
+    throw x;
+  }
 }
 
 /** assignment used to implement operator=() and copy constructor.
  *  If this is initialised, freeAll() has to be called before.
  *  Class objects from SLUFactorRational are not copied here.
  */
-inline void SLUFactorRational::assign(const SLUFactorRational& old)
-{
-   unsigned int thediminc;
-
-   // slufactor_rational
-   uptype        = old.uptype;
-   minThreshold  = old.minThreshold;
-   minStability  = old.minStability;
-   lastThreshold = old.lastThreshold;
-
-   // clufactor_rational
-   stat          = old.stat;
-   thedim        = old.thedim;
-   nzCnt         = old.nzCnt;
-   initMaxabs    = old.initMaxabs;
-   maxabs        = old.maxabs;
-   rowMemMult    = old.rowMemMult;
-   colMemMult    = old.colMemMult;
-   lMemMult      = old.lMemMult;
-   factorCount   = old.factorCount;
-   factorTime    = old.factorTime;
-   timeLimit     = old.timeLimit;
-
-   spx_alloc(row.perm, thedim);
-   spx_alloc(row.orig, thedim);
-   spx_alloc(col.perm, thedim);
-   spx_alloc(col.orig, thedim);
-
-   memcpy(row.perm, old.row.perm, (unsigned int)thedim * sizeof(*row.perm));
-   memcpy(row.orig, old.row.orig, (unsigned int)thedim * sizeof(*row.orig));
-   memcpy(col.perm, old.col.perm, (unsigned int)thedim * sizeof(*col.perm));
-   memcpy(col.orig, old.col.orig, (unsigned int)thedim * sizeof(*col.orig));
-   diag = old.diag;
-
-   work = vec.get_ptr();
-
-   /* setup U
-    */
-   thediminc = (unsigned int)(thedim + 1);
-   u.row.used = old.u.row.used;
-
-   spx_alloc(u.row.elem,  thedim);
-   spx_alloc(u.row.idx,   u.row.val.dim());
-   spx_alloc(u.row.start, thediminc);
-   spx_alloc(u.row.len, thediminc);
-   spx_alloc(u.row.max, thediminc);
-
-   memcpy(u.row.elem,  old.u.row.elem, (unsigned int)thedim       * sizeof(*u.row.elem));
-   u.row.val = old.u.row.val;
-   memcpy(u.row.idx,   old.u.row.idx, (unsigned int)u.row.val.dim()   * sizeof(*u.row.idx));
-   memcpy(u.row.start, old.u.row.start, thediminc * sizeof(*u.row.start));
-   memcpy(u.row.len,   old.u.row.len, thediminc * sizeof(*u.row.len));
-   memcpy(u.row.max,   old.u.row.max, thediminc * sizeof(*u.row.max));
-
-   // need to make row list ok ?
-   if(thedim > 0 && stat == OK)
-   {
-      u.row.list.idx = old.u.row.list.idx; // .idx neu
-
-      const Dring* oring = &old.u.row.list;
-      Dring*       ring  = &u.row.list;
-
-      while(oring->next != &old.u.row.list)
-      {
-         ring->next       = &u.row.elem[oring->next->idx];
-         ring->next->prev = ring;
-         oring            = oring->next;
-         ring             = ring->next;
-      }
-
-      ring->next       = &u.row.list;
+inline void SLUFactorRational::assign(const SLUFactorRational &old) {
+  unsigned int thediminc;
+
+  // slufactor_rational
+  uptype = old.uptype;
+  minThreshold = old.minThreshold;
+  minStability = old.minStability;
+  lastThreshold = old.lastThreshold;
+
+  // clufactor_rational
+  stat = old.stat;
+  thedim = old.thedim;
+  nzCnt = old.nzCnt;
+  initMaxabs = old.initMaxabs;
+  maxabs = old.maxabs;
+  rowMemMult = old.rowMemMult;
+  colMemMult = old.colMemMult;
+  lMemMult = old.lMemMult;
+  factorCount = old.factorCount;
+  factorTime = old.factorTime;
+  timeLimit = old.timeLimit;
+
+  spx_alloc(row.perm, thedim);
+  spx_alloc(row.orig, thedim);
+  spx_alloc(col.perm, thedim);
+  spx_alloc(col.orig, thedim);
+
+  memcpy(row.perm, old.row.perm, (unsigned int)thedim * sizeof(*row.perm));
+  memcpy(row.orig, old.row.orig, (unsigned int)thedim * sizeof(*row.orig));
+  memcpy(col.perm, old.col.perm, (unsigned int)thedim * sizeof(*col.perm));
+  memcpy(col.orig, old.col.orig, (unsigned int)thedim * sizeof(*col.orig));
+  diag = old.diag;
+
+  work = vec.get_ptr();
+
+  /* setup U
+   */
+  thediminc = (unsigned int)(thedim + 1);
+  u.row.used = old.u.row.used;
+
+  spx_alloc(u.row.elem, thedim);
+  spx_alloc(u.row.idx, u.row.val.dim());
+  spx_alloc(u.row.start, thediminc);
+  spx_alloc(u.row.len, thediminc);
+  spx_alloc(u.row.max, thediminc);
+
+  memcpy(u.row.elem, old.u.row.elem,
+         (unsigned int)thedim * sizeof(*u.row.elem));
+  u.row.val = old.u.row.val;
+  memcpy(u.row.idx, old.u.row.idx,
+         (unsigned int)u.row.val.dim() * sizeof(*u.row.idx));
+  memcpy(u.row.start, old.u.row.start, thediminc * sizeof(*u.row.start));
+  memcpy(u.row.len, old.u.row.len, thediminc * sizeof(*u.row.len));
+  memcpy(u.row.max, old.u.row.max, thediminc * sizeof(*u.row.max));
+
+  // need to make row list ok ?
+  if (thedim > 0 && stat == OK) {
+    u.row.list.idx = old.u.row.list.idx; // .idx neu
+
+    const Dring *oring = &old.u.row.list;
+    Dring *ring = &u.row.list;
+
+    while (oring->next != &old.u.row.list) {
+      ring->next = &u.row.elem[oring->next->idx];
       ring->next->prev = ring;
-   }
-
-   u.col.size = old.u.col.size;
-   u.col.used = old.u.col.used;
-
-   spx_alloc(u.col.elem,  thedim);
-   spx_alloc(u.col.idx,   u.col.size);
-   spx_alloc(u.col.start, thediminc);
-   spx_alloc(u.col.len, thediminc);
-   spx_alloc(u.col.max, thediminc);
-   u.col.val = old.u.col.val;
-
-   memcpy(u.col.elem,  old.u.col.elem, (unsigned int)thedim       * sizeof(*u.col.elem));
-   memcpy(u.col.idx,   old.u.col.idx, (unsigned int)u.col.size   * sizeof(*u.col.idx));
-   memcpy(u.col.start, old.u.col.start, thediminc * sizeof(*u.col.start));
-   memcpy(u.col.len,   old.u.col.len, thediminc * sizeof(*u.col.len));
-   memcpy(u.col.max,   old.u.col.max, thediminc * sizeof(*u.col.max));
-
-   // need to make col list ok
-   if(thedim > 0 && stat == OK)
-   {
-      u.col.list.idx = old.u.col.list.idx; // .idx neu
-
-      const Dring* oring = &old.u.col.list;
-      Dring*       ring  = &u.col.list;
-
-      while(oring->next != &old.u.col.list)
-      {
-         ring->next       = &u.col.elem[oring->next->idx];
-         ring->next->prev = ring;
-         oring            = oring->next;
-         ring             = ring->next;
-      }
-
-      ring->next       = &u.col.list;
+      oring = oring->next;
+      ring = ring->next;
+    }
+
+    ring->next = &u.row.list;
+    ring->next->prev = ring;
+  }
+
+  u.col.size = old.u.col.size;
+  u.col.used = old.u.col.used;
+
+  spx_alloc(u.col.elem, thedim);
+  spx_alloc(u.col.idx, u.col.size);
+  spx_alloc(u.col.start, thediminc);
+  spx_alloc(u.col.len, thediminc);
+  spx_alloc(u.col.max, thediminc);
+  u.col.val = old.u.col.val;
+
+  memcpy(u.col.elem, old.u.col.elem,
+         (unsigned int)thedim * sizeof(*u.col.elem));
+  memcpy(u.col.idx, old.u.col.idx,
+         (unsigned int)u.col.size * sizeof(*u.col.idx));
+  memcpy(u.col.start, old.u.col.start, thediminc * sizeof(*u.col.start));
+  memcpy(u.col.len, old.u.col.len, thediminc * sizeof(*u.col.len));
+  memcpy(u.col.max, old.u.col.max, thediminc * sizeof(*u.col.max));
+
+  // need to make col list ok
+  if (thedim > 0 && stat == OK) {
+    u.col.list.idx = old.u.col.list.idx; // .idx neu
+
+    const Dring *oring = &old.u.col.list;
+    Dring *ring = &u.col.list;
+
+    while (oring->next != &old.u.col.list) {
+      ring->next = &u.col.elem[oring->next->idx];
       ring->next->prev = ring;
-   }
-
-   /* Setup L
-    */
-   l.startSize   = old.l.startSize;
-   l.firstUpdate = old.l.firstUpdate;
-   l.firstUnused = old.l.firstUnused;
-   l.updateType  = old.l.updateType;
-
-   l.val = old.l.val;
-   spx_alloc(l.idx,   l.val.dim());
-   spx_alloc(l.start, l.startSize);
-   spx_alloc(l.row,   l.startSize);
-
-   memcpy(l.idx,   old.l.idx, (unsigned int)l.val.dim() * sizeof(*l.idx));
-   memcpy(l.start, old.l.start, (unsigned int)l.startSize * sizeof(*l.start));
-   memcpy(l.row,   old.l.row, (unsigned int)l.startSize * sizeof(*l.row));
-
-   if(l.rval.dim() != 0)
-   {
-      assert(old.l.ridx  != 0);
-      assert(old.l.rbeg  != 0);
-      assert(old.l.rorig != 0);
-      assert(old.l.rperm != 0);
-
-      int memsize = l.start[l.firstUpdate];
-
-      l.rval = old.l.rval;
-      spx_alloc(l.ridx,  memsize);
-      spx_alloc(l.rbeg,  thediminc);
-      spx_alloc(l.rorig, thedim);
-      spx_alloc(l.rperm, thedim);
-
-      memcpy(l.ridx,  old.l.ridx, (unsigned int)memsize     * sizeof(*l.ridx));
-      memcpy(l.rbeg,  old.l.rbeg, thediminc * sizeof(*l.rbeg));
-      memcpy(l.rorig, old.l.rorig, (unsigned int)thedim      * sizeof(*l.rorig));
-      memcpy(l.rperm, old.l.rperm, (unsigned int)thedim      * sizeof(*l.rperm));
-   }
-   else
-   {
-      assert(old.l.ridx  == 0);
-      assert(old.l.rbeg  == 0);
-      assert(old.l.rorig == 0);
-      assert(old.l.rperm == 0);
-
-      l.rval.reDim(0);
-      l.ridx  = 0;
-      l.rbeg  = 0;
-      l.rorig = 0;
-      l.rperm = 0;
-   }
-
-   assert(row.perm != 0);
-   assert(row.orig != 0);
-   assert(col.perm != 0);
-   assert(col.orig != 0);
-
-   assert(u.row.elem  != 0);
-   assert(u.row.idx   != 0);
-   assert(u.row.start != 0);
-   assert(u.row.len   != 0);
-   assert(u.row.max   != 0);
-
-   assert(u.col.elem  != 0);
-   assert(u.col.idx   != 0);
-   assert(u.col.start != 0);
-   assert(u.col.len   != 0);
-   assert(u.col.max   != 0);
-
-   assert(l.idx   != 0);
-   assert(l.start != 0);
-   assert(l.row   != 0);
-
+      oring = oring->next;
+      ring = ring->next;
+    }
+
+    ring->next = &u.col.list;
+    ring->next->prev = ring;
+  }
+
+  /* Setup L
+   */
+  l.startSize = old.l.startSize;
+  l.firstUpdate = old.l.firstUpdate;
+  l.firstUnused = old.l.firstUnused;
+  l.updateType = old.l.updateType;
+
+  l.val = old.l.val;
+  spx_alloc(l.idx, l.val.dim());
+  spx_alloc(l.start, l.startSize);
+  spx_alloc(l.row, l.startSize);
+
+  memcpy(l.idx, old.l.idx, (unsigned int)l.val.dim() * sizeof(*l.idx));
+  memcpy(l.start, old.l.start, (unsigned int)l.startSize * sizeof(*l.start));
+  memcpy(l.row, old.l.row, (unsigned int)l.startSize * sizeof(*l.row));
+
+  if (l.rval.dim() != 0) {
+    assert(old.l.ridx != 0);
+    assert(old.l.rbeg != 0);
+    assert(old.l.rorig != 0);
+    assert(old.l.rperm != 0);
+
+    int memsize = l.start[l.firstUpdate];
+
+    l.rval = old.l.rval;
+    spx_alloc(l.ridx, memsize);
+    spx_alloc(l.rbeg, thediminc);
+    spx_alloc(l.rorig, thedim);
+    spx_alloc(l.rperm, thedim);
+
+    memcpy(l.ridx, old.l.ridx, (unsigned int)memsize * sizeof(*l.ridx));
+    memcpy(l.rbeg, old.l.rbeg, thediminc * sizeof(*l.rbeg));
+    memcpy(l.rorig, old.l.rorig, (unsigned int)thedim * sizeof(*l.rorig));
+    memcpy(l.rperm, old.l.rperm, (unsigned int)thedim * sizeof(*l.rperm));
+  } else {
+    assert(old.l.ridx == 0);
+    assert(old.l.rbeg == 0);
+    assert(old.l.rorig == 0);
+    assert(old.l.rperm == 0);
+
+    l.rval.reDim(0);
+    l.ridx = 0;
+    l.rbeg = 0;
+    l.rorig = 0;
+    l.rperm = 0;
+  }
+
+  assert(row.perm != 0);
+  assert(row.orig != 0);
+  assert(col.perm != 0);
+  assert(col.orig != 0);
+
+  assert(u.row.elem != 0);
+  assert(u.row.idx != 0);
+  assert(u.row.start != 0);
+  assert(u.row.len != 0);
+  assert(u.row.max != 0);
+
+  assert(u.col.elem != 0);
+  assert(u.col.idx != 0);
+  assert(u.col.start != 0);
+  assert(u.col.len != 0);
+  assert(u.col.max != 0);
+
+  assert(l.idx != 0);
+  assert(l.start != 0);
+  assert(l.row != 0);
 }
 
-inline void SLUFactorRational::freeAll()
-{
+inline void SLUFactorRational::freeAll() {
 
-   if(row.perm)
-      spx_free(row.perm);
+  if (row.perm)
+    spx_free(row.perm);
 
-   if(row.orig)
-      spx_free(row.orig);
+  if (row.orig)
+    spx_free(row.orig);
 
-   if(col.perm)
-      spx_free(col.perm);
+  if (col.perm)
+    spx_free(col.perm);
 
-   if(col.orig)
-      spx_free(col.orig);
+  if (col.orig)
+    spx_free(col.orig);
 
-   if(u.row.elem)
-      spx_free(u.row.elem);
+  if (u.row.elem)
+    spx_free(u.row.elem);
 
-   if(u.row.idx)
-      spx_free(u.row.idx);
+  if (u.row.idx)
+    spx_free(u.row.idx);
 
-   if(u.row.start)
-      spx_free(u.row.start);
+  if (u.row.start)
+    spx_free(u.row.start);
 
-   if(u.row.len)
-      spx_free(u.row.len);
+  if (u.row.len)
+    spx_free(u.row.len);
 
-   if(u.row.max)
-      spx_free(u.row.max);
+  if (u.row.max)
+    spx_free(u.row.max);
 
-   if(u.col.elem)
-      spx_free(u.col.elem);
+  if (u.col.elem)
+    spx_free(u.col.elem);
 
-   if(u.col.idx)
-      spx_free(u.col.idx);
+  if (u.col.idx)
+    spx_free(u.col.idx);
 
-   if(u.col.start)
-      spx_free(u.col.start);
+  if (u.col.start)
+    spx_free(u.col.start);
 
-   if(u.col.len)
-      spx_free(u.col.len);
+  if (u.col.len)
+    spx_free(u.col.len);
 
-   if(u.col.max)
-      spx_free(u.col.max);
+  if (u.col.max)
+    spx_free(u.col.max);
 
-   if(l.idx)
-      spx_free(l.idx);
+  if (l.idx)
+    spx_free(l.idx);
 
-   if(l.start)
-      spx_free(l.start);
+  if (l.start)
+    spx_free(l.start);
 
-   if(l.row)
-      spx_free(l.row);
+  if (l.row)
+    spx_free(l.row);
 
-   if(l.ridx)
-      spx_free(l.ridx);
+  if (l.ridx)
+    spx_free(l.ridx);
 
-   if(l.rbeg)
-      spx_free(l.rbeg);
+  if (l.rbeg)
+    spx_free(l.rbeg);
 
-   if(l.rorig)
-      spx_free(l.rorig);
+  if (l.rorig)
+    spx_free(l.rorig);
 
-   if(l.rperm)
-      spx_free(l.rperm);
+  if (l.rperm)
+    spx_free(l.rperm);
 
-   spx_free(solveTime);
-   spx_free(factorTime);
+  spx_free(solveTime);
+  spx_free(factorTime);
 }
 
-inline SLUFactorRational::~SLUFactorRational()
-{
-   freeAll();
-}
+inline SLUFactorRational::~SLUFactorRational() { freeAll(); }
 
-static Rational betterThreshold(Rational th)
-{
-   assert(th < 1);
+static Rational betterThreshold(Rational th) {
+  assert(th < 1);
 
-   if(10 * th < 1)
-      th *= 10;
-   else if(10 * th < 8)
-      th = (th + 1) / 2;
-   else if(th < 0.999)
-      th = 0.99999;
+  if (10 * th < 1)
+    th *= 10;
+  else if (10 * th < 8)
+    th = (th + 1) / 2;
+  else if (th < 0.999)
+    th = 0.99999;
 
-   assert(th < 1);
+  assert(th < 1);
 
-   return th;
+  return th;
 }
 
-inline SLUFactorRational::Status SLUFactorRational::load(const SVectorRational* matrix[], int dm)
-{
-   assert(dm     >= 0);
-   assert(matrix != 0);
-
-   Rational lastStability = stability();
-
-   initDR(u.row.list);
-   initDR(u.col.list);
-
-   usetup        = false;
-   l.updateType  = uptype;
-   l.firstUpdate = 0;
-   l.firstUnused = 0;
-
-   if(dm != thedim)
-   {
-      clear();
-
-      thedim = dm;
-      vec.reDim(thedim);
-      ssvec.reDim(thedim);
-      eta.reDim(thedim);
-      forest.reDim(thedim);
-      work = vec.get_ptr();
-
-      spx_realloc(row.perm, thedim);
-      spx_realloc(row.orig, thedim);
-      spx_realloc(col.perm, thedim);
-      spx_realloc(col.orig, thedim);
-      diag.reDim(thedim);
-
-      spx_realloc(u.row.elem,  thedim);
-      spx_realloc(u.row.len,   thedim + 1);
-      spx_realloc(u.row.max,   thedim + 1);
-      spx_realloc(u.row.start, thedim + 1);
-
-      spx_realloc(u.col.elem,  thedim);
-      spx_realloc(u.col.len,   thedim + 1);
-      spx_realloc(u.col.max,   thedim + 1);
-      spx_realloc(u.col.start, thedim + 1);
-
-      l.startSize = thedim + MAXUPDATES;
-
-      spx_realloc(l.row,   l.startSize);
-      spx_realloc(l.start, l.startSize);
-   }
-   // the last factorization was reasonably stable, so we decrease the Markowitz threshold (stored in lastThreshold) in
-   // order favour sparsity
-   else if(lastStability > 2.0 * MINSTABILITYRAT)
-   {
-      // we reset lastThreshold to its previous value in the sequence minThreshold, betterThreshold(minThreshold),
-      // betterThreshold(betterThreshold(minThreshold)), ...
-      Rational last   = minThreshold;
-      Rational better = betterThreshold(last);
-
-      while(better < lastThreshold)
-      {
-         last   = better;
-         better = betterThreshold(last);
-      }
-
-      lastThreshold = last;
-
-      // we reset the minimum stability (which might have been decreased below) to ensure that the increased sparsity
-      // does not hurt the stability
-      minStability  = 2 * MINSTABILITYRAT;
-   }
-
-   u.row.list.idx      = thedim;
-   u.row.start[thedim] = 0;
-   u.row.max[thedim]   = 0;
-   u.row.len[thedim]   = 0;
-
-   u.col.list.idx      = thedim;
-   u.col.start[thedim] = 0;
-   u.col.max[thedim]   = 0;
-   u.col.len[thedim]   = 0;
-
-   stat = OK;
-   factor(matrix, lastThreshold);
-
-   MSG_DEBUG(std::cout << "DSLUFA02 threshold = " << lastThreshold
-             << "\tstability = " << stability()
-             << "\tMINSTABILITYRAT = " << MINSTABILITYRAT << std::endl;)
-   MSG_DEBUG(
-      int i;
-      FILE* fl = fopen("dump.lp", "w");
-      std::cout << "DSLUFA03 Basis:\n";
-      int j = 0;
-
-      for(i = 0; i < dim(); ++i)
-      j += matrix[i]->size();
-      for(i = 0; i < dim(); ++i)
-   {
-      for(j = 0; j < matrix[i]->size(); ++j)
-            fprintf(fl, "%8d  %8d  %s\n",
-                    i + 1, matrix[i]->index(j) + 1, matrix[i]->value(j).str());
-      }
-   fclose(fl);
-   std::cout << "DSLUFA04 LU-Factors:" << std::endl;
-             dump();
-
-             std::cout << "DSLUFA05 threshold = " << lastThreshold
-             << "\tstability = " << stability() << std::endl;
-   )
-
-   assert(isConsistent());
-   return Status(stat);
+inline SLUFactorRational::Status
+SLUFactorRational::load(const SVectorRational *matrix[], int dm) {
+  assert(dm >= 0);
+  assert(matrix != 0);
+
+  Rational lastStability = stability();
+
+  initDR(u.row.list);
+  initDR(u.col.list);
+
+  usetup = false;
+  l.updateType = uptype;
+  l.firstUpdate = 0;
+  l.firstUnused = 0;
+
+  if (dm != thedim) {
+    clear();
+
+    thedim = dm;
+    vec.reDim(thedim);
+    ssvec.reDim(thedim);
+    eta.reDim(thedim);
+    forest.reDim(thedim);
+    work = vec.get_ptr();
+
+    spx_realloc(row.perm, thedim);
+    spx_realloc(row.orig, thedim);
+    spx_realloc(col.perm, thedim);
+    spx_realloc(col.orig, thedim);
+    diag.reDim(thedim);
+
+    spx_realloc(u.row.elem, thedim);
+    spx_realloc(u.row.len, thedim + 1);
+    spx_realloc(u.row.max, thedim + 1);
+    spx_realloc(u.row.start, thedim + 1);
+
+    spx_realloc(u.col.elem, thedim);
+    spx_realloc(u.col.len, thedim + 1);
+    spx_realloc(u.col.max, thedim + 1);
+    spx_realloc(u.col.start, thedim + 1);
+
+    l.startSize = thedim + MAXUPDATES;
+
+    spx_realloc(l.row, l.startSize);
+    spx_realloc(l.start, l.startSize);
+  }
+  // the last factorization was reasonably stable, so we decrease the Markowitz
+  // threshold (stored in lastThreshold) in order favour sparsity
+  else if (lastStability > 2.0 * MINSTABILITYRAT) {
+    // we reset lastThreshold to its previous value in the sequence
+    // minThreshold, betterThreshold(minThreshold),
+    // betterThreshold(betterThreshold(minThreshold)), ...
+    Rational last = minThreshold;
+    Rational better = betterThreshold(last);
+
+    while (better < lastThreshold) {
+      last = better;
+      better = betterThreshold(last);
+    }
+
+    lastThreshold = last;
+
+    // we reset the minimum stability (which might have been decreased below) to
+    // ensure that the increased sparsity does not hurt the stability
+    minStability = 2 * MINSTABILITYRAT;
+  }
+
+  u.row.list.idx = thedim;
+  u.row.start[thedim] = 0;
+  u.row.max[thedim] = 0;
+  u.row.len[thedim] = 0;
+
+  u.col.list.idx = thedim;
+  u.col.start[thedim] = 0;
+  u.col.max[thedim] = 0;
+  u.col.len[thedim] = 0;
+
+  stat = OK;
+  factor(matrix, lastThreshold);
+
+  MSG_DEBUG(std::cout << "DSLUFA02 threshold = " << lastThreshold
+                      << "\tstability = " << stability()
+                      << "\tMINSTABILITYRAT = " << MINSTABILITYRAT
+                      << std::endl;)
+  MSG_DEBUG(int i; FILE *fl = fopen("dump.lp", "w");
+            std::cout << "DSLUFA03 Basis:\n"; int j = 0;
+
+            for (i = 0; i < dim(); ++i) j += matrix[i]->size();
+            for (i = 0; i < dim(); ++i) {
+              for (j = 0; j < matrix[i]->size(); ++j)
+                fprintf(fl, "%8d  %8d  %s\n", i + 1, matrix[i]->index(j) + 1,
+                        matrix[i]->value(j).str());
+            } fclose(fl);
+            std::cout << "DSLUFA04 LU-Factors:" << std::endl; dump();
+
+            std::cout << "DSLUFA05 threshold = " << lastThreshold
+                      << "\tstability = " << stability() << std::endl;)
+
+  assert(isConsistent());
+  return Status(stat);
 }
 
-
-inline bool SLUFactorRational::isConsistent() const
-{
+inline bool SLUFactorRational::isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
-   return CLUFactorRational::isConsistent();
+  return CLUFactorRational::isConsistent();
 #else
-   return true;
+  return true;
 #endif
 }
 
-inline void SLUFactorRational::dump() const
-{
-   CLUFactorRational::dump();
-}
+inline void SLUFactorRational::dump() const { CLUFactorRational::dump(); }
 } // namespace soplex
diff --git a/src/soplex/solbase.h b/src/soplex/solbase.h
index 08e682e..07429d6 100644
--- a/src/soplex/solbase.h
+++ b/src/soplex/solbase.h
@@ -28,285 +28,255 @@
 #ifndef _SOLBASE_H_
 #define _SOLBASE_H_
 
-/* undefine SOPLEX_DEBUG flag from including files; if SOPLEX_DEBUG should be defined in this file, do so below */
+/* undefine SOPLEX_DEBUG flag from including files; if SOPLEX_DEBUG should be
+ * defined in this file, do so below */
 #ifdef SOPLEX_DEBUG
 #define SOPLEX_DEBUG_SOLBASE
 #undef SOPLEX_DEBUG
 #endif
 
 #include <assert.h>
-#include <string.h>
-#include <math.h>
 #include <iostream>
+#include <math.h>
+#include <string.h>
 
 #include "soplex/basevectors.h"
 #include "soplex/spxsolver.h" // needed for basis information
 
-namespace soplex
-{
+namespace soplex {
 /**@class   SolBase
  * @brief   Class for storing a primal-dual solution with basis information
  * @ingroup Algo
  */
-template <class R>
-class SolBase
-{
-   template <class T> friend class SoPlexBase;
-   // Why do we need the following? This is at least used in the operator=
-   // When Rational solution needs to be copied into Real, the private member
-   // _objVal is accessed.
-   template <class S> friend class SolBase;
+template <class R> class SolBase {
+  template <class T> friend class SoPlexBase;
+  // Why do we need the following? This is at least used in the operator=
+  // When Rational solution needs to be copied into Real, the private member
+  // _objVal is accessed.
+  template <class S> friend class SolBase;
 
 public:
-   /// is the stored solution primal feasible?
-   bool isPrimalFeasible() const
-   {
-      return _isPrimalFeasible;
-   }
-
-   /// gets the primal solution vector; returns true on success
-   bool getPrimalSol(VectorBase<R>& vector) const
-   {
-      vector = _primal;
-
-      return _isPrimalFeasible;
-   }
-
-   /// gets the vector of slack values; returns true on success
-   bool getSlacks(VectorBase<R>& vector) const
-   {
-      vector = _slacks;
-
-      return _isPrimalFeasible;
-   }
-
-   /// is a primal unbounded ray available?
-   bool hasPrimalRay() const
-   {
-      return _hasPrimalRay;
-   }
-
-   /// gets the primal unbounded ray if available; returns true on success
-   bool getPrimalRaySol(VectorBase<R>& vector) const
-   {
-      if(_hasPrimalRay)
-         vector = _primalRay;
-
-      return _hasPrimalRay;
-   }
-
-   /// is a dual solution available?
-   bool isDualFeasible() const
-   {
-      return _isDualFeasible;
-   }
+  /// is the stored solution primal feasible?
+  bool isPrimalFeasible() const { return _isPrimalFeasible; }
 
-   /// gets the dual solution vector; returns true on success
-   bool getDualSol(VectorBase<R>& vector) const
-   {
-      vector = _dual;
-
-      return _isDualFeasible;
-   }
+  /// gets the primal solution vector; returns true on success
+  bool getPrimalSol(VectorBase<R> &vector) const {
+    vector = _primal;
 
-   /// gets the vector of reduced cost values if available; returns true on success
-   bool getRedCostSol(VectorBase<R>& vector) const
-   {
-      vector = _redCost;
+    return _isPrimalFeasible;
+  }
 
-      return _isDualFeasible;
-   }
+  /// gets the vector of slack values; returns true on success
+  bool getSlacks(VectorBase<R> &vector) const {
+    vector = _slacks;
 
-   /// is a dual farkas ray available?
-   bool hasDualFarkas() const
-   {
-      return _hasDualFarkas;
-   }
-
-   /// gets the Farkas proof if available; returns true on success
-   bool getDualFarkasSol(VectorBase<R>& vector) const
-   {
-      if(_hasDualFarkas)
-         vector = _dualFarkas;
+    return _isPrimalFeasible;
+  }
 
-      return _hasDualFarkas;
-   }
+  /// is a primal unbounded ray available?
+  bool hasPrimalRay() const { return _hasPrimalRay; }
 
-   /// returns total size of primal solution
-   int totalSizePrimal(const int base = 2) const
-   {
-      int size = 0;
+  /// gets the primal unbounded ray if available; returns true on success
+  bool getPrimalRaySol(VectorBase<R> &vector) const {
+    if (_hasPrimalRay)
+      vector = _primalRay;
 
-      if(_isPrimalFeasible)
-         size += totalSizeRational(_primal.get_const_ptr(), _primal.dim(), base);
+    return _hasPrimalRay;
+  }
 
-      if(_hasPrimalRay)
-         size += totalSizeRational(_primalRay.get_const_ptr(), _primalRay.dim(), base);
+  /// is a dual solution available?
+  bool isDualFeasible() const { return _isDualFeasible; }
 
-      return size;
-   }
+  /// gets the dual solution vector; returns true on success
+  bool getDualSol(VectorBase<R> &vector) const {
+    vector = _dual;
 
-   /// returns total size of dual solution
-   int totalSizeDual(const int base = 2) const
-   {
-      int size = 0;
+    return _isDualFeasible;
+  }
 
-      if(_isDualFeasible)
-         size += totalSizeRational(_dual.get_const_ptr(), _dual.dim(), base);
+  /// gets the vector of reduced cost values if available; returns true on
+  /// success
+  bool getRedCostSol(VectorBase<R> &vector) const {
+    vector = _redCost;
 
-      if(_hasDualFarkas)
-         size += totalSizeRational(_dualFarkas.get_const_ptr(), _dualFarkas.dim(), base);
+    return _isDualFeasible;
+  }
 
-      return size;
-   }
+  /// is a dual farkas ray available?
+  bool hasDualFarkas() const { return _hasDualFarkas; }
 
-   /// returns size of least common multiple of denominators in primal solution
-   int dlcmSizePrimal(const int base = 2) const
-   {
-      int size = 0;
+  /// gets the Farkas proof if available; returns true on success
+  bool getDualFarkasSol(VectorBase<R> &vector) const {
+    if (_hasDualFarkas)
+      vector = _dualFarkas;
 
-      if(_isPrimalFeasible)
-         size += dlcmSizeRational(_primal.get_const_ptr(), _primal.dim(), base);
+    return _hasDualFarkas;
+  }
 
-      if(_hasPrimalRay)
-         size += dlcmSizeRational(_primalRay.get_const_ptr(), _primalRay.dim(), base);
+  /// returns total size of primal solution
+  int totalSizePrimal(const int base = 2) const {
+    int size = 0;
 
-      return size;
-   }
+    if (_isPrimalFeasible)
+      size += totalSizeRational(_primal.get_const_ptr(), _primal.dim(), base);
 
-   /// returns  size of least common multiple of denominators in dual solution
-   int dlcmSizeDual(const int base = 2) const
-   {
-      int size = 0;
+    if (_hasPrimalRay)
+      size +=
+          totalSizeRational(_primalRay.get_const_ptr(), _primalRay.dim(), base);
 
-      if(_isDualFeasible)
-         size += dlcmSizeRational(_dual.get_const_ptr(), _dual.dim(), base);
+    return size;
+  }
 
-      if(_hasDualFarkas)
-         size += dlcmSizeRational(_dualFarkas.get_const_ptr(), _dualFarkas.dim(), base);
+  /// returns total size of dual solution
+  int totalSizeDual(const int base = 2) const {
+    int size = 0;
 
-      return size;
-   }
+    if (_isDualFeasible)
+      size += totalSizeRational(_dual.get_const_ptr(), _dual.dim(), base);
 
-   /// returns size of largest denominator in primal solution
-   int dmaxSizePrimal(const int base = 2) const
-   {
-      int size = 0;
+    if (_hasDualFarkas)
+      size += totalSizeRational(_dualFarkas.get_const_ptr(), _dualFarkas.dim(),
+                                base);
 
-      if(_isPrimalFeasible)
-         size += dmaxSizeRational(_primal.get_const_ptr(), _primal.dim(), base);
+    return size;
+  }
 
-      if(_hasPrimalRay)
-         size += dmaxSizeRational(_primalRay.get_const_ptr(), _primalRay.dim(), base);
+  /// returns size of least common multiple of denominators in primal solution
+  int dlcmSizePrimal(const int base = 2) const {
+    int size = 0;
 
-      return size;
-   }
+    if (_isPrimalFeasible)
+      size += dlcmSizeRational(_primal.get_const_ptr(), _primal.dim(), base);
 
-   /// returns size of largest denominator in dual solution
-   int dmaxSizeDual(const int base = 2) const
-   {
-      int size = 0;
+    if (_hasPrimalRay)
+      size +=
+          dlcmSizeRational(_primalRay.get_const_ptr(), _primalRay.dim(), base);
 
-      if(_isDualFeasible)
-         size += dmaxSizeRational(_dual.get_const_ptr(), _dual.dim(), base);
+    return size;
+  }
 
-      if(_hasDualFarkas)
-         size += dmaxSizeRational(_dualFarkas.get_const_ptr(), _dualFarkas.dim(), base);
+  /// returns  size of least common multiple of denominators in dual solution
+  int dlcmSizeDual(const int base = 2) const {
+    int size = 0;
 
-      return size;
-   }
+    if (_isDualFeasible)
+      size += dlcmSizeRational(_dual.get_const_ptr(), _dual.dim(), base);
 
-   /// invalidate solution
-   void invalidate()
-   {
-      _isPrimalFeasible = false;
-      _hasPrimalRay = false;
-      _isDualFeasible = false;
-      _hasDualFarkas = false;
-   }
+    if (_hasDualFarkas)
+      size += dlcmSizeRational(_dualFarkas.get_const_ptr(), _dualFarkas.dim(),
+                               base);
 
-private:
-   VectorBase<R> _primal;
-   VectorBase<R> _slacks;
-   VectorBase<R> _primalRay;
-   VectorBase<R> _dual;
-   VectorBase<R> _redCost;
-   VectorBase<R> _dualFarkas;
+    return size;
+  }
+
+  /// returns size of largest denominator in primal solution
+  int dmaxSizePrimal(const int base = 2) const {
+    int size = 0;
+
+    if (_isPrimalFeasible)
+      size += dmaxSizeRational(_primal.get_const_ptr(), _primal.dim(), base);
+
+    if (_hasPrimalRay)
+      size +=
+          dmaxSizeRational(_primalRay.get_const_ptr(), _primalRay.dim(), base);
 
-   R _objVal;
+    return size;
+  }
+
+  /// returns size of largest denominator in dual solution
+  int dmaxSizeDual(const int base = 2) const {
+    int size = 0;
+
+    if (_isDualFeasible)
+      size += dmaxSizeRational(_dual.get_const_ptr(), _dual.dim(), base);
+
+    if (_hasDualFarkas)
+      size += dmaxSizeRational(_dualFarkas.get_const_ptr(), _dualFarkas.dim(),
+                               base);
+
+    return size;
+  }
+
+  /// invalidate solution
+  void invalidate() {
+    _isPrimalFeasible = false;
+    _hasPrimalRay = false;
+    _isDualFeasible = false;
+    _hasDualFarkas = false;
+  }
+
+private:
+  VectorBase<R> _primal;
+  VectorBase<R> _slacks;
+  VectorBase<R> _primalRay;
+  VectorBase<R> _dual;
+  VectorBase<R> _redCost;
+  VectorBase<R> _dualFarkas;
 
-   unsigned int _isPrimalFeasible: 1;
-   unsigned int _hasPrimalRay: 1;
-   unsigned int _isDualFeasible: 1;
-   unsigned int _hasDualFarkas: 1;
+  R _objVal;
 
-   /// default constructor only for friends
-   SolBase<R>()
-      : _objVal(0)
-   {
-      invalidate();
-   }
+  unsigned int _isPrimalFeasible : 1;
+  unsigned int _hasPrimalRay : 1;
+  unsigned int _isDualFeasible : 1;
+  unsigned int _hasDualFarkas : 1;
 
-   /// assignment operator only for friends
-   SolBase<R>& operator=(const SolBase<R>& sol)
-   {
-      if(this != &sol)
-      {
+  /// default constructor only for friends
+  SolBase() : _objVal(0) { invalidate(); }
 
-         _isPrimalFeasible = sol._isPrimalFeasible;
-         _primal = sol._primal;
-         _slacks = sol._slacks;
-         _objVal = sol._objVal;
+  /// assignment operator only for friends
+  SolBase<R> &operator=(const SolBase<R> &sol) {
+    if (this != &sol) {
 
-         _hasPrimalRay = sol._hasPrimalRay;
+      _isPrimalFeasible = sol._isPrimalFeasible;
+      _primal = sol._primal;
+      _slacks = sol._slacks;
+      _objVal = sol._objVal;
 
-         if(_hasPrimalRay)
-            _primalRay = sol._primalRay;
+      _hasPrimalRay = sol._hasPrimalRay;
 
-         _isDualFeasible = sol._isDualFeasible;
-         _dual = sol._dual;
-         _redCost = sol._redCost;
+      if (_hasPrimalRay)
+        _primalRay = sol._primalRay;
 
-         _hasDualFarkas = sol._hasDualFarkas;
+      _isDualFeasible = sol._isDualFeasible;
+      _dual = sol._dual;
+      _redCost = sol._redCost;
 
-         if(_hasDualFarkas)
-            _dualFarkas = sol._dualFarkas;
-      }
+      _hasDualFarkas = sol._hasDualFarkas;
 
-      return *this;
-   }
+      if (_hasDualFarkas)
+        _dualFarkas = sol._dualFarkas;
+    }
 
-   /// assignment operator only for friends
-   template <class S>
-   SolBase<R>& operator=(const SolBase<S>& sol)
-   {
-      if((SolBase<S>*)this != &sol)
-      {
+    return *this;
+  }
 
-         _isPrimalFeasible = sol._isPrimalFeasible;
-         _primal = sol._primal;
-         _slacks = sol._slacks;
+  /// assignment operator only for friends
+  template <class S> SolBase<R> &operator=(const SolBase<S> &sol) {
+    if ((SolBase<S> *)this != &sol) {
 
-         _objVal = R(sol._objVal);
+      _isPrimalFeasible = sol._isPrimalFeasible;
+      _primal = sol._primal;
+      _slacks = sol._slacks;
 
-         _hasPrimalRay = sol._hasPrimalRay;
+      _objVal = R(sol._objVal);
 
-         if(_hasPrimalRay)
-            _primalRay = sol._primalRay;
+      _hasPrimalRay = sol._hasPrimalRay;
 
-         _isDualFeasible = sol._isDualFeasible;
-         _dual = sol._dual;
-         _redCost = sol._redCost;
+      if (_hasPrimalRay)
+        _primalRay = sol._primalRay;
 
-         _hasDualFarkas = sol._hasDualFarkas;
+      _isDualFeasible = sol._isDualFeasible;
+      _dual = sol._dual;
+      _redCost = sol._redCost;
 
-         if(_hasDualFarkas)
-            _dualFarkas = sol._dualFarkas;
-      }
+      _hasDualFarkas = sol._hasDualFarkas;
 
-      return *this;
-   }
+      if (_hasDualFarkas)
+        _dualFarkas = sol._dualFarkas;
+    }
 
+    return *this;
+  }
 };
 } // namespace soplex
 
diff --git a/src/soplex/solvedbds.hpp b/src/soplex/solvedbds.hpp
index 5024917..09b2d44 100644
--- a/src/soplex/solvedbds.hpp
+++ b/src/soplex/solvedbds.hpp
@@ -21,4320 +21,4268 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
-#include <iostream>
 #include <assert.h>
+#include <iostream>
 
-#include "soplex/spxdefines.h"
 #include "soplex.h"
-#include "soplex/statistics.h"
 #include "soplex/sorter.h"
+#include "soplex/spxdefines.h"
+#include "soplex/statistics.h"
 
-//#define NO_TOL
+// #define NO_TOL
 #define USE_FEASTOL
-//#define NO_TRANSFORM
-//#define PERFORM_COMPPROB_CHECK
-
-#define MAX_DEGENCHECK     20    /**< the maximum number of degen checks that are performed before the DECOMP is abandoned */
-#define DEGENCHECK_OFFSET  50    /**< the number of iteration before the degeneracy check is reperformed */
-#define SLACKCOEFF         1.0   /**< the coefficient of the slack variable in the incompatible rows. */
-#define TIMELIMIT_FRAC     0.5   /**< the fraction of the total time limit given to the setup of the reduced problem */
-
-/* This file contains the private functions for the Decomposition Based Dual Simplex (DBDS)
+// #define NO_TRANSFORM
+// #define PERFORM_COMPPROB_CHECK
+
+#define MAX_DEGENCHECK                                                         \
+  20 /**< the maximum number of degen checks that are performed before the     \
+        DECOMP is abandoned */
+#define DEGENCHECK_OFFSET                                                      \
+  50 /**< the number of iteration before the degeneracy check is reperformed   \
+      */
+#define SLACKCOEFF                                                             \
+  1.0 /**< the coefficient of the slack variable in the incompatible rows. */
+#define TIMELIMIT_FRAC                                                         \
+  0.5 /**< the fraction of the total time limit given to the setup of the      \
+         reduced problem */
+
+/* This file contains the private functions for the Decomposition Based Dual
+ * Simplex (DBDS)
  *
- * An important note about the implementation of the DBDS is the reliance on the row representation of the basis matrix.
- * The forming of the reduced and complementary problems is involves identifying rows in the row-form of the basis
- * matrix that have zero dual multipliers.
+ * An important note about the implementation of the DBDS is the reliance on the
+ * row representation of the basis matrix. The forming of the reduced and
+ * complementary problems is involves identifying rows in the row-form of the
+ * basis matrix that have zero dual multipliers.
  *
- * Ideally, this work will be extended such that the DBDS can be executed using the column-form of the basis matrix. */
+ * Ideally, this work will be extended such that the DBDS can be executed using
+ * the column-form of the basis matrix. */
 
-namespace soplex
-{
+namespace soplex {
 
 /// solves LP using the decomposition dual simplex
-template <class R>
-void SoPlexBase<R>::_solveDecompositionDualSimplex()
-{
-   assert(_solver.rep() == SPxSolverBase<R>::ROW);
-   assert(_solver.type() == SPxSolverBase<R>::LEAVE);
-
-   // flag to indicate that the algorithm must terminate
-   bool stop = false;
-
-   // setting the initial status of the reduced problem
-   _statistics->redProbStatus = SPxSolverBase<R>::NO_PROBLEM;
-
-   // start timing
-   _statistics->solvingTime->start();
-
-   // remember that last solve was in floating-point
-   _lastSolveMode = SOLVEMODE_REAL;
-
-   // setting the current solving mode.
-   _currentProb = DECOMP_ORIG;
-
-   // setting the sense to maximise. This is to make all matrix operations more consistent.
-   // @todo if the objective sense is changed, the output of the current objective value is the negative of the
-   // actual value. This needs to be corrected in future versions.
-   if(intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MINIMIZE)
-   {
-      assert(_solver.spxSense() == SPxLPBase<R>::MINIMIZE);
-
-      _solver.changeObj(_solver.maxObj());
-      _solver.changeSense(SPxLPBase<R>::MAXIMIZE);
-   }
-
-   // it is necessary to solve the initial problem to find a starting basis
-   _solver.setDecompStatus(SPxSolverBase<R>::FINDSTARTBASIS);
-
-   // setting the decomposition iteration limit to the parameter setting
-   _solver.setDecompIterationLimit(intParam(SoPlexBase<R>::DECOMP_ITERLIMIT));
-
-   // variables used in the initialisation phase of the decomposition solve.
-   int numDegenCheck = 0;
-   R degeneracyLevel = 0;
-   _decompFeasVector.reDim(_solver.nCols());
-   bool initSolveFromScratch = true;
-
-
-   /************************/
-   /* Initialisation phase */
-   /************************/
-
-   // arrays to store the basis status for the rows and columns at the interruption of the original problem solve.
-   DataArray< typename SPxSolverBase<R>::VarStatus > basisStatusRows;
-   DataArray< typename SPxSolverBase<R>::VarStatus > basisStatusCols;
-
-   // since the original LP may have been shifted, the dual multiplier will not be correct for the original LP. This
-   // loop will recheck the degeneracy level and compute the proper dual multipliers.
-   do
-   {
-      // solving the instance.
-      _decompSimplifyAndSolve(_solver, _slufactor, initSolveFromScratch, initSolveFromScratch);
-      initSolveFromScratch = false;
-
-      // checking whether the initialisation must terminate and the original problem is solved using the dual simplex.
-      if(_solver.type() == SPxSolverBase<R>::LEAVE || _solver.status() >= SPxSolverBase<R>::OPTIMAL
-            || _solver.status() == SPxSolverBase<R>::ABORT_EXDECOMP || numDegenCheck > MAX_DEGENCHECK)
-      {
-         // decomposition is deemed not useful. Solving the original problem using regular SoPlexBase.
-
-         // returning the sense to minimise
-         if(intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MINIMIZE)
-         {
-            assert(_solver.spxSense() == SPxLPBase<R>::MAXIMIZE);
-
-            _solver.changeObj(-(_solver.maxObj()));
-            _solver.changeSense(SPxLPBase<R>::MINIMIZE);
-         }
-
-         // switching off the starting basis check. This is only required to initialise the decomposition simplex.
-         _solver.setDecompStatus(SPxSolverBase<R>::DONTFINDSTARTBASIS);
-
-         // the basis is not computed correctly is the problem was unfeasible or unbounded.
-         if(_solver.status() == SPxSolverBase<R>::UNBOUNDED
-               || _solver.status() == SPxSolverBase<R>::INFEASIBLE)
-            _hasBasis = false;
-
-
-         // resolving the problem to update the real lp and solve with the correct objective.
-         // TODO: With some infeasible problem (e.g. refinery) the dual is violated. Setting fromScratch to true
-         // avoids this issue. Need to check what the problem is.
-         // @TODO: Should this be _preprocessAndSolveReal similar to the resolve at the end of the algorithm?
-         _decompSimplifyAndSolve(_solver, _slufactor, true, false);
-
-         // retreiving the original problem statistics prior to destroying it.
-         getOriginalProblemStatistics();
-
-         // storing the solution from the reduced problem
-         _storeSolutionReal();
-
-         // stop timing
-         _statistics->solvingTime->stop();
-         return;
-      }
-      else if(_solver.status() == SPxSolverBase<R>::ABORT_TIME
-              || _solver.status() == SPxSolverBase<R>::ABORT_ITER
-              || _solver.status() == SPxSolverBase<R>::ABORT_VALUE)
-      {
-         // This cleans up the problem is an abort is reached.
-
-         // at this point, the _decompSimplifyAndSolve does not store the realLP. It stores the _decompLP. As such, it is
-         // important to reinstall the _realLP to the _solver.
-         if(!_isRealLPLoaded)
-         {
-            _solver.loadLP(*_decompLP);
-            spx_free(_decompLP);
-            _decompLP = &_solver;
-            _isRealLPLoaded = true;
-         }
-
-         // returning the sense to minimise
-         if(intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MINIMIZE)
-         {
-            assert(_solver.spxSense() == SPxLPBase<R>::MAXIMIZE);
-
-            _solver.changeObj(-(_solver.maxObj()));
-            _solver.changeSense(SPxLPBase<R>::MINIMIZE);
-         }
-
-         // resolving the problem to set up all of the solution vectors. This is required because data from the
-         // initialisation solve may remain at termination causing an infeasible solution to be reported.
-         _preprocessAndSolveReal(false);
-
-         // storing the solution from the reduced problem
-         _storeSolutionReal();
-
-         // stop timing
-         _statistics->solvingTime->stop();
-         return;
-      }
-
-      // checking the degeneracy level
-      _solver.basis().solve(_decompFeasVector, _solver.maxObj());
-      degeneracyLevel = _solver.getDegeneracyLevel(_decompFeasVector);
-
-      _solver.setDegenCompOffset(DEGENCHECK_OFFSET);
-
-      numDegenCheck++;
-   }
-   while((degeneracyLevel > 0.9 || degeneracyLevel < 0.1)
-         || !checkBasisDualFeasibility(_decompFeasVector));
-
-   // decomposition simplex will commence, so the start basis does not need to be found
-   _solver.setDecompStatus(SPxSolverBase<R>::DONTFINDSTARTBASIS);
-
-   // if the original problem has a basis, this will be stored
-   if(_hasBasis)
-   {
-      basisStatusRows.reSize(numRows());
-      basisStatusCols.reSize(numCols());
-      _solver.getBasis(basisStatusRows.get_ptr(), basisStatusCols.get_ptr(), basisStatusRows.size(),
-                       basisStatusCols.size());
-   }
-
-   // updating the algorithm iterations statistic
-   _statistics->callsReducedProb++;
-
-   // setting the statistic information
-   numDecompIter = 0;
-   numRedProbIter = _solver.iterations();
-   numCompProbIter = 0;
-
-   // setting the display information
-   _decompDisplayLine = 0;
-
-   /************************/
-   /* Decomposition phase  */
-   /************************/
-
-   MSG_INFO1(spxout,
-             spxout << "========      Degeneracy Detected       ========" << std::endl
-             << std::endl
-             << "======== Commencing decomposition solve ========" << std::endl
-            );
-
-   //spxout.setVerbosity( SPxOut::DEBUG );
-   MSG_INFO2(spxout, spxout << "Creating the Reduced and Complementary problems." << std::endl);
-
-   // setting the verbosity level
-   const SPxOut::Verbosity orig_verbosity = spxout.getVerbosity();
-   const SPxOut::Verbosity decomp_verbosity = (SPxOut::Verbosity)intParam(
-            SoPlexBase<R>::DECOMP_VERBOSITY);
-
-   if(decomp_verbosity < orig_verbosity)
-      spxout.setVerbosity(decomp_verbosity);
-
-   // creating copies of the original problem that will be manipulated to form the reduced and complementary
-   // problems.
-   _createDecompReducedAndComplementaryProblems();
-
-   // creating the initial reduced problem from the basis information
-   _formDecompReducedProblem(stop);
-
-   // setting flags for the decomposition solve
-   _hasBasis = false;
-   bool hasRedBasis = false;
-   bool redProbError = false;
-   bool noRedprobIter = false;
-   bool explicitviol = boolParam(SoPlexBase<R>::EXPLICITVIOL);
-   int algIterCount = 0;
-
-
-   // a stop will be triggered if the reduced problem exceeded a specified fraction of the time limit
-   if(stop)
-   {
-      MSG_INFO1(spxout, spxout << "==== Error constructing the reduced problem ====" << std::endl);
-      redProbError = true;
-      _statistics->redProbStatus = SPxSolverBase<R>::NOT_INIT;
-   }
-
-   // the main solving loop of the decomposition simplex.
-   // This loop solves the Reduced problem, and if the problem is feasible, the complementary problem is solved.
-   while(!stop)
-   {
-      int previter = _statistics->iterations;
-
-      // setting the current solving mode.
-      _currentProb = DECOMP_RED;
-
-      // solve the reduced problem
-
-      MSG_INFO2(spxout,
-                spxout << std::endl
-                << "=========================" << std::endl
-                << "Solving: Reduced Problem." << std::endl
-                << "=========================" << std::endl
-                << std::endl);
-
-      _hasBasis = hasRedBasis;
-      // solving the reduced problem
-      _decompSimplifyAndSolve(_solver, _slufactor, !algIterCount, !algIterCount);
-
-      stop = decompTerminate(realParam(
-                                SoPlexBase<R>::TIMELIMIT));  // checking whether the algorithm should terminate
-
-      // updating the algorithm iterations statistics
-      _statistics->callsReducedProb++;
-      _statistics->redProbStatus = _solver.status();
-
-      assert(_isRealLPLoaded);
-      hasRedBasis = _hasBasis;
-      _hasBasis = false;
-
-      // checking the status of the reduced problem
-      // It is expected that infeasibility and unboundedness will be found in the initialisation solve. If this is
-      // not the case and the reduced problem is infeasible or unbounded the decomposition simplex will terminate.
-      // If the decomposition simplex terminates, then the original problem will be solved using the stored basis.
-      if(_solver.status() != SPxSolverBase<R>::OPTIMAL)
-      {
-         if(_solver.status() == SPxSolverBase<R>::UNBOUNDED)
-            MSG_INFO2(spxout, spxout << "Unbounded reduced problem." << std::endl);
-
-         if(_solver.status() == SPxSolverBase<R>::INFEASIBLE)
-            MSG_INFO2(spxout, spxout << "Infeasible reduced problem." << std::endl);
-
-         MSG_INFO2(spxout, spxout << "Reduced problem status: " << static_cast<int>
-                   (_solver.status()) << std::endl);
-
-         redProbError = true;
-         break;
-      }
-
-      // as a final check, if no iterations were performed with the reduced problem, then the algorithm terminates
-      if(_statistics->iterations == previter)
-      {
-         MSG_WARNING(spxout,
-                     spxout << "WIMDSM02: reduced problem performed zero iterations. Terminating." << std::endl;);
-
-         noRedprobIter = true;
-         stop = true;
-         break;
-      }
-
-      // printing display line
-      printDecompDisplayLine(_solver, orig_verbosity, !algIterCount, !algIterCount);
-
-      // get the dual solutions from the reduced problem
-      VectorBase<R> reducedLPDualVector(_solver.nRows());
-      VectorBase<R> reducedLPRedcostVector(_solver.nCols());
-      _solver.getDualSol(reducedLPDualVector);
-      _solver.getRedCostSol(reducedLPRedcostVector);
+template <class R> void SoPlexBase<R>::_solveDecompositionDualSimplex() {
+  assert(_solver.rep() == SPxSolverBase<R>::ROW);
+  assert(_solver.type() == SPxSolverBase<R>::LEAVE);
+
+  // flag to indicate that the algorithm must terminate
+  bool stop = false;
+
+  // setting the initial status of the reduced problem
+  _statistics->redProbStatus = SPxSolverBase<R>::NO_PROBLEM;
+
+  // start timing
+  _statistics->solvingTime->start();
+
+  // remember that last solve was in floating-point
+  _lastSolveMode = SOLVEMODE_REAL;
+
+  // setting the current solving mode.
+  _currentProb = DECOMP_ORIG;
+
+  // setting the sense to maximise. This is to make all matrix operations more
+  // consistent.
+  // @todo if the objective sense is changed, the output of the current
+  // objective value is the negative of the actual value. This needs to be
+  // corrected in future versions.
+  if (intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MINIMIZE) {
+    assert(_solver.spxSense() == SPxLPBase<R>::MINIMIZE);
+
+    _solver.changeObj(_solver.maxObj());
+    _solver.changeSense(SPxLPBase<R>::MAXIMIZE);
+  }
+
+  // it is necessary to solve the initial problem to find a starting basis
+  _solver.setDecompStatus(SPxSolverBase<R>::FINDSTARTBASIS);
+
+  // setting the decomposition iteration limit to the parameter setting
+  _solver.setDecompIterationLimit(intParam(SoPlexBase<R>::DECOMP_ITERLIMIT));
+
+  // variables used in the initialisation phase of the decomposition solve.
+  int numDegenCheck = 0;
+  R degeneracyLevel = 0;
+  _decompFeasVector.reDim(_solver.nCols());
+  bool initSolveFromScratch = true;
+
+  /************************/
+  /* Initialisation phase */
+  /************************/
+
+  // arrays to store the basis status for the rows and columns at the
+  // interruption of the original problem solve.
+  DataArray<typename SPxSolverBase<R>::VarStatus> basisStatusRows;
+  DataArray<typename SPxSolverBase<R>::VarStatus> basisStatusCols;
+
+  // since the original LP may have been shifted, the dual multiplier will not
+  // be correct for the original LP. This loop will recheck the degeneracy level
+  // and compute the proper dual multipliers.
+  do {
+    // solving the instance.
+    _decompSimplifyAndSolve(_solver, _slufactor, initSolveFromScratch,
+                            initSolveFromScratch);
+    initSolveFromScratch = false;
+
+    // checking whether the initialisation must terminate and the original
+    // problem is solved using the dual simplex.
+    if (_solver.type() == SPxSolverBase<R>::LEAVE ||
+        _solver.status() >= SPxSolverBase<R>::OPTIMAL ||
+        _solver.status() == SPxSolverBase<R>::ABORT_EXDECOMP ||
+        numDegenCheck > MAX_DEGENCHECK) {
+      // decomposition is deemed not useful. Solving the original problem using
+      // regular SoPlexBase.
 
+      // returning the sense to minimise
+      if (intParam(SoPlexBase<R>::OBJSENSE) ==
+          SoPlexBase<R>::OBJSENSE_MINIMIZE) {
+        assert(_solver.spxSense() == SPxLPBase<R>::MAXIMIZE);
 
-      // Using the solution to the reduced problem:
-      // In the first iteration of the algorithm create the complementary problem.
-      // In the subsequent iterations of the algorithm update the complementary problem.
-      if(algIterCount == 0)
-         _formDecompComplementaryProblem();
-      else
-      {
-         if(boolParam(SoPlexBase<R>::USECOMPDUAL))
-            _updateDecompComplementaryDualProblem(false);
-         else
-            _updateDecompComplementaryPrimalProblem(false);
+        _solver.changeObj(-(_solver.maxObj()));
+        _solver.changeSense(SPxLPBase<R>::MINIMIZE);
       }
 
-      // setting the current solving mode.
-      _currentProb = DECOMP_COMP;
-
-      // solve the complementary problem
-      MSG_INFO2(spxout,
-                spxout << std::endl
-                << "=========================" << std::endl
-                << "Solving: Complementary Problem." << std::endl
-                << "=========================" << std::endl
-                << std::endl);
-
-      if(!explicitviol)
-      {
-         //_compSolver.writeFileLPBase("comp.lp");
-
-         _decompSimplifyAndSolve(_compSolver, _compSlufactor, true, true);
-
-         MSG_INFO2(spxout, spxout << "Iteration " << algIterCount
-                   << "Objective Value: " << std::setprecision(10) << _compSolver.objValue()
-                   << std::endl);
+      // switching off the starting basis check. This is only required to
+      // initialise the decomposition simplex.
+      _solver.setDecompStatus(SPxSolverBase<R>::DONTFINDSTARTBASIS);
+
+      // the basis is not computed correctly is the problem was unfeasible or
+      // unbounded.
+      if (_solver.status() == SPxSolverBase<R>::UNBOUNDED ||
+          _solver.status() == SPxSolverBase<R>::INFEASIBLE)
+        _hasBasis = false;
+
+      // resolving the problem to update the real lp and solve with the correct
+      // objective.
+      // TODO: With some infeasible problem (e.g. refinery) the dual is
+      // violated. Setting fromScratch to true avoids this issue. Need to check
+      // what the problem is.
+      // @TODO: Should this be _preprocessAndSolveReal similar to the resolve at
+      // the end of the algorithm?
+      _decompSimplifyAndSolve(_solver, _slufactor, true, false);
+
+      // retreiving the original problem statistics prior to destroying it.
+      getOriginalProblemStatistics();
+
+      // storing the solution from the reduced problem
+      _storeSolutionReal();
+
+      // stop timing
+      _statistics->solvingTime->stop();
+      return;
+    } else if (_solver.status() == SPxSolverBase<R>::ABORT_TIME ||
+               _solver.status() == SPxSolverBase<R>::ABORT_ITER ||
+               _solver.status() == SPxSolverBase<R>::ABORT_VALUE) {
+      // This cleans up the problem is an abort is reached.
+
+      // at this point, the _decompSimplifyAndSolve does not store the realLP.
+      // It stores the _decompLP. As such, it is important to reinstall the
+      // _realLP to the _solver.
+      if (!_isRealLPLoaded) {
+        _solver.loadLP(*_decompLP);
+        spx_free(_decompLP);
+        _decompLP = &_solver;
+        _isRealLPLoaded = true;
       }
 
+      // returning the sense to minimise
+      if (intParam(SoPlexBase<R>::OBJSENSE) ==
+          SoPlexBase<R>::OBJSENSE_MINIMIZE) {
+        assert(_solver.spxSense() == SPxLPBase<R>::MAXIMIZE);
 
-      assert(_isRealLPLoaded);
-
-
-      // Check whether the complementary problem is solved with a non-negative objective function, is infeasible or
-      // unbounded. If true, then stop the algorithm.
-      if(!explicitviol && (GE(_compSolver.objValue(), R(0.0), R(1e-20))
-                           || _compSolver.status() == SPxSolverBase<R>::INFEASIBLE
-                           || _compSolver.status() == SPxSolverBase<R>::UNBOUNDED))
-      {
-         _statistics->compProbStatus = _compSolver.status();
-         _statistics->finalCompObj = _compSolver.objValue();
-
-         if(_compSolver.status() == SPxSolverBase<R>::UNBOUNDED)
-            MSG_INFO2(spxout, spxout << "Unbounded complementary problem." << std::endl);
-
-         if(_compSolver.status() == SPxSolverBase<R>::INFEASIBLE)
-            MSG_INFO2(spxout, spxout << "Infeasible complementary problem." << std::endl);
-
-         if(_compSolver.status() == SPxSolverBase<R>::INFEASIBLE
-               || _compSolver.status() == SPxSolverBase<R>::UNBOUNDED)
-            explicitviol = true;
-
-         stop = true;
+        _solver.changeObj(-(_solver.maxObj()));
+        _solver.changeSense(SPxLPBase<R>::MINIMIZE);
       }
 
-      if(!stop && !explicitviol)
-      {
-         // get the primal solutions from the complementary problem
-         VectorBase<R> compLPPrimalVector(_compSolver.nCols());
-         _compSolver.getPrimalSol(compLPPrimalVector);
-
-         // get the dual solutions from the complementary problem
-         VectorBase<R> compLPDualVector(_compSolver.nRows());
-         _compSolver.getDualSol(compLPDualVector);
+      // resolving the problem to set up all of the solution vectors. This is
+      // required because data from the initialisation solve may remain at
+      // termination causing an infeasible solution to be reported.
+      _preprocessAndSolveReal(false);
 
-         // updating the reduced problem
-         _updateDecompReducedProblem(_compSolver.objValue(), reducedLPDualVector, reducedLPRedcostVector,
-                                     compLPPrimalVector, compLPDualVector);
-      }
-      // if the complementary problem is infeasible or unbounded, it is possible that the algorithm can continue.
-      // a check of the original problem is required to determine whether there are any violations.
-      else if(_compSolver.status() == SPxSolverBase<R>::INFEASIBLE
-              || _compSolver.status() == SPxSolverBase<R>::UNBOUNDED
-              || explicitviol)
-      {
-         // getting the primal vector from the reduced problem
-         VectorBase<R> reducedLPPrimalVector(_solver.nCols());
-         _solver.getPrimalSol(reducedLPPrimalVector);
+      // storing the solution from the reduced problem
+      _storeSolutionReal();
+
+      // stop timing
+      _statistics->solvingTime->stop();
+      return;
+    }
+
+    // checking the degeneracy level
+    _solver.basis().solve(_decompFeasVector, _solver.maxObj());
+    degeneracyLevel = _solver.getDegeneracyLevel(_decompFeasVector);
+
+    _solver.setDegenCompOffset(DEGENCHECK_OFFSET);
+
+    numDegenCheck++;
+  } while ((degeneracyLevel > 0.9 || degeneracyLevel < 0.1) ||
+           !checkBasisDualFeasibility(_decompFeasVector));
+
+  // decomposition simplex will commence, so the start basis does not need to be
+  // found
+  _solver.setDecompStatus(SPxSolverBase<R>::DONTFINDSTARTBASIS);
+
+  // if the original problem has a basis, this will be stored
+  if (_hasBasis) {
+    basisStatusRows.reSize(numRows());
+    basisStatusCols.reSize(numCols());
+    _solver.getBasis(basisStatusRows.get_ptr(), basisStatusCols.get_ptr(),
+                     basisStatusRows.size(), basisStatusCols.size());
+  }
+
+  // updating the algorithm iterations statistic
+  _statistics->callsReducedProb++;
+
+  // setting the statistic information
+  numDecompIter = 0;
+  numRedProbIter = _solver.iterations();
+  numCompProbIter = 0;
+
+  // setting the display information
+  _decompDisplayLine = 0;
+
+  /************************/
+  /* Decomposition phase  */
+  /************************/
+
+  MSG_INFO1(spxout, spxout << "========      Degeneracy Detected       ========"
+                           << std::endl
+                           << std::endl
+                           << "======== Commencing decomposition solve ========"
+                           << std::endl);
+
+  // spxout.setVerbosity( SPxOut::DEBUG );
+  MSG_INFO2(spxout, spxout << "Creating the Reduced and Complementary problems."
+                           << std::endl);
+
+  // setting the verbosity level
+  const SPxOut::Verbosity orig_verbosity = spxout.getVerbosity();
+  const SPxOut::Verbosity decomp_verbosity =
+      (SPxOut::Verbosity)intParam(SoPlexBase<R>::DECOMP_VERBOSITY);
+
+  if (decomp_verbosity < orig_verbosity)
+    spxout.setVerbosity(decomp_verbosity);
+
+  // creating copies of the original problem that will be manipulated to form
+  // the reduced and complementary problems.
+  _createDecompReducedAndComplementaryProblems();
+
+  // creating the initial reduced problem from the basis information
+  _formDecompReducedProblem(stop);
+
+  // setting flags for the decomposition solve
+  _hasBasis = false;
+  bool hasRedBasis = false;
+  bool redProbError = false;
+  bool noRedprobIter = false;
+  bool explicitviol = boolParam(SoPlexBase<R>::EXPLICITVIOL);
+  int algIterCount = 0;
+
+  // a stop will be triggered if the reduced problem exceeded a specified
+  // fraction of the time limit
+  if (stop) {
+    MSG_INFO1(spxout, spxout
+                          << "==== Error constructing the reduced problem ===="
+                          << std::endl);
+    redProbError = true;
+    _statistics->redProbStatus = SPxSolverBase<R>::NOT_INIT;
+  }
+
+  // the main solving loop of the decomposition simplex.
+  // This loop solves the Reduced problem, and if the problem is feasible, the
+  // complementary problem is solved.
+  while (!stop) {
+    int previter = _statistics->iterations;
+
+    // setting the current solving mode.
+    _currentProb = DECOMP_RED;
+
+    // solve the reduced problem
+
+    MSG_INFO2(spxout, spxout << std::endl
+                             << "=========================" << std::endl
+                             << "Solving: Reduced Problem." << std::endl
+                             << "=========================" << std::endl
+                             << std::endl);
+
+    _hasBasis = hasRedBasis;
+    // solving the reduced problem
+    _decompSimplifyAndSolve(_solver, _slufactor, !algIterCount, !algIterCount);
+
+    stop = decompTerminate(
+        realParam(SoPlexBase<R>::TIMELIMIT)); // checking whether the algorithm
+                                              // should terminate
+
+    // updating the algorithm iterations statistics
+    _statistics->callsReducedProb++;
+    _statistics->redProbStatus = _solver.status();
+
+    assert(_isRealLPLoaded);
+    hasRedBasis = _hasBasis;
+    _hasBasis = false;
+
+    // checking the status of the reduced problem
+    // It is expected that infeasibility and unboundedness will be found in the
+    // initialisation solve. If this is not the case and the reduced problem is
+    // infeasible or unbounded the decomposition simplex will terminate. If the
+    // decomposition simplex terminates, then the original problem will be
+    // solved using the stored basis.
+    if (_solver.status() != SPxSolverBase<R>::OPTIMAL) {
+      if (_solver.status() == SPxSolverBase<R>::UNBOUNDED)
+        MSG_INFO2(spxout, spxout << "Unbounded reduced problem." << std::endl);
+
+      if (_solver.status() == SPxSolverBase<R>::INFEASIBLE)
+        MSG_INFO2(spxout, spxout << "Infeasible reduced problem." << std::endl);
+
+      MSG_INFO2(spxout, spxout << "Reduced problem status: "
+                               << static_cast<int>(_solver.status())
+                               << std::endl);
 
-         // checking the optimality of the reduced problem solution with the original problem
-         _checkOriginalProblemOptimality(reducedLPPrimalVector, true);
+      redProbError = true;
+      break;
+    }
 
-         // if there are any violated rows or bounds then stop is reset and the algorithm continues.
-         if(_nDecompViolBounds > 0 || _nDecompViolRows > 0)
-            stop = false;
+    // as a final check, if no iterations were performed with the reduced
+    // problem, then the algorithm terminates
+    if (_statistics->iterations == previter) {
+      MSG_WARNING(spxout, spxout << "WIMDSM02: reduced problem performed zero "
+                                    "iterations. Terminating."
+                                 << std::endl;);
 
-         if(_nDecompViolBounds == 0 && _nDecompViolRows == 0)
-            stop = true;
+      noRedprobIter = true;
+      stop = true;
+      break;
+    }
+
+    // printing display line
+    printDecompDisplayLine(_solver, orig_verbosity, !algIterCount,
+                           !algIterCount);
+
+    // get the dual solutions from the reduced problem
+    VectorBase<R> reducedLPDualVector(_solver.nRows());
+    VectorBase<R> reducedLPRedcostVector(_solver.nCols());
+    _solver.getDualSol(reducedLPDualVector);
+    _solver.getRedCostSol(reducedLPRedcostVector);
+
+    // Using the solution to the reduced problem:
+    // In the first iteration of the algorithm create the complementary problem.
+    // In the subsequent iterations of the algorithm update the complementary
+    // problem.
+    if (algIterCount == 0)
+      _formDecompComplementaryProblem();
+    else {
+      if (boolParam(SoPlexBase<R>::USECOMPDUAL))
+        _updateDecompComplementaryDualProblem(false);
+      else
+        _updateDecompComplementaryPrimalProblem(false);
+    }
 
-         // updating the reduced problem with the original problem violated rows
-         if(!stop)
-            _updateDecompReducedProblemViol(false);
-      }
+    // setting the current solving mode.
+    _currentProb = DECOMP_COMP;
 
+    // solve the complementary problem
+    MSG_INFO2(spxout, spxout << std::endl
+                             << "=========================" << std::endl
+                             << "Solving: Complementary Problem." << std::endl
+                             << "=========================" << std::endl
+                             << std::endl);
 
-      // =============================================================================
-      // Code check completed up to here
-      // =============================================================================
+    if (!explicitviol) {
+      //_compSolver.writeFileLPBase("comp.lp");
 
-      numDecompIter++;
-      algIterCount++;
-   }
+      _decompSimplifyAndSolve(_compSolver, _compSlufactor, true, true);
 
-   // if there is an error in solving the reduced problem, i.e. infeasible or unbounded, then we leave the
-   // decomposition solve and resolve the original. Infeasibility should be dealt with in the original problem.
-   if(!redProbError)
-   {
-#ifndef NDEBUG
-      // computing the solution for the original variables
+      MSG_INFO2(spxout, spxout << "Iteration " << algIterCount
+                               << "Objective Value: " << std::setprecision(10)
+                               << _compSolver.objValue() << std::endl);
+    }
+
+    assert(_isRealLPLoaded);
+
+    // Check whether the complementary problem is solved with a non-negative
+    // objective function, is infeasible or unbounded. If true, then stop the
+    // algorithm.
+    if (!explicitviol &&
+        (GE(_compSolver.objValue(), R(0.0), R(1e-20)) ||
+         _compSolver.status() == SPxSolverBase<R>::INFEASIBLE ||
+         _compSolver.status() == SPxSolverBase<R>::UNBOUNDED)) {
+      _statistics->compProbStatus = _compSolver.status();
+      _statistics->finalCompObj = _compSolver.objValue();
+
+      if (_compSolver.status() == SPxSolverBase<R>::UNBOUNDED)
+        MSG_INFO2(spxout,
+                  spxout << "Unbounded complementary problem." << std::endl);
+
+      if (_compSolver.status() == SPxSolverBase<R>::INFEASIBLE)
+        MSG_INFO2(spxout,
+                  spxout << "Infeasible complementary problem." << std::endl);
+
+      if (_compSolver.status() == SPxSolverBase<R>::INFEASIBLE ||
+          _compSolver.status() == SPxSolverBase<R>::UNBOUNDED)
+        explicitviol = true;
+
+      stop = true;
+    }
+
+    if (!stop && !explicitviol) {
+      // get the primal solutions from the complementary problem
+      VectorBase<R> compLPPrimalVector(_compSolver.nCols());
+      _compSolver.getPrimalSol(compLPPrimalVector);
+
+      // get the dual solutions from the complementary problem
+      VectorBase<R> compLPDualVector(_compSolver.nRows());
+      _compSolver.getDualSol(compLPDualVector);
+
+      // updating the reduced problem
+      _updateDecompReducedProblem(_compSolver.objValue(), reducedLPDualVector,
+                                  reducedLPRedcostVector, compLPPrimalVector,
+                                  compLPDualVector);
+    }
+    // if the complementary problem is infeasible or unbounded, it is possible
+    // that the algorithm can continue. a check of the original problem is
+    // required to determine whether there are any violations.
+    else if (_compSolver.status() == SPxSolverBase<R>::INFEASIBLE ||
+             _compSolver.status() == SPxSolverBase<R>::UNBOUNDED ||
+             explicitviol) {
+      // getting the primal vector from the reduced problem
       VectorBase<R> reducedLPPrimalVector(_solver.nCols());
       _solver.getPrimalSol(reducedLPPrimalVector);
 
-      // checking the optimality of the reduced problem solution with the original problem
+      // checking the optimality of the reduced problem solution with the
+      // original problem
       _checkOriginalProblemOptimality(reducedLPPrimalVector, true);
 
-      // resetting the verbosity level
-      spxout.setVerbosity(orig_verbosity);
-#endif
+      // if there are any violated rows or bounds then stop is reset and the
+      // algorithm continues.
+      if (_nDecompViolBounds > 0 || _nDecompViolRows > 0)
+        stop = false;
 
-      // This is an additional check to ensure that the complementary problem is solving correctly.
-      // This is only used for debugging
-#ifdef PERFORM_COMPPROB_CHECK
+      if (_nDecompViolBounds == 0 && _nDecompViolRows == 0)
+        stop = true;
 
-      // solving the complementary problem with the original objective function
-      if(boolParam(SoPlexBase<R>::USECOMPDUAL))
-         _setComplementaryDualOriginalObjective();
-      else
-         _setComplementaryPrimalOriginalObjective();
+      // updating the reduced problem with the original problem violated rows
+      if (!stop)
+        _updateDecompReducedProblemViol(false);
+    }
 
-      // for clean up
-      // the real lp has to be set to not loaded.
-      //_isRealLPLoaded = false;
-      // the basis has to be set to false
-      _hasBasis = false;
+    // =============================================================================
+    // Code check completed up to here
+    // =============================================================================
 
-      if(boolParam(SoPlexBase<R>::USECOMPDUAL))
-      {
-         SPxLPBase<R> compDualLP;
-         _compSolver.buildDualProblem(compDualLP, _decompPrimalRowIDs.get_ptr(),
-                                      _decompPrimalColIDs.get_ptr(),
-                                      _decompDualRowIDs.get_ptr(), _decompDualColIDs.get_ptr(), &_nPrimalRows, &_nPrimalCols, &_nDualRows,
-                                      &_nDualCols);
+    numDecompIter++;
+    algIterCount++;
+  }
 
-         _compSolver.loadLP(compDualLP);
-      }
+  // if there is an error in solving the reduced problem, i.e. infeasible or
+  // unbounded, then we leave the decomposition solve and resolve the original.
+  // Infeasibility should be dealt with in the original problem.
+  if (!redProbError) {
+#ifndef NDEBUG
+    // computing the solution for the original variables
+    VectorBase<R> reducedLPPrimalVector(_solver.nCols());
+    _solver.getPrimalSol(reducedLPPrimalVector);
 
-      _decompSimplifyAndSolve(_compSolver, _compSlufactor, true, true);
+    // checking the optimality of the reduced problem solution with the original
+    // problem
+    _checkOriginalProblemOptimality(reducedLPPrimalVector, true);
 
-      _solReal._hasPrimal = true;
-      _hasSolReal = true;
-      // get the primal solutions from the reduced problem
-      VectorBase<R> testPrimalVector(_compSolver.nCols());
-      _compSolver.getPrimalSol(testPrimalVector);
-      _solReal._primal.reDim(_compSolver.nCols());
-      _solReal._primal = testPrimalVector;
-
-      R maxviol = 0;
-      R sumviol = 0;
-
-      // Since the original objective value has now been installed in the complementary problem, the solution will be
-      // a solution to the original problem.
-      // checking the bound violation of the solution from  complementary problem
-      if(getDecompBoundViolation(maxviol, sumviol))
-         MSG_INFO1(spxout, spxout << "Bound violation - "
-                   << "Max: " << std::setprecision(20) << maxviol << " "
-                   << "Sum: " << sumviol << std::endl);
-
-      // checking the row violation of the solution from the complementary problem
-      if(getDecompRowViolation(maxviol, sumviol))
-         MSG_INFO1(spxout, spxout << "Row violation - "
-                   << "Max: " << std::setprecision(21) << maxviol << " "
-                   << "Sum: " << sumviol << std::endl);
-
-      MSG_INFO1(spxout, spxout << "Objective Value: " << _compSolver.objValue() << std::endl);
+    // resetting the verbosity level
+    spxout.setVerbosity(orig_verbosity);
 #endif
-   }
-
-   // resetting the verbosity level
-   spxout.setVerbosity(orig_verbosity);
-
-   MSG_INFO1(spxout,
-             spxout << "========  Decomposition solve completed ========" << std::endl
-             << std::endl
-             << "========   Resolving original problem   ========" << std::endl
-            );
-
-   // if there is a reduced problem error in the first iteration the complementary problme has not been
-   // set up. In this case no memory has been allocated for _decompCompProbColIDsIdx and _fixedOrigVars.
-   if((!redProbError && !noRedprobIter) || algIterCount > 0)
-   {
-      spx_free(_decompCompProbColIDsIdx);
-      spx_free(_fixedOrigVars);
-   }
-
-   spx_free(_decompViolatedRows);
-   spx_free(_decompViolatedBounds);
-   spx_free(_decompReducedProbCols);
-   spx_free(_decompReducedProbRows);
-
-   // retreiving the original problem statistics prior to destroying it.
-   getOriginalProblemStatistics();
-
-   // setting the reduced problem statistics
-   _statistics->numRedProbRows = numIncludedRows;
-   _statistics->numRedProbCols = _solver.nCols();
-
-
-   // printing display line for resolve of problem
-   _solver.printDisplayLine(false, true);
-
-   // if there is an error solving the reduced problem the LP must be solved from scratch
-   if(redProbError)
-   {
-      MSG_INFO1(spxout, spxout << "=== Reduced problem error - Solving original ===" << std::endl);
-
-      // the solver is loaded with the realLP to solve the problem from scratch
-      _solver.loadLP(*_realLP);
-      spx_free(_realLP);
-      _realLP = &_solver;
-      _isRealLPLoaded = true;
-
-      // returning the sense to minimise
-      if(intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MINIMIZE)
-      {
-         assert(_solver.spxSense() == SPxLPBase<R>::MAXIMIZE);
-
-         _solver.changeObj(-(_solver.maxObj()));
-         _solver.changeSense(SPxLPBase<R>::MINIMIZE);
 
-         // Need to add commands to multiply the objective solution values by -1
-      }
-
-      //_solver.setBasis(basisStatusRows.get_const_ptr(), basisStatusCols.get_const_ptr());
-      _preprocessAndSolveReal(true);
-   }
-   else
-   {
-      // resolving the problem to update the real lp and solve with the correct objective.
-      // the realLP is updated with the current solver. This is to resolve the problem to get the correct solution
-      // values
-      _realLP->~SPxLPBase<R>();
-      spx_free(_realLP);
-      _realLP = &_solver;
-      _isRealLPLoaded = true;
-
-      // returning the sense to minimise
-      if(intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MINIMIZE)
-      {
-         assert(_solver.spxSense() == SPxLPBase<R>::MAXIMIZE);
+    // This is an additional check to ensure that the complementary problem is
+    // solving correctly. This is only used for debugging
+#ifdef PERFORM_COMPPROB_CHECK
 
-         _solver.changeObj(-(_solver.maxObj()));
-         _solver.changeSense(SPxLPBase<R>::MINIMIZE);
+    // solving the complementary problem with the original objective function
+    if (boolParam(SoPlexBase<R>::USECOMPDUAL))
+      _setComplementaryDualOriginalObjective();
+    else
+      _setComplementaryPrimalOriginalObjective();
 
-         // Need to add commands to multiply the objective solution values by -1
-      }
+    // for clean up
+    // the real lp has to be set to not loaded.
+    //_isRealLPLoaded = false;
+    // the basis has to be set to false
+    _hasBasis = false;
 
-      _preprocessAndSolveReal(false);
-   }
+    if (boolParam(SoPlexBase<R>::USECOMPDUAL)) {
+      SPxLPBase<R> compDualLP;
+      _compSolver.buildDualProblem(compDualLP, _decompPrimalRowIDs.get_ptr(),
+                                   _decompPrimalColIDs.get_ptr(),
+                                   _decompDualRowIDs.get_ptr(),
+                                   _decompDualColIDs.get_ptr(), &_nPrimalRows,
+                                   &_nPrimalCols, &_nDualRows, &_nDualCols);
 
-   // stop timing
-   _statistics->solvingTime->stop();
+      _compSolver.loadLP(compDualLP);
+    }
+
+    _decompSimplifyAndSolve(_compSolver, _compSlufactor, true, true);
+
+    _solReal._hasPrimal = true;
+    _hasSolReal = true;
+    // get the primal solutions from the reduced problem
+    VectorBase<R> testPrimalVector(_compSolver.nCols());
+    _compSolver.getPrimalSol(testPrimalVector);
+    _solReal._primal.reDim(_compSolver.nCols());
+    _solReal._primal = testPrimalVector;
+
+    R maxviol = 0;
+    R sumviol = 0;
+
+    // Since the original objective value has now been installed in the
+    // complementary problem, the solution will be a solution to the original
+    // problem. checking the bound violation of the solution from  complementary
+    // problem
+    if (getDecompBoundViolation(maxviol, sumviol))
+      MSG_INFO1(spxout, spxout << "Bound violation - "
+                               << "Max: " << std::setprecision(20) << maxviol
+                               << " "
+                               << "Sum: " << sumviol << std::endl);
+
+    // checking the row violation of the solution from the complementary problem
+    if (getDecompRowViolation(maxviol, sumviol))
+      MSG_INFO1(spxout, spxout << "Row violation - "
+                               << "Max: " << std::setprecision(21) << maxviol
+                               << " "
+                               << "Sum: " << sumviol << std::endl);
+
+    MSG_INFO1(spxout, spxout << "Objective Value: " << _compSolver.objValue()
+                             << std::endl);
+#endif
+  }
+
+  // resetting the verbosity level
+  spxout.setVerbosity(orig_verbosity);
+
+  MSG_INFO1(spxout, spxout << "========  Decomposition solve completed ========"
+                           << std::endl
+                           << std::endl
+                           << "========   Resolving original problem   ========"
+                           << std::endl);
+
+  // if there is a reduced problem error in the first iteration the
+  // complementary problme has not been set up. In this case no memory has been
+  // allocated for _decompCompProbColIDsIdx and _fixedOrigVars.
+  if ((!redProbError && !noRedprobIter) || algIterCount > 0) {
+    spx_free(_decompCompProbColIDsIdx);
+    spx_free(_fixedOrigVars);
+  }
+
+  spx_free(_decompViolatedRows);
+  spx_free(_decompViolatedBounds);
+  spx_free(_decompReducedProbCols);
+  spx_free(_decompReducedProbRows);
+
+  // retreiving the original problem statistics prior to destroying it.
+  getOriginalProblemStatistics();
+
+  // setting the reduced problem statistics
+  _statistics->numRedProbRows = numIncludedRows;
+  _statistics->numRedProbCols = _solver.nCols();
+
+  // printing display line for resolve of problem
+  _solver.printDisplayLine(false, true);
+
+  // if there is an error solving the reduced problem the LP must be solved from
+  // scratch
+  if (redProbError) {
+    MSG_INFO1(spxout, spxout
+                          << "=== Reduced problem error - Solving original ==="
+                          << std::endl);
+
+    // the solver is loaded with the realLP to solve the problem from scratch
+    _solver.loadLP(*_realLP);
+    spx_free(_realLP);
+    _realLP = &_solver;
+    _isRealLPLoaded = true;
+
+    // returning the sense to minimise
+    if (intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MINIMIZE) {
+      assert(_solver.spxSense() == SPxLPBase<R>::MAXIMIZE);
+
+      _solver.changeObj(-(_solver.maxObj()));
+      _solver.changeSense(SPxLPBase<R>::MINIMIZE);
+
+      // Need to add commands to multiply the objective solution values by -1
+    }
+
+    //_solver.setBasis(basisStatusRows.get_const_ptr(),
+    //basisStatusCols.get_const_ptr());
+    _preprocessAndSolveReal(true);
+  } else {
+    // resolving the problem to update the real lp and solve with the correct
+    // objective. the realLP is updated with the current solver. This is to
+    // resolve the problem to get the correct solution values
+    _realLP->~SPxLPBase<R>();
+    spx_free(_realLP);
+    _realLP = &_solver;
+    _isRealLPLoaded = true;
+
+    // returning the sense to minimise
+    if (intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MINIMIZE) {
+      assert(_solver.spxSense() == SPxLPBase<R>::MAXIMIZE);
+
+      _solver.changeObj(-(_solver.maxObj()));
+      _solver.changeSense(SPxLPBase<R>::MINIMIZE);
+
+      // Need to add commands to multiply the objective solution values by -1
+    }
+
+    _preprocessAndSolveReal(false);
+  }
+
+  // stop timing
+  _statistics->solvingTime->stop();
 }
 
-
-
-/// creating copies of the original problem that will be manipulated to form the reduced and complementary problems
+/// creating copies of the original problem that will be manipulated to form the
+/// reduced and complementary problems
 template <class R>
-void SoPlexBase<R>::_createDecompReducedAndComplementaryProblems()
-{
-   // the reduced problem is formed from the current problem
-   // So, we copy the _solver to the _realLP and work on the _solver
-   // NOTE: there is no need to preprocess because we always have a starting basis.
-   _realLP = nullptr;
-   spx_alloc(_realLP);
-   _realLP = new(_realLP) SPxLPBase<R>(_solver);
-
-   // allocating memory for the reduced problem rows and cols flag array
-   _decompReducedProbRows = nullptr;
-   spx_alloc(_decompReducedProbRows, numRows());
-   _decompReducedProbCols = nullptr;
-   spx_alloc(_decompReducedProbCols, numCols());
-
-   // the complementary problem is formulated with all incompatible rows and those from the reduced problem that have
-   // a positive reduced cost.
-   _compSolver = _solver;
-   _compSolver.setOutstream(spxout);
-   _compSolver.setBasisSolver(&_compSlufactor);
-
-   // allocating memory for the violated bounds and rows arrays
-   _decompViolatedBounds = nullptr;
-   _decompViolatedRows = nullptr;
-   spx_alloc(_decompViolatedBounds, numCols());
-   spx_alloc(_decompViolatedRows, numRows());
-   _nDecompViolBounds = 0;
-   _nDecompViolRows = 0;
+void SoPlexBase<R>::_createDecompReducedAndComplementaryProblems() {
+  // the reduced problem is formed from the current problem
+  // So, we copy the _solver to the _realLP and work on the _solver
+  // NOTE: there is no need to preprocess because we always have a starting
+  // basis.
+  _realLP = nullptr;
+  spx_alloc(_realLP);
+  _realLP = new (_realLP) SPxLPBase<R>(_solver);
+
+  // allocating memory for the reduced problem rows and cols flag array
+  _decompReducedProbRows = nullptr;
+  spx_alloc(_decompReducedProbRows, numRows());
+  _decompReducedProbCols = nullptr;
+  spx_alloc(_decompReducedProbCols, numCols());
+
+  // the complementary problem is formulated with all incompatible rows and
+  // those from the reduced problem that have a positive reduced cost.
+  _compSolver = _solver;
+  _compSolver.setOutstream(spxout);
+  _compSolver.setBasisSolver(&_compSlufactor);
+
+  // allocating memory for the violated bounds and rows arrays
+  _decompViolatedBounds = nullptr;
+  _decompViolatedRows = nullptr;
+  spx_alloc(_decompViolatedBounds, numCols());
+  spx_alloc(_decompViolatedRows, numRows());
+  _nDecompViolBounds = 0;
+  _nDecompViolRows = 0;
 }
 
-
-
 /// forms the reduced problem
-template <class R>
-void SoPlexBase<R>::_formDecompReducedProblem(bool& stop)
-{
-   MSG_INFO2(spxout, spxout << "Forming the Reduced problem" << std::endl);
-   int* nonposind = 0;
-   int* compatind = 0;
-   int* rowsforremoval = 0;
-   int* colsforremoval = 0;
-   int nnonposind = 0;
-   int ncompatind = 0;
-
-   assert(_solver.nCols() == numCols());
-   assert(_solver.nRows() == numRows());
-
-   // capturing the basis used for the transformation
-   _decompTransBasis = _solver.basis();
-
-   // setting row counter to zero
-   numIncludedRows = 0;
-
-   // the _decompLP is used as a helper LP object. This is used so that _realLP can still hold the original problem.
-   _decompLP = 0;
-   spx_alloc(_decompLP);
-   _decompLP = new(_decompLP) SPxLPBase<R>(_solver);
-
-   // retreiving the basis information
-   _basisStatusRows.reSize(numRows());
-   _basisStatusCols.reSize(numCols());
-   _solver.getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr());
-
-   // get the indices of the rows with positive dual multipliers and columns with positive reduced costs.
-   spx_alloc(nonposind, numCols());
-   spx_alloc(colsforremoval, numCols());
-
-   if(!stop)
-      _getZeroDualMultiplierIndices(_decompFeasVector, nonposind, colsforremoval, &nnonposind, stop);
-
-   // get the compatible columns from the constraint matrix w.r.t the current basis matrix
-   MSG_INFO2(spxout, spxout << "Computing the compatible columns" << std::endl
-             << "Solving time: " << solveTime() << std::endl);
-
-   spx_alloc(compatind, _solver.nRows());
-   spx_alloc(rowsforremoval, _solver.nRows());
-
-   if(!stop)
-      _getCompatibleColumns(_decompFeasVector, nonposind, compatind, rowsforremoval, colsforremoval,
-                            nnonposind,
-                            &ncompatind, true, stop);
-
-   int* compatboundcons = 0;
-   int ncompatboundcons = 0;
-   spx_alloc(compatboundcons, numCols());
-
-   LPRowSetBase<R> boundcons;
-
-   // identifying the compatible bound constraints
-   if(!stop)
-      _getCompatibleBoundCons(boundcons, compatboundcons, nonposind, &ncompatboundcons, nnonposind, stop);
-
-   // delete rows and columns from the LP to form the reduced problem
-   MSG_INFO2(spxout, spxout << "Deleting rows and columns to form the reduced problem" << std::endl
-             << "Solving time: " << solveTime() << std::endl);
-
-   // allocating memory to add bound constraints
-   SPxRowId* addedrowids = 0;
-   spx_alloc(addedrowids, ncompatboundcons);
-
-   // computing the reduced problem obj coefficient vector and updating the problem
-   if(!stop)
-   {
-      _computeReducedProbObjCoeff(stop);
-
-      _solver.loadLP(*_decompLP);
-
-      // the colsforremoval are the columns with a zero reduced cost.
-      // the rowsforremoval are the rows identified as incompatible.
-      _solver.removeRows(rowsforremoval);
-      // adding the rows for the compatible bound constraints
-      _solver.addRows(addedrowids, boundcons);
-
-      for(int i = 0; i < ncompatboundcons; i++)
-         _decompReducedProbColRowIDs[compatboundcons[i]] = addedrowids[i];
-   }
-
-
-   // freeing allocated memory
-   spx_free(addedrowids);
-   spx_free(compatboundcons);
-   spx_free(rowsforremoval);
-   spx_free(compatind);
-   spx_free(colsforremoval);
-   spx_free(nonposind);
-
-   _decompLP->~SPxLPBase<R>();
-   spx_free(_decompLP);
+template <class R> void SoPlexBase<R>::_formDecompReducedProblem(bool &stop) {
+  MSG_INFO2(spxout, spxout << "Forming the Reduced problem" << std::endl);
+  int *nonposind = 0;
+  int *compatind = 0;
+  int *rowsforremoval = 0;
+  int *colsforremoval = 0;
+  int nnonposind = 0;
+  int ncompatind = 0;
+
+  assert(_solver.nCols() == numCols());
+  assert(_solver.nRows() == numRows());
+
+  // capturing the basis used for the transformation
+  _decompTransBasis = _solver.basis();
+
+  // setting row counter to zero
+  numIncludedRows = 0;
+
+  // the _decompLP is used as a helper LP object. This is used so that _realLP
+  // can still hold the original problem.
+  _decompLP = 0;
+  spx_alloc(_decompLP);
+  _decompLP = new (_decompLP) SPxLPBase<R>(_solver);
+
+  // retreiving the basis information
+  _basisStatusRows.reSize(numRows());
+  _basisStatusCols.reSize(numCols());
+  _solver.getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr());
+
+  // get the indices of the rows with positive dual multipliers and columns with
+  // positive reduced costs.
+  spx_alloc(nonposind, numCols());
+  spx_alloc(colsforremoval, numCols());
+
+  if (!stop)
+    _getZeroDualMultiplierIndices(_decompFeasVector, nonposind, colsforremoval,
+                                  &nnonposind, stop);
+
+  // get the compatible columns from the constraint matrix w.r.t the current
+  // basis matrix
+  MSG_INFO2(spxout, spxout << "Computing the compatible columns" << std::endl
+                           << "Solving time: " << solveTime() << std::endl);
+
+  spx_alloc(compatind, _solver.nRows());
+  spx_alloc(rowsforremoval, _solver.nRows());
+
+  if (!stop)
+    _getCompatibleColumns(_decompFeasVector, nonposind, compatind,
+                          rowsforremoval, colsforremoval, nnonposind,
+                          &ncompatind, true, stop);
+
+  int *compatboundcons = 0;
+  int ncompatboundcons = 0;
+  spx_alloc(compatboundcons, numCols());
+
+  LPRowSetBase<R> boundcons;
+
+  // identifying the compatible bound constraints
+  if (!stop)
+    _getCompatibleBoundCons(boundcons, compatboundcons, nonposind,
+                            &ncompatboundcons, nnonposind, stop);
+
+  // delete rows and columns from the LP to form the reduced problem
+  MSG_INFO2(spxout,
+            spxout << "Deleting rows and columns to form the reduced problem"
+                   << std::endl
+                   << "Solving time: " << solveTime() << std::endl);
+
+  // allocating memory to add bound constraints
+  SPxRowId *addedrowids = 0;
+  spx_alloc(addedrowids, ncompatboundcons);
+
+  // computing the reduced problem obj coefficient vector and updating the
+  // problem
+  if (!stop) {
+    _computeReducedProbObjCoeff(stop);
+
+    _solver.loadLP(*_decompLP);
+
+    // the colsforremoval are the columns with a zero reduced cost.
+    // the rowsforremoval are the rows identified as incompatible.
+    _solver.removeRows(rowsforremoval);
+    // adding the rows for the compatible bound constraints
+    _solver.addRows(addedrowids, boundcons);
+
+    for (int i = 0; i < ncompatboundcons; i++)
+      _decompReducedProbColRowIDs[compatboundcons[i]] = addedrowids[i];
+  }
+
+  // freeing allocated memory
+  spx_free(addedrowids);
+  spx_free(compatboundcons);
+  spx_free(rowsforremoval);
+  spx_free(compatind);
+  spx_free(colsforremoval);
+  spx_free(nonposind);
+
+  _decompLP->~SPxLPBase<R>();
+  spx_free(_decompLP);
 }
 
-
-
 /// forms the complementary problem
-template <class R>
-void SoPlexBase<R>::_formDecompComplementaryProblem()
-{
-   // delete rows and columns from the LP to form the reduced problem
-   _nElimPrimalRows = 0;
-   _decompElimPrimalRowIDs.reSize(
-      _realLP->nRows());   // the number of eliminated rows is less than the number of rows
-   // in the reduced problem
-   _decompCompProbColIDsIdx = 0;
-   spx_alloc(_decompCompProbColIDsIdx, _realLP->nCols());
-
-   _fixedOrigVars = 0;
-   spx_alloc(_fixedOrigVars, _realLP->nCols());
-
-   for(int i = 0; i < _realLP->nCols(); i++)
-   {
-      _decompCompProbColIDsIdx[i] = -1;
-      _fixedOrigVars[i] = -2; // this must be set to a value differet from -1, 0, 1 to ensure the
-      // _updateComplementaryFixedPrimalVars function updates all variables in the problem.
-   }
-
-   int naddedrows = 0;
-   DataArray < SPxRowId > rangedRowIds(numRows());
-   _deleteAndUpdateRowsComplementaryProblem(rangedRowIds.get_ptr(), naddedrows);
-
-   if(boolParam(
-            SoPlexBase<R>::USECOMPDUAL))     // if we use the dual formulation of the complementary problem, we must
-      // perform the transformation
-   {
-      // initialising the arrays to store the row id's from the primal and the col id's from the dual
-      _decompPrimalRowIDs.reSize(3 * _compSolver.nRows());
-      _decompPrimalColIDs.reSize(3 * _compSolver.nCols());
-      _decompDualRowIDs.reSize(3 * _compSolver.nCols());
-      _decompDualColIDs.reSize(3 * _compSolver.nRows());
-      _nPrimalRows = 0;
-      _nPrimalCols = 0;
-      _nDualRows = 0;
-      _nDualCols = 0;
-
-      // convert complementary problem to dual problem
-      SPxLPBase<R> compDualLP;
-      _compSolver.buildDualProblem(compDualLP, _decompPrimalRowIDs.get_ptr(),
-                                   _decompPrimalColIDs.get_ptr(),
-                                   _decompDualRowIDs.get_ptr(), _decompDualColIDs.get_ptr(), &_nPrimalRows, &_nPrimalCols, &_nDualRows,
-                                   &_nDualCols);
-      compDualLP.setOutstream(spxout);
-
-      // setting the id index array for the complementary problem
-      for(int i = 0; i < _nPrimalRows; i++)
-      {
-         // a primal row may result in two dual columns. So the index array points to the first of the indicies for the
-         // primal row.
-         if(i + 1 < _nPrimalRows &&
-               _realLP->number(SPxRowId(_decompPrimalRowIDs[i])) == _realLP->number(SPxRowId(
-                        _decompPrimalRowIDs[i + 1])))
-            i++;
-      }
-
-      for(int i = 0; i < _nPrimalCols; i++)
-      {
-         if(_decompPrimalColIDs[i].getIdx() != _compSlackColId.getIdx())
-            _decompCompProbColIDsIdx[_realLP->number(_decompPrimalColIDs[i])] = i;
-      }
-
-      // retrieving the dual row id for the complementary slack column
-      // there should be a one to one relationship between the number of primal columns and the number of dual rows.
-      // hence, it should be possible to equate the dual row id to the related primal column.
-      assert(_nPrimalCols == _nDualRows);
-      assert(_compSolver.nCols() == compDualLP.nRows());
-      _compSlackDualRowId = compDualLP.rId(_compSolver.number(_compSlackColId));
-
-      _compSolver.loadLP(compDualLP);
-
-      _compSolver.init();
-
-      _updateComplementaryDualSlackColCoeff();
-
-      // initalising the array for the dual columns representing the fixed variables in the complementary problem.
-      _decompFixedVarDualIDs.reSize(_realLP->nCols());
-      _decompVarBoundDualIDs.reSize(2 * _realLP->nCols());
-
-
-      // updating the constraints for the complementary problem
-      _updateDecompComplementaryDualProblem(false);
-   }
-   else  // when using the primal of the complementary problem, no transformation of the problem is required.
-   {
-      // initialising the arrays to store the row and column id's from the original problem the col id's from the dual
-      // if a row or column is not included in the complementary problem, the ID is set to INVALID in the
-      // _decompPrimalRowIDs or _decompPrimalColIDs respectively.
-      _decompPrimalRowIDs.reSize(_compSolver.nRows() * 2);
-      _decompPrimalColIDs.reSize(_compSolver.nCols());
-      _decompCompPrimalRowIDs.reSize(_compSolver.nRows() * 2);
-      _decompCompPrimalColIDs.reSize(_compSolver.nCols());
-      _nPrimalRows = 0;
-      _nPrimalCols = 0;
-
-      // at this point in time the complementary problem contains all rows and columns from the original problem
-      int addedrangedrows = 0;
-      _nCompPrimalRows = 0;
-      _nCompPrimalCols = 0;
+template <class R> void SoPlexBase<R>::_formDecompComplementaryProblem() {
+  // delete rows and columns from the LP to form the reduced problem
+  _nElimPrimalRows = 0;
+  _decompElimPrimalRowIDs.reSize(
+      _realLP->nRows()); // the number of eliminated rows is less than the
+                         // number of rows
+  // in the reduced problem
+  _decompCompProbColIDsIdx = 0;
+  spx_alloc(_decompCompProbColIDsIdx, _realLP->nCols());
+
+  _fixedOrigVars = 0;
+  spx_alloc(_fixedOrigVars, _realLP->nCols());
+
+  for (int i = 0; i < _realLP->nCols(); i++) {
+    _decompCompProbColIDsIdx[i] = -1;
+    _fixedOrigVars[i] =
+        -2; // this must be set to a value differet from -1, 0, 1 to ensure the
+    // _updateComplementaryFixedPrimalVars function updates all variables in the
+    // problem.
+  }
+
+  int naddedrows = 0;
+  DataArray<SPxRowId> rangedRowIds(numRows());
+  _deleteAndUpdateRowsComplementaryProblem(rangedRowIds.get_ptr(), naddedrows);
+
+  if (boolParam(
+          SoPlexBase<R>::USECOMPDUAL)) // if we use the dual formulation of the
+                                       // complementary problem, we must
+                                       // perform the transformation
+  {
+    // initialising the arrays to store the row id's from the primal and the col
+    // id's from the dual
+    _decompPrimalRowIDs.reSize(3 * _compSolver.nRows());
+    _decompPrimalColIDs.reSize(3 * _compSolver.nCols());
+    _decompDualRowIDs.reSize(3 * _compSolver.nCols());
+    _decompDualColIDs.reSize(3 * _compSolver.nRows());
+    _nPrimalRows = 0;
+    _nPrimalCols = 0;
+    _nDualRows = 0;
+    _nDualCols = 0;
+
+    // convert complementary problem to dual problem
+    SPxLPBase<R> compDualLP;
+    _compSolver.buildDualProblem(compDualLP, _decompPrimalRowIDs.get_ptr(),
+                                 _decompPrimalColIDs.get_ptr(),
+                                 _decompDualRowIDs.get_ptr(),
+                                 _decompDualColIDs.get_ptr(), &_nPrimalRows,
+                                 &_nPrimalCols, &_nDualRows, &_nDualCols);
+    compDualLP.setOutstream(spxout);
+
+    // setting the id index array for the complementary problem
+    for (int i = 0; i < _nPrimalRows; i++) {
+      // a primal row may result in two dual columns. So the index array points
+      // to the first of the indicies for the primal row.
+      if (i + 1 < _nPrimalRows &&
+          _realLP->number(SPxRowId(_decompPrimalRowIDs[i])) ==
+              _realLP->number(SPxRowId(_decompPrimalRowIDs[i + 1])))
+        i++;
+    }
+
+    for (int i = 0; i < _nPrimalCols; i++) {
+      if (_decompPrimalColIDs[i].getIdx() != _compSlackColId.getIdx())
+        _decompCompProbColIDsIdx[_realLP->number(_decompPrimalColIDs[i])] = i;
+    }
+
+    // retrieving the dual row id for the complementary slack column
+    // there should be a one to one relationship between the number of primal
+    // columns and the number of dual rows. hence, it should be possible to
+    // equate the dual row id to the related primal column.
+    assert(_nPrimalCols == _nDualRows);
+    assert(_compSolver.nCols() == compDualLP.nRows());
+    _compSlackDualRowId = compDualLP.rId(_compSolver.number(_compSlackColId));
+
+    _compSolver.loadLP(compDualLP);
+
+    _compSolver.init();
+
+    _updateComplementaryDualSlackColCoeff();
+
+    // initalising the array for the dual columns representing the fixed
+    // variables in the complementary problem.
+    _decompFixedVarDualIDs.reSize(_realLP->nCols());
+    _decompVarBoundDualIDs.reSize(2 * _realLP->nCols());
+
+    // updating the constraints for the complementary problem
+    _updateDecompComplementaryDualProblem(false);
+  } else // when using the primal of the complementary problem, no
+         // transformation of the problem is required.
+  {
+    // initialising the arrays to store the row and column id's from the
+    // original problem the col id's from the dual if a row or column is not
+    // included in the complementary problem, the ID is set to INVALID in the
+    // _decompPrimalRowIDs or _decompPrimalColIDs respectively.
+    _decompPrimalRowIDs.reSize(_compSolver.nRows() * 2);
+    _decompPrimalColIDs.reSize(_compSolver.nCols());
+    _decompCompPrimalRowIDs.reSize(_compSolver.nRows() * 2);
+    _decompCompPrimalColIDs.reSize(_compSolver.nCols());
+    _nPrimalRows = 0;
+    _nPrimalCols = 0;
+
+    // at this point in time the complementary problem contains all rows and
+    // columns from the original problem
+    int addedrangedrows = 0;
+    _nCompPrimalRows = 0;
+    _nCompPrimalCols = 0;
+
+    for (int i = 0; i < _realLP->nRows(); i++) {
+      assert(_nCompPrimalRows < _compSolver.nRows());
+      _decompPrimalRowIDs[_nPrimalRows] = _realLP->rId(i);
+      _decompCompPrimalRowIDs[_nCompPrimalRows] = _compSolver.rId(i);
+      _nPrimalRows++;
+      _nCompPrimalRows++;
 
-      for(int i = 0; i < _realLP->nRows(); i++)
-      {
-         assert(_nCompPrimalRows < _compSolver.nRows());
-         _decompPrimalRowIDs[_nPrimalRows] = _realLP->rId(i);
-         _decompCompPrimalRowIDs[_nCompPrimalRows] = _compSolver.rId(i);
-         _nPrimalRows++;
-         _nCompPrimalRows++;
-
-         if(_realLP->rowType(i) == LPRowBase<R>::RANGE || _realLP->rowType(i) == LPRowBase<R>::EQUAL)
-         {
-            assert(EQ(_compSolver.lhs(rangedRowIds[addedrangedrows]), _realLP->lhs(i)));
-            assert(LE(_compSolver.rhs(rangedRowIds[addedrangedrows]), R(infinity)));
-            assert(LE(_compSolver.lhs(i), R(-infinity)));
-            assert(LT(_compSolver.rhs(i), R(infinity)));
-
-            _decompPrimalRowIDs[_nPrimalRows] = _realLP->rId(i);
-            _decompCompPrimalRowIDs[_nCompPrimalRows] = rangedRowIds[addedrangedrows];
-            _nPrimalRows++;
-            _nCompPrimalRows++;
-            addedrangedrows++;
-         }
+      if (_realLP->rowType(i) == LPRowBase<R>::RANGE ||
+          _realLP->rowType(i) == LPRowBase<R>::EQUAL) {
+        assert(EQ(_compSolver.lhs(rangedRowIds[addedrangedrows]),
+                  _realLP->lhs(i)));
+        assert(LE(_compSolver.rhs(rangedRowIds[addedrangedrows]), R(infinity)));
+        assert(LE(_compSolver.lhs(i), R(-infinity)));
+        assert(LT(_compSolver.rhs(i), R(infinity)));
+
+        _decompPrimalRowIDs[_nPrimalRows] = _realLP->rId(i);
+        _decompCompPrimalRowIDs[_nCompPrimalRows] =
+            rangedRowIds[addedrangedrows];
+        _nPrimalRows++;
+        _nCompPrimalRows++;
+        addedrangedrows++;
       }
+    }
 
-      for(int i = 0; i < _compSolver.nCols(); i++)
-      {
+    for (int i = 0; i < _compSolver.nCols(); i++) {
 
-         if(_compSolver.cId(i).getIdx() != _compSlackColId.getIdx())
-         {
-            _decompPrimalColIDs[i] = _realLP->cId(i);
-            _decompCompPrimalColIDs[i] = _compSolver.cId(i);
-            _nPrimalCols++;
-            _nCompPrimalCols++;
+      if (_compSolver.cId(i).getIdx() != _compSlackColId.getIdx()) {
+        _decompPrimalColIDs[i] = _realLP->cId(i);
+        _decompCompPrimalColIDs[i] = _compSolver.cId(i);
+        _nPrimalCols++;
+        _nCompPrimalCols++;
 
-            _decompCompProbColIDsIdx[_realLP->number(_decompPrimalColIDs[i])] = i;
-         }
+        _decompCompProbColIDsIdx[_realLP->number(_decompPrimalColIDs[i])] = i;
       }
+    }
 
-      // updating the constraints for the complementary problem
-      _updateDecompComplementaryPrimalProblem(false);
-   }
+    // updating the constraints for the complementary problem
+    _updateDecompComplementaryPrimalProblem(false);
+  }
 }
 
-
-
 /// simplifies the problem and solves
 template <class R>
-void SoPlexBase<R>::_decompSimplifyAndSolve(SPxSolverBase<R>& solver, SLUFactor<R>& sluFactor,
-      bool fromScratch, bool applyPreprocessing)
-{
-   if(realParam(SoPlexBase<R>::TIMELIMIT) < realParam(SoPlexBase<R>::INFTY))
-      solver.setTerminationTime(Real(realParam(SoPlexBase<R>::TIMELIMIT)) -
-                                _statistics->solvingTime->time());
-
-   solver.changeObjOffset(realParam(SoPlexBase<R>::OBJ_OFFSET));
-   _statistics->preprocessingTime->start();
-
-   typename SPxSimplifier<R>::Result result = SPxSimplifier<R>::OKAY;
-
-   /* delete starting basis if solving from scratch */
-   if(fromScratch)
-   {
-      try
-      {
-         solver.reLoad();
-      }
-      catch(const SPxException& E)
-      {
-         MSG_ERROR(spxout << "Caught exception <" << E.what() << "> during simplify and solve.\n");
-      }
-   }
-
-   //assert(!fromScratch || solver.status() == SPxSolverBase<R>::NO_PROBLEM);
-
-   if(applyPreprocessing)
-   {
-      _enableSimplifierAndScaler();
-      solver.setTerminationValue(realParam(SoPlexBase<R>::INFTY));
-   }
-   else
-   {
-      _disableSimplifierAndScaler();
-      ///@todo implement for both objective senses
-      solver.setTerminationValue(solver.spxSense() == SPxLPBase<R>::MINIMIZE
-                                 ? realParam(SoPlexBase<R>::OBJLIMIT_UPPER) : realParam(SoPlexBase<R>::INFTY));
-   }
-
-   /* store original lp */
-   applyPreprocessing = (_scaler != nullptr || _simplifier != NULL);
-
-   // @TODO The use of _isRealLPLoaded is not correct. An additional parameter would be useful for this algorithm.
-   // Maybe a parameter _isDecompLPLoaded?
-   if(_isRealLPLoaded)
-   {
-      //assert(_decompLP == &solver); // there should be an assert here, but I don't know what to use.
-
-      // preprocessing is always applied to the LP in the solver; hence we have to create a copy of the original LP
-      // if preprocessing is turned on
-      if(applyPreprocessing)
-      {
-         _decompLP = 0;
-         spx_alloc(_decompLP);
-         _decompLP = new(_decompLP) SPxLPBase<R>(solver);
-         _isRealLPLoaded = false;
-      }
-      else
-         _decompLP = &solver;
-   }
-   else
-   {
-      assert(_decompLP != &solver);
-
-      // ensure that the solver has the original problem
-      solver.loadLP(*_decompLP);
-
-      // load basis if available
-      if(_hasBasis)
-      {
-         assert(_basisStatusRows.size() == solver.nRows());
-         assert(_basisStatusCols.size() == solver.nCols());
-
-         ///@todo this should not fail even if the basis is invalid (wrong dimension or wrong number of basic
-         ///      entries); fix either in SPxSolverBase or in SPxBasisBase
-         solver.setBasis(_basisStatusRows.get_const_ptr(), _basisStatusCols.get_const_ptr());
-      }
+void SoPlexBase<R>::_decompSimplifyAndSolve(SPxSolverBase<R> &solver,
+                                            SLUFactor<R> &sluFactor,
+                                            bool fromScratch,
+                                            bool applyPreprocessing) {
+  if (realParam(SoPlexBase<R>::TIMELIMIT) < realParam(SoPlexBase<R>::INFTY))
+    solver.setTerminationTime(Real(realParam(SoPlexBase<R>::TIMELIMIT)) -
+                              _statistics->solvingTime->time());
+
+  solver.changeObjOffset(realParam(SoPlexBase<R>::OBJ_OFFSET));
+  _statistics->preprocessingTime->start();
+
+  typename SPxSimplifier<R>::Result result = SPxSimplifier<R>::OKAY;
+
+  /* delete starting basis if solving from scratch */
+  if (fromScratch) {
+    try {
+      solver.reLoad();
+    } catch (const SPxException &E) {
+      MSG_ERROR(spxout << "Caught exception <" << E.what()
+                       << "> during simplify and solve.\n");
+    }
+  }
+
+  // assert(!fromScratch || solver.status() == SPxSolverBase<R>::NO_PROBLEM);
+
+  if (applyPreprocessing) {
+    _enableSimplifierAndScaler();
+    solver.setTerminationValue(realParam(SoPlexBase<R>::INFTY));
+  } else {
+    _disableSimplifierAndScaler();
+    ///@todo implement for both objective senses
+    solver.setTerminationValue(solver.spxSense() == SPxLPBase<R>::MINIMIZE
+                                   ? realParam(SoPlexBase<R>::OBJLIMIT_UPPER)
+                                   : realParam(SoPlexBase<R>::INFTY));
+  }
+
+  /* store original lp */
+  applyPreprocessing = (_scaler != nullptr || _simplifier != NULL);
+
+  // @TODO The use of _isRealLPLoaded is not correct. An additional parameter
+  // would be useful for this algorithm. Maybe a parameter _isDecompLPLoaded?
+  if (_isRealLPLoaded) {
+    // assert(_decompLP == &solver); // there should be an assert here, but I
+    // don't know what to use.
+
+    // preprocessing is always applied to the LP in the solver; hence we have to
+    // create a copy of the original LP if preprocessing is turned on
+    if (applyPreprocessing) {
+      _decompLP = 0;
+      spx_alloc(_decompLP);
+      _decompLP = new (_decompLP) SPxLPBase<R>(solver);
+      _isRealLPLoaded = false;
+    } else
+      _decompLP = &solver;
+  } else {
+    assert(_decompLP != &solver);
+
+    // ensure that the solver has the original problem
+    solver.loadLP(*_decompLP);
+
+    // load basis if available
+    if (_hasBasis) {
+      assert(_basisStatusRows.size() == solver.nRows());
+      assert(_basisStatusCols.size() == solver.nCols());
 
-      // if there is no preprocessing, then the original and the transformed problem are identical and it is more
-      // memory-efficient to keep only the problem in the solver
-      if(!applyPreprocessing)
-      {
-         _decompLP->~SPxLPBase<R>();
-         spx_free(_decompLP);
-         _decompLP = &solver;
-         _isRealLPLoaded = true;
-      }
+      ///@todo this should not fail even if the basis is invalid (wrong
+      ///dimension or wrong number of basic
+      ///      entries); fix either in SPxSolverBase or in SPxBasisBase
+      solver.setBasis(_basisStatusRows.get_const_ptr(),
+                      _basisStatusCols.get_const_ptr());
+    }
+
+    // if there is no preprocessing, then the original and the transformed
+    // problem are identical and it is more memory-efficient to keep only the
+    // problem in the solver
+    if (!applyPreprocessing) {
+      _decompLP->~SPxLPBase<R>();
+      spx_free(_decompLP);
+      _decompLP = &solver;
+      _isRealLPLoaded = true;
+    } else {
+      _decompLP = 0;
+      spx_alloc(_decompLP);
+      _decompLP = new (_decompLP) SPxLPBase<R>(solver);
+    }
+  }
+
+  // assert that we have two problems if and only if we apply preprocessing
+  assert(_decompLP == &solver || applyPreprocessing);
+  assert(_decompLP != &solver || !applyPreprocessing);
+
+  // apply problem simplification
+  if (_simplifier != 0) {
+    Real remainingTime = _solver.getMaxTime() - _solver.time();
+    result =
+        _simplifier->simplify(solver, realParam(SoPlexBase<R>::EPSILON_ZERO),
+                              realParam(SoPlexBase<R>::FEASTOL),
+                              realParam(SoPlexBase<R>::OPTTOL), remainingTime);
+    solver.changeObjOffset(_simplifier->getObjoffset() +
+                           realParam(SoPlexBase<R>::OBJ_OFFSET));
+  }
+
+  _statistics->preprocessingTime->stop();
+
+  // run the simplex method if problem has not been solved by the simplifier
+  if (result == SPxSimplifier<R>::OKAY) {
+    if (_scaler != nullptr)
+      _scaler->scale(solver);
+
+    bool _hadBasis = _hasBasis;
+
+    _statistics->simplexTime->start();
+
+    try {
+      solver.solve();
+    } catch (const SPxException &E) {
+      MSG_ERROR(std::cerr << "Caught exception <" << E.what()
+                          << "> while solving real LP.\n");
+      _status = SPxSolverBase<R>::ERROR;
+    } catch (...) {
+      MSG_ERROR(
+          std::cerr << "Caught unknown exception while solving real LP.\n");
+      _status = SPxSolverBase<R>::ERROR;
+    }
+
+    _statistics->simplexTime->stop();
+
+    // record statistics
+    // only record the main statistics for the original problem and reduced
+    // problem. the complementary problem is a pivoting rule, so these will be
+    // held in other statistics. statistics on the number of iterations for each
+    // problem is stored in individual variables.
+    if (_currentProb == DECOMP_ORIG || _currentProb == DECOMP_RED) {
+      _statistics->iterations += solver.iterations();
+      _statistics->iterationsPrimal += solver.primalIterations();
+      _statistics->iterationsFromBasis += _hadBasis ? solver.iterations() : 0;
+      _statistics->boundflips += solver.boundFlips();
+      _statistics->luFactorizationTimeReal += sluFactor.getFactorTime();
+      _statistics->luSolveTimeReal += sluFactor.getSolveTime();
+      _statistics->luFactorizationsReal += sluFactor.getFactorCount();
+      _statistics->luSolvesReal += sluFactor.getSolveCount();
+      sluFactor.resetCounters();
+
+      _statistics->degenPivotsPrimal += solver.primalDegeneratePivots();
+      _statistics->degenPivotsDual += solver.dualDegeneratePivots();
+
+      _statistics->sumDualDegen += _solver.sumDualDegeneracy();
+      _statistics->sumPrimalDegen += _solver.sumPrimalDegeneracy();
+
+      if (_currentProb == DECOMP_ORIG)
+        _statistics->iterationsInit += solver.iterations();
       else
-      {
-         _decompLP = 0;
-         spx_alloc(_decompLP);
-         _decompLP = new(_decompLP) SPxLPBase<R>(solver);
-      }
-   }
-
-   // assert that we have two problems if and only if we apply preprocessing
-   assert(_decompLP == &solver || applyPreprocessing);
-   assert(_decompLP != &solver || !applyPreprocessing);
-
-   // apply problem simplification
-   if(_simplifier != 0)
-   {
-      Real remainingTime = _solver.getMaxTime() - _solver.time();
-      result = _simplifier->simplify(solver, realParam(SoPlexBase<R>::EPSILON_ZERO),
-                                     realParam(SoPlexBase<R>::FEASTOL),
-                                     realParam(SoPlexBase<R>::OPTTOL),
-                                     remainingTime);
-      solver.changeObjOffset(_simplifier->getObjoffset() + realParam(SoPlexBase<R>::OBJ_OFFSET));
-   }
-
-   _statistics->preprocessingTime->stop();
-
-   // run the simplex method if problem has not been solved by the simplifier
-   if(result == SPxSimplifier<R>::OKAY)
-   {
-      if(_scaler != nullptr)
-         _scaler->scale(solver);
-
-      bool _hadBasis = _hasBasis;
-
-      _statistics->simplexTime->start();
-
-      try
-      {
-         solver.solve();
-      }
-      catch(const SPxException& E)
-      {
-         MSG_ERROR(std::cerr << "Caught exception <" << E.what() << "> while solving real LP.\n");
-         _status = SPxSolverBase<R>::ERROR;
-      }
-      catch(...)
-      {
-         MSG_ERROR(std::cerr << "Caught unknown exception while solving real LP.\n");
-         _status = SPxSolverBase<R>::ERROR;
-      }
+        _statistics->iterationsRedProb += solver.iterations();
+    }
 
-      _statistics->simplexTime->stop();
+    if (_currentProb == DECOMP_COMP)
+      _statistics->iterationsCompProb += solver.iterations();
+  }
 
-      // record statistics
-      // only record the main statistics for the original problem and reduced problem.
-      // the complementary problem is a pivoting rule, so these will be held in other statistics.
-      // statistics on the number of iterations for each problem is stored in individual variables.
-      if(_currentProb == DECOMP_ORIG || _currentProb == DECOMP_RED)
-      {
-         _statistics->iterations += solver.iterations();
-         _statistics->iterationsPrimal += solver.primalIterations();
-         _statistics->iterationsFromBasis += _hadBasis ? solver.iterations() : 0;
-         _statistics->boundflips += solver.boundFlips();
-         _statistics->luFactorizationTimeReal += sluFactor.getFactorTime();
-         _statistics->luSolveTimeReal += sluFactor.getSolveTime();
-         _statistics->luFactorizationsReal += sluFactor.getFactorCount();
-         _statistics->luSolvesReal += sluFactor.getSolveCount();
-         sluFactor.resetCounters();
-
-         _statistics->degenPivotsPrimal += solver.primalDegeneratePivots();
-         _statistics->degenPivotsDual += solver.dualDegeneratePivots();
-
-         _statistics->sumDualDegen += _solver.sumDualDegeneracy();
-         _statistics->sumPrimalDegen += _solver.sumPrimalDegeneracy();
-
-         if(_currentProb == DECOMP_ORIG)
-            _statistics->iterationsInit += solver.iterations();
-         else
-            _statistics->iterationsRedProb += solver.iterations();
-      }
-
-      if(_currentProb == DECOMP_COMP)
-         _statistics->iterationsCompProb += solver.iterations();
-
-   }
-
-   // check the result and run again without preprocessing if necessary
-   _evaluateSolutionDecomp(solver, sluFactor, result);
+  // check the result and run again without preprocessing if necessary
+  _evaluateSolutionDecomp(solver, sluFactor, result);
 }
 
-
-
-/// loads original problem into solver and solves again after it has been solved to optimality with preprocessing
+/// loads original problem into solver and solves again after it has been solved
+/// to optimality with preprocessing
 template <class R>
-void SoPlexBase<R>::_decompResolveWithoutPreprocessing(SPxSolverBase<R>& solver,
-      SLUFactor<R>& sluFactor, typename SPxSimplifier<R>::Result result)
-{
-   assert(_simplifier != 0 || _scaler != nullptr);
-   assert(result == SPxSimplifier<R>::VANISHED
-          || (result == SPxSimplifier<R>::OKAY
-              && (solver.status() == SPxSolverBase<R>::OPTIMAL
-                  || solver.status() == SPxSolverBase<R>::ABORT_DECOMP
-                  || solver.status() == SPxSolverBase<R>::ABORT_EXDECOMP)));
-
-   // if simplifier is active and LP is solved in presolving or to optimality, then we unsimplify to get the basis
-   if(_simplifier != 0)
-   {
-      assert(!_simplifier->isUnsimplified());
-
-      bool vanished = result == SPxSimplifier<R>::VANISHED;
-
-      // get solution vectors for transformed problem
-      VectorBase<R> primal(vanished ? 0 : solver.nCols());
-      VectorBase<R> slacks(vanished ? 0 : solver.nRows());
-      VectorBase<R> dual(vanished ? 0 : solver.nRows());
-      VectorBase<R> redCost(vanished ? 0 : solver.nCols());
-
-      assert(!_isRealLPLoaded);
-      _basisStatusRows.reSize(_decompLP->nRows());
-      _basisStatusCols.reSize(_decompLP->nCols());
-      assert(vanished || _basisStatusRows.size() >= solver.nRows());
-      assert(vanished || _basisStatusCols.size() >= solver.nCols());
-
-      if(!vanished)
-      {
-         assert(solver.status() == SPxSolverBase<R>::OPTIMAL
-                || solver.status() == SPxSolverBase<R>::ABORT_DECOMP
-                || solver.status() == SPxSolverBase<R>::ABORT_EXDECOMP);
-
-         solver.getPrimalSol(primal);
-         solver.getSlacks(slacks);
-         solver.getDualSol(dual);
-         solver.getRedCostSol(redCost);
-
-         // unscale vectors
-         if(_scaler && solver.isScaled())
-         {
-            _scaler->unscalePrimal(solver, primal);
-            _scaler->unscaleSlacks(solver, slacks);
-            _scaler->unscaleDual(solver, dual);
-            _scaler->unscaleRedCost(solver, redCost);
-         }
-
-         // get basis of transformed problem
-         solver.getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr());
+void SoPlexBase<R>::_decompResolveWithoutPreprocessing(
+    SPxSolverBase<R> &solver, SLUFactor<R> &sluFactor,
+    typename SPxSimplifier<R>::Result result) {
+  assert(_simplifier != 0 || _scaler != nullptr);
+  assert(result == SPxSimplifier<R>::VANISHED ||
+         (result == SPxSimplifier<R>::OKAY &&
+          (solver.status() == SPxSolverBase<R>::OPTIMAL ||
+           solver.status() == SPxSolverBase<R>::ABORT_DECOMP ||
+           solver.status() == SPxSolverBase<R>::ABORT_EXDECOMP)));
+
+  // if simplifier is active and LP is solved in presolving or to optimality,
+  // then we unsimplify to get the basis
+  if (_simplifier != 0) {
+    assert(!_simplifier->isUnsimplified());
+
+    bool vanished = result == SPxSimplifier<R>::VANISHED;
+
+    // get solution vectors for transformed problem
+    VectorBase<R> primal(vanished ? 0 : solver.nCols());
+    VectorBase<R> slacks(vanished ? 0 : solver.nRows());
+    VectorBase<R> dual(vanished ? 0 : solver.nRows());
+    VectorBase<R> redCost(vanished ? 0 : solver.nCols());
+
+    assert(!_isRealLPLoaded);
+    _basisStatusRows.reSize(_decompLP->nRows());
+    _basisStatusCols.reSize(_decompLP->nCols());
+    assert(vanished || _basisStatusRows.size() >= solver.nRows());
+    assert(vanished || _basisStatusCols.size() >= solver.nCols());
+
+    if (!vanished) {
+      assert(solver.status() == SPxSolverBase<R>::OPTIMAL ||
+             solver.status() == SPxSolverBase<R>::ABORT_DECOMP ||
+             solver.status() == SPxSolverBase<R>::ABORT_EXDECOMP);
+
+      solver.getPrimalSol(primal);
+      solver.getSlacks(slacks);
+      solver.getDualSol(dual);
+      solver.getRedCostSol(redCost);
+
+      // unscale vectors
+      if (_scaler && solver.isScaled()) {
+        _scaler->unscalePrimal(solver, primal);
+        _scaler->unscaleSlacks(solver, slacks);
+        _scaler->unscaleDual(solver, dual);
+        _scaler->unscaleRedCost(solver, redCost);
       }
 
-      try
-      {
-         _simplifier->unsimplify(primal, dual, slacks, redCost, _basisStatusRows.get_ptr(),
-                                 _basisStatusCols.get_ptr(), solver.status() == SPxSolverBase<R>::OPTIMAL);
-         _simplifier->getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr());
-         _hasBasis = true;
-      }
-      catch(const SPxException& E)
-      {
-         MSG_ERROR(spxout << "Caught exception <" << E.what() <<
-                   "> during unsimplification. Resolving without simplifier and scaler.\n");
-      }
-      catch(...)
-      {
-         MSG_ERROR(spxout <<
-                   "Caught unknown exception during unsimplification. Resolving without simplifier and scaler.\n");
-         _status = SPxSolverBase<R>::ERROR;
-      }
-   }
-   // if the original problem is not in the solver because of scaling, we also need to store the basis
-   else if(_scaler != nullptr)
-   {
-      _basisStatusRows.reSize(numRows());
-      _basisStatusCols.reSize(numCols());
-      assert(_basisStatusRows.size() == solver.nRows());
-      assert(_basisStatusCols.size() == solver.nCols());
-
+      // get basis of transformed problem
       solver.getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr());
+    }
+
+    try {
+      _simplifier->unsimplify(primal, dual, slacks, redCost,
+                              _basisStatusRows.get_ptr(),
+                              _basisStatusCols.get_ptr(),
+                              solver.status() == SPxSolverBase<R>::OPTIMAL);
+      _simplifier->getBasis(_basisStatusRows.get_ptr(),
+                            _basisStatusCols.get_ptr());
       _hasBasis = true;
-   }
-
-   // resolve the original problem
-   _decompSimplifyAndSolve(solver, sluFactor, false, false);
-   return;
+    } catch (const SPxException &E) {
+      MSG_ERROR(spxout << "Caught exception <" << E.what()
+                       << "> during unsimplification. Resolving without "
+                          "simplifier and scaler.\n");
+    } catch (...) {
+      MSG_ERROR(spxout << "Caught unknown exception during unsimplification. "
+                          "Resolving without simplifier and scaler.\n");
+      _status = SPxSolverBase<R>::ERROR;
+    }
+  }
+  // if the original problem is not in the solver because of scaling, we also
+  // need to store the basis
+  else if (_scaler != nullptr) {
+    _basisStatusRows.reSize(numRows());
+    _basisStatusCols.reSize(numCols());
+    assert(_basisStatusRows.size() == solver.nRows());
+    assert(_basisStatusCols.size() == solver.nCols());
+
+    solver.getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr());
+    _hasBasis = true;
+  }
+
+  // resolve the original problem
+  _decompSimplifyAndSolve(solver, sluFactor, false, false);
+  return;
 }
 
-
-/// updates the reduced problem with additional rows using the solution to the complementary problem
+/// updates the reduced problem with additional rows using the solution to the
+/// complementary problem
 template <class R>
-void SoPlexBase<R>::_updateDecompReducedProblem(R objValue, VectorBase<R> dualVector,
-      VectorBase<R> redcostVector,
-      VectorBase<R> compPrimalVector, VectorBase<R> compDualVector)
-{
-   R feastol = realParam(SoPlexBase<R>::FEASTOL);
-
-   R maxDualRatio = R(infinity);
-
-   bool usecompdual = boolParam(SoPlexBase<R>::USECOMPDUAL);
-
-   for(int i = 0; i < _nPrimalRows; i++)
-   {
-      R reducedProbDual = 0;
-      R compProbPrimal = 0;
-      R dualRatio = 0;
-      int rownumber = _realLP->number(SPxRowId(_decompPrimalRowIDs[i]));
-
-      if(_decompReducedProbRows[rownumber] && _solver.isBasic(_decompReducedProbRowIDs[rownumber]))
-      {
-         int solverRowNum = _solver.number(_decompReducedProbRowIDs[rownumber]);
-
-         // retreiving the reduced problem dual solutions and the complementary problem primal solutions
-         reducedProbDual = dualVector[solverRowNum]; // this is y
-
-         if(usecompdual)
-            compProbPrimal = compPrimalVector[_compSolver.number(SPxColId(_decompDualColIDs[i]))]; // this is u
-         else
-            compProbPrimal = compDualVector[_compSolver.number(SPxRowId(_decompCompPrimalRowIDs[i]))];
-
-         // the variable in the basis is degenerate.
-         if(EQ(reducedProbDual, R(0.0), feastol))
-         {
-            MSG_WARNING(spxout,
-                        spxout << "WIMDSM01: reduced problem dual value is very close to zero." << std::endl;);
-            continue;
-         }
-
-         // the translation of the complementary primal problem to the dual some rows resulted in two columns.
-         if(usecompdual && i < _nPrimalRows - 1 &&
-               _realLP->number(SPxRowId(_decompPrimalRowIDs[i])) == _realLP->number(SPxRowId(
-                        _decompPrimalRowIDs[i + 1])))
-         {
-            i++;
-            compProbPrimal += compPrimalVector[_compSolver.number(SPxColId(_decompDualColIDs[i]))]; // this is u
-         }
-
-
-
-         // updating the ratio
-         SoPlexBase<R>::DualSign varSign = getExpectedDualVariableSign(solverRowNum);
-
-         if(varSign == SoPlexBase<R>::IS_FREE || (varSign == SoPlexBase<R>::IS_POS
-               && LE(compProbPrimal, (R)0, feastol)) ||
-               (varSign == SoPlexBase<R>::IS_NEG && GE(compProbPrimal, (R)0, feastol)))
-         {
-            dualRatio = R(infinity);
-         }
-         else
-         {
-            dualRatio = reducedProbDual / compProbPrimal;
-         }
-
-         if(LT(dualRatio, maxDualRatio, feastol))
-            maxDualRatio = dualRatio;
-      }
+void SoPlexBase<R>::_updateDecompReducedProblem(R objValue,
+                                                VectorBase<R> dualVector,
+                                                VectorBase<R> redcostVector,
+                                                VectorBase<R> compPrimalVector,
+                                                VectorBase<R> compDualVector) {
+  R feastol = realParam(SoPlexBase<R>::FEASTOL);
+
+  R maxDualRatio = R(infinity);
+
+  bool usecompdual = boolParam(SoPlexBase<R>::USECOMPDUAL);
+
+  for (int i = 0; i < _nPrimalRows; i++) {
+    R reducedProbDual = 0;
+    R compProbPrimal = 0;
+    R dualRatio = 0;
+    int rownumber = _realLP->number(SPxRowId(_decompPrimalRowIDs[i]));
+
+    if (_decompReducedProbRows[rownumber] &&
+        _solver.isBasic(_decompReducedProbRowIDs[rownumber])) {
+      int solverRowNum = _solver.number(_decompReducedProbRowIDs[rownumber]);
+
+      // retreiving the reduced problem dual solutions and the complementary
+      // problem primal solutions
+      reducedProbDual = dualVector[solverRowNum]; // this is y
+
+      if (usecompdual)
+        compProbPrimal = compPrimalVector[_compSolver.number(
+            SPxColId(_decompDualColIDs[i]))]; // this is u
       else
-      {
-         if(usecompdual)
-            compProbPrimal = compPrimalVector[_compSolver.number(SPxColId(_decompDualColIDs[i]))]; // this is v
-         else
-            compProbPrimal = compDualVector[_compSolver.number(SPxRowId(_decompCompPrimalRowIDs[i]))];
+        compProbPrimal = compDualVector[_compSolver.number(
+            SPxRowId(_decompCompPrimalRowIDs[i]))];
+
+      // the variable in the basis is degenerate.
+      if (EQ(reducedProbDual, R(0.0), feastol)) {
+        MSG_WARNING(
+            spxout,
+            spxout
+                << "WIMDSM01: reduced problem dual value is very close to zero."
+                << std::endl;);
+        continue;
       }
 
-   }
-
-   // setting the maxDualRatio to a maximum of 1
-   if(maxDualRatio > 1.0)
-      maxDualRatio = 1.0;
-
-   VectorBase<R> compProbRedcost(
-      _compSolver.nCols());   // the reduced costs of the complementary problem
-
-   // Retrieving the reduced costs for each original problem row.
-   _compSolver.getRedCostSol(compProbRedcost);
-
-   LPRowSetBase<R> updaterows;
-
-
-   // Identifying the violated rows
-   Array<RowViolation> violatedrows;
-   int nviolatedrows = 0;
-   int* newrowidx = 0;
-   int nnewrowidx = 0;
-   spx_alloc(newrowidx, _nPrimalRows);
-
-   violatedrows.reSize(_nPrimalRows);
-
-   bool ratioTest = true;
-
-   //ratioTest = false;
-   for(int i = 0; i < _nPrimalRows; i++)
-   {
-      LPRowBase<R> origlprow;
-      DSVectorBase<R> rowtoaddVec(_realLP->nCols());
-      R compProbPrimal = 0;
-      R compRowRedcost = 0;
-      int rownumber = _realLP->number(SPxRowId(_decompPrimalRowIDs[i]));
-
-      if(!_decompReducedProbRows[_realLP->number(SPxRowId(_decompPrimalRowIDs[i]))])
-      {
-         int compRowNumber;
-
-         if(usecompdual)
-         {
-            compRowNumber = _compSolver.number(_decompDualColIDs[i]);
-            // retreiving the complementary problem primal solutions
-            compProbPrimal = compPrimalVector[compRowNumber]; // this is v
-            compRowRedcost = compProbRedcost[compRowNumber];
-         }
-         else
-         {
-            compRowNumber = _compSolver.number(_decompCompPrimalRowIDs[i]);
-            // retreiving the complementary problem primal solutions
-            compProbPrimal = compDualVector[compRowNumber]; // this is v
-         }
-
-         // the translation of the complementary primal problem to the dual some rows resulted in two columns.
-         if(usecompdual && i < _nPrimalRows - 1 &&
-               _realLP->number(SPxRowId(_decompPrimalRowIDs[i])) == _realLP->number(SPxRowId(
-                        _decompPrimalRowIDs[i + 1])))
-         {
-            i++;
-            compRowNumber = _compSolver.number(SPxColId(_decompDualColIDs[i]));
-            compProbPrimal += compPrimalVector[compRowNumber]; // this is v
-            compRowRedcost += compProbRedcost[compRowNumber];
-         }
-
-         SoPlexBase<R>::DualSign varSign = getOrigProbDualVariableSign(rownumber);
-
-         // add row to the reduced problem if the computed dual is of the correct sign for a feasible dual solution
-         if(ratioTest && ((varSign == SoPlexBase<R>::IS_FREE && !isZero(compProbPrimal, feastol)) ||
-                          (varSign == SoPlexBase<R>::IS_POS && GT(compProbPrimal * maxDualRatio, (R) 0, feastol)) ||
-                          (varSign == SoPlexBase<R>::IS_NEG && LT(compProbPrimal * maxDualRatio, (R) 0, feastol))))
-         {
-            //this set of statements are required to add rows to the reduced problem. This will add a row for every
-            //violated constraint. I only want to add a row for the most violated constraint. That is why the row
-            //adding functionality is put outside the for loop.
-            if(!_decompReducedProbRows[rownumber])
-            {
-               numIncludedRows++;
-               assert(numIncludedRows <= _realLP->nRows());
-            }
-
-            violatedrows[nviolatedrows].idx = rownumber;
-            violatedrows[nviolatedrows].violation = spxAbs(compProbPrimal * maxDualRatio);
-            nviolatedrows++;
-         }
+      // the translation of the complementary primal problem to the dual some
+      // rows resulted in two columns.
+      if (usecompdual && i < _nPrimalRows - 1 &&
+          _realLP->number(SPxRowId(_decompPrimalRowIDs[i])) ==
+              _realLP->number(SPxRowId(_decompPrimalRowIDs[i + 1]))) {
+        i++;
+        compProbPrimal += compPrimalVector[_compSolver.number(
+            SPxColId(_decompDualColIDs[i]))]; // this is u
       }
-   }
-
-
-   // sorting the violated rows by the absolute violation.
-   // Only a predefined number of rows will be added to the reduced problem
-   RowViolationCompare compare;
-   compare.entry = violatedrows.get_const_ptr();
-
-   // if no rows are identified by the pricing rule, we add rows based upon the constraint violations
-   if(!ratioTest || nviolatedrows == 0)
-   {
-      _findViolatedRows(objValue, violatedrows, nviolatedrows);
-   }
-
-   int sorted = 0;
-   int sortsize = MINIMUM(intParam(SoPlexBase<R>::DECOMP_MAXADDEDROWS), nviolatedrows);
 
-   // only sorting if the sort size is less than the number of violated rows.
-   if(sortsize > 0 && sortsize < nviolatedrows)
-      sorted = SPxQuicksortPart(violatedrows.get_ptr(), compare, sorted + 1, nviolatedrows, sortsize);
-
-   // adding the violated rows.
-   for(int i = 0; i < sortsize; i++)
-   {
-      updaterows.add(_transformedRows.lhs(violatedrows[i].idx),
-                     _transformedRows.rowVector(violatedrows[i].idx),
-                     _transformedRows.rhs(violatedrows[i].idx));
-
-      _decompReducedProbRows[violatedrows[i].idx] = true;
-      newrowidx[nnewrowidx] = violatedrows[i].idx;
-      nnewrowidx++;
-   }
+      // updating the ratio
+      SoPlexBase<R>::DualSign varSign =
+          getExpectedDualVariableSign(solverRowNum);
+
+      if (varSign == SoPlexBase<R>::IS_FREE ||
+          (varSign == SoPlexBase<R>::IS_POS &&
+           LE(compProbPrimal, (R)0, feastol)) ||
+          (varSign == SoPlexBase<R>::IS_NEG &&
+           GE(compProbPrimal, (R)0, feastol))) {
+        dualRatio = R(infinity);
+      } else {
+        dualRatio = reducedProbDual / compProbPrimal;
+      }
 
-   SPxRowId* addedrowids = 0;
-   spx_alloc(addedrowids, nnewrowidx);
-   _solver.addRows(addedrowids, updaterows);
+      if (LT(dualRatio, maxDualRatio, feastol))
+        maxDualRatio = dualRatio;
+    } else {
+      if (usecompdual)
+        compProbPrimal = compPrimalVector[_compSolver.number(
+            SPxColId(_decompDualColIDs[i]))]; // this is v
+      else
+        compProbPrimal = compDualVector[_compSolver.number(
+            SPxRowId(_decompCompPrimalRowIDs[i]))];
+    }
+  }
+
+  // setting the maxDualRatio to a maximum of 1
+  if (maxDualRatio > 1.0)
+    maxDualRatio = 1.0;
+
+  VectorBase<R> compProbRedcost(
+      _compSolver.nCols()); // the reduced costs of the complementary problem
+
+  // Retrieving the reduced costs for each original problem row.
+  _compSolver.getRedCostSol(compProbRedcost);
+
+  LPRowSetBase<R> updaterows;
+
+  // Identifying the violated rows
+  Array<RowViolation> violatedrows;
+  int nviolatedrows = 0;
+  int *newrowidx = 0;
+  int nnewrowidx = 0;
+  spx_alloc(newrowidx, _nPrimalRows);
+
+  violatedrows.reSize(_nPrimalRows);
+
+  bool ratioTest = true;
+
+  // ratioTest = false;
+  for (int i = 0; i < _nPrimalRows; i++) {
+    LPRowBase<R> origlprow;
+    DSVectorBase<R> rowtoaddVec(_realLP->nCols());
+    R compProbPrimal = 0;
+    R compRowRedcost = 0;
+    int rownumber = _realLP->number(SPxRowId(_decompPrimalRowIDs[i]));
+
+    if (!_decompReducedProbRows[_realLP->number(
+            SPxRowId(_decompPrimalRowIDs[i]))]) {
+      int compRowNumber;
+
+      if (usecompdual) {
+        compRowNumber = _compSolver.number(_decompDualColIDs[i]);
+        // retreiving the complementary problem primal solutions
+        compProbPrimal = compPrimalVector[compRowNumber]; // this is v
+        compRowRedcost = compProbRedcost[compRowNumber];
+      } else {
+        compRowNumber = _compSolver.number(_decompCompPrimalRowIDs[i]);
+        // retreiving the complementary problem primal solutions
+        compProbPrimal = compDualVector[compRowNumber]; // this is v
+      }
 
-   for(int i = 0; i < nnewrowidx; i++)
-      _decompReducedProbRowIDs[newrowidx[i]] = addedrowids[i];
+      // the translation of the complementary primal problem to the dual some
+      // rows resulted in two columns.
+      if (usecompdual && i < _nPrimalRows - 1 &&
+          _realLP->number(SPxRowId(_decompPrimalRowIDs[i])) ==
+              _realLP->number(SPxRowId(_decompPrimalRowIDs[i + 1]))) {
+        i++;
+        compRowNumber = _compSolver.number(SPxColId(_decompDualColIDs[i]));
+        compProbPrimal += compPrimalVector[compRowNumber]; // this is v
+        compRowRedcost += compProbRedcost[compRowNumber];
+      }
 
-   // freeing allocated memory
-   spx_free(addedrowids);
-   spx_free(newrowidx);
+      SoPlexBase<R>::DualSign varSign = getOrigProbDualVariableSign(rownumber);
+
+      // add row to the reduced problem if the computed dual is of the correct
+      // sign for a feasible dual solution
+      if (ratioTest && ((varSign == SoPlexBase<R>::IS_FREE &&
+                         !isZero(compProbPrimal, feastol)) ||
+                        (varSign == SoPlexBase<R>::IS_POS &&
+                         GT(compProbPrimal * maxDualRatio, (R)0, feastol)) ||
+                        (varSign == SoPlexBase<R>::IS_NEG &&
+                         LT(compProbPrimal * maxDualRatio, (R)0, feastol)))) {
+        // this set of statements are required to add rows to the reduced
+        // problem. This will add a row for every violated constraint. I only
+        // want to add a row for the most violated constraint. That is why the
+        // row adding functionality is put outside the for loop.
+        if (!_decompReducedProbRows[rownumber]) {
+          numIncludedRows++;
+          assert(numIncludedRows <= _realLP->nRows());
+        }
+
+        violatedrows[nviolatedrows].idx = rownumber;
+        violatedrows[nviolatedrows].violation =
+            spxAbs(compProbPrimal * maxDualRatio);
+        nviolatedrows++;
+      }
+    }
+  }
+
+  // sorting the violated rows by the absolute violation.
+  // Only a predefined number of rows will be added to the reduced problem
+  RowViolationCompare compare;
+  compare.entry = violatedrows.get_const_ptr();
+
+  // if no rows are identified by the pricing rule, we add rows based upon the
+  // constraint violations
+  if (!ratioTest || nviolatedrows == 0) {
+    _findViolatedRows(objValue, violatedrows, nviolatedrows);
+  }
+
+  int sorted = 0;
+  int sortsize =
+      MINIMUM(intParam(SoPlexBase<R>::DECOMP_MAXADDEDROWS), nviolatedrows);
+
+  // only sorting if the sort size is less than the number of violated rows.
+  if (sortsize > 0 && sortsize < nviolatedrows)
+    sorted = SPxQuicksortPart(violatedrows.get_ptr(), compare, sorted + 1,
+                              nviolatedrows, sortsize);
+
+  // adding the violated rows.
+  for (int i = 0; i < sortsize; i++) {
+    updaterows.add(_transformedRows.lhs(violatedrows[i].idx),
+                   _transformedRows.rowVector(violatedrows[i].idx),
+                   _transformedRows.rhs(violatedrows[i].idx));
+
+    _decompReducedProbRows[violatedrows[i].idx] = true;
+    newrowidx[nnewrowidx] = violatedrows[i].idx;
+    nnewrowidx++;
+  }
+
+  SPxRowId *addedrowids = 0;
+  spx_alloc(addedrowids, nnewrowidx);
+  _solver.addRows(addedrowids, updaterows);
+
+  for (int i = 0; i < nnewrowidx; i++)
+    _decompReducedProbRowIDs[newrowidx[i]] = addedrowids[i];
+
+  // freeing allocated memory
+  spx_free(addedrowids);
+  spx_free(newrowidx);
 }
 
-
-
-/// update the reduced problem with additional columns and rows based upon the violated original bounds and rows
-// TODO: Allow for the case that no rows are added. This should terminate the algorithm.
-// TODO: Check to make sure that only rows added to the problem do not currently exist in the reduced problem.
+/// update the reduced problem with additional columns and rows based upon the
+/// violated original bounds and rows
+// TODO: Allow for the case that no rows are added. This should terminate the
+// algorithm.
+// TODO: Check to make sure that only rows added to the problem do not currently
+// exist in the reduced problem.
 template <class R>
-void SoPlexBase<R>::_updateDecompReducedProblemViol(bool allrows)
-{
+void SoPlexBase<R>::_updateDecompReducedProblemViol(bool allrows) {
 #ifdef NO_TOL
-   R feastol = 0.0;
+  R feastol = 0.0;
 #else
 #ifdef USE_FEASTOL
-   R feastol = realParam(SoPlexBase<R>::FEASTOL);
+  R feastol = realParam(SoPlexBase<R>::FEASTOL);
 #else
-   R feastol = realParam(SoPlexBase<R>::EPSILON_ZERO);
+  R feastol = realParam(SoPlexBase<R>::EPSILON_ZERO);
 #endif
 #endif
-   LPRowSetBase<R> updaterows;
+  LPRowSetBase<R> updaterows;
 
-   int* newrowidx = 0;
-   int nnewrowidx = 0;
-   spx_alloc(newrowidx, _nPrimalRows);
+  int *newrowidx = 0;
+  int nnewrowidx = 0;
+  spx_alloc(newrowidx, _nPrimalRows);
 
-   int rowNumber;
-   int bestrow = -1;
-   R bestrownorm = R(infinity);
-   R percenttoadd = 1;
+  int rowNumber;
+  int bestrow = -1;
+  R bestrownorm = R(infinity);
+  R percenttoadd = 1;
 
-   int nrowstoadd = MINIMUM(intParam(SoPlexBase<R>::DECOMP_MAXADDEDROWS), _nDecompViolRows);
+  int nrowstoadd =
+      MINIMUM(intParam(SoPlexBase<R>::DECOMP_MAXADDEDROWS), _nDecompViolRows);
 
-   if(allrows)
-      nrowstoadd = _nDecompViolRows;   // adding all violated rows
+  if (allrows)
+    nrowstoadd = _nDecompViolRows; // adding all violated rows
 
-   SSVectorBase<R>  y(_solver.nCols());
-   y.unSetup();
+  SSVectorBase<R> y(_solver.nCols());
+  y.unSetup();
 
-   // identifying the rows not included in the reduced problem that are violated by the current solution.
-   for(int i = 0; i < nrowstoadd; i++)
-   {
-      rowNumber = _decompViolatedRows[i];
+  // identifying the rows not included in the reduced problem that are violated
+  // by the current solution.
+  for (int i = 0; i < nrowstoadd; i++) {
+    rowNumber = _decompViolatedRows[i];
 
-      if(!allrows)
-      {
-         R norm = 0;
-
-         // the rhs of this calculation are the rows of the constraint matrix
-         // so we are solving y B = A_{i,.}
-         try
-         {
-            _solver.basis().solve(y, _solver.vector(rowNumber));
-         }
-         catch(const SPxException& E)
-         {
-            MSG_ERROR(spxout << "Caught exception <" << E.what() << "> while computing compatability.\n");
-         }
-
-
-         // comparing the constraints based upon the row norm
-         if(y.isSetup())
-         {
-            for(int j = 0; j < y.size(); j++)
-            {
-               if(isZero(_solver.fVec()[i], feastol))
-                  norm += spxAbs(y.value(j)) * spxAbs(y.value(j));
-            }
-         }
-         else
-         {
-            for(int j = 0; j < numCols(); j++)
-            {
-               if(isZero(_solver.fVec()[i], feastol))
-                  norm += spxAbs(y[j]) * spxAbs(y[j]);
-            }
-         }
-
-
-         // the best row is based upon the row norm
-         // the best row is added if no violated row is found
-         norm = soplex::spxSqrt(norm);
-
-         if(LT(norm, bestrownorm))
-         {
-            bestrow = rowNumber;
-            bestrownorm = norm;
-         }
-
-
-         // adding the violated row
-         if(isZero(norm, feastol) && LT(nnewrowidx / R(numRows()), percenttoadd))
-         {
-            updaterows.add(_transformedRows.lhs(rowNumber), _transformedRows.rowVector(rowNumber),
-                           _transformedRows.rhs(rowNumber));
-
-            _decompReducedProbRows[rowNumber] = true;
-            newrowidx[nnewrowidx] = rowNumber;
-            nnewrowidx++;
-         }
+    if (!allrows) {
+      R norm = 0;
 
+      // the rhs of this calculation are the rows of the constraint matrix
+      // so we are solving y B = A_{i,.}
+      try {
+        _solver.basis().solve(y, _solver.vector(rowNumber));
+      } catch (const SPxException &E) {
+        MSG_ERROR(spxout << "Caught exception <" << E.what()
+                         << "> while computing compatability.\n");
       }
-      else
-      {
-         // adding all violated rows
-         updaterows.add(_transformedRows.lhs(rowNumber), _transformedRows.rowVector(rowNumber),
-                        _transformedRows.rhs(rowNumber));
 
-         _decompReducedProbRows[rowNumber] = true;
-         newrowidx[nnewrowidx] = rowNumber;
-         nnewrowidx++;
+      // comparing the constraints based upon the row norm
+      if (y.isSetup()) {
+        for (int j = 0; j < y.size(); j++) {
+          if (isZero(_solver.fVec()[i], feastol))
+            norm += spxAbs(y.value(j)) * spxAbs(y.value(j));
+        }
+      } else {
+        for (int j = 0; j < numCols(); j++) {
+          if (isZero(_solver.fVec()[i], feastol))
+            norm += spxAbs(y[j]) * spxAbs(y[j]);
+        }
       }
-   }
 
-   // if no violated row is found during the first pass of the available rows, then we add all violated rows.
-   if(nnewrowidx == 0)
-   {
-      for(int i = 0; i < nrowstoadd; i++)
-      {
-         rowNumber = _decompViolatedRows[i];
+      // the best row is based upon the row norm
+      // the best row is added if no violated row is found
+      norm = soplex::spxSqrt(norm);
 
-         updaterows.add(_transformedRows.lhs(rowNumber), _transformedRows.rowVector(rowNumber),
-                        _transformedRows.rhs(rowNumber));
+      if (LT(norm, bestrownorm)) {
+        bestrow = rowNumber;
+        bestrownorm = norm;
+      }
+
+      // adding the violated row
+      if (isZero(norm, feastol) &&
+          LT(nnewrowidx / R(numRows()), percenttoadd)) {
+        updaterows.add(_transformedRows.lhs(rowNumber),
+                       _transformedRows.rowVector(rowNumber),
+                       _transformedRows.rhs(rowNumber));
 
-         _decompReducedProbRows[rowNumber] = true;
-         newrowidx[nnewrowidx] = rowNumber;
-         nnewrowidx++;
+        _decompReducedProbRows[rowNumber] = true;
+        newrowidx[nnewrowidx] = rowNumber;
+        nnewrowidx++;
       }
-   }
 
-   // we will always add the row that is deemed best based upon the row norm.
-   // TODO: check whether this should be skipped if a row has already been added.
-   if(!allrows && bestrow >= 0)
-   {
-      updaterows.add(_transformedRows.lhs(bestrow), _transformedRows.rowVector(bestrow),
-                     _transformedRows.rhs(bestrow));
+    } else {
+      // adding all violated rows
+      updaterows.add(_transformedRows.lhs(rowNumber),
+                     _transformedRows.rowVector(rowNumber),
+                     _transformedRows.rhs(rowNumber));
 
-      _decompReducedProbRows[bestrow] = true;
-      newrowidx[nnewrowidx] = bestrow;
+      _decompReducedProbRows[rowNumber] = true;
+      newrowidx[nnewrowidx] = rowNumber;
       nnewrowidx++;
-   }
-
+    }
+  }
 
-   SPxRowId* addedrowids = 0;
-   spx_alloc(addedrowids, nnewrowidx);
-   _solver.addRows(addedrowids, updaterows);
+  // if no violated row is found during the first pass of the available rows,
+  // then we add all violated rows.
+  if (nnewrowidx == 0) {
+    for (int i = 0; i < nrowstoadd; i++) {
+      rowNumber = _decompViolatedRows[i];
 
-   for(int i = 0; i < nnewrowidx; i++)
-      _decompReducedProbRowIDs[newrowidx[i]] = addedrowids[i];
+      updaterows.add(_transformedRows.lhs(rowNumber),
+                     _transformedRows.rowVector(rowNumber),
+                     _transformedRows.rhs(rowNumber));
 
-   // freeing allocated memory
-   spx_free(addedrowids);
-   spx_free(newrowidx);
+      _decompReducedProbRows[rowNumber] = true;
+      newrowidx[nnewrowidx] = rowNumber;
+      nnewrowidx++;
+    }
+  }
+
+  // we will always add the row that is deemed best based upon the row norm.
+  // TODO: check whether this should be skipped if a row has already been added.
+  if (!allrows && bestrow >= 0) {
+    updaterows.add(_transformedRows.lhs(bestrow),
+                   _transformedRows.rowVector(bestrow),
+                   _transformedRows.rhs(bestrow));
+
+    _decompReducedProbRows[bestrow] = true;
+    newrowidx[nnewrowidx] = bestrow;
+    nnewrowidx++;
+  }
+
+  SPxRowId *addedrowids = 0;
+  spx_alloc(addedrowids, nnewrowidx);
+  _solver.addRows(addedrowids, updaterows);
+
+  for (int i = 0; i < nnewrowidx; i++)
+    _decompReducedProbRowIDs[newrowidx[i]] = addedrowids[i];
+
+  // freeing allocated memory
+  spx_free(addedrowids);
+  spx_free(newrowidx);
 }
 
-
-
 /// builds the update rows with those violated in the complmentary problem
 // A row is violated in the constraint matrix Ax <= b, if b - A_{i}x < 0
 // To aid the computation, all violations are translated to <= constraints
 template <class R>
-void SoPlexBase<R>::_findViolatedRows(R compObjValue, Array<RowViolation>& violatedrows,
-                                      int& nviolatedrows)
-{
-   R feastol = realParam(SoPlexBase<R>::FEASTOL);
-   VectorBase<R> compProbRedcost(
-      _compSolver.nCols());   // the reduced costs of the complementary problem
-   VectorBase<R> compProbPrimal(
-      _compSolver.nCols());    // the primal vector of the complementary problem
-   VectorBase<R> compProbActivity(
-      _compSolver.nRows());  // the activity vector of the complementary problem
-   R compProbSlackVal = 0;
-
-   if(boolParam(SoPlexBase<R>::USECOMPDUAL))
-   {
-      // Retrieving the slacks for each row.
-      _compSolver.getRedCostSol(compProbRedcost);
-   }
-   else
-   {
-      // Retrieving the primal vector for the complementary problem
-      _compSolver.getPrimalSol(compProbPrimal);
-      _compSolver.computePrimalActivity(compProbPrimal, compProbActivity);
-
-      compProbSlackVal = compProbPrimal[_compSolver.number(_compSlackColId)];
-   }
-
-   // scanning all rows of the complementary problem for violations.
-   for(int i = 0; i < _nPrimalRows; i++)
-   {
-      LPRowBase<R> origlprow;
-      DSVectorBase<R> rowtoaddVec(_realLP->nCols());
-      R compProbViol = 0;
-      R compSlackCoeff = 0;
-      int rownumber = _realLP->number(SPxRowId(_decompPrimalRowIDs[i]));
-      int comprownum = _compSolver.number(SPxRowId(_decompPrimalRowIDs[i]));
+void SoPlexBase<R>::_findViolatedRows(R compObjValue,
+                                      Array<RowViolation> &violatedrows,
+                                      int &nviolatedrows) {
+  R feastol = realParam(SoPlexBase<R>::FEASTOL);
+  VectorBase<R> compProbRedcost(
+      _compSolver.nCols()); // the reduced costs of the complementary problem
+  VectorBase<R> compProbPrimal(
+      _compSolver.nCols()); // the primal vector of the complementary problem
+  VectorBase<R> compProbActivity(
+      _compSolver.nRows()); // the activity vector of the complementary problem
+  R compProbSlackVal = 0;
+
+  if (boolParam(SoPlexBase<R>::USECOMPDUAL)) {
+    // Retrieving the slacks for each row.
+    _compSolver.getRedCostSol(compProbRedcost);
+  } else {
+    // Retrieving the primal vector for the complementary problem
+    _compSolver.getPrimalSol(compProbPrimal);
+    _compSolver.computePrimalActivity(compProbPrimal, compProbActivity);
+
+    compProbSlackVal = compProbPrimal[_compSolver.number(_compSlackColId)];
+  }
+
+  // scanning all rows of the complementary problem for violations.
+  for (int i = 0; i < _nPrimalRows; i++) {
+    LPRowBase<R> origlprow;
+    DSVectorBase<R> rowtoaddVec(_realLP->nCols());
+    R compProbViol = 0;
+    R compSlackCoeff = 0;
+    int rownumber = _realLP->number(SPxRowId(_decompPrimalRowIDs[i]));
+    int comprownum = _compSolver.number(SPxRowId(_decompPrimalRowIDs[i]));
+
+    if (!_decompReducedProbRows[rownumber]) {
+      // retreiving the violation of the complementary problem primal
+      // constraints
+      if (boolParam(SoPlexBase<R>::USECOMPDUAL)) {
+        compSlackCoeff = getCompSlackVarCoeff(i);
+        compProbViol = compProbRedcost[_compSolver.number(
+            SPxColId(_decompDualColIDs[i]))]; // this is b - Ax
+        // subtracting the slack variable value
+        compProbViol += compObjValue *
+                        compSlackCoeff; // must add on the slack variable value.
+        compProbViol *=
+            compSlackCoeff; // translating the violation to a <= constraint
+      } else {
+        R viol = _compSolver.rhs(comprownum) -
+                 (compProbActivity[comprownum] + compProbSlackVal);
+
+        if (viol < 0.0)
+          compProbViol = viol;
+
+        viol = (compProbActivity[comprownum] - compProbSlackVal) -
+               _compSolver.lhs(comprownum);
+
+        if (viol < 0.0)
+          compProbViol = viol;
+      }
 
-      if(!_decompReducedProbRows[rownumber])
-      {
-         // retreiving the violation of the complementary problem primal constraints
-         if(boolParam(SoPlexBase<R>::USECOMPDUAL))
-         {
-            compSlackCoeff = getCompSlackVarCoeff(i);
-            compProbViol = compProbRedcost[_compSolver.number(SPxColId(
-                                              _decompDualColIDs[i]))]; // this is b - Ax
-            // subtracting the slack variable value
-            compProbViol += compObjValue * compSlackCoeff; // must add on the slack variable value.
-            compProbViol *= compSlackCoeff;  // translating the violation to a <= constraint
-         }
-         else
-         {
-            R viol = _compSolver.rhs(comprownum) - (compProbActivity[comprownum] + compProbSlackVal);
-
-            if(viol < 0.0)
-               compProbViol = viol;
-
-            viol = (compProbActivity[comprownum] - compProbSlackVal) - _compSolver.lhs(comprownum);
-
-            if(viol < 0.0)
-               compProbViol = viol;
-
-         }
-
-         // NOTE: if the row was originally a ranged constraint, we are only interest in one of the inequalities.
-         // If one inequality of the range violates the bounds, then we will add the row.
-
-         // the translation of the complementary primal problem to the dual some rows resulted in two columns.
-         if(boolParam(SoPlexBase<R>::USECOMPDUAL) && i < _nPrimalRows - 1 &&
-               _realLP->number(SPxRowId(_decompPrimalRowIDs[i])) == _realLP->number(SPxRowId(
-                        _decompPrimalRowIDs[i + 1])))
-         {
-            i++;
-            compSlackCoeff = getCompSlackVarCoeff(i);
-            R tempViol = compProbRedcost[_compSolver.number(SPxColId(_decompDualColIDs[i]))]; // this is b - Ax
-            tempViol += compObjValue * compSlackCoeff;
-            tempViol *= compSlackCoeff;
-
-            // if the other side of the range constraint has a larger violation, then this is used for the
-            // computation.
-            if(tempViol < compProbViol)
-               compProbViol = tempViol;
-         }
-
-
-         // checking the violation of the row.
-         if(LT(compProbViol, (R) 0, feastol))
-         {
-            if(!_decompReducedProbRows[rownumber])
-            {
-               numIncludedRows++;
-               assert(numIncludedRows <= _realLP->nRows());
-            }
-
-            violatedrows[nviolatedrows].idx = rownumber;
-            violatedrows[nviolatedrows].violation = spxAbs(compProbViol);
-            nviolatedrows++;
-         }
+      // NOTE: if the row was originally a ranged constraint, we are only
+      // interest in one of the inequalities. If one inequality of the range
+      // violates the bounds, then we will add the row.
+
+      // the translation of the complementary primal problem to the dual some
+      // rows resulted in two columns.
+      if (boolParam(SoPlexBase<R>::USECOMPDUAL) && i < _nPrimalRows - 1 &&
+          _realLP->number(SPxRowId(_decompPrimalRowIDs[i])) ==
+              _realLP->number(SPxRowId(_decompPrimalRowIDs[i + 1]))) {
+        i++;
+        compSlackCoeff = getCompSlackVarCoeff(i);
+        R tempViol = compProbRedcost[_compSolver.number(
+            SPxColId(_decompDualColIDs[i]))]; // this is b - Ax
+        tempViol += compObjValue * compSlackCoeff;
+        tempViol *= compSlackCoeff;
+
+        // if the other side of the range constraint has a larger violation,
+        // then this is used for the computation.
+        if (tempViol < compProbViol)
+          compProbViol = tempViol;
       }
-   }
-}
 
+      // checking the violation of the row.
+      if (LT(compProbViol, (R)0, feastol)) {
+        if (!_decompReducedProbRows[rownumber]) {
+          numIncludedRows++;
+          assert(numIncludedRows <= _realLP->nRows());
+        }
 
+        violatedrows[nviolatedrows].idx = rownumber;
+        violatedrows[nviolatedrows].violation = spxAbs(compProbViol);
+        nviolatedrows++;
+      }
+    }
+  }
+}
 
-/// identifies the columns of the row-form basis that correspond to rows with zero dual multipliers.
+/// identifies the columns of the row-form basis that correspond to rows with
+/// zero dual multipliers.
 // This function assumes that the basis is in the row form.
 // @todo extend this to the case when the basis is in the column form.
 template <class R>
-void SoPlexBase<R>::_getZeroDualMultiplierIndices(VectorBase<R> feasVector, int* nonposind,
-      int* colsforremoval,
-      int* nnonposind, bool& stop)
-{
-   assert(_solver.rep() == SPxSolverBase<R>::ROW);
+void SoPlexBase<R>::_getZeroDualMultiplierIndices(VectorBase<R> feasVector,
+                                                  int *nonposind,
+                                                  int *colsforremoval,
+                                                  int *nnonposind, bool &stop) {
+  assert(_solver.rep() == SPxSolverBase<R>::ROW);
 
 #ifdef NO_TOL
-   R feastol = 0.0;
+  R feastol = 0.0;
 #else
 #ifdef USE_FEASTOL
-   R feastol = realParam(SoPlexBase<R>::FEASTOL);
+  R feastol = realParam(SoPlexBase<R>::FEASTOL);
 #else
-   R feastol = realParam(SoPlexBase<R>::EPSILON_ZERO);
+  R feastol = realParam(SoPlexBase<R>::EPSILON_ZERO);
 #endif
 #endif
 
-   bool delCol;
-
-   _decompReducedProbColIDs.reSize(numCols());
-   *nnonposind = 0;
-
-   // iterating over all columns in the basis matrix
-   // this identifies the basis indices and the indicies that are positive.
-   for(int i = 0; i < _solver.nCols(); ++i)
-   {
-      _decompReducedProbCols[i] = true;
-      _decompReducedProbColIDs[i].inValidate();
-      colsforremoval[i] = i;
-      delCol = false;
-
-      if(_solver.basis().baseId(i).isSPxRowId())   // find the row id's for rows in the basis
-      {
-         // record the row if the dual multiple is zero.
-         if(isZero(feasVector[i], feastol))
-         {
-            nonposind[*nnonposind] = i;
-            (*nnonposind)++;
-
-            // NOTE: commenting out the delCol flag at this point. The colsforremoval array should indicate the
-            // columns that have a zero reduced cost. Hence, the delCol flag should only be set in the isSPxColId
-            // branch of the if statement.
-            //delCol = true;
-         }
-      }
-      else if(_solver.basis().baseId(
-                 i).isSPxColId())    // get the column id's for the columns in the basis
-      {
-         if(isZero(feasVector[i], feastol))
-         {
-            nonposind[*nnonposind] = i;
-            (*nnonposind)++;
-
-            delCol = true;
-         }
+  bool delCol;
+
+  _decompReducedProbColIDs.reSize(numCols());
+  *nnonposind = 0;
+
+  // iterating over all columns in the basis matrix
+  // this identifies the basis indices and the indicies that are positive.
+  for (int i = 0; i < _solver.nCols(); ++i) {
+    _decompReducedProbCols[i] = true;
+    _decompReducedProbColIDs[i].inValidate();
+    colsforremoval[i] = i;
+    delCol = false;
+
+    if (_solver.basis()
+            .baseId(i)
+            .isSPxRowId()) // find the row id's for rows in the basis
+    {
+      // record the row if the dual multiple is zero.
+      if (isZero(feasVector[i], feastol)) {
+        nonposind[*nnonposind] = i;
+        (*nnonposind)++;
+
+        // NOTE: commenting out the delCol flag at this point. The
+        // colsforremoval array should indicate the columns that have a zero
+        // reduced cost. Hence, the delCol flag should only be set in the
+        // isSPxColId branch of the if statement.
+        // delCol = true;
       }
-
-      // setting an array to identify the columns to be removed from the LP to form the reduced problem
-      if(delCol)
-      {
-         colsforremoval[i] = -1;
-         _decompReducedProbCols[i] = false;
+    } else if (_solver.basis()
+                   .baseId(i)
+                   .isSPxColId()) // get the column id's for the columns in the
+                                  // basis
+    {
+      if (isZero(feasVector[i], feastol)) {
+        nonposind[*nnonposind] = i;
+        (*nnonposind)++;
+
+        delCol = true;
       }
-      else if(_solver.basis().baseId(i).isSPxColId())
-      {
-         if(_solver.basis().baseId(i).isSPxColId())
-            _decompReducedProbColIDs[_solver.number(_solver.basis().baseId(i))] = SPxColId(
-                     _solver.basis().baseId(i));
-         else
-            _decompReducedProbCols[_solver.number(_solver.basis().baseId(i))] = false;
-      }
-   }
+    }
+
+    // setting an array to identify the columns to be removed from the LP to
+    // form the reduced problem
+    if (delCol) {
+      colsforremoval[i] = -1;
+      _decompReducedProbCols[i] = false;
+    } else if (_solver.basis().baseId(i).isSPxColId()) {
+      if (_solver.basis().baseId(i).isSPxColId())
+        _decompReducedProbColIDs[_solver.number(_solver.basis().baseId(i))] =
+            SPxColId(_solver.basis().baseId(i));
+      else
+        _decompReducedProbCols[_solver.number(_solver.basis().baseId(i))] =
+            false;
+    }
+  }
 
-   stop = decompTerminate(realParam(SoPlexBase<R>::TIMELIMIT) * TIMELIMIT_FRAC);
+  stop = decompTerminate(realParam(SoPlexBase<R>::TIMELIMIT) * TIMELIMIT_FRAC);
 }
 
-
-
 /// retrieves the compatible columns from the constraint matrix
-// This function also updates the constraint matrix of the reduced problem. It is efficient to perform this in the
-// following function because the required linear algebra has been performed.
+// This function also updates the constraint matrix of the reduced problem. It
+// is efficient to perform this in the following function because the required
+// linear algebra has been performed.
 template <class R>
-void SoPlexBase<R>::_getCompatibleColumns(VectorBase<R> feasVector, int* nonposind, int* compatind,
-      int* rowsforremoval,
-      int* colsforremoval, int nnonposind, int* ncompatind, bool formRedProb, bool& stop)
-{
+void SoPlexBase<R>::_getCompatibleColumns(VectorBase<R> feasVector,
+                                          int *nonposind, int *compatind,
+                                          int *rowsforremoval,
+                                          int *colsforremoval, int nnonposind,
+                                          int *ncompatind, bool formRedProb,
+                                          bool &stop) {
 #ifdef NO_TOL
-   R feastol = 0.0;
+  R feastol = 0.0;
 #else
 #ifdef USE_FEASTOL
-   R feastol = realParam(SoPlexBase<R>::FEASTOL);
+  R feastol = realParam(SoPlexBase<R>::FEASTOL);
 #else
-   R feastol = realParam(SoPlexBase<R>::EPSILON_ZERO);
+  R feastol = realParam(SoPlexBase<R>::EPSILON_ZERO);
 #endif
 #endif
 
-   bool compatible;
-   SSVectorBase<R>  y(_solver.nCols());
-   y.unSetup();
+  bool compatible;
+  SSVectorBase<R> y(_solver.nCols());
+  y.unSetup();
 
-   *ncompatind  = 0;
+  *ncompatind = 0;
 
 #ifndef NDEBUG
-   int bind = 0;
-   bool* activerows = 0;
-   spx_alloc(activerows, numRows());
-
-   for(int i = 0; i < numRows(); ++i)
-      activerows[i] = false;
-
-   for(int i = 0; i < numCols(); ++i)
-   {
-      if(_solver.basis().baseId(i).isSPxRowId())   // find the row id's for rows in the basis
-      {
-         if(!isZero(feasVector[i], feastol))
-         {
-            bind = _realLP->number(SPxRowId(_solver.basis().baseId(i))); // getting the corresponding row
-            // for the original LP.
-            assert(bind >= 0 && bind < numRows());
-            activerows[bind] = true;
-         }
+  int bind = 0;
+  bool *activerows = 0;
+  spx_alloc(activerows, numRows());
+
+  for (int i = 0; i < numRows(); ++i)
+    activerows[i] = false;
+
+  for (int i = 0; i < numCols(); ++i) {
+    if (_solver.basis()
+            .baseId(i)
+            .isSPxRowId()) // find the row id's for rows in the basis
+    {
+      if (!isZero(feasVector[i], feastol)) {
+        bind = _realLP->number(SPxRowId(
+            _solver.basis().baseId(i))); // getting the corresponding row
+        // for the original LP.
+        assert(bind >= 0 && bind < numRows());
+        activerows[bind] = true;
       }
-   }
+    }
+  }
 
 #endif
 
-   // this function is called from other places where to identify the columns for removal. In these places the
-   // reduced problem is not formed.
-   if(formRedProb)
-   {
-      _decompReducedProbRowIDs.reSize(_solver.nRows());
-      _decompReducedProbColRowIDs.reSize(_solver.nRows());
-   }
-
-   for(int i = 0; i < numRows(); ++i)
-   {
-      rowsforremoval[i] = i;
-
-      if(formRedProb)
-         _decompReducedProbRows[i] = true;
-
-      numIncludedRows++;
-
-      // the rhs of this calculation are the rows of the constraint matrix
-      // so we are solving y B = A_{i,.}
-      // @NOTE: This may not actually be necessary. The solve process is very time consuming and is a point where the
-      // approach breaks down. It could be simplier if we use a faster solve. Maybe something like:
-      // Omer, J.; Towhidi, M. & Soumis, F., "The positive edge pricing rule for the dual simplex",
-      // Computers & Operations Research , 2015, 61, 135-142
-      try
-      {
-         _solver.basis().solve(y, _solver.vector(i));
+  // this function is called from other places where to identify the columns for
+  // removal. In these places the reduced problem is not formed.
+  if (formRedProb) {
+    _decompReducedProbRowIDs.reSize(_solver.nRows());
+    _decompReducedProbColRowIDs.reSize(_solver.nRows());
+  }
+
+  for (int i = 0; i < numRows(); ++i) {
+    rowsforremoval[i] = i;
+
+    if (formRedProb)
+      _decompReducedProbRows[i] = true;
+
+    numIncludedRows++;
+
+    // the rhs of this calculation are the rows of the constraint matrix
+    // so we are solving y B = A_{i,.}
+    // @NOTE: This may not actually be necessary. The solve process is very time
+    // consuming and is a point where the approach breaks down. It could be
+    // simplier if we use a faster solve. Maybe something like: Omer, J.;
+    // Towhidi, M. & Soumis, F., "The positive edge pricing rule for the dual
+    // simplex", Computers & Operations Research , 2015, 61, 135-142
+    try {
+      _solver.basis().solve(y, _solver.vector(i));
+    } catch (const SPxException &E) {
+      MSG_ERROR(spxout << "Caught exception <" << E.what()
+                       << "> while computing compatability.\n");
+    }
+
+    compatible = true;
+
+    // a compatible row is given by zeros in all columns related to the
+    // nonpositive indices
+    for (int j = 0; j < nnonposind; ++j) {
+      // @TODO: getting a tolerance issue with this check. Don't know how to fix
+      // it.
+      if (!isZero(y[nonposind[j]], feastol)) {
+        compatible = false;
+        break;
       }
-      catch(const SPxException& E)
-      {
-         MSG_ERROR(spxout << "Caught exception <" << E.what() << "> while computing compatability.\n");
+    }
+
+    // checking that the active rows are compatible
+    assert(!activerows[i] || compatible);
+
+    // changing the matrix coefficients
+    DSVectorBase<R> newRowVector;
+    LPRowBase<R> rowtoupdate;
+
+    if (y.isSetup()) {
+      for (int j = 0; j < y.size(); j++)
+        // coverity[var_deref_model]
+        newRowVector.add(y.index(j), y.value(j));
+    } else {
+      for (int j = 0; j < numCols(); j++) {
+        if (!isZero(y[j], feastol))
+          newRowVector.add(j, y[j]);
       }
+    }
 
-      compatible = true;
-
-      // a compatible row is given by zeros in all columns related to the nonpositive indices
-      for(int j = 0; j < nnonposind; ++j)
-      {
-         // @TODO: getting a tolerance issue with this check. Don't know how to fix it.
-         if(!isZero(y[nonposind[j]], feastol))
-         {
-            compatible = false;
-            break;
-         }
-      }
-
-      // checking that the active rows are compatible
-      assert(!activerows[i] || compatible);
-
-      // changing the matrix coefficients
-      DSVectorBase<R> newRowVector;
-      LPRowBase<R> rowtoupdate;
-
-      if(y.isSetup())
-      {
-         for(int j = 0; j < y.size(); j++)
-            // coverity[var_deref_model]
-            newRowVector.add(y.index(j), y.value(j));
-      }
-      else
-      {
-         for(int j = 0; j < numCols(); j++)
-         {
-            if(!isZero(y[j], feastol))
-               newRowVector.add(j, y[j]);
-         }
-      }
-
-      // transforming the original problem rows
-      _solver.getRow(i, rowtoupdate);
+    // transforming the original problem rows
+    _solver.getRow(i, rowtoupdate);
 
 #ifndef NO_TRANSFORM
-      rowtoupdate.setRowVector(newRowVector);
+    rowtoupdate.setRowVector(newRowVector);
 #endif
 
-      if(formRedProb)
-         _transformedRows.add(rowtoupdate);
-
+    if (formRedProb)
+      _transformedRows.add(rowtoupdate);
 
-      // Making all equality constraints compatible, i.e. they are included in the reduced problem
-      if(EQ(rowtoupdate.lhs(), rowtoupdate.rhs()))
-         compatible = true;
+    // Making all equality constraints compatible, i.e. they are included in the
+    // reduced problem
+    if (EQ(rowtoupdate.lhs(), rowtoupdate.rhs()))
+      compatible = true;
 
-      if(compatible)
-      {
-         compatind[*ncompatind] = i;
-         (*ncompatind)++;
+    if (compatible) {
+      compatind[*ncompatind] = i;
+      (*ncompatind)++;
 
-         if(formRedProb)
-         {
-            _decompReducedProbRowIDs[i] = _solver.rowId(i);
+      if (formRedProb) {
+        _decompReducedProbRowIDs[i] = _solver.rowId(i);
 
-            // updating the compatible row
-            _decompLP->changeRow(i, rowtoupdate);
-         }
+        // updating the compatible row
+        _decompLP->changeRow(i, rowtoupdate);
       }
-      else
-      {
-         // setting an array to identify the rows to be removed from the LP to form the reduced problem
-         rowsforremoval[i] = -1;
-         numIncludedRows--;
+    } else {
+      // setting an array to identify the rows to be removed from the LP to form
+      // the reduced problem
+      rowsforremoval[i] = -1;
+      numIncludedRows--;
 
-         if(formRedProb)
-            _decompReducedProbRows[i] = false;
-      }
+      if (formRedProb)
+        _decompReducedProbRows[i] = false;
+    }
 
-      // determine whether the reduced problem setup should be terminated
-      stop = decompTerminate(realParam(SoPlexBase<R>::TIMELIMIT) * TIMELIMIT_FRAC);
+    // determine whether the reduced problem setup should be terminated
+    stop =
+        decompTerminate(realParam(SoPlexBase<R>::TIMELIMIT) * TIMELIMIT_FRAC);
 
-      if(stop)
-         break;
-   }
+    if (stop)
+      break;
+  }
 
-   assert(numIncludedRows <= _solver.nRows());
+  assert(numIncludedRows <= _solver.nRows());
 
 #ifndef NDEBUG
-   spx_free(activerows);
+  spx_free(activerows);
 #endif
 }
 
-
-
 /// computes the reduced problem objective coefficients
-template <class R>
-void SoPlexBase<R>::_computeReducedProbObjCoeff(bool& stop)
-{
+template <class R> void SoPlexBase<R>::_computeReducedProbObjCoeff(bool &stop) {
 #ifdef NO_TOL
-   R feastol = 0.0;
+  R feastol = 0.0;
 #else
 #ifdef USE_FEASTOL
-   R feastol = realParam(SoPlexBase<R>::FEASTOL);
+  R feastol = realParam(SoPlexBase<R>::FEASTOL);
 #else
-   R feastol = realParam(SoPlexBase<R>::EPSILON_ZERO);
+  R feastol = realParam(SoPlexBase<R>::EPSILON_ZERO);
 #endif
 #endif
 
-   SSVectorBase<R>  y(numCols());
-   y.unSetup();
-
-   // the rhs of this calculation is the original objective coefficient vector
-   // so we are solving y B = c
-   try
-   {
-      _solver.basis().solve(y, _solver.maxObj());
-   }
-   catch(const SPxException& E)
-   {
-      MSG_ERROR(spxout << "Caught exception <" << E.what() << "> while computing compatability.\n");
-   }
-
-   _transformedObj.reDim(numCols());
-
-   if(y.isSetup())
-   {
-      int ycount = 0;
-
-      for(int i = 0; i < numCols(); i++)
-      {
-         if(ycount < y.size() && i == y.index(ycount))
-         {
-            _transformedObj[i] = y.value(ycount);
-            ycount++;
-         }
-         else
-            _transformedObj[i] = 0.0;
-      }
-   }
-   else
-   {
-      for(int i = 0; i < numCols(); i++)
-      {
-         if(isZero(y[i], feastol))
-            _transformedObj[i] = 0.0;
-         else
-            _transformedObj[i] = y[i];
-      }
-   }
+  SSVectorBase<R> y(numCols());
+  y.unSetup();
+
+  // the rhs of this calculation is the original objective coefficient vector
+  // so we are solving y B = c
+  try {
+    _solver.basis().solve(y, _solver.maxObj());
+  } catch (const SPxException &E) {
+    MSG_ERROR(spxout << "Caught exception <" << E.what()
+                     << "> while computing compatability.\n");
+  }
+
+  _transformedObj.reDim(numCols());
+
+  if (y.isSetup()) {
+    int ycount = 0;
+
+    for (int i = 0; i < numCols(); i++) {
+      if (ycount < y.size() && i == y.index(ycount)) {
+        _transformedObj[i] = y.value(ycount);
+        ycount++;
+      } else
+        _transformedObj[i] = 0.0;
+    }
+  } else {
+    for (int i = 0; i < numCols(); i++) {
+      if (isZero(y[i], feastol))
+        _transformedObj[i] = 0.0;
+      else
+        _transformedObj[i] = y[i];
+    }
+  }
 
-   // setting the updated objective vector
+  // setting the updated objective vector
 #ifndef NO_TRANSFORM
-   _decompLP->changeObj(_transformedObj);
+  _decompLP->changeObj(_transformedObj);
 #endif
 
-   // determine whether the reduced problem setup should be terminated
-   stop = decompTerminate(realParam(SoPlexBase<R>::TIMELIMIT) * TIMELIMIT_FRAC);
+  // determine whether the reduced problem setup should be terminated
+  stop = decompTerminate(realParam(SoPlexBase<R>::TIMELIMIT) * TIMELIMIT_FRAC);
 }
 
-
-
-/// computes the compatible bound constraints and adds them to the reduced problem
-// NOTE: No columns are getting removed from the reduced problem. Only the bound constraints are being removed.
-// So in the reduced problem, all variables are free unless the bound constraints are selected as compatible.
+/// computes the compatible bound constraints and adds them to the reduced
+/// problem
+// NOTE: No columns are getting removed from the reduced problem. Only the bound
+// constraints are being removed. So in the reduced problem, all variables are
+// free unless the bound constraints are selected as compatible.
 template <class R>
-void SoPlexBase<R>::_getCompatibleBoundCons(LPRowSetBase<R>& boundcons, int* compatboundcons,
-      int* nonposind,
-      int* ncompatboundcons, int nnonposind, bool& stop)
-{
+void SoPlexBase<R>::_getCompatibleBoundCons(LPRowSetBase<R> &boundcons,
+                                            int *compatboundcons,
+                                            int *nonposind,
+                                            int *ncompatboundcons,
+                                            int nnonposind, bool &stop) {
 #ifdef NO_TOL
-   R feastol = 0.0;
+  R feastol = 0.0;
 #else
 #ifdef USE_FEASTOL
-   R feastol = realParam(SoPlexBase<R>::FEASTOL);
+  R feastol = realParam(SoPlexBase<R>::FEASTOL);
 #else
-   R feastol = realParam(SoPlexBase<R>::EPSILON_ZERO);
+  R feastol = realParam(SoPlexBase<R>::EPSILON_ZERO);
 #endif
 #endif
 
-   bool compatible;
-   int ncols = numCols();
-   SSVectorBase<R>  y(ncols);
-   y.unSetup();
-
-   _decompReducedProbColRowIDs.reSize(numCols());
-
-
-   // identifying the compatible bound constraints
-   for(int i = 0; i < ncols; i++)
-   {
-      _decompReducedProbColRowIDs[i].inValidate();
-
-      // setting all variables to free variables.
-      // Bound constraints will only be added to the variables with compatible bound constraints.
-      _decompLP->changeUpper(i, R(infinity));
-      _decompLP->changeLower(i, R(-infinity));
-
-      // the rhs of this calculation are the unit vectors of the bound constraints
-      // so we are solving y B = I_{i,.}
-      // this solve should not be required. We only need the column of the basis inverse.
-      try
-      {
-         _solver.basis().solve(y, _solver.unitVector(i));
-      }
-      catch(const SPxException& E)
-      {
-         MSG_ERROR(spxout << "Caught exception <" << E.what() << "> while computing compatability.\n");
-      }
-
-      compatible = true;
-
-      // a compatible row is given by zeros in all columns related to the nonpositive indices
-      for(int j = 0; j < nnonposind; ++j)
-      {
-         // @todo really need to check this part of the code. Run through this with Ambros or Matthias.
-         if(!isZero(y[nonposind[j]]))
-         {
-            compatible = false;
-            break;
-         }
+  bool compatible;
+  int ncols = numCols();
+  SSVectorBase<R> y(ncols);
+  y.unSetup();
+
+  _decompReducedProbColRowIDs.reSize(numCols());
+
+  // identifying the compatible bound constraints
+  for (int i = 0; i < ncols; i++) {
+    _decompReducedProbColRowIDs[i].inValidate();
+
+    // setting all variables to free variables.
+    // Bound constraints will only be added to the variables with compatible
+    // bound constraints.
+    _decompLP->changeUpper(i, R(infinity));
+    _decompLP->changeLower(i, R(-infinity));
+
+    // the rhs of this calculation are the unit vectors of the bound constraints
+    // so we are solving y B = I_{i,.}
+    // this solve should not be required. We only need the column of the basis
+    // inverse.
+    try {
+      _solver.basis().solve(y, _solver.unitVector(i));
+    } catch (const SPxException &E) {
+      MSG_ERROR(spxout << "Caught exception <" << E.what()
+                       << "> while computing compatability.\n");
+    }
+
+    compatible = true;
+
+    // a compatible row is given by zeros in all columns related to the
+    // nonpositive indices
+    for (int j = 0; j < nnonposind; ++j) {
+      // @todo really need to check this part of the code. Run through this with
+      // Ambros or Matthias.
+      if (!isZero(y[nonposind[j]])) {
+        compatible = false;
+        break;
       }
+    }
 
-      // changing the matrix coefficients
-      DSVectorBase<R> newRowVector;
-      LPRowBase<R> rowtoupdate;
+    // changing the matrix coefficients
+    DSVectorBase<R> newRowVector;
+    LPRowBase<R> rowtoupdate;
 
 #ifndef NO_TRANSFORM
 
-      if(y.isSetup())
-      {
-         for(int j = 0; j < y.size(); j++)
-            newRowVector.add(y.index(j), y.value(j));
-      }
-      else
-      {
-         for(int j = 0; j < ncols; j++)
-         {
-            if(!isZero(y[j], feastol))
-            {
-               newRowVector.add(j, y[j]);
-            }
-         }
+    if (y.isSetup()) {
+      for (int j = 0; j < y.size(); j++)
+        newRowVector.add(y.index(j), y.value(j));
+    } else {
+      for (int j = 0; j < ncols; j++) {
+        if (!isZero(y[j], feastol)) {
+          newRowVector.add(j, y[j]);
+        }
       }
+    }
 
 #else
-      newRowVector.add(i, 1.0);
+    newRowVector.add(i, 1.0);
 #endif
 
-      // will probably need to map this set of rows.
-      _transformedRows.add(_solver.lower(i), newRowVector, _solver.upper(i));
+    // will probably need to map this set of rows.
+    _transformedRows.add(_solver.lower(i), newRowVector, _solver.upper(i));
 
-      // variable bounds are compatible in the current implementation.
-      // this is still function is still required to transform the bound constraints with respect to the basis matrix.
-      compatible = true;
-
-      // if the bound constraint is compatible, it remains in the reduced problem.
-      // Otherwise the bound is removed and the variables are free.
-      if(compatible)
-      {
-         R lhs = R(-infinity);
-         R rhs = R(infinity);
+    // variable bounds are compatible in the current implementation.
+    // this is still function is still required to transform the bound
+    // constraints with respect to the basis matrix.
+    compatible = true;
 
-         if(GT(_solver.lower(i), R(-infinity)))
-            lhs = _solver.lower(i);
+    // if the bound constraint is compatible, it remains in the reduced problem.
+    // Otherwise the bound is removed and the variables are free.
+    if (compatible) {
+      R lhs = R(-infinity);
+      R rhs = R(infinity);
 
-         if(LT(_solver.upper(i), R(infinity)))
-            rhs = _solver.upper(i);
+      if (GT(_solver.lower(i), R(-infinity)))
+        lhs = _solver.lower(i);
 
-         if(GT(lhs, R(-infinity)) || LT(rhs, R(infinity)))
-         {
-            compatboundcons[(*ncompatboundcons)] = i;
-            (*ncompatboundcons)++;
-
-            boundcons.add(lhs, newRowVector, rhs);
-         }
+      if (LT(_solver.upper(i), R(infinity)))
+        rhs = _solver.upper(i);
 
+      if (GT(lhs, R(-infinity)) || LT(rhs, R(infinity))) {
+        compatboundcons[(*ncompatboundcons)] = i;
+        (*ncompatboundcons)++;
 
+        boundcons.add(lhs, newRowVector, rhs);
       }
+    }
 
-      // determine whether the reduced problem setup should be terminated
-      stop = decompTerminate(realParam(SoPlexBase<R>::TIMELIMIT) * TIMELIMIT_FRAC);
-
-      if(stop)
-         break;
-   }
+    // determine whether the reduced problem setup should be terminated
+    stop =
+        decompTerminate(realParam(SoPlexBase<R>::TIMELIMIT) * TIMELIMIT_FRAC);
 
+    if (stop)
+      break;
+  }
 }
 
-
-
 /// computes the rows to remove from the complementary problem
 template <class R>
-void SoPlexBase<R>::_getRowsForRemovalComplementaryProblem(int* nonposind, int* bind,
-      int* rowsforremoval,
-      int* nrowsforremoval, int nnonposind)
-{
-   *nrowsforremoval = 0;
-
-   for(int i = 0; i < nnonposind; i++)
-   {
-      if(bind[nonposind[i]] < 0)
-      {
-         rowsforremoval[*nrowsforremoval] = -1 - bind[nonposind[i]];
-         (*nrowsforremoval)++;
-      }
-   }
+void SoPlexBase<R>::_getRowsForRemovalComplementaryProblem(int *nonposind,
+                                                           int *bind,
+                                                           int *rowsforremoval,
+                                                           int *nrowsforremoval,
+                                                           int nnonposind) {
+  *nrowsforremoval = 0;
+
+  for (int i = 0; i < nnonposind; i++) {
+    if (bind[nonposind[i]] < 0) {
+      rowsforremoval[*nrowsforremoval] = -1 - bind[nonposind[i]];
+      (*nrowsforremoval)++;
+    }
+  }
 }
 
-
-
 /// removing rows from the complementary problem.
-// the rows that are removed from decompCompLP are the rows from the reduced problem that have a non-positive dual
-// multiplier in the optimal solution.
+// the rows that are removed from decompCompLP are the rows from the reduced
+// problem that have a non-positive dual multiplier in the optimal solution.
 template <class R>
-void SoPlexBase<R>::_deleteAndUpdateRowsComplementaryProblem(SPxRowId rangedRowIds[],
-      int& naddedrows)
-{
-   DSVectorBase<R> slackColCoeff;
-
-   // setting the objective coefficients of the original variables to zero
-   VectorBase<R> newObjCoeff(numCols());
-
-   for(int i = 0; i < numCols(); i++)
-   {
-      _compSolver.changeBounds(_realLP->cId(i), R(-infinity), R(infinity));
-      newObjCoeff[i] = 0;
-   }
-
-   _compSolver.changeObj(newObjCoeff);
-
-   // adding the slack column to the complementary problem
-   SPxColId* addedcolid = 0;
-
-   if(boolParam(SoPlexBase<R>::USECOMPDUAL))
-   {
-      spx_alloc(addedcolid, 1);
-      LPColSetBase<R> compSlackCol;
-      compSlackCol.add(R(1.0), R(-infinity), slackColCoeff, R(infinity));
-      _compSolver.addCols(addedcolid, compSlackCol);
-      _compSlackColId = addedcolid[0];
-   }
-   else
-   {
-      LPRowSetBase<R>
-      addrangedrows;    // the row set of ranged and equality rows that must be added to the complementary problem.
-      naddedrows = 0;
-
-      // finding all of the ranged and equality rows and creating two <= constraints.
-      for(int i = 0; i < numRows(); i++)
-      {
-         if(_realLP->rowType(i) == LPRowBase<R>::RANGE || _realLP->rowType(i) == LPRowBase<R>::EQUAL)
-         {
-            assert(GT(_compSolver.lhs(i), R(-infinity)) && LT(_compSolver.rhs(i), R(infinity)));
-            assert(_compSolver.rowType(i) == LPRowBase<R>::RANGE
-                   || _compSolver.rowType(i) == LPRowBase<R>::EQUAL);
-
-            _compSolver.changeLhs(i, R(-infinity));
-            addrangedrows.add(_realLP->lhs(i), _realLP->rowVector(i), R(infinity));
-            naddedrows++;
-         }
+void SoPlexBase<R>::_deleteAndUpdateRowsComplementaryProblem(
+    SPxRowId rangedRowIds[], int &naddedrows) {
+  DSVectorBase<R> slackColCoeff;
+
+  // setting the objective coefficients of the original variables to zero
+  VectorBase<R> newObjCoeff(numCols());
+
+  for (int i = 0; i < numCols(); i++) {
+    _compSolver.changeBounds(_realLP->cId(i), R(-infinity), R(infinity));
+    newObjCoeff[i] = 0;
+  }
+
+  _compSolver.changeObj(newObjCoeff);
+
+  // adding the slack column to the complementary problem
+  SPxColId *addedcolid = 0;
+
+  if (boolParam(SoPlexBase<R>::USECOMPDUAL)) {
+    spx_alloc(addedcolid, 1);
+    LPColSetBase<R> compSlackCol;
+    compSlackCol.add(R(1.0), R(-infinity), slackColCoeff, R(infinity));
+    _compSolver.addCols(addedcolid, compSlackCol);
+    _compSlackColId = addedcolid[0];
+  } else {
+    LPRowSetBase<R>
+        addrangedrows; // the row set of ranged and equality rows that must be
+                       // added to the complementary problem.
+    naddedrows = 0;
+
+    // finding all of the ranged and equality rows and creating two <=
+    // constraints.
+    for (int i = 0; i < numRows(); i++) {
+      if (_realLP->rowType(i) == LPRowBase<R>::RANGE ||
+          _realLP->rowType(i) == LPRowBase<R>::EQUAL) {
+        assert(GT(_compSolver.lhs(i), R(-infinity)) &&
+               LT(_compSolver.rhs(i), R(infinity)));
+        assert(_compSolver.rowType(i) == LPRowBase<R>::RANGE ||
+               _compSolver.rowType(i) == LPRowBase<R>::EQUAL);
+
+        _compSolver.changeLhs(i, R(-infinity));
+        addrangedrows.add(_realLP->lhs(i), _realLP->rowVector(i), R(infinity));
+        naddedrows++;
       }
+    }
 
-      // adding the rows for the ranged rows to make <= conatraints
-      SPxRowId* addedrowid = 0;
-      spx_alloc(addedrowid, naddedrows);
-      _compSolver.addRows(addedrowid, addrangedrows);
-
-      // collecting the row ids
-      for(int i = 0; i < naddedrows; i++)
-         rangedRowIds[i] = addedrowid[i];
-
-      spx_free(addedrowid);
-
+    // adding the rows for the ranged rows to make <= conatraints
+    SPxRowId *addedrowid = 0;
+    spx_alloc(addedrowid, naddedrows);
+    _compSolver.addRows(addedrowid, addrangedrows);
 
-      // adding the slack column
-      spx_alloc(addedcolid, 1);
-      LPColSetBase<R> compSlackCol;
-      compSlackCol.add(R(-1.0), R(0.0), slackColCoeff, R(infinity));
-
-      _compSolver.addCols(addedcolid, compSlackCol);
-      _compSlackColId = addedcolid[0];
-   }
-
-   // freeing allocated memory
-   spx_free(addedcolid);
-}
-
-
-
-/// update the dual complementary problem with additional columns and rows
-// Given the solution to the updated reduced problem, the complementary problem will be updated with modifications to
-// the constraints and the removal of variables
-template <class R>
-void SoPlexBase<R>::_updateDecompComplementaryDualProblem(bool origObj)
-{
-   R feastol = realParam(SoPlexBase<R>::FEASTOL);
-
-   int prevNumCols =
-      _compSolver.nCols(); // number of columns in the previous formulation of the complementary prob
-   int prevNumRows = _compSolver.nRows();
-   int prevPrimalRowIds = _nPrimalRows;
-   int prevDualColIds = _nDualCols;
-
-   LPColSetBase<R> addElimCols(_nElimPrimalRows);  // columns previously eliminated from the
-   // complementary problem that must be added
-   int numElimColsAdded = 0;
-   int currnumrows = prevNumRows;
-   // looping over all rows from the original LP that were eliminated during the formation of the complementary
-   // problem. The eliminated rows will be added if they are basic in the reduced problem.
-
-   for(int i = 0; i < _nElimPrimalRows; i++)
-   {
-      int rowNumber = _realLP->number(_decompElimPrimalRowIDs[i]);
-
-      int solverRowNum = _solver.number(_decompReducedProbRowIDs[rowNumber]);
-      assert(solverRowNum >= 0 && solverRowNum < _solver.nRows());
+    // collecting the row ids
+    for (int i = 0; i < naddedrows; i++)
+      rangedRowIds[i] = addedrowid[i];
 
-      // checking for the basic rows in the reduced problem
-      if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_ON_UPPER ||
-            _solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_ON_LOWER ||
-            _solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_FIXED ||
-            _solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_FREE ||
-            (_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_ON_LOWER &&
-             LE(_solver.rhs(solverRowNum) - _solver.pVec()[solverRowNum], R(0.0), feastol)) ||
-            (_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_ON_UPPER &&
-             LE(_solver.pVec()[solverRowNum] - _solver.lhs(solverRowNum), R(0.0), feastol)))
-      {
-         LPRowBase<R> origlprow;
-         DSVectorBase<R> coltoaddVec(_realLP->nCols());
-
-         LPRowSetBase<R> additionalrows;
-         int nnewrows = 0;
-
-         _realLP->getRow(rowNumber, origlprow);
-
-         for(int j = 0; j < origlprow.rowVector().size(); j++)
-         {
-            // the column of the new row may not exist in the current complementary problem.
-            // if the column does not exist, then it is necessary to create the column.
-            int colNumber = origlprow.rowVector().index(j);
-
-            if(_decompCompProbColIDsIdx[colNumber] == -1)
-            {
-               assert(!_decompReducedProbColIDs[colNumber].isValid());
-               _decompPrimalColIDs[_nPrimalCols] = _realLP->cId(colNumber);
-               _decompCompProbColIDsIdx[colNumber] = _nPrimalCols;
-               _fixedOrigVars[colNumber] = -2;
-               _nPrimalCols++;
-
-               // all columns for the complementary problem are converted to unrestricted.
-               additionalrows.create(1, _realLP->maxObj(colNumber), _realLP->maxObj(colNumber));
-               nnewrows++;
-
-               coltoaddVec.add(currnumrows, origlprow.rowVector().value(j));
-               currnumrows++;
-            }
-            else
-               coltoaddVec.add(_compSolver.number(_decompDualRowIDs[_decompCompProbColIDsIdx[colNumber]]),
-                               origlprow.rowVector().value(j));
-         }
-
-         SPxRowId* addedrowids = 0;
-         spx_alloc(addedrowids, nnewrows);
-         _compSolver.addRows(addedrowids, additionalrows);
-
-         for(int j = 0; j < nnewrows; j++)
-         {
-            _decompDualRowIDs[_nDualRows] = addedrowids[j];
-            _nDualRows++;
-         }
-
-         spx_free(addedrowids);
-
-
-
-         if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_ON_UPPER ||
-               _solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_FIXED ||
-               _solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_FREE ||
-               (_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_ON_LOWER &&
-                LE(_solver.rhs(solverRowNum) - _solver.pVec()[solverRowNum], R(0.0), feastol)))
-         {
-            assert(LT(_realLP->rhs(_decompElimPrimalRowIDs[i]), R(infinity)));
-            addElimCols.add(_realLP->rhs(_decompElimPrimalRowIDs[i]), R(-infinity), coltoaddVec, R(infinity));
-
-            if(_nPrimalRows >= _decompPrimalRowIDs.size())
-            {
-               _decompPrimalRowIDs.reSize(_nPrimalRows * 2);
-               _decompDualColIDs.reSize(_nPrimalRows * 2);
-            }
-
-            _decompPrimalRowIDs[_nPrimalRows] = _decompElimPrimalRowIDs[i];
-            _nPrimalRows++;
-
-            _decompElimPrimalRowIDs.remove(i);
-            _nElimPrimalRows--;
-            i--;
-
-            numElimColsAdded++;
-         }
-         else if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_ON_LOWER ||
-                 (_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_ON_UPPER &&
-                  LE(_solver.pVec()[solverRowNum] - _solver.lhs(solverRowNum), R(0.0), feastol)))
-         {
-            // this assert should stay, but there is an issue with the status and the dual vector
-            //assert(LT(dualVector[_solver.number(_decompReducedProbRowIDs[rowNumber])], 0.0));
-            assert(GT(_realLP->lhs(_decompElimPrimalRowIDs[i]), R(-infinity)));
-            addElimCols.add(_realLP->lhs(_decompElimPrimalRowIDs[i]), R(-infinity), coltoaddVec, R(infinity));
-
-            _decompPrimalRowIDs[_nPrimalRows] = _decompElimPrimalRowIDs[i];
-            _nPrimalRows++;
-
-            _decompElimPrimalRowIDs.remove(i);
-            _nElimPrimalRows--;
-            i--;
-
-            numElimColsAdded++;
-         }
-      }
-   }
+    spx_free(addedrowid);
 
-   MSG_INFO2(spxout, spxout << "Number of eliminated columns added to complementary problem: "
-             << numElimColsAdded << std::endl);
+    // adding the slack column
+    spx_alloc(addedcolid, 1);
+    LPColSetBase<R> compSlackCol;
+    compSlackCol.add(R(-1.0), R(0.0), slackColCoeff, R(infinity));
+
+    _compSolver.addCols(addedcolid, compSlackCol);
+    _compSlackColId = addedcolid[0];
+  }
 
-   // updating the _decompDualColIDs with the additional columns from the eliminated rows.
-   _compSolver.addCols(addElimCols);
+  // freeing allocated memory
+  spx_free(addedcolid);
+}
 
-   for(int i = prevNumCols; i < _compSolver.nCols(); i++)
-   {
-      _decompDualColIDs[prevDualColIds + i - prevNumCols] = _compSolver.colId(i);
-      _nDualCols++;
-   }
+/// update the dual complementary problem with additional columns and rows
+// Given the solution to the updated reduced problem, the complementary problem
+// will be updated with modifications to the constraints and the removal of
+// variables
+template <class R>
+void SoPlexBase<R>::_updateDecompComplementaryDualProblem(bool origObj) {
+  R feastol = realParam(SoPlexBase<R>::FEASTOL);
+
+  int prevNumCols =
+      _compSolver.nCols(); // number of columns in the previous formulation of
+                           // the complementary prob
+  int prevNumRows = _compSolver.nRows();
+  int prevPrimalRowIds = _nPrimalRows;
+  int prevDualColIds = _nDualCols;
+
+  LPColSetBase<R> addElimCols(
+      _nElimPrimalRows); // columns previously eliminated from the
+  // complementary problem that must be added
+  int numElimColsAdded = 0;
+  int currnumrows = prevNumRows;
+  // looping over all rows from the original LP that were eliminated during the
+  // formation of the complementary problem. The eliminated rows will be added
+  // if they are basic in the reduced problem.
+
+  for (int i = 0; i < _nElimPrimalRows; i++) {
+    int rowNumber = _realLP->number(_decompElimPrimalRowIDs[i]);
+
+    int solverRowNum = _solver.number(_decompReducedProbRowIDs[rowNumber]);
+    assert(solverRowNum >= 0 && solverRowNum < _solver.nRows());
+
+    // checking for the basic rows in the reduced problem
+    if (_solver.basis().desc().rowStatus(solverRowNum) ==
+            SPxBasisBase<R>::Desc::P_ON_UPPER ||
+        _solver.basis().desc().rowStatus(solverRowNum) ==
+            SPxBasisBase<R>::Desc::P_ON_LOWER ||
+        _solver.basis().desc().rowStatus(solverRowNum) ==
+            SPxBasisBase<R>::Desc::P_FIXED ||
+        _solver.basis().desc().rowStatus(solverRowNum) ==
+            SPxBasisBase<R>::Desc::D_FREE ||
+        (_solver.basis().desc().rowStatus(solverRowNum) ==
+             SPxBasisBase<R>::Desc::D_ON_LOWER &&
+         LE(_solver.rhs(solverRowNum) - _solver.pVec()[solverRowNum], R(0.0),
+            feastol)) ||
+        (_solver.basis().desc().rowStatus(solverRowNum) ==
+             SPxBasisBase<R>::Desc::D_ON_UPPER &&
+         LE(_solver.pVec()[solverRowNum] - _solver.lhs(solverRowNum), R(0.0),
+            feastol))) {
+      LPRowBase<R> origlprow;
+      DSVectorBase<R> coltoaddVec(_realLP->nCols());
+
+      LPRowSetBase<R> additionalrows;
+      int nnewrows = 0;
+
+      _realLP->getRow(rowNumber, origlprow);
+
+      for (int j = 0; j < origlprow.rowVector().size(); j++) {
+        // the column of the new row may not exist in the current complementary
+        // problem. if the column does not exist, then it is necessary to create
+        // the column.
+        int colNumber = origlprow.rowVector().index(j);
+
+        if (_decompCompProbColIDsIdx[colNumber] == -1) {
+          assert(!_decompReducedProbColIDs[colNumber].isValid());
+          _decompPrimalColIDs[_nPrimalCols] = _realLP->cId(colNumber);
+          _decompCompProbColIDsIdx[colNumber] = _nPrimalCols;
+          _fixedOrigVars[colNumber] = -2;
+          _nPrimalCols++;
+
+          // all columns for the complementary problem are converted to
+          // unrestricted.
+          additionalrows.create(1, _realLP->maxObj(colNumber),
+                                _realLP->maxObj(colNumber));
+          nnewrows++;
+
+          coltoaddVec.add(currnumrows, origlprow.rowVector().value(j));
+          currnumrows++;
+        } else
+          coltoaddVec.add(
+              _compSolver.number(
+                  _decompDualRowIDs[_decompCompProbColIDsIdx[colNumber]]),
+              origlprow.rowVector().value(j));
+      }
 
-   assert(_nDualCols == _nPrimalRows);
+      SPxRowId *addedrowids = 0;
+      spx_alloc(addedrowids, nnewrows);
+      _compSolver.addRows(addedrowids, additionalrows);
 
-   // looping over all rows from the original problem that were originally contained in the complementary problem.
-   // The basic rows will be set as free variables, the non-basic rows will be eliminated from the complementary
-   // problem.
-   DSVectorBase<R> slackRowCoeff(_compSolver.nCols());
+      for (int j = 0; j < nnewrows; j++) {
+        _decompDualRowIDs[_nDualRows] = addedrowids[j];
+        _nDualRows++;
+      }
 
-   int* colsforremoval = 0;
-   int ncolsforremoval = 0;
-   spx_alloc(colsforremoval, prevPrimalRowIds);
+      spx_free(addedrowids);
+
+      if (_solver.basis().desc().rowStatus(solverRowNum) ==
+              SPxBasisBase<R>::Desc::P_ON_UPPER ||
+          _solver.basis().desc().rowStatus(solverRowNum) ==
+              SPxBasisBase<R>::Desc::P_FIXED ||
+          _solver.basis().desc().rowStatus(solverRowNum) ==
+              SPxBasisBase<R>::Desc::D_FREE ||
+          (_solver.basis().desc().rowStatus(solverRowNum) ==
+               SPxBasisBase<R>::Desc::D_ON_LOWER &&
+           LE(_solver.rhs(solverRowNum) - _solver.pVec()[solverRowNum], R(0.0),
+              feastol))) {
+        assert(LT(_realLP->rhs(_decompElimPrimalRowIDs[i]), R(infinity)));
+        addElimCols.add(_realLP->rhs(_decompElimPrimalRowIDs[i]), R(-infinity),
+                        coltoaddVec, R(infinity));
+
+        if (_nPrimalRows >= _decompPrimalRowIDs.size()) {
+          _decompPrimalRowIDs.reSize(_nPrimalRows * 2);
+          _decompDualColIDs.reSize(_nPrimalRows * 2);
+        }
+
+        _decompPrimalRowIDs[_nPrimalRows] = _decompElimPrimalRowIDs[i];
+        _nPrimalRows++;
+
+        _decompElimPrimalRowIDs.remove(i);
+        _nElimPrimalRows--;
+        i--;
+
+        numElimColsAdded++;
+      } else if (_solver.basis().desc().rowStatus(solverRowNum) ==
+                     SPxBasisBase<R>::Desc::P_ON_LOWER ||
+                 (_solver.basis().desc().rowStatus(solverRowNum) ==
+                      SPxBasisBase<R>::Desc::D_ON_UPPER &&
+                  LE(_solver.pVec()[solverRowNum] - _solver.lhs(solverRowNum),
+                     R(0.0), feastol))) {
+        // this assert should stay, but there is an issue with the status and
+        // the dual vector
+        // assert(LT(dualVector[_solver.number(_decompReducedProbRowIDs[rowNumber])],
+        // 0.0));
+        assert(GT(_realLP->lhs(_decompElimPrimalRowIDs[i]), R(-infinity)));
+        addElimCols.add(_realLP->lhs(_decompElimPrimalRowIDs[i]), R(-infinity),
+                        coltoaddVec, R(infinity));
+
+        _decompPrimalRowIDs[_nPrimalRows] = _decompElimPrimalRowIDs[i];
+        _nPrimalRows++;
+
+        _decompElimPrimalRowIDs.remove(i);
+        _nElimPrimalRows--;
+        i--;
+
+        numElimColsAdded++;
+      }
+    }
+  }
 
-   for(int i = 0; i < prevPrimalRowIds; i++)
-   {
-      int rowNumber = _realLP->number(_decompPrimalRowIDs[i]);
+  MSG_INFO2(
+      spxout,
+      spxout << "Number of eliminated columns added to complementary problem: "
+             << numElimColsAdded << std::endl);
 
-      // this loop runs over all rows previously in the complementary problem. If rows are added to the reduced
-      // problem, they will be transfered from the incompatible set to the compatible set in the following if
-      // statement.
-      if(_decompReducedProbRows[rowNumber])
-      {
-         // rows added to the reduced problem may have been equality constriants. The equality constraints from the
-         // original problem are converted into <= and >= constraints. Upon adding these constraints to the reduced
-         // problem, only a single dual column is needed in the complementary problem. Hence, one of the dual columns
-         // is removed.
-         //
-         // 22.06.2015 Testing keeping all constraints in the complementary problem.
-         // This requires a dual column to be fixed to zero for the range and equality rows.
+  // updating the _decompDualColIDs with the additional columns from the
+  // eliminated rows.
+  _compSolver.addCols(addElimCols);
+
+  for (int i = prevNumCols; i < _compSolver.nCols(); i++) {
+    _decompDualColIDs[prevDualColIds + i - prevNumCols] = _compSolver.colId(i);
+    _nDualCols++;
+  }
+
+  assert(_nDualCols == _nPrimalRows);
+
+  // looping over all rows from the original problem that were originally
+  // contained in the complementary problem. The basic rows will be set as free
+  // variables, the non-basic rows will be eliminated from the complementary
+  // problem.
+  DSVectorBase<R> slackRowCoeff(_compSolver.nCols());
+
+  int *colsforremoval = 0;
+  int ncolsforremoval = 0;
+  spx_alloc(colsforremoval, prevPrimalRowIds);
+
+  for (int i = 0; i < prevPrimalRowIds; i++) {
+    int rowNumber = _realLP->number(_decompPrimalRowIDs[i]);
+
+    // this loop runs over all rows previously in the complementary problem. If
+    // rows are added to the reduced problem, they will be transfered from the
+    // incompatible set to the compatible set in the following if statement.
+    if (_decompReducedProbRows[rowNumber]) {
+      // rows added to the reduced problem may have been equality constriants.
+      // The equality constraints from the original problem are converted into
+      // <= and >= constraints. Upon adding these constraints to the reduced
+      // problem, only a single dual column is needed in the complementary
+      // problem. Hence, one of the dual columns is removed.
+      //
+      // 22.06.2015 Testing keeping all constraints in the complementary
+      // problem. This requires a dual column to be fixed to zero for the range
+      // and equality rows.
 #ifdef KEEP_ALL_ROWS_IN_COMP_PROB
-         bool incrementI = false;
+      bool incrementI = false;
 #endif
 
-         if(i + 1 < prevPrimalRowIds
-               && _realLP->number(_decompPrimalRowIDs[i]) == _realLP->number(_decompPrimalRowIDs[i + 1]))
-         {
-            assert(_decompPrimalRowIDs[i].idx == _decompPrimalRowIDs[i + 1].idx);
+      if (i + 1 < prevPrimalRowIds &&
+          _realLP->number(_decompPrimalRowIDs[i]) ==
+              _realLP->number(_decompPrimalRowIDs[i + 1])) {
+        assert(_decompPrimalRowIDs[i].idx == _decompPrimalRowIDs[i + 1].idx);
 
 #ifdef KEEP_ALL_ROWS_IN_COMP_PROB // 22.06.2015
 
-            if(_realLP->rowType(_decompPrimalRowIDs[i]) == LPRowBase<R>::RANGE)
-            {
-               _compSolver.changeObj(_decompDualColIDs[i + 1], 0.0);
-               _compSolver.changeBounds(_decompDualColIDs[i + 1], 0.0, 0.0);
-            }
+        if (_realLP->rowType(_decompPrimalRowIDs[i]) == LPRowBase<R>::RANGE) {
+          _compSolver.changeObj(_decompDualColIDs[i + 1], 0.0);
+          _compSolver.changeBounds(_decompDualColIDs[i + 1], 0.0, 0.0);
+        }
 
-            incrementI = true;
+        incrementI = true;
 #else
-            colsforremoval[ncolsforremoval] = _compSolver.number(SPxColId(_decompDualColIDs[i + 1]));
-            ncolsforremoval++;
+        colsforremoval[ncolsforremoval] =
+            _compSolver.number(SPxColId(_decompDualColIDs[i + 1]));
+        ncolsforremoval++;
 
-            _decompPrimalRowIDs.remove(i + 1);
-            _nPrimalRows--;
-            _decompDualColIDs.remove(i + 1);
-            _nDualCols--;
+        _decompPrimalRowIDs.remove(i + 1);
+        _nPrimalRows--;
+        _decompDualColIDs.remove(i + 1);
+        _nDualCols--;
 
-            prevPrimalRowIds--;
+        prevPrimalRowIds--;
 #endif
-         }
-
-         //assert(i + 1 == prevPrimalRowIds || _decompPrimalRowIDs[i].idx != _decompPrimalRowIDs[i+1].idx);
-
-         int solverRowNum = _solver.number(_decompReducedProbRowIDs[rowNumber]);
-         assert(solverRowNum >= 0 && solverRowNum < _solver.nRows());
-
-         if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_ON_UPPER ||
-               _solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_FIXED ||
-               _solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_FREE ||
-               (_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_ON_LOWER &&
-                LE(_solver.rhs(solverRowNum) - _solver.pVec()[solverRowNum], R(0.0), feastol)))
-         {
-            //assert(GT(dualVector[solverRowNum], 0.0));
-            _compSolver.changeObj(_decompDualColIDs[i], _realLP->rhs(SPxRowId(_decompPrimalRowIDs[i])));
-            _compSolver.changeBounds(_decompDualColIDs[i], R(-infinity), R(infinity));
-         }
-         else if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_ON_LOWER ||
-                 (_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_ON_UPPER &&
-                  LE(_solver.pVec()[solverRowNum] - _solver.lhs(solverRowNum), R(0.0), feastol)))
-         {
-            //assert(LT(dualVector[solverRowNum], 0.0));
-            _compSolver.changeObj(_decompDualColIDs[i], _realLP->lhs(SPxRowId(_decompPrimalRowIDs[i])));
-            _compSolver.changeBounds(_decompDualColIDs[i], R(-infinity), R(infinity));
-         }
-         else //if ( _solver.basis().desc().rowStatus(solverRowNum) != SPxBasisBase<R>::Desc::D_FREE )
-         {
-            //assert(isZero(dualVector[solverRowNum], 0.0));
-
-            // 22.06.2015 Testing keeping all rows in the complementary problem
-#ifdef KEEP_ALL_ROWS_IN_COMP_PROB
-            switch(_realLP->rowType(_decompPrimalRowIDs[i]))
-            {
-            case LPRowBase<R>::RANGE:
-               assert(_realLP->number(SPxColId(_decompPrimalRowIDs[i])) ==
-                      _realLP->number(SPxColId(_decompPrimalRowIDs[i + 1])));
-               assert(_compSolver.obj(_compSolver.number(SPxColId(_decompDualColIDs[i]))) !=
-                      _compSolver.obj(_compSolver.number(SPxColId(_decompDualColIDs[i + 1]))));
-
-               _compSolver.changeObj(_decompDualColIDs[i], _realLP->rhs(_decompPrimalRowIDs[i]));
-               _compSolver.changeBounds(_decompDualColIDs[i], 0.0, R(infinity));
-               _compSolver.changeObj(_decompDualColIDs[i + 1], _realLP->lhs(_decompPrimalRowIDs[i]));
-               _compSolver.changeBounds(_decompDualColIDs[i + 1], R(-infinity), 0.0);
-
-               i++;
-               break;
-
-            case LPRowBase<R>::GREATER_EQUAL:
-               _compSolver.changeObj(_decompDualColIDs[i], _realLP->lhs(_decompPrimalRowIDs[i]));
-               _compSolver.changeBounds(_decompDualColIDs[i], R(-infinity), 0.0);
-               break;
-
-            case LPRowBase<R>::LESS_EQUAL:
-               _compSolver.changeObj(_decompDualColIDs[i], _realLP->rhs(_decompPrimalRowIDs[i]));
-               _compSolver.changeBounds(_decompDualColIDs[i], 0.0, R(infinity));
-               break;
-
-            default:
-               throw SPxInternalCodeException("XDECOMPSL01 This should never happen.");
-            }
+      }
 
-#else // 22.06.2015 testing keeping all rows in the complementary problem
-            colsforremoval[ncolsforremoval] = _compSolver.number(SPxColId(_decompDualColIDs[i]));
-            ncolsforremoval++;
+      // assert(i + 1 == prevPrimalRowIds || _decompPrimalRowIDs[i].idx !=
+      // _decompPrimalRowIDs[i+1].idx);
 
-            if(_nElimPrimalRows >= _decompElimPrimalRowIDs.size())
-               _decompElimPrimalRowIDs.reSize(_realLP->nRows());
+      int solverRowNum = _solver.number(_decompReducedProbRowIDs[rowNumber]);
+      assert(solverRowNum >= 0 && solverRowNum < _solver.nRows());
+
+      if (_solver.basis().desc().rowStatus(solverRowNum) ==
+              SPxBasisBase<R>::Desc::P_ON_UPPER ||
+          _solver.basis().desc().rowStatus(solverRowNum) ==
+              SPxBasisBase<R>::Desc::P_FIXED ||
+          _solver.basis().desc().rowStatus(solverRowNum) ==
+              SPxBasisBase<R>::Desc::D_FREE ||
+          (_solver.basis().desc().rowStatus(solverRowNum) ==
+               SPxBasisBase<R>::Desc::D_ON_LOWER &&
+           LE(_solver.rhs(solverRowNum) - _solver.pVec()[solverRowNum], R(0.0),
+              feastol))) {
+        // assert(GT(dualVector[solverRowNum], 0.0));
+        _compSolver.changeObj(_decompDualColIDs[i],
+                              _realLP->rhs(SPxRowId(_decompPrimalRowIDs[i])));
+        _compSolver.changeBounds(_decompDualColIDs[i], R(-infinity),
+                                 R(infinity));
+      } else if (_solver.basis().desc().rowStatus(solverRowNum) ==
+                     SPxBasisBase<R>::Desc::P_ON_LOWER ||
+                 (_solver.basis().desc().rowStatus(solverRowNum) ==
+                      SPxBasisBase<R>::Desc::D_ON_UPPER &&
+                  LE(_solver.pVec()[solverRowNum] - _solver.lhs(solverRowNum),
+                     R(0.0), feastol))) {
+        // assert(LT(dualVector[solverRowNum], 0.0));
+        _compSolver.changeObj(_decompDualColIDs[i],
+                              _realLP->lhs(SPxRowId(_decompPrimalRowIDs[i])));
+        _compSolver.changeBounds(_decompDualColIDs[i], R(-infinity),
+                                 R(infinity));
+      } else // if ( _solver.basis().desc().rowStatus(solverRowNum) !=
+             // SPxBasisBase<R>::Desc::D_FREE )
+      {
+        // assert(isZero(dualVector[solverRowNum], 0.0));
 
-            _decompElimPrimalRowIDs[_nElimPrimalRows] = _decompPrimalRowIDs[i];
-            _nElimPrimalRows++;
-            _decompPrimalRowIDs.remove(i);
-            _nPrimalRows--;
-            _decompDualColIDs.remove(i);
-            _nDualCols--;
+        // 22.06.2015 Testing keeping all rows in the complementary problem
+#ifdef KEEP_ALL_ROWS_IN_COMP_PROB
+        switch (_realLP->rowType(_decompPrimalRowIDs[i])) {
+        case LPRowBase<R>::RANGE:
+          assert(_realLP->number(SPxColId(_decompPrimalRowIDs[i])) ==
+                 _realLP->number(SPxColId(_decompPrimalRowIDs[i + 1])));
+          assert(_compSolver.obj(
+                     _compSolver.number(SPxColId(_decompDualColIDs[i]))) !=
+                 _compSolver.obj(
+                     _compSolver.number(SPxColId(_decompDualColIDs[i + 1]))));
+
+          _compSolver.changeObj(_decompDualColIDs[i],
+                                _realLP->rhs(_decompPrimalRowIDs[i]));
+          _compSolver.changeBounds(_decompDualColIDs[i], 0.0, R(infinity));
+          _compSolver.changeObj(_decompDualColIDs[i + 1],
+                                _realLP->lhs(_decompPrimalRowIDs[i]));
+          _compSolver.changeBounds(_decompDualColIDs[i + 1], R(-infinity), 0.0);
+
+          i++;
+          break;
+
+        case LPRowBase<R>::GREATER_EQUAL:
+          _compSolver.changeObj(_decompDualColIDs[i],
+                                _realLP->lhs(_decompPrimalRowIDs[i]));
+          _compSolver.changeBounds(_decompDualColIDs[i], R(-infinity), 0.0);
+          break;
+
+        case LPRowBase<R>::LESS_EQUAL:
+          _compSolver.changeObj(_decompDualColIDs[i],
+                                _realLP->rhs(_decompPrimalRowIDs[i]));
+          _compSolver.changeBounds(_decompDualColIDs[i], 0.0, R(infinity));
+          break;
+
+        default:
+          throw SPxInternalCodeException(
+              "XDECOMPSL01 This should never happen.");
+        }
 
-            i--;
-            prevPrimalRowIds--;
+#else // 22.06.2015 testing keeping all rows in the complementary problem
+        colsforremoval[ncolsforremoval] =
+            _compSolver.number(SPxColId(_decompDualColIDs[i]));
+        ncolsforremoval++;
+
+        if (_nElimPrimalRows >= _decompElimPrimalRowIDs.size())
+          _decompElimPrimalRowIDs.reSize(_realLP->nRows());
+
+        _decompElimPrimalRowIDs[_nElimPrimalRows] = _decompPrimalRowIDs[i];
+        _nElimPrimalRows++;
+        _decompPrimalRowIDs.remove(i);
+        _nPrimalRows--;
+        _decompDualColIDs.remove(i);
+        _nDualCols--;
+
+        i--;
+        prevPrimalRowIds--;
 #endif
-         }
+      }
 
 #ifdef KEEP_ALL_ROWS_IN_COMP_PROB
 
-         if(incrementI)
-            i++;
+      if (incrementI)
+        i++;
 
 #endif
+    } else {
+      switch (_realLP->rowType(_decompPrimalRowIDs[i])) {
+      case LPRowBase<R>::RANGE:
+        assert(_realLP->number(SPxColId(_decompPrimalRowIDs[i])) ==
+               _realLP->number(SPxColId(_decompPrimalRowIDs[i + 1])));
+        assert(_compSolver.obj(
+                   _compSolver.number(SPxColId(_decompDualColIDs[i]))) !=
+               _compSolver.obj(
+                   _compSolver.number(SPxColId(_decompDualColIDs[i + 1]))));
+
+        if (_compSolver.obj(
+                _compSolver.number(SPxColId(_decompDualColIDs[i]))) <
+            _compSolver.obj(
+                _compSolver.number(SPxColId(_decompDualColIDs[i + 1])))) {
+          slackRowCoeff.add(_compSolver.number(SPxColId(_decompDualColIDs[i])),
+                            -SLACKCOEFF);
+          slackRowCoeff.add(
+              _compSolver.number(SPxColId(_decompDualColIDs[i + 1])),
+              SLACKCOEFF);
+        } else {
+          slackRowCoeff.add(_compSolver.number(SPxColId(_decompDualColIDs[i])),
+                            SLACKCOEFF);
+          slackRowCoeff.add(
+              _compSolver.number(SPxColId(_decompDualColIDs[i + 1])),
+              -SLACKCOEFF);
+        }
+
+        i++;
+        break;
+
+      case LPRowBase<R>::EQUAL:
+        assert(_realLP->number(SPxColId(_decompPrimalRowIDs[i])) ==
+               _realLP->number(SPxColId(_decompPrimalRowIDs[i + 1])));
+
+        slackRowCoeff.add(_compSolver.number(SPxColId(_decompDualColIDs[i])),
+                          SLACKCOEFF);
+        slackRowCoeff.add(
+            _compSolver.number(SPxColId(_decompDualColIDs[i + 1])), SLACKCOEFF);
+
+        i++;
+        break;
+
+      case LPRowBase<R>::GREATER_EQUAL:
+        slackRowCoeff.add(_compSolver.number(SPxColId(_decompDualColIDs[i])),
+                          -SLACKCOEFF);
+        break;
+
+      case LPRowBase<R>::LESS_EQUAL:
+        slackRowCoeff.add(_compSolver.number(SPxColId(_decompDualColIDs[i])),
+                          SLACKCOEFF);
+        break;
+
+      default:
+        throw SPxInternalCodeException("XDECOMPSL01 This should never happen.");
       }
-      else
-      {
-         switch(_realLP->rowType(_decompPrimalRowIDs[i]))
-         {
-         case LPRowBase<R>::RANGE:
-            assert(_realLP->number(SPxColId(_decompPrimalRowIDs[i])) ==
-                   _realLP->number(SPxColId(_decompPrimalRowIDs[i + 1])));
-            assert(_compSolver.obj(_compSolver.number(SPxColId(_decompDualColIDs[i]))) !=
-                   _compSolver.obj(_compSolver.number(SPxColId(_decompDualColIDs[i + 1]))));
-
-            if(_compSolver.obj(_compSolver.number(SPxColId(_decompDualColIDs[i]))) <
-                  _compSolver.obj(_compSolver.number(SPxColId(_decompDualColIDs[i + 1]))))
-            {
-               slackRowCoeff.add(_compSolver.number(SPxColId(_decompDualColIDs[i])), -SLACKCOEFF);
-               slackRowCoeff.add(_compSolver.number(SPxColId(_decompDualColIDs[i + 1])), SLACKCOEFF);
-            }
-            else
-            {
-               slackRowCoeff.add(_compSolver.number(SPxColId(_decompDualColIDs[i])), SLACKCOEFF);
-               slackRowCoeff.add(_compSolver.number(SPxColId(_decompDualColIDs[i + 1])), -SLACKCOEFF);
-            }
-
-
-            i++;
-            break;
-
-         case LPRowBase<R>::EQUAL:
-            assert(_realLP->number(SPxColId(_decompPrimalRowIDs[i])) ==
-                   _realLP->number(SPxColId(_decompPrimalRowIDs[i + 1])));
-
-            slackRowCoeff.add(_compSolver.number(SPxColId(_decompDualColIDs[i])), SLACKCOEFF);
-            slackRowCoeff.add(_compSolver.number(SPxColId(_decompDualColIDs[i + 1])), SLACKCOEFF);
-
-            i++;
-            break;
-
-         case LPRowBase<R>::GREATER_EQUAL:
-            slackRowCoeff.add(_compSolver.number(SPxColId(_decompDualColIDs[i])), -SLACKCOEFF);
-            break;
-
-         case LPRowBase<R>::LESS_EQUAL:
-            slackRowCoeff.add(_compSolver.number(SPxColId(_decompDualColIDs[i])), SLACKCOEFF);
-            break;
-
-         default:
-            throw SPxInternalCodeException("XDECOMPSL01 This should never happen.");
-         }
-
-         if(origObj)
-         {
-            int numRemove = 1;
-            int removeCount = 0;
-
-            if(_realLP->number(SPxColId(_decompPrimalRowIDs[i])) ==
-                  _realLP->number(SPxColId(_decompPrimalRowIDs[i + 1])))
-               numRemove++;
-
-            do
-            {
-               colsforremoval[ncolsforremoval] = _compSolver.number(SPxColId(_decompDualColIDs[i]));
-               ncolsforremoval++;
-
-               if(_nElimPrimalRows >= _decompElimPrimalRowIDs.size())
-                  _decompElimPrimalRowIDs.reSize(_realLP->nRows());
-
-               _decompElimPrimalRowIDs[_nElimPrimalRows] = _decompPrimalRowIDs[i];
-               _nElimPrimalRows++;
-               _decompPrimalRowIDs.remove(i);
-               _nPrimalRows--;
-               _decompDualColIDs.remove(i);
-               _nDualCols--;
-
-               i--;
-               prevPrimalRowIds--;
-
-               removeCount++;
-            }
-            while(removeCount < numRemove);
-         }
-      }
-   }
-
-   // updating the slack column in the complementary problem
-   R lhs = 1.0;
-   R rhs = 1.0;
-
-   // it is possible that all rows are included in the reduced problem. In this case, the slack row will be empty. To
-   // avoid infeasibility, the lhs and rhs are set to 0.
-   if(slackRowCoeff.size() == 0)
-   {
-      lhs = 0.0;
-      rhs = 0.0;
-   }
 
-   LPRowBase<R> compSlackRow(lhs, slackRowCoeff, rhs);
-   _compSolver.changeRow(_compSlackDualRowId, compSlackRow);
+      if (origObj) {
+        int numRemove = 1;
+        int removeCount = 0;
 
+        if (_realLP->number(SPxColId(_decompPrimalRowIDs[i])) ==
+            _realLP->number(SPxColId(_decompPrimalRowIDs[i + 1])))
+          numRemove++;
 
-   // if the original objective is used, then all dual columns related to primal rows not in the reduced problem are
-   // removed from the complementary problem.
-   // As a result, the slack row becomes an empty row.
-   int* perm = 0;
-   spx_alloc(perm, _compSolver.nCols() + numElimColsAdded);
-   _compSolver.removeCols(colsforremoval, ncolsforremoval, perm);
+        do {
+          colsforremoval[ncolsforremoval] =
+              _compSolver.number(SPxColId(_decompDualColIDs[i]));
+          ncolsforremoval++;
 
+          if (_nElimPrimalRows >= _decompElimPrimalRowIDs.size())
+            _decompElimPrimalRowIDs.reSize(_realLP->nRows());
 
-   // updating the dual columns to represent the fixed primal variables.
-   int* currFixedVars = 0;
-   spx_alloc(currFixedVars, _realLP->nCols());
-   _identifyComplementaryDualFixedPrimalVars(currFixedVars);
-   _removeComplementaryDualFixedPrimalVars(currFixedVars);
-   _updateComplementaryDualFixedPrimalVars(currFixedVars);
+          _decompElimPrimalRowIDs[_nElimPrimalRows] = _decompPrimalRowIDs[i];
+          _nElimPrimalRows++;
+          _decompPrimalRowIDs.remove(i);
+          _nPrimalRows--;
+          _decompDualColIDs.remove(i);
+          _nDualCols--;
 
+          i--;
+          prevPrimalRowIds--;
 
-   // freeing allocated memory
-   spx_free(currFixedVars);
-   spx_free(perm);
-   spx_free(colsforremoval);
+          removeCount++;
+        } while (removeCount < numRemove);
+      }
+    }
+  }
+
+  // updating the slack column in the complementary problem
+  R lhs = 1.0;
+  R rhs = 1.0;
+
+  // it is possible that all rows are included in the reduced problem. In this
+  // case, the slack row will be empty. To avoid infeasibility, the lhs and rhs
+  // are set to 0.
+  if (slackRowCoeff.size() == 0) {
+    lhs = 0.0;
+    rhs = 0.0;
+  }
+
+  LPRowBase<R> compSlackRow(lhs, slackRowCoeff, rhs);
+  _compSolver.changeRow(_compSlackDualRowId, compSlackRow);
+
+  // if the original objective is used, then all dual columns related to primal
+  // rows not in the reduced problem are removed from the complementary problem.
+  // As a result, the slack row becomes an empty row.
+  int *perm = 0;
+  spx_alloc(perm, _compSolver.nCols() + numElimColsAdded);
+  _compSolver.removeCols(colsforremoval, ncolsforremoval, perm);
+
+  // updating the dual columns to represent the fixed primal variables.
+  int *currFixedVars = 0;
+  spx_alloc(currFixedVars, _realLP->nCols());
+  _identifyComplementaryDualFixedPrimalVars(currFixedVars);
+  _removeComplementaryDualFixedPrimalVars(currFixedVars);
+  _updateComplementaryDualFixedPrimalVars(currFixedVars);
+
+  // freeing allocated memory
+  spx_free(currFixedVars);
+  spx_free(perm);
+  spx_free(colsforremoval);
 }
 
-
-
 /// update the primal complementary problem with additional columns and rows
-// Given the solution to the updated reduced problem, the complementary problem will be updated with modifications to
-// the constraints and the removal of variables
+// Given the solution to the updated reduced problem, the complementary problem
+// will be updated with modifications to the constraints and the removal of
+// variables
 template <class R>
-void SoPlexBase<R>::_updateDecompComplementaryPrimalProblem(bool origObj)
-{
-   R feastol = realParam(SoPlexBase<R>::FEASTOL);
-
-   int prevNumRows = _compSolver.nRows();
-   int prevPrimalRowIds = _nPrimalRows;
-
-   assert(_nPrimalRows == _nCompPrimalRows);
-
-   LPRowSetBase<R> addElimRows(_nElimPrimalRows);  // rows previously eliminated from the
-   // complementary problem that must be added
-   int numElimRowsAdded = 0;
-   // looping over all rows from the original LP that were eliminated during the formation of the complementary
-   // problem. The eliminated rows will be added if they are basic in the reduced problem.
-
-   for(int i = 0; i < _nElimPrimalRows; i++)
-   {
-      int rowNumber = _realLP->number(_decompElimPrimalRowIDs[i]);
-
-      int solverRowNum = _solver.number(_decompReducedProbRowIDs[rowNumber]);
-      assert(solverRowNum >= 0 && solverRowNum < _solver.nRows());
-
-      // checking the rows that are basic in the reduced problem that should be added to the complementary problem
-      if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_ON_UPPER
-            || _solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_ON_LOWER
-            || _solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_FIXED
-            || _solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_FREE
-            || (_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_ON_LOWER &&
-                EQ(_solver.rhs(solverRowNum) - _solver.pVec()[solverRowNum], R(0.0), feastol))
-            || (_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_ON_UPPER &&
-                EQ(_solver.pVec()[solverRowNum] - _solver.lhs(solverRowNum), R(0.0), feastol)))
-      {
-         LPRowBase<R> origlprow;
-         _realLP->getRow(rowNumber, origlprow);
-
-         // NOTE: 11.02.2016 I am assuming that all columns from the original problem are contained in the
-         // complementary problem. Will need to check this. Since nothing is happenning in the
-         // _deleteAndUpdateRowsComplementaryProblem function, I am feeling confident that all columns remain.
-
-
-         if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_ON_UPPER
-               || _solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_FIXED
-               || _solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_FREE
-               || (_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_ON_LOWER &&
-                   EQ(_solver.rhs(solverRowNum) - _solver.pVec()[solverRowNum], R(0.0), feastol)))
-         {
-            assert(LT(_realLP->rhs(_decompElimPrimalRowIDs[i]), R(infinity)));
-
-            if(_nPrimalRows >= _decompPrimalRowIDs.size())
-            {
-               _decompPrimalRowIDs.reSize(_nPrimalRows * 2);
-               _decompCompPrimalRowIDs.reSize(_nPrimalRows * 2);
-            }
-
-            addElimRows.add(_realLP->rhs(_decompElimPrimalRowIDs[i]), origlprow.rowVector(),
-                            _realLP->rhs(_decompElimPrimalRowIDs[i]));
-
-            _decompPrimalRowIDs[_nPrimalRows] = _decompElimPrimalRowIDs[i];
-            _nPrimalRows++;
-
-            _decompElimPrimalRowIDs.remove(i);
-            _nElimPrimalRows--;
-            i--;
-
-            numElimRowsAdded++;
-         }
-         else if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_ON_LOWER
-                 || (_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_ON_UPPER &&
-                     EQ(_solver.pVec()[solverRowNum] - _solver.lhs(solverRowNum), R(0.0), feastol)))
-         {
-            assert(GT(_realLP->lhs(_decompElimPrimalRowIDs[i]), R(-infinity)));
-
-            if(_nPrimalRows >= _decompPrimalRowIDs.size())
-            {
-               _decompPrimalRowIDs.reSize(_nPrimalRows * 2);
-               _decompCompPrimalRowIDs.reSize(_nPrimalRows * 2);
-            }
-
-            addElimRows.add(_realLP->lhs(_decompElimPrimalRowIDs[i]), origlprow.rowVector(),
-                            _realLP->lhs(_decompElimPrimalRowIDs[i]));
-
-            _decompPrimalRowIDs[_nPrimalRows] = _decompElimPrimalRowIDs[i];
-            _nPrimalRows++;
-
-            _decompElimPrimalRowIDs.remove(i);
-            _nElimPrimalRows--;
-            i--;
-
-            numElimRowsAdded++;
-         }
+void SoPlexBase<R>::_updateDecompComplementaryPrimalProblem(bool origObj) {
+  R feastol = realParam(SoPlexBase<R>::FEASTOL);
+
+  int prevNumRows = _compSolver.nRows();
+  int prevPrimalRowIds = _nPrimalRows;
+
+  assert(_nPrimalRows == _nCompPrimalRows);
+
+  LPRowSetBase<R> addElimRows(
+      _nElimPrimalRows); // rows previously eliminated from the
+  // complementary problem that must be added
+  int numElimRowsAdded = 0;
+  // looping over all rows from the original LP that were eliminated during the
+  // formation of the complementary problem. The eliminated rows will be added
+  // if they are basic in the reduced problem.
+
+  for (int i = 0; i < _nElimPrimalRows; i++) {
+    int rowNumber = _realLP->number(_decompElimPrimalRowIDs[i]);
+
+    int solverRowNum = _solver.number(_decompReducedProbRowIDs[rowNumber]);
+    assert(solverRowNum >= 0 && solverRowNum < _solver.nRows());
+
+    // checking the rows that are basic in the reduced problem that should be
+    // added to the complementary problem
+    if (_solver.basis().desc().rowStatus(solverRowNum) ==
+            SPxBasisBase<R>::Desc::P_ON_UPPER ||
+        _solver.basis().desc().rowStatus(solverRowNum) ==
+            SPxBasisBase<R>::Desc::P_ON_LOWER ||
+        _solver.basis().desc().rowStatus(solverRowNum) ==
+            SPxBasisBase<R>::Desc::P_FIXED ||
+        _solver.basis().desc().rowStatus(solverRowNum) ==
+            SPxBasisBase<R>::Desc::D_FREE ||
+        (_solver.basis().desc().rowStatus(solverRowNum) ==
+             SPxBasisBase<R>::Desc::D_ON_LOWER &&
+         EQ(_solver.rhs(solverRowNum) - _solver.pVec()[solverRowNum], R(0.0),
+            feastol)) ||
+        (_solver.basis().desc().rowStatus(solverRowNum) ==
+             SPxBasisBase<R>::Desc::D_ON_UPPER &&
+         EQ(_solver.pVec()[solverRowNum] - _solver.lhs(solverRowNum), R(0.0),
+            feastol))) {
+      LPRowBase<R> origlprow;
+      _realLP->getRow(rowNumber, origlprow);
+
+      // NOTE: 11.02.2016 I am assuming that all columns from the original
+      // problem are contained in the complementary problem. Will need to check
+      // this. Since nothing is happenning in the
+      // _deleteAndUpdateRowsComplementaryProblem function, I am feeling
+      // confident that all columns remain.
+
+      if (_solver.basis().desc().rowStatus(solverRowNum) ==
+              SPxBasisBase<R>::Desc::P_ON_UPPER ||
+          _solver.basis().desc().rowStatus(solverRowNum) ==
+              SPxBasisBase<R>::Desc::P_FIXED ||
+          _solver.basis().desc().rowStatus(solverRowNum) ==
+              SPxBasisBase<R>::Desc::D_FREE ||
+          (_solver.basis().desc().rowStatus(solverRowNum) ==
+               SPxBasisBase<R>::Desc::D_ON_LOWER &&
+           EQ(_solver.rhs(solverRowNum) - _solver.pVec()[solverRowNum], R(0.0),
+              feastol))) {
+        assert(LT(_realLP->rhs(_decompElimPrimalRowIDs[i]), R(infinity)));
+
+        if (_nPrimalRows >= _decompPrimalRowIDs.size()) {
+          _decompPrimalRowIDs.reSize(_nPrimalRows * 2);
+          _decompCompPrimalRowIDs.reSize(_nPrimalRows * 2);
+        }
+
+        addElimRows.add(_realLP->rhs(_decompElimPrimalRowIDs[i]),
+                        origlprow.rowVector(),
+                        _realLP->rhs(_decompElimPrimalRowIDs[i]));
+
+        _decompPrimalRowIDs[_nPrimalRows] = _decompElimPrimalRowIDs[i];
+        _nPrimalRows++;
+
+        _decompElimPrimalRowIDs.remove(i);
+        _nElimPrimalRows--;
+        i--;
+
+        numElimRowsAdded++;
+      } else if (_solver.basis().desc().rowStatus(solverRowNum) ==
+                     SPxBasisBase<R>::Desc::P_ON_LOWER ||
+                 (_solver.basis().desc().rowStatus(solverRowNum) ==
+                      SPxBasisBase<R>::Desc::D_ON_UPPER &&
+                  EQ(_solver.pVec()[solverRowNum] - _solver.lhs(solverRowNum),
+                     R(0.0), feastol))) {
+        assert(GT(_realLP->lhs(_decompElimPrimalRowIDs[i]), R(-infinity)));
+
+        if (_nPrimalRows >= _decompPrimalRowIDs.size()) {
+          _decompPrimalRowIDs.reSize(_nPrimalRows * 2);
+          _decompCompPrimalRowIDs.reSize(_nPrimalRows * 2);
+        }
+
+        addElimRows.add(_realLP->lhs(_decompElimPrimalRowIDs[i]),
+                        origlprow.rowVector(),
+                        _realLP->lhs(_decompElimPrimalRowIDs[i]));
+
+        _decompPrimalRowIDs[_nPrimalRows] = _decompElimPrimalRowIDs[i];
+        _nPrimalRows++;
+
+        _decompElimPrimalRowIDs.remove(i);
+        _nElimPrimalRows--;
+        i--;
+
+        numElimRowsAdded++;
       }
-   }
+    }
+  }
 
-   MSG_INFO2(spxout, spxout << "Number of eliminated rows added to the complementary problem: "
+  MSG_INFO2(
+      spxout,
+      spxout << "Number of eliminated rows added to the complementary problem: "
              << numElimRowsAdded << std::endl);
 
-   // adding the eliminated rows to the complementary problem.
-   _compSolver.addRows(addElimRows);
-
-   for(int i = prevNumRows; i < _compSolver.nRows(); i++)
-   {
-      _decompCompPrimalRowIDs[prevPrimalRowIds + i - prevNumRows] = _compSolver.rowId(i);
-      _nCompPrimalRows++;
-   }
-
-   assert(_nPrimalRows == _nCompPrimalRows);
+  // adding the eliminated rows to the complementary problem.
+  _compSolver.addRows(addElimRows);
+
+  for (int i = prevNumRows; i < _compSolver.nRows(); i++) {
+    _decompCompPrimalRowIDs[prevPrimalRowIds + i - prevNumRows] =
+        _compSolver.rowId(i);
+    _nCompPrimalRows++;
+  }
+
+  assert(_nPrimalRows == _nCompPrimalRows);
+
+  // looping over all rows from the original problem that were originally
+  // contained in the complementary problem. The basic rows will be set as
+  // equalities, the non-basic rows will be eliminated from the complementary
+  // problem.
+  DSVectorBase<R> slackColCoeff(_compSolver.nRows());
+
+  int *rowsforremoval = 0;
+  int nrowsforremoval = 0;
+  spx_alloc(rowsforremoval, prevPrimalRowIds);
+
+  for (int i = 0; i < prevPrimalRowIds; i++) {
+    int rowNumber = _realLP->number(_decompPrimalRowIDs[i]);
+
+    // this loop runs over all rows previously in the complementary problem. If
+    // rows are added to the reduced problem, they will be transfered from the
+    // incompatible set to the compatible set in the following if statement.
+    if (_decompReducedProbRows[rowNumber]) {
+      // rows added to the reduced problem may have been equality constriants.
+      // The equality constraints from the original problem are converted into
+      // <= and >= constraints. Upon adding these constraints to the reduced
+      // problem, only a single dual column is needed in the complementary
+      // problem. Hence, one of the dual columns is removed.
+      //
 
+      int solverRowNum = _solver.number(_decompReducedProbRowIDs[rowNumber]);
+      assert(solverRowNum >= 0 && solverRowNum < _solver.nRows());
 
-   // looping over all rows from the original problem that were originally contained in the complementary problem.
-   // The basic rows will be set as equalities, the non-basic rows will be eliminated from the complementary
-   // problem.
-   DSVectorBase<R> slackColCoeff(_compSolver.nRows());
-
-   int* rowsforremoval = 0;
-   int nrowsforremoval = 0;
-   spx_alloc(rowsforremoval, prevPrimalRowIds);
-
-   for(int i = 0; i < prevPrimalRowIds; i++)
-   {
-      int rowNumber = _realLP->number(_decompPrimalRowIDs[i]);
-
-      // this loop runs over all rows previously in the complementary problem. If rows are added to the reduced
-      // problem, they will be transfered from the incompatible set to the compatible set in the following if
-      // statement.
-      if(_decompReducedProbRows[rowNumber])
+      if (_solver.basis().desc().rowStatus(solverRowNum) ==
+              SPxBasisBase<R>::Desc::P_ON_UPPER ||
+          _solver.basis().desc().rowStatus(solverRowNum) ==
+              SPxBasisBase<R>::Desc::P_FIXED ||
+          _solver.basis().desc().rowStatus(solverRowNum) ==
+              SPxBasisBase<R>::Desc::D_FREE ||
+          (_solver.basis().desc().rowStatus(solverRowNum) ==
+               SPxBasisBase<R>::Desc::D_ON_LOWER &&
+           EQ(_solver.rhs(solverRowNum) - _solver.pVec()[solverRowNum], R(0.0),
+              feastol))) {
+        _compSolver.changeLhs(_decompCompPrimalRowIDs[i],
+                              _realLP->rhs(SPxRowId(_decompPrimalRowIDs[i])));
+        // need to also update the RHS because a ranged row could have
+        // previously been fixed to LOWER
+        _compSolver.changeRhs(_decompCompPrimalRowIDs[i],
+                              _realLP->rhs(SPxRowId(_decompPrimalRowIDs[i])));
+      } else if (_solver.basis().desc().rowStatus(solverRowNum) ==
+                     SPxBasisBase<R>::Desc::P_ON_LOWER ||
+                 (_solver.basis().desc().rowStatus(solverRowNum) ==
+                      SPxBasisBase<R>::Desc::D_ON_UPPER &&
+                  EQ(_solver.pVec()[solverRowNum] - _solver.lhs(solverRowNum),
+                     R(0.0), feastol))) {
+        _compSolver.changeRhs(_decompCompPrimalRowIDs[i],
+                              _realLP->lhs(SPxRowId(_decompPrimalRowIDs[i])));
+        // need to also update the LHS because a ranged row could have
+        // previously been fixed to UPPER
+        _compSolver.changeLhs(_decompCompPrimalRowIDs[i],
+                              _realLP->lhs(SPxRowId(_decompPrimalRowIDs[i])));
+      } else // if ( _solver.basis().desc().rowStatus(solverRowNum) !=
+             // SPxBasisBase<R>::Desc::D_FREE )
       {
-         // rows added to the reduced problem may have been equality constriants. The equality constraints from the
-         // original problem are converted into <= and >= constraints. Upon adding these constraints to the reduced
-         // problem, only a single dual column is needed in the complementary problem. Hence, one of the dual columns
-         // is removed.
-         //
-
-         int solverRowNum = _solver.number(_decompReducedProbRowIDs[rowNumber]);
-         assert(solverRowNum >= 0 && solverRowNum < _solver.nRows());
-
-         if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_ON_UPPER
-               || _solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_FIXED
-               || _solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_FREE
-               || (_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_ON_LOWER &&
-                   EQ(_solver.rhs(solverRowNum) - _solver.pVec()[solverRowNum], R(0.0), feastol)))
-         {
-            _compSolver.changeLhs(_decompCompPrimalRowIDs[i], _realLP->rhs(SPxRowId(_decompPrimalRowIDs[i])));
-            // need to also update the RHS because a ranged row could have previously been fixed to LOWER
-            _compSolver.changeRhs(_decompCompPrimalRowIDs[i], _realLP->rhs(SPxRowId(_decompPrimalRowIDs[i])));
-         }
-         else if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_ON_LOWER
-                 || (_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_ON_UPPER &&
-                     EQ(_solver.pVec()[solverRowNum] - _solver.lhs(solverRowNum), R(0.0), feastol)))
-         {
-            _compSolver.changeRhs(_decompCompPrimalRowIDs[i], _realLP->lhs(SPxRowId(_decompPrimalRowIDs[i])));
-            // need to also update the LHS because a ranged row could have previously been fixed to UPPER
-            _compSolver.changeLhs(_decompCompPrimalRowIDs[i], _realLP->lhs(SPxRowId(_decompPrimalRowIDs[i])));
-         }
-         else //if ( _solver.basis().desc().rowStatus(solverRowNum) != SPxBasisBase<R>::Desc::D_FREE )
-         {
-            rowsforremoval[nrowsforremoval] = _compSolver.number(SPxRowId(_decompCompPrimalRowIDs[i]));
-            nrowsforremoval++;
-
-            if(_nElimPrimalRows >= _decompElimPrimalRowIDs.size())
-               _decompElimPrimalRowIDs.reSize(_realLP->nRows());
-
-            _decompElimPrimalRowIDs[_nElimPrimalRows] = _decompPrimalRowIDs[i];
-            _nElimPrimalRows++;
-            _decompPrimalRowIDs.remove(i);
-            _nPrimalRows--;
-            _decompCompPrimalRowIDs.remove(i);
-            _nCompPrimalRows--;
-
-            i--;
-            prevPrimalRowIds--;
-         }
+        rowsforremoval[nrowsforremoval] =
+            _compSolver.number(SPxRowId(_decompCompPrimalRowIDs[i]));
+        nrowsforremoval++;
+
+        if (_nElimPrimalRows >= _decompElimPrimalRowIDs.size())
+          _decompElimPrimalRowIDs.reSize(_realLP->nRows());
+
+        _decompElimPrimalRowIDs[_nElimPrimalRows] = _decompPrimalRowIDs[i];
+        _nElimPrimalRows++;
+        _decompPrimalRowIDs.remove(i);
+        _nPrimalRows--;
+        _decompCompPrimalRowIDs.remove(i);
+        _nCompPrimalRows--;
+
+        i--;
+        prevPrimalRowIds--;
       }
-      else
-      {
-         switch(_compSolver.rowType(_decompCompPrimalRowIDs[i]))
-         {
-         case LPRowBase<R>::RANGE:
-            assert(false);
-            break;
-
-         case LPRowBase<R>::EQUAL:
-            assert(false);
-            break;
-
-         case LPRowBase<R>::LESS_EQUAL:
-            slackColCoeff.add(_compSolver.number(SPxRowId(_decompCompPrimalRowIDs[i])), -SLACKCOEFF);
-            break;
-
-         case LPRowBase<R>::GREATER_EQUAL:
-            slackColCoeff.add(_compSolver.number(SPxRowId(_decompCompPrimalRowIDs[i])), SLACKCOEFF);
-            break;
-
-         default:
-            throw SPxInternalCodeException("XDECOMPSL01 This should never happen.");
-         }
-
-         // this is used as a check at the end of the algorithm. If the original objective function is used, then we
-         // need to remove all unfixed variables.
-         if(origObj)
-         {
-            rowsforremoval[nrowsforremoval] = _compSolver.number(SPxRowId(_decompCompPrimalRowIDs[i]));
-            nrowsforremoval++;
-
-            if(_nElimPrimalRows >= _decompElimPrimalRowIDs.size())
-               _decompElimPrimalRowIDs.reSize(_realLP->nRows());
-
-            _decompElimPrimalRowIDs[_nElimPrimalRows] = _decompPrimalRowIDs[i];
-            _nElimPrimalRows++;
-            _decompPrimalRowIDs.remove(i);
-            _nPrimalRows--;
-            _decompCompPrimalRowIDs.remove(i);
-            _nCompPrimalRows--;
-
-            i--;
-            prevPrimalRowIds--;
-         }
+    } else {
+      switch (_compSolver.rowType(_decompCompPrimalRowIDs[i])) {
+      case LPRowBase<R>::RANGE:
+        assert(false);
+        break;
+
+      case LPRowBase<R>::EQUAL:
+        assert(false);
+        break;
+
+      case LPRowBase<R>::LESS_EQUAL:
+        slackColCoeff.add(
+            _compSolver.number(SPxRowId(_decompCompPrimalRowIDs[i])),
+            -SLACKCOEFF);
+        break;
+
+      case LPRowBase<R>::GREATER_EQUAL:
+        slackColCoeff.add(
+            _compSolver.number(SPxRowId(_decompCompPrimalRowIDs[i])),
+            SLACKCOEFF);
+        break;
+
+      default:
+        throw SPxInternalCodeException("XDECOMPSL01 This should never happen.");
       }
-   }
-
-   // updating the slack column in the complementary problem
-   LPColBase<R> compSlackCol(-1, slackColCoeff, R(infinity), 0.0);
-   _compSolver.changeCol(_compSlackColId, compSlackCol);
-
-
-   // if the original objective is used, then all complementary rows related to primal rows not in the reduced problem are
-   // removed from the complementary problem.
-   // As a result, the slack column becomes an empty column.
-   int* perm = 0;
-   spx_alloc(perm, _compSolver.nRows() + numElimRowsAdded);
-   _compSolver.removeRows(rowsforremoval, nrowsforremoval, perm);
-
-   // updating the dual columns to represent the fixed primal variables.
-   int* currFixedVars = 0;
-   spx_alloc(currFixedVars, _realLP->nCols());
-   _identifyComplementaryPrimalFixedPrimalVars(currFixedVars);
-   _updateComplementaryPrimalFixedPrimalVars(currFixedVars);
-
 
-   // freeing allocated memory
-   spx_free(currFixedVars);
-   spx_free(perm);
-   spx_free(rowsforremoval);
+      // this is used as a check at the end of the algorithm. If the original
+      // objective function is used, then we need to remove all unfixed
+      // variables.
+      if (origObj) {
+        rowsforremoval[nrowsforremoval] =
+            _compSolver.number(SPxRowId(_decompCompPrimalRowIDs[i]));
+        nrowsforremoval++;
+
+        if (_nElimPrimalRows >= _decompElimPrimalRowIDs.size())
+          _decompElimPrimalRowIDs.reSize(_realLP->nRows());
+
+        _decompElimPrimalRowIDs[_nElimPrimalRows] = _decompPrimalRowIDs[i];
+        _nElimPrimalRows++;
+        _decompPrimalRowIDs.remove(i);
+        _nPrimalRows--;
+        _decompCompPrimalRowIDs.remove(i);
+        _nCompPrimalRows--;
+
+        i--;
+        prevPrimalRowIds--;
+      }
+    }
+  }
+
+  // updating the slack column in the complementary problem
+  LPColBase<R> compSlackCol(-1, slackColCoeff, R(infinity), 0.0);
+  _compSolver.changeCol(_compSlackColId, compSlackCol);
+
+  // if the original objective is used, then all complementary rows related to
+  // primal rows not in the reduced problem are removed from the complementary
+  // problem. As a result, the slack column becomes an empty column.
+  int *perm = 0;
+  spx_alloc(perm, _compSolver.nRows() + numElimRowsAdded);
+  _compSolver.removeRows(rowsforremoval, nrowsforremoval, perm);
+
+  // updating the dual columns to represent the fixed primal variables.
+  int *currFixedVars = 0;
+  spx_alloc(currFixedVars, _realLP->nCols());
+  _identifyComplementaryPrimalFixedPrimalVars(currFixedVars);
+  _updateComplementaryPrimalFixedPrimalVars(currFixedVars);
+
+  // freeing allocated memory
+  spx_free(currFixedVars);
+  spx_free(perm);
+  spx_free(rowsforremoval);
 }
 
-
-
 /// checking the optimality of the original problem.
-// this function is called if the complementary problem is solved with a non-negative objective value. This implies
-// that the rows currently included in the reduced problem are sufficient to identify the optimal solution to the
+// this function is called if the complementary problem is solved with a
+// non-negative objective value. This implies that the rows currently included
+// in the reduced problem are sufficient to identify the optimal solution to the
 // original problem.
 template <class R>
-void SoPlexBase<R>::_checkOriginalProblemOptimality(VectorBase<R> primalVector, bool printViol)
-{
-   SSVectorBase<R>  x(_solver.nCols());
-   x.unSetup();
-
-   // multiplying the solution vector of the reduced problem with the transformed basis to identify the original
-   // solution vector.
-   _decompTransBasis.coSolve(x, primalVector);
-
-   if(printViol)
-   {
-      MSG_INFO1(spxout, spxout << std::endl
-                << "Checking consistency between the reduced problem and the original problem." << std::endl);
-   }
-
-
-   // checking the objective function values of the reduced problem and the original problem.
-   R redObjVal = 0;
-   R objectiveVal = 0;
-
-   for(int i = 0; i < _solver.nCols(); i++)
-   {
-      redObjVal += _solver.maxObj(i) * primalVector[i];
-      objectiveVal += _realLP->maxObj(i) * x[i];
-   }
-
-   if(printViol)
-   {
-      MSG_INFO1(spxout, spxout << "Reduced Problem Objective Value: " << redObjVal << std::endl
-                << "Original Problem Objective Value: " << objectiveVal << std::endl);
-   }
-
-   _solReal._isPrimalFeasible = true;
-   _hasSolReal = true;
-   // get the primal solutions from the reduced problem
-   _solReal._primal.reDim(_solver.nCols());
-   _solReal._primal = x;
-
-   R maxviol = 0;
-   R sumviol = 0;
-
-   // checking the bound violations
-   if(getDecompBoundViolation(maxviol, sumviol))
-   {
-      if(printViol)
-         MSG_INFO1(spxout, spxout << "Bound violation - "
-                   << "Max violation: " << maxviol << " Sum violation: " << sumviol << std::endl);
-   }
-
-   _statistics->totalBoundViol = sumviol;
-   _statistics->maxBoundViol = maxviol;
-
-   // checking the row violations
-   if(getDecompRowViolation(maxviol, sumviol))
-   {
-      if(printViol)
-         MSG_INFO1(spxout, spxout << "Row violation - "
-                   << "Max violation: " << maxviol << " Sum violation: " << sumviol << std::endl);
-   }
-
-   _statistics->totalRowViol = sumviol;
-   _statistics->maxRowViol = maxviol;
-
-   if(printViol)
-      MSG_INFO1(spxout, spxout << std::endl);
+void SoPlexBase<R>::_checkOriginalProblemOptimality(VectorBase<R> primalVector,
+                                                    bool printViol) {
+  SSVectorBase<R> x(_solver.nCols());
+  x.unSetup();
+
+  // multiplying the solution vector of the reduced problem with the transformed
+  // basis to identify the original solution vector.
+  _decompTransBasis.coSolve(x, primalVector);
+
+  if (printViol) {
+    MSG_INFO1(spxout, spxout << std::endl
+                             << "Checking consistency between the reduced "
+                                "problem and the original problem."
+                             << std::endl);
+  }
+
+  // checking the objective function values of the reduced problem and the
+  // original problem.
+  R redObjVal = 0;
+  R objectiveVal = 0;
+
+  for (int i = 0; i < _solver.nCols(); i++) {
+    redObjVal += _solver.maxObj(i) * primalVector[i];
+    objectiveVal += _realLP->maxObj(i) * x[i];
+  }
+
+  if (printViol) {
+    MSG_INFO1(spxout, spxout << "Reduced Problem Objective Value: " << redObjVal
+                             << std::endl
+                             << "Original Problem Objective Value: "
+                             << objectiveVal << std::endl);
+  }
+
+  _solReal._isPrimalFeasible = true;
+  _hasSolReal = true;
+  // get the primal solutions from the reduced problem
+  _solReal._primal.reDim(_solver.nCols());
+  _solReal._primal = x;
+
+  R maxviol = 0;
+  R sumviol = 0;
+
+  // checking the bound violations
+  if (getDecompBoundViolation(maxviol, sumviol)) {
+    if (printViol)
+      MSG_INFO1(spxout, spxout << "Bound violation - "
+                               << "Max violation: " << maxviol
+                               << " Sum violation: " << sumviol << std::endl);
+  }
+
+  _statistics->totalBoundViol = sumviol;
+  _statistics->maxBoundViol = maxviol;
+
+  // checking the row violations
+  if (getDecompRowViolation(maxviol, sumviol)) {
+    if (printViol)
+      MSG_INFO1(spxout, spxout << "Row violation - "
+                               << "Max violation: " << maxviol
+                               << " Sum violation: " << sumviol << std::endl);
+  }
+
+  _statistics->totalRowViol = sumviol;
+  _statistics->maxRowViol = maxviol;
+
+  if (printViol)
+    MSG_INFO1(spxout, spxout << std::endl);
 }
 
-
-
 /// updating the slack column coefficients to adjust for equality constraints
-template <class R>
-void SoPlexBase<R>::_updateComplementaryDualSlackColCoeff()
-{
-   // the slack column for the equality constraints is not handled correctly in the dual conversion. Hence, it is
-   // necessary to change the equality coefficients of the dual row related to the slack column.
-   for(int i = 0; i < _nPrimalRows; i++)
-   {
-      int rowNumber = _realLP->number(SPxRowId(_decompPrimalRowIDs[i]));
-
-      if(!_decompReducedProbRows[rowNumber])
-      {
-         if(_realLP->rowType(_decompPrimalRowIDs[i]) == LPRowBase<R>::EQUAL)
-         {
-            assert(_realLP->lhs(_decompPrimalRowIDs[i]) == _realLP->rhs(_decompPrimalRowIDs[i]));
-            _compSolver.changeLower(_decompDualColIDs[i],
-                                    0.0);   // setting the lower bound of the dual column to zero.
-
-            LPColBase<R> addEqualityCol(-_realLP->rhs(_decompPrimalRowIDs[i]),
-                                        R(-1.0)*_compSolver.colVector(_decompDualColIDs[i]), R(infinity),
-                                        0.0);    // adding a new column to the dual
-
-            SPxColId newDualCol;
-            _compSolver.addCol(newDualCol, addEqualityCol);
-
-            // inserting the row and col ids for the added column. This is to be next to the original column that has
-            // been duplicated.
-            _decompPrimalRowIDs.insert(i + 1, 1, _decompPrimalRowIDs[i]);
-            _decompDualColIDs.insert(i + 1, 1, newDualCol);
-            assert(_realLP->number(_decompPrimalRowIDs[i]) == _realLP->number(_decompPrimalRowIDs[i + 1]));
-
-            i++;
-            _nPrimalRows++;
-            _nDualCols++;
-         }
+template <class R> void SoPlexBase<R>::_updateComplementaryDualSlackColCoeff() {
+  // the slack column for the equality constraints is not handled correctly in
+  // the dual conversion. Hence, it is necessary to change the equality
+  // coefficients of the dual row related to the slack column.
+  for (int i = 0; i < _nPrimalRows; i++) {
+    int rowNumber = _realLP->number(SPxRowId(_decompPrimalRowIDs[i]));
+
+    if (!_decompReducedProbRows[rowNumber]) {
+      if (_realLP->rowType(_decompPrimalRowIDs[i]) == LPRowBase<R>::EQUAL) {
+        assert(_realLP->lhs(_decompPrimalRowIDs[i]) ==
+               _realLP->rhs(_decompPrimalRowIDs[i]));
+        _compSolver.changeLower(
+            _decompDualColIDs[i],
+            0.0); // setting the lower bound of the dual column to zero.
+
+        LPColBase<R> addEqualityCol(
+            -_realLP->rhs(_decompPrimalRowIDs[i]),
+            R(-1.0) * _compSolver.colVector(_decompDualColIDs[i]), R(infinity),
+            0.0); // adding a new column to the dual
+
+        SPxColId newDualCol;
+        _compSolver.addCol(newDualCol, addEqualityCol);
+
+        // inserting the row and col ids for the added column. This is to be
+        // next to the original column that has been duplicated.
+        _decompPrimalRowIDs.insert(i + 1, 1, _decompPrimalRowIDs[i]);
+        _decompDualColIDs.insert(i + 1, 1, newDualCol);
+        assert(_realLP->number(_decompPrimalRowIDs[i]) ==
+               _realLP->number(_decompPrimalRowIDs[i + 1]));
+
+        i++;
+        _nPrimalRows++;
+        _nDualCols++;
       }
-   }
+    }
+  }
 }
 
-
-
 /// identify the dual columns related to the fixed variables
 template <class R>
-void SoPlexBase<R>::_identifyComplementaryDualFixedPrimalVars(int* currFixedVars)
-{
-   R feastol = realParam(SoPlexBase<R>::FEASTOL);
-
-   int numFixedVar = 0;
-
-   for(int i = 0; i < _realLP->nCols(); i++)
-   {
-      currFixedVars[i] = 0;
-
-      if(!_decompReducedProbColRowIDs[i].isValid())
-         continue;
-
-      int rowNumber = _solver.number(_decompReducedProbColRowIDs[i]);
-
-      if(_decompReducedProbColRowIDs[i].isValid())
-      {
-         if(_solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::P_ON_UPPER ||
-               _solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::P_ON_LOWER ||
-               _solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::P_FIXED ||
-               _solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::D_FREE)
-         {
-            // setting the value of the _fixedOrigVars array to indicate which variables are at their bounds.
-            currFixedVars[i] = getOrigVarFixedDirection(i);
-
-            numFixedVar++;
-         }
-         else
-         {
-            // the dual flags do not imply anything about the primal status of the rows.
-            if(_solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::D_ON_LOWER &&
-                  EQ(_solver.rhs(rowNumber) - _solver.pVec()[rowNumber], R(0.0), feastol))
-               currFixedVars[i] = 1;
-            else if(_solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::D_ON_UPPER &&
-                    EQ(_solver.pVec()[rowNumber] - _solver.lhs(rowNumber), R(0.0), feastol))
-               currFixedVars[i] = -1;
-         }
+void SoPlexBase<R>::_identifyComplementaryDualFixedPrimalVars(
+    int *currFixedVars) {
+  R feastol = realParam(SoPlexBase<R>::FEASTOL);
+
+  int numFixedVar = 0;
+
+  for (int i = 0; i < _realLP->nCols(); i++) {
+    currFixedVars[i] = 0;
+
+    if (!_decompReducedProbColRowIDs[i].isValid())
+      continue;
+
+    int rowNumber = _solver.number(_decompReducedProbColRowIDs[i]);
+
+    if (_decompReducedProbColRowIDs[i].isValid()) {
+      if (_solver.basis().desc().rowStatus(rowNumber) ==
+              SPxBasisBase<R>::Desc::P_ON_UPPER ||
+          _solver.basis().desc().rowStatus(rowNumber) ==
+              SPxBasisBase<R>::Desc::P_ON_LOWER ||
+          _solver.basis().desc().rowStatus(rowNumber) ==
+              SPxBasisBase<R>::Desc::P_FIXED ||
+          _solver.basis().desc().rowStatus(rowNumber) ==
+              SPxBasisBase<R>::Desc::D_FREE) {
+        // setting the value of the _fixedOrigVars array to indicate which
+        // variables are at their bounds.
+        currFixedVars[i] = getOrigVarFixedDirection(i);
+
+        numFixedVar++;
+      } else {
+        // the dual flags do not imply anything about the primal status of the
+        // rows.
+        if (_solver.basis().desc().rowStatus(rowNumber) ==
+                SPxBasisBase<R>::Desc::D_ON_LOWER &&
+            EQ(_solver.rhs(rowNumber) - _solver.pVec()[rowNumber], R(0.0),
+               feastol))
+          currFixedVars[i] = 1;
+        else if (_solver.basis().desc().rowStatus(rowNumber) ==
+                     SPxBasisBase<R>::Desc::D_ON_UPPER &&
+                 EQ(_solver.pVec()[rowNumber] - _solver.lhs(rowNumber), R(0.0),
+                    feastol))
+          currFixedVars[i] = -1;
       }
-   }
+    }
+  }
 
-   MSG_INFO3(spxout, spxout << "Number of fixed primal variables in the complementary (dual) problem: "
-             << numFixedVar << std::endl);
+  MSG_INFO3(spxout, spxout << "Number of fixed primal variables in the "
+                              "complementary (dual) problem: "
+                           << numFixedVar << std::endl);
 }
 
-
-
 /// removing the dual columns related to the fixed variables
 template <class R>
-void SoPlexBase<R>::_removeComplementaryDualFixedPrimalVars(int* currFixedVars)
-{
-   SPxColId tempId;
-   int ncolsforremoval = 0;
-   int* colsforremoval = 0;
-   spx_alloc(colsforremoval, _realLP->nCols() * 2);
-
-   tempId.inValidate();
-
-   for(int i = 0; i < _realLP->nCols(); i++)
-   {
-      assert(_decompCompProbColIDsIdx[i] != -1);   // this should be true in the current implementation
-
-      if(_decompCompProbColIDsIdx[i] != -1
-            && _fixedOrigVars[i] != -2)  //&& _fixedOrigVars[i] != currFixedVars[i] )
+void SoPlexBase<R>::_removeComplementaryDualFixedPrimalVars(
+    int *currFixedVars) {
+  SPxColId tempId;
+  int ncolsforremoval = 0;
+  int *colsforremoval = 0;
+  spx_alloc(colsforremoval, _realLP->nCols() * 2);
+
+  tempId.inValidate();
+
+  for (int i = 0; i < _realLP->nCols(); i++) {
+    assert(_decompCompProbColIDsIdx[i] !=
+           -1); // this should be true in the current implementation
+
+    if (_decompCompProbColIDsIdx[i] != -1 &&
+        _fixedOrigVars[i] != -2) //&& _fixedOrigVars[i] != currFixedVars[i] )
+    {
+      if (_fixedOrigVars[i] != 0) {
+        assert(_compSolver.number(SPxColId(_decompFixedVarDualIDs[i])) >= 0);
+        assert(_fixedOrigVars[i] == -1 || _fixedOrigVars[i] == 1);
+        assert(_decompFixedVarDualIDs[i].isValid());
+
+        colsforremoval[ncolsforremoval] =
+            _compSolver.number(SPxColId(_decompFixedVarDualIDs[i]));
+        ncolsforremoval++;
+
+        _decompFixedVarDualIDs[i] = tempId;
+      } else // if( false && !_decompReducedProbColRowIDs[i].isValid() ) // we
+             // want to remove all valid columns
+             //  in the current implementation, the only columns not included in
+             //  the reduced problem are free columns.
       {
-         if(_fixedOrigVars[i] != 0)
-         {
-            assert(_compSolver.number(SPxColId(_decompFixedVarDualIDs[i])) >= 0);
-            assert(_fixedOrigVars[i] == -1 || _fixedOrigVars[i] == 1);
-            assert(_decompFixedVarDualIDs[i].isValid());
-
-            colsforremoval[ncolsforremoval] = _compSolver.number(SPxColId(_decompFixedVarDualIDs[i]));
-            ncolsforremoval++;
-
-            _decompFixedVarDualIDs[i] = tempId;
-         }
-         else //if( false && !_decompReducedProbColRowIDs[i].isValid() ) // we want to remove all valid columns
-            // in the current implementation, the only columns not included in the reduced problem are free columns.
-         {
-            assert((LE(_realLP->lower(i), R(-infinity)) && GE(_realLP->upper(i), R(infinity))) ||
-                   _compSolver.number(SPxColId(_decompVarBoundDualIDs[i * 2])) >= 0);
-            int varcount = 0;
-
-            if(GT(_realLP->lower(i), R(-infinity)))
-            {
-               colsforremoval[ncolsforremoval] = _compSolver.number(SPxColId(_decompVarBoundDualIDs[i * 2 +
-                                                 varcount]));
-               ncolsforremoval++;
-
-               _decompVarBoundDualIDs[i * 2 + varcount] = tempId;
-               varcount++;
-            }
-
-            if(LT(_realLP->upper(i), R(infinity)))
-            {
-               colsforremoval[ncolsforremoval] = _compSolver.number(SPxColId(_decompVarBoundDualIDs[i * 2 +
-                                                 varcount]));
-               ncolsforremoval++;
-
-               _decompVarBoundDualIDs[i * 2 + varcount] = tempId;
-            }
-
-         }
+        assert((LE(_realLP->lower(i), R(-infinity)) &&
+                GE(_realLP->upper(i), R(infinity))) ||
+               _compSolver.number(SPxColId(_decompVarBoundDualIDs[i * 2])) >=
+                   0);
+        int varcount = 0;
+
+        if (GT(_realLP->lower(i), R(-infinity))) {
+          colsforremoval[ncolsforremoval] = _compSolver.number(
+              SPxColId(_decompVarBoundDualIDs[i * 2 + varcount]));
+          ncolsforremoval++;
+
+          _decompVarBoundDualIDs[i * 2 + varcount] = tempId;
+          varcount++;
+        }
+
+        if (LT(_realLP->upper(i), R(infinity))) {
+          colsforremoval[ncolsforremoval] = _compSolver.number(
+              SPxColId(_decompVarBoundDualIDs[i * 2 + varcount]));
+          ncolsforremoval++;
+
+          _decompVarBoundDualIDs[i * 2 + varcount] = tempId;
+        }
       }
-   }
+    }
+  }
 
-   int* perm = 0;
-   spx_alloc(perm, _compSolver.nCols());
-   _compSolver.removeCols(colsforremoval, ncolsforremoval, perm);
+  int *perm = 0;
+  spx_alloc(perm, _compSolver.nCols());
+  _compSolver.removeCols(colsforremoval, ncolsforremoval, perm);
 
-   // freeing allocated memory
-   spx_free(perm);
-   spx_free(colsforremoval);
+  // freeing allocated memory
+  spx_free(perm);
+  spx_free(colsforremoval);
 }
 
-
-
 /// updating the dual columns related to the fixed primal variables.
 template <class R>
-void SoPlexBase<R>::_updateComplementaryDualFixedPrimalVars(int* currFixedVars)
-{
-   DSVectorBase<R> col(1);
-   LPColSetBase<R> boundConsCols;
-   LPColSetBase<R> fixedVarsDualCols(_nPrimalCols);
-   int numFixedVars = 0;
-   // the solution to the reduced problem results in a number of variables at their bounds. If such variables exist
-   // it is necessary to include a dual column to the complementary problem related to a variable fixing. This is
-   // equivalent to the tight constraints being converted to equality constraints.
-   int numBoundConsCols = 0;
-   int* boundConsColsAdded = 0;
-   spx_alloc(boundConsColsAdded, _realLP->nCols());
-
-   // NOTE: this loop only goes over the primal columns that are included in the complementary problem, i.e. the
-   // columns from the original problem.
-   // 29.04.15 in the current implementation, all bound constraints are included in the reduced problem. So, all
-   // variables (columns) are included in the reduced problem.
-   for(int i = 0; i < _realLP->nCols(); i++)
-   {
-      boundConsColsAdded[i] = 0;
-      assert(_decompCompProbColIDsIdx[i] != -1);
-
-      if(_decompCompProbColIDsIdx[i] != -1)
-      {
-         int idIndex = _decompCompProbColIDsIdx[i];
-         assert(_compSolver.number(SPxRowId(_decompDualRowIDs[idIndex])) >= 0);
-         col.add(_compSolver.number(SPxRowId(_decompDualRowIDs[idIndex])), 1.0);
-
-         if(currFixedVars[i] != 0)
-         {
-            assert(currFixedVars[i] == -1 || currFixedVars[i] == 1);
-
-            assert(_realLP->lower(i) == _solver.lhs(_decompReducedProbColRowIDs[i]));
-            assert(_realLP->upper(i) == _solver.rhs(_decompReducedProbColRowIDs[i]));
-            R colObjCoeff = 0;
-
-            if(currFixedVars[i] == -1)
-               colObjCoeff = _solver.lhs(_decompReducedProbColRowIDs[i]);
-            else
-               colObjCoeff = _solver.rhs(_decompReducedProbColRowIDs[i]);
-
-            fixedVarsDualCols.add(colObjCoeff, R(-infinity), col, R(infinity));
-            numFixedVars++;
-         }
-         // 09.02.15 I think that the else should only be entered if the column does not exist in the reduced
-         // prob. I have tested by just leaving this as an else (without the if), but I think that this is wrong.
-         //else if( !_decompReducedProbColRowIDs[i].isValid() )
-
-         // NOTE: in the current implementation all columns, except the free columns, are included int the reduced
-         // problem. There in no need to include the variable bounds in the complementary problem.
-         else //if( false && _fixedOrigVars[i] == -2 )
-         {
-            bool isRedProbCol = _decompReducedProbColRowIDs[i].isValid();
-
-            // 29.04.15 in the current implementation only free variables are not included in the reduced problem
-            if(GT(_realLP->lower(i), R(-infinity)))
-            {
-               if(!isRedProbCol)
-                  col.add(_compSolver.number(SPxRowId(_compSlackDualRowId)), -SLACKCOEFF);
-
-               boundConsCols.add(_realLP->lower(i), R(-infinity), col, 0.0);
-
-               if(!isRedProbCol)
-                  col.remove(col.size() - 1);
-
-               boundConsColsAdded[i]++;
-               numBoundConsCols++;
-            }
-
-            if(LT(_realLP->upper(i), R(infinity)))
-            {
-               if(!isRedProbCol)
-                  col.add(_compSolver.number(SPxRowId(_compSlackDualRowId)), SLACKCOEFF);
-
-               boundConsCols.add(_realLP->upper(i), 0.0, col, R(infinity));
-
-               if(!isRedProbCol)
-                  col.remove(col.size() - 1);
-
-               boundConsColsAdded[i]++;
-               numBoundConsCols++;
-            }
-         }
-
-         col.clear();
-         _fixedOrigVars[i] = currFixedVars[i];
-      }
-   }
-
-   // adding the fixed var dual columns to the complementary problem
-   SPxColId* addedcolids = 0;
-   spx_alloc(addedcolids, numFixedVars);
-   _compSolver.addCols(addedcolids, fixedVarsDualCols);
-
-   SPxColId tempId;
-   int addedcolcount = 0;
-
-   tempId.inValidate();
+void SoPlexBase<R>::_updateComplementaryDualFixedPrimalVars(
+    int *currFixedVars) {
+  DSVectorBase<R> col(1);
+  LPColSetBase<R> boundConsCols;
+  LPColSetBase<R> fixedVarsDualCols(_nPrimalCols);
+  int numFixedVars = 0;
+  // the solution to the reduced problem results in a number of variables at
+  // their bounds. If such variables exist it is necessary to include a dual
+  // column to the complementary problem related to a variable fixing. This is
+  // equivalent to the tight constraints being converted to equality
+  // constraints.
+  int numBoundConsCols = 0;
+  int *boundConsColsAdded = 0;
+  spx_alloc(boundConsColsAdded, _realLP->nCols());
+
+  // NOTE: this loop only goes over the primal columns that are included in the
+  // complementary problem, i.e. the columns from the original problem. 29.04.15
+  // in the current implementation, all bound constraints are included in the
+  // reduced problem. So, all variables (columns) are included in the reduced
+  // problem.
+  for (int i = 0; i < _realLP->nCols(); i++) {
+    boundConsColsAdded[i] = 0;
+    assert(_decompCompProbColIDsIdx[i] != -1);
+
+    if (_decompCompProbColIDsIdx[i] != -1) {
+      int idIndex = _decompCompProbColIDsIdx[i];
+      assert(_compSolver.number(SPxRowId(_decompDualRowIDs[idIndex])) >= 0);
+      col.add(_compSolver.number(SPxRowId(_decompDualRowIDs[idIndex])), 1.0);
 
-   for(int i = 0; i < _realLP->nCols(); i++)
-   {
-      if(_fixedOrigVars[i] != 0)
-      {
-         assert(_fixedOrigVars[i] == -1 || _fixedOrigVars[i] == 1);
-         _decompFixedVarDualIDs[i] = addedcolids[addedcolcount];
-         addedcolcount++;
-      }
-      else
-         _decompFixedVarDualIDs[i] = tempId;
-   }
+      if (currFixedVars[i] != 0) {
+        assert(currFixedVars[i] == -1 || currFixedVars[i] == 1);
 
-   // adding the bound cons dual columns to the complementary problem
-   SPxColId* addedbndcolids = 0;
-   spx_alloc(addedbndcolids, numBoundConsCols);
-   _compSolver.addCols(addedbndcolids, boundConsCols);
+        assert(_realLP->lower(i) ==
+               _solver.lhs(_decompReducedProbColRowIDs[i]));
+        assert(_realLP->upper(i) ==
+               _solver.rhs(_decompReducedProbColRowIDs[i]));
+        R colObjCoeff = 0;
 
-   addedcolcount = 0;
+        if (currFixedVars[i] == -1)
+          colObjCoeff = _solver.lhs(_decompReducedProbColRowIDs[i]);
+        else
+          colObjCoeff = _solver.rhs(_decompReducedProbColRowIDs[i]);
 
-   for(int i = 0; i < _realLP->nCols(); i++)
-   {
-      if(boundConsColsAdded[i] > 0)
-      {
-         for(int j = 0; j < boundConsColsAdded[i]; j++)
-         {
-            _decompVarBoundDualIDs[i * 2 + j] = addedbndcolids[addedcolcount];
-            addedcolcount++;
-         }
+        fixedVarsDualCols.add(colObjCoeff, R(-infinity), col, R(infinity));
+        numFixedVars++;
       }
-
-      switch(boundConsColsAdded[i])
+      // 09.02.15 I think that the else should only be entered if the column
+      // does not exist in the reduced prob. I have tested by just leaving this
+      // as an else (without the if), but I think that this is wrong.
+      // else if( !_decompReducedProbColRowIDs[i].isValid() )
+
+      // NOTE: in the current implementation all columns, except the free
+      // columns, are included int the reduced problem. There in no need to
+      // include the variable bounds in the complementary problem.
+      else // if( false && _fixedOrigVars[i] == -2 )
       {
-      case 0:
-         _decompVarBoundDualIDs[i * 2] = tempId;
+        bool isRedProbCol = _decompReducedProbColRowIDs[i].isValid();
 
-      // FALLTHROUGH
-      case 1:
-         _decompVarBoundDualIDs[i * 2 + 1] = tempId;
-         break;
-      }
-   }
+        // 29.04.15 in the current implementation only free variables are not
+        // included in the reduced problem
+        if (GT(_realLP->lower(i), R(-infinity))) {
+          if (!isRedProbCol)
+            col.add(_compSolver.number(SPxRowId(_compSlackDualRowId)),
+                    -SLACKCOEFF);
 
-   // freeing allocated memory
-   spx_free(addedbndcolids);
-   spx_free(addedcolids);
-   spx_free(boundConsColsAdded);
-}
+          boundConsCols.add(_realLP->lower(i), R(-infinity), col, 0.0);
 
+          if (!isRedProbCol)
+            col.remove(col.size() - 1);
 
-/// identify the dual columns related to the fixed variables
-template <class R>
-void SoPlexBase<R>::_identifyComplementaryPrimalFixedPrimalVars(int* currFixedVars)
-{
-   int numFixedVar = 0;
+          boundConsColsAdded[i]++;
+          numBoundConsCols++;
+        }
 
-   for(int i = 0; i < _realLP->nCols(); i++)
-   {
-      currFixedVars[i] = 0;
+        if (LT(_realLP->upper(i), R(infinity))) {
+          if (!isRedProbCol)
+            col.add(_compSolver.number(SPxRowId(_compSlackDualRowId)),
+                    SLACKCOEFF);
 
-      if(!_decompReducedProbColRowIDs[i].isValid())
-         continue;
+          boundConsCols.add(_realLP->upper(i), 0.0, col, R(infinity));
 
-      int rowNumber = _solver.number(_decompReducedProbColRowIDs[i]);
+          if (!isRedProbCol)
+            col.remove(col.size() - 1);
 
-      if(_decompReducedProbColRowIDs[i].isValid() &&
-            (_solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::P_ON_UPPER ||
-             _solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::P_ON_LOWER ||
-             _solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::P_FIXED))
-      {
-         // setting the value of the _fixedOrigVars array to indicate which variables are at their bounds.
-         currFixedVars[i] = getOrigVarFixedDirection(i);
+          boundConsColsAdded[i]++;
+          numBoundConsCols++;
+        }
+      }
 
-         numFixedVar++;
+      col.clear();
+      _fixedOrigVars[i] = currFixedVars[i];
+    }
+  }
+
+  // adding the fixed var dual columns to the complementary problem
+  SPxColId *addedcolids = 0;
+  spx_alloc(addedcolids, numFixedVars);
+  _compSolver.addCols(addedcolids, fixedVarsDualCols);
+
+  SPxColId tempId;
+  int addedcolcount = 0;
+
+  tempId.inValidate();
+
+  for (int i = 0; i < _realLP->nCols(); i++) {
+    if (_fixedOrigVars[i] != 0) {
+      assert(_fixedOrigVars[i] == -1 || _fixedOrigVars[i] == 1);
+      _decompFixedVarDualIDs[i] = addedcolids[addedcolcount];
+      addedcolcount++;
+    } else
+      _decompFixedVarDualIDs[i] = tempId;
+  }
+
+  // adding the bound cons dual columns to the complementary problem
+  SPxColId *addedbndcolids = 0;
+  spx_alloc(addedbndcolids, numBoundConsCols);
+  _compSolver.addCols(addedbndcolids, boundConsCols);
+
+  addedcolcount = 0;
+
+  for (int i = 0; i < _realLP->nCols(); i++) {
+    if (boundConsColsAdded[i] > 0) {
+      for (int j = 0; j < boundConsColsAdded[i]; j++) {
+        _decompVarBoundDualIDs[i * 2 + j] = addedbndcolids[addedcolcount];
+        addedcolcount++;
       }
-   }
+    }
 
-   MSG_INFO3(spxout, spxout <<
-             "Number of fixed primal variables in the complementary (primal) problem: "
-             << numFixedVar << std::endl);
-}
+    switch (boundConsColsAdded[i]) {
+    case 0:
+      _decompVarBoundDualIDs[i * 2] = tempId;
 
+    // FALLTHROUGH
+    case 1:
+      _decompVarBoundDualIDs[i * 2 + 1] = tempId;
+      break;
+    }
+  }
+
+  // freeing allocated memory
+  spx_free(addedbndcolids);
+  spx_free(addedcolids);
+  spx_free(boundConsColsAdded);
+}
 
+/// identify the dual columns related to the fixed variables
+template <class R>
+void SoPlexBase<R>::_identifyComplementaryPrimalFixedPrimalVars(
+    int *currFixedVars) {
+  int numFixedVar = 0;
+
+  for (int i = 0; i < _realLP->nCols(); i++) {
+    currFixedVars[i] = 0;
+
+    if (!_decompReducedProbColRowIDs[i].isValid())
+      continue;
+
+    int rowNumber = _solver.number(_decompReducedProbColRowIDs[i]);
+
+    if (_decompReducedProbColRowIDs[i].isValid() &&
+        (_solver.basis().desc().rowStatus(rowNumber) ==
+             SPxBasisBase<R>::Desc::P_ON_UPPER ||
+         _solver.basis().desc().rowStatus(rowNumber) ==
+             SPxBasisBase<R>::Desc::P_ON_LOWER ||
+         _solver.basis().desc().rowStatus(rowNumber) ==
+             SPxBasisBase<R>::Desc::P_FIXED)) {
+      // setting the value of the _fixedOrigVars array to indicate which
+      // variables are at their bounds.
+      currFixedVars[i] = getOrigVarFixedDirection(i);
+
+      numFixedVar++;
+    }
+  }
+
+  MSG_INFO3(spxout, spxout << "Number of fixed primal variables in the "
+                              "complementary (primal) problem: "
+                           << numFixedVar << std::endl);
+}
 
 /// updating the dual columns related to the fixed primal variables.
 template <class R>
-void SoPlexBase<R>::_updateComplementaryPrimalFixedPrimalVars(int* currFixedVars)
-{
-   int numFixedVars = 0;
-
-   // NOTE: this loop only goes over the primal columns that are included in the complementary problem, i.e. the
-   // columns from the original problem.
-   // 29.04.15 in the current implementation, all bound constraints are included in the reduced problem. So, all
-   // variables (columns) are included in the reduced problem.
-   for(int i = 0; i < _nCompPrimalCols; i++)
-   {
-      int colNumber = _compSolver.number(SPxColId(_decompCompPrimalColIDs[i]));
-
-      if(_fixedOrigVars[colNumber] != currFixedVars[colNumber])
-      {
-         if(currFixedVars[colNumber] != 0)
-         {
-            assert(currFixedVars[colNumber] == -1 || currFixedVars[colNumber] == 1);
-
-            if(currFixedVars[colNumber] == -1)
-               _compSolver.changeBounds(colNumber, _realLP->lower(SPxColId(_decompPrimalColIDs[i])),
-                                        _realLP->lower(SPxColId(_decompPrimalColIDs[i])));
-            else
-               _compSolver.changeBounds(colNumber, _realLP->upper(SPxColId(_decompPrimalColIDs[i])),
-                                        _realLP->upper(SPxColId(_decompPrimalColIDs[i])));
-
-            numFixedVars++;
-         }
-         else
-         {
-            _compSolver.changeBounds(colNumber, R(-infinity), R(infinity));
-         }
+void SoPlexBase<R>::_updateComplementaryPrimalFixedPrimalVars(
+    int *currFixedVars) {
+  int numFixedVars = 0;
+
+  // NOTE: this loop only goes over the primal columns that are included in the
+  // complementary problem, i.e. the columns from the original problem. 29.04.15
+  // in the current implementation, all bound constraints are included in the
+  // reduced problem. So, all variables (columns) are included in the reduced
+  // problem.
+  for (int i = 0; i < _nCompPrimalCols; i++) {
+    int colNumber = _compSolver.number(SPxColId(_decompCompPrimalColIDs[i]));
+
+    if (_fixedOrigVars[colNumber] != currFixedVars[colNumber]) {
+      if (currFixedVars[colNumber] != 0) {
+        assert(currFixedVars[colNumber] == -1 || currFixedVars[colNumber] == 1);
+
+        if (currFixedVars[colNumber] == -1)
+          _compSolver.changeBounds(
+              colNumber, _realLP->lower(SPxColId(_decompPrimalColIDs[i])),
+              _realLP->lower(SPxColId(_decompPrimalColIDs[i])));
+        else
+          _compSolver.changeBounds(
+              colNumber, _realLP->upper(SPxColId(_decompPrimalColIDs[i])),
+              _realLP->upper(SPxColId(_decompPrimalColIDs[i])));
+
+        numFixedVars++;
+      } else {
+        _compSolver.changeBounds(colNumber, R(-infinity), R(infinity));
       }
+    }
 
-      _fixedOrigVars[colNumber] = currFixedVars[colNumber];
-   }
+    _fixedOrigVars[colNumber] = currFixedVars[colNumber];
+  }
 }
 
-
-
 /// updating the complementary dual problem with the original objective function
 template <class R>
-void SoPlexBase<R>::_setComplementaryDualOriginalObjective()
-{
-   for(int i = 0; i < _realLP->nCols(); i++)
-   {
-      assert(_decompCompProbColIDsIdx[i] != -1);   // this should be true in the current implementation
-      int idIndex = _decompCompProbColIDsIdx[i];
-      int compRowNumber = _compSolver.number(_decompDualRowIDs[idIndex]);
-
-      if(_decompCompProbColIDsIdx[i] != -1)
-      {
-         // In the dual conversion, when a variable has a non-standard bound it is converted to a free variable.
-         if(LE(_realLP->lower(i), R(-infinity)) && GE(_realLP->upper(i), R(infinity)))
-         {
-            // unrestricted variable
-            _compSolver.changeLhs(compRowNumber, _realLP->obj(i));
-            _compSolver.changeRhs(compRowNumber, _realLP->obj(i));
-            assert(LE(_compSolver.lhs(compRowNumber), _compSolver.rhs(compRowNumber)));
-         }
-         else if(LE(_realLP->lower(i), R(-infinity)))
-         {
-            // variable with a finite upper bound
-            _compSolver.changeRhs(compRowNumber, _realLP->obj(i));
-
-            if(isZero(_realLP->upper(i)))
-               _compSolver.changeLhs(compRowNumber, R(-infinity));
-            else
-               _compSolver.changeLhs(compRowNumber, _realLP->obj(i));
-         }
-         else if(GE(_realLP->upper(i), R(infinity)))
-         {
-            // variable with a finite lower bound
-            _compSolver.changeLhs(compRowNumber, _realLP->obj(i));
-
-            if(isZero(_realLP->upper(i)))
-               _compSolver.changeRhs(compRowNumber, R(infinity));
-            else
-               _compSolver.changeRhs(compRowNumber, _realLP->obj(i));
-         }
-         else if(NE(_realLP->lower(i), _realLP->upper(i)))
-         {
-            // variable with a finite upper and lower bound
-            if(isZero(_realLP->upper(i)))
-            {
-               _compSolver.changeLhs(compRowNumber, _realLP->obj(i));
-               _compSolver.changeRhs(compRowNumber, R(infinity));
-            }
-            else if(isZero(_realLP->upper(i)))
-            {
-               _compSolver.changeLhs(compRowNumber, R(-infinity));
-               _compSolver.changeRhs(compRowNumber, _realLP->obj(i));
-            }
-            else
-            {
-               _compSolver.changeLhs(compRowNumber, _realLP->obj(i));
-               _compSolver.changeRhs(compRowNumber, _realLP->obj(i));
-            }
-         }
-         else
-         {
-            // fixed variable
-            _compSolver.changeLhs(compRowNumber, _realLP->obj(i));
-            _compSolver.changeRhs(compRowNumber, _realLP->obj(i));
-         }
+void SoPlexBase<R>::_setComplementaryDualOriginalObjective() {
+  for (int i = 0; i < _realLP->nCols(); i++) {
+    assert(_decompCompProbColIDsIdx[i] !=
+           -1); // this should be true in the current implementation
+    int idIndex = _decompCompProbColIDsIdx[i];
+    int compRowNumber = _compSolver.number(_decompDualRowIDs[idIndex]);
+
+    if (_decompCompProbColIDsIdx[i] != -1) {
+      // In the dual conversion, when a variable has a non-standard bound it is
+      // converted to a free variable.
+      if (LE(_realLP->lower(i), R(-infinity)) &&
+          GE(_realLP->upper(i), R(infinity))) {
+        // unrestricted variable
+        _compSolver.changeLhs(compRowNumber, _realLP->obj(i));
+        _compSolver.changeRhs(compRowNumber, _realLP->obj(i));
+        assert(
+            LE(_compSolver.lhs(compRowNumber), _compSolver.rhs(compRowNumber)));
+      } else if (LE(_realLP->lower(i), R(-infinity))) {
+        // variable with a finite upper bound
+        _compSolver.changeRhs(compRowNumber, _realLP->obj(i));
+
+        if (isZero(_realLP->upper(i)))
+          _compSolver.changeLhs(compRowNumber, R(-infinity));
+        else
+          _compSolver.changeLhs(compRowNumber, _realLP->obj(i));
+      } else if (GE(_realLP->upper(i), R(infinity))) {
+        // variable with a finite lower bound
+        _compSolver.changeLhs(compRowNumber, _realLP->obj(i));
+
+        if (isZero(_realLP->upper(i)))
+          _compSolver.changeRhs(compRowNumber, R(infinity));
+        else
+          _compSolver.changeRhs(compRowNumber, _realLP->obj(i));
+      } else if (NE(_realLP->lower(i), _realLP->upper(i))) {
+        // variable with a finite upper and lower bound
+        if (isZero(_realLP->upper(i))) {
+          _compSolver.changeLhs(compRowNumber, _realLP->obj(i));
+          _compSolver.changeRhs(compRowNumber, R(infinity));
+        } else if (isZero(_realLP->upper(i))) {
+          _compSolver.changeLhs(compRowNumber, R(-infinity));
+          _compSolver.changeRhs(compRowNumber, _realLP->obj(i));
+        } else {
+          _compSolver.changeLhs(compRowNumber, _realLP->obj(i));
+          _compSolver.changeRhs(compRowNumber, _realLP->obj(i));
+        }
+      } else {
+        // fixed variable
+        _compSolver.changeLhs(compRowNumber, _realLP->obj(i));
+        _compSolver.changeRhs(compRowNumber, _realLP->obj(i));
       }
-   }
+    }
+  }
 
-   // removing the complementary problem slack column dual row
-   _compSolver.removeRow(_compSlackDualRowId);
+  // removing the complementary problem slack column dual row
+  _compSolver.removeRow(_compSlackDualRowId);
 }
 
-
-
-/// updating the complementary primal problem with the original objective function
+/// updating the complementary primal problem with the original objective
+/// function
 template <class R>
-void SoPlexBase<R>::_setComplementaryPrimalOriginalObjective()
-{
-   // the comp solver has not removed any columns. Only the slack variables have been added.
-   assert(_realLP->nCols() == _compSolver.nCols() - 1);
-
-   for(int i = 0; i < _realLP->nCols(); i++)
-   {
-      int colNumber = _realLP->number(_decompPrimalColIDs[i]);
-      int compColNumber = _compSolver.number(_decompCompPrimalColIDs[i]);
-      _compSolver.changeObj(compColNumber, _realLP->maxObj(colNumber));
-   }
-
-   // removing the complementary problem slack column dual row
-   _compSolver.removeCol(_compSlackColId);
+void SoPlexBase<R>::_setComplementaryPrimalOriginalObjective() {
+  // the comp solver has not removed any columns. Only the slack variables have
+  // been added.
+  assert(_realLP->nCols() == _compSolver.nCols() - 1);
+
+  for (int i = 0; i < _realLP->nCols(); i++) {
+    int colNumber = _realLP->number(_decompPrimalColIDs[i]);
+    int compColNumber = _compSolver.number(_decompCompPrimalColIDs[i]);
+    _compSolver.changeObj(compColNumber, _realLP->maxObj(colNumber));
+  }
+
+  // removing the complementary problem slack column dual row
+  _compSolver.removeCol(_compSlackColId);
 }
 
-
-
 /// determining which bound the primal variables will be fixed to.
-template <class R>
-int SoPlexBase<R>::getOrigVarFixedDirection(int colNum)
-{
-   if(!_decompReducedProbColRowIDs[colNum].isValid())
-      return 0;
-
-   int rowNumber = _solver.number(_decompReducedProbColRowIDs[colNum]);
-
-   // setting the value of the _fixedOrigVars array to indicate which variables are at their bounds.
-   if(_solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::P_ON_UPPER ||
-         _solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::P_FIXED ||
-         _solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::D_FREE)
-   {
-      assert(_solver.rhs(rowNumber) < R(infinity));
-      return 1;
-   }
-   else if(_solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::P_ON_LOWER)
-   {
-      assert(_solver.lhs(rowNumber) > R(-infinity));
-      return -1;
-   }
-
-   return 0;
+template <class R> int SoPlexBase<R>::getOrigVarFixedDirection(int colNum) {
+  if (!_decompReducedProbColRowIDs[colNum].isValid())
+    return 0;
+
+  int rowNumber = _solver.number(_decompReducedProbColRowIDs[colNum]);
+
+  // setting the value of the _fixedOrigVars array to indicate which variables
+  // are at their bounds.
+  if (_solver.basis().desc().rowStatus(rowNumber) ==
+          SPxBasisBase<R>::Desc::P_ON_UPPER ||
+      _solver.basis().desc().rowStatus(rowNumber) ==
+          SPxBasisBase<R>::Desc::P_FIXED ||
+      _solver.basis().desc().rowStatus(rowNumber) ==
+          SPxBasisBase<R>::Desc::D_FREE) {
+    assert(_solver.rhs(rowNumber) < R(infinity));
+    return 1;
+  } else if (_solver.basis().desc().rowStatus(rowNumber) ==
+             SPxBasisBase<R>::Desc::P_ON_LOWER) {
+    assert(_solver.lhs(rowNumber) > R(-infinity));
+    return -1;
+  }
+
+  return 0;
 }
 
-
-
-// @todo update this function and related comments. It has only been hacked together.
-/// checks result of the solving process and solves again without preprocessing if necessary
-// @todo need to evaluate the solution to ensure that it is solved to optimality and then we are able to perform the
-// next steps in the algorithm.
+// @todo update this function and related comments. It has only been hacked
+// together.
+/// checks result of the solving process and solves again without preprocessing
+/// if necessary
+// @todo need to evaluate the solution to ensure that it is solved to optimality
+// and then we are able to perform the next steps in the algorithm.
 template <class R>
-void SoPlexBase<R>::_evaluateSolutionDecomp(SPxSolverBase<R>& solver, SLUFactor<R>& sluFactor,
-      typename SPxSimplifier<R>::Result result)
-{
-   typename SPxSolverBase<R>::Status solverStat = SPxSolverBase<R>::UNKNOWN;
-
-   if(result == SPxSimplifier<R>::INFEASIBLE)
-      solverStat = SPxSolverBase<R>::INFEASIBLE;
-   else if(result == SPxSimplifier<R>::DUAL_INFEASIBLE)
-      solverStat = SPxSolverBase<R>::INForUNBD;
-   else if(result == SPxSimplifier<R>::UNBOUNDED)
-      solverStat = SPxSolverBase<R>::UNBOUNDED;
-   else if(result == SPxSimplifier<R>::VANISHED)
-      solverStat = SPxSolverBase<R>::OPTIMAL;
-   else if(result == SPxSimplifier<R>::OKAY)
-      solverStat = solver.status();
-
-   // updating the status of SoPlexBase if the problem solved is the reduced problem.
-   if(_currentProb == DECOMP_ORIG || _currentProb == DECOMP_RED)
-      _status = solverStat;
-
-   // process result
-   // coverity[switch_selector_expr_is_constant]
-   switch(solverStat)
-   {
-   case SPxSolverBase<R>::OPTIMAL:
-      if(!_isRealLPLoaded)
-      {
-         solver.changeObjOffset(realParam(SoPlexBase<R>::OBJ_OFFSET));
-         _decompResolveWithoutPreprocessing(solver, sluFactor, result);
-         // Need to solve the complementary problem
-         return;
-      }
-      else
-         _hasBasis = true;
-
-      break;
-
-   case SPxSolverBase<R>::UNBOUNDED:
-   case SPxSolverBase<R>::INFEASIBLE:
-   case SPxSolverBase<R>::INForUNBD:
-
-      // in case of infeasibility or unboundedness, we currently can not unsimplify, but have to solve the original LP again
-      if(!_isRealLPLoaded)
-      {
-         solver.changeObjOffset(realParam(SoPlexBase<R>::OBJ_OFFSET));
-         _decompSimplifyAndSolve(solver, sluFactor, false, false);
-         return;
-      }
-      else
-         _hasBasis = (solver.basis().status() > SPxBasisBase<R>::NO_PROBLEM);
-
-      break;
-
-   case SPxSolverBase<R>::ABORT_DECOMP:
-   case SPxSolverBase<R>::ABORT_EXDECOMP:
-
-      // in the initialisation of the decomposition simplex, we want to keep the current basis.
-      if(!_isRealLPLoaded)
-      {
-         solver.changeObjOffset(realParam(SoPlexBase<R>::OBJ_OFFSET));
-         _decompResolveWithoutPreprocessing(solver, sluFactor, result);
-         //_decompSimplifyAndSolve(solver, sluFactor, false, false);
-         return;
-      }
-      else
-         _hasBasis = (solver.basis().status() > SPxBasisBase<R>::NO_PROBLEM);
-
-      break;
-
-   case SPxSolverBase<R>::SINGULAR:
-   case SPxSolverBase<R>::ABORT_CYCLING:
-
-      // in case of infeasibility or unboundedness, we currently can not unsimplify, but have to solve the original LP again
-      if(!_isRealLPLoaded)
-      {
-         solver.changeObjOffset(realParam(SoPlexBase<R>::OBJ_OFFSET));
-         _decompSimplifyAndSolve(solver, sluFactor, false, false);
-         return;
-      }
-
-      break;
-
-
-   // else fallthrough
-   case SPxSolverBase<R>::ABORT_TIME:
-   case SPxSolverBase<R>::ABORT_ITER:
-   case SPxSolverBase<R>::ABORT_VALUE:
-   case SPxSolverBase<R>::REGULAR:
-   case SPxSolverBase<R>::RUNNING:
-
-      // store regular basis if there is no simplifier and the original problem is not in the solver because of
-      // scaling; non-optimal bases should currently not be unsimplified
-      if(_simplifier == 0 && solver.basis().status() > SPxBasisBase<R>::NO_PROBLEM)
-      {
-         _basisStatusRows.reSize(_decompLP->nRows());
-         _basisStatusCols.reSize(_decompLP->nCols());
-         assert(_basisStatusRows.size() == solver.nRows());
-         assert(_basisStatusCols.size() == solver.nCols());
-
-         solver.getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr());
-         _hasBasis = true;
-      }
-      else
-         _hasBasis = false;
+void SoPlexBase<R>::_evaluateSolutionDecomp(
+    SPxSolverBase<R> &solver, SLUFactor<R> &sluFactor,
+    typename SPxSimplifier<R>::Result result) {
+  typename SPxSolverBase<R>::Status solverStat = SPxSolverBase<R>::UNKNOWN;
+
+  if (result == SPxSimplifier<R>::INFEASIBLE)
+    solverStat = SPxSolverBase<R>::INFEASIBLE;
+  else if (result == SPxSimplifier<R>::DUAL_INFEASIBLE)
+    solverStat = SPxSolverBase<R>::INForUNBD;
+  else if (result == SPxSimplifier<R>::UNBOUNDED)
+    solverStat = SPxSolverBase<R>::UNBOUNDED;
+  else if (result == SPxSimplifier<R>::VANISHED)
+    solverStat = SPxSolverBase<R>::OPTIMAL;
+  else if (result == SPxSimplifier<R>::OKAY)
+    solverStat = solver.status();
+
+  // updating the status of SoPlexBase if the problem solved is the reduced
+  // problem.
+  if (_currentProb == DECOMP_ORIG || _currentProb == DECOMP_RED)
+    _status = solverStat;
+
+  // process result
+  // coverity[switch_selector_expr_is_constant]
+  switch (solverStat) {
+  case SPxSolverBase<R>::OPTIMAL:
+    if (!_isRealLPLoaded) {
+      solver.changeObjOffset(realParam(SoPlexBase<R>::OBJ_OFFSET));
+      _decompResolveWithoutPreprocessing(solver, sluFactor, result);
+      // Need to solve the complementary problem
+      return;
+    } else
+      _hasBasis = true;
 
-      break;
+    break;
+
+  case SPxSolverBase<R>::UNBOUNDED:
+  case SPxSolverBase<R>::INFEASIBLE:
+  case SPxSolverBase<R>::INForUNBD:
+
+    // in case of infeasibility or unboundedness, we currently can not
+    // unsimplify, but have to solve the original LP again
+    if (!_isRealLPLoaded) {
+      solver.changeObjOffset(realParam(SoPlexBase<R>::OBJ_OFFSET));
+      _decompSimplifyAndSolve(solver, sluFactor, false, false);
+      return;
+    } else
+      _hasBasis = (solver.basis().status() > SPxBasisBase<R>::NO_PROBLEM);
+
+    break;
+
+  case SPxSolverBase<R>::ABORT_DECOMP:
+  case SPxSolverBase<R>::ABORT_EXDECOMP:
+
+    // in the initialisation of the decomposition simplex, we want to keep the
+    // current basis.
+    if (!_isRealLPLoaded) {
+      solver.changeObjOffset(realParam(SoPlexBase<R>::OBJ_OFFSET));
+      _decompResolveWithoutPreprocessing(solver, sluFactor, result);
+      //_decompSimplifyAndSolve(solver, sluFactor, false, false);
+      return;
+    } else
+      _hasBasis = (solver.basis().status() > SPxBasisBase<R>::NO_PROBLEM);
+
+    break;
+
+  case SPxSolverBase<R>::SINGULAR:
+  case SPxSolverBase<R>::ABORT_CYCLING:
+
+    // in case of infeasibility or unboundedness, we currently can not
+    // unsimplify, but have to solve the original LP again
+    if (!_isRealLPLoaded) {
+      solver.changeObjOffset(realParam(SoPlexBase<R>::OBJ_OFFSET));
+      _decompSimplifyAndSolve(solver, sluFactor, false, false);
+      return;
+    }
+
+    break;
+
+  // else fallthrough
+  case SPxSolverBase<R>::ABORT_TIME:
+  case SPxSolverBase<R>::ABORT_ITER:
+  case SPxSolverBase<R>::ABORT_VALUE:
+  case SPxSolverBase<R>::REGULAR:
+  case SPxSolverBase<R>::RUNNING:
+
+    // store regular basis if there is no simplifier and the original problem is
+    // not in the solver because of scaling; non-optimal bases should currently
+    // not be unsimplified
+    if (_simplifier == 0 &&
+        solver.basis().status() > SPxBasisBase<R>::NO_PROBLEM) {
+      _basisStatusRows.reSize(_decompLP->nRows());
+      _basisStatusCols.reSize(_decompLP->nCols());
+      assert(_basisStatusRows.size() == solver.nRows());
+      assert(_basisStatusCols.size() == solver.nCols());
 
-   default:
+      solver.getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr());
+      _hasBasis = true;
+    } else
       _hasBasis = false;
-      break;
-   }
-}
-
 
+    break;
 
+  default:
+    _hasBasis = false;
+    break;
+  }
+}
 
 /// checks the dual feasibility of the current basis
 template <class R>
-bool SoPlexBase<R>::checkBasisDualFeasibility(VectorBase<R> feasVec)
-{
-   assert(_solver.rep() == SPxSolverBase<R>::ROW);
-   assert(_solver.spxSense() == SPxLPBase<R>::MAXIMIZE);
-
-   R feastol = realParam(SoPlexBase<R>::FEASTOL);
+bool SoPlexBase<R>::checkBasisDualFeasibility(VectorBase<R> feasVec) {
+  assert(_solver.rep() == SPxSolverBase<R>::ROW);
+  assert(_solver.spxSense() == SPxLPBase<R>::MAXIMIZE);
+
+  R feastol = realParam(SoPlexBase<R>::FEASTOL);
+
+  // iterating through all elements in the basis to determine whether the dual
+  // feasibility is satisfied.
+  for (int i = 0; i < _solver.nCols(); i++) {
+    if (_solver.basis()
+            .baseId(i)
+            .isSPxRowId()) // find the row id's for rows in the basis
+    {
+      int rownumber = _solver.number(_solver.basis().baseId(i));
+
+      if (_solver.basis().desc().rowStatus(rownumber) !=
+              SPxBasisBase<R>::Desc::P_ON_UPPER &&
+          _solver.basis().desc().rowStatus(rownumber) !=
+              SPxBasisBase<R>::Desc::P_FIXED) {
+        if (GT(feasVec[i], (R)0, feastol))
+          return false;
+      }
 
-   // iterating through all elements in the basis to determine whether the dual feasibility is satisfied.
-   for(int i = 0; i < _solver.nCols(); i++)
-   {
-      if(_solver.basis().baseId(i).isSPxRowId())   // find the row id's for rows in the basis
-      {
-         int rownumber = _solver.number(_solver.basis().baseId(i));
-
-         if(_solver.basis().desc().rowStatus(rownumber) != SPxBasisBase<R>::Desc::P_ON_UPPER &&
-               _solver.basis().desc().rowStatus(rownumber) != SPxBasisBase<R>::Desc::P_FIXED)
-         {
-            if(GT(feasVec[i], (R) 0, feastol))
-               return false;
-         }
-
-         if(_solver.basis().desc().rowStatus(rownumber) != SPxBasisBase<R>::Desc::P_ON_LOWER &&
-               _solver.basis().desc().rowStatus(rownumber) != SPxBasisBase<R>::Desc::P_FIXED)
-         {
-            if(LT(feasVec[i], (R) 0, feastol))
-               return false;
-         }
+      if (_solver.basis().desc().rowStatus(rownumber) !=
+              SPxBasisBase<R>::Desc::P_ON_LOWER &&
+          _solver.basis().desc().rowStatus(rownumber) !=
+              SPxBasisBase<R>::Desc::P_FIXED) {
+        if (LT(feasVec[i], (R)0, feastol))
+          return false;
+      }
 
+    } else if (_solver.basis()
+                   .baseId(i)
+                   .isSPxColId()) // get the column id's for the columns in the
+                                  // basis
+    {
+      int colnumber = _solver.number(_solver.basis().baseId(i));
+
+      if (_solver.basis().desc().colStatus(colnumber) !=
+              SPxBasisBase<R>::Desc::P_ON_UPPER &&
+          _solver.basis().desc().colStatus(colnumber) !=
+              SPxBasisBase<R>::Desc::P_FIXED) {
+        if (GT(feasVec[i], (R)0, feastol))
+          return false;
       }
-      else if(_solver.basis().baseId(
-                 i).isSPxColId())    // get the column id's for the columns in the basis
-      {
-         int colnumber = _solver.number(_solver.basis().baseId(i));
-
-         if(_solver.basis().desc().colStatus(colnumber) != SPxBasisBase<R>::Desc::P_ON_UPPER &&
-               _solver.basis().desc().colStatus(colnumber) != SPxBasisBase<R>::Desc::P_FIXED)
-         {
-            if(GT(feasVec[i], (R) 0, feastol))
-               return false;
-         }
-
-         if(_solver.basis().desc().colStatus(colnumber) != SPxBasisBase<R>::Desc::P_ON_LOWER &&
-               _solver.basis().desc().colStatus(colnumber) != SPxBasisBase<R>::Desc::P_FIXED)
-         {
-            if(LT(feasVec[i], (R) 0, feastol))
-               return false;
-         }
+
+      if (_solver.basis().desc().colStatus(colnumber) !=
+              SPxBasisBase<R>::Desc::P_ON_LOWER &&
+          _solver.basis().desc().colStatus(colnumber) !=
+              SPxBasisBase<R>::Desc::P_FIXED) {
+        if (LT(feasVec[i], (R)0, feastol))
+          return false;
       }
-   }
+    }
+  }
 
-   return true;
+  return true;
 }
 
-
-
 /// returns the expected sign of the dual variables for the reduced problem
 template <class R>
-typename SoPlexBase<R>::DualSign SoPlexBase<R>::getExpectedDualVariableSign(int rowNumber)
-{
-   if(_solver.isRowBasic(rowNumber))
-   {
-      if(_solver.basis().desc().rowStatus(rowNumber) != SPxBasisBase<R>::Desc::P_ON_UPPER &&
-            _solver.basis().desc().rowStatus(rowNumber) != SPxBasisBase<R>::Desc::P_FIXED)
-         return SoPlexBase<R>::IS_NEG;
-
-      if(_solver.basis().desc().rowStatus(rowNumber) != SPxBasisBase<R>::Desc::P_ON_LOWER &&
-            _solver.basis().desc().rowStatus(rowNumber) != SPxBasisBase<R>::Desc::P_FIXED)
-         return SoPlexBase<R>::IS_POS;
-   }
-
-   return SoPlexBase<R>::IS_FREE;
+typename SoPlexBase<R>::DualSign
+SoPlexBase<R>::getExpectedDualVariableSign(int rowNumber) {
+  if (_solver.isRowBasic(rowNumber)) {
+    if (_solver.basis().desc().rowStatus(rowNumber) !=
+            SPxBasisBase<R>::Desc::P_ON_UPPER &&
+        _solver.basis().desc().rowStatus(rowNumber) !=
+            SPxBasisBase<R>::Desc::P_FIXED)
+      return SoPlexBase<R>::IS_NEG;
+
+    if (_solver.basis().desc().rowStatus(rowNumber) !=
+            SPxBasisBase<R>::Desc::P_ON_LOWER &&
+        _solver.basis().desc().rowStatus(rowNumber) !=
+            SPxBasisBase<R>::Desc::P_FIXED)
+      return SoPlexBase<R>::IS_POS;
+  }
+
+  return SoPlexBase<R>::IS_FREE;
 }
 
-
-
 /// returns the expected sign of the dual variables for the original problem
 template <class R>
-typename SoPlexBase<R>::DualSign SoPlexBase<R>::getOrigProbDualVariableSign(int rowNumber)
-{
-   if(_realLP->rowType(rowNumber) == LPRowBase<R>::LESS_EQUAL)
-      return IS_POS;
+typename SoPlexBase<R>::DualSign
+SoPlexBase<R>::getOrigProbDualVariableSign(int rowNumber) {
+  if (_realLP->rowType(rowNumber) == LPRowBase<R>::LESS_EQUAL)
+    return IS_POS;
 
-   if(_realLP->rowType(rowNumber) == LPRowBase<R>::GREATER_EQUAL)
-      return IS_NEG;
+  if (_realLP->rowType(rowNumber) == LPRowBase<R>::GREATER_EQUAL)
+    return IS_NEG;
 
-   if(_realLP->rowType(rowNumber) == LPRowBase<R>::EQUAL)
-      return IS_FREE;
+  if (_realLP->rowType(rowNumber) == LPRowBase<R>::EQUAL)
+    return IS_FREE;
 
-   // this final statement needs to be checked.
-   if(_realLP->rowType(rowNumber) == LPRowBase<R>::RANGE)
-      return IS_FREE;
+  // this final statement needs to be checked.
+  if (_realLP->rowType(rowNumber) == LPRowBase<R>::RANGE)
+    return IS_FREE;
 
-   return IS_FREE;
+  return IS_FREE;
 }
 
-
 /// print display line of flying table
 template <class R>
-void SoPlexBase<R>::printDecompDisplayLine(SPxSolverBase<R>& solver,
-      const SPxOut::Verbosity origVerb, bool force, bool forceHead)
-{
-   // setting the verbosity level
-   const SPxOut::Verbosity currVerb = spxout.getVerbosity();
-   spxout.setVerbosity(origVerb);
-
-   int displayFreq = intParam(SoPlexBase<R>::DECOMP_DISPLAYFREQ);
-
-   MSG_INFO1(spxout,
-
-             if(forceHead || (_decompDisplayLine % (displayFreq * 30) == 0))
-{
-   spxout << "type |   time |   iters | red iter | alg iter |     rows |     cols |  shift   |    value\n";
-}
-if(force || (_decompDisplayLine % displayFreq == 0))
-{
-   Real currentTime = _statistics->solvingTime->time();
-      (solver.type() == SPxSolverBase<R>::LEAVE) ? spxout << "  L  |" : spxout << "  E  |";
-      spxout << std::fixed << std::setw(7) << std::setprecision(1) << currentTime << " |";
-      spxout << std::scientific << std::setprecision(2);
-      spxout << std::setw(8) << _statistics->iterations << " | ";
-      spxout << std::scientific << std::setprecision(2);
-      spxout << std::setw(8) << _statistics->iterationsRedProb << " | ";
-      spxout << std::scientific << std::setprecision(2);
-      spxout << std::setw(8) << _statistics->callsReducedProb << " | ";
-      spxout << std::scientific << std::setprecision(2);
-      spxout << std::setw(8) << numIncludedRows << " | ";
-      spxout << std::scientific << std::setprecision(2);
-      spxout << std::setw(8) << solver.nCols() << " | "
-             << solver.shift() << " | "
-             << std::setprecision(8) << solver.value() + solver.objOffset()
-             << std::endl;
-
-   }
-   _decompDisplayLine++;
-            );
-
-   spxout.setVerbosity(currVerb);
+void SoPlexBase<R>::printDecompDisplayLine(SPxSolverBase<R> &solver,
+                                           const SPxOut::Verbosity origVerb,
+                                           bool force, bool forceHead) {
+  // setting the verbosity level
+  const SPxOut::Verbosity currVerb = spxout.getVerbosity();
+  spxout.setVerbosity(origVerb);
+
+  int displayFreq = intParam(SoPlexBase<R>::DECOMP_DISPLAYFREQ);
+
+  MSG_INFO1(
+      spxout,
+
+      if (forceHead || (_decompDisplayLine % (displayFreq * 30) == 0)) {
+        spxout << "type |   time |   iters | red iter | alg iter |     rows |  "
+                  "   cols |  shift   |    value\n";
+      } if (force || (_decompDisplayLine % displayFreq == 0)) {
+        Real currentTime = _statistics->solvingTime->time();
+        (solver.type() == SPxSolverBase<R>::LEAVE) ? spxout << "  L  |"
+                                                   : spxout << "  E  |";
+        spxout << std::fixed << std::setw(7) << std::setprecision(1)
+               << currentTime << " |";
+        spxout << std::scientific << std::setprecision(2);
+        spxout << std::setw(8) << _statistics->iterations << " | ";
+        spxout << std::scientific << std::setprecision(2);
+        spxout << std::setw(8) << _statistics->iterationsRedProb << " | ";
+        spxout << std::scientific << std::setprecision(2);
+        spxout << std::setw(8) << _statistics->callsReducedProb << " | ";
+        spxout << std::scientific << std::setprecision(2);
+        spxout << std::setw(8) << numIncludedRows << " | ";
+        spxout << std::scientific << std::setprecision(2);
+        spxout << std::setw(8) << solver.nCols() << " | " << solver.shift()
+               << " | " << std::setprecision(8)
+               << solver.value() + solver.objOffset() << std::endl;
+      } _decompDisplayLine++;);
+
+  spxout.setVerbosity(currVerb);
 }
 
-
-
 /// stores the problem statistics of the original problem
-template <class R>
-void SoPlexBase<R>::getOriginalProblemStatistics()
-{
-   numProbRows = _realLP->nRows();
-   numProbCols = _realLP->nCols();
-   nNonzeros = _realLP->nNzos();
-   minAbsNonzero = _realLP->minAbsNzo();
-   maxAbsNonzero = _realLP->maxAbsNzo();
-
-   origCountLower = 0;
-   origCountUpper = 0;
-   origCountBoxed = 0;
-   origCountFreeCol = 0;
-
-   origCountLhs = 0;
-   origCountRhs = 0;
-   origCountRanged = 0;
-   origCountFreeRow = 0;
-
-   for(int i = 0; i < _realLP->nCols(); i++)
-   {
-      bool hasLower = false;
-      bool hasUpper = false;
-
-      if(_realLP->lower(i) > R(-infinity))
-      {
-         origCountLower++;
-         hasLower = true;
-      }
-
-      if(_realLP->upper(i) < R(infinity))
-      {
-         origCountUpper++;
-         hasUpper = true;
-      }
-
-      if(hasUpper && hasLower)
-      {
-         origCountBoxed++;
-         origCountUpper--;
-         origCountLower--;
-      }
-
-      if(!hasUpper && !hasLower)
-         origCountFreeCol++;
-   }
-
-   for(int i = 0; i < _realLP->nRows(); i++)
-   {
-      bool hasRhs = false;
-      bool hasLhs = false;
-
-      if(_realLP->lhs(i) > R(-infinity))
-      {
-         origCountLhs++;
-         hasLhs = true;
-      }
-
-      if(_realLP->rhs(i) < R(infinity))
-      {
-         origCountRhs++;
-         hasRhs = true;
-      }
-
-      if(hasRhs && hasLhs)
-      {
-         if(EQ(_realLP->rhs(i), _realLP->lhs(i)))
-            origCountEqual++;
-         else
-            origCountRanged++;
+template <class R> void SoPlexBase<R>::getOriginalProblemStatistics() {
+  numProbRows = _realLP->nRows();
+  numProbCols = _realLP->nCols();
+  nNonzeros = _realLP->nNzos();
+  minAbsNonzero = _realLP->minAbsNzo();
+  maxAbsNonzero = _realLP->maxAbsNzo();
+
+  origCountLower = 0;
+  origCountUpper = 0;
+  origCountBoxed = 0;
+  origCountFreeCol = 0;
+
+  origCountLhs = 0;
+  origCountRhs = 0;
+  origCountRanged = 0;
+  origCountFreeRow = 0;
+
+  for (int i = 0; i < _realLP->nCols(); i++) {
+    bool hasLower = false;
+    bool hasUpper = false;
+
+    if (_realLP->lower(i) > R(-infinity)) {
+      origCountLower++;
+      hasLower = true;
+    }
+
+    if (_realLP->upper(i) < R(infinity)) {
+      origCountUpper++;
+      hasUpper = true;
+    }
+
+    if (hasUpper && hasLower) {
+      origCountBoxed++;
+      origCountUpper--;
+      origCountLower--;
+    }
+
+    if (!hasUpper && !hasLower)
+      origCountFreeCol++;
+  }
+
+  for (int i = 0; i < _realLP->nRows(); i++) {
+    bool hasRhs = false;
+    bool hasLhs = false;
+
+    if (_realLP->lhs(i) > R(-infinity)) {
+      origCountLhs++;
+      hasLhs = true;
+    }
+
+    if (_realLP->rhs(i) < R(infinity)) {
+      origCountRhs++;
+      hasRhs = true;
+    }
+
+    if (hasRhs && hasLhs) {
+      if (EQ(_realLP->rhs(i), _realLP->lhs(i)))
+        origCountEqual++;
+      else
+        origCountRanged++;
 
-         origCountLhs--;
-         origCountRhs--;
-      }
+      origCountLhs--;
+      origCountRhs--;
+    }
 
-      if(!hasRhs && !hasLhs)
-         origCountFreeRow++;
-   }
+    if (!hasRhs && !hasLhs)
+      origCountFreeRow++;
+  }
 }
 
 template <class R>
-void SoPlexBase<R>::printOriginalProblemStatistics(std::ostream& os)
-{
-   os << "  Columns           : " << numProbCols << "\n"
-      << "              boxed : " << origCountBoxed << "\n"
-      << "        lower bound : " << origCountLower << "\n"
-      << "        upper bound : " << origCountUpper << "\n"
-      << "               free : " << origCountFreeCol << "\n"
-      << "  Rows              : " << numProbRows << "\n"
-      << "              equal : " << origCountEqual << "\n"
-      << "             ranged : " << origCountRanged << "\n"
-      << "                lhs : " << origCountLhs << "\n"
-      << "                rhs : " << origCountRhs << "\n"
-      << "               free : " << origCountFreeRow << "\n"
-      << "  Nonzeros          : " << nNonzeros << "\n"
-      << "         per column : " << R(nNonzeros) / R(numProbCols) << "\n"
-      << "            per row : " << R(nNonzeros) / R(numProbRows) << "\n"
-      << "           sparsity : " << R(nNonzeros) / R(numProbCols) / R(numProbRows) << "\n"
-      << "    min. abs. value : " << R(minAbsNonzero) << "\n"
-      << "    max. abs. value : " << R(maxAbsNonzero) << "\n";
+void SoPlexBase<R>::printOriginalProblemStatistics(std::ostream &os) {
+  os << "  Columns           : " << numProbCols << "\n"
+     << "              boxed : " << origCountBoxed << "\n"
+     << "        lower bound : " << origCountLower << "\n"
+     << "        upper bound : " << origCountUpper << "\n"
+     << "               free : " << origCountFreeCol << "\n"
+     << "  Rows              : " << numProbRows << "\n"
+     << "              equal : " << origCountEqual << "\n"
+     << "             ranged : " << origCountRanged << "\n"
+     << "                lhs : " << origCountLhs << "\n"
+     << "                rhs : " << origCountRhs << "\n"
+     << "               free : " << origCountFreeRow << "\n"
+     << "  Nonzeros          : " << nNonzeros << "\n"
+     << "         per column : " << R(nNonzeros) / R(numProbCols) << "\n"
+     << "            per row : " << R(nNonzeros) / R(numProbRows) << "\n"
+     << "           sparsity : "
+     << R(nNonzeros) / R(numProbCols) / R(numProbRows) << "\n"
+     << "    min. abs. value : " << R(minAbsNonzero) << "\n"
+     << "    max. abs. value : " << R(maxAbsNonzero) << "\n";
 }
 
-
-
-/// gets the coefficient of the slack variable in the primal complementary problem
-template <class R>
-R SoPlexBase<R>::getCompSlackVarCoeff(int primalRowNum)
-{
-   int indDir = 1;
-
-   switch(_realLP->rowType(_decompPrimalRowIDs[primalRowNum]))
-   {
-   // NOTE: check the sign of the slackCoeff for the Range constraints. This will depend on the method of
-   // dual conversion.
-   case LPRowBase<R>::RANGE:
-      assert((primalRowNum < _nPrimalRows - 1
-              && _realLP->number(SPxColId(_decompPrimalRowIDs[primalRowNum])) ==
-              _realLP->number(SPxColId(_decompPrimalRowIDs[primalRowNum + 1]))) ||
-             (primalRowNum > 0 && _realLP->number(SPxColId(_decompPrimalRowIDs[primalRowNum - 1])) ==
-              _realLP->number(SPxColId(_decompPrimalRowIDs[primalRowNum]))));
-
-      // determine with primalRowNum and primalRowNum+1 or primalRowNum-1 and primalRowNum have the same row id.
-      if(_realLP->number(SPxColId(_decompPrimalRowIDs[primalRowNum - 1])) ==
-            _realLP->number(SPxColId(_decompPrimalRowIDs[primalRowNum])))
-         indDir = -1;
-
-      if(_compSolver.obj(_compSolver.number(SPxColId(_decompDualColIDs[primalRowNum]))) <
-            _compSolver.obj(_compSolver.number(SPxColId(_decompDualColIDs[primalRowNum + indDir]))))
-         return -SLACKCOEFF;
-      else
-         return SLACKCOEFF;
-
-      break;
-
-   case LPRowBase<R>::GREATER_EQUAL:
+/// gets the coefficient of the slack variable in the primal complementary
+/// problem
+template <class R> R SoPlexBase<R>::getCompSlackVarCoeff(int primalRowNum) {
+  int indDir = 1;
+
+  switch (_realLP->rowType(_decompPrimalRowIDs[primalRowNum])) {
+  // NOTE: check the sign of the slackCoeff for the Range constraints. This will
+  // depend on the method of dual conversion.
+  case LPRowBase<R>::RANGE:
+    assert((primalRowNum < _nPrimalRows - 1 &&
+            _realLP->number(SPxColId(_decompPrimalRowIDs[primalRowNum])) ==
+                _realLP->number(
+                    SPxColId(_decompPrimalRowIDs[primalRowNum + 1]))) ||
+           (primalRowNum > 0 &&
+            _realLP->number(SPxColId(_decompPrimalRowIDs[primalRowNum - 1])) ==
+                _realLP->number(SPxColId(_decompPrimalRowIDs[primalRowNum]))));
+
+    // determine with primalRowNum and primalRowNum+1 or primalRowNum-1 and
+    // primalRowNum have the same row id.
+    if (_realLP->number(SPxColId(_decompPrimalRowIDs[primalRowNum - 1])) ==
+        _realLP->number(SPxColId(_decompPrimalRowIDs[primalRowNum])))
+      indDir = -1;
+
+    if (_compSolver.obj(
+            _compSolver.number(SPxColId(_decompDualColIDs[primalRowNum]))) <
+        _compSolver.obj(_compSolver.number(
+            SPxColId(_decompDualColIDs[primalRowNum + indDir]))))
       return -SLACKCOEFF;
-      break;
-
-   case LPRowBase<R>::EQUAL:
-      assert((primalRowNum < _nPrimalRows - 1
-              && _realLP->number(SPxColId(_decompPrimalRowIDs[primalRowNum])) ==
-              _realLP->number(SPxColId(_decompPrimalRowIDs[primalRowNum + 1]))) ||
-             (primalRowNum > 0 && _realLP->number(SPxColId(_decompPrimalRowIDs[primalRowNum - 1])) ==
-              _realLP->number(SPxColId(_decompPrimalRowIDs[primalRowNum]))));
-
-   // FALLTHROUGH
-   case LPRowBase<R>::LESS_EQUAL:
+    else
       return SLACKCOEFF;
-      break;
 
-   default:
-      throw SPxInternalCodeException("XDECOMPSL01 This should never happen.");
-   }
+    break;
+
+  case LPRowBase<R>::GREATER_EQUAL:
+    return -SLACKCOEFF;
+    break;
+
+  case LPRowBase<R>::EQUAL:
+    assert((primalRowNum < _nPrimalRows - 1 &&
+            _realLP->number(SPxColId(_decompPrimalRowIDs[primalRowNum])) ==
+                _realLP->number(
+                    SPxColId(_decompPrimalRowIDs[primalRowNum + 1]))) ||
+           (primalRowNum > 0 &&
+            _realLP->number(SPxColId(_decompPrimalRowIDs[primalRowNum - 1])) ==
+                _realLP->number(SPxColId(_decompPrimalRowIDs[primalRowNum]))));
+
+  // FALLTHROUGH
+  case LPRowBase<R>::LESS_EQUAL:
+    return SLACKCOEFF;
+    break;
+
+  default:
+    throw SPxInternalCodeException("XDECOMPSL01 This should never happen.");
+  }
 }
 
-
-
 /// gets violation of bounds; returns true on success
 template <class R>
-bool SoPlexBase<R>::getDecompBoundViolation(R& maxviol, R& sumviol)
-{
-   R feastol = realParam(SoPlexBase<R>::FEASTOL);
+bool SoPlexBase<R>::getDecompBoundViolation(R &maxviol, R &sumviol) {
+  R feastol = realParam(SoPlexBase<R>::FEASTOL);
 
-   VectorBase<R>& primal = _solReal._primal;
-   assert(primal.dim() == _realLP->nCols());
+  VectorBase<R> &primal = _solReal._primal;
+  assert(primal.dim() == _realLP->nCols());
 
-   _nDecompViolBounds = 0;
+  _nDecompViolBounds = 0;
 
-   maxviol = 0.0;
-   sumviol = 0.0;
+  maxviol = 0.0;
+  sumviol = 0.0;
 
-   bool isViol = false;
-   bool isMaxViol = false;
+  bool isViol = false;
+  bool isMaxViol = false;
 
-   for(int i = _realLP->nCols() - 1; i >= 0; i--)
-   {
-      R currviol = 0.0;
+  for (int i = _realLP->nCols() - 1; i >= 0; i--) {
+    R currviol = 0.0;
 
-      R viol = _realLP->lower(i) - primal[i];
+    R viol = _realLP->lower(i) - primal[i];
 
-      isViol = false;
-      isMaxViol = false;
-
-      if(viol > 0.0)
-      {
-         sumviol += viol;
+    isViol = false;
+    isMaxViol = false;
 
-         if(viol > maxviol)
-         {
-            maxviol = viol;
-            isMaxViol = true;
-         }
+    if (viol > 0.0) {
+      sumviol += viol;
 
-         if(currviol < viol)
-            currviol = viol;
+      if (viol > maxviol) {
+        maxviol = viol;
+        isMaxViol = true;
       }
 
-      if(GT(viol, R(0.0), feastol))
-         isViol = true;
+      if (currviol < viol)
+        currviol = viol;
+    }
 
-      viol = primal[i] - _realLP->upper(i);
+    if (GT(viol, R(0.0), feastol))
+      isViol = true;
 
-      if(viol > 0.0)
-      {
-         sumviol += viol;
+    viol = primal[i] - _realLP->upper(i);
 
-         if(viol > maxviol)
-         {
-            maxviol = viol;
-            isMaxViol = true;
-         }
+    if (viol > 0.0) {
+      sumviol += viol;
 
-         if(currviol < viol)
-            currviol = viol;
+      if (viol > maxviol) {
+        maxviol = viol;
+        isMaxViol = true;
       }
 
-      if(GT(viol, R(0.0), feastol))
-         isViol = true;
+      if (currviol < viol)
+        currviol = viol;
+    }
 
-      if(isViol)
-      {
-         // updating the violated bounds list
-         if(isMaxViol)
-         {
-            _decompViolatedBounds[_nDecompViolBounds] = _decompViolatedBounds[0];
-            _decompViolatedBounds[0] = i;
-         }
-         else
-            _decompViolatedBounds[_nDecompViolBounds] = i;
-
-         _nDecompViolBounds++;
-      }
-   }
+    if (GT(viol, R(0.0), feastol))
+      isViol = true;
 
-   return true;
-}
+    if (isViol) {
+      // updating the violated bounds list
+      if (isMaxViol) {
+        _decompViolatedBounds[_nDecompViolBounds] = _decompViolatedBounds[0];
+        _decompViolatedBounds[0] = i;
+      } else
+        _decompViolatedBounds[_nDecompViolBounds] = i;
 
+      _nDecompViolBounds++;
+    }
+  }
 
+  return true;
+}
 
 /// gets violation of constraints; returns true on success
 template <class R>
-bool SoPlexBase<R>::getDecompRowViolation(R& maxviol, R& sumviol)
-{
-   R feastol = realParam(SoPlexBase<R>::FEASTOL);
-
-   VectorBase<R>& primal = _solReal._primal;
-   assert(primal.dim() == _realLP->nCols());
+bool SoPlexBase<R>::getDecompRowViolation(R &maxviol, R &sumviol) {
+  R feastol = realParam(SoPlexBase<R>::FEASTOL);
 
-   VectorBase<R> activity(_realLP->nRows());
-   _realLP->computePrimalActivity(primal, activity);
+  VectorBase<R> &primal = _solReal._primal;
+  assert(primal.dim() == _realLP->nCols());
 
-   _nDecompViolRows = 0;
+  VectorBase<R> activity(_realLP->nRows());
+  _realLP->computePrimalActivity(primal, activity);
 
-   maxviol = 0.0;
-   sumviol = 0.0;
+  _nDecompViolRows = 0;
 
-   bool isViol = false;
-   bool isMaxViol = false;
+  maxviol = 0.0;
+  sumviol = 0.0;
 
-   for(int i = _realLP->nRows() - 1; i >= 0; i--)
-   {
-      R currviol = 0.0;
+  bool isViol = false;
+  bool isMaxViol = false;
 
-      isViol = false;
-      isMaxViol = false;
+  for (int i = _realLP->nRows() - 1; i >= 0; i--) {
+    R currviol = 0.0;
 
-      R viol = _realLP->lhs(i) - activity[i];
+    isViol = false;
+    isMaxViol = false;
 
-      if(viol > 0.0)
-      {
-         sumviol += viol;
+    R viol = _realLP->lhs(i) - activity[i];
 
-         if(viol > maxviol)
-         {
-            maxviol = viol;
-            isMaxViol = true;
-         }
+    if (viol > 0.0) {
+      sumviol += viol;
 
-         if(viol > currviol)
-            currviol = viol;
+      if (viol > maxviol) {
+        maxviol = viol;
+        isMaxViol = true;
       }
 
-      if(GT(viol, R(0.0), feastol))
-         isViol = true;
+      if (viol > currviol)
+        currviol = viol;
+    }
 
-      viol = activity[i] - _realLP->rhs(i);
+    if (GT(viol, R(0.0), feastol))
+      isViol = true;
 
-      if(viol > 0.0)
-      {
-         sumviol += viol;
+    viol = activity[i] - _realLP->rhs(i);
 
-         if(viol > maxviol)
-         {
-            maxviol = viol;
-            isMaxViol = true;
-         }
+    if (viol > 0.0) {
+      sumviol += viol;
 
-         if(viol > currviol)
-            currviol = viol;
+      if (viol > maxviol) {
+        maxviol = viol;
+        isMaxViol = true;
       }
 
-      if(GT(viol, R(0.0), feastol))
-         isViol = true;
+      if (viol > currviol)
+        currviol = viol;
+    }
 
-      if(isViol)
-      {
-         // updating the violated rows list
-         if(isMaxViol)
-         {
-            _decompViolatedRows[_nDecompViolRows] = _decompViolatedRows[0];
-            _decompViolatedRows[0] = i;
-         }
-         else
-            _decompViolatedRows[_nDecompViolRows] = i;
-
-         _nDecompViolRows++;
-      }
-   }
+    if (GT(viol, R(0.0), feastol))
+      isViol = true;
 
-   return true;
-}
+    if (isViol) {
+      // updating the violated rows list
+      if (isMaxViol) {
+        _decompViolatedRows[_nDecompViolRows] = _decompViolatedRows[0];
+        _decompViolatedRows[0] = i;
+      } else
+        _decompViolatedRows[_nDecompViolRows] = i;
 
+      _nDecompViolRows++;
+    }
+  }
 
+  return true;
+}
 
 /// function call to terminate the decomposition simplex
-template <class R>
-bool SoPlexBase<R>::decompTerminate(R timeLimit)
-{
-   R maxTime = timeLimit;
+template <class R> bool SoPlexBase<R>::decompTerminate(R timeLimit) {
+  R maxTime = timeLimit;
 
-   // check if a time limit is actually set
-   if(maxTime < 0 || maxTime >= R(infinity))
-      return false;
+  // check if a time limit is actually set
+  if (maxTime < 0 || maxTime >= R(infinity))
+    return false;
 
-   Real currentTime = _statistics->solvingTime->time();
+  Real currentTime = _statistics->solvingTime->time();
 
-   if(currentTime >= maxTime)
-   {
-      MSG_INFO2(spxout, spxout << " --- timelimit (" << _solver.getMaxTime()
-                << ") reached" << std::endl;)
-      _solver.setSolverStatus(SPxSolverBase<R>::ABORT_TIME);
-      return true;
-   }
+  if (currentTime >= maxTime) {
+    MSG_INFO2(spxout, spxout << " --- timelimit (" << _solver.getMaxTime()
+                             << ") reached" << std::endl;)
+    _solver.setSolverStatus(SPxSolverBase<R>::ABORT_TIME);
+    return true;
+  }
 
-   return false;
+  return false;
 }
 
-
-
-/// function to retrieve the original problem row basis status from the reduced and complementary problems
+/// function to retrieve the original problem row basis status from the reduced
+/// and complementary problems
 template <class R>
-void SoPlexBase<R>::getOriginalProblemBasisRowStatus(DataArray< int >& degenerateRowNums,
-      DataArray< typename SPxSolverBase<R>::VarStatus >& degenerateRowStatus, int& nDegenerateRows,
-      int& nNonBasicRows)
-{
-   R feastol = realParam(SoPlexBase<R>::FEASTOL);
-   int basicRow = 0;
-
-   // looping over all rows not contained in the complementary problem
-   for(int i = 0; i < _nElimPrimalRows; i++)
-   {
-      int rowNumber = _realLP->number(_decompElimPrimalRowIDs[i]);
-
+void SoPlexBase<R>::getOriginalProblemBasisRowStatus(
+    DataArray<int> &degenerateRowNums,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &degenerateRowStatus,
+    int &nDegenerateRows, int &nNonBasicRows) {
+  R feastol = realParam(SoPlexBase<R>::FEASTOL);
+  int basicRow = 0;
+
+  // looping over all rows not contained in the complementary problem
+  for (int i = 0; i < _nElimPrimalRows; i++) {
+    int rowNumber = _realLP->number(_decompElimPrimalRowIDs[i]);
+
+    int solverRowNum = _solver.number(_decompReducedProbRowIDs[rowNumber]);
+    assert(solverRowNum >= 0 && solverRowNum < _solver.nRows());
+
+    if (_solver.basis().desc().rowStatus(solverRowNum) ==
+        SPxBasisBase<R>::Desc::
+            P_ON_UPPER) /*||
+                             (_solver.basis().desc().rowStatus(solverRowNum) ==
+                           SPxBasisBase<R>::Desc::D_ON_LOWER &&
+                             EQ(_solver.rhs(solverRowNum) -
+                           _solver.pVec()[solverRowNum], 0.0, feastol)) )*/
+    {
+      _basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_UPPER;
+    } else if (_solver.basis().desc().rowStatus(solverRowNum) ==
+               SPxBasisBase<R>::Desc::
+                   P_ON_LOWER) /*||
+                                    (_solver.basis().desc().rowStatus(solverRowNum)
+                                  == SPxBasisBase<R>::Desc::D_ON_UPPER &&
+                                    EQ(_solver.pVec()[solverRowNum] -
+                                  _solver.lhs(solverRowNum), 0.0, feastol)) )*/
+    {
+      _basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_LOWER;
+    } else if (_solver.basis().desc().rowStatus(solverRowNum) ==
+               SPxBasisBase<R>::Desc::P_FIXED) {
+      _basisStatusRows[rowNumber] = SPxSolverBase<R>::FIXED;
+    } else if (_solver.basis().desc().rowStatus(solverRowNum) ==
+               SPxBasisBase<R>::Desc::P_FREE) {
+      _basisStatusRows[rowNumber] = SPxSolverBase<R>::ZERO;
+    } else {
+      _basisStatusRows[rowNumber] = SPxSolverBase<R>::BASIC;
+      basicRow++;
+    }
+  }
+
+  for (int i = 0; i < _nPrimalRows; i++) {
+    int rowNumber = _realLP->number(_decompPrimalRowIDs[i]);
+
+    // this loop runs over all rows previously in the complementary problem.
+    if (_decompReducedProbRows[rowNumber]) {
       int solverRowNum = _solver.number(_decompReducedProbRowIDs[rowNumber]);
       assert(solverRowNum >= 0 && solverRowNum < _solver.nRows());
 
-      if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_ON_UPPER) /*||
-                                                                                                   (_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_ON_LOWER &&
-                                                                                                   EQ(_solver.rhs(solverRowNum) - _solver.pVec()[solverRowNum], 0.0, feastol)) )*/
-      {
-         _basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_UPPER;
-      }
-      else if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_ON_LOWER) /*||
-                                                                                                        (_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_ON_UPPER &&
-                                                                                                        EQ(_solver.pVec()[solverRowNum] - _solver.lhs(solverRowNum), 0.0, feastol)) )*/
-      {
-         _basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_LOWER;
-      }
-      else if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_FIXED)
-      {
-         _basisStatusRows[rowNumber] = SPxSolverBase<R>::FIXED;
-      }
-      else if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_FREE)
-      {
-         _basisStatusRows[rowNumber] = SPxSolverBase<R>::ZERO;
-      }
-      else
-      {
-         _basisStatusRows[rowNumber] = SPxSolverBase<R>::BASIC;
-         basicRow++;
-      }
-   }
-
-   for(int i = 0; i < _nPrimalRows; i++)
-   {
-      int rowNumber = _realLP->number(_decompPrimalRowIDs[i]);
-
-      // this loop runs over all rows previously in the complementary problem.
-      if(_decompReducedProbRows[rowNumber])
-      {
-         int solverRowNum = _solver.number(_decompReducedProbRowIDs[rowNumber]);
-         assert(solverRowNum >= 0 && solverRowNum < _solver.nRows());
-
-         if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_ON_UPPER)
-         {
-            _basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_UPPER;
-         }
-         else if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_ON_LOWER &&
-                 EQ(_solver.rhs(solverRowNum) - _solver.pVec()[solverRowNum], 0.0, feastol))
-         {
-            // if a row is non basic, but is at its bound then the row number and status is stored
-            degenerateRowNums[nDegenerateRows] = rowNumber;
-            degenerateRowStatus[nDegenerateRows] = SPxSolverBase<R>::ON_UPPER;
-            nDegenerateRows++;
-         }
-         else if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_ON_LOWER)
-         {
-            _basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_LOWER;
-         }
-         else if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::D_ON_UPPER &&
-                 EQ(_solver.pVec()[solverRowNum] - _solver.lhs(solverRowNum), 0.0, feastol))
-         {
-            // if a row is non basic, but is at its bound then the row number and status is stored
-            degenerateRowNums[nDegenerateRows] = rowNumber;
-            degenerateRowStatus[nDegenerateRows] = SPxSolverBase<R>::ON_LOWER;
-            nDegenerateRows++;
-         }
-         else if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_FIXED)
-         {
-            _basisStatusRows[rowNumber] = SPxSolverBase<R>::FIXED;
-         }
-         else if(_solver.basis().desc().rowStatus(solverRowNum) == SPxBasisBase<R>::Desc::P_FREE)
-         {
-            _basisStatusRows[rowNumber] = SPxSolverBase<R>::ZERO;
-         }
-         else
-         {
-            _basisStatusRows[rowNumber] = SPxSolverBase<R>::BASIC;
-            basicRow++;
-         }
+      if (_solver.basis().desc().rowStatus(solverRowNum) ==
+          SPxBasisBase<R>::Desc::P_ON_UPPER) {
+        _basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_UPPER;
+      } else if (_solver.basis().desc().rowStatus(solverRowNum) ==
+                     SPxBasisBase<R>::Desc::D_ON_LOWER &&
+                 EQ(_solver.rhs(solverRowNum) - _solver.pVec()[solverRowNum],
+                    0.0, feastol)) {
+        // if a row is non basic, but is at its bound then the row number and
+        // status is stored
+        degenerateRowNums[nDegenerateRows] = rowNumber;
+        degenerateRowStatus[nDegenerateRows] = SPxSolverBase<R>::ON_UPPER;
+        nDegenerateRows++;
+      } else if (_solver.basis().desc().rowStatus(solverRowNum) ==
+                 SPxBasisBase<R>::Desc::P_ON_LOWER) {
+        _basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_LOWER;
+      } else if (_solver.basis().desc().rowStatus(solverRowNum) ==
+                     SPxBasisBase<R>::Desc::D_ON_UPPER &&
+                 EQ(_solver.pVec()[solverRowNum] - _solver.lhs(solverRowNum),
+                    0.0, feastol)) {
+        // if a row is non basic, but is at its bound then the row number and
+        // status is stored
+        degenerateRowNums[nDegenerateRows] = rowNumber;
+        degenerateRowStatus[nDegenerateRows] = SPxSolverBase<R>::ON_LOWER;
+        nDegenerateRows++;
+      } else if (_solver.basis().desc().rowStatus(solverRowNum) ==
+                 SPxBasisBase<R>::Desc::P_FIXED) {
+        _basisStatusRows[rowNumber] = SPxSolverBase<R>::FIXED;
+      } else if (_solver.basis().desc().rowStatus(solverRowNum) ==
+                 SPxBasisBase<R>::Desc::P_FREE) {
+        _basisStatusRows[rowNumber] = SPxSolverBase<R>::ZERO;
+      } else {
+        _basisStatusRows[rowNumber] = SPxSolverBase<R>::BASIC;
+        basicRow++;
       }
-      else
-      {
-         _basisStatusRows[rowNumber] = SPxSolverBase<R>::BASIC;
-         basicRow++;
-
-         switch(_realLP->rowType(_decompPrimalRowIDs[i]))
-         {
-         case LPRowBase<R>::RANGE:
-            //assert(_realLP->number(SPxColId(_decompPrimalRowIDs[i])) ==
-            //_realLP->number(SPxColId(_decompPrimalRowIDs[i+1])));
-            //assert(_compSolver.obj(_compSolver.number(SPxColId(_decompDualColIDs[i]))) !=
-            //_compSolver.obj(_compSolver.number(SPxColId(_decompDualColIDs[i + 1]))));
-
-            //// NOTE: This is not correct at present. Need to modify the inequalities. Look at the dual conversion
-            //// function to get this correct.
-            //if( _compSolver.obj(_compSolver.number(SPxColId(_decompDualColIDs[i]))) <
-            //_compSolver.obj(_compSolver.number(SPxColId(_decompDualColIDs[i + 1]))))
-            //{
-            //if( _compSolver.basis().desc().rowStatus(_compSolver.number(SPxColId(_decompDualColIDs[i]))) ==
-            //SPxBasisBase<R>::Desc::D_ON_LOWER )
-            //{
-            //_basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_LOWER;
-            //}
-            //else if( _compSolver.basis().desc().rowStatus(_compSolver.number(SPxColId(_decompDualColIDs[i + 1]))) ==
-            //SPxBasisBase<R>::Desc::D_ON_UPPER )
-            //{
-            //_basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_UPPER;
-            //}
-            //else
-            //{
-            //_basisStatusRows[rowNumber] = SPxSolverBase<R>::BASIC;
-            //basicRow++;
-            //}
-            //}
-            //else
-            //{
-            //if( _compSolver.basis().desc().rowStatus(_compSolver.number(SPxColId(_decompDualColIDs[i]))) ==
-            //SPxBasisBase<R>::Desc::D_ON_UPPER )
-            //{
-            //_basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_UPPER;
-            //}
-            //else if( _compSolver.basis().desc().rowStatus(_compSolver.number(SPxColId(_decompDualColIDs[i + 1]))) ==
-            //SPxBasisBase<R>::Desc::D_ON_LOWER )
-            //{
-            //_basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_LOWER;
-            //}
-            //else
-            //{
-            //_basisStatusRows[rowNumber] = SPxSolverBase<R>::BASIC;
-            //basicRow++;
-            //}
-            //}
-
-            i++;
-            break;
-
-         case LPRowBase<R>::EQUAL:
-            //assert(_realLP->number(SPxColId(_decompPrimalRowIDs[i])) ==
-            //_realLP->number(SPxColId(_decompPrimalRowIDs[i+1])));
-
-            //_basisStatusRows[rowNumber] = SPxSolverBase<R>::FIXED;
-
-            i++;
-            break;
-
-         case LPRowBase<R>::GREATER_EQUAL:
-            //if( _compSolver.basis().desc().rowStatus(_compSolver.number(SPxColId(_decompDualColIDs[i]))) ==
-            //SPxBasisBase<R>::Desc::D_ON_LOWER )
-            //{
-            //_basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_LOWER;
-            //}
-            //else
-            //{
-            //_basisStatusRows[rowNumber] = SPxSolverBase<R>::BASIC;
-            //basicRow++;
-            //}
-
-            break;
-
-         case LPRowBase<R>::LESS_EQUAL:
-            //if( _compSolver.basis().desc().rowStatus(_compSolver.number(SPxColId(_decompDualColIDs[i]))) ==
-            //SPxBasisBase<R>::Desc::D_ON_UPPER )
-            //{
-            //_basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_UPPER;
-            //}
-            //else
-            //{
-            //_basisStatusRows[rowNumber] = SPxSolverBase<R>::BASIC;
-            //basicRow++;
-            //}
-
-            break;
-
-         default:
-            throw SPxInternalCodeException("XDECOMPSL01 This should never happen.");
-         }
+    } else {
+      _basisStatusRows[rowNumber] = SPxSolverBase<R>::BASIC;
+      basicRow++;
+
+      switch (_realLP->rowType(_decompPrimalRowIDs[i])) {
+      case LPRowBase<R>::RANGE:
+        // assert(_realLP->number(SPxColId(_decompPrimalRowIDs[i])) ==
+        //_realLP->number(SPxColId(_decompPrimalRowIDs[i+1])));
+        // assert(_compSolver.obj(_compSolver.number(SPxColId(_decompDualColIDs[i])))
+        // != _compSolver.obj(_compSolver.number(SPxColId(_decompDualColIDs[i +
+        //1]))));
+
+        //// NOTE: This is not correct at present. Need to modify the
+        ///inequalities. Look at the dual conversion / function to get this
+        ///correct.
+        // if(
+        // _compSolver.obj(_compSolver.number(SPxColId(_decompDualColIDs[i]))) <
+        //_compSolver.obj(_compSolver.number(SPxColId(_decompDualColIDs[i +
+        //1]))))
+        //{
+        // if(
+        // _compSolver.basis().desc().rowStatus(_compSolver.number(SPxColId(_decompDualColIDs[i])))
+        // == SPxBasisBase<R>::Desc::D_ON_LOWER )
+        //{
+        //_basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_LOWER;
+        // }
+        // else if(
+        // _compSolver.basis().desc().rowStatus(_compSolver.number(SPxColId(_decompDualColIDs[i
+        // + 1]))) == SPxBasisBase<R>::Desc::D_ON_UPPER )
+        //{
+        //_basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_UPPER;
+        // }
+        // else
+        //{
+        //_basisStatusRows[rowNumber] = SPxSolverBase<R>::BASIC;
+        // basicRow++;
+        // }
+        // }
+        // else
+        //{
+        // if(
+        // _compSolver.basis().desc().rowStatus(_compSolver.number(SPxColId(_decompDualColIDs[i])))
+        // == SPxBasisBase<R>::Desc::D_ON_UPPER )
+        //{
+        //_basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_UPPER;
+        // }
+        // else if(
+        // _compSolver.basis().desc().rowStatus(_compSolver.number(SPxColId(_decompDualColIDs[i
+        // + 1]))) == SPxBasisBase<R>::Desc::D_ON_LOWER )
+        //{
+        //_basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_LOWER;
+        // }
+        // else
+        //{
+        //_basisStatusRows[rowNumber] = SPxSolverBase<R>::BASIC;
+        // basicRow++;
+        // }
+        // }
+
+        i++;
+        break;
+
+      case LPRowBase<R>::EQUAL:
+        // assert(_realLP->number(SPxColId(_decompPrimalRowIDs[i])) ==
+        //_realLP->number(SPxColId(_decompPrimalRowIDs[i+1])));
+
+        //_basisStatusRows[rowNumber] = SPxSolverBase<R>::FIXED;
+
+        i++;
+        break;
+
+      case LPRowBase<R>::GREATER_EQUAL:
+        // if(
+        // _compSolver.basis().desc().rowStatus(_compSolver.number(SPxColId(_decompDualColIDs[i])))
+        // == SPxBasisBase<R>::Desc::D_ON_LOWER )
+        //{
+        //_basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_LOWER;
+        // }
+        // else
+        //{
+        //_basisStatusRows[rowNumber] = SPxSolverBase<R>::BASIC;
+        // basicRow++;
+        // }
+
+        break;
+
+      case LPRowBase<R>::LESS_EQUAL:
+        // if(
+        // _compSolver.basis().desc().rowStatus(_compSolver.number(SPxColId(_decompDualColIDs[i])))
+        // == SPxBasisBase<R>::Desc::D_ON_UPPER )
+        //{
+        //_basisStatusRows[rowNumber] = SPxSolverBase<R>::ON_UPPER;
+        // }
+        // else
+        //{
+        //_basisStatusRows[rowNumber] = SPxSolverBase<R>::BASIC;
+        // basicRow++;
+        // }
+
+        break;
+
+      default:
+        throw SPxInternalCodeException("XDECOMPSL01 This should never happen.");
       }
-   }
+    }
+  }
 
-   nNonBasicRows = _realLP->nRows() - basicRow - nDegenerateRows;
-   MSG_INFO2(spxout, spxout << "Number of non-basic rows: " << nNonBasicRows << " (from "
-             << _realLP->nRows() << ")" << std::endl);
+  nNonBasicRows = _realLP->nRows() - basicRow - nDegenerateRows;
+  MSG_INFO2(spxout, spxout << "Number of non-basic rows: " << nNonBasicRows
+                           << " (from " << _realLP->nRows() << ")"
+                           << std::endl);
 }
 
-
-/// function to retrieve the column status for the original problem basis from the reduced and complementary problems
-// all columns are currently in the reduced problem, so it is only necessary to retrieve the status from there.
-// However, a transformation of the columns has been made, so it is only possible to retrieve the status from the
-// variable bound constraints.
+/// function to retrieve the column status for the original problem basis from
+/// the reduced and complementary problems
+// all columns are currently in the reduced problem, so it is only necessary to
+// retrieve the status from there. However, a transformation of the columns has
+// been made, so it is only possible to retrieve the status from the variable
+// bound constraints.
 template <class R>
-void SoPlexBase<R>::getOriginalProblemBasisColStatus(int& nNonBasicCols)
-{
-   R feastol = realParam(SoPlexBase<R>::FEASTOL);
-   int basicCol = 0;
-   int numZeroDual = 0;
-
-   // looping over all variable bound constraints
-   for(int i = 0; i < _realLP->nCols(); i++)
-   {
-      if(!_decompReducedProbColRowIDs[i].isValid())
-         continue;
-
-      int rowNumber = _solver.number(_decompReducedProbColRowIDs[i]);
-
-      if(_decompReducedProbColRowIDs[i].isValid())
+void SoPlexBase<R>::getOriginalProblemBasisColStatus(int &nNonBasicCols) {
+  R feastol = realParam(SoPlexBase<R>::FEASTOL);
+  int basicCol = 0;
+  int numZeroDual = 0;
+
+  // looping over all variable bound constraints
+  for (int i = 0; i < _realLP->nCols(); i++) {
+    if (!_decompReducedProbColRowIDs[i].isValid())
+      continue;
+
+    int rowNumber = _solver.number(_decompReducedProbColRowIDs[i]);
+
+    if (_decompReducedProbColRowIDs[i].isValid()) {
+      if (_solver.basis().desc().rowStatus(rowNumber) ==
+          SPxBasisBase<R>::Desc::
+              P_ON_UPPER) /*||
+                                (_solver.basis().desc().rowStatus(rowNumber) ==
+                             SPxBasisBase<R>::Desc::D_ON_LOWER &&
+                                EQ(_solver.rhs(rowNumber) -
+                             _solver.pVec()[rowNumber], 0.0, feastol)) )*/
       {
-         if(_solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::P_ON_UPPER) /*||
-                                                                                                    (_solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::D_ON_LOWER &&
-                                                                                                    EQ(_solver.rhs(rowNumber) - _solver.pVec()[rowNumber], 0.0, feastol)) )*/
-         {
-            _basisStatusCols[i] = SPxSolverBase<R>::ON_UPPER;
-         }
-         else if(_solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::P_ON_LOWER) /*||
-                                                                                                         (_solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::D_ON_UPPER &&
-                                                                                                         EQ(_solver.pVec()[rowNumber] - _solver.lhs(rowNumber), 0.0, feastol)) )*/
-         {
-            _basisStatusCols[i] = SPxSolverBase<R>::ON_LOWER;
-         }
-         else if(_solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::P_FIXED)
-         {
-            _basisStatusCols[i] = SPxSolverBase<R>::FIXED;
-         }
-         else if(_solver.basis().desc().rowStatus(rowNumber) == SPxBasisBase<R>::Desc::P_FREE)
-         {
-            _basisStatusCols[i] = SPxSolverBase<R>::ZERO;
-         }
-         else
-         {
-            _basisStatusCols[i] = SPxSolverBase<R>::BASIC;
-            basicCol++;
-         }
+        _basisStatusCols[i] = SPxSolverBase<R>::ON_UPPER;
+      } else if (_solver.basis().desc().rowStatus(rowNumber) ==
+                 SPxBasisBase<R>::Desc::
+                     P_ON_LOWER) /*||
+                                       (_solver.basis().desc().rowStatus(rowNumber)
+                                    == SPxBasisBase<R>::Desc::D_ON_UPPER &&
+                                       EQ(_solver.pVec()[rowNumber] -
+                                    _solver.lhs(rowNumber), 0.0, feastol)) )*/
+      {
+        _basisStatusCols[i] = SPxSolverBase<R>::ON_LOWER;
+      } else if (_solver.basis().desc().rowStatus(rowNumber) ==
+                 SPxBasisBase<R>::Desc::P_FIXED) {
+        _basisStatusCols[i] = SPxSolverBase<R>::FIXED;
+      } else if (_solver.basis().desc().rowStatus(rowNumber) ==
+                 SPxBasisBase<R>::Desc::P_FREE) {
+        _basisStatusCols[i] = SPxSolverBase<R>::ZERO;
+      } else {
+        _basisStatusCols[i] = SPxSolverBase<R>::BASIC;
+        basicCol++;
       }
-
-      if(EQ(_solver.fVec()[i], 0.0, feastol))
-         numZeroDual++;
-   }
-
-   nNonBasicCols = _realLP->nCols() - basicCol;
-   MSG_INFO2(spxout, spxout << "Number of non-basic columns: "
-             << nNonBasicCols << " (from " << _realLP->nCols() << ")" << std::endl
-             << "Number of zero dual columns: " << numZeroDual << " (from " << _realLP->nCols() << ")" <<
-             std::endl);
+    }
+
+    if (EQ(_solver.fVec()[i], 0.0, feastol))
+      numZeroDual++;
+  }
+
+  nNonBasicCols = _realLP->nCols() - basicCol;
+  MSG_INFO2(spxout, spxout << "Number of non-basic columns: " << nNonBasicCols
+                           << " (from " << _realLP->nCols() << ")" << std::endl
+                           << "Number of zero dual columns: " << numZeroDual
+                           << " (from " << _realLP->nCols() << ")"
+                           << std::endl);
 }
 
-
-
-/// function to build a basis for the original problem as given by the solution to the reduced problem
+/// function to build a basis for the original problem as given by the solution
+/// to the reduced problem
 template <class R>
-void SoPlexBase<R>::_writeOriginalProblemBasis(const char* filename, NameSet* rowNames,
-      NameSet* colNames, bool cpxFormat)
-{
-   int numrows = _realLP->nRows();
-   int numcols = _realLP->nCols();
-   int nNonBasicRows = 0;
-   int nNonBasicCols = 0;
-   int nDegenerateRows = 0;
-   DataArray< int > degenerateRowNums;   // array to store the orig prob row number of degenerate rows
-   DataArray< typename SPxSolverBase<R>::VarStatus >
-   degenerateRowStatus;  // possible status for the degenerate rows in the orig prob
-
-   // setting the basis status rows and columns to size of the original problem
-   _basisStatusRows.reSize(numrows);
-   _basisStatusCols.reSize(numcols);
-
-   degenerateRowNums.reSize(numrows);
-   degenerateRowStatus.reSize(numrows);
-
-   // setting the row and column status for the original problem
-   getOriginalProblemBasisRowStatus(degenerateRowNums, degenerateRowStatus, nDegenerateRows,
-                                    nNonBasicRows);
-   getOriginalProblemBasisColStatus(nNonBasicCols);
-
-   // checking the consistency of the non-basic rows and columns for printing out the basis.
-   // it is necessary to have numcols of non-basic rows and columns.
-   // if there are not enought non-basic rows and columns, then the degenerate rows are set as non-basic.
-   // all degenerate rows that are not changed to non-basic must be set to basic.
-   assert(nDegenerateRows + nNonBasicRows + nNonBasicCols >= numcols);
-   int degenRowsSetNonBasic = 0;
-
-   for(int i = 0; i < nDegenerateRows; i++)
-   {
-      if(nNonBasicRows + nNonBasicCols + degenRowsSetNonBasic < numcols)
-      {
-         _basisStatusRows[degenerateRowNums[i]] = degenerateRowStatus[i];
-         degenRowsSetNonBasic++;
-      }
-      else
-         _basisStatusRows[degenerateRowNums[i]] = SPxSolverBase<R>::BASIC;
-   }
-
-   // writing the basis file for the original problem
-   bool wasRealLPLoaded = _isRealLPLoaded;
-   _isRealLPLoaded = false;
-   writeBasisFile(filename, rowNames, colNames, cpxFormat);
-   _isRealLPLoaded = wasRealLPLoaded;
+void SoPlexBase<R>::_writeOriginalProblemBasis(const char *filename,
+                                               NameSet *rowNames,
+                                               NameSet *colNames,
+                                               bool cpxFormat) {
+  int numrows = _realLP->nRows();
+  int numcols = _realLP->nCols();
+  int nNonBasicRows = 0;
+  int nNonBasicCols = 0;
+  int nDegenerateRows = 0;
+  DataArray<int> degenerateRowNums; // array to store the orig prob row number
+                                    // of degenerate rows
+  DataArray<typename SPxSolverBase<R>::VarStatus>
+      degenerateRowStatus; // possible status for the degenerate rows in the
+                           // orig prob
+
+  // setting the basis status rows and columns to size of the original problem
+  _basisStatusRows.reSize(numrows);
+  _basisStatusCols.reSize(numcols);
+
+  degenerateRowNums.reSize(numrows);
+  degenerateRowStatus.reSize(numrows);
+
+  // setting the row and column status for the original problem
+  getOriginalProblemBasisRowStatus(degenerateRowNums, degenerateRowStatus,
+                                   nDegenerateRows, nNonBasicRows);
+  getOriginalProblemBasisColStatus(nNonBasicCols);
+
+  // checking the consistency of the non-basic rows and columns for printing out
+  // the basis. it is necessary to have numcols of non-basic rows and columns.
+  // if there are not enought non-basic rows and columns, then the degenerate
+  // rows are set as non-basic. all degenerate rows that are not changed to
+  // non-basic must be set to basic.
+  assert(nDegenerateRows + nNonBasicRows + nNonBasicCols >= numcols);
+  int degenRowsSetNonBasic = 0;
+
+  for (int i = 0; i < nDegenerateRows; i++) {
+    if (nNonBasicRows + nNonBasicCols + degenRowsSetNonBasic < numcols) {
+      _basisStatusRows[degenerateRowNums[i]] = degenerateRowStatus[i];
+      degenRowsSetNonBasic++;
+    } else
+      _basisStatusRows[degenerateRowNums[i]] = SPxSolverBase<R>::BASIC;
+  }
+
+  // writing the basis file for the original problem
+  bool wasRealLPLoaded = _isRealLPLoaded;
+  _isRealLPLoaded = false;
+  writeBasisFile(filename, rowNames, colNames, cpxFormat);
+  _isRealLPLoaded = wasRealLPLoaded;
 }
 } // namespace soplex
diff --git a/src/soplex/solverational.hpp b/src/soplex/solverational.hpp
index a4a1567..95417e9 100644
--- a/src/soplex/solverational.hpp
+++ b/src/soplex/solverational.hpp
@@ -21,1605 +21,1510 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
-#include <iostream>
 #include <assert.h>
+#include <iostream>
 
 #include "soplex.h"
-#include "soplex/statistics.h"
-#include "soplex/slufactor_rational.h"
 #include "soplex/ratrecon.h"
+#include "soplex/slufactor_rational.h"
+#include "soplex/statistics.h"
 
-namespace soplex
-{
+namespace soplex {
 
 /// solves rational LP
 template <class R>
-void SoPlexBase<R>::_optimizeRational(volatile bool* interrupt)
-{
+void SoPlexBase<R>::_optimizeRational(volatile bool *interrupt) {
 #ifndef SOPLEX_WITH_BOOST
-   MSG_ERROR(std::cerr << "ERROR: rational solve without Boost not defined!" << std::endl;)
-   return;
+  MSG_ERROR(std::cerr << "ERROR: rational solve without Boost not defined!"
+                      << std::endl;)
+  return;
 #else
-   bool hasUnboundedRay = false;
-   bool infeasibilityNotCertified = false;
-   bool unboundednessNotCertified = false;
-
-   // start timing
-   _statistics->solvingTime->start();
-   _statistics->preprocessingTime->start();
-
-   // remember that last solve was rational
-   _lastSolveMode = SOLVEMODE_RATIONAL;
-
-   // ensure that the solver has the original problemo
-   if(!_isRealLPLoaded)
-   {
-      assert(_realLP != &_solver);
-
-      _solver.loadLP(*_realLP);
-      spx_free(_realLP);
-      _realLP = &_solver;
-      _isRealLPLoaded = true;
-   }
-   // during the rational solve, we always store basis information in the basis arrays
-   else if(_hasBasis)
-   {
-      _basisStatusRows.reSize(numRows());
-      _basisStatusCols.reSize(numCols());
-      _solver.getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr(), _basisStatusRows.size(),
-                       _basisStatusCols.size());
-   }
-
-   // store objective, bounds, and sides of Real LP in case they will be modified during iterative refinement
-   _storeLPReal();
-
-   // deactivate objective limit in floating-point solver
-   if(realParam(SoPlexBase<R>::OBJLIMIT_LOWER) > -realParam(SoPlexBase<R>::INFTY)
-         || realParam(SoPlexBase<R>::OBJLIMIT_UPPER) < realParam(SoPlexBase<R>::INFTY))
-   {
-      MSG_INFO2(spxout, spxout << "Deactivating objective limit.\n");
-   }
-
-   _solver.setTerminationValue(realParam(SoPlexBase<R>::INFTY));
-
-   _statistics->preprocessingTime->stop();
-
-   // apply lifting to reduce range of nonzero matrix coefficients
-   if(boolParam(SoPlexBase<R>::LIFTING))
-      _lift();
-
-   // force column representation
-   ///@todo implement row objectives with row representation
-   int oldRepresentation = intParam(SoPlexBase<R>::REPRESENTATION);
-   setIntParam(SoPlexBase<R>::REPRESENTATION, SoPlexBase<R>::REPRESENTATION_COLUMN);
-
-   // force ratio test (avoid bound flipping)
-   int oldRatiotester = intParam(SoPlexBase<R>::RATIOTESTER);
-   setIntParam(SoPlexBase<R>::RATIOTESTER, SoPlexBase<R>::RATIOTESTER_FAST);
-
-   ///@todo implement handling of row objectives in Cplex interface
+  bool hasUnboundedRay = false;
+  bool infeasibilityNotCertified = false;
+  bool unboundednessNotCertified = false;
+
+  // start timing
+  _statistics->solvingTime->start();
+  _statistics->preprocessingTime->start();
+
+  // remember that last solve was rational
+  _lastSolveMode = SOLVEMODE_RATIONAL;
+
+  // ensure that the solver has the original problemo
+  if (!_isRealLPLoaded) {
+    assert(_realLP != &_solver);
+
+    _solver.loadLP(*_realLP);
+    spx_free(_realLP);
+    _realLP = &_solver;
+    _isRealLPLoaded = true;
+  }
+  // during the rational solve, we always store basis information in the basis
+  // arrays
+  else if (_hasBasis) {
+    _basisStatusRows.reSize(numRows());
+    _basisStatusCols.reSize(numCols());
+    _solver.getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr(),
+                     _basisStatusRows.size(), _basisStatusCols.size());
+  }
+
+  // store objective, bounds, and sides of Real LP in case they will be modified
+  // during iterative refinement
+  _storeLPReal();
+
+  // deactivate objective limit in floating-point solver
+  if (realParam(SoPlexBase<R>::OBJLIMIT_LOWER) >
+          -realParam(SoPlexBase<R>::INFTY) ||
+      realParam(SoPlexBase<R>::OBJLIMIT_UPPER) <
+          realParam(SoPlexBase<R>::INFTY)) {
+    MSG_INFO2(spxout, spxout << "Deactivating objective limit.\n");
+  }
+
+  _solver.setTerminationValue(realParam(SoPlexBase<R>::INFTY));
+
+  _statistics->preprocessingTime->stop();
+
+  // apply lifting to reduce range of nonzero matrix coefficients
+  if (boolParam(SoPlexBase<R>::LIFTING))
+    _lift();
+
+  // force column representation
+  ///@todo implement row objectives with row representation
+  int oldRepresentation = intParam(SoPlexBase<R>::REPRESENTATION);
+  setIntParam(SoPlexBase<R>::REPRESENTATION,
+              SoPlexBase<R>::REPRESENTATION_COLUMN);
+
+  // force ratio test (avoid bound flipping)
+  int oldRatiotester = intParam(SoPlexBase<R>::RATIOTESTER);
+  setIntParam(SoPlexBase<R>::RATIOTESTER, SoPlexBase<R>::RATIOTESTER_FAST);
+
+  ///@todo implement handling of row objectives in Cplex interface
 #ifdef SOPLEX_WITH_CPX
-   int oldEqtrans = boolParam(SoPlexBase<R>::EQTRANS);
-   setBoolParam(SoPlexBase<R>::EQTRANS, true);
+  int oldEqtrans = boolParam(SoPlexBase<R>::EQTRANS);
+  setBoolParam(SoPlexBase<R>::EQTRANS, true);
 #endif
 
-   // introduce slack variables to transform inequality constraints into equations
-   if(boolParam(SoPlexBase<R>::EQTRANS))
-      _transformEquality();
+  // introduce slack variables to transform inequality constraints into
+  // equations
+  if (boolParam(SoPlexBase<R>::EQTRANS))
+    _transformEquality();
+
+  _storedBasis = false;
+
+  bool stoppedTime;
+  bool stoppedIter;
+
+  do {
+    bool primalFeasible = false;
+    bool dualFeasible = false;
+    bool infeasible = false;
+    bool unbounded = false;
+    bool error = false;
+    stoppedTime = false;
+    stoppedIter = false;
+
+    // solve problem with iterative refinement and recovery mechanism
+    _performOptIRStable(_solRational, !unboundednessNotCertified,
+                        !infeasibilityNotCertified, 0, primalFeasible,
+                        dualFeasible, infeasible, unbounded, stoppedTime,
+                        stoppedIter, error);
+
+    // case: an unrecoverable error occured
+    if (error) {
+      _status = SPxSolverBase<R>::ERROR;
+      break;
+    }
+    // case: stopped due to some limit
+    else if (stoppedTime) {
+      _status = SPxSolverBase<R>::ABORT_TIME;
+      break;
+    } else if (stoppedIter) {
+      _status = SPxSolverBase<R>::ABORT_ITER;
+      break;
+    }
+    // case: unboundedness detected for the first time
+    else if (unbounded && !unboundednessNotCertified) {
+      SolRational solUnbounded;
 
-   _storedBasis = false;
+      _performUnboundedIRStable(solUnbounded, hasUnboundedRay, stoppedTime,
+                                stoppedIter, error);
 
-   bool stoppedTime;
-   bool stoppedIter;
+      assert(!hasUnboundedRay || solUnbounded.hasPrimalRay());
+      assert(!solUnbounded.hasPrimalRay() || hasUnboundedRay);
 
-   do
-   {
-      bool primalFeasible = false;
-      bool dualFeasible = false;
-      bool infeasible = false;
-      bool unbounded = false;
-      bool error = false;
-      stoppedTime = false;
-      stoppedIter = false;
+      if (error) {
+        MSG_INFO1(spxout, spxout << "Error while testing for unboundedness.\n");
+        _status = SPxSolverBase<R>::ERROR;
+        break;
+      }
 
-      // solve problem with iterative refinement and recovery mechanism
-      _performOptIRStable(_solRational, !unboundednessNotCertified, !infeasibilityNotCertified, 0,
-                          primalFeasible, dualFeasible, infeasible, unbounded, stoppedTime, stoppedIter, error);
+      if (hasUnboundedRay) {
+        MSG_INFO1(
+            spxout,
+            spxout << "Dual infeasible.  Primal unbounded ray available.\n");
+      } else {
+        MSG_INFO1(
+            spxout,
+            spxout << "Dual feasible.  Rejecting primal unboundedness.\n");
+      }
 
-      // case: an unrecoverable error occured
-      if(error)
-      {
-         _status = SPxSolverBase<R>::ERROR;
-         break;
+      unboundednessNotCertified = !hasUnboundedRay;
+
+      if (stoppedTime) {
+        _status = SPxSolverBase<R>::ABORT_TIME;
+        break;
+      } else if (stoppedIter) {
+        _status = SPxSolverBase<R>::ABORT_ITER;
+        break;
       }
-      // case: stopped due to some limit
-      else if(stoppedTime)
-      {
-         _status = SPxSolverBase<R>::ABORT_TIME;
-         break;
+
+      _performFeasIRStable(_solRational, infeasible, stoppedTime, stoppedIter,
+                           error);
+
+      ///@todo this should be stored already earlier, possible switch use
+      ///solRational above and solFeas here
+      if (hasUnboundedRay) {
+        _solRational._primalRay = solUnbounded._primalRay;
+        _solRational._hasPrimalRay = true;
       }
-      else if(stoppedIter)
-      {
-         _status = SPxSolverBase<R>::ABORT_ITER;
-         break;
+
+      if (error) {
+        MSG_INFO1(spxout, spxout << "Error while testing for feasibility.\n");
+        _status = SPxSolverBase<R>::ERROR;
+        break;
+      } else if (stoppedTime) {
+        _status = SPxSolverBase<R>::ABORT_TIME;
+        break;
+      } else if (stoppedIter) {
+        _status = SPxSolverBase<R>::ABORT_ITER;
+        break;
+      } else if (infeasible) {
+        MSG_INFO1(spxout,
+                  spxout << "Primal infeasible.  Dual Farkas ray available.\n");
+        _status = SPxSolverBase<R>::INFEASIBLE;
+        break;
+      } else if (hasUnboundedRay) {
+        MSG_INFO1(spxout, spxout << "Primal feasible and unbounded.\n");
+        _status = SPxSolverBase<R>::UNBOUNDED;
+        break;
+      } else {
+        MSG_INFO1(spxout, spxout << "Primal feasible and bounded.\n");
+        continue;
       }
-      // case: unboundedness detected for the first time
-      else if(unbounded && !unboundednessNotCertified)
-      {
-         SolRational solUnbounded;
-
-         _performUnboundedIRStable(solUnbounded, hasUnboundedRay, stoppedTime, stoppedIter, error);
-
-         assert(!hasUnboundedRay || solUnbounded.hasPrimalRay());
-         assert(!solUnbounded.hasPrimalRay() || hasUnboundedRay);
-
-         if(error)
-         {
-            MSG_INFO1(spxout, spxout << "Error while testing for unboundedness.\n");
-            _status = SPxSolverBase<R>::ERROR;
-            break;
-         }
-
-         if(hasUnboundedRay)
-         {
-            MSG_INFO1(spxout, spxout << "Dual infeasible.  Primal unbounded ray available.\n");
-         }
-         else
-         {
-            MSG_INFO1(spxout, spxout << "Dual feasible.  Rejecting primal unboundedness.\n");
-         }
-
-         unboundednessNotCertified = !hasUnboundedRay;
-
-         if(stoppedTime)
-         {
-            _status = SPxSolverBase<R>::ABORT_TIME;
-            break;
-         }
-         else if(stoppedIter)
-         {
-            _status = SPxSolverBase<R>::ABORT_ITER;
-            break;
-         }
-
-         _performFeasIRStable(_solRational, infeasible, stoppedTime, stoppedIter, error);
-
-         ///@todo this should be stored already earlier, possible switch use solRational above and solFeas here
-         if(hasUnboundedRay)
-         {
-            _solRational._primalRay = solUnbounded._primalRay;
-            _solRational._hasPrimalRay = true;
-         }
-
-         if(error)
-         {
-            MSG_INFO1(spxout, spxout << "Error while testing for feasibility.\n");
-            _status = SPxSolverBase<R>::ERROR;
-            break;
-         }
-         else if(stoppedTime)
-         {
-            _status = SPxSolverBase<R>::ABORT_TIME;
-            break;
-         }
-         else if(stoppedIter)
-         {
-            _status = SPxSolverBase<R>::ABORT_ITER;
-            break;
-         }
-         else if(infeasible)
-         {
-            MSG_INFO1(spxout, spxout << "Primal infeasible.  Dual Farkas ray available.\n");
-            _status = SPxSolverBase<R>::INFEASIBLE;
-            break;
-         }
-         else if(hasUnboundedRay)
-         {
-            MSG_INFO1(spxout, spxout << "Primal feasible and unbounded.\n");
-            _status = SPxSolverBase<R>::UNBOUNDED;
-            break;
-         }
-         else
-         {
-            MSG_INFO1(spxout, spxout << "Primal feasible and bounded.\n");
-            continue;
-         }
+    }
+    // case: infeasibility detected
+    else if (infeasible && !infeasibilityNotCertified) {
+      _storeBasis();
+
+      _performFeasIRStable(_solRational, infeasible, stoppedTime, stoppedIter,
+                           error);
+
+      if (error) {
+        MSG_INFO1(spxout, spxout << "Error while testing for infeasibility.\n");
+        _status = SPxSolverBase<R>::ERROR;
+        _restoreBasis();
+        break;
       }
-      // case: infeasibility detected
-      else if(infeasible && !infeasibilityNotCertified)
-      {
-         _storeBasis();
-
-         _performFeasIRStable(_solRational, infeasible, stoppedTime, stoppedIter, error);
-
-         if(error)
-         {
-            MSG_INFO1(spxout, spxout << "Error while testing for infeasibility.\n");
-            _status = SPxSolverBase<R>::ERROR;
-            _restoreBasis();
-            break;
-         }
-
-         infeasibilityNotCertified = !infeasible;
-
-         if(stoppedTime)
-         {
-            _status = SPxSolverBase<R>::ABORT_TIME;
-            _restoreBasis();
-            break;
-         }
-         else if(stoppedIter)
-         {
-            _status = SPxSolverBase<R>::ABORT_ITER;
-            _restoreBasis();
-            break;
-         }
-
-         if(infeasible && boolParam(SoPlexBase<R>::TESTDUALINF))
-         {
-            SolRational solUnbounded;
-
-            _performUnboundedIRStable(solUnbounded, hasUnboundedRay, stoppedTime, stoppedIter, error);
-
-            assert(!hasUnboundedRay || solUnbounded.hasPrimalRay());
-            assert(!solUnbounded.hasPrimalRay() || hasUnboundedRay);
-
-            if(error)
-            {
-               MSG_INFO1(spxout, spxout << "Error while testing for dual infeasibility.\n");
-               _status = SPxSolverBase<R>::ERROR;
-               _restoreBasis();
-               break;
-            }
 
-            if(hasUnboundedRay)
-            {
-               MSG_INFO1(spxout, spxout << "Dual infeasible.  Primal unbounded ray available.\n");
-               _solRational._primalRay = solUnbounded._primalRay;
-               _solRational._hasPrimalRay = true;
-            }
-            else if(solUnbounded._isDualFeasible)
-            {
-               MSG_INFO1(spxout, spxout << "Dual feasible.  Storing dual multipliers.\n");
-               _solRational._dual = solUnbounded._dual;
-               _solRational._redCost = solUnbounded._redCost;
-               _solRational._isDualFeasible = true;
-            }
-            else
-            {
-               assert(false);
-               MSG_INFO1(spxout, spxout << "Not dual infeasible.\n");
-            }
-         }
-
-         _restoreBasis();
-
-         if(infeasible)
-         {
-            MSG_INFO1(spxout, spxout << "Primal infeasible.  Dual Farkas ray available.\n");
-            _status = SPxSolverBase<R>::INFEASIBLE;
-            break;
-         }
-         else if(hasUnboundedRay)
-         {
-            MSG_INFO1(spxout, spxout << "Primal feasible and unbounded.\n");
-            _status = SPxSolverBase<R>::UNBOUNDED;
-            break;
-         }
-         else
-         {
-            MSG_INFO1(spxout, spxout << "Primal feasible.  Optimizing again.\n");
-            continue;
-         }
+      infeasibilityNotCertified = !infeasible;
+
+      if (stoppedTime) {
+        _status = SPxSolverBase<R>::ABORT_TIME;
+        _restoreBasis();
+        break;
+      } else if (stoppedIter) {
+        _status = SPxSolverBase<R>::ABORT_ITER;
+        _restoreBasis();
+        break;
       }
-      else if(primalFeasible && dualFeasible)
-      {
-         MSG_INFO1(spxout, spxout << "Solved to optimality.\n");
-         _status = SPxSolverBase<R>::OPTIMAL;
-         break;
+
+      if (infeasible && boolParam(SoPlexBase<R>::TESTDUALINF)) {
+        SolRational solUnbounded;
+
+        _performUnboundedIRStable(solUnbounded, hasUnboundedRay, stoppedTime,
+                                  stoppedIter, error);
+
+        assert(!hasUnboundedRay || solUnbounded.hasPrimalRay());
+        assert(!solUnbounded.hasPrimalRay() || hasUnboundedRay);
+
+        if (error) {
+          MSG_INFO1(spxout,
+                    spxout << "Error while testing for dual infeasibility.\n");
+          _status = SPxSolverBase<R>::ERROR;
+          _restoreBasis();
+          break;
+        }
+
+        if (hasUnboundedRay) {
+          MSG_INFO1(
+              spxout,
+              spxout << "Dual infeasible.  Primal unbounded ray available.\n");
+          _solRational._primalRay = solUnbounded._primalRay;
+          _solRational._hasPrimalRay = true;
+        } else if (solUnbounded._isDualFeasible) {
+          MSG_INFO1(spxout,
+                    spxout << "Dual feasible.  Storing dual multipliers.\n");
+          _solRational._dual = solUnbounded._dual;
+          _solRational._redCost = solUnbounded._redCost;
+          _solRational._isDualFeasible = true;
+        } else {
+          assert(false);
+          MSG_INFO1(spxout, spxout << "Not dual infeasible.\n");
+        }
       }
-      else
-      {
-         MSG_INFO1(spxout, spxout << "Terminating without success.\n");
-         break;
+
+      _restoreBasis();
+
+      if (infeasible) {
+        MSG_INFO1(spxout,
+                  spxout << "Primal infeasible.  Dual Farkas ray available.\n");
+        _status = SPxSolverBase<R>::INFEASIBLE;
+        break;
+      } else if (hasUnboundedRay) {
+        MSG_INFO1(spxout, spxout << "Primal feasible and unbounded.\n");
+        _status = SPxSolverBase<R>::UNBOUNDED;
+        break;
+      } else {
+        MSG_INFO1(spxout, spxout << "Primal feasible.  Optimizing again.\n");
+        continue;
       }
-   }
-   while(!_isSolveStopped(stoppedTime, stoppedIter));
+    } else if (primalFeasible && dualFeasible) {
+      MSG_INFO1(spxout, spxout << "Solved to optimality.\n");
+      _status = SPxSolverBase<R>::OPTIMAL;
+      break;
+    } else {
+      MSG_INFO1(spxout, spxout << "Terminating without success.\n");
+      break;
+    }
+  } while (!_isSolveStopped(stoppedTime, stoppedIter));
 
-   ///@todo set status to ABORT_VALUE if optimal solution exceeds objective limit
+  ///@todo set status to ABORT_VALUE if optimal solution exceeds objective limit
 
-   if(_status == SPxSolverBase<R>::OPTIMAL || _status == SPxSolverBase<R>::INFEASIBLE
-         || _status == SPxSolverBase<R>::UNBOUNDED)
-      _hasSolRational = true;
+  if (_status == SPxSolverBase<R>::OPTIMAL ||
+      _status == SPxSolverBase<R>::INFEASIBLE ||
+      _status == SPxSolverBase<R>::UNBOUNDED)
+    _hasSolRational = true;
 
-   // restore original problem
-   if(boolParam(SoPlexBase<R>::EQTRANS))
-      _untransformEquality(_solRational);
+  // restore original problem
+  if (boolParam(SoPlexBase<R>::EQTRANS))
+    _untransformEquality(_solRational);
 
 #ifdef SOPLEX_WITH_CPX
-   setBoolParam(SoPlexBase<R>::EQTRANS, oldEqtrans);
+  setBoolParam(SoPlexBase<R>::EQTRANS, oldEqtrans);
 #endif
 
-   // reset representation and ratio test
-   setIntParam(SoPlexBase<R>::REPRESENTATION, oldRepresentation);
-   setIntParam(SoPlexBase<R>::RATIOTESTER, oldRatiotester);
-
-   // undo lifting
-   if(boolParam(SoPlexBase<R>::LIFTING))
-      _project(_solRational);
-
-   // restore objective, bounds, and sides of Real LP in case they have been modified during iterative refinement
-   _restoreLPReal();
-
-   // since the Real LP is loaded in the solver, we need to also pass the basis information to the solver if
-   // available
-   if(_hasBasis)
-   {
-      assert(_isRealLPLoaded);
-      _solver.setBasis(_basisStatusRows.get_const_ptr(), _basisStatusCols.get_const_ptr());
-      _hasBasis = (_solver.basis().status() > SPxBasisBase<R>::NO_PROBLEM);
-
-      // since setBasis always sets the basis status to regular, we need to set it manually here
-      switch(_status)
-      {
-      case SPxSolverBase<R>::OPTIMAL:
-         _solver.setBasisStatus(SPxBasisBase<R>::OPTIMAL);
-         break;
-
-      case SPxSolverBase<R>::INFEASIBLE:
-         _solver.setBasisStatus(SPxBasisBase<R>::INFEASIBLE);
-         break;
+  // reset representation and ratio test
+  setIntParam(SoPlexBase<R>::REPRESENTATION, oldRepresentation);
+  setIntParam(SoPlexBase<R>::RATIOTESTER, oldRatiotester);
+
+  // undo lifting
+  if (boolParam(SoPlexBase<R>::LIFTING))
+    _project(_solRational);
+
+  // restore objective, bounds, and sides of Real LP in case they have been
+  // modified during iterative refinement
+  _restoreLPReal();
+
+  // since the Real LP is loaded in the solver, we need to also pass the basis
+  // information to the solver if available
+  if (_hasBasis) {
+    assert(_isRealLPLoaded);
+    _solver.setBasis(_basisStatusRows.get_const_ptr(),
+                     _basisStatusCols.get_const_ptr());
+    _hasBasis = (_solver.basis().status() > SPxBasisBase<R>::NO_PROBLEM);
+
+    // since setBasis always sets the basis status to regular, we need to set it
+    // manually here
+    switch (_status) {
+    case SPxSolverBase<R>::OPTIMAL:
+      _solver.setBasisStatus(SPxBasisBase<R>::OPTIMAL);
+      break;
 
-      case SPxSolverBase<R>::UNBOUNDED:
-         _solver.setBasisStatus(SPxBasisBase<R>::UNBOUNDED);
-         break;
+    case SPxSolverBase<R>::INFEASIBLE:
+      _solver.setBasisStatus(SPxBasisBase<R>::INFEASIBLE);
+      break;
 
-      default:
-         break;
-      }
+    case SPxSolverBase<R>::UNBOUNDED:
+      _solver.setBasisStatus(SPxBasisBase<R>::UNBOUNDED);
+      break;
 
-   }
+    default:
+      break;
+    }
+  }
 
-   // stop timing
-   _statistics->solvingTime->stop();
+  // stop timing
+  _statistics->solvingTime->stop();
 #endif
 }
 
-
-
 /// solves current problem with iterative refinement and recovery mechanism
 template <class R>
-void SoPlexBase<R>::_performOptIRStable(
-   SolRational& sol,
-   bool acceptUnbounded,
-   bool acceptInfeasible,
-   int minRounds,
-   bool& primalFeasible,
-   bool& dualFeasible,
-   bool& infeasible,
-   bool& unbounded,
-   bool& stoppedTime,
-   bool& stoppedIter,
-   bool& error)
-{
-   // start rational solving timing
-   _statistics->rationalTime->start();
-
-   primalFeasible = false;
-   dualFeasible = false;
-   infeasible = false;
-   unbounded = false;
-   stoppedTime = false;
-   stoppedIter = false;
-   error = false;
-
-   // set working tolerances in floating-point solver
-   _solver.setFeastol(realParam(SoPlexBase<R>::FPFEASTOL));
-   _solver.setOpttol(realParam(SoPlexBase<R>::FPOPTTOL));
-
-   // declare vectors and variables
-   typename SPxSolverBase<R>::Status result = SPxSolverBase<R>::UNKNOWN;
-
-   _modLower.reDim(numColsRational(), false);
-   _modUpper.reDim(numColsRational(), false);
-   _modLhs.reDim(numRowsRational(), false);
-   _modRhs.reDim(numRowsRational(), false);
-   _modObj.reDim(numColsRational(), false);
-
-   VectorBase<R> primalReal(numColsRational());
-   VectorBase<R> dualReal(numRowsRational());
-
-   Rational boundsViolation;
-   Rational sideViolation;
-   Rational redCostViolation;
-   Rational dualViolation;
-   Rational primalScale;
-   Rational dualScale;
-   Rational maxScale;
-
-   // solve original LP
-   MSG_INFO1(spxout, spxout << "Initial floating-point solve . . .\n");
-
-   if(_hasBasis)
-   {
-      assert(_basisStatusRows.size() == numRowsRational());
-      assert(_basisStatusCols.size() == numColsRational());
-      _solver.setBasis(_basisStatusRows.get_const_ptr(), _basisStatusCols.get_const_ptr());
-      _hasBasis = (_solver.basis().status() > SPxBasisBase<R>::NO_PROBLEM);
-   }
-
-   for(int r = numRowsRational() - 1; r >= 0; r--)
-   {
-      assert(_solver.maxRowObj(r) == 0.0);
-   }
-
-   _statistics->rationalTime->stop();
-   result = _solveRealStable(acceptUnbounded, acceptInfeasible, primalReal, dualReal, _basisStatusRows,
-                             _basisStatusCols);
-
-   // evaluate result
-   switch(result)
-   {
-   case SPxSolverBase<R>::OPTIMAL:
-      MSG_INFO1(spxout, spxout << "Floating-point optimal.\n");
-      break;
-
-   case SPxSolverBase<R>::INFEASIBLE:
-      MSG_INFO1(spxout, spxout << "Floating-point infeasible.\n");
+void SoPlexBase<R>::_performOptIRStable(SolRational &sol, bool acceptUnbounded,
+                                        bool acceptInfeasible, int minRounds,
+                                        bool &primalFeasible,
+                                        bool &dualFeasible, bool &infeasible,
+                                        bool &unbounded, bool &stoppedTime,
+                                        bool &stoppedIter, bool &error) {
+  // start rational solving timing
+  _statistics->rationalTime->start();
+
+  primalFeasible = false;
+  dualFeasible = false;
+  infeasible = false;
+  unbounded = false;
+  stoppedTime = false;
+  stoppedIter = false;
+  error = false;
+
+  // set working tolerances in floating-point solver
+  _solver.setFeastol(realParam(SoPlexBase<R>::FPFEASTOL));
+  _solver.setOpttol(realParam(SoPlexBase<R>::FPOPTTOL));
+
+  // declare vectors and variables
+  typename SPxSolverBase<R>::Status result = SPxSolverBase<R>::UNKNOWN;
+
+  _modLower.reDim(numColsRational(), false);
+  _modUpper.reDim(numColsRational(), false);
+  _modLhs.reDim(numRowsRational(), false);
+  _modRhs.reDim(numRowsRational(), false);
+  _modObj.reDim(numColsRational(), false);
+
+  VectorBase<R> primalReal(numColsRational());
+  VectorBase<R> dualReal(numRowsRational());
+
+  Rational boundsViolation;
+  Rational sideViolation;
+  Rational redCostViolation;
+  Rational dualViolation;
+  Rational primalScale;
+  Rational dualScale;
+  Rational maxScale;
+
+  // solve original LP
+  MSG_INFO1(spxout, spxout << "Initial floating-point solve . . .\n");
+
+  if (_hasBasis) {
+    assert(_basisStatusRows.size() == numRowsRational());
+    assert(_basisStatusCols.size() == numColsRational());
+    _solver.setBasis(_basisStatusRows.get_const_ptr(),
+                     _basisStatusCols.get_const_ptr());
+    _hasBasis = (_solver.basis().status() > SPxBasisBase<R>::NO_PROBLEM);
+  }
+
+  for (int r = numRowsRational() - 1; r >= 0; r--) {
+    assert(_solver.maxRowObj(r) == 0.0);
+  }
+
+  _statistics->rationalTime->stop();
+  result = _solveRealStable(acceptUnbounded, acceptInfeasible, primalReal,
+                            dualReal, _basisStatusRows, _basisStatusCols);
+
+  // evaluate result
+  switch (result) {
+  case SPxSolverBase<R>::OPTIMAL:
+    MSG_INFO1(spxout, spxout << "Floating-point optimal.\n");
+    break;
+
+  case SPxSolverBase<R>::INFEASIBLE:
+    MSG_INFO1(spxout, spxout << "Floating-point infeasible.\n");
+
+    // the floating-point solve returns a Farkas ray if and only if the
+    // simplifier was not used, which is exactly the case when a basis could be
+    // returned
+    if (_hasBasis) {
+      sol._dualFarkas = dualReal;
+      sol._hasDualFarkas = true;
+    } else
+      sol._hasDualFarkas = false;
 
-      // the floating-point solve returns a Farkas ray if and only if the simplifier was not used, which is exactly
-      // the case when a basis could be returned
-      if(_hasBasis)
-      {
-         sol._dualFarkas = dualReal;
-         sol._hasDualFarkas = true;
+    infeasible = true;
+    return;
+
+  case SPxSolverBase<R>::UNBOUNDED:
+    MSG_INFO1(spxout, spxout << "Floating-point unbounded.\n");
+    unbounded = true;
+    return;
+
+  case SPxSolverBase<R>::ABORT_TIME:
+    stoppedTime = true;
+    return;
+
+  case SPxSolverBase<R>::ABORT_ITER:
+    stoppedIter = true;
+    return;
+
+  default:
+    error = true;
+    return;
+  }
+
+  _statistics->rationalTime->start();
+
+  // store floating-point solution of original LP as current rational solution
+  // and ensure that solution vectors have right dimension; ensure that solution
+  // is aligned with basis
+  sol._primal.reDim(numColsRational(), false);
+  sol._slacks.reDim(numRowsRational(), false);
+  sol._dual.reDim(numRowsRational(), false);
+  sol._redCost.reDim(numColsRational(), false);
+  sol._isPrimalFeasible = true;
+  sol._isDualFeasible = true;
+
+  for (int c = numColsRational() - 1; c >= 0; c--) {
+    typename SPxSolverBase<R>::VarStatus &basisStatusCol = _basisStatusCols[c];
+
+    if (basisStatusCol == SPxSolverBase<R>::ON_LOWER)
+      sol._primal[c] = lowerRational(c);
+    else if (basisStatusCol == SPxSolverBase<R>::ON_UPPER)
+      sol._primal[c] = upperRational(c);
+    else if (basisStatusCol == SPxSolverBase<R>::FIXED) {
+      // it may happen that lower and upper are only equal in the Real LP but
+      // different in the rational LP; we do not check this to avoid rational
+      // comparisons, but simply switch the basis status to the lower bound;
+      // this is necessary, because for fixed variables any reduced cost is
+      // feasible
+      sol._primal[c] = lowerRational(c);
+      basisStatusCol = SPxSolverBase<R>::ON_LOWER;
+    } else if (basisStatusCol == SPxSolverBase<R>::ZERO)
+      sol._primal[c] = 0;
+    else
+      sol._primal[c].assign(primalReal[c]);
+  }
+
+  _rationalLP->computePrimalActivity(sol._primal, sol._slacks);
+
+  int dualSize = 0;
+
+  for (int r = numRowsRational() - 1; r >= 0; r--) {
+    typename SPxSolverBase<R>::VarStatus &basisStatusRow = _basisStatusRows[r];
+
+    // it may happen that left-hand and right-hand side are different in the
+    // rational, but equal in the Real LP, leading to a fixed basis status; this
+    // is critical because rows with fixed basis status are ignored in the
+    // computation of the dual violation; to avoid rational comparisons we do
+    // not check this but simply switch to the left-hand side status
+    if (basisStatusRow == SPxSolverBase<R>::FIXED)
+      basisStatusRow = SPxSolverBase<R>::ON_LOWER;
+
+    {
+      sol._dual[r].assign(dualReal[r]);
+
+      if (dualReal[r] != 0.0)
+        dualSize++;
+    }
+  }
+
+  // we assume that the objective function vector has less nonzeros than the
+  // reduced cost vector, and so multiplying with -1 first and subtracting the
+  // dual activity should be faster than adding the dual activity and negating
+  // afterwards
+  _rationalLP->getObj(sol._redCost);
+  _rationalLP->subDualActivity(sol._dual, sol._redCost);
+
+  // initial scaling factors are one
+  primalScale = _rationalPosone;
+  dualScale = _rationalPosone;
+
+  // control progress
+  Rational maxViolation;
+  Rational bestViolation = _rationalPosInfty;
+  const Rational violationImprovementFactor = 16;
+  const Rational errorCorrectionFactor = 1.1;
+  Rational errorCorrection = 2;
+  int numFailedRefinements = 0;
+
+  // store basis status in case solving modified problem failed
+  DataArray<typename SPxSolverBase<R>::VarStatus> basisStatusRowsFirst;
+  DataArray<typename SPxSolverBase<R>::VarStatus> basisStatusColsFirst;
+
+  // refinement loop
+  const bool maximizing =
+      (intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MAXIMIZE);
+  const int maxDimRational = numColsRational() > numRowsRational()
+                                 ? numColsRational()
+                                 : numRowsRational();
+  SolRational factorSol;
+  bool factorSolNewBasis = true;
+  int lastStallRefinements = 0;
+  int nextRatrecRefinement = 0;
+
+  do {
+    // decrement minRounds counter
+    minRounds--;
+
+    MSG_DEBUG(std::cout << "Computing primal violations.\n");
+
+    // compute violation of bounds
+    boundsViolation = 0;
+
+    for (int c = numColsRational() - 1; c >= 0; c--) {
+      // lower bound
+      assert((lowerRational(c) > _rationalNegInfty) ==
+             _lowerFinite(_colTypes[c]));
+
+      if (_lowerFinite(_colTypes[c])) {
+        if (lowerRational(c) == 0) {
+          _modLower[c] = sol._primal[c];
+          _modLower[c] *= -1;
+
+          if (_modLower[c] > boundsViolation)
+            boundsViolation = _modLower[c];
+        } else {
+          _modLower[c] = lowerRational(c);
+          _modLower[c] -= sol._primal[c];
+
+          if (_modLower[c] > boundsViolation)
+            boundsViolation = _modLower[c];
+        }
       }
-      else
-         sol._hasDualFarkas = false;
 
-      infeasible = true;
-      return;
+      // upper bound
+      assert((upperRational(c) < _rationalPosInfty) ==
+             _upperFinite(_colTypes[c]));
 
-   case SPxSolverBase<R>::UNBOUNDED:
-      MSG_INFO1(spxout, spxout << "Floating-point unbounded.\n");
-      unbounded = true;
-      return;
+      if (_upperFinite(_colTypes[c])) {
+        if (upperRational(c) == 0) {
+          _modUpper[c] = sol._primal[c];
+          _modUpper[c] *= -1;
 
-   case SPxSolverBase<R>::ABORT_TIME:
-      stoppedTime = true;
-      return;
-
-   case SPxSolverBase<R>::ABORT_ITER:
-      stoppedIter = true;
-      return;
+          if (_modUpper[c] < -boundsViolation)
+            boundsViolation = -_modUpper[c];
+        } else {
+          _modUpper[c] = upperRational(c);
+          _modUpper[c] -= sol._primal[c];
 
-   default:
-      error = true;
-      return;
-   }
-
-   _statistics->rationalTime->start();
-
-   // store floating-point solution of original LP as current rational solution and ensure that solution vectors have
-   // right dimension; ensure that solution is aligned with basis
-   sol._primal.reDim(numColsRational(), false);
-   sol._slacks.reDim(numRowsRational(), false);
-   sol._dual.reDim(numRowsRational(), false);
-   sol._redCost.reDim(numColsRational(), false);
-   sol._isPrimalFeasible = true;
-   sol._isDualFeasible = true;
-
-   for(int c = numColsRational() - 1; c >= 0; c--)
-   {
-      typename SPxSolverBase<R>::VarStatus& basisStatusCol = _basisStatusCols[c];
-
-      if(basisStatusCol == SPxSolverBase<R>::ON_LOWER)
-         sol._primal[c] = lowerRational(c);
-      else if(basisStatusCol == SPxSolverBase<R>::ON_UPPER)
-         sol._primal[c] = upperRational(c);
-      else if(basisStatusCol == SPxSolverBase<R>::FIXED)
-      {
-         // it may happen that lower and upper are only equal in the Real LP but different in the rational LP; we do
-         // not check this to avoid rational comparisons, but simply switch the basis status to the lower bound; this
-         // is necessary, because for fixed variables any reduced cost is feasible
-         sol._primal[c] = lowerRational(c);
-         basisStatusCol = SPxSolverBase<R>::ON_LOWER;
+          if (_modUpper[c] < -boundsViolation)
+            boundsViolation = -_modUpper[c];
+        }
       }
-      else if(basisStatusCol == SPxSolverBase<R>::ZERO)
-         sol._primal[c] = 0;
-      else
-         sol._primal[c].assign(primalReal[c]);
-   }
-
-   _rationalLP->computePrimalActivity(sol._primal, sol._slacks);
-
-   int dualSize = 0;
-
-   for(int r = numRowsRational() - 1; r >= 0; r--)
-   {
-      typename SPxSolverBase<R>::VarStatus& basisStatusRow = _basisStatusRows[r];
-
-      // it may happen that left-hand and right-hand side are different in the rational, but equal in the Real LP,
-      // leading to a fixed basis status; this is critical because rows with fixed basis status are ignored in the
-      // computation of the dual violation; to avoid rational comparisons we do not check this but simply switch to
-      // the left-hand side status
-      if(basisStatusRow == SPxSolverBase<R>::FIXED)
-         basisStatusRow = SPxSolverBase<R>::ON_LOWER;
-
-      {
-         sol._dual[r].assign(dualReal[r]);
-
-         if(dualReal[r] != 0.0)
-            dualSize++;
+    }
+
+    // compute violation of sides
+    sideViolation = 0;
+
+    for (int r = numRowsRational() - 1; r >= 0; r--) {
+      const typename SPxSolverBase<R>::VarStatus &basisStatusRow =
+          _basisStatusRows[r];
+
+      // left-hand side
+      assert((lhsRational(r) > _rationalNegInfty) ==
+             _lowerFinite(_rowTypes[r]));
+
+      if (_lowerFinite(_rowTypes[r])) {
+        if (lhsRational(r) == 0) {
+          _modLhs[r] = sol._slacks[r];
+          _modLhs[r] *= -1;
+        } else {
+          _modLhs[r] = lhsRational(r);
+          _modLhs[r] -= sol._slacks[r];
+        }
+
+        if (_modLhs[r] > sideViolation)
+          sideViolation = _modLhs[r];
+        // if the activity is feasible, but too far from the bound, this
+        // violates complementary slackness; we count it as side violation here
+        else if (basisStatusRow == SPxSolverBase<R>::ON_LOWER &&
+                 _modLhs[r] < -sideViolation)
+          sideViolation = -_modLhs[r];
       }
-   }
-
-   // we assume that the objective function vector has less nonzeros than the reduced cost vector, and so multiplying
-   // with -1 first and subtracting the dual activity should be faster than adding the dual activity and negating
-   // afterwards
-   _rationalLP->getObj(sol._redCost);
-   _rationalLP->subDualActivity(sol._dual, sol._redCost);
-
-   // initial scaling factors are one
-   primalScale = _rationalPosone;
-   dualScale = _rationalPosone;
-
-   // control progress
-   Rational maxViolation;
-   Rational bestViolation = _rationalPosInfty;
-   const Rational violationImprovementFactor = 16;
-   const Rational errorCorrectionFactor = 1.1;
-   Rational errorCorrection = 2;
-   int numFailedRefinements = 0;
-
-   // store basis status in case solving modified problem failed
-   DataArray< typename SPxSolverBase<R>::VarStatus > basisStatusRowsFirst;
-   DataArray< typename SPxSolverBase<R>::VarStatus > basisStatusColsFirst;
-
-   // refinement loop
-   const bool maximizing = (intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MAXIMIZE);
-   const int maxDimRational = numColsRational() > numRowsRational() ? numColsRational() :
-                              numRowsRational();
-   SolRational factorSol;
-   bool factorSolNewBasis = true;
-   int lastStallRefinements = 0;
-   int nextRatrecRefinement = 0;
-
-   do
-   {
-      // decrement minRounds counter
-      minRounds--;
-
-      MSG_DEBUG(std::cout << "Computing primal violations.\n");
-
-      // compute violation of bounds
-      boundsViolation = 0;
-
-      for(int c = numColsRational() - 1; c >= 0; c--)
-      {
-         // lower bound
-         assert((lowerRational(c) > _rationalNegInfty) == _lowerFinite(_colTypes[c]));
-
-         if(_lowerFinite(_colTypes[c]))
-         {
-            if(lowerRational(c) == 0)
-            {
-               _modLower[c] = sol._primal[c];
-               _modLower[c] *= -1;
-
-               if(_modLower[c] > boundsViolation)
-                  boundsViolation = _modLower[c];
-            }
-            else
-            {
-               _modLower[c] = lowerRational(c);
-               _modLower[c] -= sol._primal[c];
-
-               if(_modLower[c] > boundsViolation)
-                  boundsViolation = _modLower[c];
-            }
-         }
 
-         // upper bound
-         assert((upperRational(c) < _rationalPosInfty) == _upperFinite(_colTypes[c]));
-
-         if(_upperFinite(_colTypes[c]))
-         {
-            if(upperRational(c) == 0)
-            {
-               _modUpper[c] = sol._primal[c];
-               _modUpper[c] *= -1;
-
-               if(_modUpper[c] < -boundsViolation)
-                  boundsViolation = -_modUpper[c];
-            }
-            else
-            {
-               _modUpper[c] = upperRational(c);
-               _modUpper[c] -= sol._primal[c];
-
-               if(_modUpper[c] < -boundsViolation)
-                  boundsViolation = -_modUpper[c];
-            }
-         }
+      // right-hand side
+      assert((rhsRational(r) < _rationalPosInfty) ==
+             _upperFinite(_rowTypes[r]));
+
+      if (_upperFinite(_rowTypes[r])) {
+        if (rhsRational(r) == 0) {
+          _modRhs[r] = sol._slacks[r];
+          _modRhs[r] *= -1;
+        } else {
+          _modRhs[r] = rhsRational(r);
+          _modRhs[r] -= sol._slacks[r];
+        }
+
+        if (_modRhs[r] < -sideViolation)
+          sideViolation = -_modRhs[r];
+        // if the activity is feasible, but too far from the bound, this
+        // violates complementary slackness; we count it as side violation here
+        else if (basisStatusRow == SPxSolverBase<R>::ON_UPPER &&
+                 _modRhs[r] > sideViolation)
+          sideViolation = _modRhs[r];
       }
-
-      // compute violation of sides
-      sideViolation = 0;
-
-      for(int r = numRowsRational() - 1; r >= 0; r--)
-      {
-         const typename SPxSolverBase<R>::VarStatus& basisStatusRow = _basisStatusRows[r];
-
-         // left-hand side
-         assert((lhsRational(r) > _rationalNegInfty) == _lowerFinite(_rowTypes[r]));
-
-         if(_lowerFinite(_rowTypes[r]))
-         {
-            if(lhsRational(r) == 0)
-            {
-               _modLhs[r] = sol._slacks[r];
-               _modLhs[r] *= -1;
-            }
-            else
-            {
-               _modLhs[r] = lhsRational(r);
-               _modLhs[r] -= sol._slacks[r];
-            }
-
-            if(_modLhs[r] > sideViolation)
-               sideViolation = _modLhs[r];
-            // if the activity is feasible, but too far from the bound, this violates complementary slackness; we
-            // count it as side violation here
-            else if(basisStatusRow == SPxSolverBase<R>::ON_LOWER && _modLhs[r] < -sideViolation)
-               sideViolation = -_modLhs[r];
-         }
-
-         // right-hand side
-         assert((rhsRational(r) < _rationalPosInfty) == _upperFinite(_rowTypes[r]));
-
-         if(_upperFinite(_rowTypes[r]))
-         {
-            if(rhsRational(r) == 0)
-            {
-               _modRhs[r] = sol._slacks[r];
-               _modRhs[r] *= -1;
-            }
-            else
-            {
-               _modRhs[r] = rhsRational(r);
-               _modRhs[r] -= sol._slacks[r];
-            }
-
-            if(_modRhs[r] < -sideViolation)
-               sideViolation = -_modRhs[r];
-            // if the activity is feasible, but too far from the bound, this violates complementary slackness; we
-            // count it as side violation here
-            else if(basisStatusRow == SPxSolverBase<R>::ON_UPPER && _modRhs[r] > sideViolation)
-               sideViolation = _modRhs[r];
-         }
+    }
+
+    MSG_DEBUG(std::cout << "Computing dual violations.\n");
+
+    // compute reduced cost violation
+    redCostViolation = 0;
+
+    for (int c = numColsRational() - 1; c >= 0; c--) {
+      if (_colTypes[c] == RANGETYPE_FIXED)
+        continue;
+
+      const typename SPxSolverBase<R>::VarStatus &basisStatusCol =
+          _basisStatusCols[c];
+      assert(basisStatusCol != SPxSolverBase<R>::FIXED);
+
+      if (((maximizing && basisStatusCol != SPxSolverBase<R>::ON_LOWER) ||
+           (!maximizing && basisStatusCol != SPxSolverBase<R>::ON_UPPER)) &&
+          sol._redCost[c] < -redCostViolation) {
+        MSG_DEBUG(std::cout
+                  << "basisStatusCol = " << basisStatusCol << ", lower tight = "
+                  << bool(sol._primal[c] <= lowerRational(c))
+                  << ", upper tight = "
+                  << bool(sol._primal[c] >= upperRational(c))
+                  << ", sol._redCost[c] = " << sol._redCost[c].str() << "\n");
+        redCostViolation = -sol._redCost[c];
       }
 
-      MSG_DEBUG(std::cout << "Computing dual violations.\n");
-
-      // compute reduced cost violation
-      redCostViolation = 0;
-
-      for(int c = numColsRational() - 1; c >= 0; c--)
-      {
-         if(_colTypes[c] == RANGETYPE_FIXED)
-            continue;
-
-         const typename SPxSolverBase<R>::VarStatus& basisStatusCol = _basisStatusCols[c];
-         assert(basisStatusCol != SPxSolverBase<R>::FIXED);
-
-         if(((maximizing && basisStatusCol != SPxSolverBase<R>::ON_LOWER) || (!maximizing
-               && basisStatusCol != SPxSolverBase<R>::ON_UPPER))
-               && sol._redCost[c] < -redCostViolation)
-         {
-            MSG_DEBUG(std::cout << "basisStatusCol = " << basisStatusCol
-                      << ", lower tight = " << bool(sol._primal[c] <= lowerRational(c))
-                      << ", upper tight = " << bool(sol._primal[c] >= upperRational(c))
-                      << ", sol._redCost[c] = " << sol._redCost[c].str()
-                      << "\n");
-            redCostViolation = -sol._redCost[c];
-         }
-
-         if(((maximizing && basisStatusCol != SPxSolverBase<R>::ON_UPPER) || (!maximizing
-               && basisStatusCol != SPxSolverBase<R>::ON_LOWER))
-               && sol._redCost[c] > redCostViolation)
-         {
-            MSG_DEBUG(std::cout << "basisStatusCol = " << basisStatusCol
-                      << ", lower tight = " << bool(sol._primal[c] <= lowerRational(c))
-                      << ", upper tight = " << bool(sol._primal[c] >= upperRational(c))
-                      << ", sol._redCost[c] = " << sol._redCost[c].str()
-                      << "\n");
-            redCostViolation = sol._redCost[c];
-         }
+      if (((maximizing && basisStatusCol != SPxSolverBase<R>::ON_UPPER) ||
+           (!maximizing && basisStatusCol != SPxSolverBase<R>::ON_LOWER)) &&
+          sol._redCost[c] > redCostViolation) {
+        MSG_DEBUG(std::cout
+                  << "basisStatusCol = " << basisStatusCol << ", lower tight = "
+                  << bool(sol._primal[c] <= lowerRational(c))
+                  << ", upper tight = "
+                  << bool(sol._primal[c] >= upperRational(c))
+                  << ", sol._redCost[c] = " << sol._redCost[c].str() << "\n");
+        redCostViolation = sol._redCost[c];
       }
-
-      // compute dual violation
-      dualViolation = 0;
-
-      for(int r = numRowsRational() - 1; r >= 0; r--)
-      {
-         if(_rowTypes[r] == RANGETYPE_FIXED)
-            continue;
-
-         const typename SPxSolverBase<R>::VarStatus& basisStatusRow = _basisStatusRows[r];
-         assert(basisStatusRow != SPxSolverBase<R>::FIXED);
-
-         if(((maximizing && basisStatusRow != SPxSolverBase<R>::ON_LOWER) || (!maximizing
-               && basisStatusRow != SPxSolverBase<R>::ON_UPPER))
-               && sol._dual[r] < -dualViolation)
-         {
-            MSG_DEBUG(std::cout << "basisStatusRow = " << basisStatusRow
-                      << ", lower tight = " << bool(sol._slacks[r] <= lhsRational(r))
-                      << ", upper tight = " << bool(sol._slacks[r] >= rhsRational(r))
-                      << ", sol._dual[r] = " << sol._dual[r].str()
-                      << "\n");
-            dualViolation = -sol._dual[r];
-         }
-
-         if(((maximizing && basisStatusRow != SPxSolverBase<R>::ON_UPPER) || (!maximizing
-               && basisStatusRow != SPxSolverBase<R>::ON_LOWER))
-               && sol._dual[r] > dualViolation)
-         {
-            MSG_DEBUG(std::cout << "basisStatusRow = " << basisStatusRow
-                      << ", lower tight = " << bool(sol._slacks[r] <= lhsRational(r))
-                      << ", upper tight = " << bool(sol._slacks[r] >= rhsRational(r))
-                      << ", sol._dual[r] = " << sol._dual[r].str()
-                      << "\n");
-            dualViolation = sol._dual[r];
-         }
+    }
+
+    // compute dual violation
+    dualViolation = 0;
+
+    for (int r = numRowsRational() - 1; r >= 0; r--) {
+      if (_rowTypes[r] == RANGETYPE_FIXED)
+        continue;
+
+      const typename SPxSolverBase<R>::VarStatus &basisStatusRow =
+          _basisStatusRows[r];
+      assert(basisStatusRow != SPxSolverBase<R>::FIXED);
+
+      if (((maximizing && basisStatusRow != SPxSolverBase<R>::ON_LOWER) ||
+           (!maximizing && basisStatusRow != SPxSolverBase<R>::ON_UPPER)) &&
+          sol._dual[r] < -dualViolation) {
+        MSG_DEBUG(std::cout
+                  << "basisStatusRow = " << basisStatusRow << ", lower tight = "
+                  << bool(sol._slacks[r] <= lhsRational(r))
+                  << ", upper tight = "
+                  << bool(sol._slacks[r] >= rhsRational(r))
+                  << ", sol._dual[r] = " << sol._dual[r].str() << "\n");
+        dualViolation = -sol._dual[r];
       }
 
-      _modObj = sol._redCost;
-
-      // output violations; the reduced cost violations for artificially introduced slack columns are actually violations of the dual multipliers
-      MSG_INFO1(spxout, spxout
-                << "Max. bound violation = " << boundsViolation.str() << "\n"
-                << "Max. row violation = " << sideViolation.str() << "\n"
-                << "Max. reduced cost violation = " << redCostViolation.str() << "\n"
-                << "Max. dual violation = " << dualViolation.str() << "\n");
-
-      MSG_DEBUG(spxout
-                << std::fixed << std::setprecision(2) << std::setw(10)
-                << "Progress table: "
-                << std::setw(10) << _statistics->refinements << " & "
-                << std::setw(10) << _statistics->iterations << " & "
-                << std::setw(10) << _statistics->solvingTime->time() << " & "
-                << std::setw(10) << _statistics->rationalTime->time() << " & "
-                << std::setw(10) << boundsViolation > sideViolation ? boundsViolation :
-                sideViolation << " & "
-                << std::setw(10) << redCostViolation > dualViolation ? redCostViolation :
-                dualViolation << "\n");
-
-      // terminate if tolerances are satisfied
-      primalFeasible = (boundsViolation <= _rationalFeastol && sideViolation <= _rationalFeastol);
-      dualFeasible = (redCostViolation <= _rationalOpttol && dualViolation <= _rationalOpttol);
-
-      if(primalFeasible && dualFeasible)
-      {
-         if(minRounds < 0)
-         {
-            MSG_INFO1(spxout, spxout << "Tolerances reached.\n");
-            break;
-         }
-         else
-         {
-            MSG_INFO1(spxout, spxout <<
-                      "Tolerances reached but minRounds forcing additional refinement rounds.\n");
-         }
+      if (((maximizing && basisStatusRow != SPxSolverBase<R>::ON_UPPER) ||
+           (!maximizing && basisStatusRow != SPxSolverBase<R>::ON_LOWER)) &&
+          sol._dual[r] > dualViolation) {
+        MSG_DEBUG(std::cout
+                  << "basisStatusRow = " << basisStatusRow << ", lower tight = "
+                  << bool(sol._slacks[r] <= lhsRational(r))
+                  << ", upper tight = "
+                  << bool(sol._slacks[r] >= rhsRational(r))
+                  << ", sol._dual[r] = " << sol._dual[r].str() << "\n");
+        dualViolation = sol._dual[r];
       }
-
-      // terminate if some limit is reached
-      if(_isSolveStopped(stoppedTime, stoppedIter) || numFailedRefinements > 2)
-         break;
-
-      // check progress
-      maxViolation = boundsViolation;
-
-      if(sideViolation > maxViolation)
-         maxViolation = sideViolation;
-
-      if(redCostViolation > maxViolation)
-         maxViolation = redCostViolation;
-
-      if(dualViolation > maxViolation)
-         maxViolation = dualViolation;
-
-      bestViolation /= violationImprovementFactor;
-
-      if(maxViolation > bestViolation)
-      {
-         MSG_INFO2(spxout, spxout << "Failed to reduce violation significantly.\n");
-         bestViolation *= violationImprovementFactor;
-         numFailedRefinements++;
+    }
+
+    _modObj = sol._redCost;
+
+    // output violations; the reduced cost violations for artificially
+    // introduced slack columns are actually violations of the dual multipliers
+    MSG_INFO1(
+        spxout,
+        spxout << "Max. bound violation = " << boundsViolation.str() << "\n"
+               << "Max. row violation = " << sideViolation.str() << "\n"
+               << "Max. reduced cost violation = " << redCostViolation.str()
+               << "\n"
+               << "Max. dual violation = " << dualViolation.str() << "\n");
+
+    MSG_DEBUG(spxout << std::fixed << std::setprecision(2) << std::setw(10)
+                     << "Progress table: " << std::setw(10)
+                     << _statistics->refinements << " & " << std::setw(10)
+                     << _statistics->iterations << " & " << std::setw(10)
+                     << _statistics->solvingTime->time() << " & "
+                     << std::setw(10) << _statistics->rationalTime->time()
+                     << " & " << std::setw(10) << boundsViolation >
+                      sideViolation
+                  ? boundsViolation
+              : sideViolation << " & " << std::setw(10) << redCostViolation >
+                      dualViolation
+                  ? redCostViolation
+                  : dualViolation << "\n");
+
+    // terminate if tolerances are satisfied
+    primalFeasible = (boundsViolation <= _rationalFeastol &&
+                      sideViolation <= _rationalFeastol);
+    dualFeasible = (redCostViolation <= _rationalOpttol &&
+                    dualViolation <= _rationalOpttol);
+
+    if (primalFeasible && dualFeasible) {
+      if (minRounds < 0) {
+        MSG_INFO1(spxout, spxout << "Tolerances reached.\n");
+        break;
+      } else {
+        MSG_INFO1(spxout, spxout << "Tolerances reached but minRounds forcing "
+                                    "additional refinement rounds.\n");
       }
-      else
-         bestViolation = maxViolation;
+    }
 
-      // decide whether to perform rational reconstruction and/or factorization
-      bool forcebasic    = boolParam(SoPlexBase<R>::FORCEBASIC);
-      bool performRatfac = boolParam(SoPlexBase<R>::RATFAC)
-                           && lastStallRefinements >= intParam(SoPlexBase<R>::RATFAC_MINSTALLS) && _hasBasis
-                           && factorSolNewBasis;
-      bool performRatrec = boolParam(SoPlexBase<R>::RATREC)
-                           && (_statistics->refinements >= nextRatrecRefinement || performRatfac);
-
-      // if we want to force the solution to be basic we need to turn rational factorization on
-      performRatfac = performRatfac || forcebasic;
-
-      // attempt rational reconstruction
-      errorCorrection *= errorCorrectionFactor;
-
-      if(performRatrec && maxViolation > 0)
-      {
-         MSG_INFO1(spxout, spxout << "Performing rational reconstruction . . .\n");
-
-         maxViolation *= errorCorrection; // only used for sign check later
-         invert(maxViolation);
-
-         if(_reconstructSolutionRational(sol, _basisStatusRows, _basisStatusCols, maxViolation))
-         {
-            MSG_INFO1(spxout, spxout << "Tolerances reached.\n");
-            primalFeasible = true;
-            dualFeasible = true;
-
-            if(_hasBasis || !forcebasic)
-               break;
-         }
-
-         nextRatrecRefinement = int(_statistics->refinements * realParam(SoPlexBase<R>::RATREC_FREQ)) + 1;
-         MSG_DEBUG(spxout << "Next rational reconstruction after refinement " << nextRatrecRefinement <<
-                   ".\n");
-      }
+    // terminate if some limit is reached
+    if (_isSolveStopped(stoppedTime, stoppedIter) || numFailedRefinements > 2)
+      break;
 
-      // solve basis systems exactly
-      if((performRatfac && maxViolation > 0) || (!_hasBasis && forcebasic))
-      {
-         MSG_INFO1(spxout, spxout << "Performing rational factorization . . .\n");
-
-         bool optimal;
-         _factorizeColumnRational(sol, _basisStatusRows, _basisStatusCols, stoppedTime, stoppedIter, error,
-                                  optimal);
-         factorSolNewBasis = false;
-
-         if(stoppedTime)
-         {
-            MSG_INFO1(spxout, spxout << "Stopped rational factorization.\n");
-         }
-         else if(error)
-         {
-            // message was already printed; reset error flag and continue without factorization
-            error = false;
-         }
-         else if(optimal)
-         {
-            MSG_INFO1(spxout, spxout << "Tolerances reached.\n");
-            primalFeasible = true;
-            dualFeasible = true;
-            break;
-         }
-         else if(boolParam(SoPlexBase<R>::RATFACJUMP))
-         {
-            MSG_INFO1(spxout, spxout << "Jumping to exact basic solution.\n");
-            minRounds++;
-            continue;
-         }
-      }
+    // check progress
+    maxViolation = boundsViolation;
 
-      // start refinement
+    if (sideViolation > maxViolation)
+      maxViolation = sideViolation;
 
-      // compute primal scaling factor; limit increase in scaling by tolerance used in floating point solve
-      maxScale = primalScale;
-      maxScale *= _rationalMaxscaleincr;
+    if (redCostViolation > maxViolation)
+      maxViolation = redCostViolation;
 
-      primalScale = boundsViolation > sideViolation ? boundsViolation : sideViolation;
+    if (dualViolation > maxViolation)
+      maxViolation = dualViolation;
 
-      if(primalScale < redCostViolation)
-         primalScale = redCostViolation;
+    bestViolation /= violationImprovementFactor;
 
-      assert(primalScale >= 0);
+    if (maxViolation > bestViolation) {
+      MSG_INFO2(spxout,
+                spxout << "Failed to reduce violation significantly.\n");
+      bestViolation *= violationImprovementFactor;
+      numFailedRefinements++;
+    } else
+      bestViolation = maxViolation;
 
-      if(primalScale > 0)
-      {
-         invert(primalScale);
+    // decide whether to perform rational reconstruction and/or factorization
+    bool forcebasic = boolParam(SoPlexBase<R>::FORCEBASIC);
+    bool performRatfac =
+        boolParam(SoPlexBase<R>::RATFAC) &&
+        lastStallRefinements >= intParam(SoPlexBase<R>::RATFAC_MINSTALLS) &&
+        _hasBasis && factorSolNewBasis;
+    bool performRatrec =
+        boolParam(SoPlexBase<R>::RATREC) &&
+        (_statistics->refinements >= nextRatrecRefinement || performRatfac);
 
-         if(primalScale > maxScale)
-            primalScale = maxScale;
-      }
-      else
-         primalScale = maxScale;
+    // if we want to force the solution to be basic we need to turn rational
+    // factorization on
+    performRatfac = performRatfac || forcebasic;
 
-      if(boolParam(SoPlexBase<R>::POWERSCALING))
-         powRound(primalScale);
+    // attempt rational reconstruction
+    errorCorrection *= errorCorrectionFactor;
 
-      // apply scaled bounds
-      if(primalScale <= 1)
-      {
-         if(primalScale < 1)
-            primalScale = 1;
-
-         for(int c = numColsRational() - 1; c >= 0; c--)
-         {
-            if(_lowerFinite(_colTypes[c]))
-            {
-               if(_modLower[c] <= _rationalNegInfty)
-                  _solver.changeLower(c, -realParam(SoPlexBase<R>::INFTY));
-               else
-                  _solver.changeLower(c, static_cast<R>(_modLower[c]));
-            }
+    if (performRatrec && maxViolation > 0) {
+      MSG_INFO1(spxout, spxout << "Performing rational reconstruction . . .\n");
 
-            if(_upperFinite(_colTypes[c]))
-            {
-               if(_modUpper[c] >= _rationalPosInfty)
-                  _solver.changeUpper(c, realParam(SoPlexBase<R>::INFTY));
-               else
-                  _solver.changeUpper(c, R(_modUpper[c]));
-            }
-         }
-      }
-      else
-      {
-         MSG_INFO2(spxout, spxout << "Scaling primal by " << primalScale.str() << ".\n");
-
-         for(int c = numColsRational() - 1; c >= 0; c--)
-         {
-            if(_lowerFinite(_colTypes[c]))
-            {
-               _modLower[c] *= primalScale;
-
-               if(_modLower[c] <= _rationalNegInfty)
-                  _solver.changeLower(c, -realParam(SoPlexBase<R>::INFTY));
-               else
-                  _solver.changeLower(c, R(_modLower[c]));
-            }
+      maxViolation *= errorCorrection; // only used for sign check later
+      invert(maxViolation);
 
-            if(_upperFinite(_colTypes[c]))
-            {
-               _modUpper[c] *= primalScale;
+      if (_reconstructSolutionRational(sol, _basisStatusRows, _basisStatusCols,
+                                       maxViolation)) {
+        MSG_INFO1(spxout, spxout << "Tolerances reached.\n");
+        primalFeasible = true;
+        dualFeasible = true;
 
-               if(_modUpper[c] >= _rationalPosInfty)
-                  _solver.changeUpper(c, realParam(SoPlexBase<R>::INFTY));
-               else
-                  _solver.changeUpper(c, R(_modUpper[c]));
-            }
-         }
+        if (_hasBasis || !forcebasic)
+          break;
       }
 
-      // apply scaled sides
-      assert(primalScale >= 1);
-
-      if(primalScale == 1)
-      {
-         for(int r = numRowsRational() - 1; r >= 0; r--)
-         {
-            if(_lowerFinite(_rowTypes[r]))
-            {
-               if(_modLhs[r] <= _rationalNegInfty)
-                  _solver.changeLhs(r, -realParam(SoPlexBase<R>::INFTY));
-               else
-                  _solver.changeLhs(r, R(_modLhs[r]));
-            }
-
-            if(_upperFinite(_rowTypes[r]))
-            {
-               if(_modRhs[r] >= _rationalPosInfty)
-                  _solver.changeRhs(r, realParam(SoPlexBase<R>::INFTY));
-               else
-                  _solver.changeRhs(r, R(_modRhs[r]));
-            }
-         }
+      nextRatrecRefinement = int(_statistics->refinements *
+                                 realParam(SoPlexBase<R>::RATREC_FREQ)) +
+                             1;
+      MSG_DEBUG(spxout << "Next rational reconstruction after refinement "
+                       << nextRatrecRefinement << ".\n");
+    }
+
+    // solve basis systems exactly
+    if ((performRatfac && maxViolation > 0) || (!_hasBasis && forcebasic)) {
+      MSG_INFO1(spxout, spxout << "Performing rational factorization . . .\n");
+
+      bool optimal;
+      _factorizeColumnRational(sol, _basisStatusRows, _basisStatusCols,
+                               stoppedTime, stoppedIter, error, optimal);
+      factorSolNewBasis = false;
+
+      if (stoppedTime) {
+        MSG_INFO1(spxout, spxout << "Stopped rational factorization.\n");
+      } else if (error) {
+        // message was already printed; reset error flag and continue without
+        // factorization
+        error = false;
+      } else if (optimal) {
+        MSG_INFO1(spxout, spxout << "Tolerances reached.\n");
+        primalFeasible = true;
+        dualFeasible = true;
+        break;
+      } else if (boolParam(SoPlexBase<R>::RATFACJUMP)) {
+        MSG_INFO1(spxout, spxout << "Jumping to exact basic solution.\n");
+        minRounds++;
+        continue;
       }
-      else
-      {
-         for(int r = numRowsRational() - 1; r >= 0; r--)
-         {
-            if(_lowerFinite(_rowTypes[r]))
-            {
-               _modLhs[r] *= primalScale;
-
-               if(_modLhs[r] <= _rationalNegInfty)
-                  _solver.changeLhs(r, -realParam(SoPlexBase<R>::INFTY));
-               else
-                  _solver.changeLhs(r, R(_modLhs[r]));
-            }
+    }
 
-            if(_upperFinite(_rowTypes[r]))
-            {
-               _modRhs[r] *= primalScale;
+    // start refinement
 
-               if(_modRhs[r] >= _rationalPosInfty)
-                  _solver.changeRhs(r, realParam(SoPlexBase<R>::INFTY));
-               else
-                  _solver.changeRhs(r, R(_modRhs[r]));
-            }
-         }
-      }
+    // compute primal scaling factor; limit increase in scaling by tolerance
+    // used in floating point solve
+    maxScale = primalScale;
+    maxScale *= _rationalMaxscaleincr;
 
-      // compute dual scaling factor; limit increase in scaling by tolerance used in floating point solve
-      maxScale = dualScale;
-      maxScale *= _rationalMaxscaleincr;
+    primalScale =
+        boundsViolation > sideViolation ? boundsViolation : sideViolation;
 
-      dualScale = redCostViolation > dualViolation ? redCostViolation : dualViolation;
-      assert(dualScale >= 0);
+    if (primalScale < redCostViolation)
+      primalScale = redCostViolation;
 
-      if(dualScale > 0)
-      {
-         invert(dualScale);
+    assert(primalScale >= 0);
 
-         if(dualScale > maxScale)
-            dualScale = maxScale;
-      }
-      else
-         dualScale = maxScale;
+    if (primalScale > 0) {
+      invert(primalScale);
 
-      if(boolParam(SoPlexBase<R>::POWERSCALING))
-         powRound(dualScale);
+      if (primalScale > maxScale)
+        primalScale = maxScale;
+    } else
+      primalScale = maxScale;
 
-      if(dualScale > primalScale)
-         dualScale = primalScale;
+    if (boolParam(SoPlexBase<R>::POWERSCALING))
+      powRound(primalScale);
 
-      if(dualScale < 1)
-         dualScale = 1;
-      else
-      {
-         MSG_INFO2(spxout, spxout << "Scaling dual by " << dualScale.str() << ".\n");
+    // apply scaled bounds
+    if (primalScale <= 1) {
+      if (primalScale < 1)
+        primalScale = 1;
 
-         // perform dual scaling
-         ///@todo remove _modObj and use dualScale * sol._redCost directly
-         _modObj *= dualScale;
-      }
-
-      // apply scaled objective function
-      for(int c = numColsRational() - 1; c >= 0; c--)
-      {
-         if(_modObj[c] >= _rationalPosInfty)
-            _solver.changeObj(c, realParam(SoPlexBase<R>::INFTY));
-         else if(_modObj[c] <= _rationalNegInfty)
-            _solver.changeObj(c, -realParam(SoPlexBase<R>::INFTY));
-         else
-            _solver.changeObj(c, R(_modObj[c]));
-      }
+      for (int c = numColsRational() - 1; c >= 0; c--) {
+        if (_lowerFinite(_colTypes[c])) {
+          if (_modLower[c] <= _rationalNegInfty)
+            _solver.changeLower(c, -realParam(SoPlexBase<R>::INFTY));
+          else
+            _solver.changeLower(c, static_cast<R>(_modLower[c]));
+        }
 
-      for(int r = numRowsRational() - 1; r >= 0; r--)
-      {
-         Rational newRowObj;
-
-         if(_rowTypes[r] == RANGETYPE_FIXED)
-            _solver.changeRowObj(r, R(0.0));
-         else
-         {
-            newRowObj = sol._dual[r];
-            newRowObj *= dualScale;
-
-            if(newRowObj >= _rationalPosInfty)
-               _solver.changeRowObj(r, -realParam(SoPlexBase<R>::INFTY));
-            else if(newRowObj <= _rationalNegInfty)
-               _solver.changeRowObj(r, realParam(SoPlexBase<R>::INFTY));
-            else
-               _solver.changeRowObj(r, -R(newRowObj));
-         }
+        if (_upperFinite(_colTypes[c])) {
+          if (_modUpper[c] >= _rationalPosInfty)
+            _solver.changeUpper(c, realParam(SoPlexBase<R>::INFTY));
+          else
+            _solver.changeUpper(c, R(_modUpper[c]));
+        }
       }
-
-      MSG_INFO1(spxout, spxout << "Refined floating-point solve . . .\n");
-
-      // ensure that artificial slack columns are basic and inequality constraints are nonbasic; otherwise we may end
-      // up with dual violation on inequality constraints after removing the slack columns; do not change this in the
-      // floating-point solver, though, because the solver may require its original basis to detect optimality
-      if(_slackCols.num() > 0 && _hasBasis)
-      {
-         int numOrigCols = numColsRational() - _slackCols.num();
-         assert(_slackCols.num() <= 0 || boolParam(SoPlexBase<R>::EQTRANS));
-
-         for(int i = 0; i < _slackCols.num(); i++)
-         {
-            int row = _slackCols.colVector(i).index(0);
-            int col = numOrigCols + i;
-
-            assert(row >= 0);
-            assert(row < numRowsRational());
-
-            if(_basisStatusRows[row] == SPxSolverBase<R>::BASIC
-                  && _basisStatusCols[col] != SPxSolverBase<R>::BASIC)
-            {
-               _basisStatusRows[row] = _basisStatusCols[col];
-               _basisStatusCols[col] = SPxSolverBase<R>::BASIC;
-               _rationalLUSolver.clear();
-            }
-         }
+    } else {
+      MSG_INFO2(spxout,
+                spxout << "Scaling primal by " << primalScale.str() << ".\n");
+
+      for (int c = numColsRational() - 1; c >= 0; c--) {
+        if (_lowerFinite(_colTypes[c])) {
+          _modLower[c] *= primalScale;
+
+          if (_modLower[c] <= _rationalNegInfty)
+            _solver.changeLower(c, -realParam(SoPlexBase<R>::INFTY));
+          else
+            _solver.changeLower(c, R(_modLower[c]));
+        }
+
+        if (_upperFinite(_colTypes[c])) {
+          _modUpper[c] *= primalScale;
+
+          if (_modUpper[c] >= _rationalPosInfty)
+            _solver.changeUpper(c, realParam(SoPlexBase<R>::INFTY));
+          else
+            _solver.changeUpper(c, R(_modUpper[c]));
+        }
       }
-
-      // load basis
-      if(_hasBasis && _solver.basis().status() < SPxBasisBase<R>::REGULAR)
-      {
-         MSG_DEBUG(spxout << "basis (status = " << _solver.basis().status() << ") desc before set:\n";
-                   _solver.basis().desc().dump());
-         _solver.setBasis(_basisStatusRows.get_const_ptr(), _basisStatusCols.get_const_ptr());
-         MSG_DEBUG(spxout << "basis (status = " << _solver.basis().status() << ") desc after set:\n";
-                   _solver.basis().desc().dump());
-
-         _hasBasis = _solver.basis().status() > SPxBasisBase<R>::NO_PROBLEM;
-         MSG_DEBUG(spxout << "setting basis in solver " << (_hasBasis ? "successful" : "failed") <<
-                   " (3)\n");
+    }
+
+    // apply scaled sides
+    assert(primalScale >= 1);
+
+    if (primalScale == 1) {
+      for (int r = numRowsRational() - 1; r >= 0; r--) {
+        if (_lowerFinite(_rowTypes[r])) {
+          if (_modLhs[r] <= _rationalNegInfty)
+            _solver.changeLhs(r, -realParam(SoPlexBase<R>::INFTY));
+          else
+            _solver.changeLhs(r, R(_modLhs[r]));
+        }
+
+        if (_upperFinite(_rowTypes[r])) {
+          if (_modRhs[r] >= _rationalPosInfty)
+            _solver.changeRhs(r, realParam(SoPlexBase<R>::INFTY));
+          else
+            _solver.changeRhs(r, R(_modRhs[r]));
+        }
       }
-
-      // solve modified problem
-      int prevIterations = _statistics->iterations;
-      _statistics->rationalTime->stop();
-      result = _solveRealStable(acceptUnbounded, acceptInfeasible, primalReal, dualReal, _basisStatusRows,
-                                _basisStatusCols, primalScale > 1e20 || dualScale > 1e20);
-
-      // count refinements and remember whether we moved to a new basis
-      _statistics->refinements++;
-
-      if(_statistics->iterations <= prevIterations)
-      {
-         lastStallRefinements++;
-         _statistics->stallRefinements++;
+    } else {
+      for (int r = numRowsRational() - 1; r >= 0; r--) {
+        if (_lowerFinite(_rowTypes[r])) {
+          _modLhs[r] *= primalScale;
+
+          if (_modLhs[r] <= _rationalNegInfty)
+            _solver.changeLhs(r, -realParam(SoPlexBase<R>::INFTY));
+          else
+            _solver.changeLhs(r, R(_modLhs[r]));
+        }
+
+        if (_upperFinite(_rowTypes[r])) {
+          _modRhs[r] *= primalScale;
+
+          if (_modRhs[r] >= _rationalPosInfty)
+            _solver.changeRhs(r, realParam(SoPlexBase<R>::INFTY));
+          else
+            _solver.changeRhs(r, R(_modRhs[r]));
+        }
       }
+    }
+
+    // compute dual scaling factor; limit increase in scaling by tolerance used
+    // in floating point solve
+    maxScale = dualScale;
+    maxScale *= _rationalMaxscaleincr;
+
+    dualScale =
+        redCostViolation > dualViolation ? redCostViolation : dualViolation;
+    assert(dualScale >= 0);
+
+    if (dualScale > 0) {
+      invert(dualScale);
+
+      if (dualScale > maxScale)
+        dualScale = maxScale;
+    } else
+      dualScale = maxScale;
+
+    if (boolParam(SoPlexBase<R>::POWERSCALING))
+      powRound(dualScale);
+
+    if (dualScale > primalScale)
+      dualScale = primalScale;
+
+    if (dualScale < 1)
+      dualScale = 1;
+    else {
+      MSG_INFO2(spxout,
+                spxout << "Scaling dual by " << dualScale.str() << ".\n");
+
+      // perform dual scaling
+      ///@todo remove _modObj and use dualScale * sol._redCost directly
+      _modObj *= dualScale;
+    }
+
+    // apply scaled objective function
+    for (int c = numColsRational() - 1; c >= 0; c--) {
+      if (_modObj[c] >= _rationalPosInfty)
+        _solver.changeObj(c, realParam(SoPlexBase<R>::INFTY));
+      else if (_modObj[c] <= _rationalNegInfty)
+        _solver.changeObj(c, -realParam(SoPlexBase<R>::INFTY));
       else
-      {
-         factorSolNewBasis = true;
-         lastStallRefinements = 0;
-         _statistics->pivotRefinements = _statistics->refinements;
+        _solver.changeObj(c, R(_modObj[c]));
+    }
+
+    for (int r = numRowsRational() - 1; r >= 0; r--) {
+      Rational newRowObj;
+
+      if (_rowTypes[r] == RANGETYPE_FIXED)
+        _solver.changeRowObj(r, R(0.0));
+      else {
+        newRowObj = sol._dual[r];
+        newRowObj *= dualScale;
+
+        if (newRowObj >= _rationalPosInfty)
+          _solver.changeRowObj(r, -realParam(SoPlexBase<R>::INFTY));
+        else if (newRowObj <= _rationalNegInfty)
+          _solver.changeRowObj(r, realParam(SoPlexBase<R>::INFTY));
+        else
+          _solver.changeRowObj(r, -R(newRowObj));
       }
+    }
+
+    MSG_INFO1(spxout, spxout << "Refined floating-point solve . . .\n");
+
+    // ensure that artificial slack columns are basic and inequality constraints
+    // are nonbasic; otherwise we may end up with dual violation on inequality
+    // constraints after removing the slack columns; do not change this in the
+    // floating-point solver, though, because the solver may require its
+    // original basis to detect optimality
+    if (_slackCols.num() > 0 && _hasBasis) {
+      int numOrigCols = numColsRational() - _slackCols.num();
+      assert(_slackCols.num() <= 0 || boolParam(SoPlexBase<R>::EQTRANS));
+
+      for (int i = 0; i < _slackCols.num(); i++) {
+        int row = _slackCols.colVector(i).index(0);
+        int col = numOrigCols + i;
+
+        assert(row >= 0);
+        assert(row < numRowsRational());
+
+        if (_basisStatusRows[row] == SPxSolverBase<R>::BASIC &&
+            _basisStatusCols[col] != SPxSolverBase<R>::BASIC) {
+          _basisStatusRows[row] = _basisStatusCols[col];
+          _basisStatusCols[col] = SPxSolverBase<R>::BASIC;
+          _rationalLUSolver.clear();
+        }
+      }
+    }
+
+    // load basis
+    if (_hasBasis && _solver.basis().status() < SPxBasisBase<R>::REGULAR) {
+      MSG_DEBUG(spxout << "basis (status = " << _solver.basis().status()
+                       << ") desc before set:\n";
+                _solver.basis().desc().dump());
+      _solver.setBasis(_basisStatusRows.get_const_ptr(),
+                       _basisStatusCols.get_const_ptr());
+      MSG_DEBUG(spxout << "basis (status = " << _solver.basis().status()
+                       << ") desc after set:\n";
+                _solver.basis().desc().dump());
+
+      _hasBasis = _solver.basis().status() > SPxBasisBase<R>::NO_PROBLEM;
+      MSG_DEBUG(spxout << "setting basis in solver "
+                       << (_hasBasis ? "successful" : "failed") << " (3)\n");
+    }
+
+    // solve modified problem
+    int prevIterations = _statistics->iterations;
+    _statistics->rationalTime->stop();
+    result = _solveRealStable(acceptUnbounded, acceptInfeasible, primalReal,
+                              dualReal, _basisStatusRows, _basisStatusCols,
+                              primalScale > 1e20 || dualScale > 1e20);
+
+    // count refinements and remember whether we moved to a new basis
+    _statistics->refinements++;
+
+    if (_statistics->iterations <= prevIterations) {
+      lastStallRefinements++;
+      _statistics->stallRefinements++;
+    } else {
+      factorSolNewBasis = true;
+      lastStallRefinements = 0;
+      _statistics->pivotRefinements = _statistics->refinements;
+    }
+
+    // evaluate result; if modified problem was not solved to optimality, stop
+    // refinement
+    switch (result) {
+    case SPxSolverBase<R>::OPTIMAL:
+      MSG_INFO1(spxout, spxout << "Floating-point optimal.\n");
+      break;
 
-      // evaluate result; if modified problem was not solved to optimality, stop refinement
-      switch(result)
-      {
-      case SPxSolverBase<R>::OPTIMAL:
-         MSG_INFO1(spxout, spxout << "Floating-point optimal.\n");
-         break;
-
-      case SPxSolverBase<R>::INFEASIBLE:
-         MSG_INFO1(spxout, spxout << "Floating-point infeasible.\n");
-         sol._dualFarkas = dualReal;
-         sol._hasDualFarkas = true;
-         infeasible = true;
-         _solver.clearRowObjs();
-         return;
+    case SPxSolverBase<R>::INFEASIBLE:
+      MSG_INFO1(spxout, spxout << "Floating-point infeasible.\n");
+      sol._dualFarkas = dualReal;
+      sol._hasDualFarkas = true;
+      infeasible = true;
+      _solver.clearRowObjs();
+      return;
 
-      case SPxSolverBase<R>::UNBOUNDED:
-         MSG_INFO1(spxout, spxout << "Floating-point unbounded.\n");
-         unbounded = true;
-         _solver.clearRowObjs();
-         return;
+    case SPxSolverBase<R>::UNBOUNDED:
+      MSG_INFO1(spxout, spxout << "Floating-point unbounded.\n");
+      unbounded = true;
+      _solver.clearRowObjs();
+      return;
 
-      case SPxSolverBase<R>::ABORT_TIME:
-         stoppedTime = true;
-         return;
+    case SPxSolverBase<R>::ABORT_TIME:
+      stoppedTime = true;
+      return;
 
-      case SPxSolverBase<R>::ABORT_ITER:
-         stoppedIter = true;
-         _solver.clearRowObjs();
-         return;
+    case SPxSolverBase<R>::ABORT_ITER:
+      stoppedIter = true;
+      _solver.clearRowObjs();
+      return;
 
-      default:
-         error = true;
-         _solver.clearRowObjs();
-         return;
+    default:
+      error = true;
+      _solver.clearRowObjs();
+      return;
+    }
+
+    _statistics->rationalTime->start();
+
+    // correct primal solution and align with basis
+    MSG_DEBUG(std::cout << "Correcting primal solution.\n");
+
+    int primalSize = 0;
+    Rational primalScaleInverse = primalScale;
+    invert(primalScaleInverse);
+    _primalDualDiff.clear();
+
+    for (int c = numColsRational() - 1; c >= 0; c--) {
+      // force values of nonbasic variables to bounds
+      typename SPxSolverBase<R>::VarStatus &basisStatusCol =
+          _basisStatusCols[c];
+
+      if (basisStatusCol == SPxSolverBase<R>::ON_LOWER) {
+        if (sol._primal[c] != lowerRational(c)) {
+          int i = _primalDualDiff.size();
+          _ensureDSVectorRationalMemory(_primalDualDiff, maxDimRational);
+          _primalDualDiff.add(c);
+          _primalDualDiff.value(i) = lowerRational(c);
+          _primalDualDiff.value(i) -= sol._primal[c];
+          sol._primal[c] = lowerRational(c);
+        }
+      } else if (basisStatusCol == SPxSolverBase<R>::ON_UPPER) {
+        if (sol._primal[c] != upperRational(c)) {
+          int i = _primalDualDiff.size();
+          _ensureDSVectorRationalMemory(_primalDualDiff, maxDimRational);
+          _primalDualDiff.add(c);
+          _primalDualDiff.value(i) = upperRational(c);
+          _primalDualDiff.value(i) -= sol._primal[c];
+          sol._primal[c] = upperRational(c);
+        }
+      } else if (basisStatusCol == SPxSolverBase<R>::FIXED) {
+        // it may happen that lower and upper are only equal in the Real LP but
+        // different in the rational LP; we do not check this to avoid rational
+        // comparisons, but simply switch the basis status to the lower bound;
+        // this is necessary, because for fixed variables any reduced cost is
+        // feasible
+        basisStatusCol = SPxSolverBase<R>::ON_LOWER;
+
+        if (sol._primal[c] != lowerRational(c)) {
+          int i = _primalDualDiff.size();
+          _ensureDSVectorRationalMemory(_primalDualDiff, maxDimRational);
+          _primalDualDiff.add(c);
+          _primalDualDiff.value(i) = lowerRational(c);
+          _primalDualDiff.value(i) -= sol._primal[c];
+          sol._primal[c] = lowerRational(c);
+        }
+      } else if (basisStatusCol == SPxSolverBase<R>::ZERO) {
+        if (sol._primal[c] != 0) {
+          int i = _primalDualDiff.size();
+          _ensureDSVectorRationalMemory(_primalDualDiff, maxDimRational);
+          _primalDualDiff.add(c);
+          _primalDualDiff.value(i) = sol._primal[c];
+          _primalDualDiff.value(i) *= -1;
+          sol._primal[c] = 0;
+        }
+      } else {
+        if (primalReal[c] == 1.0) {
+          int i = _primalDualDiff.size();
+          _ensureDSVectorRationalMemory(_primalDualDiff, maxDimRational);
+          _primalDualDiff.add(c);
+          _primalDualDiff.value(i) = primalScaleInverse;
+          sol._primal[c] += _primalDualDiff.value(i);
+        } else if (primalReal[c] == -1.0) {
+          int i = _primalDualDiff.size();
+          _ensureDSVectorRationalMemory(_primalDualDiff, maxDimRational);
+          _primalDualDiff.add(c);
+          _primalDualDiff.value(i) = primalScaleInverse;
+          _primalDualDiff.value(i) *= -1;
+          sol._primal[c] += _primalDualDiff.value(i);
+        } else if (primalReal[c] != 0.0) {
+          int i = _primalDualDiff.size();
+          _ensureDSVectorRationalMemory(_primalDualDiff, maxDimRational);
+          _primalDualDiff.add(c);
+          _primalDualDiff.value(i).assign(primalReal[c]);
+          _primalDualDiff.value(i) *= primalScaleInverse;
+          sol._primal[c] += _primalDualDiff.value(i);
+        }
       }
 
-      _statistics->rationalTime->start();
-
-      // correct primal solution and align with basis
-      MSG_DEBUG(std::cout << "Correcting primal solution.\n");
+      if (sol._primal[c] != 0)
+        primalSize++;
+    }
 
-      int primalSize = 0;
-      Rational primalScaleInverse = primalScale;
-      invert(primalScaleInverse);
-      _primalDualDiff.clear();
-
-      for(int c = numColsRational() - 1; c >= 0; c--)
+    // update or recompute slacks depending on which looks faster
+    if (_primalDualDiff.size() < primalSize) {
+      _rationalLP->addPrimalActivity(_primalDualDiff, sol._slacks);
+#ifndef NDEBUG
       {
-         // force values of nonbasic variables to bounds
-         typename SPxSolverBase<R>::VarStatus& basisStatusCol = _basisStatusCols[c];
-
-         if(basisStatusCol == SPxSolverBase<R>::ON_LOWER)
-         {
-            if(sol._primal[c] != lowerRational(c))
-            {
-               int i = _primalDualDiff.size();
-               _ensureDSVectorRationalMemory(_primalDualDiff, maxDimRational);
-               _primalDualDiff.add(c);
-               _primalDualDiff.value(i) = lowerRational(c);
-               _primalDualDiff.value(i) -= sol._primal[c];
-               sol._primal[c] = lowerRational(c);
-            }
-         }
-         else if(basisStatusCol == SPxSolverBase<R>::ON_UPPER)
-         {
-            if(sol._primal[c] != upperRational(c))
-            {
-               int i = _primalDualDiff.size();
-               _ensureDSVectorRationalMemory(_primalDualDiff, maxDimRational);
-               _primalDualDiff.add(c);
-               _primalDualDiff.value(i) = upperRational(c);
-               _primalDualDiff.value(i) -= sol._primal[c];
-               sol._primal[c] = upperRational(c);
-            }
-         }
-         else if(basisStatusCol == SPxSolverBase<R>::FIXED)
-         {
-            // it may happen that lower and upper are only equal in the Real LP but different in the rational LP; we
-            // do not check this to avoid rational comparisons, but simply switch the basis status to the lower
-            // bound; this is necessary, because for fixed variables any reduced cost is feasible
-            basisStatusCol = SPxSolverBase<R>::ON_LOWER;
-
-            if(sol._primal[c] != lowerRational(c))
-            {
-               int i = _primalDualDiff.size();
-               _ensureDSVectorRationalMemory(_primalDualDiff, maxDimRational);
-               _primalDualDiff.add(c);
-               _primalDualDiff.value(i) = lowerRational(c);
-               _primalDualDiff.value(i) -= sol._primal[c];
-               sol._primal[c] = lowerRational(c);
-            }
-         }
-         else if(basisStatusCol == SPxSolverBase<R>::ZERO)
-         {
-            if(sol._primal[c] != 0)
-            {
-               int i = _primalDualDiff.size();
-               _ensureDSVectorRationalMemory(_primalDualDiff, maxDimRational);
-               _primalDualDiff.add(c);
-               _primalDualDiff.value(i) = sol._primal[c];
-               _primalDualDiff.value(i) *= -1;
-               sol._primal[c] = 0;
-            }
-         }
-         else
-         {
-            if(primalReal[c] == 1.0)
-            {
-               int i = _primalDualDiff.size();
-               _ensureDSVectorRationalMemory(_primalDualDiff, maxDimRational);
-               _primalDualDiff.add(c);
-               _primalDualDiff.value(i) = primalScaleInverse;
-               sol._primal[c] += _primalDualDiff.value(i);
-            }
-            else if(primalReal[c] == -1.0)
-            {
-               int i = _primalDualDiff.size();
-               _ensureDSVectorRationalMemory(_primalDualDiff, maxDimRational);
-               _primalDualDiff.add(c);
-               _primalDualDiff.value(i) = primalScaleInverse;
-               _primalDualDiff.value(i) *= -1;
-               sol._primal[c] += _primalDualDiff.value(i);
-            }
-            else if(primalReal[c] != 0.0)
-            {
-               int i = _primalDualDiff.size();
-               _ensureDSVectorRationalMemory(_primalDualDiff, maxDimRational);
-               _primalDualDiff.add(c);
-               _primalDualDiff.value(i).assign(primalReal[c]);
-               _primalDualDiff.value(i) *= primalScaleInverse;
-               sol._primal[c] += _primalDualDiff.value(i);
-            }
-         }
-
-         if(sol._primal[c] != 0)
-            primalSize++;
+        VectorRational activity(numRowsRational());
+        _rationalLP->computePrimalActivity(sol._primal, activity);
+        assert(sol._slacks == activity);
       }
-
-      // update or recompute slacks depending on which looks faster
-      if(_primalDualDiff.size() < primalSize)
-      {
-         _rationalLP->addPrimalActivity(_primalDualDiff, sol._slacks);
-#ifndef NDEBUG
-         {
-            VectorRational activity(numRowsRational());
-            _rationalLP->computePrimalActivity(sol._primal, activity);
-            assert(sol._slacks == activity);
-         }
 #endif
-      }
-      else
-         _rationalLP->computePrimalActivity(sol._primal, sol._slacks);
+    } else
+      _rationalLP->computePrimalActivity(sol._primal, sol._slacks);
 
-      const int numCorrectedPrimals = _primalDualDiff.size();
+    const int numCorrectedPrimals = _primalDualDiff.size();
 
-      // correct dual solution and align with basis
-      MSG_DEBUG(std::cout << "Correcting dual solution.\n");
+    // correct dual solution and align with basis
+    MSG_DEBUG(std::cout << "Correcting dual solution.\n");
 
 #ifndef NDEBUG
-      {
-         // compute reduced cost violation
-         VectorRational debugRedCost(numColsRational());
-         debugRedCost = VectorRational(_realLP->maxObj());
-         debugRedCost *= -1;
-         _rationalLP->subDualActivity(VectorRational(dualReal), debugRedCost);
-
-         Rational debugRedCostViolation = 0;
-
-         for(int c = numColsRational() - 1; c >= 0; c--)
-         {
-            if(_colTypes[c] == RANGETYPE_FIXED)
-               continue;
-
-            const typename SPxSolverBase<R>::VarStatus& basisStatusCol = _basisStatusCols[c];
-            assert(basisStatusCol != SPxSolverBase<R>::FIXED);
-
-            if(((maximizing && basisStatusCol != SPxSolverBase<R>::ON_LOWER) || (!maximizing
-                  && basisStatusCol != SPxSolverBase<R>::ON_UPPER))
-                  && debugRedCost[c] < -debugRedCostViolation)
-            {
-               MSG_DEBUG(std::cout << "basisStatusCol = " << basisStatusCol
-                         << ", lower tight = " << bool(sol._primal[c] <= lowerRational(c))
-                         << ", upper tight = " << bool(sol._primal[c] >= upperRational(c))
-                         << ", obj[c] = " << _realLP->obj(c)
-                         << ", debugRedCost[c] = " << debugRedCost[c].str()
-                         << "\n");
-               debugRedCostViolation = -debugRedCost[c];
-            }
-
-            if(((maximizing && basisStatusCol != SPxSolverBase<R>::ON_UPPER) || (!maximizing
-                  && basisStatusCol != SPxSolverBase<R>::ON_LOWER))
-                  && debugRedCost[c] > debugRedCostViolation)
-            {
-               MSG_DEBUG(std::cout << "basisStatusCol = " << basisStatusCol
-                         << ", lower tight = " << bool(sol._primal[c] <= lowerRational(c))
-                         << ", upper tight = " << bool(sol._primal[c] >= upperRational(c))
-                         << ", obj[c] = " << _realLP->obj(c)
-                         << ", debugRedCost[c] = " << debugRedCost[c].str()
-                         << "\n");
-               debugRedCostViolation = debugRedCost[c];
-            }
-         }
-
-         // compute dual violation
-         Rational debugDualViolation = 0;
-         Rational debugBasicDualViolation = 0;
-
-         for(int r = numRowsRational() - 1; r >= 0; r--)
-         {
-            if(_rowTypes[r] == RANGETYPE_FIXED)
-               continue;
-
-            const typename SPxSolverBase<R>::VarStatus& basisStatusRow = _basisStatusRows[r];
-            assert(basisStatusRow != SPxSolverBase<R>::FIXED);
-
-            Rational val = (-dualScale * sol._dual[r]) - Rational(dualReal[r]);
-
-            if(((maximizing && basisStatusRow != SPxSolverBase<R>::ON_LOWER) || (!maximizing
-                  && basisStatusRow != SPxSolverBase<R>::ON_UPPER))
-                  && val > debugDualViolation)
-            {
-               MSG_DEBUG(std::cout << "basisStatusRow = " << basisStatusRow
-                         << ", lower tight = " << bool(sol._slacks[r] <= lhsRational(r))
-                         << ", upper tight = " << bool(sol._slacks[r] >= rhsRational(r))
-                         << ", dualReal[r] = " << val.str()
-                         << ", dualReal[r] = " << dualReal[r]
-                         << "\n");
-               debugDualViolation = val;
-            }
+    {
+      // compute reduced cost violation
+      VectorRational debugRedCost(numColsRational());
+      debugRedCost = VectorRational(_realLP->maxObj());
+      debugRedCost *= -1;
+      _rationalLP->subDualActivity(VectorRational(dualReal), debugRedCost);
+
+      Rational debugRedCostViolation = 0;
+
+      for (int c = numColsRational() - 1; c >= 0; c--) {
+        if (_colTypes[c] == RANGETYPE_FIXED)
+          continue;
+
+        const typename SPxSolverBase<R>::VarStatus &basisStatusCol =
+            _basisStatusCols[c];
+        assert(basisStatusCol != SPxSolverBase<R>::FIXED);
+
+        if (((maximizing && basisStatusCol != SPxSolverBase<R>::ON_LOWER) ||
+             (!maximizing && basisStatusCol != SPxSolverBase<R>::ON_UPPER)) &&
+            debugRedCost[c] < -debugRedCostViolation) {
+          MSG_DEBUG(std::cout << "basisStatusCol = " << basisStatusCol
+                              << ", lower tight = "
+                              << bool(sol._primal[c] <= lowerRational(c))
+                              << ", upper tight = "
+                              << bool(sol._primal[c] >= upperRational(c))
+                              << ", obj[c] = " << _realLP->obj(c)
+                              << ", debugRedCost[c] = " << debugRedCost[c].str()
+                              << "\n");
+          debugRedCostViolation = -debugRedCost[c];
+        }
+
+        if (((maximizing && basisStatusCol != SPxSolverBase<R>::ON_UPPER) ||
+             (!maximizing && basisStatusCol != SPxSolverBase<R>::ON_LOWER)) &&
+            debugRedCost[c] > debugRedCostViolation) {
+          MSG_DEBUG(std::cout << "basisStatusCol = " << basisStatusCol
+                              << ", lower tight = "
+                              << bool(sol._primal[c] <= lowerRational(c))
+                              << ", upper tight = "
+                              << bool(sol._primal[c] >= upperRational(c))
+                              << ", obj[c] = " << _realLP->obj(c)
+                              << ", debugRedCost[c] = " << debugRedCost[c].str()
+                              << "\n");
+          debugRedCostViolation = debugRedCost[c];
+        }
+      }
 
-            if(((maximizing && basisStatusRow != SPxSolverBase<R>::ON_UPPER) || (!maximizing
-                  && basisStatusRow != SPxSolverBase<R>::ON_LOWER))
-                  && val < -debugDualViolation)
-            {
-               MSG_DEBUG(std::cout << "basisStatusRow = " << basisStatusRow
-                         << ", lower tight = " << bool(sol._slacks[r] <= lhsRational(r))
-                         << ", upper tight = " << bool(sol._slacks[r] >= rhsRational(r))
-                         << ", dualReal[r] = " << val.str()
-                         << ", dualReal[r] = " << dualReal[r]
-                         << "\n");
-               debugDualViolation = -val;
-            }
+      // compute dual violation
+      Rational debugDualViolation = 0;
+      Rational debugBasicDualViolation = 0;
+
+      for (int r = numRowsRational() - 1; r >= 0; r--) {
+        if (_rowTypes[r] == RANGETYPE_FIXED)
+          continue;
+
+        const typename SPxSolverBase<R>::VarStatus &basisStatusRow =
+            _basisStatusRows[r];
+        assert(basisStatusRow != SPxSolverBase<R>::FIXED);
+
+        Rational val = (-dualScale * sol._dual[r]) - Rational(dualReal[r]);
+
+        if (((maximizing && basisStatusRow != SPxSolverBase<R>::ON_LOWER) ||
+             (!maximizing && basisStatusRow != SPxSolverBase<R>::ON_UPPER)) &&
+            val > debugDualViolation) {
+          MSG_DEBUG(std::cout << "basisStatusRow = " << basisStatusRow
+                              << ", lower tight = "
+                              << bool(sol._slacks[r] <= lhsRational(r))
+                              << ", upper tight = "
+                              << bool(sol._slacks[r] >= rhsRational(r))
+                              << ", dualReal[r] = " << val.str()
+                              << ", dualReal[r] = " << dualReal[r] << "\n");
+          debugDualViolation = val;
+        }
+
+        if (((maximizing && basisStatusRow != SPxSolverBase<R>::ON_UPPER) ||
+             (!maximizing && basisStatusRow != SPxSolverBase<R>::ON_LOWER)) &&
+            val < -debugDualViolation) {
+          MSG_DEBUG(std::cout << "basisStatusRow = " << basisStatusRow
+                              << ", lower tight = "
+                              << bool(sol._slacks[r] <= lhsRational(r))
+                              << ", upper tight = "
+                              << bool(sol._slacks[r] >= rhsRational(r))
+                              << ", dualReal[r] = " << val.str()
+                              << ", dualReal[r] = " << dualReal[r] << "\n");
+          debugDualViolation = -val;
+        }
+
+        if (basisStatusRow == SPxSolverBase<R>::BASIC &&
+            spxAbs(val) > debugBasicDualViolation) {
+          MSG_DEBUG(std::cout << "basisStatusRow = " << basisStatusRow
+                              << ", lower tight = "
+                              << bool(sol._slacks[r] <= lhsRational(r))
+                              << ", upper tight = "
+                              << bool(sol._slacks[r] >= rhsRational(r))
+                              << ", dualReal[r] = " << val.str()
+                              << ", dualReal[r] = " << dualReal[r] << "\n");
+          debugBasicDualViolation = spxAbs(val);
+        }
+      }
 
-            if(basisStatusRow == SPxSolverBase<R>::BASIC && spxAbs(val) > debugBasicDualViolation)
-            {
-               MSG_DEBUG(std::cout << "basisStatusRow = " << basisStatusRow
-                         << ", lower tight = " << bool(sol._slacks[r] <= lhsRational(r))
-                         << ", upper tight = " << bool(sol._slacks[r] >= rhsRational(r))
-                         << ", dualReal[r] = " << val.str()
-                         << ", dualReal[r] = " << dualReal[r]
-                         << "\n");
-               debugBasicDualViolation = spxAbs(val);
-            }
-         }
-
-         if(R(debugRedCostViolation) > _solver.opttol() || R(debugDualViolation) > _solver.opttol()
-               || debugBasicDualViolation > 1e-9)
-         {
-            MSG_WARNING(spxout, spxout << "Warning: floating-point dual solution with violation "
-                        << debugRedCostViolation.str() << " / "
-                        << debugDualViolation.str() << " / "
-                        << debugBasicDualViolation.str()
-                        << " (red. cost, dual, basic).\n");
-         }
+      if (R(debugRedCostViolation) > _solver.opttol() ||
+          R(debugDualViolation) > _solver.opttol() ||
+          debugBasicDualViolation > 1e-9) {
+        MSG_WARNING(
+            spxout,
+            spxout << "Warning: floating-point dual solution with violation "
+                   << debugRedCostViolation.str() << " / "
+                   << debugDualViolation.str() << " / "
+                   << debugBasicDualViolation.str()
+                   << " (red. cost, dual, basic).\n");
       }
+    }
 #endif
 
-      Rational dualScaleInverseNeg = dualScale;
-      invert(dualScaleInverseNeg);
-      dualScaleInverseNeg *= -1;
-      _primalDualDiff.clear();
-      dualSize = 0;
-
-      for(int r = numRowsRational() - 1; r >= 0; r--)
-      {
-         typename SPxSolverBase<R>::VarStatus& basisStatusRow = _basisStatusRows[r];
-
-         // it may happen that left-hand and right-hand side are different in the rational, but equal in the Real LP,
-         // leading to a fixed basis status; this is critical because rows with fixed basis status are ignored in the
-         // computation of the dual violation; to avoid rational comparisons we do not check this but simply switch
-         // to the left-hand side status
-         if(basisStatusRow == SPxSolverBase<R>::FIXED)
-            basisStatusRow = SPxSolverBase<R>::ON_LOWER;
-
-         {
-            if(dualReal[r] != 0)
-            {
-               int i = _primalDualDiff.size();
-               _ensureDSVectorRationalMemory(_primalDualDiff, maxDimRational);
-               _primalDualDiff.add(r);
-               _primalDualDiff.value(i).assign(dualReal[r]);
-               _primalDualDiff.value(i) *= dualScaleInverseNeg;
-               sol._dual[r] -= _primalDualDiff.value(i);
-
-               dualSize++;
-            }
-            else
-            {
-               // we do not check whether the dual value is nonzero, because it probably is; this gives us an
-               // overestimation of the number of nonzeros in the dual solution
-               dualSize++;
-            }
-         }
-      }
+    Rational dualScaleInverseNeg = dualScale;
+    invert(dualScaleInverseNeg);
+    dualScaleInverseNeg *= -1;
+    _primalDualDiff.clear();
+    dualSize = 0;
 
-      // update or recompute reduced cost values depending on which looks faster; adding one to the length of the
-      // dual vector accounts for the objective function vector
-      if(_primalDualDiff.size() < dualSize + 1)
-      {
-         _rationalLP->addDualActivity(_primalDualDiff, sol._redCost);
-#ifndef NDEBUG
-         {
-            VectorRational activity(_rationalLP->maxObj());
-            activity *= -1;
-            _rationalLP->subDualActivity(sol._dual, activity);
-         }
-#endif
-      }
-      else
-      {
-         // we assume that the objective function vector has less nonzeros than the reduced cost vector, and so multiplying
-         // with -1 first and subtracting the dual activity should be faster than adding the dual activity and negating
-         // afterwards
-         _rationalLP->getObj(sol._redCost);
-         _rationalLP->subDualActivity(sol._dual, sol._redCost);
-      }
+    for (int r = numRowsRational() - 1; r >= 0; r--) {
+      typename SPxSolverBase<R>::VarStatus &basisStatusRow =
+          _basisStatusRows[r];
 
-      const int numCorrectedDuals = _primalDualDiff.size();
+      // it may happen that left-hand and right-hand side are different in the
+      // rational, but equal in the Real LP, leading to a fixed basis status;
+      // this is critical because rows with fixed basis status are ignored in
+      // the computation of the dual violation; to avoid rational comparisons we
+      // do not check this but simply switch to the left-hand side status
+      if (basisStatusRow == SPxSolverBase<R>::FIXED)
+        basisStatusRow = SPxSolverBase<R>::ON_LOWER;
 
-      if(numCorrectedPrimals + numCorrectedDuals > 0)
       {
-         MSG_INFO2(spxout, spxout << "Corrected " << numCorrectedPrimals << " primal variables and " <<
-                   numCorrectedDuals << " dual values.\n");
+        if (dualReal[r] != 0) {
+          int i = _primalDualDiff.size();
+          _ensureDSVectorRationalMemory(_primalDualDiff, maxDimRational);
+          _primalDualDiff.add(r);
+          _primalDualDiff.value(i).assign(dualReal[r]);
+          _primalDualDiff.value(i) *= dualScaleInverseNeg;
+          sol._dual[r] -= _primalDualDiff.value(i);
+
+          dualSize++;
+        } else {
+          // we do not check whether the dual value is nonzero, because it
+          // probably is; this gives us an overestimation of the number of
+          // nonzeros in the dual solution
+          dualSize++;
+        }
       }
-   }
-   while(true);
+    }
 
-   // correct basis status for restricted inequalities
-   if(_hasBasis)
-   {
-      for(int r = numRowsRational() - 1; r >= 0; r--)
+    // update or recompute reduced cost values depending on which looks faster;
+    // adding one to the length of the dual vector accounts for the objective
+    // function vector
+    if (_primalDualDiff.size() < dualSize + 1) {
+      _rationalLP->addDualActivity(_primalDualDiff, sol._redCost);
+#ifndef NDEBUG
       {
-         assert((lhsRational(r) == rhsRational(r)) == (_rowTypes[r] == RANGETYPE_FIXED));
-
-         if(_rowTypes[r] != RANGETYPE_FIXED && _basisStatusRows[r] == SPxSolverBase<R>::FIXED)
-            _basisStatusRows[r] = (maximizing == (sol._dual[r] < 0))
+        VectorRational activity(_rationalLP->maxObj());
+        activity *= -1;
+        _rationalLP->subDualActivity(sol._dual, activity);
+      }
+#endif
+    } else {
+      // we assume that the objective function vector has less nonzeros than the
+      // reduced cost vector, and so multiplying with -1 first and subtracting
+      // the dual activity should be faster than adding the dual activity and
+      // negating afterwards
+      _rationalLP->getObj(sol._redCost);
+      _rationalLP->subDualActivity(sol._dual, sol._redCost);
+    }
+
+    const int numCorrectedDuals = _primalDualDiff.size();
+
+    if (numCorrectedPrimals + numCorrectedDuals > 0) {
+      MSG_INFO2(spxout, spxout << "Corrected " << numCorrectedPrimals
+                               << " primal variables and " << numCorrectedDuals
+                               << " dual values.\n");
+    }
+  } while (true);
+
+  // correct basis status for restricted inequalities
+  if (_hasBasis) {
+    for (int r = numRowsRational() - 1; r >= 0; r--) {
+      assert((lhsRational(r) == rhsRational(r)) ==
+             (_rowTypes[r] == RANGETYPE_FIXED));
+
+      if (_rowTypes[r] != RANGETYPE_FIXED &&
+          _basisStatusRows[r] == SPxSolverBase<R>::FIXED)
+        _basisStatusRows[r] = (maximizing == (sol._dual[r] < 0))
                                   ? SPxSolverBase<R>::ON_LOWER
                                   : SPxSolverBase<R>::ON_UPPER;
-      }
-   }
+    }
+  }
 
-   // compute objective function values
-   assert(sol._isPrimalFeasible == sol._isDualFeasible);
+  // compute objective function values
+  assert(sol._isPrimalFeasible == sol._isDualFeasible);
 
-   if(sol._isPrimalFeasible)
-   {
-      sol._objVal = sol._primal * _rationalLP->maxObj();
+  if (sol._isPrimalFeasible) {
+    sol._objVal = sol._primal * _rationalLP->maxObj();
 
-      if(intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MINIMIZE)
-         sol._objVal *= -1;
-   }
+    if (intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MINIMIZE)
+      sol._objVal *= -1;
+  }
 
-   // set objective coefficients for all rows to zero
-   _solver.clearRowObjs();
+  // set objective coefficients for all rows to zero
+  _solver.clearRowObjs();
 
-   // stop rational solving time
-   _statistics->rationalTime->stop();
+  // stop rational solving time
+  _statistics->rationalTime->stop();
 }
 
-
-/// performs iterative refinement on the auxiliary problem for testing unboundedness
+/// performs iterative refinement on the auxiliary problem for testing
+/// unboundedness
 template <class R>
-void SoPlexBase<R>::_performUnboundedIRStable(
-   SolRational& sol,
-   bool& hasUnboundedRay,
-   bool& stoppedTime,
-   bool& stoppedIter,
-   bool& error)
-{
-   bool primalFeasible;
-   bool dualFeasible;
-   bool infeasible;
-   bool unbounded;
-
-   // move objective function to constraints and adjust sides and bounds
-   _transformUnbounded();
-
-   // invalidate solution
-   sol.invalidate();
-
-   // remember current number of refinements
-   int oldRefinements = _statistics->refinements;
-
-   // perform iterative refinement
-   _performOptIRStable(sol, false, false, 0, primalFeasible, dualFeasible, infeasible, unbounded,
-                       stoppedTime, stoppedIter, error);
-
-   // update unbounded refinement counter
-   _statistics->unbdRefinements += _statistics->refinements - oldRefinements;
-
-   // stopped due to some limit
-   if(stoppedTime || stoppedIter)
-   {
-      sol.invalidate();
-      hasUnboundedRay = false;
-      error = false;
-   }
-   // the unbounded problem should always be solved to optimality
-   else if(error || unbounded || infeasible || !primalFeasible || !dualFeasible)
-   {
-      sol.invalidate();
-      hasUnboundedRay = false;
-      error = true;
-   }
-   else
-   {
-      const Rational& tau = sol._primal[numColsRational() - 1];
-
-      MSG_DEBUG(std::cout << "tau = " << tau << " (roughly " << tau.str() << ")\n");
-
-      assert(tau <= 1.0 + 2.0 * realParam(SoPlexBase<R>::FEASTOL));
-      assert(tau >= -realParam(SoPlexBase<R>::FEASTOL));
-
-      // because the right-hand side and all bounds (but tau's upper bound) are zero, tau should be approximately
-      // zero if basic; otherwise at its upper bound 1
-      error = !(tau >= _rationalPosone || tau <= _rationalFeastol);
-      assert(!error);
-
-      hasUnboundedRay = (tau >= 1);
-   }
-
-   // restore problem
-   _untransformUnbounded(sol, hasUnboundedRay);
+void SoPlexBase<R>::_performUnboundedIRStable(SolRational &sol,
+                                              bool &hasUnboundedRay,
+                                              bool &stoppedTime,
+                                              bool &stoppedIter, bool &error) {
+  bool primalFeasible;
+  bool dualFeasible;
+  bool infeasible;
+  bool unbounded;
+
+  // move objective function to constraints and adjust sides and bounds
+  _transformUnbounded();
+
+  // invalidate solution
+  sol.invalidate();
+
+  // remember current number of refinements
+  int oldRefinements = _statistics->refinements;
+
+  // perform iterative refinement
+  _performOptIRStable(sol, false, false, 0, primalFeasible, dualFeasible,
+                      infeasible, unbounded, stoppedTime, stoppedIter, error);
+
+  // update unbounded refinement counter
+  _statistics->unbdRefinements += _statistics->refinements - oldRefinements;
+
+  // stopped due to some limit
+  if (stoppedTime || stoppedIter) {
+    sol.invalidate();
+    hasUnboundedRay = false;
+    error = false;
+  }
+  // the unbounded problem should always be solved to optimality
+  else if (error || unbounded || infeasible || !primalFeasible ||
+           !dualFeasible) {
+    sol.invalidate();
+    hasUnboundedRay = false;
+    error = true;
+  } else {
+    const Rational &tau = sol._primal[numColsRational() - 1];
+
+    MSG_DEBUG(std::cout << "tau = " << tau << " (roughly " << tau.str()
+                        << ")\n");
+
+    assert(tau <= 1.0 + 2.0 * realParam(SoPlexBase<R>::FEASTOL));
+    assert(tau >= -realParam(SoPlexBase<R>::FEASTOL));
+
+    // because the right-hand side and all bounds (but tau's upper bound) are
+    // zero, tau should be approximately zero if basic; otherwise at its upper
+    // bound 1
+    error = !(tau >= _rationalPosone || tau <= _rationalFeastol);
+    assert(!error);
+
+    hasUnboundedRay = (tau >= 1);
+  }
+
+  // restore problem
+  _untransformUnbounded(sol, hasUnboundedRay);
 }
 
-
-
-/// performs iterative refinement on the auxiliary problem for testing feasibility
+/// performs iterative refinement on the auxiliary problem for testing
+/// feasibility
 template <class R>
-void SoPlexBase<R>::_performFeasIRStable(
-   SolRational& sol,
-   bool& withDualFarkas,
-   bool& stoppedTime,
-   bool& stoppedIter,
-   bool& error)
-{
-   bool primalFeasible;
-   bool dualFeasible;
-   bool infeasible;
-   bool unbounded;
-   bool success = false;
-   error = false;
+void SoPlexBase<R>::_performFeasIRStable(SolRational &sol, bool &withDualFarkas,
+                                         bool &stoppedTime, bool &stoppedIter,
+                                         bool &error) {
+  bool primalFeasible;
+  bool dualFeasible;
+  bool infeasible;
+  bool unbounded;
+  bool success = false;
+  error = false;
 
 #if 0
    // if the problem has been found to be infeasible and an approximate Farkas proof is available, we compute a
@@ -1630,2945 +1535,2758 @@ void SoPlexBase<R>::_performFeasIRStable(
    ///@todo if approx Farkas proof is good enough then exit without doing any transformation
 #endif
 
-   // remove objective function, shift, homogenize
-   _transformFeasibility();
+  // remove objective function, shift, homogenize
+  _transformFeasibility();
 
-   // invalidate solution
-   sol.invalidate();
+  // invalidate solution
+  sol.invalidate();
 
-   do
-   {
-      // remember current number of refinements
-      int oldRefinements = _statistics->refinements;
+  do {
+    // remember current number of refinements
+    int oldRefinements = _statistics->refinements;
 
-      // perform iterative refinement
-      _performOptIRStable(sol, false, false, 0, primalFeasible, dualFeasible, infeasible, unbounded,
-                          stoppedTime, stoppedIter, error);
+    // perform iterative refinement
+    _performOptIRStable(sol, false, false, 0, primalFeasible, dualFeasible,
+                        infeasible, unbounded, stoppedTime, stoppedIter, error);
 
-      // update feasible refinement counter
-      _statistics->feasRefinements += _statistics->refinements - oldRefinements;
+    // update feasible refinement counter
+    _statistics->feasRefinements += _statistics->refinements - oldRefinements;
 
-      // stopped due to some limit
-      if(stoppedTime || stoppedIter)
-      {
-         sol.invalidate();
-         withDualFarkas = false;
-         error = false;
-      }
-      // the feasibility problem should always be solved to optimality
-      else if(error || unbounded || infeasible || !primalFeasible || !dualFeasible)
-      {
-         sol.invalidate();
-         withDualFarkas = false;
-         error = true;
-      }
-      // else we should have either a refined Farkas proof or an approximate feasible solution to the original
-      else
-      {
-         const Rational& tau = sol._primal[numColsRational() - 1];
+    // stopped due to some limit
+    if (stoppedTime || stoppedIter) {
+      sol.invalidate();
+      withDualFarkas = false;
+      error = false;
+    }
+    // the feasibility problem should always be solved to optimality
+    else if (error || unbounded || infeasible || !primalFeasible ||
+             !dualFeasible) {
+      sol.invalidate();
+      withDualFarkas = false;
+      error = true;
+    }
+    // else we should have either a refined Farkas proof or an approximate
+    // feasible solution to the original
+    else {
+      const Rational &tau = sol._primal[numColsRational() - 1];
 
-         MSG_DEBUG(std::cout << "tau = " << tau << " (roughly " << tau.str() << ")\n");
+      MSG_DEBUG(std::cout << "tau = " << tau << " (roughly " << tau.str()
+                          << ")\n");
 
-         assert(tau >= -realParam(SoPlexBase<R>::FEASTOL));
-         assert(tau <= 1.0 + realParam(SoPlexBase<R>::FEASTOL));
+      assert(tau >= -realParam(SoPlexBase<R>::FEASTOL));
+      assert(tau <= 1.0 + realParam(SoPlexBase<R>::FEASTOL));
 
-         error = (tau < -_rationalFeastol || tau > _rationalPosone + _rationalFeastol);
-         withDualFarkas = (tau < _rationalPosone);
+      error =
+          (tau < -_rationalFeastol || tau > _rationalPosone + _rationalFeastol);
+      withDualFarkas = (tau < _rationalPosone);
 
-         if(withDualFarkas)
-         {
-            _solRational._hasDualFarkas = true;
-            _solRational._dualFarkas = _solRational._dual;
+      if (withDualFarkas) {
+        _solRational._hasDualFarkas = true;
+        _solRational._dualFarkas = _solRational._dual;
 
 #if 0
             // check if we can compute sufficiently large Farkas box
             _computeInfeasBox(_solRational, true);
 #endif
 
-            if(true)  //@todo check if computeInfeasBox found a sufficient box
-            {
+        if (true) //@todo check if computeInfeasBox found a sufficient box
+        {
 
-               success = true;
-               sol._isPrimalFeasible = false;
-            }
-         }
-         else
-         {
-            sol._isDualFeasible = false;
-            success = true; //successfully found approximate feasible solution
-         }
+          success = true;
+          sol._isPrimalFeasible = false;
+        }
+      } else {
+        sol._isDualFeasible = false;
+        success = true; // successfully found approximate feasible solution
       }
-   }
-   while(!error && !success && !(stoppedTime || stoppedIter));
+    }
+  } while (!error && !success && !(stoppedTime || stoppedIter));
 
-   // restore problem
-   _untransformFeasibility(sol, withDualFarkas);
+  // restore problem
+  _untransformFeasibility(sol, withDualFarkas);
 }
 
+/// reduces matrix coefficient in absolute value by the lifting procedure of
+/// Thiele et al. 2013
+template <class R> void SoPlexBase<R>::_lift() {
+  MSG_DEBUG(std::cout << "Reducing matrix coefficients by lifting.\n");
 
+  // start timing
+  _statistics->transformTime->start();
 
-/// reduces matrix coefficient in absolute value by the lifting procedure of Thiele et al. 2013
-template <class R>
-void SoPlexBase<R>::_lift()
-{
-   MSG_DEBUG(std::cout << "Reducing matrix coefficients by lifting.\n");
-
-   // start timing
-   _statistics->transformTime->start();
+  MSG_DEBUG(_realLP->writeFileLPBase("beforeLift.lp", 0, 0, 0));
 
-   MSG_DEBUG(_realLP->writeFileLPBase("beforeLift.lp", 0, 0, 0));
+  // remember unlifted state
+  _beforeLiftCols = numColsRational();
+  _beforeLiftRows = numRowsRational();
 
-   // remember unlifted state
-   _beforeLiftCols = numColsRational();
-   _beforeLiftRows = numRowsRational();
+  // allocate vector memory
+  DSVectorRational colVector;
+  SVectorRational::Element liftingRowMem[2];
+  SVectorRational liftingRowVector(2, liftingRowMem);
 
-   // allocate vector memory
-   DSVectorRational colVector;
-   SVectorRational::Element liftingRowMem[2];
-   SVectorRational liftingRowVector(2, liftingRowMem);
+  // search each column for large nonzeros entries
+  // @todo: rethink about the static_cast TODO
+  const Rational maxValue =
+      static_cast<Rational>(realParam(SoPlexBase<R>::LIFTMAXVAL));
 
-   // search each column for large nonzeros entries
-   // @todo: rethink about the static_cast TODO
-   const Rational maxValue = static_cast<Rational>(realParam(SoPlexBase<R>::LIFTMAXVAL));
+  for (int i = 0; i < numColsRational(); i++) {
+    MSG_DEBUG(std::cout << "in lifting: examining column " << i << "\n");
 
-   for(int i = 0; i < numColsRational(); i++)
-   {
-      MSG_DEBUG(std::cout << "in lifting: examining column " << i << "\n");
+    // get column vector
+    colVector = colVectorRational(i);
 
-      // get column vector
-      colVector = colVectorRational(i);
+    bool addedLiftingRow = false;
+    int liftingColumnIndex = -1;
 
-      bool addedLiftingRow = false;
-      int liftingColumnIndex = -1;
+    // go through nonzero entries of the column
+    for (int k = colVector.size() - 1; k >= 0; k--) {
+      const Rational &value = colVector.value(k);
 
-      // go through nonzero entries of the column
-      for(int k = colVector.size() - 1; k >= 0; k--)
-      {
-         const Rational& value = colVector.value(k);
+      if (spxAbs(value) > maxValue) {
+        MSG_DEBUG(std::cout << "   --> nonzero " << k << " has value "
+                            << value.str() << " in row " << colVector.index(k)
+                            << "\n");
 
-         if(spxAbs(value) > maxValue)
-         {
-            MSG_DEBUG(std::cout << "   --> nonzero " << k << " has value " << value.str() << " in row " <<
-                      colVector.index(k) << "\n");
+        // add new column equal to maxValue times original column
+        if (!addedLiftingRow) {
+          MSG_DEBUG(std::cout << "            --> adding lifting row\n");
 
-            // add new column equal to maxValue times original column
-            if(!addedLiftingRow)
-            {
-               MSG_DEBUG(std::cout << "            --> adding lifting row\n");
+          assert(liftingRowVector.size() == 0);
 
-               assert(liftingRowVector.size() == 0);
+          liftingColumnIndex = numColsRational();
+          liftingRowVector.add(i, maxValue);
+          liftingRowVector.add(liftingColumnIndex, -1);
 
-               liftingColumnIndex = numColsRational();
-               liftingRowVector.add(i, maxValue);
-               liftingRowVector.add(liftingColumnIndex, -1);
+          _rationalLP->addRow(LPRowRational(0, liftingRowVector, 0));
+          _realLP->addRow(
+              LPRowBase<R>(0.0, DSVectorBase<R>(liftingRowVector), 0.0));
 
-               _rationalLP->addRow(LPRowRational(0, liftingRowVector, 0));
-               _realLP->addRow(LPRowBase<R>(0.0, DSVectorBase<R>(liftingRowVector), 0.0));
+          assert(liftingColumnIndex == numColsRational() - 1);
+          assert(liftingColumnIndex == numCols() - 1);
 
-               assert(liftingColumnIndex == numColsRational() - 1);
-               assert(liftingColumnIndex == numCols() - 1);
+          _rationalLP->changeBounds(liftingColumnIndex, _rationalNegInfty,
+                                    _rationalPosInfty);
+          _realLP->changeBounds(liftingColumnIndex,
+                                -realParam(SoPlexBase<R>::INFTY),
+                                realParam(SoPlexBase<R>::INFTY));
 
-               _rationalLP->changeBounds(liftingColumnIndex, _rationalNegInfty, _rationalPosInfty);
-               _realLP->changeBounds(liftingColumnIndex, -realParam(SoPlexBase<R>::INFTY),
-                                     realParam(SoPlexBase<R>::INFTY));
+          liftingRowVector.clear();
+          addedLiftingRow = true;
+        }
 
-               liftingRowVector.clear();
-               addedLiftingRow = true;
-            }
+        // get row index
+        int rowIndex = colVector.index(k);
+        assert(rowIndex >= 0);
+        assert(rowIndex < _beforeLiftRows);
+        assert(liftingColumnIndex == numColsRational() - 1);
 
-            // get row index
-            int rowIndex = colVector.index(k);
-            assert(rowIndex >= 0);
-            assert(rowIndex < _beforeLiftRows);
-            assert(liftingColumnIndex == numColsRational() - 1);
+        MSG_DEBUG(std::cout << "            --> changing matrix\n");
 
-            MSG_DEBUG(std::cout << "            --> changing matrix\n");
+        // remove nonzero from original column
+        _rationalLP->changeElement(rowIndex, i, 0);
+        _realLP->changeElement(rowIndex, i, 0.0);
 
-            // remove nonzero from original column
-            _rationalLP->changeElement(rowIndex, i, 0);
-            _realLP->changeElement(rowIndex, i, 0.0);
-
-            // add nonzero divided by maxValue to new column
-            Rational newValue(value);
-            newValue /= maxValue;
-            _rationalLP->changeElement(rowIndex, liftingColumnIndex, newValue);
-            _realLP->changeElement(rowIndex, liftingColumnIndex, R(newValue));
-         }
+        // add nonzero divided by maxValue to new column
+        Rational newValue(value);
+        newValue /= maxValue;
+        _rationalLP->changeElement(rowIndex, liftingColumnIndex, newValue);
+        _realLP->changeElement(rowIndex, liftingColumnIndex, R(newValue));
       }
-   }
+    }
+  }
 
-   // search each column for small nonzeros entries
-   const Rational minValue = Rational(realParam(SoPlexBase<R>::LIFTMINVAL));
+  // search each column for small nonzeros entries
+  const Rational minValue = Rational(realParam(SoPlexBase<R>::LIFTMINVAL));
 
-   for(int i = 0; i < numColsRational(); i++)
-   {
-      MSG_DEBUG(std::cout << "in lifting: examining column " << i << "\n");
+  for (int i = 0; i < numColsRational(); i++) {
+    MSG_DEBUG(std::cout << "in lifting: examining column " << i << "\n");
 
-      // get column vector
-      colVector = colVectorRational(i);
+    // get column vector
+    colVector = colVectorRational(i);
 
-      bool addedLiftingRow = false;
-      int liftingColumnIndex = -1;
+    bool addedLiftingRow = false;
+    int liftingColumnIndex = -1;
 
-      // go through nonzero entries of the column
-      for(int k = colVector.size() - 1; k >= 0; k--)
-      {
-         const Rational& value = colVector.value(k);
+    // go through nonzero entries of the column
+    for (int k = colVector.size() - 1; k >= 0; k--) {
+      const Rational &value = colVector.value(k);
 
-         if(spxAbs(value) < minValue)
-         {
-            MSG_DEBUG(std::cout << "   --> nonzero " << k << " has value " << value.str() << " in row " <<
-                      colVector.index(k) << "\n");
+      if (spxAbs(value) < minValue) {
+        MSG_DEBUG(std::cout << "   --> nonzero " << k << " has value "
+                            << value.str() << " in row " << colVector.index(k)
+                            << "\n");
 
-            // add new column equal to maxValue times original column
-            if(!addedLiftingRow)
-            {
-               MSG_DEBUG(std::cout << "            --> adding lifting row\n");
+        // add new column equal to maxValue times original column
+        if (!addedLiftingRow) {
+          MSG_DEBUG(std::cout << "            --> adding lifting row\n");
 
-               assert(liftingRowVector.size() == 0);
+          assert(liftingRowVector.size() == 0);
 
-               liftingColumnIndex = numColsRational();
-               liftingRowVector.add(i, minValue);
-               liftingRowVector.add(liftingColumnIndex, -1);
+          liftingColumnIndex = numColsRational();
+          liftingRowVector.add(i, minValue);
+          liftingRowVector.add(liftingColumnIndex, -1);
 
-               _rationalLP->addRow(LPRowRational(0, liftingRowVector, 0));
-               _realLP->addRow(LPRowBase<R>(0.0, DSVectorBase<R>(liftingRowVector), 0.0));
+          _rationalLP->addRow(LPRowRational(0, liftingRowVector, 0));
+          _realLP->addRow(
+              LPRowBase<R>(0.0, DSVectorBase<R>(liftingRowVector), 0.0));
 
-               assert(liftingColumnIndex == numColsRational() - 1);
-               assert(liftingColumnIndex == numCols() - 1);
+          assert(liftingColumnIndex == numColsRational() - 1);
+          assert(liftingColumnIndex == numCols() - 1);
 
-               _rationalLP->changeBounds(liftingColumnIndex, _rationalNegInfty, _rationalPosInfty);
-               _realLP->changeBounds(liftingColumnIndex, -realParam(SoPlexBase<R>::INFTY),
-                                     realParam(SoPlexBase<R>::INFTY));
+          _rationalLP->changeBounds(liftingColumnIndex, _rationalNegInfty,
+                                    _rationalPosInfty);
+          _realLP->changeBounds(liftingColumnIndex,
+                                -realParam(SoPlexBase<R>::INFTY),
+                                realParam(SoPlexBase<R>::INFTY));
 
-               liftingRowVector.clear();
-               addedLiftingRow = true;
-            }
+          liftingRowVector.clear();
+          addedLiftingRow = true;
+        }
 
-            // get row index
-            int rowIndex = colVector.index(k);
-            assert(rowIndex >= 0);
-            assert(rowIndex < _beforeLiftRows);
-            assert(liftingColumnIndex == numColsRational() - 1);
+        // get row index
+        int rowIndex = colVector.index(k);
+        assert(rowIndex >= 0);
+        assert(rowIndex < _beforeLiftRows);
+        assert(liftingColumnIndex == numColsRational() - 1);
 
-            MSG_DEBUG(std::cout << "            --> changing matrix\n");
+        MSG_DEBUG(std::cout << "            --> changing matrix\n");
 
-            // remove nonzero from original column
-            _rationalLP->changeElement(rowIndex, i, 0);
-            _realLP->changeElement(rowIndex, i, 0.0);
+        // remove nonzero from original column
+        _rationalLP->changeElement(rowIndex, i, 0);
+        _realLP->changeElement(rowIndex, i, 0.0);
 
-            // add nonzero divided by maxValue to new column
-            Rational newValue(value);
-            newValue /= minValue;
-            _rationalLP->changeElement(rowIndex, liftingColumnIndex, newValue);
-            _realLP->changeElement(rowIndex, liftingColumnIndex, R(newValue));
-         }
+        // add nonzero divided by maxValue to new column
+        Rational newValue(value);
+        newValue /= minValue;
+        _rationalLP->changeElement(rowIndex, liftingColumnIndex, newValue);
+        _realLP->changeElement(rowIndex, liftingColumnIndex, R(newValue));
       }
-   }
-
-   // adjust basis
-   if(_hasBasis)
-   {
-      assert(numColsRational() >= _beforeLiftCols);
-      assert(numRowsRational() >= _beforeLiftRows);
-
-      _basisStatusCols.append(numColsRational() - _beforeLiftCols, SPxSolverBase<R>::BASIC);
-      _basisStatusRows.append(numRowsRational() - _beforeLiftRows, SPxSolverBase<R>::FIXED);
-      _rationalLUSolver.clear();
-   }
-
-   MSG_DEBUG(_realLP->writeFileLPBase("afterLift.lp", 0, 0, 0));
-
-   // stop timing
-   _statistics->transformTime->stop();
-
-   if(numColsRational() > _beforeLiftCols || numRowsRational() > _beforeLiftRows)
-   {
-      MSG_INFO1(spxout, spxout << "Added " << numColsRational() - _beforeLiftCols << " columns and "
-                << numRowsRational() - _beforeLiftRows << " rows to reduce large matrix coefficients\n.");
-   }
+    }
+  }
+
+  // adjust basis
+  if (_hasBasis) {
+    assert(numColsRational() >= _beforeLiftCols);
+    assert(numRowsRational() >= _beforeLiftRows);
+
+    _basisStatusCols.append(numColsRational() - _beforeLiftCols,
+                            SPxSolverBase<R>::BASIC);
+    _basisStatusRows.append(numRowsRational() - _beforeLiftRows,
+                            SPxSolverBase<R>::FIXED);
+    _rationalLUSolver.clear();
+  }
+
+  MSG_DEBUG(_realLP->writeFileLPBase("afterLift.lp", 0, 0, 0));
+
+  // stop timing
+  _statistics->transformTime->stop();
+
+  if (numColsRational() > _beforeLiftCols ||
+      numRowsRational() > _beforeLiftRows) {
+    MSG_INFO1(spxout, spxout << "Added " << numColsRational() - _beforeLiftCols
+                             << " columns and "
+                             << numRowsRational() - _beforeLiftRows
+                             << " rows to reduce large matrix coefficients\n.");
+  }
 }
 
-
-
 /// undoes lifting
-template <class R>
-void SoPlexBase<R>::_project(SolRational& sol)
-{
-   // start timing
-   _statistics->transformTime->start();
-
-   // print LP if in debug mode
-   MSG_DEBUG(_realLP->writeFileLPBase("beforeProject.lp", 0, 0, 0));
-
-   assert(numColsRational() >= _beforeLiftCols);
-   assert(numRowsRational() >= _beforeLiftRows);
-
-   // shrink rational LP to original size
-   _rationalLP->removeColRange(_beforeLiftCols, numColsRational() - 1);
-   _rationalLP->removeRowRange(_beforeLiftRows, numRowsRational() - 1);
-
-   // shrink real LP to original size
-   _realLP->removeColRange(_beforeLiftCols, numColsReal() - 1);
-   _realLP->removeRowRange(_beforeLiftRows, numRowsReal() - 1);
-
-   // adjust solution
-   if(sol.isPrimalFeasible())
-   {
-      sol._primal.reDim(_beforeLiftCols);
-      sol._slacks.reDim(_beforeLiftRows);
-   }
-
-   if(sol.hasPrimalRay())
-   {
-      sol._primalRay.reDim(_beforeLiftCols);
-   }
-
-   ///@todo if we know the mapping between original and lifting columns, we simply need to add the reduced cost of
-   ///      the lifting column to the reduced cost of the original column; this is not implemented now, because for
-   ///      optimal solutions the reduced costs of the lifting columns are zero
-   const Rational maxValue = Rational(realParam(SoPlexBase<R>::LIFTMAXVAL));
-
-   for(int i = _beforeLiftCols; i < numColsRational() && sol._isDualFeasible; i++)
-   {
-      if(spxAbs(Rational(maxValue * sol._redCost[i])) > _rationalOpttol)
-      {
-         MSG_INFO1(spxout, spxout << "Warning: lost dual solution during project phase.\n");
-         sol._isDualFeasible = false;
-      }
-   }
-
-   if(sol.isDualFeasible())
-   {
-      sol._redCost.reDim(_beforeLiftCols);
-      sol._dual.reDim(_beforeLiftRows);
-   }
-
-   if(sol.hasDualFarkas())
-   {
-      sol._dualFarkas.reDim(_beforeLiftRows);
-   }
-
-   // adjust basis
-   for(int i = _beforeLiftCols; i < numColsRational() && _hasBasis; i++)
-   {
-      if(_basisStatusCols[i] != SPxSolverBase<R>::BASIC)
-      {
-         MSG_INFO1(spxout, spxout <<
-                   "Warning: lost basis during project phase because of nonbasic lifting column.\n");
-         _hasBasis = false;
-         _rationalLUSolver.clear();
-      }
-   }
-
-   for(int i = _beforeLiftRows; i < numRowsRational() && _hasBasis; i++)
-   {
-      if(_basisStatusRows[i] == SPxSolverBase<R>::BASIC)
-      {
-         MSG_INFO1(spxout, spxout <<
-                   "Warning: lost basis during project phase because of basic lifting row.\n");
-         _hasBasis = false;
-         _rationalLUSolver.clear();
-      }
-   }
-
-   if(_hasBasis)
-   {
-      _basisStatusCols.reSize(_beforeLiftCols);
-      _basisStatusRows.reSize(_beforeLiftRows);
+template <class R> void SoPlexBase<R>::_project(SolRational &sol) {
+  // start timing
+  _statistics->transformTime->start();
+
+  // print LP if in debug mode
+  MSG_DEBUG(_realLP->writeFileLPBase("beforeProject.lp", 0, 0, 0));
+
+  assert(numColsRational() >= _beforeLiftCols);
+  assert(numRowsRational() >= _beforeLiftRows);
+
+  // shrink rational LP to original size
+  _rationalLP->removeColRange(_beforeLiftCols, numColsRational() - 1);
+  _rationalLP->removeRowRange(_beforeLiftRows, numRowsRational() - 1);
+
+  // shrink real LP to original size
+  _realLP->removeColRange(_beforeLiftCols, numColsReal() - 1);
+  _realLP->removeRowRange(_beforeLiftRows, numRowsReal() - 1);
+
+  // adjust solution
+  if (sol.isPrimalFeasible()) {
+    sol._primal.reDim(_beforeLiftCols);
+    sol._slacks.reDim(_beforeLiftRows);
+  }
+
+  if (sol.hasPrimalRay()) {
+    sol._primalRay.reDim(_beforeLiftCols);
+  }
+
+  ///@todo if we know the mapping between original and lifting columns, we
+  ///simply need to add the reduced cost of
+  ///      the lifting column to the reduced cost of the original column; this
+  ///      is not implemented now, because for optimal solutions the reduced
+  ///      costs of the lifting columns are zero
+  const Rational maxValue = Rational(realParam(SoPlexBase<R>::LIFTMAXVAL));
+
+  for (int i = _beforeLiftCols; i < numColsRational() && sol._isDualFeasible;
+       i++) {
+    if (spxAbs(Rational(maxValue * sol._redCost[i])) > _rationalOpttol) {
+      MSG_INFO1(
+          spxout,
+          spxout << "Warning: lost dual solution during project phase.\n");
+      sol._isDualFeasible = false;
+    }
+  }
+
+  if (sol.isDualFeasible()) {
+    sol._redCost.reDim(_beforeLiftCols);
+    sol._dual.reDim(_beforeLiftRows);
+  }
+
+  if (sol.hasDualFarkas()) {
+    sol._dualFarkas.reDim(_beforeLiftRows);
+  }
+
+  // adjust basis
+  for (int i = _beforeLiftCols; i < numColsRational() && _hasBasis; i++) {
+    if (_basisStatusCols[i] != SPxSolverBase<R>::BASIC) {
+      MSG_INFO1(spxout, spxout << "Warning: lost basis during project phase "
+                                  "because of nonbasic lifting column.\n");
+      _hasBasis = false;
       _rationalLUSolver.clear();
-   }
+    }
+  }
 
-   // print LP if in debug mode
-   MSG_DEBUG(_realLP->writeFileLPBase("afterProject.lp", 0, 0, 0));
+  for (int i = _beforeLiftRows; i < numRowsRational() && _hasBasis; i++) {
+    if (_basisStatusRows[i] == SPxSolverBase<R>::BASIC) {
+      MSG_INFO1(spxout, spxout << "Warning: lost basis during project phase "
+                                  "because of basic lifting row.\n");
+      _hasBasis = false;
+      _rationalLUSolver.clear();
+    }
+  }
 
-   // stop timing
-   _statistics->transformTime->stop();
-}
+  if (_hasBasis) {
+    _basisStatusCols.reSize(_beforeLiftCols);
+    _basisStatusRows.reSize(_beforeLiftRows);
+    _rationalLUSolver.clear();
+  }
 
+  // print LP if in debug mode
+  MSG_DEBUG(_realLP->writeFileLPBase("afterProject.lp", 0, 0, 0));
 
+  // stop timing
+  _statistics->transformTime->stop();
+}
 
 /// stores objective, bounds, and sides of real LP
-template <class R>
-void SoPlexBase<R>::_storeLPReal()
-{
+template <class R> void SoPlexBase<R>::_storeLPReal() {
 #ifndef SOPLEX_MANUAL_ALT
 
-   if(intParam(SoPlexBase<R>::SYNCMODE) == SYNCMODE_MANUAL)
-   {
-      _manualRealLP = *_realLP;
-      return;
-   }
+  if (intParam(SoPlexBase<R>::SYNCMODE) == SYNCMODE_MANUAL) {
+    _manualRealLP = *_realLP;
+    return;
+  }
 
 #endif
 
-   _manualLower = _realLP->lower();
-   _manualUpper = _realLP->upper();
-   _manualLhs = _realLP->lhs();
-   _manualRhs = _realLP->rhs();
-   _manualObj.reDim(_realLP->nCols());
-   _realLP->getObj(_manualObj);
+  _manualLower = _realLP->lower();
+  _manualUpper = _realLP->upper();
+  _manualLhs = _realLP->lhs();
+  _manualRhs = _realLP->rhs();
+  _manualObj.reDim(_realLP->nCols());
+  _realLP->getObj(_manualObj);
 }
 
-
-
 /// restores objective, bounds, and sides of real LP
-template <class R>
-void SoPlexBase<R>::_restoreLPReal()
-{
-   if(intParam(SoPlexBase<R>::SYNCMODE) == SYNCMODE_MANUAL)
-   {
+template <class R> void SoPlexBase<R>::_restoreLPReal() {
+  if (intParam(SoPlexBase<R>::SYNCMODE) == SYNCMODE_MANUAL) {
 #ifndef SOPLEX_MANUAL_ALT
-      _solver.loadLP(_manualRealLP);
+    _solver.loadLP(_manualRealLP);
 #else
-      _realLP->changeLower(_manualLower);
-      _realLP->changeUpper(_manualUpper);
-      _realLP->changeLhs(_manualLhs);
-      _realLP->changeRhs(_manualRhs);
-      _realLP->changeObj(_manualObj);
+    _realLP->changeLower(_manualLower);
+    _realLP->changeUpper(_manualUpper);
+    _realLP->changeLhs(_manualLhs);
+    _realLP->changeRhs(_manualRhs);
+    _realLP->changeObj(_manualObj);
 #endif
 
-      if(_hasBasis)
-      {
-         // in manual sync mode, if the right-hand side of an equality constraint is not floating-point
-         // representable, the user might have constructed the constraint in the real LP by rounding down the
-         // left-hand side and rounding up the right-hand side; if the basis status is fixed, we need to adjust it
-         for(int i = 0; i < _solver.nRows(); i++)
-         {
-            if(_basisStatusRows[i] == SPxSolverBase<R>::FIXED && _solver.lhs(i) != _solver.rhs(i))
-            {
-               assert(_solver.rhs(i) == spxNextafter(_solver.lhs(i), R(infinity)));
-
-               if(_hasSolRational && _solRational.isDualFeasible()
-                     && ((intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MAXIMIZE
-                          && _solRational._dual[i] > 0)
-                         || (intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MINIMIZE
-                             && _solRational._dual[i] < 0)))
-               {
-                  _basisStatusRows[i] = SPxSolverBase<R>::ON_UPPER;
-               }
-               else
-               {
-                  _basisStatusRows[i] = SPxSolverBase<R>::ON_LOWER;
-               }
-            }
-         }
-
-         _solver.setBasis(_basisStatusRows.get_const_ptr(), _basisStatusCols.get_const_ptr());
-         _hasBasis = (_solver.basis().status() > SPxBasisBase<R>::NO_PROBLEM);
+    if (_hasBasis) {
+      // in manual sync mode, if the right-hand side of an equality constraint
+      // is not floating-point representable, the user might have constructed
+      // the constraint in the real LP by rounding down the left-hand side and
+      // rounding up the right-hand side; if the basis status is fixed, we need
+      // to adjust it
+      for (int i = 0; i < _solver.nRows(); i++) {
+        if (_basisStatusRows[i] == SPxSolverBase<R>::FIXED &&
+            _solver.lhs(i) != _solver.rhs(i)) {
+          assert(_solver.rhs(i) == spxNextafter(_solver.lhs(i), R(infinity)));
+
+          if (_hasSolRational && _solRational.isDualFeasible() &&
+              ((intParam(SoPlexBase<R>::OBJSENSE) ==
+                    SoPlexBase<R>::OBJSENSE_MAXIMIZE &&
+                _solRational._dual[i] > 0) ||
+               (intParam(SoPlexBase<R>::OBJSENSE) ==
+                    SoPlexBase<R>::OBJSENSE_MINIMIZE &&
+                _solRational._dual[i] < 0))) {
+            _basisStatusRows[i] = SPxSolverBase<R>::ON_UPPER;
+          } else {
+            _basisStatusRows[i] = SPxSolverBase<R>::ON_LOWER;
+          }
+        }
       }
-   }
-   else
-   {
-      _realLP->changeLower(_manualLower);
-      _realLP->changeUpper(_manualUpper);
-      _realLP->changeLhs(_manualLhs);
-      _realLP->changeRhs(_manualRhs);
-      _realLP->changeObj(_manualObj);
-   }
-}
-
-
-
-/// introduces slack variables to transform inequality constraints into equations for both rational and real LP,
-/// which should be in sync
-template <class R>
-void SoPlexBase<R>::_transformEquality()
-{
-   MSG_DEBUG(std::cout << "Transforming rows to equation form.\n");
-
-   // start timing
-   _statistics->transformTime->start();
-
-   MSG_DEBUG(_realLP->writeFileLPBase("beforeTransEqu.lp", 0, 0, 0));
 
-   // clear array of slack columns
-   _slackCols.clear();
-
-   // add artificial slack variables to convert inequality to equality constraints
-   for(int i = 0; i < numRowsRational(); i++)
-   {
-      assert((lhsRational(i) == rhsRational(i)) == (_rowTypes[i] == RANGETYPE_FIXED));
-
-      if(_rowTypes[i] != RANGETYPE_FIXED)
-      {
-         _slackCols.add(_rationalZero, -rhsRational(i), *_unitVectorRational(i), -lhsRational(i));
-
-         if(_rationalLP->lhs(i) != 0)
-            _rationalLP->changeLhs(i, _rationalZero);
-
-         if(_rationalLP->rhs(i) != 0)
-            _rationalLP->changeRhs(i, _rationalZero);
-
-         assert(_rationalLP->lhs(i) == 0);
-         assert(_rationalLP->rhs(i) == 0);
-         _realLP->changeRange(i, R(0.0), R(0.0));
-         _colTypes.append(_switchRangeType(_rowTypes[i]));
-         _rowTypes[i] = RANGETYPE_FIXED;
-      }
-   }
-
-   _rationalLP->addCols(_slackCols);
-   _realLP->addCols(_slackCols);
-
-   // adjust basis
-   if(_hasBasis)
-   {
-      for(int i = 0; i < _slackCols.num(); i++)
-      {
-         int row = _slackCols.colVector(i).index(0);
-
-         assert(row >= 0);
-         assert(row < numRowsRational());
-
-         switch(_basisStatusRows[row])
-         {
-         case SPxSolverBase<R>::ON_LOWER:
-            _basisStatusCols.append(SPxSolverBase<R>::ON_UPPER);
-            break;
-
-         case SPxSolverBase<R>::ON_UPPER:
-            _basisStatusCols.append(SPxSolverBase<R>::ON_LOWER);
-            break;
-
-         case SPxSolverBase<R>::BASIC:
-         case SPxSolverBase<R>::FIXED:
-         default:
-            _basisStatusCols.append(_basisStatusRows[row]);
-            break;
-         }
-
-         _basisStatusRows[row] = SPxSolverBase<R>::FIXED;
-      }
-
-      _rationalLUSolver.clear();
-   }
-
-   MSG_DEBUG(_realLP->writeFileLPBase("afterTransEqu.lp", 0, 0, 0));
-
-   // stop timing
-   _statistics->transformTime->stop();
-
-   if(_slackCols.num() > 0)
-   {
-      MSG_INFO1(spxout, spxout << "Added " << _slackCols.num() <<
-                " slack columns to transform rows to equality form.\n");
-   }
+      _solver.setBasis(_basisStatusRows.get_const_ptr(),
+                       _basisStatusCols.get_const_ptr());
+      _hasBasis = (_solver.basis().status() > SPxBasisBase<R>::NO_PROBLEM);
+    }
+  } else {
+    _realLP->changeLower(_manualLower);
+    _realLP->changeUpper(_manualUpper);
+    _realLP->changeLhs(_manualLhs);
+    _realLP->changeRhs(_manualRhs);
+    _realLP->changeObj(_manualObj);
+  }
 }
 
+/// introduces slack variables to transform inequality constraints into
+/// equations for both rational and real LP, which should be in sync
+template <class R> void SoPlexBase<R>::_transformEquality() {
+  MSG_DEBUG(std::cout << "Transforming rows to equation form.\n");
 
+  // start timing
+  _statistics->transformTime->start();
 
-/// restores original problem
-template <class R>
-void SoPlexBase<R>::_untransformEquality(SolRational& sol)
-{
-   // start timing
-   _statistics->transformTime->start();
-
-   // print LP if in debug mode
-   MSG_DEBUG(_realLP->writeFileLPBase("beforeUntransEqu.lp", 0, 0, 0));
-
-   int numCols = numColsRational();
-   int numOrigCols = numColsRational() - _slackCols.num();
-
-   // adjust solution
-   if(sol.isPrimalFeasible())
-   {
-      for(int i = 0; i < _slackCols.num(); i++)
-      {
-         int col = numOrigCols + i;
-         int row = _slackCols.colVector(i).index(0);
-
-         assert(row >= 0);
-         assert(row < numRowsRational());
+  MSG_DEBUG(_realLP->writeFileLPBase("beforeTransEqu.lp", 0, 0, 0));
 
-         sol._slacks[row] -= sol._primal[col];
-      }
+  // clear array of slack columns
+  _slackCols.clear();
 
-      sol._primal.reDim(numOrigCols);
-   }
+  // add artificial slack variables to convert inequality to equality
+  // constraints
+  for (int i = 0; i < numRowsRational(); i++) {
+    assert((lhsRational(i) == rhsRational(i)) ==
+           (_rowTypes[i] == RANGETYPE_FIXED));
 
-   if(sol.hasPrimalRay())
-   {
-      sol._primalRay.reDim(numOrigCols);
-   }
+    if (_rowTypes[i] != RANGETYPE_FIXED) {
+      _slackCols.add(_rationalZero, -rhsRational(i), *_unitVectorRational(i),
+                     -lhsRational(i));
 
-   // adjust basis
-   if(_hasBasis)
-   {
-      for(int i = 0; i < _slackCols.num(); i++)
-      {
-         int col = numOrigCols + i;
-         int row = _slackCols.colVector(i).index(0);
-
-         assert(row >= 0);
-         assert(row < numRowsRational());
-         assert(_basisStatusRows[row] != SPxSolverBase<R>::UNDEFINED);
-         assert(_basisStatusRows[row] != SPxSolverBase<R>::ZERO || lhsRational(row) == 0);
-         assert(_basisStatusRows[row] != SPxSolverBase<R>::ZERO || rhsRational(row) == 0);
-         assert(_basisStatusRows[row] != SPxSolverBase<R>::BASIC
-                || _basisStatusCols[col] != SPxSolverBase<R>::BASIC);
-
-         MSG_DEBUG(std::cout << "slack column " << col << " for row " << row
-                   << ": col status=" << _basisStatusCols[col]
-                   << ", row status=" << _basisStatusRows[row]
-                   << ", redcost=" << sol._redCost[col].str()
-                   << ", dual=" << sol._dual[row].str() << "\n");
-
-         if(_basisStatusRows[row] != SPxSolverBase<R>::BASIC)
-         {
-            switch(_basisStatusCols[col])
-            {
-            case SPxSolverBase<R>::ON_LOWER:
-               _basisStatusRows[row] = SPxSolverBase<R>::ON_UPPER;
-               break;
-
-            case SPxSolverBase<R>::ON_UPPER:
-               _basisStatusRows[row] = SPxSolverBase<R>::ON_LOWER;
-               break;
-
-            case SPxSolverBase<R>::BASIC:
-            case SPxSolverBase<R>::FIXED:
-            default:
-               _basisStatusRows[row] = _basisStatusCols[col];
-               break;
-            }
-         }
-      }
+      if (_rationalLP->lhs(i) != 0)
+        _rationalLP->changeLhs(i, _rationalZero);
 
-      _basisStatusCols.reSize(numOrigCols);
+      if (_rationalLP->rhs(i) != 0)
+        _rationalLP->changeRhs(i, _rationalZero);
 
-      if(_slackCols.num() > 0)
-         _rationalLUSolver.clear();
-   }
+      assert(_rationalLP->lhs(i) == 0);
+      assert(_rationalLP->rhs(i) == 0);
+      _realLP->changeRange(i, R(0.0), R(0.0));
+      _colTypes.append(_switchRangeType(_rowTypes[i]));
+      _rowTypes[i] = RANGETYPE_FIXED;
+    }
+  }
 
-   // not earlier because of debug message
-   if(sol.isDualFeasible())
-   {
-      sol._redCost.reDim(numOrigCols);
-   }
+  _rationalLP->addCols(_slackCols);
+  _realLP->addCols(_slackCols);
 
-   // restore sides and remove slack columns
-   for(int i = 0; i < _slackCols.num(); i++)
-   {
-      int col = numOrigCols + i;
+  // adjust basis
+  if (_hasBasis) {
+    for (int i = 0; i < _slackCols.num(); i++) {
       int row = _slackCols.colVector(i).index(0);
 
-      if(upperRational(col) != 0)
-         _rationalLP->changeLhs(row, -upperRational(col));
-
-      if(lowerRational(col) != 0)
-         _rationalLP->changeRhs(row, -lowerRational(col));
-
-      assert(_rationalLP->lhs(row) == -upperRational(col));
-      assert(_rationalLP->rhs(row) == -lowerRational(col));
-      _rowTypes[row] = _switchRangeType(_colTypes[col]);
-   }
+      assert(row >= 0);
+      assert(row < numRowsRational());
 
-   _rationalLP->removeColRange(numOrigCols, numCols - 1);
-   _realLP->removeColRange(numOrigCols, numCols - 1);
-   _colTypes.reSize(numOrigCols);
+      switch (_basisStatusRows[row]) {
+      case SPxSolverBase<R>::ON_LOWER:
+        _basisStatusCols.append(SPxSolverBase<R>::ON_UPPER);
+        break;
 
-   // objective, bounds, and sides of real LP are restored only after _solveRational()
+      case SPxSolverBase<R>::ON_UPPER:
+        _basisStatusCols.append(SPxSolverBase<R>::ON_LOWER);
+        break;
 
-   // print LP if in debug mode
-   MSG_DEBUG(_realLP->writeFileLPBase("afterUntransEqu.lp", 0, 0, 0));
-
-   // stop timing
-   _statistics->transformTime->stop();
-}
-
-
-
-/// transforms LP to unboundedness problem by moving the objective function to the constraints, changing right-hand
-/// side and bounds to zero, and adding an auxiliary variable for the decrease in the objective function
-template <class R>
-void SoPlexBase<R>::_transformUnbounded()
-{
-   MSG_INFO1(spxout, spxout << "Setting up LP to compute primal unbounded ray.\n");
-
-   // start timing
-   _statistics->transformTime->start();
-
-   // print LP if in debug mode
-   MSG_DEBUG(_realLP->writeFileLPBase("beforeTransUnbounded.lp", 0, 0, 0));
-
-   // store bounds
-   _unboundedLower.reDim(numColsRational());
-   _unboundedUpper.reDim(numColsRational());
-
-   for(int c = numColsRational() - 1; c >= 0; c--)
-   {
-      if(_lowerFinite(_colTypes[c]))
-         _unboundedLower[c] = lowerRational(c);
-
-      if(_upperFinite(_colTypes[c]))
-         _unboundedUpper[c] = upperRational(c);
-   }
-
-   // store sides
-   _unboundedLhs.reDim(numRowsRational());
-   _unboundedRhs.reDim(numRowsRational());
-
-   for(int r = numRowsRational() - 1; r >= 0; r--)
-   {
-      if(_lowerFinite(_rowTypes[r]))
-         _unboundedLhs[r] = lhsRational(r);
-
-      if(_upperFinite(_rowTypes[r]))
-         _unboundedRhs[r] = rhsRational(r);
-   }
-
-   // make right-hand side zero
-   for(int r = numRowsRational() - 1; r >= 0; r--)
-   {
-      assert((lhsRational(r) > _rationalNegInfty) == _lowerFinite(_rowTypes[r]));
-
-      if(_lowerFinite(_rowTypes[r]))
-      {
-         _rationalLP->changeLhs(r, Rational(0));
-         _realLP->changeLhs(r, R(0.0));
-      }
-      else if(_realLP->lhs(r) > -realParam(SoPlexBase<R>::INFTY))
-         _realLP->changeLhs(r, -realParam(SoPlexBase<R>::INFTY));
-
-      assert((rhsRational(r) < _rationalPosInfty) == _upperFinite(_rowTypes[r]));
-
-      if(_upperFinite(_rowTypes[r]))
-      {
-         _rationalLP->changeRhs(r, Rational(0));
-         _realLP->changeRhs(r, R(0.0));
-      }
-      else if(_realLP->rhs(r) < realParam(SoPlexBase<R>::INFTY))
-         _realLP->changeRhs(r, realParam(SoPlexBase<R>::INFTY));
-   }
-
-   // transform objective function to constraint and add auxiliary variable
-   int numOrigCols = numColsRational();
-   DSVectorRational obj(numOrigCols + 1);
-   ///@todo implement this without copying the objective function
-   obj = _rationalLP->maxObj();
-   obj.add(numOrigCols, -1);
-   _rationalLP->addRow(LPRowRational(0, obj, 0));
-   _realLP->addRow(LPRowBase<R>(0, DSVectorBase<R>(obj), 0));
-   _rowTypes.append(RANGETYPE_FIXED);
-
-   assert(numColsRational() == numOrigCols + 1);
-
-   // set objective coefficient and bounds for auxiliary variable
-   _rationalLP->changeMaxObj(numOrigCols, Rational(1));
-   _realLP->changeMaxObj(numOrigCols, R(1.0));
-
-   _rationalLP->changeBounds(numOrigCols, _rationalNegInfty, 1);
-   _realLP->changeBounds(numOrigCols, -realParam(SoPlexBase<R>::INFTY), 1.0);
-   _colTypes.append(RANGETYPE_UPPER);
-
-   // set objective coefficients to zero and adjust bounds for problem variables
-   for(int c = numColsRational() - 2; c >= 0; c--)
-   {
-      _rationalLP->changeObj(c, Rational(0));
-      _realLP->changeObj(c, R(0.0));
-
-      assert((lowerRational(c) > _rationalNegInfty) == _lowerFinite(_colTypes[c]));
-
-      if(_lowerFinite(_colTypes[c]))
-      {
-         _rationalLP->changeLower(c, Rational(0));
-         _realLP->changeLower(c, R(0.0));
-      }
-      else if(_realLP->lower(c) > -realParam(SoPlexBase<R>::INFTY))
-         _realLP->changeLower(c, -realParam(SoPlexBase<R>::INFTY));
-
-      assert((upperRational(c) < _rationalPosInfty) == _upperFinite(_colTypes[c]));
-
-      if(_upperFinite(_colTypes[c]))
-      {
-         _rationalLP->changeUpper(c, Rational(0));
-         _realLP->changeUpper(c, R(0.0));
-      }
-      else if(_realLP->upper(c) < realParam(SoPlexBase<R>::INFTY))
-         _realLP->changeUpper(c, realParam(SoPlexBase<R>::INFTY));
-   }
-
-   // adjust basis
-   if(_hasBasis)
-   {
-      _basisStatusCols.append(SPxSolverBase<R>::ON_UPPER);
-      _basisStatusRows.append(SPxSolverBase<R>::BASIC);
-      _rationalLUSolver.clear();
-   }
-
-   // print LP if in debug mode
-   MSG_DEBUG(_realLP->writeFileLPBase("afterTransUnbounded.lp", 0, 0, 0));
-
-   // stop timing
-   _statistics->transformTime->stop();
-}
-
-
-
-/// undoes transformation to unboundedness problem
-template <class R>
-void SoPlexBase<R>::_untransformUnbounded(SolRational& sol, bool unbounded)
-{
-   // start timing
-   _statistics->transformTime->start();
-
-   // print LP if in debug mode
-   MSG_DEBUG(_realLP->writeFileLPBase("beforeUntransUnbounded.lp", 0, 0, 0));
-
-   int numOrigCols = numColsRational() - 1;
-   int numOrigRows = numRowsRational() - 1;
-   const Rational& tau = sol._primal[numOrigCols];
-
-   // adjust solution and basis
-   if(unbounded)
-   {
-      assert(tau >= _rationalPosone);
-
-      sol._isPrimalFeasible = false;
-      sol._hasPrimalRay = true;
-      sol._isDualFeasible = false;
-      sol._hasDualFarkas = false;
-
-      if(tau != 1)
-         sol._primal /= tau;
-
-      sol._primalRay = sol._primal;
-      sol._primalRay.reDim(numOrigCols);
-
-      _hasBasis = (_basisStatusCols[numOrigCols] != SPxSolverBase<R>::BASIC
-                   && _basisStatusRows[numOrigRows] == SPxSolverBase<R>::BASIC);
-      _basisStatusCols.reSize(numOrigCols);
-      _basisStatusRows.reSize(numOrigRows);
-   }
-   else if(boolParam(SoPlexBase<R>::TESTDUALINF) && tau < _rationalFeastol)
-   {
-      const Rational& alpha = sol._dual[numOrigRows];
-
-      assert(sol._isDualFeasible);
-      assert(alpha <= _rationalFeastol - _rationalPosone);
-
-      sol._isPrimalFeasible = false;
-      sol._hasPrimalRay = false;
-      sol._hasDualFarkas = false;
-
-      if(alpha != -1)
-      {
-         sol._dual /= -alpha;
-         sol._redCost /= -alpha;
-      }
-
-      sol._dual.reDim(numOrigRows);
-      sol._redCost.reDim(numOrigCols);
-   }
-   else
-   {
-      sol.invalidate();
-      _hasBasis = false;
-      _basisStatusCols.reSize(numOrigCols);
-      _basisStatusCols.reSize(numOrigRows);
-   }
-
-   // recover objective function
-   const SVectorRational& objRowVector = _rationalLP->rowVector(numOrigRows);
-
-   for(int i = objRowVector.size() - 1; i >= 0; i--)
-   {
-      _rationalLP->changeMaxObj(objRowVector.index(i), objRowVector.value(i));
-      _realLP->changeMaxObj(objRowVector.index(i), R(objRowVector.value(i)));
-   }
-
-   // remove objective function constraint and auxiliary variable
-   _rationalLP->removeRow(numOrigRows);
-   _realLP->removeRow(numOrigRows);
-   _rowTypes.reSize(numOrigRows);
-
-   _rationalLP->removeCol(numOrigCols);
-   _realLP->removeCol(numOrigCols);
-   _colTypes.reSize(numOrigCols);
-
-   // restore objective, sides and bounds
-   for(int r = numRowsRational() - 1; r >= 0; r--)
-   {
-      if(_lowerFinite(_rowTypes[r]))
-      {
-         _rationalLP->changeLhs(r, _unboundedLhs[r]);
-         _realLP->changeLhs(r, R(_unboundedLhs[r]));
-      }
-
-      if(_upperFinite(_rowTypes[r]))
-      {
-         _rationalLP->changeRhs(r, _unboundedRhs[r]);
-         _realLP->changeRhs(r, R(_unboundedRhs[r]));
-      }
-
-      assert((lhsRational(r) > _rationalNegInfty) == _lowerFinite(_rowTypes[r]));
-      assert((rhsRational(r) < _rationalPosInfty) == _upperFinite(_rowTypes[r]));
-      assert((lhsReal(r) > -realParam(SoPlexBase<R>::INFTY)) == _lowerFinite(_rowTypes[r]));
-      assert((rhsReal(r) < realParam(SoPlexBase<R>::INFTY)) == _upperFinite(_rowTypes[r]));
-   }
-
-   for(int c = numColsRational() - 1; c >= 0; c--)
-   {
-      if(_lowerFinite(_colTypes[c]))
-      {
-         _rationalLP->changeLower(c, _unboundedLower[c]);
-         _realLP->changeLower(c, R(_unboundedLower[c]));
-      }
-
-      if(_upperFinite(_colTypes[c]))
-      {
-         _rationalLP->changeUpper(c, _unboundedUpper[c]);
-         _realLP->changeUpper(c, R(_unboundedUpper[c]));
+      case SPxSolverBase<R>::BASIC:
+      case SPxSolverBase<R>::FIXED:
+      default:
+        _basisStatusCols.append(_basisStatusRows[row]);
+        break;
       }
 
-      assert((lowerRational(c) > _rationalNegInfty) == _lowerFinite(_colTypes[c]));
-      assert((upperRational(c) < _rationalPosInfty) == _upperFinite(_colTypes[c]));
-      assert((lowerReal(c) > -realParam(SoPlexBase<R>::INFTY)) == _lowerFinite(_colTypes[c]));
-      assert((upperReal(c) < realParam(SoPlexBase<R>::INFTY)) == _upperFinite(_colTypes[c]));
-   }
-
-   // invalidate rational basis factorization
-   _rationalLUSolver.clear();
+      _basisStatusRows[row] = SPxSolverBase<R>::FIXED;
+    }
 
-   // print LP if in debug mode
-   MSG_DEBUG(_realLP->writeFileLPBase("afterUntransUnbounded.lp", 0, 0, 0));
-
-   // stop timing
-   _statistics->transformTime->stop();
-}
-
-
-
-/// store basis
-template <class R>
-void SoPlexBase<R>::_storeBasis()
-{
-   assert(!_storedBasis);
-
-   if(_hasBasis)
-   {
-      _storedBasis = true;
-      _storedBasisStatusCols = _basisStatusCols;
-      _storedBasisStatusRows = _basisStatusRows;
-   }
-   else
-      _storedBasis = false;
-}
+    _rationalLUSolver.clear();
+  }
 
+  MSG_DEBUG(_realLP->writeFileLPBase("afterTransEqu.lp", 0, 0, 0));
 
+  // stop timing
+  _statistics->transformTime->stop();
 
-/// restore basis
-template <class R>
-void SoPlexBase<R>::_restoreBasis()
-{
-   if(_storedBasis)
-   {
-      _hasBasis = true;
-      _basisStatusCols = _storedBasisStatusCols;
-      _basisStatusRows = _storedBasisStatusRows;
-      _storedBasis = false;
-   }
+  if (_slackCols.num() > 0) {
+    MSG_INFO1(spxout,
+              spxout << "Added " << _slackCols.num()
+                     << " slack columns to transform rows to equality form.\n");
+  }
 }
 
+/// restores original problem
+template <class R> void SoPlexBase<R>::_untransformEquality(SolRational &sol) {
+  // start timing
+  _statistics->transformTime->start();
 
+  // print LP if in debug mode
+  MSG_DEBUG(_realLP->writeFileLPBase("beforeUntransEqu.lp", 0, 0, 0));
 
-/// transforms LP to feasibility problem by removing the objective function, shifting variables, and homogenizing the
-/// right-hand side
-template <class R>
-void SoPlexBase<R>::_transformFeasibility()
-{
-   MSG_INFO1(spxout, spxout << "Setting up LP to test for feasibility.\n");
-
-   // start timing
-   _statistics->transformTime->start();
-
-   // print LP if in debug mode
-   MSG_DEBUG(_realLP->writeFileLPBase("beforeTransFeas.lp", 0, 0, 0));
-
-   // store objective function
-   _feasObj.reDim(numColsRational());
-
-   for(int c = numColsRational() - 1; c >= 0; c--)
-      _feasObj[c] = _rationalLP->maxObj(c);
-
-   // store bounds
-   _feasLower.reDim(numColsRational());
-   _feasUpper.reDim(numColsRational());
-
-   for(int c = numColsRational() - 1; c >= 0; c--)
-   {
-      if(_lowerFinite(_colTypes[c]))
-         _feasLower[c] = lowerRational(c);
-
-      if(_upperFinite(_colTypes[c]))
-         _feasUpper[c] = upperRational(c);
-   }
-
-   // store sides
-   _feasLhs.reDim(numRowsRational());
-   _feasRhs.reDim(numRowsRational());
-
-   for(int r = numRowsRational() - 1; r >= 0; r--)
-   {
-      if(_lowerFinite(_rowTypes[r]))
-         _feasLhs[r] = lhsRational(r);
+  int numCols = numColsRational();
+  int numOrigCols = numColsRational() - _slackCols.num();
 
-      if(_upperFinite(_rowTypes[r]))
-         _feasRhs[r] = rhsRational(r);
-   }
+  // adjust solution
+  if (sol.isPrimalFeasible()) {
+    for (int i = 0; i < _slackCols.num(); i++) {
+      int col = numOrigCols + i;
+      int row = _slackCols.colVector(i).index(0);
 
-   // set objective coefficients to zero; shift primal space such as to guarantee that the zero solution is within
-   // the bounds
-   Rational shiftValue;
-   Rational shiftValue2;
+      assert(row >= 0);
+      assert(row < numRowsRational());
 
-   for(int c = numColsRational() - 1; c >= 0; c--)
-   {
-      _rationalLP->changeMaxObj(c, Rational(0));
-      _realLP->changeMaxObj(c, R(0.0));
+      sol._slacks[row] -= sol._primal[col];
+    }
 
-      if(lowerRational(c) > 0)
-      {
-         const SVectorRational& colVector = colVectorRational(c);
-
-         for(int i = 0; i < colVector.size(); i++)
-         {
-            shiftValue = colVector.value(i);
-            shiftValue *= lowerRational(c);
-            int r = colVector.index(i);
-
-            assert((lhsRational(r) > _rationalNegInfty) == _lowerFinite(_rowTypes[r]));
-            assert((rhsRational(r) < _rationalPosInfty) == _upperFinite(_rowTypes[r]));
-
-            if(_lowerFinite(_rowTypes[r]) && _upperFinite(_rowTypes[r]))
-            {
-               shiftValue2 = lhsRational(r);
-               shiftValue2 -= shiftValue;
-               _rationalLP->changeLhs(r, shiftValue2);
-               _realLP->changeLhs(r, R(shiftValue2));
-
-               shiftValue -= rhsRational(r);
-               shiftValue *= -1;
-               _rationalLP->changeRhs(r, shiftValue);
-               _realLP->changeRhs(r, R(shiftValue));
-            }
-            else if(_lowerFinite(_rowTypes[r]))
-            {
-               shiftValue -= lhsRational(r);
-               shiftValue *= -1;
-               _rationalLP->changeLhs(r, shiftValue);
-               _realLP->changeLhs(r, R(shiftValue));
-            }
-            else if(_upperFinite(_rowTypes[r]))
-            {
-               shiftValue -= rhsRational(r);
-               shiftValue *= -1;
-               _rationalLP->changeRhs(r, shiftValue);
-               _realLP->changeRhs(r, R(shiftValue));
-            }
-         }
-
-         assert((upperRational(c) < _rationalPosInfty) == _upperFinite(_colTypes[c]));
-
-         if(_upperFinite(_colTypes[c]))
-         {
-            _rationalLP->changeBounds(c, 0, upperRational(c) - lowerRational(c));
-            _realLP->changeBounds(c, 0.0, R(upperRational(c)));
-         }
-         else if(_realLP->upper(c) < realParam(SoPlexBase<R>::INFTY))
-         {
-            _rationalLP->changeLower(c, Rational(0));
-            _realLP->changeBounds(c, 0.0, realParam(SoPlexBase<R>::INFTY));
-         }
-         else
-         {
-            _rationalLP->changeLower(c, Rational(0));
-            _realLP->changeLower(c, R(0.0));
-         }
-      }
-      else if(upperRational(c) < 0)
-      {
-         const SVectorRational& colVector = colVectorRational(c);
-
-         for(int i = 0; i < colVector.size(); i++)
-         {
-            shiftValue = colVector.value(i);
-            shiftValue *= upperRational(c);
-            int r = colVector.index(i);
-
-            assert((lhsRational(r) > _rationalNegInfty) == _lowerFinite(_rowTypes[r]));
-            assert((rhsRational(r) < _rationalPosInfty) == _upperFinite(_rowTypes[r]));
-
-            if(_lowerFinite(_rowTypes[r]) && _upperFinite(_rowTypes[r]))
-            {
-               shiftValue2 = lhsRational(r);
-               shiftValue2 -= shiftValue;
-               _rationalLP->changeLhs(r, shiftValue2);
-               _realLP->changeLhs(r, R(shiftValue2));
-
-               shiftValue -= rhsRational(r);
-               shiftValue *= -1;
-               _rationalLP->changeRhs(r, shiftValue);
-               _realLP->changeRhs(r, R(shiftValue));
-            }
-            else if(_lowerFinite(_rowTypes[r]))
-            {
-               shiftValue -= lhsRational(r);
-               shiftValue *= -1;
-               _rationalLP->changeLhs(r, shiftValue);
-               _realLP->changeLhs(r, R(shiftValue));
-            }
-            else if(_upperFinite(_rowTypes[r]))
-            {
-               shiftValue -= rhsRational(r);
-               shiftValue *= -1;
-               _rationalLP->changeRhs(r, shiftValue);
-               _realLP->changeRhs(r, R(shiftValue));
-            }
-         }
-
-         assert((lowerRational(c) > _rationalNegInfty) == _lowerFinite(_colTypes[c]));
-
-         if(_lowerFinite(_colTypes[c]))
-         {
-            _rationalLP->changeBounds(c, lowerRational(c) - upperRational(c), 0);
-            _realLP->changeBounds(c, R(lowerRational(c)), 0.0);
-         }
-         else if(_realLP->lower(c) > -realParam(SoPlexBase<R>::INFTY))
-         {
-            _rationalLP->changeUpper(c, Rational(0));
-            _realLP->changeBounds(c, -realParam(SoPlexBase<R>::INFTY), 0.0);
-         }
-         else
-         {
-            _rationalLP->changeUpper(c, Rational(0));
-            _realLP->changeUpper(c, R(0.0));
-         }
-      }
-      else
-      {
-         if(_lowerFinite(_colTypes[c]))
-            _realLP->changeLower(c, R(lowerRational(c)));
-         else if(_realLP->lower(c) > -realParam(SoPlexBase<R>::INFTY))
-            _realLP->changeLower(c, -realParam(SoPlexBase<R>::INFTY));
-
-         if(_upperFinite(_colTypes[c]))
-            _realLP->changeUpper(c, R(upperRational(c)));
-         else if(_realLP->upper(c) < realParam(SoPlexBase<R>::INFTY))
-            _realLP->changeUpper(c, realParam(SoPlexBase<R>::INFTY));
-      }
+    sol._primal.reDim(numOrigCols);
+  }
 
-      assert(lowerReal(c) <= upperReal(c));
-   }
+  if (sol.hasPrimalRay()) {
+    sol._primalRay.reDim(numOrigCols);
+  }
 
-   // homogenize sides
-   _tauColVector.clear();
+  // adjust basis
+  if (_hasBasis) {
+    for (int i = 0; i < _slackCols.num(); i++) {
+      int col = numOrigCols + i;
+      int row = _slackCols.colVector(i).index(0);
 
-   for(int r = numRowsRational() - 1; r >= 0; r--)
-   {
-      if(lhsRational(r) > 0)
-      {
-         _tauColVector.add(r, lhsRational(r));
-         assert((rhsRational(r) < _rationalPosInfty) == _upperFinite(_rowTypes[r]));
-
-         if(_upperFinite(_rowTypes[r]))
-         {
-            _rationalLP->changeRange(r, 0, rhsRational(r) - lhsRational(r));
-            _realLP->changeRange(r, 0.0, R(rhsRational(r)));
-         }
-         else
-         {
-            _rationalLP->changeLhs(r, Rational(0));
-            _realLP->changeLhs(r, R(0.0));
-
-            if(_realLP->rhs(r) < realParam(SoPlexBase<R>::INFTY))
-               _realLP->changeRhs(r, realParam(SoPlexBase<R>::INFTY));
-         }
-      }
-      else if(rhsRational(r) < 0)
-      {
-         _tauColVector.add(r, rhsRational(r));
-         assert((lhsRational(r) > _rationalNegInfty) == _lowerFinite(_rowTypes[r]));
-
-         if(_lowerFinite(_rowTypes[r]))
-         {
-            _rationalLP->changeRange(r, lhsRational(r) - rhsRational(r), 0);
-            _realLP->changeRange(r, R(lhsRational(r)), 0.0);
-         }
-         else
-         {
-            _rationalLP->changeRhs(r, Rational(0));
-            _realLP->changeRhs(r, R(0.0));
-
-            if(_realLP->lhs(r) > -realParam(SoPlexBase<R>::INFTY))
-               _realLP->changeLhs(r, -realParam(SoPlexBase<R>::INFTY));
-         }
-      }
-      else
-      {
-         if(_lowerFinite(_rowTypes[r]))
-            _realLP->changeLhs(r, R(lhsRational(r)));
-         else if(_realLP->lhs(r) > -realParam(SoPlexBase<R>::INFTY))
-            _realLP->changeLhs(r, -realParam(SoPlexBase<R>::INFTY));
-
-         if(_upperFinite(_rowTypes[r]))
-            _realLP->changeRhs(r, R(rhsRational(r)));
-         else if(_realLP->rhs(r) < realParam(SoPlexBase<R>::INFTY))
-            _realLP->changeRhs(r, realParam(SoPlexBase<R>::INFTY));
+      assert(row >= 0);
+      assert(row < numRowsRational());
+      assert(_basisStatusRows[row] != SPxSolverBase<R>::UNDEFINED);
+      assert(_basisStatusRows[row] != SPxSolverBase<R>::ZERO ||
+             lhsRational(row) == 0);
+      assert(_basisStatusRows[row] != SPxSolverBase<R>::ZERO ||
+             rhsRational(row) == 0);
+      assert(_basisStatusRows[row] != SPxSolverBase<R>::BASIC ||
+             _basisStatusCols[col] != SPxSolverBase<R>::BASIC);
+
+      MSG_DEBUG(std::cout << "slack column " << col << " for row " << row
+                          << ": col status=" << _basisStatusCols[col]
+                          << ", row status=" << _basisStatusRows[row]
+                          << ", redcost=" << sol._redCost[col].str()
+                          << ", dual=" << sol._dual[row].str() << "\n");
+
+      if (_basisStatusRows[row] != SPxSolverBase<R>::BASIC) {
+        switch (_basisStatusCols[col]) {
+        case SPxSolverBase<R>::ON_LOWER:
+          _basisStatusRows[row] = SPxSolverBase<R>::ON_UPPER;
+          break;
+
+        case SPxSolverBase<R>::ON_UPPER:
+          _basisStatusRows[row] = SPxSolverBase<R>::ON_LOWER;
+          break;
+
+        case SPxSolverBase<R>::BASIC:
+        case SPxSolverBase<R>::FIXED:
+        default:
+          _basisStatusRows[row] = _basisStatusCols[col];
+          break;
+        }
       }
+    }
 
-      assert(rhsReal(r) <= rhsReal(r));
-   }
-
-   ///@todo exploit this case by returning without LP solving
-   if(_tauColVector.size() == 0)
-   {
-      MSG_INFO3(spxout, spxout << "LP is trivially feasible.\n");
-   }
-
-   // add artificial column
-   SPxColId id;
-   _tauColVector *= -1;
-   _rationalLP->addCol(id,
-                       LPColRational((intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MAXIMIZE ?
-                                      _rationalPosone : _rationalNegone),
-                                     _tauColVector, 1, 0));
-   _realLP->addCol(id,
-                   LPColBase<R>((intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MAXIMIZE ? 1.0 : -1.0),
-                                DSVectorBase<R>(_tauColVector), 1.0, 0.0));
-   _colTypes.append(RANGETYPE_BOXED);
-
-   // adjust basis
-   if(_hasBasis)
-   {
-      _basisStatusCols.append(SPxSolverBase<R>::ON_UPPER);
-   }
-
-   // invalidate rational basis factorization
-   _rationalLUSolver.clear();
-
-   // print LP if in debug mode
-   MSG_DEBUG(_realLP->writeFileLPBase("afterTransFeas.lp", 0, 0, 0));
-
-   // stop timing
-   _statistics->transformTime->stop();
-}
-
-
-
-/// undoes transformation to feasibility problem
-template <class R>
-void SoPlexBase<R>::_untransformFeasibility(SolRational& sol, bool infeasible)
-{
-   // start timing
-   _statistics->transformTime->start();
-
-   // print LP if in debug mode
-   MSG_DEBUG(_realLP->writeFileLPBase("beforeUntransFeas.lp", 0, 0, 0));
+    _basisStatusCols.reSize(numOrigCols);
 
-   int numOrigCols = numColsRational() - 1;
+    if (_slackCols.num() > 0)
+      _rationalLUSolver.clear();
+  }
 
-   // adjust solution and basis
-   if(infeasible)
-   {
-      assert(sol._isDualFeasible);
-      assert(sol._primal[numOrigCols] < 1);
+  // not earlier because of debug message
+  if (sol.isDualFeasible()) {
+    sol._redCost.reDim(numOrigCols);
+  }
 
-      sol._isPrimalFeasible = false;
-      sol._hasPrimalRay = false;
-      sol._isDualFeasible = false;
-      sol._hasDualFarkas = true;
+  // restore sides and remove slack columns
+  for (int i = 0; i < _slackCols.num(); i++) {
+    int col = numOrigCols + i;
+    int row = _slackCols.colVector(i).index(0);
 
-      sol._dualFarkas = sol._dual;
+    if (upperRational(col) != 0)
+      _rationalLP->changeLhs(row, -upperRational(col));
 
-      _hasBasis = false;
-      _basisStatusCols.reSize(numOrigCols);
-   }
-   else if(sol._isPrimalFeasible)
-   {
-      assert(sol._primal[numOrigCols] >= 1);
+    if (lowerRational(col) != 0)
+      _rationalLP->changeRhs(row, -lowerRational(col));
 
-      sol._hasPrimalRay = false;
-      sol._isDualFeasible = false;
-      sol._hasDualFarkas = false;
+    assert(_rationalLP->lhs(row) == -upperRational(col));
+    assert(_rationalLP->rhs(row) == -lowerRational(col));
+    _rowTypes[row] = _switchRangeType(_colTypes[col]);
+  }
 
-      if(sol._primal[numOrigCols] != 1)
-      {
-         sol._slacks /= sol._primal[numOrigCols];
+  _rationalLP->removeColRange(numOrigCols, numCols - 1);
+  _realLP->removeColRange(numOrigCols, numCols - 1);
+  _colTypes.reSize(numOrigCols);
 
-         for(int i = 0; i < numOrigCols; i++)
-            sol._primal[i] /= sol._primal[numOrigCols];
+  // objective, bounds, and sides of real LP are restored only after
+  // _solveRational()
 
-         sol._primal[numOrigCols] = 1;
-      }
+  // print LP if in debug mode
+  MSG_DEBUG(_realLP->writeFileLPBase("afterUntransEqu.lp", 0, 0, 0));
 
-      sol._primal.reDim(numOrigCols);
-      sol._slacks -= _rationalLP->colVector(numOrigCols);
+  // stop timing
+  _statistics->transformTime->stop();
+}
 
-      _hasBasis = (_basisStatusCols[numOrigCols] != SPxSolverBase<R>::BASIC);
-      _basisStatusCols.reSize(numOrigCols);
-   }
-   else
-   {
-      _hasBasis = false;
-      _basisStatusCols.reSize(numOrigCols);
-   }
+/// transforms LP to unboundedness problem by moving the objective function to
+/// the constraints, changing right-hand side and bounds to zero, and adding an
+/// auxiliary variable for the decrease in the objective function
+template <class R> void SoPlexBase<R>::_transformUnbounded() {
+  MSG_INFO1(spxout,
+            spxout << "Setting up LP to compute primal unbounded ray.\n");
+
+  // start timing
+  _statistics->transformTime->start();
+
+  // print LP if in debug mode
+  MSG_DEBUG(_realLP->writeFileLPBase("beforeTransUnbounded.lp", 0, 0, 0));
+
+  // store bounds
+  _unboundedLower.reDim(numColsRational());
+  _unboundedUpper.reDim(numColsRational());
+
+  for (int c = numColsRational() - 1; c >= 0; c--) {
+    if (_lowerFinite(_colTypes[c]))
+      _unboundedLower[c] = lowerRational(c);
+
+    if (_upperFinite(_colTypes[c]))
+      _unboundedUpper[c] = upperRational(c);
+  }
+
+  // store sides
+  _unboundedLhs.reDim(numRowsRational());
+  _unboundedRhs.reDim(numRowsRational());
+
+  for (int r = numRowsRational() - 1; r >= 0; r--) {
+    if (_lowerFinite(_rowTypes[r]))
+      _unboundedLhs[r] = lhsRational(r);
+
+    if (_upperFinite(_rowTypes[r]))
+      _unboundedRhs[r] = rhsRational(r);
+  }
+
+  // make right-hand side zero
+  for (int r = numRowsRational() - 1; r >= 0; r--) {
+    assert((lhsRational(r) > _rationalNegInfty) == _lowerFinite(_rowTypes[r]));
+
+    if (_lowerFinite(_rowTypes[r])) {
+      _rationalLP->changeLhs(r, Rational(0));
+      _realLP->changeLhs(r, R(0.0));
+    } else if (_realLP->lhs(r) > -realParam(SoPlexBase<R>::INFTY))
+      _realLP->changeLhs(r, -realParam(SoPlexBase<R>::INFTY));
+
+    assert((rhsRational(r) < _rationalPosInfty) == _upperFinite(_rowTypes[r]));
+
+    if (_upperFinite(_rowTypes[r])) {
+      _rationalLP->changeRhs(r, Rational(0));
+      _realLP->changeRhs(r, R(0.0));
+    } else if (_realLP->rhs(r) < realParam(SoPlexBase<R>::INFTY))
+      _realLP->changeRhs(r, realParam(SoPlexBase<R>::INFTY));
+  }
+
+  // transform objective function to constraint and add auxiliary variable
+  int numOrigCols = numColsRational();
+  DSVectorRational obj(numOrigCols + 1);
+  ///@todo implement this without copying the objective function
+  obj = _rationalLP->maxObj();
+  obj.add(numOrigCols, -1);
+  _rationalLP->addRow(LPRowRational(0, obj, 0));
+  _realLP->addRow(LPRowBase<R>(0, DSVectorBase<R>(obj), 0));
+  _rowTypes.append(RANGETYPE_FIXED);
+
+  assert(numColsRational() == numOrigCols + 1);
+
+  // set objective coefficient and bounds for auxiliary variable
+  _rationalLP->changeMaxObj(numOrigCols, Rational(1));
+  _realLP->changeMaxObj(numOrigCols, R(1.0));
+
+  _rationalLP->changeBounds(numOrigCols, _rationalNegInfty, 1);
+  _realLP->changeBounds(numOrigCols, -realParam(SoPlexBase<R>::INFTY), 1.0);
+  _colTypes.append(RANGETYPE_UPPER);
+
+  // set objective coefficients to zero and adjust bounds for problem variables
+  for (int c = numColsRational() - 2; c >= 0; c--) {
+    _rationalLP->changeObj(c, Rational(0));
+    _realLP->changeObj(c, R(0.0));
+
+    assert((lowerRational(c) > _rationalNegInfty) ==
+           _lowerFinite(_colTypes[c]));
+
+    if (_lowerFinite(_colTypes[c])) {
+      _rationalLP->changeLower(c, Rational(0));
+      _realLP->changeLower(c, R(0.0));
+    } else if (_realLP->lower(c) > -realParam(SoPlexBase<R>::INFTY))
+      _realLP->changeLower(c, -realParam(SoPlexBase<R>::INFTY));
+
+    assert((upperRational(c) < _rationalPosInfty) ==
+           _upperFinite(_colTypes[c]));
+
+    if (_upperFinite(_colTypes[c])) {
+      _rationalLP->changeUpper(c, Rational(0));
+      _realLP->changeUpper(c, R(0.0));
+    } else if (_realLP->upper(c) < realParam(SoPlexBase<R>::INFTY))
+      _realLP->changeUpper(c, realParam(SoPlexBase<R>::INFTY));
+  }
+
+  // adjust basis
+  if (_hasBasis) {
+    _basisStatusCols.append(SPxSolverBase<R>::ON_UPPER);
+    _basisStatusRows.append(SPxSolverBase<R>::BASIC);
+    _rationalLUSolver.clear();
+  }
+
+  // print LP if in debug mode
+  MSG_DEBUG(_realLP->writeFileLPBase("afterTransUnbounded.lp", 0, 0, 0));
+
+  // stop timing
+  _statistics->transformTime->stop();
+}
 
-   // restore right-hand side
-   for(int r = numRowsRational() - 1; r >= 0; r--)
-   {
-      assert(rhsRational(r) >= _rationalPosInfty || lhsRational(r) <= _rationalNegInfty
-             || _feasLhs[r] - lhsRational(r) == _feasRhs[r] - rhsRational(r));
+/// undoes transformation to unboundedness problem
+template <class R>
+void SoPlexBase<R>::_untransformUnbounded(SolRational &sol, bool unbounded) {
+  // start timing
+  _statistics->transformTime->start();
+
+  // print LP if in debug mode
+  MSG_DEBUG(_realLP->writeFileLPBase("beforeUntransUnbounded.lp", 0, 0, 0));
+
+  int numOrigCols = numColsRational() - 1;
+  int numOrigRows = numRowsRational() - 1;
+  const Rational &tau = sol._primal[numOrigCols];
+
+  // adjust solution and basis
+  if (unbounded) {
+    assert(tau >= _rationalPosone);
+
+    sol._isPrimalFeasible = false;
+    sol._hasPrimalRay = true;
+    sol._isDualFeasible = false;
+    sol._hasDualFarkas = false;
+
+    if (tau != 1)
+      sol._primal /= tau;
+
+    sol._primalRay = sol._primal;
+    sol._primalRay.reDim(numOrigCols);
+
+    _hasBasis = (_basisStatusCols[numOrigCols] != SPxSolverBase<R>::BASIC &&
+                 _basisStatusRows[numOrigRows] == SPxSolverBase<R>::BASIC);
+    _basisStatusCols.reSize(numOrigCols);
+    _basisStatusRows.reSize(numOrigRows);
+  } else if (boolParam(SoPlexBase<R>::TESTDUALINF) && tau < _rationalFeastol) {
+    const Rational &alpha = sol._dual[numOrigRows];
+
+    assert(sol._isDualFeasible);
+    assert(alpha <= _rationalFeastol - _rationalPosone);
+
+    sol._isPrimalFeasible = false;
+    sol._hasPrimalRay = false;
+    sol._hasDualFarkas = false;
+
+    if (alpha != -1) {
+      sol._dual /= -alpha;
+      sol._redCost /= -alpha;
+    }
+
+    sol._dual.reDim(numOrigRows);
+    sol._redCost.reDim(numOrigCols);
+  } else {
+    sol.invalidate();
+    _hasBasis = false;
+    _basisStatusCols.reSize(numOrigCols);
+    _basisStatusCols.reSize(numOrigRows);
+  }
+
+  // recover objective function
+  const SVectorRational &objRowVector = _rationalLP->rowVector(numOrigRows);
+
+  for (int i = objRowVector.size() - 1; i >= 0; i--) {
+    _rationalLP->changeMaxObj(objRowVector.index(i), objRowVector.value(i));
+    _realLP->changeMaxObj(objRowVector.index(i), R(objRowVector.value(i)));
+  }
+
+  // remove objective function constraint and auxiliary variable
+  _rationalLP->removeRow(numOrigRows);
+  _realLP->removeRow(numOrigRows);
+  _rowTypes.reSize(numOrigRows);
+
+  _rationalLP->removeCol(numOrigCols);
+  _realLP->removeCol(numOrigCols);
+  _colTypes.reSize(numOrigCols);
+
+  // restore objective, sides and bounds
+  for (int r = numRowsRational() - 1; r >= 0; r--) {
+    if (_lowerFinite(_rowTypes[r])) {
+      _rationalLP->changeLhs(r, _unboundedLhs[r]);
+      _realLP->changeLhs(r, R(_unboundedLhs[r]));
+    }
+
+    if (_upperFinite(_rowTypes[r])) {
+      _rationalLP->changeRhs(r, _unboundedRhs[r]);
+      _realLP->changeRhs(r, R(_unboundedRhs[r]));
+    }
+
+    assert((lhsRational(r) > _rationalNegInfty) == _lowerFinite(_rowTypes[r]));
+    assert((rhsRational(r) < _rationalPosInfty) == _upperFinite(_rowTypes[r]));
+    assert((lhsReal(r) > -realParam(SoPlexBase<R>::INFTY)) ==
+           _lowerFinite(_rowTypes[r]));
+    assert((rhsReal(r) < realParam(SoPlexBase<R>::INFTY)) ==
+           _upperFinite(_rowTypes[r]));
+  }
+
+  for (int c = numColsRational() - 1; c >= 0; c--) {
+    if (_lowerFinite(_colTypes[c])) {
+      _rationalLP->changeLower(c, _unboundedLower[c]);
+      _realLP->changeLower(c, R(_unboundedLower[c]));
+    }
+
+    if (_upperFinite(_colTypes[c])) {
+      _rationalLP->changeUpper(c, _unboundedUpper[c]);
+      _realLP->changeUpper(c, R(_unboundedUpper[c]));
+    }
+
+    assert((lowerRational(c) > _rationalNegInfty) ==
+           _lowerFinite(_colTypes[c]));
+    assert((upperRational(c) < _rationalPosInfty) ==
+           _upperFinite(_colTypes[c]));
+    assert((lowerReal(c) > -realParam(SoPlexBase<R>::INFTY)) ==
+           _lowerFinite(_colTypes[c]));
+    assert((upperReal(c) < realParam(SoPlexBase<R>::INFTY)) ==
+           _upperFinite(_colTypes[c]));
+  }
+
+  // invalidate rational basis factorization
+  _rationalLUSolver.clear();
+
+  // print LP if in debug mode
+  MSG_DEBUG(_realLP->writeFileLPBase("afterUntransUnbounded.lp", 0, 0, 0));
+
+  // stop timing
+  _statistics->transformTime->stop();
+}
 
-      if(_lowerFinite(_rowTypes[r]))
-      {
-         _rationalLP->changeLhs(r, _feasLhs[r]);
-         _realLP->changeLhs(r, R(_feasLhs[r]));
-      }
-      else if(_realLP->lhs(r) > -realParam(SoPlexBase<R>::INFTY))
-         _realLP->changeLhs(r, -realParam(SoPlexBase<R>::INFTY));
+/// store basis
+template <class R> void SoPlexBase<R>::_storeBasis() {
+  assert(!_storedBasis);
+
+  if (_hasBasis) {
+    _storedBasis = true;
+    _storedBasisStatusCols = _basisStatusCols;
+    _storedBasisStatusRows = _basisStatusRows;
+  } else
+    _storedBasis = false;
+}
 
-      assert(_lowerFinite(_rowTypes[r]) == (lhsRational(r) > _rationalNegInfty));
-      assert(_lowerFinite(_rowTypes[r]) == (lhsReal(r) > -realParam(SoPlexBase<R>::INFTY)));
+/// restore basis
+template <class R> void SoPlexBase<R>::_restoreBasis() {
+  if (_storedBasis) {
+    _hasBasis = true;
+    _basisStatusCols = _storedBasisStatusCols;
+    _basisStatusRows = _storedBasisStatusRows;
+    _storedBasis = false;
+  }
+}
 
-      if(_upperFinite(_rowTypes[r]))
-      {
-         _rationalLP->changeRhs(r, _feasRhs[r]);
-         _realLP->changeRhs(r, R(_feasRhs[r]));
+/// transforms LP to feasibility problem by removing the objective function,
+/// shifting variables, and homogenizing the right-hand side
+template <class R> void SoPlexBase<R>::_transformFeasibility() {
+  MSG_INFO1(spxout, spxout << "Setting up LP to test for feasibility.\n");
+
+  // start timing
+  _statistics->transformTime->start();
+
+  // print LP if in debug mode
+  MSG_DEBUG(_realLP->writeFileLPBase("beforeTransFeas.lp", 0, 0, 0));
+
+  // store objective function
+  _feasObj.reDim(numColsRational());
+
+  for (int c = numColsRational() - 1; c >= 0; c--)
+    _feasObj[c] = _rationalLP->maxObj(c);
+
+  // store bounds
+  _feasLower.reDim(numColsRational());
+  _feasUpper.reDim(numColsRational());
+
+  for (int c = numColsRational() - 1; c >= 0; c--) {
+    if (_lowerFinite(_colTypes[c]))
+      _feasLower[c] = lowerRational(c);
+
+    if (_upperFinite(_colTypes[c]))
+      _feasUpper[c] = upperRational(c);
+  }
+
+  // store sides
+  _feasLhs.reDim(numRowsRational());
+  _feasRhs.reDim(numRowsRational());
+
+  for (int r = numRowsRational() - 1; r >= 0; r--) {
+    if (_lowerFinite(_rowTypes[r]))
+      _feasLhs[r] = lhsRational(r);
+
+    if (_upperFinite(_rowTypes[r]))
+      _feasRhs[r] = rhsRational(r);
+  }
+
+  // set objective coefficients to zero; shift primal space such as to guarantee
+  // that the zero solution is within the bounds
+  Rational shiftValue;
+  Rational shiftValue2;
+
+  for (int c = numColsRational() - 1; c >= 0; c--) {
+    _rationalLP->changeMaxObj(c, Rational(0));
+    _realLP->changeMaxObj(c, R(0.0));
+
+    if (lowerRational(c) > 0) {
+      const SVectorRational &colVector = colVectorRational(c);
+
+      for (int i = 0; i < colVector.size(); i++) {
+        shiftValue = colVector.value(i);
+        shiftValue *= lowerRational(c);
+        int r = colVector.index(i);
+
+        assert((lhsRational(r) > _rationalNegInfty) ==
+               _lowerFinite(_rowTypes[r]));
+        assert((rhsRational(r) < _rationalPosInfty) ==
+               _upperFinite(_rowTypes[r]));
+
+        if (_lowerFinite(_rowTypes[r]) && _upperFinite(_rowTypes[r])) {
+          shiftValue2 = lhsRational(r);
+          shiftValue2 -= shiftValue;
+          _rationalLP->changeLhs(r, shiftValue2);
+          _realLP->changeLhs(r, R(shiftValue2));
+
+          shiftValue -= rhsRational(r);
+          shiftValue *= -1;
+          _rationalLP->changeRhs(r, shiftValue);
+          _realLP->changeRhs(r, R(shiftValue));
+        } else if (_lowerFinite(_rowTypes[r])) {
+          shiftValue -= lhsRational(r);
+          shiftValue *= -1;
+          _rationalLP->changeLhs(r, shiftValue);
+          _realLP->changeLhs(r, R(shiftValue));
+        } else if (_upperFinite(_rowTypes[r])) {
+          shiftValue -= rhsRational(r);
+          shiftValue *= -1;
+          _rationalLP->changeRhs(r, shiftValue);
+          _realLP->changeRhs(r, R(shiftValue));
+        }
       }
-      else if(_realLP->rhs(r) < realParam(SoPlexBase<R>::INFTY))
-         _realLP->changeRhs(r, realParam(SoPlexBase<R>::INFTY));
-
-      assert(_upperFinite(_rowTypes[r]) == (rhsRational(r) < _rationalPosInfty));
-      assert(_upperFinite(_rowTypes[r]) == (rhsReal(r) < realParam(SoPlexBase<R>::INFTY)));
 
-      assert(lhsReal(r) <= rhsReal(r));
-   }
+      assert((upperRational(c) < _rationalPosInfty) ==
+             _upperFinite(_colTypes[c]));
+
+      if (_upperFinite(_colTypes[c])) {
+        _rationalLP->changeBounds(c, 0, upperRational(c) - lowerRational(c));
+        _realLP->changeBounds(c, 0.0, R(upperRational(c)));
+      } else if (_realLP->upper(c) < realParam(SoPlexBase<R>::INFTY)) {
+        _rationalLP->changeLower(c, Rational(0));
+        _realLP->changeBounds(c, 0.0, realParam(SoPlexBase<R>::INFTY));
+      } else {
+        _rationalLP->changeLower(c, Rational(0));
+        _realLP->changeLower(c, R(0.0));
+      }
+    } else if (upperRational(c) < 0) {
+      const SVectorRational &colVector = colVectorRational(c);
+
+      for (int i = 0; i < colVector.size(); i++) {
+        shiftValue = colVector.value(i);
+        shiftValue *= upperRational(c);
+        int r = colVector.index(i);
+
+        assert((lhsRational(r) > _rationalNegInfty) ==
+               _lowerFinite(_rowTypes[r]));
+        assert((rhsRational(r) < _rationalPosInfty) ==
+               _upperFinite(_rowTypes[r]));
+
+        if (_lowerFinite(_rowTypes[r]) && _upperFinite(_rowTypes[r])) {
+          shiftValue2 = lhsRational(r);
+          shiftValue2 -= shiftValue;
+          _rationalLP->changeLhs(r, shiftValue2);
+          _realLP->changeLhs(r, R(shiftValue2));
+
+          shiftValue -= rhsRational(r);
+          shiftValue *= -1;
+          _rationalLP->changeRhs(r, shiftValue);
+          _realLP->changeRhs(r, R(shiftValue));
+        } else if (_lowerFinite(_rowTypes[r])) {
+          shiftValue -= lhsRational(r);
+          shiftValue *= -1;
+          _rationalLP->changeLhs(r, shiftValue);
+          _realLP->changeLhs(r, R(shiftValue));
+        } else if (_upperFinite(_rowTypes[r])) {
+          shiftValue -= rhsRational(r);
+          shiftValue *= -1;
+          _rationalLP->changeRhs(r, shiftValue);
+          _realLP->changeRhs(r, R(shiftValue));
+        }
+      }
 
-   // unshift primal space and restore objective coefficients
-   Rational shiftValue;
+      assert((lowerRational(c) > _rationalNegInfty) ==
+             _lowerFinite(_colTypes[c]));
+
+      if (_lowerFinite(_colTypes[c])) {
+        _rationalLP->changeBounds(c, lowerRational(c) - upperRational(c), 0);
+        _realLP->changeBounds(c, R(lowerRational(c)), 0.0);
+      } else if (_realLP->lower(c) > -realParam(SoPlexBase<R>::INFTY)) {
+        _rationalLP->changeUpper(c, Rational(0));
+        _realLP->changeBounds(c, -realParam(SoPlexBase<R>::INFTY), 0.0);
+      } else {
+        _rationalLP->changeUpper(c, Rational(0));
+        _realLP->changeUpper(c, R(0.0));
+      }
+    } else {
+      if (_lowerFinite(_colTypes[c]))
+        _realLP->changeLower(c, R(lowerRational(c)));
+      else if (_realLP->lower(c) > -realParam(SoPlexBase<R>::INFTY))
+        _realLP->changeLower(c, -realParam(SoPlexBase<R>::INFTY));
+
+      if (_upperFinite(_colTypes[c]))
+        _realLP->changeUpper(c, R(upperRational(c)));
+      else if (_realLP->upper(c) < realParam(SoPlexBase<R>::INFTY))
+        _realLP->changeUpper(c, realParam(SoPlexBase<R>::INFTY));
+    }
+
+    assert(lowerReal(c) <= upperReal(c));
+  }
+
+  // homogenize sides
+  _tauColVector.clear();
+
+  for (int r = numRowsRational() - 1; r >= 0; r--) {
+    if (lhsRational(r) > 0) {
+      _tauColVector.add(r, lhsRational(r));
+      assert((rhsRational(r) < _rationalPosInfty) ==
+             _upperFinite(_rowTypes[r]));
+
+      if (_upperFinite(_rowTypes[r])) {
+        _rationalLP->changeRange(r, 0, rhsRational(r) - lhsRational(r));
+        _realLP->changeRange(r, 0.0, R(rhsRational(r)));
+      } else {
+        _rationalLP->changeLhs(r, Rational(0));
+        _realLP->changeLhs(r, R(0.0));
+
+        if (_realLP->rhs(r) < realParam(SoPlexBase<R>::INFTY))
+          _realLP->changeRhs(r, realParam(SoPlexBase<R>::INFTY));
+      }
+    } else if (rhsRational(r) < 0) {
+      _tauColVector.add(r, rhsRational(r));
+      assert((lhsRational(r) > _rationalNegInfty) ==
+             _lowerFinite(_rowTypes[r]));
+
+      if (_lowerFinite(_rowTypes[r])) {
+        _rationalLP->changeRange(r, lhsRational(r) - rhsRational(r), 0);
+        _realLP->changeRange(r, R(lhsRational(r)), 0.0);
+      } else {
+        _rationalLP->changeRhs(r, Rational(0));
+        _realLP->changeRhs(r, R(0.0));
+
+        if (_realLP->lhs(r) > -realParam(SoPlexBase<R>::INFTY))
+          _realLP->changeLhs(r, -realParam(SoPlexBase<R>::INFTY));
+      }
+    } else {
+      if (_lowerFinite(_rowTypes[r]))
+        _realLP->changeLhs(r, R(lhsRational(r)));
+      else if (_realLP->lhs(r) > -realParam(SoPlexBase<R>::INFTY))
+        _realLP->changeLhs(r, -realParam(SoPlexBase<R>::INFTY));
+
+      if (_upperFinite(_rowTypes[r]))
+        _realLP->changeRhs(r, R(rhsRational(r)));
+      else if (_realLP->rhs(r) < realParam(SoPlexBase<R>::INFTY))
+        _realLP->changeRhs(r, realParam(SoPlexBase<R>::INFTY));
+    }
+
+    assert(rhsReal(r) <= rhsReal(r));
+  }
+
+  ///@todo exploit this case by returning without LP solving
+  if (_tauColVector.size() == 0) {
+    MSG_INFO3(spxout, spxout << "LP is trivially feasible.\n");
+  }
+
+  // add artificial column
+  SPxColId id;
+  _tauColVector *= -1;
+  _rationalLP->addCol(id,
+                      LPColRational((intParam(SoPlexBase<R>::OBJSENSE) ==
+                                             SoPlexBase<R>::OBJSENSE_MAXIMIZE
+                                         ? _rationalPosone
+                                         : _rationalNegone),
+                                    _tauColVector, 1, 0));
+  _realLP->addCol(id, LPColBase<R>((intParam(SoPlexBase<R>::OBJSENSE) ==
+                                            SoPlexBase<R>::OBJSENSE_MAXIMIZE
+                                        ? 1.0
+                                        : -1.0),
+                                   DSVectorBase<R>(_tauColVector), 1.0, 0.0));
+  _colTypes.append(RANGETYPE_BOXED);
+
+  // adjust basis
+  if (_hasBasis) {
+    _basisStatusCols.append(SPxSolverBase<R>::ON_UPPER);
+  }
+
+  // invalidate rational basis factorization
+  _rationalLUSolver.clear();
+
+  // print LP if in debug mode
+  MSG_DEBUG(_realLP->writeFileLPBase("afterTransFeas.lp", 0, 0, 0));
+
+  // stop timing
+  _statistics->transformTime->stop();
+}
 
-   for(int c = numOrigCols - 1; c >= 0; c--)
-   {
-      bool shifted = (_lowerFinite(_colTypes[c]) && _feasLower[c] > 0) || (_upperFinite(_colTypes[c])
-                     && _feasUpper[c] < 0);
-      assert(shifted || !_lowerFinite(_colTypes[c]) || _feasLower[c] == lowerRational(c));
-      assert(shifted || !_upperFinite(_colTypes[c]) || _feasUpper[c] == upperRational(c));
-      assert(upperRational(c) >= _rationalPosInfty || lowerRational(c) <= _rationalNegInfty
-             || _feasLower[c] - lowerRational(c) == _feasUpper[c] - upperRational(c));
+/// undoes transformation to feasibility problem
+template <class R>
+void SoPlexBase<R>::_untransformFeasibility(SolRational &sol, bool infeasible) {
+  // start timing
+  _statistics->transformTime->start();
+
+  // print LP if in debug mode
+  MSG_DEBUG(_realLP->writeFileLPBase("beforeUntransFeas.lp", 0, 0, 0));
+
+  int numOrigCols = numColsRational() - 1;
+
+  // adjust solution and basis
+  if (infeasible) {
+    assert(sol._isDualFeasible);
+    assert(sol._primal[numOrigCols] < 1);
+
+    sol._isPrimalFeasible = false;
+    sol._hasPrimalRay = false;
+    sol._isDualFeasible = false;
+    sol._hasDualFarkas = true;
+
+    sol._dualFarkas = sol._dual;
+
+    _hasBasis = false;
+    _basisStatusCols.reSize(numOrigCols);
+  } else if (sol._isPrimalFeasible) {
+    assert(sol._primal[numOrigCols] >= 1);
+
+    sol._hasPrimalRay = false;
+    sol._isDualFeasible = false;
+    sol._hasDualFarkas = false;
+
+    if (sol._primal[numOrigCols] != 1) {
+      sol._slacks /= sol._primal[numOrigCols];
+
+      for (int i = 0; i < numOrigCols; i++)
+        sol._primal[i] /= sol._primal[numOrigCols];
+
+      sol._primal[numOrigCols] = 1;
+    }
+
+    sol._primal.reDim(numOrigCols);
+    sol._slacks -= _rationalLP->colVector(numOrigCols);
+
+    _hasBasis = (_basisStatusCols[numOrigCols] != SPxSolverBase<R>::BASIC);
+    _basisStatusCols.reSize(numOrigCols);
+  } else {
+    _hasBasis = false;
+    _basisStatusCols.reSize(numOrigCols);
+  }
+
+  // restore right-hand side
+  for (int r = numRowsRational() - 1; r >= 0; r--) {
+    assert(rhsRational(r) >= _rationalPosInfty ||
+           lhsRational(r) <= _rationalNegInfty ||
+           _feasLhs[r] - lhsRational(r) == _feasRhs[r] - rhsRational(r));
+
+    if (_lowerFinite(_rowTypes[r])) {
+      _rationalLP->changeLhs(r, _feasLhs[r]);
+      _realLP->changeLhs(r, R(_feasLhs[r]));
+    } else if (_realLP->lhs(r) > -realParam(SoPlexBase<R>::INFTY))
+      _realLP->changeLhs(r, -realParam(SoPlexBase<R>::INFTY));
+
+    assert(_lowerFinite(_rowTypes[r]) == (lhsRational(r) > _rationalNegInfty));
+    assert(_lowerFinite(_rowTypes[r]) ==
+           (lhsReal(r) > -realParam(SoPlexBase<R>::INFTY)));
+
+    if (_upperFinite(_rowTypes[r])) {
+      _rationalLP->changeRhs(r, _feasRhs[r]);
+      _realLP->changeRhs(r, R(_feasRhs[r]));
+    } else if (_realLP->rhs(r) < realParam(SoPlexBase<R>::INFTY))
+      _realLP->changeRhs(r, realParam(SoPlexBase<R>::INFTY));
+
+    assert(_upperFinite(_rowTypes[r]) == (rhsRational(r) < _rationalPosInfty));
+    assert(_upperFinite(_rowTypes[r]) ==
+           (rhsReal(r) < realParam(SoPlexBase<R>::INFTY)));
+
+    assert(lhsReal(r) <= rhsReal(r));
+  }
+
+  // unshift primal space and restore objective coefficients
+  Rational shiftValue;
+
+  for (int c = numOrigCols - 1; c >= 0; c--) {
+    bool shifted = (_lowerFinite(_colTypes[c]) && _feasLower[c] > 0) ||
+                   (_upperFinite(_colTypes[c]) && _feasUpper[c] < 0);
+    assert(shifted || !_lowerFinite(_colTypes[c]) ||
+           _feasLower[c] == lowerRational(c));
+    assert(shifted || !_upperFinite(_colTypes[c]) ||
+           _feasUpper[c] == upperRational(c));
+    assert(upperRational(c) >= _rationalPosInfty ||
+           lowerRational(c) <= _rationalNegInfty ||
+           _feasLower[c] - lowerRational(c) ==
+               _feasUpper[c] - upperRational(c));
+
+    if (shifted) {
+      if (_lowerFinite(_colTypes[c])) {
+        shiftValue = _feasLower[c];
+        shiftValue -= lowerRational(c);
+      } else if (_upperFinite(_colTypes[c])) {
+        shiftValue = _feasUpper[c];
+        shiftValue -= upperRational(c);
+      }
 
-      if(shifted)
-      {
-         if(_lowerFinite(_colTypes[c]))
-         {
-            shiftValue = _feasLower[c];
-            shiftValue -= lowerRational(c);
-         }
-         else if(_upperFinite(_colTypes[c]))
-         {
-            shiftValue = _feasUpper[c];
-            shiftValue -= upperRational(c);
-         }
-
-         if(sol._isPrimalFeasible)
-         {
-            sol._primal[c] += shiftValue;
-            sol._slacks.multAdd(shiftValue, _rationalLP->colVector(c));
-         }
+      if (sol._isPrimalFeasible) {
+        sol._primal[c] += shiftValue;
+        sol._slacks.multAdd(shiftValue, _rationalLP->colVector(c));
       }
+    }
 
-      if(_lowerFinite(_colTypes[c]))
-      {
-         if(shifted)
-            _rationalLP->changeLower(c, _feasLower[c]);
+    if (_lowerFinite(_colTypes[c])) {
+      if (shifted)
+        _rationalLP->changeLower(c, _feasLower[c]);
 
-         _realLP->changeLower(c, R(_feasLower[c]));
-      }
-      else if(_realLP->lower(c) > -realParam(SoPlexBase<R>::INFTY))
-         _realLP->changeLower(c, -realParam(SoPlexBase<R>::INFTY));
+      _realLP->changeLower(c, R(_feasLower[c]));
+    } else if (_realLP->lower(c) > -realParam(SoPlexBase<R>::INFTY))
+      _realLP->changeLower(c, -realParam(SoPlexBase<R>::INFTY));
 
-      assert(_lowerFinite(_colTypes[c]) == (lowerRational(c) > -_rationalPosInfty));
-      assert(_lowerFinite(_colTypes[c]) == (lowerReal(c) > -realParam(SoPlexBase<R>::INFTY)));
+    assert(_lowerFinite(_colTypes[c]) ==
+           (lowerRational(c) > -_rationalPosInfty));
+    assert(_lowerFinite(_colTypes[c]) ==
+           (lowerReal(c) > -realParam(SoPlexBase<R>::INFTY)));
 
-      if(_upperFinite(_colTypes[c]))
-      {
-         if(shifted)
-            _rationalLP->changeUpper(c, _feasUpper[c]);
+    if (_upperFinite(_colTypes[c])) {
+      if (shifted)
+        _rationalLP->changeUpper(c, _feasUpper[c]);
 
-         _realLP->changeUpper(c, R(upperRational(c)));
-      }
-      else if(_realLP->upper(c) < realParam(SoPlexBase<R>::INFTY))
-         _realLP->changeUpper(c, realParam(SoPlexBase<R>::INFTY));
+      _realLP->changeUpper(c, R(upperRational(c)));
+    } else if (_realLP->upper(c) < realParam(SoPlexBase<R>::INFTY))
+      _realLP->changeUpper(c, realParam(SoPlexBase<R>::INFTY));
 
-      assert(_upperFinite(_colTypes[c]) == (upperRational(c) < _rationalPosInfty));
-      assert(_upperFinite(_colTypes[c]) == (upperReal(c) < realParam(SoPlexBase<R>::INFTY)));
+    assert(_upperFinite(_colTypes[c]) ==
+           (upperRational(c) < _rationalPosInfty));
+    assert(_upperFinite(_colTypes[c]) ==
+           (upperReal(c) < realParam(SoPlexBase<R>::INFTY)));
 
-      _rationalLP->changeMaxObj(c, _feasObj[c]);
-      _realLP->changeMaxObj(c, R(_feasObj[c]));
+    _rationalLP->changeMaxObj(c, _feasObj[c]);
+    _realLP->changeMaxObj(c, R(_feasObj[c]));
 
-      assert(lowerReal(c) <= upperReal(c));
-   }
+    assert(lowerReal(c) <= upperReal(c));
+  }
 
-   // remove last column
-   _rationalLP->removeCol(numOrigCols);
-   _realLP->removeCol(numOrigCols);
-   _colTypes.reSize(numOrigCols);
+  // remove last column
+  _rationalLP->removeCol(numOrigCols);
+  _realLP->removeCol(numOrigCols);
+  _colTypes.reSize(numOrigCols);
 
-   // invalidate rational basis factorization
-   _rationalLUSolver.clear();
+  // invalidate rational basis factorization
+  _rationalLUSolver.clear();
 
-   // print LP if in debug mode
-   MSG_DEBUG(_realLP->writeFileLPBase("afterUntransFeas.lp", 0, 0, 0));
+  // print LP if in debug mode
+  MSG_DEBUG(_realLP->writeFileLPBase("afterUntransFeas.lp", 0, 0, 0));
 
-   // stop timing
-   _statistics->transformTime->stop();
+  // stop timing
+  _statistics->transformTime->stop();
 
 #ifndef NDEBUG
 
-   if(sol._isPrimalFeasible)
-   {
-      VectorRational activity(numRowsRational());
-      _rationalLP->computePrimalActivity(sol._primal, activity);
-      assert(sol._slacks == activity);
-   }
+  if (sol._isPrimalFeasible) {
+    VectorRational activity(numRowsRational());
+    _rationalLP->computePrimalActivity(sol._primal, activity);
+    assert(sol._slacks == activity);
+  }
 
 #endif
 }
 
 /** computes radius of infeasibility box implied by an approximate Farkas' proof
 
- Given constraints of the form \f$ lhs <= Ax <= rhs \f$, a farkas proof y should satisfy \f$ y^T A = 0 \f$ and
- \f$ y_+^T lhs - y_-^T rhs > 0 \f$, where \f$ y_+, y_- \f$ denote the positive and negative parts of \f$ y \f$.
- If \f$ y \f$ is approximate, it may not satisfy \f$ y^T A = 0 \f$ exactly, but the proof is still valid as long
- as the following holds for all potentially feasible \f$ x \f$:
+ Given constraints of the form \f$ lhs <= Ax <= rhs \f$, a farkas proof y should
+ satisfy \f$ y^T A = 0 \f$ and \f$ y_+^T lhs - y_-^T rhs > 0 \f$, where \f$ y_+,
+ y_- \f$ denote the positive and negative parts of \f$ y \f$. If \f$ y \f$ is
+ approximate, it may not satisfy \f$ y^T A = 0 \f$ exactly, but the proof is
+ still valid as long as the following holds for all potentially feasible \f$ x
+ \f$:
 
  \f[
     y^T Ax < (y_+^T lhs - y_-^T rhs)              (*)
  \f]
 
- we may therefore calculate \f$ y^T A \f$ and \f$ y_+^T lhs - y_-^T rhs \f$ exactly and check if the upper and lower
- bounds on \f$ x \f$ imply that all feasible \f$ x \f$ satisfy (*), and if not then compute bounds on \f$ x \f$ to
+ we may therefore calculate \f$ y^T A \f$ and \f$ y_+^T lhs - y_-^T rhs \f$
+ exactly and check if the upper and lower bounds on \f$ x \f$ imply that all
+ feasible \f$ x \f$ satisfy (*), and if not then compute bounds on \f$ x \f$ to
  guarantee (*).  The simplest way to do this is to compute
 
  \f[
     B = (y_+^T lhs - y_-^T rhs) / \sum_i(|(y^T A)_i|)
  \f]
 
- noting that if every component of \f$ x \f$ has \f$ |x_i| < B \f$, then (*) holds.
+ noting that if every component of \f$ x \f$ has \f$ |x_i| < B \f$, then (*)
+ holds.
 
- \f$ B \f$ can be increased by iteratively including variable bounds smaller than \f$ B \f$.  The speed of this
- method can be further improved by using interval arithmetic for all computations.  For related information see
- Sec. 4 of Neumaier and Shcherbina, Mathematical Programming A, 2004.
+ \f$ B \f$ can be increased by iteratively including variable bounds smaller
+ than \f$ B \f$.  The speed of this method can be further improved by using
+ interval arithmetic for all computations.  For related information see Sec. 4
+ of Neumaier and Shcherbina, Mathematical Programming A, 2004.
 
  Set transformed to true if this method is called after _transformFeasibility().
 */
 template <class R>
-void SoPlexBase<R>::_computeInfeasBox(SolRational& sol, bool transformed)
-{
-   assert(sol.hasDualFarkas());
-
-   const VectorRational& lower = transformed ? _feasLower : lowerRational();
-   const VectorRational& upper = transformed ? _feasUpper : upperRational();
-   const VectorRational& lhs = transformed ? _feasLhs : lhsRational();
-   const VectorRational& rhs = transformed ? _feasRhs : rhsRational();
-   const VectorRational& y = sol._dualFarkas;
-
-   const int numRows = numRowsRational();
-   const int numCols = transformed ? numColsRational() - 1 : numColsRational();
-
-   SSVectorRational ytransA(numColsRational());
-   Rational ytransb;
-   Rational temp;
-
-   // prepare ytransA and ytransb; since we want exact arithmetic, we set the zero threshold of the semi-sparse
-   // vector to zero
-   ytransA.setEpsilon(0);
-   ytransA.clear();
-   ytransb = 0;
-
-   ///@todo this currently works only if all constraints are equations aggregate rows and sides using the multipliers of the Farkas ray
-   for(int r = 0; r < numRows; r++)
-   {
-      ytransA += y[r] * _rationalLP->rowVector(r);
-      ytransb += y[r] * (y[r] > 0 ? lhs[r] : rhs[r]);
-   }
-
-   // if we work on the feasibility problem, we ignore the last column
-   if(transformed)
-      ytransA.reDim(numCols);
-
-   MSG_DEBUG(std::cout << "ytransb = " << ytransb.str() << "\n");
-
-   // if we choose minus ytransb as vector of multipliers for the bound constraints on the variables, we obtain an
-   // exactly feasible dual solution for the LP with zero objective function; we aggregate the bounds of the
-   // variables accordingly and store its negation in temp
-   temp = 0;
-   bool isTempFinite = true;
-
-   for(int c = 0; c < numCols && isTempFinite; c++)
-   {
-      const Rational& minusRedCost = ytransA[c];
-
-      if(minusRedCost > 0)
-      {
-         assert((upper[c] < _rationalPosInfty) == _upperFinite(_colTypes[c]));
-
-         if(_upperFinite(_colTypes[c]))
-            temp += minusRedCost * upper[c];
-         else
-            isTempFinite = false;
-      }
-      else if(minusRedCost < 0)
-      {
-         assert((lower[c] > _rationalNegInfty) == _lowerFinite(_colTypes[c]));
+void SoPlexBase<R>::_computeInfeasBox(SolRational &sol, bool transformed) {
+  assert(sol.hasDualFarkas());
+
+  const VectorRational &lower = transformed ? _feasLower : lowerRational();
+  const VectorRational &upper = transformed ? _feasUpper : upperRational();
+  const VectorRational &lhs = transformed ? _feasLhs : lhsRational();
+  const VectorRational &rhs = transformed ? _feasRhs : rhsRational();
+  const VectorRational &y = sol._dualFarkas;
+
+  const int numRows = numRowsRational();
+  const int numCols = transformed ? numColsRational() - 1 : numColsRational();
+
+  SSVectorRational ytransA(numColsRational());
+  Rational ytransb;
+  Rational temp;
+
+  // prepare ytransA and ytransb; since we want exact arithmetic, we set the
+  // zero threshold of the semi-sparse vector to zero
+  ytransA.setEpsilon(0);
+  ytransA.clear();
+  ytransb = 0;
+
+  ///@todo this currently works only if all constraints are equations aggregate
+  ///rows and sides using the multipliers of the Farkas ray
+  for (int r = 0; r < numRows; r++) {
+    ytransA += y[r] * _rationalLP->rowVector(r);
+    ytransb += y[r] * (y[r] > 0 ? lhs[r] : rhs[r]);
+  }
+
+  // if we work on the feasibility problem, we ignore the last column
+  if (transformed)
+    ytransA.reDim(numCols);
+
+  MSG_DEBUG(std::cout << "ytransb = " << ytransb.str() << "\n");
+
+  // if we choose minus ytransb as vector of multipliers for the bound
+  // constraints on the variables, we obtain an exactly feasible dual solution
+  // for the LP with zero objective function; we aggregate the bounds of the
+  // variables accordingly and store its negation in temp
+  temp = 0;
+  bool isTempFinite = true;
+
+  for (int c = 0; c < numCols && isTempFinite; c++) {
+    const Rational &minusRedCost = ytransA[c];
+
+    if (minusRedCost > 0) {
+      assert((upper[c] < _rationalPosInfty) == _upperFinite(_colTypes[c]));
+
+      if (_upperFinite(_colTypes[c]))
+        temp += minusRedCost * upper[c];
+      else
+        isTempFinite = false;
+    } else if (minusRedCost < 0) {
+      assert((lower[c] > _rationalNegInfty) == _lowerFinite(_colTypes[c]));
 
-         if(_lowerFinite(_colTypes[c]))
-            temp += minusRedCost * lower[c];
-         else
-            isTempFinite = false;
+      if (_lowerFinite(_colTypes[c]))
+        temp += minusRedCost * lower[c];
+      else
+        isTempFinite = false;
+    }
+  }
+
+  MSG_DEBUG(std::cout << "max ytransA*[x_l,x_u] = "
+                      << (isTempFinite ? temp.str() : "infinite") << "\n");
+
+  // ytransb - temp is the increase in the dual objective along the Farkas ray;
+  // if this is positive, the dual is unbounded and certifies primal
+  // infeasibility
+  if (isTempFinite && temp < ytransb) {
+    MSG_INFO1(spxout,
+              spxout << "Farkas infeasibility proof verified exactly. (1)\n");
+    return;
+  }
+
+  // ensure that array of nonzero elements in ytransA is available
+  assert(ytransA.isSetup());
+  ytransA.setup();
+
+  // if ytransb is negative, try to make it zero by including a positive lower
+  // bound or a negative upper bound
+  if (ytransb < 0) {
+    for (int c = 0; c < numCols; c++) {
+      if (lower[c] > 0) {
+        ytransA.setValue(c, ytransA[c] - ytransb / lower[c]);
+        ytransb = 0;
+        break;
+      } else if (upper[c] < 0) {
+        ytransA.setValue(c, ytransA[c] - ytransb / upper[c]);
+        ytransb = 0;
+        break;
       }
-   }
-
-   MSG_DEBUG(std::cout << "max ytransA*[x_l,x_u] = " << (isTempFinite ? temp.str() : "infinite") <<
-             "\n");
-
-   // ytransb - temp is the increase in the dual objective along the Farkas ray; if this is positive, the dual is
-   // unbounded and certifies primal infeasibility
-   if(isTempFinite && temp < ytransb)
-   {
-      MSG_INFO1(spxout, spxout << "Farkas infeasibility proof verified exactly. (1)\n");
-      return;
-   }
-
-   // ensure that array of nonzero elements in ytransA is available
-   assert(ytransA.isSetup());
-   ytransA.setup();
-
-   // if ytransb is negative, try to make it zero by including a positive lower bound or a negative upper bound
-   if(ytransb < 0)
-   {
-      for(int c = 0; c < numCols; c++)
-      {
-         if(lower[c] > 0)
-         {
-            ytransA.setValue(c, ytransA[c] - ytransb / lower[c]);
-            ytransb = 0;
-            break;
-         }
-         else if(upper[c] < 0)
-         {
-            ytransA.setValue(c, ytransA[c] - ytransb / upper[c]);
-            ytransb = 0;
-            break;
-         }
+    }
+  }
+
+  // if ytransb is still zero then the zero solution is inside the bounds and
+  // cannot be cut off by the Farkas constraint; in this case, we cannot compute
+  // a Farkas box
+  if (ytransb < 0) {
+    MSG_INFO1(spxout, spxout << "Approximate Farkas proof to weak.  Could not "
+                                "compute Farkas box. (1)\n");
+    return;
+  }
+
+  // compute the one norm of ytransA
+  temp = 0;
+  const int size = ytransA.size();
+
+  for (int n = 0; n < size; n++)
+    temp += spxAbs(ytransA.value(n));
+
+  // if the one norm is zero then ytransA is zero the Farkas proof should have
+  // been verified above
+  assert(temp != 0);
+
+  // initialize variables in loop: size of Farkas box B, flag whether B has been
+  // increased, and number of current nonzero in ytransA
+  Rational B = ytransb / temp;
+  bool success = false;
+  int n = 0;
+
+  // loop through nonzeros of ytransA
+  MSG_DEBUG(std::cout << "B = " << B.str() << "\n");
+  assert(ytransb >= 0);
+
+  while (true) {
+    // if all nonzeros have been inspected once without increasing B, we abort;
+    // otherwise, we start another round
+    if (n >= ytransA.size()) {
+      if (!success)
+        break;
+
+      success = false;
+      n = 0;
+    }
+
+    // get Farkas multiplier of the bound constraint as minus the value in
+    // ytransA
+    const Rational &minusRedCost = ytransA.value(n);
+    int colIdx = ytransA.index(n);
+
+    // if the multiplier is positive we inspect the lower bound: if it is finite
+    // and within the Farkas box, we can increase B by including it in the
+    // Farkas proof
+    assert((upper[colIdx] < _rationalPosInfty) ==
+           _upperFinite(_colTypes[colIdx]));
+    assert((lower[colIdx] > _rationalNegInfty) ==
+           _lowerFinite(_colTypes[colIdx]));
+
+    if (minusRedCost < 0 && lower[colIdx] > -B &&
+        _lowerFinite(_colTypes[colIdx])) {
+      ytransA.clearNum(n);
+      ytransb -= minusRedCost * lower[colIdx];
+      temp += minusRedCost;
+
+      assert(ytransb >= 0);
+      assert(temp >= 0);
+      assert(temp == 0 || ytransb / temp > B);
+
+      // if ytransA and ytransb are zero, we have 0^T x >= 0 and cannot compute
+      // a Farkas box
+      if (temp == 0 && ytransb == 0) {
+        MSG_INFO1(spxout, spxout << "Approximate Farkas proof to weak.  Could "
+                                    "not compute Farkas box. (2)\n");
+        return;
       }
-   }
-
-   // if ytransb is still zero then the zero solution is inside the bounds and cannot be cut off by the Farkas
-   // constraint; in this case, we cannot compute a Farkas box
-   if(ytransb < 0)
-   {
-      MSG_INFO1(spxout, spxout <<
-                "Approximate Farkas proof to weak.  Could not compute Farkas box. (1)\n");
-      return;
-   }
-
-   // compute the one norm of ytransA
-   temp = 0;
-   const int size = ytransA.size();
-
-   for(int n = 0; n < size; n++)
-      temp += spxAbs(ytransA.value(n));
-
-   // if the one norm is zero then ytransA is zero the Farkas proof should have been verified above
-   assert(temp != 0);
-
-   // initialize variables in loop: size of Farkas box B, flag whether B has been increased, and number of current
-   // nonzero in ytransA
-   Rational B = ytransb / temp;
-   bool success = false;
-   int n = 0;
-
-   // loop through nonzeros of ytransA
-   MSG_DEBUG(std::cout << "B = " << B.str() << "\n");
-   assert(ytransb >= 0);
-
-   while(true)
-   {
-      // if all nonzeros have been inspected once without increasing B, we abort; otherwise, we start another round
-      if(n >= ytransA.size())
-      {
-         if(!success)
-            break;
-
-         success = false;
-         n = 0;
+      // if ytransb is positive and ytransA is zero, we have 0^T x > 0, proving
+      // infeasibility
+      else if (temp == 0) {
+        assert(ytransb > 0);
+        MSG_INFO1(
+            spxout,
+            spxout << "Farkas infeasibility proof verified exactly. (2)\n");
+        return;
+      } else {
+        B = ytransb / temp;
+        MSG_DEBUG(std::cout << "B = " << B.str() << "\n");
       }
 
-      // get Farkas multiplier of the bound constraint as minus the value in ytransA
-      const Rational& minusRedCost = ytransA.value(n);
-      int colIdx = ytransA.index(n);
-
-      // if the multiplier is positive we inspect the lower bound: if it is finite and within the Farkas box, we can
-      // increase B by including it in the Farkas proof
-      assert((upper[colIdx] < _rationalPosInfty) == _upperFinite(_colTypes[colIdx]));
-      assert((lower[colIdx] > _rationalNegInfty) == _lowerFinite(_colTypes[colIdx]));
-
-      if(minusRedCost < 0 && lower[colIdx] > -B && _lowerFinite(_colTypes[colIdx]))
-      {
-         ytransA.clearNum(n);
-         ytransb -= minusRedCost * lower[colIdx];
-         temp += minusRedCost;
-
-         assert(ytransb >= 0);
-         assert(temp >= 0);
-         assert(temp == 0 || ytransb / temp > B);
-
-         // if ytransA and ytransb are zero, we have 0^T x >= 0 and cannot compute a Farkas box
-         if(temp == 0 && ytransb == 0)
-         {
-            MSG_INFO1(spxout, spxout <<
-                      "Approximate Farkas proof to weak.  Could not compute Farkas box. (2)\n");
-            return;
-         }
-         // if ytransb is positive and ytransA is zero, we have 0^T x > 0, proving infeasibility
-         else if(temp == 0)
-         {
-            assert(ytransb > 0);
-            MSG_INFO1(spxout, spxout << "Farkas infeasibility proof verified exactly. (2)\n");
-            return;
-         }
-         else
-         {
-            B = ytransb / temp;
-            MSG_DEBUG(std::cout << "B = " << B.str() << "\n");
-         }
-
-         success = true;
+      success = true;
+    }
+    // if the multiplier is negative we inspect the upper bound: if it is finite
+    // and within the Farkas box, we can increase B by including it in the
+    // Farkas proof
+    else if (minusRedCost > 0 && upper[colIdx] < B &&
+             _upperFinite(_colTypes[colIdx])) {
+      ytransA.clearNum(n);
+      ytransb -= minusRedCost * upper[colIdx];
+      temp -= minusRedCost;
+
+      assert(ytransb >= 0);
+      assert(temp >= 0);
+      assert(temp == 0 || ytransb / temp > B);
+
+      // if ytransA and ytransb are zero, we have 0^T x >= 0 and cannot compute
+      // a Farkas box
+      if (temp == 0 && ytransb == 0) {
+        MSG_INFO1(spxout, spxout << "Approximate Farkas proof to weak.  Could "
+                                    "not compute Farkas box. (2)\n");
+        return;
       }
-      // if the multiplier is negative we inspect the upper bound: if it is finite and within the Farkas box, we can
-      // increase B by including it in the Farkas proof
-      else if(minusRedCost > 0 && upper[colIdx] < B && _upperFinite(_colTypes[colIdx]))
-      {
-         ytransA.clearNum(n);
-         ytransb -= minusRedCost * upper[colIdx];
-         temp -= minusRedCost;
-
-         assert(ytransb >= 0);
-         assert(temp >= 0);
-         assert(temp == 0 || ytransb / temp > B);
-
-         // if ytransA and ytransb are zero, we have 0^T x >= 0 and cannot compute a Farkas box
-         if(temp == 0 && ytransb == 0)
-         {
-            MSG_INFO1(spxout, spxout <<
-                      "Approximate Farkas proof to weak.  Could not compute Farkas box. (2)\n");
-            return;
-         }
-         // if ytransb is positive and ytransA is zero, we have 0^T x > 0, proving infeasibility
-         else if(temp == 0)
-         {
-            assert(ytransb > 0);
-            MSG_INFO1(spxout, spxout << "Farkas infeasibility proof verified exactly. (2)\n");
-            return;
-         }
-         else
-         {
-            B = ytransb / temp;
-            MSG_DEBUG(std::cout << "B = " << B.str() << "\n");
-         }
-
-         success = true;
+      // if ytransb is positive and ytransA is zero, we have 0^T x > 0, proving
+      // infeasibility
+      else if (temp == 0) {
+        assert(ytransb > 0);
+        MSG_INFO1(
+            spxout,
+            spxout << "Farkas infeasibility proof verified exactly. (2)\n");
+        return;
+      } else {
+        B = ytransb / temp;
+        MSG_DEBUG(std::cout << "B = " << B.str() << "\n");
       }
-      // the multiplier is zero, we can ignore the bound constraints on this variable
-      else if(minusRedCost == 0)
-         ytransA.clearNum(n);
-      // currently this bound cannot be used to increase B; we will check it again in the next round, because B might
-      // have increased by then
-      else
-         n++;
-   }
-
-   if(B > 0)
-   {
-      MSG_INFO1(spxout, spxout <<
-                "Computed Farkas box: provably no feasible solutions with components less than "
-                << B.str() << " in absolute value.\n");
-   }
-}
-
-
 
+      success = true;
+    }
+    // the multiplier is zero, we can ignore the bound constraints on this
+    // variable
+    else if (minusRedCost == 0)
+      ytransA.clearNum(n);
+    // currently this bound cannot be used to increase B; we will check it again
+    // in the next round, because B might have increased by then
+    else
+      n++;
+  }
+
+  if (B > 0) {
+    MSG_INFO1(spxout, spxout << "Computed Farkas box: provably no feasible "
+                                "solutions with components less than "
+                             << B.str() << " in absolute value.\n");
+  }
+}
 
 // General specializations
 /// solves real LP during iterative refinement
 template <class R>
-typename SPxSolverBase<R>::Status SoPlexBase<R>::_solveRealForRational(bool fromscratch,
-      VectorBase<R>& primal, VectorBase<R>& dual,
-      DataArray< typename SPxSolverBase<R>::VarStatus >& basisStatusRows,
-      DataArray< typename SPxSolverBase<R>::VarStatus >& basisStatusCols)
-{
-   assert(_isConsistent());
+typename SPxSolverBase<R>::Status SoPlexBase<R>::_solveRealForRational(
+    bool fromscratch, VectorBase<R> &primal, VectorBase<R> &dual,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &basisStatusRows,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &basisStatusCols) {
+  assert(_isConsistent());
 
-   assert(_solver.nRows() == numRowsRational());
-   assert(_solver.nCols() == numColsRational());
-   assert(primal.dim() == numColsRational());
-   assert(dual.dim() == numRowsRational());
+  assert(_solver.nRows() == numRowsRational());
+  assert(_solver.nCols() == numColsRational());
+  assert(primal.dim() == numColsRational());
+  assert(dual.dim() == numRowsRational());
 
-   typename SPxSolverBase<R>::Status result = SPxSolverBase<R>::UNKNOWN;
+  typename SPxSolverBase<R>::Status result = SPxSolverBase<R>::UNKNOWN;
 
 #ifndef SOPLEX_MANUAL_ALT
 
-   if(fromscratch || !_hasBasis)
-      _enableSimplifierAndScaler();
-   else
-      _disableSimplifierAndScaler();
+  if (fromscratch || !_hasBasis)
+    _enableSimplifierAndScaler();
+  else
+    _disableSimplifierAndScaler();
 
 #else
-   _disableSimplifierAndScaler();
+  _disableSimplifierAndScaler();
 #endif
 
-   // reset basis to slack basis when solving from scratch
-   if(fromscratch)
-      _solver.reLoad();
-
-   // start timing
-   _statistics->syncTime->start();
-
-   // if preprocessing is applied, we need to restore the original LP at the end
-   SPxLPRational* rationalLP = 0;
-
-   if(_simplifier != 0 || _scaler != nullptr)
-   {
-      spx_alloc(rationalLP);
-      rationalLP = new(rationalLP) SPxLPRational(_solver);
-   }
-
-   // with preprocessing or solving from scratch, the basis may change, hence invalidate the
-   // rational basis factorization
-   if(_simplifier != nullptr || _scaler != nullptr || fromscratch)
-      _rationalLUSolver.clear();
-
-   // stop timing
-   _statistics->syncTime->stop();
-
-   try
-   {
-      // apply problem simplification
-      typename SPxSimplifier<R>::Result simplificationStatus = SPxSimplifier<R>::OKAY;
-
-      if(_simplifier != 0)
-      {
-         // do not remove bounds of boxed variables or sides of ranged rows if bound flipping is used
-         bool keepbounds = intParam(SoPlexBase<R>::RATIOTESTER) == SoPlexBase<R>::RATIOTESTER_BOUNDFLIPPING;
-         Real remainingTime = _solver.getMaxTime() - _solver.time();
-         simplificationStatus = _simplifier->simplify(_solver, realParam(SoPlexBase<R>::EPSILON_ZERO),
-                                realParam(SoPlexBase<R>::FPFEASTOL), realParam(SoPlexBase<R>::FPOPTTOL), remainingTime, keepbounds,
-                                _solver.random.getSeed());
-      }
-
-      // apply scaling after the simplification
-      if(_scaler != nullptr && simplificationStatus == SPxSimplifier<R>::OKAY)
-         _scaler->scale(_solver, false);
-
-      // run the simplex method if problem has not been solved by the simplifier
-      if(simplificationStatus == SPxSimplifier<R>::OKAY)
-      {
-         MSG_INFO1(spxout, spxout << std::endl);
-
-         _solveRealLPAndRecordStatistics();
-
-         MSG_INFO1(spxout, spxout << std::endl);
-      }
+  // reset basis to slack basis when solving from scratch
+  if (fromscratch)
+    _solver.reLoad();
+
+  // start timing
+  _statistics->syncTime->start();
+
+  // if preprocessing is applied, we need to restore the original LP at the end
+  SPxLPRational *rationalLP = 0;
+
+  if (_simplifier != 0 || _scaler != nullptr) {
+    spx_alloc(rationalLP);
+    rationalLP = new (rationalLP) SPxLPRational(_solver);
+  }
+
+  // with preprocessing or solving from scratch, the basis may change, hence
+  // invalidate the rational basis factorization
+  if (_simplifier != nullptr || _scaler != nullptr || fromscratch)
+    _rationalLUSolver.clear();
+
+  // stop timing
+  _statistics->syncTime->stop();
+
+  try {
+    // apply problem simplification
+    typename SPxSimplifier<R>::Result simplificationStatus =
+        SPxSimplifier<R>::OKAY;
+
+    if (_simplifier != 0) {
+      // do not remove bounds of boxed variables or sides of ranged rows if
+      // bound flipping is used
+      bool keepbounds = intParam(SoPlexBase<R>::RATIOTESTER) ==
+                        SoPlexBase<R>::RATIOTESTER_BOUNDFLIPPING;
+      Real remainingTime = _solver.getMaxTime() - _solver.time();
+      simplificationStatus = _simplifier->simplify(
+          _solver, realParam(SoPlexBase<R>::EPSILON_ZERO),
+          realParam(SoPlexBase<R>::FPFEASTOL),
+          realParam(SoPlexBase<R>::FPOPTTOL), remainingTime, keepbounds,
+          _solver.random.getSeed());
+    }
+
+    // apply scaling after the simplification
+    if (_scaler != nullptr && simplificationStatus == SPxSimplifier<R>::OKAY)
+      _scaler->scale(_solver, false);
+
+    // run the simplex method if problem has not been solved by the simplifier
+    if (simplificationStatus == SPxSimplifier<R>::OKAY) {
+      MSG_INFO1(spxout, spxout << std::endl);
+
+      _solveRealLPAndRecordStatistics();
+
+      MSG_INFO1(spxout, spxout << std::endl);
+    }
+
+    ///@todo move to private helper methods
+    // evaluate status flag
+    if (simplificationStatus == SPxSimplifier<R>::INFEASIBLE)
+      result = SPxSolverBase<R>::INFEASIBLE;
+    else if (simplificationStatus == SPxSimplifier<R>::DUAL_INFEASIBLE)
+      result = SPxSolverBase<R>::INForUNBD;
+    else if (simplificationStatus == SPxSimplifier<R>::UNBOUNDED)
+      result = SPxSolverBase<R>::UNBOUNDED;
+    else if (simplificationStatus == SPxSimplifier<R>::VANISHED ||
+             simplificationStatus == SPxSimplifier<R>::OKAY) {
+      result = simplificationStatus == SPxSimplifier<R>::VANISHED
+                   ? SPxSolverBase<R>::OPTIMAL
+                   : _solver.status();
 
       ///@todo move to private helper methods
-      // evaluate status flag
-      if(simplificationStatus == SPxSimplifier<R>::INFEASIBLE)
-         result = SPxSolverBase<R>::INFEASIBLE;
-      else if(simplificationStatus == SPxSimplifier<R>::DUAL_INFEASIBLE)
-         result = SPxSolverBase<R>::INForUNBD;
-      else if(simplificationStatus == SPxSimplifier<R>::UNBOUNDED)
-         result = SPxSolverBase<R>::UNBOUNDED;
-      else if(simplificationStatus == SPxSimplifier<R>::VANISHED
-              || simplificationStatus == SPxSimplifier<R>::OKAY)
-      {
-         result = simplificationStatus == SPxSimplifier<R>::VANISHED ? SPxSolverBase<R>::OPTIMAL :
-                  _solver.status();
-
-         ///@todo move to private helper methods
-         // process result
-         switch(result)
-         {
-         case SPxSolverBase<R>::OPTIMAL:
-
-            // unsimplify if simplifier is active and LP is solved to optimality; this must be done here and not at solution
-            // query, because we want to have the basis for the original problem
-            if(_simplifier != 0)
-            {
-               assert(!_simplifier->isUnsimplified());
-               assert(simplificationStatus == SPxSimplifier<R>::VANISHED
-                      || simplificationStatus == SPxSimplifier<R>::OKAY);
-
-               bool vanished = simplificationStatus == SPxSimplifier<R>::VANISHED;
-
-               // get solution vectors for transformed problem
-               VectorBase<R> tmpPrimal(vanished ? 0 : _solver.nCols());
-               VectorBase<R> tmpSlacks(vanished ? 0 : _solver.nRows());
-               VectorBase<R> tmpDual(vanished ? 0 : _solver.nRows());
-               VectorBase<R> tmpRedCost(vanished ? 0 : _solver.nCols());
-
-               if(!vanished)
-               {
-                  assert(_solver.status() == SPxSolverBase<R>::OPTIMAL);
-
-                  _solver.getPrimalSol(tmpPrimal);
-                  _solver.getSlacks(tmpSlacks);
-                  _solver.getDualSol(tmpDual);
-                  _solver.getRedCostSol(tmpRedCost);
-
-                  // unscale vectors
-                  if(_scaler != nullptr)
-                  {
-                     _scaler->unscalePrimal(_solver, tmpPrimal);
-                     _scaler->unscaleSlacks(_solver, tmpSlacks);
-                     _scaler->unscaleDual(_solver, tmpDual);
-                     _scaler->unscaleRedCost(_solver, tmpRedCost);
-                  }
-
-                  // get basis of transformed problem
-                  basisStatusRows.reSize(_solver.nRows());
-                  basisStatusCols.reSize(_solver.nCols());
-                  _solver.getBasis(basisStatusRows.get_ptr(), basisStatusCols.get_ptr(), basisStatusRows.size(),
-                                   basisStatusCols.size());
-               }
-
-               ///@todo catch exception
-               _simplifier->unsimplify(tmpPrimal, tmpDual, tmpSlacks, tmpRedCost, basisStatusRows.get_ptr(),
-                                       basisStatusCols.get_ptr());
-
-               // store basis for original problem
-               basisStatusRows.reSize(numRowsRational());
-               basisStatusCols.reSize(numColsRational());
-               _simplifier->getBasis(basisStatusRows.get_ptr(), basisStatusCols.get_ptr(), basisStatusRows.size(),
-                                     basisStatusCols.size());
-               _hasBasis = true;
-
-               primal = _simplifier->unsimplifiedPrimal();
-               dual = _simplifier->unsimplifiedDual();
-            }
-            else
-            {
-               _solver.getPrimalSol(primal);
-               _solver.getDualSol(dual);
-
-               // unscale vectors
-               if(_scaler != nullptr)
-               {
-                  _scaler->unscalePrimal(_solver, primal);
-                  _scaler->unscaleDual(_solver, dual);
-               }
-
-               // get basis of transformed problem
-               basisStatusRows.reSize(_solver.nRows());
-               basisStatusCols.reSize(_solver.nCols());
-               _solver.getBasis(basisStatusRows.get_ptr(), basisStatusCols.get_ptr(), basisStatusRows.size(),
-                                basisStatusCols.size());
-               _hasBasis = true;
-            }
-
-            break;
-
-         case SPxSolverBase<R>::ABORT_CYCLING:
-            if(_simplifier == 0 && boolParam(SoPlexBase<R>::ACCEPTCYCLING))
-            {
-               _solver.getPrimalSol(primal);
-               _solver.getDualSol(dual);
-
-               // unscale vectors
-               if(_scaler != nullptr)
-               {
-                  _scaler->unscalePrimal(_solver, primal);
-                  _scaler->unscaleDual(_solver, dual);
-               }
-            }
+      // process result
+      switch (result) {
+      case SPxSolverBase<R>::OPTIMAL:
 
-         // intentional fallthrough
-         case SPxSolverBase<R>::ABORT_TIME:
-         case SPxSolverBase<R>::ABORT_ITER:
-         case SPxSolverBase<R>::ABORT_VALUE:
-         case SPxSolverBase<R>::REGULAR:
-         case SPxSolverBase<R>::RUNNING:
-         case SPxSolverBase<R>::UNBOUNDED:
-            _hasBasis = (_solver.basis().status() > SPxBasisBase<R>::NO_PROBLEM);
-
-            if(_hasBasis && _simplifier == 0)
-            {
-               basisStatusRows.reSize(_solver.nRows());
-               basisStatusCols.reSize(_solver.nCols());
-               _solver.getBasis(basisStatusRows.get_ptr(), basisStatusCols.get_ptr(), basisStatusRows.size(),
-                                basisStatusCols.size());
-            }
-            else
-            {
-               _hasBasis = false;
-               _rationalLUSolver.clear();
-            }
+        // unsimplify if simplifier is active and LP is solved to optimality;
+        // this must be done here and not at solution query, because we want to
+        // have the basis for the original problem
+        if (_simplifier != 0) {
+          assert(!_simplifier->isUnsimplified());
+          assert(simplificationStatus == SPxSimplifier<R>::VANISHED ||
+                 simplificationStatus == SPxSimplifier<R>::OKAY);
 
-            break;
+          bool vanished = simplificationStatus == SPxSimplifier<R>::VANISHED;
 
-         case SPxSolverBase<R>::INFEASIBLE:
+          // get solution vectors for transformed problem
+          VectorBase<R> tmpPrimal(vanished ? 0 : _solver.nCols());
+          VectorBase<R> tmpSlacks(vanished ? 0 : _solver.nRows());
+          VectorBase<R> tmpDual(vanished ? 0 : _solver.nRows());
+          VectorBase<R> tmpRedCost(vanished ? 0 : _solver.nCols());
 
-            // if simplifier is active we can currently not return a Farkas ray or basis
-            if(_simplifier != 0)
-            {
-               _hasBasis = false;
-               _rationalLUSolver.clear();
-               break;
-            }
+          if (!vanished) {
+            assert(_solver.status() == SPxSolverBase<R>::OPTIMAL);
 
-            // return Farkas ray as dual solution
-            _solver.getDualfarkas(dual);
+            _solver.getPrimalSol(tmpPrimal);
+            _solver.getSlacks(tmpSlacks);
+            _solver.getDualSol(tmpDual);
+            _solver.getRedCostSol(tmpRedCost);
 
             // unscale vectors
-            if(_scaler != nullptr)
-               _scaler->unscaleDual(_solver, dual);
+            if (_scaler != nullptr) {
+              _scaler->unscalePrimal(_solver, tmpPrimal);
+              _scaler->unscaleSlacks(_solver, tmpSlacks);
+              _scaler->unscaleDual(_solver, tmpDual);
+              _scaler->unscaleRedCost(_solver, tmpRedCost);
+            }
 
             // get basis of transformed problem
             basisStatusRows.reSize(_solver.nRows());
             basisStatusCols.reSize(_solver.nCols());
-            _solver.getBasis(basisStatusRows.get_ptr(), basisStatusCols.get_ptr(), basisStatusRows.size(),
+            _solver.getBasis(basisStatusRows.get_ptr(),
+                             basisStatusCols.get_ptr(), basisStatusRows.size(),
                              basisStatusCols.size());
-            _hasBasis = true;
-            break;
-
-         case SPxSolverBase<R>::INForUNBD:
-         case SPxSolverBase<R>::SINGULAR:
-         default:
-            _hasBasis = false;
-            _rationalLUSolver.clear();
-            break;
-         }
-      }
-   }
-   catch(...)
-   {
-      MSG_INFO1(spxout, spxout << "Exception thrown during floating-point solve.\n");
-      result = SPxSolverBase<R>::ERROR;
-      _hasBasis = false;
-      _rationalLUSolver.clear();
+          }
+
+          ///@todo catch exception
+          _simplifier->unsimplify(tmpPrimal, tmpDual, tmpSlacks, tmpRedCost,
+                                  basisStatusRows.get_ptr(),
+                                  basisStatusCols.get_ptr());
+
+          // store basis for original problem
+          basisStatusRows.reSize(numRowsRational());
+          basisStatusCols.reSize(numColsRational());
+          _simplifier->getBasis(basisStatusRows.get_ptr(),
+                                basisStatusCols.get_ptr(),
+                                basisStatusRows.size(), basisStatusCols.size());
+          _hasBasis = true;
+
+          primal = _simplifier->unsimplifiedPrimal();
+          dual = _simplifier->unsimplifiedDual();
+        } else {
+          _solver.getPrimalSol(primal);
+          _solver.getDualSol(dual);
+
+          // unscale vectors
+          if (_scaler != nullptr) {
+            _scaler->unscalePrimal(_solver, primal);
+            _scaler->unscaleDual(_solver, dual);
+          }
+
+          // get basis of transformed problem
+          basisStatusRows.reSize(_solver.nRows());
+          basisStatusCols.reSize(_solver.nCols());
+          _solver.getBasis(basisStatusRows.get_ptr(), basisStatusCols.get_ptr(),
+                           basisStatusRows.size(), basisStatusCols.size());
+          _hasBasis = true;
+        }
+
+        break;
+
+      case SPxSolverBase<R>::ABORT_CYCLING:
+        if (_simplifier == 0 && boolParam(SoPlexBase<R>::ACCEPTCYCLING)) {
+          _solver.getPrimalSol(primal);
+          _solver.getDualSol(dual);
+
+          // unscale vectors
+          if (_scaler != nullptr) {
+            _scaler->unscalePrimal(_solver, primal);
+            _scaler->unscaleDual(_solver, dual);
+          }
+        }
+
+      // intentional fallthrough
+      case SPxSolverBase<R>::ABORT_TIME:
+      case SPxSolverBase<R>::ABORT_ITER:
+      case SPxSolverBase<R>::ABORT_VALUE:
+      case SPxSolverBase<R>::REGULAR:
+      case SPxSolverBase<R>::RUNNING:
+      case SPxSolverBase<R>::UNBOUNDED:
+        _hasBasis = (_solver.basis().status() > SPxBasisBase<R>::NO_PROBLEM);
 
-   }
+        if (_hasBasis && _simplifier == 0) {
+          basisStatusRows.reSize(_solver.nRows());
+          basisStatusCols.reSize(_solver.nCols());
+          _solver.getBasis(basisStatusRows.get_ptr(), basisStatusCols.get_ptr(),
+                           basisStatusRows.size(), basisStatusCols.size());
+        } else {
+          _hasBasis = false;
+          _rationalLUSolver.clear();
+        }
 
-   // restore original LP if necessary
-   if(_simplifier != 0 || _scaler != nullptr)
-   {
-      assert(rationalLP != 0);
-      _solver.loadLP((SPxLPBase<R>)(*rationalLP));
-      rationalLP->~SPxLPRational();
-      spx_free(rationalLP);
+        break;
 
-      if(_hasBasis)
-         _solver.setBasis(basisStatusRows.get_ptr(), basisStatusCols.get_ptr());
-   }
+      case SPxSolverBase<R>::INFEASIBLE:
 
-   return result;
+        // if simplifier is active we can currently not return a Farkas ray or
+        // basis
+        if (_simplifier != 0) {
+          _hasBasis = false;
+          _rationalLUSolver.clear();
+          break;
+        }
+
+        // return Farkas ray as dual solution
+        _solver.getDualfarkas(dual);
+
+        // unscale vectors
+        if (_scaler != nullptr)
+          _scaler->unscaleDual(_solver, dual);
+
+        // get basis of transformed problem
+        basisStatusRows.reSize(_solver.nRows());
+        basisStatusCols.reSize(_solver.nCols());
+        _solver.getBasis(basisStatusRows.get_ptr(), basisStatusCols.get_ptr(),
+                         basisStatusRows.size(), basisStatusCols.size());
+        _hasBasis = true;
+        break;
+
+      case SPxSolverBase<R>::INForUNBD:
+      case SPxSolverBase<R>::SINGULAR:
+      default:
+        _hasBasis = false;
+        _rationalLUSolver.clear();
+        break;
+      }
+    }
+  } catch (...) {
+    MSG_INFO1(spxout,
+              spxout << "Exception thrown during floating-point solve.\n");
+    result = SPxSolverBase<R>::ERROR;
+    _hasBasis = false;
+    _rationalLUSolver.clear();
+  }
+
+  // restore original LP if necessary
+  if (_simplifier != 0 || _scaler != nullptr) {
+    assert(rationalLP != 0);
+    _solver.loadLP((SPxLPBase<R>)(*rationalLP));
+    rationalLP->~SPxLPRational();
+    spx_free(rationalLP);
+
+    if (_hasBasis)
+      _solver.setBasis(basisStatusRows.get_ptr(), basisStatusCols.get_ptr());
+  }
+
+  return result;
 }
 
 /// solves real LP with recovery mechanism
 template <class R>
-typename SPxSolverBase<R>::Status SoPlexBase<R>::_solveRealStable(bool acceptUnbounded,
-      bool acceptInfeasible, VectorBase<R>& primal, VectorBase<R>& dual,
-      DataArray< typename SPxSolverBase<R>::VarStatus >& basisStatusRows,
-      DataArray< typename SPxSolverBase<R>::VarStatus >& basisStatusCols,
-      const bool forceNoSimplifier)
-{
-   typename SPxSolverBase<R>::Status result = SPxSolverBase<R>::UNKNOWN;
-
-   bool fromScratch = false;
-   bool solved = false;
-   bool solvedFromScratch = false;
-   bool initialSolve = true;
-   bool increasedMarkowitz = false;
-   bool relaxedTolerances = false;
-   bool tightenedTolerances = false;
-   bool switchedScaler = false;
-   bool switchedSimplifier = false;
-   bool switchedRatiotester = false;
-   bool switchedPricer = false;
-   bool turnedoffPre = false;
-
-   R markowitz = _slufactor.markowitz();
-   int ratiotester = intParam(SoPlexBase<R>::RATIOTESTER);
-   int pricer = intParam(SoPlexBase<R>::PRICER);
-   int simplifier = intParam(SoPlexBase<R>::SIMPLIFIER);
-   int scaler = intParam(SoPlexBase<R>::SCALER);
-   int type = intParam(SoPlexBase<R>::ALGORITHM);
-
-   if(forceNoSimplifier)
-      setIntParam(SoPlexBase<R>::SIMPLIFIER, SoPlexBase<R>::SIMPLIFIER_OFF);
-
-   while(true)
-   {
-      assert(!increasedMarkowitz || GE(_slufactor.markowitz(), R(0.9)));
-
-      result = _solveRealForRational(fromScratch, primal, dual, basisStatusRows, basisStatusCols);
+typename SPxSolverBase<R>::Status SoPlexBase<R>::_solveRealStable(
+    bool acceptUnbounded, bool acceptInfeasible, VectorBase<R> &primal,
+    VectorBase<R> &dual,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &basisStatusRows,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &basisStatusCols,
+    const bool forceNoSimplifier) {
+  typename SPxSolverBase<R>::Status result = SPxSolverBase<R>::UNKNOWN;
+
+  bool fromScratch = false;
+  bool solved = false;
+  bool solvedFromScratch = false;
+  bool initialSolve = true;
+  bool increasedMarkowitz = false;
+  bool relaxedTolerances = false;
+  bool tightenedTolerances = false;
+  bool switchedScaler = false;
+  bool switchedSimplifier = false;
+  bool switchedRatiotester = false;
+  bool switchedPricer = false;
+  bool turnedoffPre = false;
+
+  R markowitz = _slufactor.markowitz();
+  int ratiotester = intParam(SoPlexBase<R>::RATIOTESTER);
+  int pricer = intParam(SoPlexBase<R>::PRICER);
+  int simplifier = intParam(SoPlexBase<R>::SIMPLIFIER);
+  int scaler = intParam(SoPlexBase<R>::SCALER);
+  int type = intParam(SoPlexBase<R>::ALGORITHM);
+
+  if (forceNoSimplifier)
+    setIntParam(SoPlexBase<R>::SIMPLIFIER, SoPlexBase<R>::SIMPLIFIER_OFF);
+
+  while (true) {
+    assert(!increasedMarkowitz || GE(_slufactor.markowitz(), R(0.9)));
+
+    result = _solveRealForRational(fromScratch, primal, dual, basisStatusRows,
+                                   basisStatusCols);
+
+    solved = (result == SPxSolverBase<R>::OPTIMAL) ||
+             (result == SPxSolverBase<R>::INFEASIBLE && acceptInfeasible) ||
+             (result == SPxSolverBase<R>::UNBOUNDED && acceptUnbounded);
+
+    if (solved || result == SPxSolverBase<R>::ABORT_TIME ||
+        result == SPxSolverBase<R>::ABORT_ITER)
+      break;
 
-      solved = (result == SPxSolverBase<R>::OPTIMAL)
-               || (result == SPxSolverBase<R>::INFEASIBLE && acceptInfeasible)
-               || (result == SPxSolverBase<R>::UNBOUNDED && acceptUnbounded);
+    if (initialSolve) {
+      MSG_INFO1(spxout, spxout
+                            << "Numerical troubles during floating-point solve."
+                            << std::endl);
+      initialSolve = false;
+    }
 
-      if(solved || result == SPxSolverBase<R>::ABORT_TIME || result == SPxSolverBase<R>::ABORT_ITER)
-         break;
+    if (!turnedoffPre &&
+        (intParam(SoPlexBase<R>::SIMPLIFIER) != SoPlexBase<R>::SIMPLIFIER_OFF ||
+         intParam(SoPlexBase<R>::SCALER) != SoPlexBase<R>::SCALER_OFF)) {
+      MSG_INFO1(spxout, spxout << "Turning off preprocessing." << std::endl);
 
-      if(initialSolve)
-      {
-         MSG_INFO1(spxout, spxout << "Numerical troubles during floating-point solve." << std::endl);
-         initialSolve = false;
-      }
+      turnedoffPre = true;
 
-      if(!turnedoffPre
-            && (intParam(SoPlexBase<R>::SIMPLIFIER) != SoPlexBase<R>::SIMPLIFIER_OFF
-                || intParam(SoPlexBase<R>::SCALER) != SoPlexBase<R>::SCALER_OFF))
-      {
-         MSG_INFO1(spxout, spxout << "Turning off preprocessing." << std::endl);
+      setIntParam(SoPlexBase<R>::SCALER, SoPlexBase<R>::SCALER_OFF);
+      setIntParam(SoPlexBase<R>::SIMPLIFIER, SoPlexBase<R>::SIMPLIFIER_OFF);
 
-         turnedoffPre = true;
+      fromScratch = true;
+      solvedFromScratch = true;
+      continue;
+    }
 
-         setIntParam(SoPlexBase<R>::SCALER, SoPlexBase<R>::SCALER_OFF);
-         setIntParam(SoPlexBase<R>::SIMPLIFIER, SoPlexBase<R>::SIMPLIFIER_OFF);
+    setIntParam(SoPlexBase<R>::SCALER, scaler);
+    setIntParam(SoPlexBase<R>::SIMPLIFIER, simplifier);
 
-         fromScratch = true;
-         solvedFromScratch = true;
-         continue;
-      }
+    if (!increasedMarkowitz) {
+      MSG_INFO1(spxout,
+                spxout << "Increasing Markowitz threshold." << std::endl);
 
-      setIntParam(SoPlexBase<R>::SCALER, scaler);
-      setIntParam(SoPlexBase<R>::SIMPLIFIER, simplifier);
+      _slufactor.setMarkowitz(0.9);
+      increasedMarkowitz = true;
 
-      if(!increasedMarkowitz)
-      {
-         MSG_INFO1(spxout, spxout << "Increasing Markowitz threshold." << std::endl);
-
-         _slufactor.setMarkowitz(0.9);
-         increasedMarkowitz = true;
-
-         try
-         {
-            _solver.factorize();
-            continue;
-         }
-         catch(...)
-         {
-            MSG_DEBUG(std::cout << std::endl << "Factorization failed." << std::endl);
-         }
+      try {
+        _solver.factorize();
+        continue;
+      } catch (...) {
+        MSG_DEBUG(std::cout << std::endl
+                            << "Factorization failed." << std::endl);
       }
+    }
 
-      if(!solvedFromScratch)
-      {
-         MSG_INFO1(spxout, spxout << "Solving from scratch." << std::endl);
+    if (!solvedFromScratch) {
+      MSG_INFO1(spxout, spxout << "Solving from scratch." << std::endl);
 
-         fromScratch = true;
-         solvedFromScratch = true;
-         continue;
-      }
+      fromScratch = true;
+      solvedFromScratch = true;
+      continue;
+    }
 
-      setIntParam(SoPlexBase<R>::RATIOTESTER, ratiotester);
-      setIntParam(SoPlexBase<R>::PRICER, pricer);
+    setIntParam(SoPlexBase<R>::RATIOTESTER, ratiotester);
+    setIntParam(SoPlexBase<R>::PRICER, pricer);
 
-      if(!switchedScaler)
-      {
-         MSG_INFO1(spxout, spxout << "Switching scaling." << std::endl);
+    if (!switchedScaler) {
+      MSG_INFO1(spxout, spxout << "Switching scaling." << std::endl);
 
-         if(scaler == int(SoPlexBase<R>::SCALER_OFF))
-            setIntParam(SoPlexBase<R>::SCALER, SoPlexBase<R>::SCALER_BIEQUI);
-         else
-            setIntParam(SoPlexBase<R>::SCALER, SoPlexBase<R>::SCALER_OFF);
+      if (scaler == int(SoPlexBase<R>::SCALER_OFF))
+        setIntParam(SoPlexBase<R>::SCALER, SoPlexBase<R>::SCALER_BIEQUI);
+      else
+        setIntParam(SoPlexBase<R>::SCALER, SoPlexBase<R>::SCALER_OFF);
 
-         fromScratch = true;
-         solvedFromScratch = true;
-         switchedScaler = true;
-         continue;
-      }
+      fromScratch = true;
+      solvedFromScratch = true;
+      switchedScaler = true;
+      continue;
+    }
 
-      if(!switchedSimplifier && !forceNoSimplifier)
-      {
-         MSG_INFO1(spxout, spxout << "Switching simplification." << std::endl);
+    if (!switchedSimplifier && !forceNoSimplifier) {
+      MSG_INFO1(spxout, spxout << "Switching simplification." << std::endl);
 
-         if(simplifier == int(SoPlexBase<R>::SIMPLIFIER_OFF))
-            setIntParam(SoPlexBase<R>::SIMPLIFIER, SoPlexBase<R>::SIMPLIFIER_INTERNAL);
-         else
-            setIntParam(SoPlexBase<R>::SIMPLIFIER, SoPlexBase<R>::SIMPLIFIER_OFF);
+      if (simplifier == int(SoPlexBase<R>::SIMPLIFIER_OFF))
+        setIntParam(SoPlexBase<R>::SIMPLIFIER,
+                    SoPlexBase<R>::SIMPLIFIER_INTERNAL);
+      else
+        setIntParam(SoPlexBase<R>::SIMPLIFIER, SoPlexBase<R>::SIMPLIFIER_OFF);
 
-         fromScratch = true;
-         solvedFromScratch = true;
-         switchedSimplifier = true;
-         continue;
-      }
+      fromScratch = true;
+      solvedFromScratch = true;
+      switchedSimplifier = true;
+      continue;
+    }
 
-      setIntParam(SoPlexBase<R>::SIMPLIFIER, SoPlexBase<R>::SIMPLIFIER_OFF);
+    setIntParam(SoPlexBase<R>::SIMPLIFIER, SoPlexBase<R>::SIMPLIFIER_OFF);
 
-      if(!relaxedTolerances)
-      {
-         MSG_INFO1(spxout, spxout << "Relaxing tolerances." << std::endl);
+    if (!relaxedTolerances) {
+      MSG_INFO1(spxout, spxout << "Relaxing tolerances." << std::endl);
 
-         setIntParam(SoPlexBase<R>::ALGORITHM, SoPlexBase<R>::ALGORITHM_PRIMAL);
-         _solver.setDelta((_solver.feastol() * 1e3 > 1e-3) ? 1e-3 : (_solver.feastol() * 1e3));
-         relaxedTolerances = _solver.feastol() >= 1e-3;
-         solvedFromScratch = false;
-         continue;
-      }
+      setIntParam(SoPlexBase<R>::ALGORITHM, SoPlexBase<R>::ALGORITHM_PRIMAL);
+      _solver.setDelta(
+          (_solver.feastol() * 1e3 > 1e-3) ? 1e-3 : (_solver.feastol() * 1e3));
+      relaxedTolerances = _solver.feastol() >= 1e-3;
+      solvedFromScratch = false;
+      continue;
+    }
 
-      if(!tightenedTolerances && result != SPxSolverBase<R>::INFEASIBLE)
-      {
-         MSG_INFO1(spxout, spxout << "Tightening tolerances." << std::endl);
+    if (!tightenedTolerances && result != SPxSolverBase<R>::INFEASIBLE) {
+      MSG_INFO1(spxout, spxout << "Tightening tolerances." << std::endl);
 
-         setIntParam(SoPlexBase<R>::ALGORITHM, SoPlexBase<R>::ALGORITHM_DUAL);
-         _solver.setDelta(_solver.feastol() * 1e-3 < 1e-9 ? 1e-9 : _solver.feastol() * 1e-3);
-         tightenedTolerances = _solver.feastol() <= 1e-9;
-         solvedFromScratch = false;
-         continue;
-      }
+      setIntParam(SoPlexBase<R>::ALGORITHM, SoPlexBase<R>::ALGORITHM_DUAL);
+      _solver.setDelta(
+          _solver.feastol() * 1e-3 < 1e-9 ? 1e-9 : _solver.feastol() * 1e-3);
+      tightenedTolerances = _solver.feastol() <= 1e-9;
+      solvedFromScratch = false;
+      continue;
+    }
 
-      setIntParam(SoPlexBase<R>::ALGORITHM, type);
+    setIntParam(SoPlexBase<R>::ALGORITHM, type);
 
-      if(!switchedRatiotester)
-      {
-         MSG_INFO1(spxout, spxout << "Switching ratio test." << std::endl);
+    if (!switchedRatiotester) {
+      MSG_INFO1(spxout, spxout << "Switching ratio test." << std::endl);
 
-         _solver.setType(_solver.type() == SPxSolverBase<R>::LEAVE ? SPxSolverBase<R>::ENTER :
-                         SPxSolverBase<R>::LEAVE);
+      _solver.setType(_solver.type() == SPxSolverBase<R>::LEAVE
+                          ? SPxSolverBase<R>::ENTER
+                          : SPxSolverBase<R>::LEAVE);
 
-         if(_solver.ratiotester() != (SPxRatioTester<R>*)&_ratiotesterTextbook)
-            setIntParam(SoPlexBase<R>::RATIOTESTER, RATIOTESTER_TEXTBOOK);
-         else
-            setIntParam(SoPlexBase<R>::RATIOTESTER, RATIOTESTER_FAST);
+      if (_solver.ratiotester() != (SPxRatioTester<R> *)&_ratiotesterTextbook)
+        setIntParam(SoPlexBase<R>::RATIOTESTER, RATIOTESTER_TEXTBOOK);
+      else
+        setIntParam(SoPlexBase<R>::RATIOTESTER, RATIOTESTER_FAST);
 
-         switchedRatiotester = true;
-         solvedFromScratch = false;
-         continue;
-      }
+      switchedRatiotester = true;
+      solvedFromScratch = false;
+      continue;
+    }
 
-      if(!switchedPricer)
-      {
-         MSG_INFO1(spxout, spxout << "Switching pricer." << std::endl);
+    if (!switchedPricer) {
+      MSG_INFO1(spxout, spxout << "Switching pricer." << std::endl);
 
-         _solver.setType(_solver.type() == SPxSolverBase<R>::LEAVE ? SPxSolverBase<R>::ENTER :
-                         SPxSolverBase<R>::LEAVE);
+      _solver.setType(_solver.type() == SPxSolverBase<R>::LEAVE
+                          ? SPxSolverBase<R>::ENTER
+                          : SPxSolverBase<R>::LEAVE);
 
-         if(_solver.pricer() != (SPxPricer<R>*)&_pricerDevex)
-            setIntParam(SoPlexBase<R>::PRICER, PRICER_DEVEX);
-         else
-            setIntParam(SoPlexBase<R>::PRICER, PRICER_STEEP);
+      if (_solver.pricer() != (SPxPricer<R> *)&_pricerDevex)
+        setIntParam(SoPlexBase<R>::PRICER, PRICER_DEVEX);
+      else
+        setIntParam(SoPlexBase<R>::PRICER, PRICER_STEEP);
 
-         switchedPricer = true;
-         solvedFromScratch = false;
-         continue;
-      }
+      switchedPricer = true;
+      solvedFromScratch = false;
+      continue;
+    }
 
-      MSG_INFO1(spxout, spxout << "Giving up." << std::endl);
+    MSG_INFO1(spxout, spxout << "Giving up." << std::endl);
 
-      break;
-   }
+    break;
+  }
 
-   _solver.setFeastol(realParam(SoPlexBase<R>::FPFEASTOL));
-   _solver.setOpttol(realParam(SoPlexBase<R>::FPOPTTOL));
-   _slufactor.setMarkowitz(markowitz);
+  _solver.setFeastol(realParam(SoPlexBase<R>::FPFEASTOL));
+  _solver.setOpttol(realParam(SoPlexBase<R>::FPOPTTOL));
+  _slufactor.setMarkowitz(markowitz);
 
-   setIntParam(SoPlexBase<R>::RATIOTESTER, ratiotester);
-   setIntParam(SoPlexBase<R>::PRICER, pricer);
-   setIntParam(SoPlexBase<R>::SIMPLIFIER, simplifier);
-   setIntParam(SoPlexBase<R>::SCALER, scaler);
-   setIntParam(SoPlexBase<R>::ALGORITHM, type);
+  setIntParam(SoPlexBase<R>::RATIOTESTER, ratiotester);
+  setIntParam(SoPlexBase<R>::PRICER, pricer);
+  setIntParam(SoPlexBase<R>::SIMPLIFIER, simplifier);
+  setIntParam(SoPlexBase<R>::SCALER, scaler);
+  setIntParam(SoPlexBase<R>::ALGORITHM, type);
 
-   return result;
+  return result;
 }
 
-/// computes rational inverse of basis matrix as defined by _rationalLUSolverBind
-template <class R>
-void SoPlexBase<R>::_computeBasisInverseRational()
-{
-   assert(_rationalLUSolver.status() == SLinSolverRational::UNLOADED
-          || _rationalLUSolver.status() == SLinSolverRational::TIME);
-
-   const int matrixdim = numRowsRational();
-   assert(_rationalLUSolverBind.size() == matrixdim);
-
-   Array< const SVectorRational* > matrix(matrixdim);
-   _rationalLUSolverBind.reSize(matrixdim);
-
-   for(int i = 0; i < matrixdim; i++)
-   {
-      if(_rationalLUSolverBind[i] >= 0)
-      {
-         assert(_rationalLUSolverBind[i] < numColsRational());
-         matrix[i] = &colVectorRational(_rationalLUSolverBind[i]);
-      }
-      else
-      {
-         assert(-1 - _rationalLUSolverBind[i] >= 0);
-         assert(-1 - _rationalLUSolverBind[i] < numRowsRational());
-         matrix[i] = _unitVectorRational(-1 - _rationalLUSolverBind[i]);
-      }
-   }
-
-   // load and factorize rational basis matrix
-   if(realParam(SoPlexBase<R>::TIMELIMIT) < realParam(SoPlexBase<R>::INFTY))
-      _rationalLUSolver.setTimeLimit((double)realParam(SoPlexBase<R>::TIMELIMIT) -
-                                     _statistics->solvingTime->time());
-   else
-      _rationalLUSolver.setTimeLimit(-1.0);
-
-   _rationalLUSolver.load(matrix.get_ptr(), matrixdim);
-
-   // record statistics
-   _statistics->luFactorizationTimeRational += _rationalLUSolver.getFactorTime();
-   _statistics->luFactorizationsRational += _rationalLUSolver.getFactorCount();
-   _rationalLUSolver.resetCounters();
-
-   if(_rationalLUSolver.status() == SLinSolverRational::TIME)
-   {
-      MSG_INFO2(spxout, spxout << "Rational factorization hit time limit.\n");
-   }
-   else if(_rationalLUSolver.status() != SLinSolverRational::OK)
-   {
-      MSG_INFO1(spxout, spxout << "Error performing rational LU factorization.\n");
-   }
-
-   return;
+/// computes rational inverse of basis matrix as defined by
+/// _rationalLUSolverBind
+template <class R> void SoPlexBase<R>::_computeBasisInverseRational() {
+  assert(_rationalLUSolver.status() == SLinSolverRational::UNLOADED ||
+         _rationalLUSolver.status() == SLinSolverRational::TIME);
+
+  const int matrixdim = numRowsRational();
+  assert(_rationalLUSolverBind.size() == matrixdim);
+
+  Array<const SVectorRational *> matrix(matrixdim);
+  _rationalLUSolverBind.reSize(matrixdim);
+
+  for (int i = 0; i < matrixdim; i++) {
+    if (_rationalLUSolverBind[i] >= 0) {
+      assert(_rationalLUSolverBind[i] < numColsRational());
+      matrix[i] = &colVectorRational(_rationalLUSolverBind[i]);
+    } else {
+      assert(-1 - _rationalLUSolverBind[i] >= 0);
+      assert(-1 - _rationalLUSolverBind[i] < numRowsRational());
+      matrix[i] = _unitVectorRational(-1 - _rationalLUSolverBind[i]);
+    }
+  }
+
+  // load and factorize rational basis matrix
+  if (realParam(SoPlexBase<R>::TIMELIMIT) < realParam(SoPlexBase<R>::INFTY))
+    _rationalLUSolver.setTimeLimit((double)realParam(SoPlexBase<R>::TIMELIMIT) -
+                                   _statistics->solvingTime->time());
+  else
+    _rationalLUSolver.setTimeLimit(-1.0);
+
+  _rationalLUSolver.load(matrix.get_ptr(), matrixdim);
+
+  // record statistics
+  _statistics->luFactorizationTimeRational += _rationalLUSolver.getFactorTime();
+  _statistics->luFactorizationsRational += _rationalLUSolver.getFactorCount();
+  _rationalLUSolver.resetCounters();
+
+  if (_rationalLUSolver.status() == SLinSolverRational::TIME) {
+    MSG_INFO2(spxout, spxout << "Rational factorization hit time limit.\n");
+  } else if (_rationalLUSolver.status() != SLinSolverRational::OK) {
+    MSG_INFO1(spxout,
+              spxout << "Error performing rational LU factorization.\n");
+  }
+
+  return;
 }
 
-
-
 /// factorizes rational basis matrix in column representation
 template <class R>
-void SoPlexBase<R>::_factorizeColumnRational(SolRational& sol,
-      DataArray< typename SPxSolverBase<R>::VarStatus >& basisStatusRows,
-      DataArray< typename SPxSolverBase<R>::VarStatus >& basisStatusCols, bool& stoppedTime,
-      bool& stoppedIter, bool& error, bool& optimal)
-{
-   // start rational solving time
-   _statistics->rationalTime->start();
-
-   stoppedTime = false;
-   stoppedIter = false;
-   error = false;
-   optimal = false;
-
-   const bool maximizing = (intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MAXIMIZE);
-   const int matrixdim = numRowsRational();
-   bool loadMatrix = (_rationalLUSolver.status() == SLinSolverRational::UNLOADED
-                      || _rationalLUSolver.status() == SLinSolverRational::TIME);
-   int numBasicRows;
-
-   assert(loadMatrix || matrixdim == _rationalLUSolver.dim());
-   assert(loadMatrix || matrixdim == _rationalLUSolverBind.size());
-
-   if(!loadMatrix && (matrixdim != _rationalLUSolver.dim()
-                      || matrixdim != _rationalLUSolverBind.size()))
-   {
-      MSG_WARNING(spxout, spxout <<
-                  "Warning: dimensioning error in rational matrix factorization (recovered).\n");
-      loadMatrix = true;
-   }
-
-   _workSol._primal.reDim(matrixdim);
-   _workSol._slacks.reDim(matrixdim);
-   _workSol._dual.reDim(matrixdim);
-   _workSol._redCost.reDim(numColsRational() > matrixdim ? numColsRational() : matrixdim);
-
-   if(loadMatrix)
-      _rationalLUSolverBind.reSize(matrixdim);
-
-   VectorRational& basicPrimalRhs = _workSol._slacks;
-   VectorRational& basicDualRhs = _workSol._redCost;
-   VectorRational& basicPrimal = _workSol._primal;
-   VectorRational& basicDual = _workSol._dual;
-
-   Rational violation;
-   Rational primalViolation;
-   Rational dualViolation;
-   bool primalFeasible = false;
-   bool dualFeasible = false;
-
-   assert(basisStatusCols.size() == numColsRational());
-   assert(basisStatusRows.size() == numRowsRational());
-
-   int j = 0;
-
-   for(int i = 0; i < basisStatusRows.size(); i++)
-   {
-      if(basisStatusRows[i] == SPxSolverBase<R>::BASIC && j < matrixdim)
-      {
-         basicPrimalRhs[i] = 0;
-         basicDualRhs[j] = 0;
-
-         if(loadMatrix)
-            _rationalLUSolverBind[j] = -1 - i;
-
-         j++;
-      }
-      else if(basisStatusRows[i] == SPxSolverBase<R>::ON_LOWER)
-         basicPrimalRhs[i] = lhsRational(i);
-      else if(basisStatusRows[i] == SPxSolverBase<R>::ON_UPPER)
-         basicPrimalRhs[i] = rhsRational(i);
-      else if(basisStatusRows[i] == SPxSolverBase<R>::ZERO)
-         basicPrimalRhs[i] = 0;
-      else if(basisStatusRows[i] == SPxSolverBase<R>::FIXED)
-      {
-         assert(lhsRational(i) == rhsRational(i));
-         basicPrimalRhs[i] = lhsRational(i);
-      }
-      else if(basisStatusRows[i] == SPxSolverBase<R>::UNDEFINED)
-      {
-         MSG_INFO1(spxout, spxout << "Undefined basis status of row in rational factorization.\n");
-         error = true;
-         goto TERMINATE;
-      }
-      else
-      {
-         assert(basisStatusRows[i] == SPxSolverBase<R>::BASIC);
-         MSG_INFO1(spxout, spxout << "Too many basic rows in rational factorization.\n");
-         error = true;
-         goto TERMINATE;
-      }
-   }
-
-   numBasicRows = j;
-
-   for(int i = 0; i < basisStatusCols.size(); i++)
-   {
-      if(basisStatusCols[i] == SPxSolverBase<R>::BASIC && j < matrixdim)
-      {
-         basicDualRhs[j] = objRational(i);
-
-         if(loadMatrix)
-            _rationalLUSolverBind[j] = i;
-
-         j++;
-      }
-      else if(basisStatusCols[i] == SPxSolverBase<R>::ON_LOWER)
-         basicPrimalRhs.multAdd(-lowerRational(i), colVectorRational(i));
-      else if(basisStatusCols[i] == SPxSolverBase<R>::ON_UPPER)
-         basicPrimalRhs.multAdd(-upperRational(i), colVectorRational(i));
-      else if(basisStatusCols[i] == SPxSolverBase<R>::ZERO)
-      {}
-      else if(basisStatusCols[i] == SPxSolverBase<R>::FIXED)
-      {
-         assert(lowerRational(i) == upperRational(i));
-         basicPrimalRhs.multAdd(-lowerRational(i), colVectorRational(i));
-      }
-      else if(basisStatusCols[i] == SPxSolverBase<R>::UNDEFINED)
-      {
-         MSG_INFO1(spxout, spxout << "Undefined basis status of column in rational factorization.\n");
-         error = true;
-         goto TERMINATE;
-      }
-      else
-      {
-         assert(basisStatusCols[i] == SPxSolverBase<R>::BASIC);
-         MSG_INFO1(spxout, spxout << "Too many basic columns in rational factorization.\n");
-         error = true;
-         goto TERMINATE;
-      }
-   }
-
-   if(j != matrixdim)
-   {
-      MSG_INFO1(spxout, spxout << "Too few basic entries in rational factorization.\n");
+void SoPlexBase<R>::_factorizeColumnRational(
+    SolRational &sol,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &basisStatusRows,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &basisStatusCols,
+    bool &stoppedTime, bool &stoppedIter, bool &error, bool &optimal) {
+  // start rational solving time
+  _statistics->rationalTime->start();
+
+  stoppedTime = false;
+  stoppedIter = false;
+  error = false;
+  optimal = false;
+
+  const bool maximizing =
+      (intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MAXIMIZE);
+  const int matrixdim = numRowsRational();
+  bool loadMatrix =
+      (_rationalLUSolver.status() == SLinSolverRational::UNLOADED ||
+       _rationalLUSolver.status() == SLinSolverRational::TIME);
+  int numBasicRows;
+
+  assert(loadMatrix || matrixdim == _rationalLUSolver.dim());
+  assert(loadMatrix || matrixdim == _rationalLUSolverBind.size());
+
+  if (!loadMatrix && (matrixdim != _rationalLUSolver.dim() ||
+                      matrixdim != _rationalLUSolverBind.size())) {
+    MSG_WARNING(spxout, spxout << "Warning: dimensioning error in rational "
+                                  "matrix factorization (recovered).\n");
+    loadMatrix = true;
+  }
+
+  _workSol._primal.reDim(matrixdim);
+  _workSol._slacks.reDim(matrixdim);
+  _workSol._dual.reDim(matrixdim);
+  _workSol._redCost.reDim(numColsRational() > matrixdim ? numColsRational()
+                                                        : matrixdim);
+
+  if (loadMatrix)
+    _rationalLUSolverBind.reSize(matrixdim);
+
+  VectorRational &basicPrimalRhs = _workSol._slacks;
+  VectorRational &basicDualRhs = _workSol._redCost;
+  VectorRational &basicPrimal = _workSol._primal;
+  VectorRational &basicDual = _workSol._dual;
+
+  Rational violation;
+  Rational primalViolation;
+  Rational dualViolation;
+  bool primalFeasible = false;
+  bool dualFeasible = false;
+
+  assert(basisStatusCols.size() == numColsRational());
+  assert(basisStatusRows.size() == numRowsRational());
+
+  int j = 0;
+
+  for (int i = 0; i < basisStatusRows.size(); i++) {
+    if (basisStatusRows[i] == SPxSolverBase<R>::BASIC && j < matrixdim) {
+      basicPrimalRhs[i] = 0;
+      basicDualRhs[j] = 0;
+
+      if (loadMatrix)
+        _rationalLUSolverBind[j] = -1 - i;
+
+      j++;
+    } else if (basisStatusRows[i] == SPxSolverBase<R>::ON_LOWER)
+      basicPrimalRhs[i] = lhsRational(i);
+    else if (basisStatusRows[i] == SPxSolverBase<R>::ON_UPPER)
+      basicPrimalRhs[i] = rhsRational(i);
+    else if (basisStatusRows[i] == SPxSolverBase<R>::ZERO)
+      basicPrimalRhs[i] = 0;
+    else if (basisStatusRows[i] == SPxSolverBase<R>::FIXED) {
+      assert(lhsRational(i) == rhsRational(i));
+      basicPrimalRhs[i] = lhsRational(i);
+    } else if (basisStatusRows[i] == SPxSolverBase<R>::UNDEFINED) {
+      MSG_INFO1(
+          spxout,
+          spxout
+              << "Undefined basis status of row in rational factorization.\n");
       error = true;
       goto TERMINATE;
-   }
-
-   // load and factorize rational basis matrix
-   if(loadMatrix)
-      _computeBasisInverseRational();
-
-   if(_rationalLUSolver.status() == SLinSolverRational::TIME)
-   {
-      stoppedTime = true;
-      return;
-   }
-   else if(_rationalLUSolver.status() != SLinSolverRational::OK)
-   {
+    } else {
+      assert(basisStatusRows[i] == SPxSolverBase<R>::BASIC);
+      MSG_INFO1(spxout,
+                spxout << "Too many basic rows in rational factorization.\n");
       error = true;
-      return;
-   }
-
-   assert(_rationalLUSolver.status() == SLinSolverRational::OK);
-
-   // solve for primal solution
-   if(realParam(SoPlexBase<R>::TIMELIMIT) < realParam(SoPlexBase<R>::INFTY))
-      _rationalLUSolver.setTimeLimit(Real(realParam(SoPlexBase<R>::TIMELIMIT)) -
-                                     _statistics->solvingTime->time());
-   else
-      _rationalLUSolver.setTimeLimit(-1.0);
-
-   _rationalLUSolver.solveRight(basicPrimal, basicPrimalRhs);
-
-   // record statistics
-   _statistics->luSolveTimeRational += _rationalLUSolver.getSolveTime();
-   _rationalLUSolver.resetCounters();
-
-   if(_isSolveStopped(stoppedTime, stoppedIter))
-   {
-      MSG_INFO2(spxout, spxout << "Rational factorization hit time limit while solving for primal.\n");
-      return;
-   }
-
-   // check bound violation on basic rows and columns
-   j = 0;
-   primalViolation = 0;
-   primalFeasible = true;
-
-   for(int i = 0; i < basisStatusRows.size(); i++)
-   {
-      if(basisStatusRows[i] == SPxSolverBase<R>::BASIC)
-      {
-         assert(j < matrixdim);
-         assert(_rationalLUSolverBind[j] == -1 - i);
-         violation = lhsRational(i);
-         violation += basicPrimal[j];
-
-         if(violation > primalViolation)
-         {
-            primalFeasible = false;
-            primalViolation = violation;
-         }
-
-         violation = rhsRational(i);
-         violation += basicPrimal[j];
-         violation *= -1;
-
-         if(violation > primalViolation)
-         {
-            primalFeasible = false;
-            primalViolation = violation;
-         }
-
-         j++;
+      goto TERMINATE;
+    }
+  }
+
+  numBasicRows = j;
+
+  for (int i = 0; i < basisStatusCols.size(); i++) {
+    if (basisStatusCols[i] == SPxSolverBase<R>::BASIC && j < matrixdim) {
+      basicDualRhs[j] = objRational(i);
+
+      if (loadMatrix)
+        _rationalLUSolverBind[j] = i;
+
+      j++;
+    } else if (basisStatusCols[i] == SPxSolverBase<R>::ON_LOWER)
+      basicPrimalRhs.multAdd(-lowerRational(i), colVectorRational(i));
+    else if (basisStatusCols[i] == SPxSolverBase<R>::ON_UPPER)
+      basicPrimalRhs.multAdd(-upperRational(i), colVectorRational(i));
+    else if (basisStatusCols[i] == SPxSolverBase<R>::ZERO) {
+    } else if (basisStatusCols[i] == SPxSolverBase<R>::FIXED) {
+      assert(lowerRational(i) == upperRational(i));
+      basicPrimalRhs.multAdd(-lowerRational(i), colVectorRational(i));
+    } else if (basisStatusCols[i] == SPxSolverBase<R>::UNDEFINED) {
+      MSG_INFO1(spxout, spxout << "Undefined basis status of column in "
+                                  "rational factorization.\n");
+      error = true;
+      goto TERMINATE;
+    } else {
+      assert(basisStatusCols[i] == SPxSolverBase<R>::BASIC);
+      MSG_INFO1(
+          spxout,
+          spxout << "Too many basic columns in rational factorization.\n");
+      error = true;
+      goto TERMINATE;
+    }
+  }
+
+  if (j != matrixdim) {
+    MSG_INFO1(spxout,
+              spxout << "Too few basic entries in rational factorization.\n");
+    error = true;
+    goto TERMINATE;
+  }
+
+  // load and factorize rational basis matrix
+  if (loadMatrix)
+    _computeBasisInverseRational();
+
+  if (_rationalLUSolver.status() == SLinSolverRational::TIME) {
+    stoppedTime = true;
+    return;
+  } else if (_rationalLUSolver.status() != SLinSolverRational::OK) {
+    error = true;
+    return;
+  }
+
+  assert(_rationalLUSolver.status() == SLinSolverRational::OK);
+
+  // solve for primal solution
+  if (realParam(SoPlexBase<R>::TIMELIMIT) < realParam(SoPlexBase<R>::INFTY))
+    _rationalLUSolver.setTimeLimit(Real(realParam(SoPlexBase<R>::TIMELIMIT)) -
+                                   _statistics->solvingTime->time());
+  else
+    _rationalLUSolver.setTimeLimit(-1.0);
+
+  _rationalLUSolver.solveRight(basicPrimal, basicPrimalRhs);
+
+  // record statistics
+  _statistics->luSolveTimeRational += _rationalLUSolver.getSolveTime();
+  _rationalLUSolver.resetCounters();
+
+  if (_isSolveStopped(stoppedTime, stoppedIter)) {
+    MSG_INFO2(spxout, spxout << "Rational factorization hit time limit while "
+                                "solving for primal.\n");
+    return;
+  }
+
+  // check bound violation on basic rows and columns
+  j = 0;
+  primalViolation = 0;
+  primalFeasible = true;
+
+  for (int i = 0; i < basisStatusRows.size(); i++) {
+    if (basisStatusRows[i] == SPxSolverBase<R>::BASIC) {
+      assert(j < matrixdim);
+      assert(_rationalLUSolverBind[j] == -1 - i);
+      violation = lhsRational(i);
+      violation += basicPrimal[j];
+
+      if (violation > primalViolation) {
+        primalFeasible = false;
+        primalViolation = violation;
       }
-   }
-
-   for(int i = 0; i < basisStatusCols.size(); i++)
-   {
-      if(basisStatusCols[i] == SPxSolverBase<R>::BASIC)
-      {
-         assert(j < matrixdim);
-         assert(_rationalLUSolverBind[j] == i);
-
-         if(basicPrimal[j] < lowerRational(i))
-         {
-            violation = lowerRational(i);
-            violation -= basicPrimal[j];
-
-            if(violation > primalViolation)
-            {
-               primalFeasible = false;
-               primalViolation = violation;
-            }
-         }
 
-         if(basicPrimal[j] > upperRational(i))
-         {
-            violation = basicPrimal[j];
-            violation -= upperRational(i);
+      violation = rhsRational(i);
+      violation += basicPrimal[j];
+      violation *= -1;
 
-            if(violation > primalViolation)
-            {
-               primalFeasible = false;
-               primalViolation = violation;
-            }
-         }
-
-         j++;
+      if (violation > primalViolation) {
+        primalFeasible = false;
+        primalViolation = violation;
       }
-   }
-
-   if(!primalFeasible)
-   {
-      MSG_INFO1(spxout, spxout << "Rational solution primal infeasible.\n");
-   }
-
-   // solve for dual solution
-   if(realParam(SoPlexBase<R>::TIMELIMIT) < realParam(SoPlexBase<R>::INFTY))
-      _rationalLUSolver.setTimeLimit(Real(realParam(SoPlexBase<R>::TIMELIMIT)) -
-                                     _statistics->solvingTime->time());
-   else
-      _rationalLUSolver.setTimeLimit(-1.0);
 
-   _rationalLUSolver.solveLeft(basicDual, basicDualRhs);
+      j++;
+    }
+  }
 
-   // record statistics
-   _statistics->luSolveTimeRational += _rationalLUSolver.getSolveTime();
-   _rationalLUSolver.resetCounters();
+  for (int i = 0; i < basisStatusCols.size(); i++) {
+    if (basisStatusCols[i] == SPxSolverBase<R>::BASIC) {
+      assert(j < matrixdim);
+      assert(_rationalLUSolverBind[j] == i);
 
-   if(_isSolveStopped(stoppedTime, stoppedIter))
-   {
-      MSG_INFO2(spxout, spxout << "Rational factorization hit time limit while solving for dual.\n");
-      return;
-   }
-
-   // check dual violation on nonbasic rows
-   dualViolation = 0;
-   dualFeasible = true;
+      if (basicPrimal[j] < lowerRational(i)) {
+        violation = lowerRational(i);
+        violation -= basicPrimal[j];
 
-   for(int i = 0; i < basisStatusRows.size(); i++)
-   {
-      if(_rowTypes[i] == RANGETYPE_FIXED
-            && (basisStatusRows[i] == SPxSolverBase<R>::ON_LOWER
-                || basisStatusRows[i] == SPxSolverBase<R>::ON_UPPER))
-      {
-         assert(lhsRational(i) == rhsRational(i));
-         basisStatusRows[i] = SPxSolverBase<R>::FIXED;
+        if (violation > primalViolation) {
+          primalFeasible = false;
+          primalViolation = violation;
+        }
       }
 
-      assert(basisStatusRows[i] != SPxSolverBase<R>::BASIC || basicDual[i] == 0);
+      if (basicPrimal[j] > upperRational(i)) {
+        violation = basicPrimal[j];
+        violation -= upperRational(i);
 
-      if(basisStatusRows[i] == SPxSolverBase<R>::BASIC || basisStatusRows[i] == SPxSolverBase<R>::FIXED)
-         continue;
-      else if(basicDual[i] < 0)
-      {
-         if(((maximizing && basisStatusRows[i] != SPxSolverBase<R>::ON_LOWER) || (!maximizing
-               && basisStatusRows[i] != SPxSolverBase<R>::ON_UPPER))
-               && (basisStatusRows[i] != SPxSolverBase<R>::ZERO || rhsRational(i) != 0))
-         {
-            dualFeasible = false;
-            violation = -basicDual[i];
-
-            if(violation > dualViolation)
-               dualViolation = violation;
-
-            MSG_DEBUG(spxout << "negative dual multliplier for row " << i
-                      << " with dual " << basicDual[i].str()
-                      << " and status " << basisStatusRows[i]
-                      << " and [lhs,rhs] = [" << lhsRational(i).str() << "," << rhsRational(i).str() << "]"
-                      << "\n");
-         }
+        if (violation > primalViolation) {
+          primalFeasible = false;
+          primalViolation = violation;
+        }
       }
-      else if(basicDual[i] > 0)
-      {
-         if(((maximizing && basisStatusRows[i] != SPxSolverBase<R>::ON_UPPER) || (!maximizing
-               && basisStatusRows[i] != SPxSolverBase<R>::ON_LOWER))
-               && (basisStatusRows[i] != SPxSolverBase<R>::ZERO || lhsRational(i) == 0))
-         {
-            dualFeasible = false;
-
-            if(basicDual[i] > dualViolation)
-               dualViolation = basicDual[i];
-
-            MSG_DEBUG(spxout << "positive dual multliplier for row " << i
-                      << " with dual " << basicDual[i].str()
-                      << " and status " << basisStatusRows[i]
-                      << " and [lhs,rhs] = [" << lhsRational(i).str() << "," << rhsRational(i).str() << "]"
-                      << "\n");
-         }
-      }
-   }
-
-   // check reduced cost violation on nonbasic columns
-   for(int i = 0; i < basisStatusCols.size(); i++)
-   {
-      if(_colTypes[i] == RANGETYPE_FIXED
-            && (basisStatusCols[i] == SPxSolverBase<R>::ON_LOWER
-                || basisStatusCols[i] == SPxSolverBase<R>::ON_UPPER))
-      {
-         assert(lowerRational(i) == upperRational(i));
-         basisStatusCols[i] = SPxSolverBase<R>::FIXED;
-      }
-
-      assert(basisStatusCols[i] != SPxSolverBase<R>::BASIC
-             || basicDual * colVectorRational(i) == objRational(i));
-
-      if(basisStatusCols[i] == SPxSolverBase<R>::BASIC || basisStatusCols[i] == SPxSolverBase<R>::FIXED)
-         continue;
-      else
-      {
-         _workSol._redCost[i] = basicDual * colVectorRational(i);
-         _workSol._redCost[i] -= objRational(i);
-
-         if(_workSol._redCost[i] > 0)
-         {
-            if(((maximizing && basisStatusCols[i] != SPxSolverBase<R>::ON_LOWER) || (!maximizing
-                  && basisStatusCols[i] != SPxSolverBase<R>::ON_UPPER))
-                  && (basisStatusCols[i] != SPxSolverBase<R>::ZERO || upperRational(i) != 0))
-            {
-               dualFeasible = false;
-
-               if(_workSol._redCost[i] > dualViolation)
-                  dualViolation = _workSol._redCost[i];
-            }
-
-            _workSol._redCost[i] *= -1;
-         }
-         else if(_workSol._redCost[i] < 0)
-         {
-            _workSol._redCost[i] *= -1;
 
-            if(((maximizing && basisStatusCols[i] != SPxSolverBase<R>::ON_UPPER) || (!maximizing
-                  && basisStatusCols[i] != SPxSolverBase<R>::ON_LOWER))
-                  && (basisStatusCols[i] != SPxSolverBase<R>::ZERO || lowerRational(i) != 0))
-            {
-               dualFeasible = false;
-
-               if(_workSol._redCost[i] > dualViolation)
-                  dualViolation = _workSol._redCost[i];
-            }
-         }
-         else
-            _workSol._redCost[i] *= -1;
+      j++;
+    }
+  }
+
+  if (!primalFeasible) {
+    MSG_INFO1(spxout, spxout << "Rational solution primal infeasible.\n");
+  }
+
+  // solve for dual solution
+  if (realParam(SoPlexBase<R>::TIMELIMIT) < realParam(SoPlexBase<R>::INFTY))
+    _rationalLUSolver.setTimeLimit(Real(realParam(SoPlexBase<R>::TIMELIMIT)) -
+                                   _statistics->solvingTime->time());
+  else
+    _rationalLUSolver.setTimeLimit(-1.0);
+
+  _rationalLUSolver.solveLeft(basicDual, basicDualRhs);
+
+  // record statistics
+  _statistics->luSolveTimeRational += _rationalLUSolver.getSolveTime();
+  _rationalLUSolver.resetCounters();
+
+  if (_isSolveStopped(stoppedTime, stoppedIter)) {
+    MSG_INFO2(spxout, spxout << "Rational factorization hit time limit while "
+                                "solving for dual.\n");
+    return;
+  }
+
+  // check dual violation on nonbasic rows
+  dualViolation = 0;
+  dualFeasible = true;
+
+  for (int i = 0; i < basisStatusRows.size(); i++) {
+    if (_rowTypes[i] == RANGETYPE_FIXED &&
+        (basisStatusRows[i] == SPxSolverBase<R>::ON_LOWER ||
+         basisStatusRows[i] == SPxSolverBase<R>::ON_UPPER)) {
+      assert(lhsRational(i) == rhsRational(i));
+      basisStatusRows[i] = SPxSolverBase<R>::FIXED;
+    }
+
+    assert(basisStatusRows[i] != SPxSolverBase<R>::BASIC || basicDual[i] == 0);
+
+    if (basisStatusRows[i] == SPxSolverBase<R>::BASIC ||
+        basisStatusRows[i] == SPxSolverBase<R>::FIXED)
+      continue;
+    else if (basicDual[i] < 0) {
+      if (((maximizing && basisStatusRows[i] != SPxSolverBase<R>::ON_LOWER) ||
+           (!maximizing && basisStatusRows[i] != SPxSolverBase<R>::ON_UPPER)) &&
+          (basisStatusRows[i] != SPxSolverBase<R>::ZERO ||
+           rhsRational(i) != 0)) {
+        dualFeasible = false;
+        violation = -basicDual[i];
+
+        if (violation > dualViolation)
+          dualViolation = violation;
+
+        MSG_DEBUG(spxout << "negative dual multliplier for row " << i
+                         << " with dual " << basicDual[i].str()
+                         << " and status " << basisStatusRows[i]
+                         << " and [lhs,rhs] = [" << lhsRational(i).str() << ","
+                         << rhsRational(i).str() << "]"
+                         << "\n");
       }
-   }
-
-   if(!dualFeasible)
-   {
-      MSG_INFO1(spxout, spxout << "Rational solution dual infeasible.\n");
-   }
-
-   // store solution
-   optimal = primalFeasible && dualFeasible;
-
-   if(optimal || boolParam(SoPlexBase<R>::RATFACJUMP))
-   {
-      _hasBasis = true;
-
-      if(&basisStatusRows != &_basisStatusRows)
-         _basisStatusRows = basisStatusRows;
-
-      if(&basisStatusCols != &_basisStatusCols)
-         _basisStatusCols = basisStatusCols;
-
-      sol._primal.reDim(numColsRational());
-      j = numBasicRows;
-
-      for(int i = 0; i < basisStatusCols.size(); i++)
-      {
-         if(basisStatusCols[i] == SPxSolverBase<R>::BASIC)
-         {
-            assert(j < matrixdim);
-            assert(_rationalLUSolverBind[j] == i);
-            sol._primal[i] = basicPrimal[j];
-            j++;
-         }
-         else if(basisStatusCols[i] == SPxSolverBase<R>::ON_LOWER)
-            sol._primal[i] = lowerRational(i);
-         else if(basisStatusCols[i] == SPxSolverBase<R>::ON_UPPER)
-            sol._primal[i] = upperRational(i);
-         else if(basisStatusCols[i] == SPxSolverBase<R>::ZERO)
-            sol._primal[i] = 0;
-         else if(basisStatusCols[i] == SPxSolverBase<R>::FIXED)
-         {
-            assert(lowerRational(i) == upperRational(i));
-            sol._primal[i] = lowerRational(i);
-         }
-         else
-         {
-            assert(basisStatusCols[i] == SPxSolverBase<R>::UNDEFINED);
-            MSG_INFO1(spxout, spxout << "Undefined basis status of column in rational factorization.\n");
-            error = true;
-            goto TERMINATE;
-         }
+    } else if (basicDual[i] > 0) {
+      if (((maximizing && basisStatusRows[i] != SPxSolverBase<R>::ON_UPPER) ||
+           (!maximizing && basisStatusRows[i] != SPxSolverBase<R>::ON_LOWER)) &&
+          (basisStatusRows[i] != SPxSolverBase<R>::ZERO ||
+           lhsRational(i) == 0)) {
+        dualFeasible = false;
+
+        if (basicDual[i] > dualViolation)
+          dualViolation = basicDual[i];
+
+        MSG_DEBUG(spxout << "positive dual multliplier for row " << i
+                         << " with dual " << basicDual[i].str()
+                         << " and status " << basisStatusRows[i]
+                         << " and [lhs,rhs] = [" << lhsRational(i).str() << ","
+                         << rhsRational(i).str() << "]"
+                         << "\n");
       }
-
-      sol._slacks.reDim(numRowsRational());
-      _rationalLP->computePrimalActivity(sol._primal, sol._slacks);
-      sol._isPrimalFeasible = true;
-
-      sol._dual = basicDual;
-
-      for(int i = 0; i < numColsRational(); i++)
-      {
-         if(basisStatusCols[i] == SPxSolverBase<R>::BASIC)
-            sol._redCost[i] = 0;
-         else if(basisStatusCols[i] == SPxSolverBase<R>::FIXED)
-         {
-            sol._redCost[i] = basicDual * colVectorRational(i);
-            sol._redCost[i] -= objRational(i);
-            sol._redCost[i] *= -1;
-         }
-         else
-            sol._redCost[i] = _workSol._redCost[i];
+    }
+  }
+
+  // check reduced cost violation on nonbasic columns
+  for (int i = 0; i < basisStatusCols.size(); i++) {
+    if (_colTypes[i] == RANGETYPE_FIXED &&
+        (basisStatusCols[i] == SPxSolverBase<R>::ON_LOWER ||
+         basisStatusCols[i] == SPxSolverBase<R>::ON_UPPER)) {
+      assert(lowerRational(i) == upperRational(i));
+      basisStatusCols[i] = SPxSolverBase<R>::FIXED;
+    }
+
+    assert(basisStatusCols[i] != SPxSolverBase<R>::BASIC ||
+           basicDual * colVectorRational(i) == objRational(i));
+
+    if (basisStatusCols[i] == SPxSolverBase<R>::BASIC ||
+        basisStatusCols[i] == SPxSolverBase<R>::FIXED)
+      continue;
+    else {
+      _workSol._redCost[i] = basicDual * colVectorRational(i);
+      _workSol._redCost[i] -= objRational(i);
+
+      if (_workSol._redCost[i] > 0) {
+        if (((maximizing && basisStatusCols[i] != SPxSolverBase<R>::ON_LOWER) ||
+             (!maximizing &&
+              basisStatusCols[i] != SPxSolverBase<R>::ON_UPPER)) &&
+            (basisStatusCols[i] != SPxSolverBase<R>::ZERO ||
+             upperRational(i) != 0)) {
+          dualFeasible = false;
+
+          if (_workSol._redCost[i] > dualViolation)
+            dualViolation = _workSol._redCost[i];
+        }
+
+        _workSol._redCost[i] *= -1;
+      } else if (_workSol._redCost[i] < 0) {
+        _workSol._redCost[i] *= -1;
+
+        if (((maximizing && basisStatusCols[i] != SPxSolverBase<R>::ON_UPPER) ||
+             (!maximizing &&
+              basisStatusCols[i] != SPxSolverBase<R>::ON_LOWER)) &&
+            (basisStatusCols[i] != SPxSolverBase<R>::ZERO ||
+             lowerRational(i) != 0)) {
+          dualFeasible = false;
+
+          if (_workSol._redCost[i] > dualViolation)
+            dualViolation = _workSol._redCost[i];
+        }
+      } else
+        _workSol._redCost[i] *= -1;
+    }
+  }
+
+  if (!dualFeasible) {
+    MSG_INFO1(spxout, spxout << "Rational solution dual infeasible.\n");
+  }
+
+  // store solution
+  optimal = primalFeasible && dualFeasible;
+
+  if (optimal || boolParam(SoPlexBase<R>::RATFACJUMP)) {
+    _hasBasis = true;
+
+    if (&basisStatusRows != &_basisStatusRows)
+      _basisStatusRows = basisStatusRows;
+
+    if (&basisStatusCols != &_basisStatusCols)
+      _basisStatusCols = basisStatusCols;
+
+    sol._primal.reDim(numColsRational());
+    j = numBasicRows;
+
+    for (int i = 0; i < basisStatusCols.size(); i++) {
+      if (basisStatusCols[i] == SPxSolverBase<R>::BASIC) {
+        assert(j < matrixdim);
+        assert(_rationalLUSolverBind[j] == i);
+        sol._primal[i] = basicPrimal[j];
+        j++;
+      } else if (basisStatusCols[i] == SPxSolverBase<R>::ON_LOWER)
+        sol._primal[i] = lowerRational(i);
+      else if (basisStatusCols[i] == SPxSolverBase<R>::ON_UPPER)
+        sol._primal[i] = upperRational(i);
+      else if (basisStatusCols[i] == SPxSolverBase<R>::ZERO)
+        sol._primal[i] = 0;
+      else if (basisStatusCols[i] == SPxSolverBase<R>::FIXED) {
+        assert(lowerRational(i) == upperRational(i));
+        sol._primal[i] = lowerRational(i);
+      } else {
+        assert(basisStatusCols[i] == SPxSolverBase<R>::UNDEFINED);
+        MSG_INFO1(spxout, spxout << "Undefined basis status of column in "
+                                    "rational factorization.\n");
+        error = true;
+        goto TERMINATE;
       }
-
-      sol._isDualFeasible  = true;
-   }
-   else
-   {
-      _rationalLUSolver.clear();
-   }
-
+    }
+
+    sol._slacks.reDim(numRowsRational());
+    _rationalLP->computePrimalActivity(sol._primal, sol._slacks);
+    sol._isPrimalFeasible = true;
+
+    sol._dual = basicDual;
+
+    for (int i = 0; i < numColsRational(); i++) {
+      if (basisStatusCols[i] == SPxSolverBase<R>::BASIC)
+        sol._redCost[i] = 0;
+      else if (basisStatusCols[i] == SPxSolverBase<R>::FIXED) {
+        sol._redCost[i] = basicDual * colVectorRational(i);
+        sol._redCost[i] -= objRational(i);
+        sol._redCost[i] *= -1;
+      } else
+        sol._redCost[i] = _workSol._redCost[i];
+    }
+
+    sol._isDualFeasible = true;
+  } else {
+    _rationalLUSolver.clear();
+  }
 
 TERMINATE:
-   // stop rational solving time
-   _statistics->rationalTime->stop();
-   return;
+  // stop rational solving time
+  _statistics->rationalTime->stop();
+  return;
 }
 
 /// attempts rational reconstruction of primal-dual solution
 template <class R>
-bool SoPlexBase<R>::_reconstructSolutionRational(SolRational& sol,
-      DataArray< typename SPxSolverBase<R>::VarStatus >& basisStatusRows,
-      DataArray< typename SPxSolverBase<R>::VarStatus >& basisStatusCols,
-      const Rational& denomBoundSquared)
-{
-   bool success;
-   bool isSolBasic;
-   DIdxSet basicIndices(numColsRational());
-
-   success = false;
-   isSolBasic = true;
-
-   if(!sol.isPrimalFeasible() || !sol.isDualFeasible())
-      return success;
-
-   // start timing and increment statistics counter
-   _statistics->reconstructionTime->start();
-   _statistics->rationalReconstructions++;
-
-   // reconstruct primal vector
-   _workSol._primal = sol._primal;
-
-   for(int j = 0; j < numColsRational(); ++j)
-   {
-      if(basisStatusCols[j] == SPxSolverBase<R>::BASIC)
-         basicIndices.addIdx(j);
-   }
-
-   success = reconstructVector(_workSol._primal, denomBoundSquared, &basicIndices);
-
-   if(!success)
-   {
-      MSG_INFO1(spxout, spxout << "Rational reconstruction of primal solution failed.\n");
+bool SoPlexBase<R>::_reconstructSolutionRational(
+    SolRational &sol,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &basisStatusRows,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &basisStatusCols,
+    const Rational &denomBoundSquared) {
+  bool success;
+  bool isSolBasic;
+  DIdxSet basicIndices(numColsRational());
+
+  success = false;
+  isSolBasic = true;
+
+  if (!sol.isPrimalFeasible() || !sol.isDualFeasible())
+    return success;
+
+  // start timing and increment statistics counter
+  _statistics->reconstructionTime->start();
+  _statistics->rationalReconstructions++;
+
+  // reconstruct primal vector
+  _workSol._primal = sol._primal;
+
+  for (int j = 0; j < numColsRational(); ++j) {
+    if (basisStatusCols[j] == SPxSolverBase<R>::BASIC)
+      basicIndices.addIdx(j);
+  }
+
+  success =
+      reconstructVector(_workSol._primal, denomBoundSquared, &basicIndices);
+
+  if (!success) {
+    MSG_INFO1(spxout,
+              spxout << "Rational reconstruction of primal solution failed.\n");
+    _statistics->reconstructionTime->stop();
+    return success;
+  }
+
+  MSG_DEBUG(
+      spxout << "Rational reconstruction of primal solution successful.\n");
+
+  // check violation of bounds
+  for (int c = numColsRational() - 1; c >= 0; c--) {
+    // we want to notify the user whether the reconstructed solution is basic;
+    // otherwise, this would be redundant
+    typename SPxSolverBase<R>::VarStatus &basisStatusCol = _basisStatusCols[c];
+
+    if ((basisStatusCol == SPxSolverBase<R>::FIXED &&
+         _workSol._primal[c] != lowerRational(c)) ||
+        (basisStatusCol == SPxSolverBase<R>::ON_LOWER &&
+         _workSol._primal[c] != lowerRational(c)) ||
+        (basisStatusCol == SPxSolverBase<R>::ON_UPPER &&
+         _workSol._primal[c] != upperRational(c)) ||
+        (basisStatusCol == SPxSolverBase<R>::ZERO &&
+         _workSol._primal[c] != 0) ||
+        (basisStatusCol == SPxSolverBase<R>::UNDEFINED)) {
+      isSolBasic = false;
+    }
+
+    if (_lowerFinite(_colTypes[c]) && _workSol._primal[c] < lowerRational(c)) {
+      MSG_DEBUG(std::cout << "Lower bound of variable " << c << " violated by "
+                          << (lowerRational(c) - _workSol._primal[c]).str()
+                          << "\n");
+      MSG_INFO1(spxout,
+                spxout << "Reconstructed solution primal infeasible (1).\n");
       _statistics->reconstructionTime->stop();
-      return success;
-   }
-
-   MSG_DEBUG(spxout << "Rational reconstruction of primal solution successful.\n");
-
-   // check violation of bounds
-   for(int c = numColsRational() - 1; c >= 0; c--)
-   {
-      // we want to notify the user whether the reconstructed solution is basic; otherwise, this would be redundant
-      typename SPxSolverBase<R>::VarStatus& basisStatusCol = _basisStatusCols[c];
-
-      if((basisStatusCol == SPxSolverBase<R>::FIXED && _workSol._primal[c] != lowerRational(c))
-            || (basisStatusCol == SPxSolverBase<R>::ON_LOWER && _workSol._primal[c] != lowerRational(c))
-            || (basisStatusCol == SPxSolverBase<R>::ON_UPPER && _workSol._primal[c] != upperRational(c))
-            || (basisStatusCol == SPxSolverBase<R>::ZERO && _workSol._primal[c] != 0)
-            || (basisStatusCol == SPxSolverBase<R>::UNDEFINED))
-      {
-         isSolBasic = false;
-      }
-
-      if(_lowerFinite(_colTypes[c]) && _workSol._primal[c] < lowerRational(c))
-      {
-         MSG_DEBUG(std::cout << "Lower bound of variable " << c << " violated by " <<
-                   (lowerRational(c) - _workSol._primal[c]).str() << "\n");
-         MSG_INFO1(spxout, spxout << "Reconstructed solution primal infeasible (1).\n");
-         _statistics->reconstructionTime->stop();
-         return false;
+      return false;
+    }
+
+    if (_upperFinite(_colTypes[c]) && _workSol._primal[c] > upperRational(c)) {
+      MSG_DEBUG(std::cout << "Upper bound of variable " << c << " violated by "
+                          << (_workSol._primal[c] - upperRational(c)).str()
+                          << "\n");
+      MSG_INFO1(spxout,
+                spxout << "Reconstructed solution primal infeasible (2).\n");
+      _statistics->reconstructionTime->stop();
+      return false;
+    }
+  }
+
+  // compute slacks
+  ///@todo we should compute them one by one so we can abort when encountering
+  ///an infeasibility
+  _workSol._slacks.reDim(numRowsRational());
+  _rationalLP->computePrimalActivity(_workSol._primal, _workSol._slacks);
+
+  // check violation of sides
+  for (int r = numRowsRational() - 1; r >= 0; r--) {
+    // we want to notify the user whether the reconstructed solution is basic;
+    // otherwise, this would be redundant
+    typename SPxSolverBase<R>::VarStatus &basisStatusRow = _basisStatusRows[r];
+
+    if ((basisStatusRow == SPxSolverBase<R>::FIXED &&
+         _workSol._slacks[r] != lhsRational(r)) ||
+        (basisStatusRow == SPxSolverBase<R>::ON_LOWER &&
+         _workSol._slacks[r] != lhsRational(r)) ||
+        (basisStatusRow == SPxSolverBase<R>::ON_UPPER &&
+         _workSol._slacks[r] != rhsRational(r)) ||
+        (basisStatusRow == SPxSolverBase<R>::ZERO &&
+         _workSol._slacks[r] != 0) ||
+        (basisStatusRow == SPxSolverBase<R>::UNDEFINED)) {
+      isSolBasic = false;
+    }
+
+    if (_lowerFinite(_rowTypes[r]) && _workSol._slacks[r] < lhsRational(r)) {
+      MSG_DEBUG(std::cout << "Lhs of row " << r << " violated by "
+                          << (lhsRational(r) - _workSol._slacks[r]).str()
+                          << "\n");
+      MSG_INFO1(spxout,
+                spxout << "Reconstructed solution primal infeasible (3).\n");
+      _statistics->reconstructionTime->stop();
+      return false;
+    }
+
+    if (_upperFinite(_rowTypes[r]) && _workSol._slacks[r] > rhsRational(r)) {
+      MSG_DEBUG(std::cout << "Rhs of row " << r << " violated by "
+                          << (_workSol._slacks[r] - rhsRational(r)) << "\n");
+      MSG_INFO1(spxout,
+                spxout << "Reconstructed solution primal infeasible (4).\n");
+      _statistics->reconstructionTime->stop();
+      return false;
+    }
+  }
+
+  // reconstruct dual vector
+  _workSol._dual = sol._dual;
+
+  success = reconstructVector(_workSol._dual, denomBoundSquared);
+
+  if (!success) {
+    MSG_INFO1(spxout,
+              spxout << "Rational reconstruction of dual solution failed.\n");
+    _statistics->reconstructionTime->stop();
+    return success;
+  }
+
+  MSG_DEBUG(spxout << "Rational reconstruction of dual vector successful.\n");
+
+  // check dual multipliers before reduced costs because this check is faster
+  // since it does not require the computation of reduced costs
+  const bool maximizing =
+      (intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MAXIMIZE);
+
+  for (int r = numRowsRational() - 1; r >= 0; r--) {
+    int sig = sign(_workSol._dual[r]);
+
+    if ((!maximizing && sig > 0) || (maximizing && sig < 0)) {
+      if (!_lowerFinite(_rowTypes[r]) || _workSol._slacks[r] > lhsRational(r)) {
+        MSG_DEBUG(std::cout << "complementary slackness violated by row " << r
+                            << " with dual " << _workSol._dual[r].str()
+                            << " and slack " << _workSol._slacks[r].str()
+                            << " not at lhs " << lhsRational(r).str() << "\n");
+        MSG_INFO1(spxout,
+                  spxout << "Reconstructed solution dual infeasible (1).\n");
+        _statistics->reconstructionTime->stop();
+        return false;
       }
 
-      if(_upperFinite(_colTypes[c]) && _workSol._primal[c] > upperRational(c))
-      {
-         MSG_DEBUG(std::cout << "Upper bound of variable " << c << " violated by " <<
-                   (_workSol._primal[c] - upperRational(c)).str() << "\n");
-         MSG_INFO1(spxout, spxout << "Reconstructed solution primal infeasible (2).\n");
-         _statistics->reconstructionTime->stop();
-         return false;
+      if (_basisStatusRows[r] != SPxSolverBase<R>::ON_LOWER &&
+          _basisStatusRows[r] != SPxSolverBase<R>::FIXED) {
+        if (_basisStatusRows[r] == SPxSolverBase<R>::BASIC ||
+            _basisStatusRows[r] == SPxSolverBase<R>::UNDEFINED)
+          isSolBasic = false;
+        else
+          _basisStatusRows[r] = SPxSolverBase<R>::ON_LOWER;
       }
-   }
-
-   // compute slacks
-   ///@todo we should compute them one by one so we can abort when encountering an infeasibility
-   _workSol._slacks.reDim(numRowsRational());
-   _rationalLP->computePrimalActivity(_workSol._primal, _workSol._slacks);
-
-   // check violation of sides
-   for(int r = numRowsRational() - 1; r >= 0; r--)
-   {
-      // we want to notify the user whether the reconstructed solution is basic; otherwise, this would be redundant
-      typename SPxSolverBase<R>::VarStatus& basisStatusRow = _basisStatusRows[r];
-
-      if((basisStatusRow == SPxSolverBase<R>::FIXED && _workSol._slacks[r] != lhsRational(r))
-            || (basisStatusRow == SPxSolverBase<R>::ON_LOWER && _workSol._slacks[r] != lhsRational(r))
-            || (basisStatusRow == SPxSolverBase<R>::ON_UPPER && _workSol._slacks[r] != rhsRational(r))
-            || (basisStatusRow == SPxSolverBase<R>::ZERO && _workSol._slacks[r] != 0)
-            || (basisStatusRow == SPxSolverBase<R>::UNDEFINED))
-      {
-         isSolBasic = false;
+    } else if ((!maximizing && sig < 0) || (maximizing && sig > 0)) {
+      if (!_upperFinite(_rowTypes[r]) || _workSol._slacks[r] < rhsRational(r)) {
+        MSG_DEBUG(std::cout << "complementary slackness violated by row " << r
+                            << " with dual " << _workSol._dual[r].str()
+                            << " and slack " << _workSol._slacks[r].str()
+                            << " not at rhs " << rhsRational(r).str() << "\n");
+        MSG_INFO1(spxout,
+                  spxout << "Reconstructed solution dual infeasible (2).\n");
+        _statistics->reconstructionTime->stop();
+        return false;
       }
 
-      if(_lowerFinite(_rowTypes[r]) && _workSol._slacks[r] < lhsRational(r))
-      {
-         MSG_DEBUG(std::cout << "Lhs of row " << r << " violated by " <<
-                   (lhsRational(r) - _workSol._slacks[r]).str() << "\n");
-         MSG_INFO1(spxout, spxout << "Reconstructed solution primal infeasible (3).\n");
-         _statistics->reconstructionTime->stop();
-         return false;
+      if (_basisStatusRows[r] != SPxSolverBase<R>::ON_UPPER &&
+          _basisStatusRows[r] != SPxSolverBase<R>::FIXED) {
+        if (_basisStatusRows[r] == SPxSolverBase<R>::BASIC ||
+            _basisStatusRows[r] == SPxSolverBase<R>::UNDEFINED)
+          isSolBasic = false;
+        else
+          _basisStatusRows[r] = SPxSolverBase<R>::ON_UPPER;
       }
-
-      if(_upperFinite(_rowTypes[r]) && _workSol._slacks[r] > rhsRational(r))
-      {
-         MSG_DEBUG(std::cout << "Rhs of row " << r << " violated by " <<
-                   (_workSol._slacks[r] - rhsRational(r)) << "\n");
-         MSG_INFO1(spxout, spxout << "Reconstructed solution primal infeasible (4).\n");
-         _statistics->reconstructionTime->stop();
-         return false;
+    }
+  }
+
+  // compute reduced cost vector; we assume that the objective function vector
+  // has less nonzeros than the reduced cost vector, and so multiplying with -1
+  // first and subtracting the dual activity should be faster than adding the
+  // dual activity and negating afterwards
+  ///@todo we should compute them one by one so we can abort when encountering
+  ///an infeasibility
+  _workSol._redCost.reDim(numColsRational());
+  _rationalLP->getObj(_workSol._redCost);
+  _rationalLP->subDualActivity(_workSol._dual, _workSol._redCost);
+
+  // check reduced cost violation
+  for (int c = numColsRational() - 1; c >= 0; c--) {
+    int sig = sign(_workSol._redCost[c]);
+
+    if ((!maximizing && sig > 0) || (maximizing && sig < 0)) {
+      if (!_lowerFinite(_colTypes[c]) ||
+          _workSol._primal[c] > lowerRational(c)) {
+        MSG_DEBUG(std::cout
+                  << "complementary slackness violated by column " << c
+                  << " with reduced cost " << _workSol._redCost[c].str()
+                  << " and value " << _workSol._primal[c].str()
+                  << " not at lower bound " << lowerRational(c).str() << "\n");
+        MSG_INFO1(spxout,
+                  spxout << "Reconstructed solution dual infeasible (3).\n");
+        _statistics->reconstructionTime->stop();
+        return false;
       }
-   }
-
-   // reconstruct dual vector
-   _workSol._dual = sol._dual;
-
-   success = reconstructVector(_workSol._dual, denomBoundSquared);
-
-   if(!success)
-   {
-      MSG_INFO1(spxout, spxout << "Rational reconstruction of dual solution failed.\n");
-      _statistics->reconstructionTime->stop();
-      return success;
-   }
-
-   MSG_DEBUG(spxout << "Rational reconstruction of dual vector successful.\n");
-
-   // check dual multipliers before reduced costs because this check is faster since it does not require the
-   // computation of reduced costs
-   const bool maximizing = (intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MAXIMIZE);
 
-   for(int r = numRowsRational() - 1; r >= 0; r--)
-   {
-      int sig = sign(_workSol._dual[r]);
-
-      if((!maximizing && sig > 0) || (maximizing && sig < 0))
-      {
-         if(!_lowerFinite(_rowTypes[r]) || _workSol._slacks[r] > lhsRational(r))
-         {
-            MSG_DEBUG(std::cout << "complementary slackness violated by row " << r
-                      << " with dual " << _workSol._dual[r].str()
-                      << " and slack " << _workSol._slacks[r].str()
-                      << " not at lhs " << lhsRational(r).str()
-                      << "\n");
-            MSG_INFO1(spxout, spxout << "Reconstructed solution dual infeasible (1).\n");
-            _statistics->reconstructionTime->stop();
-            return false;
-         }
-
-         if(_basisStatusRows[r] != SPxSolverBase<R>::ON_LOWER
-               && _basisStatusRows[r] != SPxSolverBase<R>::FIXED)
-         {
-            if(_basisStatusRows[r] == SPxSolverBase<R>::BASIC
-                  || _basisStatusRows[r] == SPxSolverBase<R>::UNDEFINED)
-               isSolBasic = false;
-            else
-               _basisStatusRows[r] = SPxSolverBase<R>::ON_LOWER;
-         }
-      }
-      else if((!maximizing && sig < 0) || (maximizing && sig > 0))
-      {
-         if(!_upperFinite(_rowTypes[r]) || _workSol._slacks[r] < rhsRational(r))
-         {
-            MSG_DEBUG(std::cout << "complementary slackness violated by row " << r
-                      << " with dual " << _workSol._dual[r].str()
-                      << " and slack " << _workSol._slacks[r].str()
-                      << " not at rhs " << rhsRational(r).str()
-                      << "\n");
-            MSG_INFO1(spxout, spxout << "Reconstructed solution dual infeasible (2).\n");
-            _statistics->reconstructionTime->stop();
-            return false;
-         }
-
-         if(_basisStatusRows[r] != SPxSolverBase<R>::ON_UPPER
-               && _basisStatusRows[r] != SPxSolverBase<R>::FIXED)
-         {
-            if(_basisStatusRows[r] == SPxSolverBase<R>::BASIC
-                  || _basisStatusRows[r] == SPxSolverBase<R>::UNDEFINED)
-               isSolBasic = false;
-            else
-               _basisStatusRows[r] = SPxSolverBase<R>::ON_UPPER;
-         }
+      if (_basisStatusCols[c] != SPxSolverBase<R>::ON_LOWER &&
+          _basisStatusCols[c] != SPxSolverBase<R>::FIXED) {
+        if (_basisStatusCols[c] == SPxSolverBase<R>::BASIC ||
+            _basisStatusCols[c] == SPxSolverBase<R>::UNDEFINED)
+          isSolBasic = false;
+        else
+          _basisStatusCols[c] = SPxSolverBase<R>::ON_LOWER;
       }
-   }
-
-   // compute reduced cost vector; we assume that the objective function vector has less nonzeros than the reduced
-   // cost vector, and so multiplying with -1 first and subtracting the dual activity should be faster than adding
-   // the dual activity and negating afterwards
-   ///@todo we should compute them one by one so we can abort when encountering an infeasibility
-   _workSol._redCost.reDim(numColsRational());
-   _rationalLP->getObj(_workSol._redCost);
-   _rationalLP->subDualActivity(_workSol._dual, _workSol._redCost);
-
-   // check reduced cost violation
-   for(int c = numColsRational() - 1; c >= 0; c--)
-   {
-      int sig = sign(_workSol._redCost[c]);
-
-      if((!maximizing && sig > 0) || (maximizing && sig < 0))
-      {
-         if(!_lowerFinite(_colTypes[c]) || _workSol._primal[c] > lowerRational(c))
-         {
-            MSG_DEBUG(std::cout << "complementary slackness violated by column " << c
-                      << " with reduced cost " << _workSol._redCost[c].str()
-                      << " and value " << _workSol._primal[c].str()
-                      << " not at lower bound " << lowerRational(c).str()
-                      << "\n");
-            MSG_INFO1(spxout, spxout << "Reconstructed solution dual infeasible (3).\n");
-            _statistics->reconstructionTime->stop();
-            return false;
-         }
-
-         if(_basisStatusCols[c] != SPxSolverBase<R>::ON_LOWER
-               && _basisStatusCols[c] != SPxSolverBase<R>::FIXED)
-         {
-            if(_basisStatusCols[c] == SPxSolverBase<R>::BASIC
-                  || _basisStatusCols[c] == SPxSolverBase<R>::UNDEFINED)
-               isSolBasic = false;
-            else
-               _basisStatusCols[c] = SPxSolverBase<R>::ON_LOWER;
-         }
+    } else if ((!maximizing && sig < 0) || (maximizing && sig > 0)) {
+      if (!_upperFinite(_colTypes[c]) ||
+          _workSol._primal[c] < upperRational(c)) {
+        MSG_DEBUG(std::cout
+                  << "complementary slackness violated by column " << c
+                  << " with reduced cost " << _workSol._redCost[c].str()
+                  << " and value " << _workSol._primal[c].str()
+                  << " not at upper bound " << upperRational(c).str() << "\n");
+        MSG_INFO1(spxout,
+                  spxout << "Reconstructed solution dual infeasible (4).\n");
+        _statistics->reconstructionTime->stop();
+        return false;
       }
-      else if((!maximizing && sig < 0) || (maximizing && sig > 0))
-      {
-         if(!_upperFinite(_colTypes[c]) || _workSol._primal[c] < upperRational(c))
-         {
-            MSG_DEBUG(std::cout << "complementary slackness violated by column " << c
-                      << " with reduced cost " << _workSol._redCost[c].str()
-                      << " and value " << _workSol._primal[c].str()
-                      << " not at upper bound " << upperRational(c).str()
-                      << "\n");
-            MSG_INFO1(spxout, spxout << "Reconstructed solution dual infeasible (4).\n");
-            _statistics->reconstructionTime->stop();
-            return false;
-         }
-
-         if(_basisStatusCols[c] != SPxSolverBase<R>::ON_UPPER
-               && _basisStatusCols[c] != SPxSolverBase<R>::FIXED)
-         {
-            if(_basisStatusCols[c] == SPxSolverBase<R>::BASIC
-                  || _basisStatusCols[c] == SPxSolverBase<R>::UNDEFINED)
-               isSolBasic = false;
-            else
-               _basisStatusCols[c] = SPxSolverBase<R>::ON_UPPER;
-         }
+
+      if (_basisStatusCols[c] != SPxSolverBase<R>::ON_UPPER &&
+          _basisStatusCols[c] != SPxSolverBase<R>::FIXED) {
+        if (_basisStatusCols[c] == SPxSolverBase<R>::BASIC ||
+            _basisStatusCols[c] == SPxSolverBase<R>::UNDEFINED)
+          isSolBasic = false;
+        else
+          _basisStatusCols[c] = SPxSolverBase<R>::ON_UPPER;
       }
-   }
+    }
+  }
 
-   // update solution
-   sol._primal = _workSol._primal;
-   sol._slacks = _workSol._slacks;
-   sol._dual = _workSol._dual;
-   sol._redCost = _workSol._redCost;
+  // update solution
+  sol._primal = _workSol._primal;
+  sol._slacks = _workSol._slacks;
+  sol._dual = _workSol._dual;
+  sol._redCost = _workSol._redCost;
 
-   if(!isSolBasic)
-   {
-      MSG_WARNING(spxout, spxout << "Warning: Reconstructed solution not basic.\n");
-      _hasBasis = false;
-   }
+  if (!isSolBasic) {
+    MSG_WARNING(spxout,
+                spxout << "Warning: Reconstructed solution not basic.\n");
+    _hasBasis = false;
+  }
 
-   // stop timing
-   _statistics->reconstructionTime->stop();
+  // stop timing
+  _statistics->reconstructionTime->stop();
 
-   return success;
+  return success;
 }
 } // namespace soplex
diff --git a/src/soplex/solvereal.hpp b/src/soplex/solvereal.hpp
index 657149a..4d5f394 100644
--- a/src/soplex/solvereal.hpp
+++ b/src/soplex/solvereal.hpp
@@ -21,744 +21,730 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
-#include <iostream>
 #include <assert.h>
+#include <iostream>
 
 #include "soplex.h"
 #include "soplex/statistics.h"
 
-#define ALLOWED_UNSCALE_PERCENTAGE    0.1
-#define MIN_OPT_CALLS_WITH_SCALING     10
+#define ALLOWED_UNSCALE_PERCENTAGE 0.1
+#define MIN_OPT_CALLS_WITH_SCALING 10
 
-namespace soplex
-{
+namespace soplex {
 /// solves real LP
-template <class R>
-void SoPlexBase<R>::_optimize(volatile bool* interrupt)
-{
-   assert(_realLP != 0);
-   assert(_realLP == &_solver);
-
-   _solReal.invalidate();
-   ++_optimizeCalls;
-
-   // start timing
-   _statistics->solvingTime->start();
-
-   if(boolParam(SoPlexBase<R>::PERSISTENTSCALING))
-   {
-      // scale original problem; overwriting _realLP
-      if(_scaler && !_realLP->isScaled() && _reapplyPersistentScaling())
-      {
+template <class R> void SoPlexBase<R>::_optimize(volatile bool *interrupt) {
+  assert(_realLP != 0);
+  assert(_realLP == &_solver);
+
+  _solReal.invalidate();
+  ++_optimizeCalls;
+
+  // start timing
+  _statistics->solvingTime->start();
+
+  if (boolParam(SoPlexBase<R>::PERSISTENTSCALING)) {
+    // scale original problem; overwriting _realLP
+    if (_scaler && !_realLP->isScaled() && _reapplyPersistentScaling()) {
 #ifdef SOPLEX_DEBUG
-         SPxLPBase<R>* origLP = 0;
-         spx_alloc(origLP);
-         origLP = new(origLP) SPxLPBase<R>(*_realLP);
+      SPxLPBase<R> *origLP = 0;
+      spx_alloc(origLP);
+      origLP = new (origLP) SPxLPBase<R>(*_realLP);
 #endif
-         _scaler->scale(*_realLP, true);
-         _isRealLPScaled = _realLP->isScaled(); // a scaler might decide not to apply scaling
-         _solver.invalidateBasis();
+      _scaler->scale(*_realLP, true);
+      _isRealLPScaled =
+          _realLP->isScaled(); // a scaler might decide not to apply scaling
+      _solver.invalidateBasis();
 #ifdef SOPLEX_DEBUG
-         _checkScaling(origLP);
+      _checkScaling(origLP);
 #endif
-      }
-      // unscale previously scaled problem, overwriting _realLP
-      else if(!_scaler && _realLP->isScaled())
-      {
-         _solver.unscaleLPandReloadBasis();
-         _isRealLPScaled = false;
-         ++_unscaleCalls;
-      }
-   }
-
-   // remember that last solve was in floating-point
-   _lastSolveMode = SOLVEMODE_REAL;
-
-   // solve and store solution; if we have a starting basis, do not apply preprocessing; if we are solving from
-   // scratch, apply preprocessing according to parameter settings
-   if(!_hasBasis && realParam(SoPlexBase<R>::OBJLIMIT_LOWER) == -realParam(SoPlexBase<R>::INFTY)
-         && realParam(SoPlexBase<R>::OBJLIMIT_UPPER) == realParam(SoPlexBase<R>::INFTY))
-      _preprocessAndSolveReal(true, interrupt);
-   else
-      _preprocessAndSolveReal(false, interrupt);
-
-   _statistics->finalBasisCondition = _solver.getBasisMetric(0);
-
-   // stop timing
-   _statistics->solvingTime->stop();
+    }
+    // unscale previously scaled problem, overwriting _realLP
+    else if (!_scaler && _realLP->isScaled()) {
+      _solver.unscaleLPandReloadBasis();
+      _isRealLPScaled = false;
+      ++_unscaleCalls;
+    }
+  }
+
+  // remember that last solve was in floating-point
+  _lastSolveMode = SOLVEMODE_REAL;
+
+  // solve and store solution; if we have a starting basis, do not apply
+  // preprocessing; if we are solving from scratch, apply preprocessing
+  // according to parameter settings
+  if (!_hasBasis &&
+      realParam(SoPlexBase<R>::OBJLIMIT_LOWER) ==
+          -realParam(SoPlexBase<R>::INFTY) &&
+      realParam(SoPlexBase<R>::OBJLIMIT_UPPER) ==
+          realParam(SoPlexBase<R>::INFTY))
+    _preprocessAndSolveReal(true, interrupt);
+  else
+    _preprocessAndSolveReal(false, interrupt);
+
+  _statistics->finalBasisCondition = _solver.getBasisMetric(0);
+
+  // stop timing
+  _statistics->solvingTime->stop();
 }
 
-
-
-/// check whether persistent scaling is supposed to be reapplied again after unscaling
-template <class R>
-bool SoPlexBase<R>::_reapplyPersistentScaling() const
-{
-   if((_unscaleCalls > _optimizeCalls * ALLOWED_UNSCALE_PERCENTAGE)
-         && _optimizeCalls > MIN_OPT_CALLS_WITH_SCALING)
-      return false;
-   else
-      return true;
+/// check whether persistent scaling is supposed to be reapplied again after
+/// unscaling
+template <class R> bool SoPlexBase<R>::_reapplyPersistentScaling() const {
+  if ((_unscaleCalls > _optimizeCalls * ALLOWED_UNSCALE_PERCENTAGE) &&
+      _optimizeCalls > MIN_OPT_CALLS_WITH_SCALING)
+    return false;
+  else
+    return true;
 }
 
-
-
-/// checks result of the solving process and solves again without preprocessing if necessary
+/// checks result of the solving process and solves again without preprocessing
+/// if necessary
 template <class R>
-void SoPlexBase<R>::_evaluateSolutionReal(typename SPxSimplifier<R>::Result simplificationStatus)
-{
-   // if the simplifier detected infeasibility or unboundedness we optimize again
-   // just to get the proof (primal or dual ray)
-   // todo get infeasibility proof from simplifier
-   switch(simplificationStatus)
-   {
-   case SPxSimplifier<R>::INFEASIBLE:
-   case SPxSimplifier<R>::DUAL_INFEASIBLE:
-   case SPxSimplifier<R>::UNBOUNDED:
-      _hasBasis = false;
-
-      if(boolParam(SoPlexBase<R>::ENSURERAY))
-      {
-         MSG_INFO1(spxout, spxout <<
-                   "simplifier detected infeasibility or unboundedness - solve again without simplifying" << std::endl;
-                  )
-         _preprocessAndSolveReal(false);
-      }
+void SoPlexBase<R>::_evaluateSolutionReal(
+    typename SPxSimplifier<R>::Result simplificationStatus) {
+  // if the simplifier detected infeasibility or unboundedness we optimize again
+  // just to get the proof (primal or dual ray)
+  // todo get infeasibility proof from simplifier
+  switch (simplificationStatus) {
+  case SPxSimplifier<R>::INFEASIBLE:
+  case SPxSimplifier<R>::DUAL_INFEASIBLE:
+  case SPxSimplifier<R>::UNBOUNDED:
+    _hasBasis = false;
+
+    if (boolParam(SoPlexBase<R>::ENSURERAY)) {
+      MSG_INFO1(spxout, spxout
+                            << "simplifier detected infeasibility or "
+                               "unboundedness - solve again without simplifying"
+                            << std::endl;)
+      _preprocessAndSolveReal(false);
+    } else {
+      if (simplificationStatus == SPxSimplifier<R>::INFEASIBLE)
+        _status = SPxSolverBase<R>::INFEASIBLE;
+      else if (simplificationStatus == SPxSimplifier<R>::UNBOUNDED)
+        _status = SPxSolverBase<R>::UNBOUNDED;
       else
-      {
-         if(simplificationStatus == SPxSimplifier<R>::INFEASIBLE)
-            _status = SPxSolverBase<R>::INFEASIBLE;
-         else if(simplificationStatus == SPxSimplifier<R>::UNBOUNDED)
-            _status = SPxSolverBase<R>::UNBOUNDED;
-         else
-            _status = SPxSolverBase<R>::INForUNBD;
-
-         // load original LP to restore clean solver state
-         _loadRealLP(false);
-      }
+        _status = SPxSolverBase<R>::INForUNBD;
 
-      return;
-
-   case SPxSimplifier<R>::VANISHED:
-      _status = SPxSolverBase<R>::OPTIMAL;
-      _storeSolutionRealFromPresol();
-      return;
-
-   case SPxSimplifier<R>::OKAY:
-      _status = _solver.status();
-   }
-
-   // process result
-   switch(_status)
-   {
-   case SPxSolverBase<R>::OPTIMAL:
-      _storeSolutionReal(!_isRealLPLoaded || _isRealLPScaled);
-
-      // apply polishing on original problem
-      if(_applyPolishing)
-      {
-         int polishing = intParam(SoPlexBase<R>::SOLUTION_POLISHING);
-         setIntParam(SoPlexBase<R>::SOLUTION_POLISHING, polishing);
-         _preprocessAndSolveReal(false);
-      }
-
-      break;
-
-   case SPxSolverBase<R>::UNBOUNDED:
-   case SPxSolverBase<R>::INFEASIBLE:
-   case SPxSolverBase<R>::INForUNBD:
-
-      // in case of infeasibility or unboundedness, we currently can not unsimplify, but have to solve the original LP again
-      if(!_isRealLPLoaded && boolParam(SoPlexBase<R>::ENSURERAY))
-      {
-         MSG_INFO1(spxout, spxout << " --- loading original problem" << std::endl;)
-         _solver.changeObjOffset(realParam(SoPlexBase<R>::OBJ_OFFSET));
-         // we cannot do more to remove violations
-         _resolveWithoutPreprocessing(simplificationStatus);
-      }
-      else
-      {
-         _storeSolutionReal(false);
-      }
+      // load original LP to restore clean solver state
+      _loadRealLP(false);
+    }
 
-      break;
+    return;
 
-   case SPxSolverBase<R>::SINGULAR:
+  case SPxSimplifier<R>::VANISHED:
+    _status = SPxSolverBase<R>::OPTIMAL;
+    _storeSolutionRealFromPresol();
+    return;
 
-      // if preprocessing was applied, try to run again without to avoid singularity
-      if(!_isRealLPLoaded)
-      {
-         MSG_INFO1(spxout, spxout << "encountered singularity - trying to solve again without simplifying" <<
-                   std::endl;)
-         _preprocessAndSolveReal(false);
-         return;
-      }
+  case SPxSimplifier<R>::OKAY:
+    _status = _solver.status();
+  }
 
-      _hasBasis = false;
-      break;
-
-   case SPxSolverBase<R>::ABORT_CYCLING:
-
-      // if preprocessing or scaling was applied, try to run again without to
-      // avoid cycling
-      if(!_isRealLPLoaded || _isRealLPScaled)
-      {
-         MSG_INFO1(spxout, spxout << "encountered cycling - trying to solve again without simplifying" <<
-                   std::endl;)
-         // store and unsimplify sub-optimal solution and basis, may trigger re-solve
-         _storeSolutionReal(true);
-         return;
-      }
-
-      if(_solReal.isPrimalFeasible() || _solReal.isDualFeasible())
-         _status = SPxSolverBase<R>::OPTIMAL_UNSCALED_VIOLATIONS;
-
-   // FALLTHROUGH
-   case SPxSolverBase<R>::ABORT_TIME:
-   case SPxSolverBase<R>::ABORT_ITER:
-   case SPxSolverBase<R>::ABORT_VALUE:
-   case SPxSolverBase<R>::REGULAR:
-   case SPxSolverBase<R>::RUNNING:
-
-      // If we aborted the solve for some reason and there is still a shift, ensure that the basis status is correct
-      if(_solver.shift() > _solver.epsilon())
-         _solver.setBasisStatus(SPxBasisBase<R>::REGULAR);
+  // process result
+  switch (_status) {
+  case SPxSolverBase<R>::OPTIMAL:
+    _storeSolutionReal(!_isRealLPLoaded || _isRealLPScaled);
 
+    // apply polishing on original problem
+    if (_applyPolishing) {
+      int polishing = intParam(SoPlexBase<R>::SOLUTION_POLISHING);
+      setIntParam(SoPlexBase<R>::SOLUTION_POLISHING, polishing);
+      _preprocessAndSolveReal(false);
+    }
+
+    break;
+
+  case SPxSolverBase<R>::UNBOUNDED:
+  case SPxSolverBase<R>::INFEASIBLE:
+  case SPxSolverBase<R>::INForUNBD:
+
+    // in case of infeasibility or unboundedness, we currently can not
+    // unsimplify, but have to solve the original LP again
+    if (!_isRealLPLoaded && boolParam(SoPlexBase<R>::ENSURERAY)) {
+      MSG_INFO1(spxout, spxout << " --- loading original problem" << std::endl;)
+      _solver.changeObjOffset(realParam(SoPlexBase<R>::OBJ_OFFSET));
+      // we cannot do more to remove violations
+      _resolveWithoutPreprocessing(simplificationStatus);
+    } else {
       _storeSolutionReal(false);
-      break;
-
-   default:
-      _hasBasis = false;
-      break;
-   }
-}
-
-
-
-/// solves real LP with/without preprocessing
-template <class R>
-void SoPlexBase<R>::_preprocessAndSolveReal(bool applySimplifier, volatile bool* interrupt)
-{
-   _solver.changeObjOffset(realParam(SoPlexBase<R>::OBJ_OFFSET));
-   _statistics->preprocessingTime->start();
-
-   _applyPolishing = false;
-
-   if(applySimplifier)
-      _enableSimplifierAndScaler();
-   else
-      _disableSimplifierAndScaler();
-
-   // create a copy of the LP when simplifying or when using internal scaling, i.e. w/o persistent scaling
-   bool copyLP = (_simplifier != 0 || (_scaler && !_isRealLPScaled));
-
-   _solver.setTerminationValue(intParam(SoPlexBase<R>::OBJSENSE) == SoPlexBase<R>::OBJSENSE_MINIMIZE
-                               ? realParam(SoPlexBase<R>::OBJLIMIT_UPPER) : realParam(SoPlexBase<R>::OBJLIMIT_LOWER));
-
-   if(_isRealLPLoaded)
-   {
-      assert(_realLP == &_solver);
-
-      // preprocessing is always applied to the LP in the solver; hence we have to create a copy of the original LP
-      // if simplifier is turned on
-      if(copyLP)
-      {
-         _realLP = nullptr;
-         spx_alloc(_realLP);
-         _realLP = new(_realLP) SPxLPBase<R>(_solver);
-         _isRealLPLoaded = false;
-      }
-   }
-   else
-   {
-      assert(_realLP != &_solver);
-
-      // load real LP and basis if available
-      if(_hasBasis)
-      {
-         assert(_basisStatusRows.size() == numRows());
-         assert(_basisStatusCols.size() == this->numCols());
-
-         _solver.loadLP(*_realLP, false);
-         _solver.setBasis(_basisStatusRows.get_const_ptr(), _basisStatusCols.get_const_ptr());
-      }
-      // load real LP and set up slack basis
-      else
-         _solver.loadLP(*_realLP, true);
-
-      // if there is no simplifier, then the original and the transformed problem are identical and it is more
-      // memory-efficient to keep only the problem in the solver
-      if(!copyLP)
-      {
-         _realLP->~SPxLPBase<R>();
-         spx_free(_realLP);
-         _realLP = &_solver;
-         _isRealLPLoaded = true;
-      }
-   }
-
-   // assert that we have two problems if and only if we apply the simplifier
-   assert(_realLP == &_solver || copyLP);
-   assert(_realLP != &_solver || !copyLP);
-
-   // apply problem simplification
-   typename SPxSimplifier<R>::Result simplificationStatus = SPxSimplifier<R>::OKAY;
-
-   if(_simplifier)
-   {
-      assert(!_isRealLPLoaded);
-      // do not remove bounds of boxed variables or sides of ranged rows if bound flipping is used; also respect row-boundflip parameter
-      bool keepbounds = intParam(SoPlexBase<R>::RATIOTESTER) == SoPlexBase<R>::RATIOTESTER_BOUNDFLIPPING;
-
-      if(intParam(SoPlexBase<R>::REPRESENTATION) == SoPlexBase<R>::REPRESENTATION_ROW
-            || (intParam(SoPlexBase<R>::REPRESENTATION) == SoPlexBase<R>::REPRESENTATION_AUTO
-                && (_solver.nCols() + 1) * realParam(SoPlexBase<R>::REPRESENTATION_SWITCH) < (_solver.nRows() + 1)))
-         keepbounds &= boolParam(SoPlexBase<R>::ROWBOUNDFLIPS);
-
-      Real remainingTime = _solver.getMaxTime() - _solver.time();
-      simplificationStatus = _simplifier->simplify(_solver, realParam(SoPlexBase<R>::EPSILON_ZERO),
-                             realParam(SoPlexBase<R>::FEASTOL), realParam(SoPlexBase<R>::OPTTOL), remainingTime, keepbounds,
-                             _solver.random.getSeed());
-      _solver.changeObjOffset(_simplifier->getObjoffset() + realParam(SoPlexBase<R>::OBJ_OFFSET));
-      _solver.setScalingInfo(false);
-      _applyPolishing = true;
-
-      _solver.setSolutionPolishing(SPxSolverBase<R>::POLISH_OFF);
-   }
-
-   _statistics->preprocessingTime->stop();
-
-   // run the simplex method if problem has not been solved by the simplifier
-   if(simplificationStatus == SPxSimplifier<R>::OKAY)
-   {
-      if(_scaler && !_solver.isScaled())
-      {
-         _scaler->scale(_solver, false);
-         _solver.invalidateBasis();
-      }
-
-      _solveRealLPAndRecordStatistics(interrupt);
-   }
-
-   _evaluateSolutionReal(simplificationStatus);
-}
-
-
-
-/// loads original problem into solver and solves again after it has been solved to infeasibility or unboundedness with preprocessing
-template <class R>
-void SoPlexBase<R>::_resolveWithoutPreprocessing(typename SPxSimplifier<R>::Result
-      simplificationStatus)
-{
-   assert(!_isRealLPLoaded || _scaler != nullptr);
-   assert(_simplifier != 0 || _scaler != nullptr);
-   assert(_status == SPxSolverBase<R>::INFEASIBLE || _status == SPxSolverBase<R>::INForUNBD
-          || _status == SPxSolverBase<R>::UNBOUNDED);
-
-   // if simplifier was active, then we unsimplify to get the basis
-   if(_simplifier)
-   {
-      assert(!_simplifier->isUnsimplified());
-      assert(simplificationStatus == SPxSimplifier<R>::OKAY);
-
-      // get temporary solution vectors for transformed problem
-      VectorBase<R> primal(_solver.nCols());
-      VectorBase<R> slacks(_solver.nRows());
-      VectorBase<R> dual(_solver.nRows());
-      VectorBase<R> redCost(_solver.nCols());
-
-      _basisStatusRows.reSize(numRows());
-      _basisStatusCols.reSize(numCols());
-      assert(_basisStatusRows.size() >= _solver.nRows());
-      assert(_basisStatusCols.size() >= _solver.nCols());
-
-      // get solution data from transformed problem
-      _solver.getPrimalSol(primal);
-      _solver.getSlacks(slacks);
-      _solver.getDualSol(dual);
-      _solver.getRedCostSol(redCost);
-
-      // unscale vectors
-      if(_scaler && _solver.isScaled())
-      {
-         _scaler->unscalePrimal(_solver, primal);
-         _scaler->unscaleSlacks(_solver, slacks);
-         _scaler->unscaleDual(_solver, dual);
-         _scaler->unscaleRedCost(_solver, redCost);
-      }
-
-      // get basis of transformed problem
-      _solver.getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr(), _basisStatusRows.size(),
-                       _basisStatusCols.size());
-
-      try
-      {
-         _simplifier->unsimplify(primal, dual, slacks, redCost, _basisStatusRows.get_ptr(),
-                                 _basisStatusCols.get_ptr(), false);
-         _simplifier->getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr(),
-                               _basisStatusRows.size(), _basisStatusCols.size());
-         _hasBasis = true;
-      }
-      catch(const SPxException& E)
-      {
-         MSG_INFO1(spxout, spxout << "Caught exception <" << E.what() <<
-                   "> during unsimplification. Resolving without simplifier and scaler.\n");
-         _hasBasis = false;
-      }
-   }
-   // if the original problem is not in the solver because of scaling, we also need to store the basis
-   else if(_scaler != nullptr)
-   {
-      _basisStatusRows.reSize(numRows());
-      _basisStatusCols.reSize(numCols());
-      assert(_basisStatusRows.size() == _solver.nRows());
-      assert(_basisStatusCols.size() == _solver.nCols());
-
-      _solver.getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr(), _basisStatusRows.size(),
-                       _basisStatusCols.size());
-      _hasBasis = true;
-   }
-
-   // resolve the original problem
-   _preprocessAndSolveReal(false);
-   return;
-}
+    }
 
+    break;
 
+  case SPxSolverBase<R>::SINGULAR:
 
-/// verify computed solution based on status and resolve if claimed primal or dual feasibility is not fulfilled
-template <class R>
-void SoPlexBase<R>::_verifySolutionReal()
-{
-   assert(_hasSolReal);
-
-   MSG_INFO1(spxout, spxout << " --- verifying computed solution" << std::endl;)
-
-   R sumviol = 0;
-   R boundviol = 0;
-   R rowviol = 0;
-   R dualviol = 0;
-   R redcostviol = 0;
-
-   (void) getBoundViolation(boundviol, sumviol);
-   (void) getRowViolation(rowviol, sumviol);
-   (void) getDualViolation(dualviol, sumviol);
-   (void) getRedCostViolation(redcostviol, sumviol);
-
-   if(boundviol >= _solver.feastol() || rowviol >= _solver.feastol() || dualviol >= _solver.opttol()
-         || redcostviol >= _solver.opttol())
-   {
-      assert(&_solver == _realLP);
-      assert(_isRealLPLoaded);
-      MSG_INFO3(spxout, spxout << "bound violation: " << boundviol
-                << ", row violation: " << rowviol
-                << ", dual violation: " << dualviol
-                << ", redcost violation: " << redcostviol << std::endl;)
-      MSG_INFO1(spxout, spxout <<
-                " --- detected violations in original problem space -- solve again without presolving/scaling" <<
-                std::endl;)
-
-      if(_isRealLPScaled)
-      {
-         _solver.unscaleLPandReloadBasis();
-         _isRealLPScaled = false;
-         ++_unscaleCalls;
-      }
-
+    // if preprocessing was applied, try to run again without to avoid
+    // singularity
+    if (!_isRealLPLoaded) {
+      MSG_INFO1(spxout, spxout << "encountered singularity - trying to solve "
+                                  "again without simplifying"
+                               << std::endl;)
       _preprocessAndSolveReal(false);
-   }
+      return;
+    }
+
+    _hasBasis = false;
+    break;
+
+  case SPxSolverBase<R>::ABORT_CYCLING:
+
+    // if preprocessing or scaling was applied, try to run again without to
+    // avoid cycling
+    if (!_isRealLPLoaded || _isRealLPScaled) {
+      MSG_INFO1(spxout, spxout << "encountered cycling - trying to solve again "
+                                  "without simplifying"
+                               << std::endl;)
+      // store and unsimplify sub-optimal solution and basis, may trigger
+      // re-solve
+      _storeSolutionReal(true);
+      return;
+    }
+
+    if (_solReal.isPrimalFeasible() || _solReal.isDualFeasible())
+      _status = SPxSolverBase<R>::OPTIMAL_UNSCALED_VIOLATIONS;
+
+  // FALLTHROUGH
+  case SPxSolverBase<R>::ABORT_TIME:
+  case SPxSolverBase<R>::ABORT_ITER:
+  case SPxSolverBase<R>::ABORT_VALUE:
+  case SPxSolverBase<R>::REGULAR:
+  case SPxSolverBase<R>::RUNNING:
+
+    // If we aborted the solve for some reason and there is still a shift,
+    // ensure that the basis status is correct
+    if (_solver.shift() > _solver.epsilon())
+      _solver.setBasisStatus(SPxBasisBase<R>::REGULAR);
+
+    _storeSolutionReal(false);
+    break;
+
+  default:
+    _hasBasis = false;
+    break;
+  }
 }
 
-
-/// stores solution data from the solver, possibly after applying unscaling and unsimplifying
+/// solves real LP with/without preprocessing
 template <class R>
-void SoPlexBase<R>::_storeSolutionReal(bool verify)
-{
-   // prepare storage for basis (enough to fit the original basis)
-   _basisStatusRows.reSize(numRows());
-   _basisStatusCols.reSize(numCols());
-
-   // prepare storage for the solution data (only in transformed space due to unscaling), w/o setting it to zero
-   _solReal._primal.reDim(_solver.nCols(), false);
-   _solReal._slacks.reDim(_solver.nRows(), false);
-   _solReal._dual.reDim(_solver.nRows(), false);
-   _solReal._redCost.reDim(_solver.nCols(), false);
-
-   // check primal status consistency and query solution status
-   assert(_solver.basis().status() != SPxBasisBase<R>::PRIMAL || status() != SPxSolverBase<R>::ERROR);
-   assert(_solver.basis().status() != SPxBasisBase<R>::PRIMAL
-          || status() != SPxSolverBase<R>::NO_RATIOTESTER);
-   assert(_solver.basis().status() != SPxBasisBase<R>::PRIMAL
-          || status() != SPxSolverBase<R>::NO_PRICER);
-   assert(_solver.basis().status() != SPxBasisBase<R>::PRIMAL
-          || status() != SPxSolverBase<R>::NO_SOLVER);
-   assert(_solver.basis().status() != SPxBasisBase<R>::PRIMAL
-          || status() != SPxSolverBase<R>::NOT_INIT);
-   assert(_solver.basis().status() != SPxBasisBase<R>::PRIMAL
-          || status() != SPxSolverBase<R>::SINGULAR);
-   assert(_solver.basis().status() != SPxBasisBase<R>::PRIMAL
-          || status() != SPxSolverBase<R>::NO_PROBLEM);
-   assert(_solver.basis().status() != SPxBasisBase<R>::PRIMAL
-          || status() != SPxSolverBase<R>::UNBOUNDED);
-   assert(_solver.basis().status() != SPxBasisBase<R>::PRIMAL
-          || status() != SPxSolverBase<R>::INFEASIBLE);
-   assert(_solver.basis().status() != SPxBasisBase<R>::UNBOUNDED
-          || status() == SPxSolverBase<R>::UNBOUNDED);
-   assert(_solver.basis().status() == SPxBasisBase<R>::UNBOUNDED
-          || _solver.basis().status() == SPxBasisBase<R>::NO_PROBLEM
-          || status() != SPxSolverBase<R>::UNBOUNDED);
-
-   _solReal._isPrimalFeasible = (status() == SPxSolverBase<R>::OPTIMAL
-                                 || ((_solver.basis().status() == SPxBasisBase<R>::PRIMAL
-                                      || _solver.basis().status() == SPxBasisBase<R>::UNBOUNDED)
-                                     && _solver.shift() < 10.0 * realParam(SoPlexBase<R>::EPSILON_ZERO)));
-
-   _solReal._hasPrimalRay = (status() == SPxSolverBase<R>::UNBOUNDED && _isRealLPLoaded);
-
-   // check dual status consistency and query solution status
-   assert(_solver.basis().status() != SPxBasisBase<R>::DUAL || status() != SPxSolverBase<R>::ERROR);
-   assert(_solver.basis().status() != SPxBasisBase<R>::DUAL
-          || status() != SPxSolverBase<R>::NO_RATIOTESTER);
-   assert(_solver.basis().status() != SPxBasisBase<R>::DUAL
-          || status() != SPxSolverBase<R>::NO_PRICER);
-   assert(_solver.basis().status() != SPxBasisBase<R>::DUAL
-          || status() != SPxSolverBase<R>::NO_SOLVER);
-   assert(_solver.basis().status() != SPxBasisBase<R>::DUAL || status() != SPxSolverBase<R>::NOT_INIT);
-   assert(_solver.basis().status() != SPxBasisBase<R>::DUAL || status() != SPxSolverBase<R>::SINGULAR);
-   assert(_solver.basis().status() != SPxBasisBase<R>::DUAL
-          || status() != SPxSolverBase<R>::NO_PROBLEM);
-   assert(_solver.basis().status() != SPxBasisBase<R>::DUAL
-          || status() != SPxSolverBase<R>::UNBOUNDED);
-   assert(_solver.basis().status() != SPxBasisBase<R>::DUAL
-          || status() != SPxSolverBase<R>::INFEASIBLE);
-   assert(_solver.basis().status() != SPxBasisBase<R>::INFEASIBLE
-          || status() == SPxSolverBase<R>::INFEASIBLE);
-   assert(_solver.basis().status() == SPxBasisBase<R>::INFEASIBLE
-          || _solver.basis().status() == SPxBasisBase<R>::NO_PROBLEM
-          || status() != SPxSolverBase<R>::INFEASIBLE);
-
-   _solReal._isDualFeasible = (status() == SPxSolverBase<R>::OPTIMAL
-                               || ((_solver.basis().status() == SPxBasisBase<R>::DUAL
-                                    || _solver.basis().status() == SPxBasisBase<R>::INFEASIBLE)
-                                   && _solver.shift() < 10.0 * realParam(SoPlexBase<R>::EPSILON_ZERO)));
-
-   _solReal._hasDualFarkas = (status() == SPxSolverBase<R>::INFEASIBLE && _isRealLPLoaded);
-
-   // get infeasibility or unboundedness proof if available
-   if(_solReal._hasPrimalRay)
-   {
-      _solReal._primalRay.reDim(_solver.nCols(), false);
-      _solver.getPrimalray(_solReal._primalRay);
-   }
-
-   if(_solReal._hasDualFarkas)
-   {
-      _solReal._dualFarkas.reDim(_solver.nRows(), false);
-      _solver.getDualfarkas(_solReal._dualFarkas);
-   }
-
-   // get solution data from the solver; independent of solution status
-   _solver.getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr(),
-                    _basisStatusRows.size(), _basisStatusCols.size());
-
-   _solver.getPrimalSol(_solReal._primal);
-   _solver.getSlacks(_solReal._slacks);
-   _solver.getDualSol(_solReal._dual);
-   _solver.getRedCostSol(_solReal._redCost);
-
-   _hasBasis = true;
-
-   // get primal and/or dual objective function value depending on status
-   _solver.forceRecompNonbasicValue();
-   _solReal._objVal = _solver.objValue();
-
-   // infeasible solutions shall also be stored and be accessible
-   _hasSolReal = true;
-
-   // unscale vectors
-   if(_solver.isScaled() && !_isRealLPLoaded)
-      _unscaleSolutionReal(_solver, false);
-
-   // get unsimplified solution data from simplifier
-   if(_simplifier)
-   {
-      assert(!_simplifier->isUnsimplified());
-      assert(_simplifier->result() == SPxSimplifier<R>::OKAY);
-      assert(_realLP != &_solver);
-
-      typename SPxBasisBase<R>::SPxStatus simplifiedBasisStatus = _solver.getBasisStatus();
-
-      try
-      {
-         // pass solution data of transformed problem to simplifier
-         _simplifier->unsimplify(_solReal._primal, _solReal._dual, _solReal._slacks, _solReal._redCost,
-                                 _basisStatusRows.get_ptr(), _basisStatusCols.get_ptr(), status() == SPxSolverBase<R>::OPTIMAL);
-      }
-      catch(const SPxException& E)
-      {
-         MSG_INFO1(spxout, spxout << "Caught exception <" << E.what() <<
-                   "> during unsimplification. Resolving without simplifier and scaler.\n");
-         _hasBasis = false;
-         _preprocessAndSolveReal(false);
-         return;
-      }
-
-      // copy unsimplified solution data from simplifier (size and dimension is adapted during copy)
-      _solReal._primal  = _simplifier->unsimplifiedPrimal();
-      _solReal._slacks  = _simplifier->unsimplifiedSlacks();
-      _solReal._dual    = _simplifier->unsimplifiedDual();
-      _solReal._redCost = _simplifier->unsimplifiedRedCost();
-
-      // overwrite the transformed basis with the unsimplified one
-      _simplifier->getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr(),
-                            _basisStatusRows.size(), _basisStatusCols.size());
-
-      // load original problem but don't setup a slack basis
-      _loadRealLP(false);
-
-      // since we presolved the problem, we should not allow access to the dual norms
-      _solver.weightsAreSetup = false;
-
-      assert(_realLP == &_solver);
-
-      // reset basis status
-      _solver.setBasisStatus(simplifiedBasisStatus);
-
-      _solver.setBasis(_basisStatusRows.get_const_ptr(), _basisStatusCols.get_const_ptr());
-      // load unsimplified basis into solver
+void SoPlexBase<R>::_preprocessAndSolveReal(bool applySimplifier,
+                                            volatile bool *interrupt) {
+  _solver.changeObjOffset(realParam(SoPlexBase<R>::OBJ_OFFSET));
+  _statistics->preprocessingTime->start();
+
+  _applyPolishing = false;
+
+  if (applySimplifier)
+    _enableSimplifierAndScaler();
+  else
+    _disableSimplifierAndScaler();
+
+  // create a copy of the LP when simplifying or when using internal scaling,
+  // i.e. w/o persistent scaling
+  bool copyLP = (_simplifier != 0 || (_scaler && !_isRealLPScaled));
+
+  _solver.setTerminationValue(intParam(SoPlexBase<R>::OBJSENSE) ==
+                                      SoPlexBase<R>::OBJSENSE_MINIMIZE
+                                  ? realParam(SoPlexBase<R>::OBJLIMIT_UPPER)
+                                  : realParam(SoPlexBase<R>::OBJLIMIT_LOWER));
+
+  if (_isRealLPLoaded) {
+    assert(_realLP == &_solver);
+
+    // preprocessing is always applied to the LP in the solver; hence we have to
+    // create a copy of the original LP if simplifier is turned on
+    if (copyLP) {
+      _realLP = nullptr;
+      spx_alloc(_realLP);
+      _realLP = new (_realLP) SPxLPBase<R>(_solver);
+      _isRealLPLoaded = false;
+    }
+  } else {
+    assert(_realLP != &_solver);
+
+    // load real LP and basis if available
+    if (_hasBasis) {
       assert(_basisStatusRows.size() == numRows());
       assert(_basisStatusCols.size() == this->numCols());
-      _hasBasis = true;
-   }
 
-   // load realLP into the solver again (internal scaling was applied)
-   else if(_realLP != &_solver)
-   {
-      assert(_solver.isScaled());
-      _loadRealLP(false);
-   }
-
-   // unscale stored solution (removes persistent scaling)
-   if(_isRealLPScaled)
-      _unscaleSolutionReal(*_realLP, true);
-
-   // check solution for violations and solve again if necessary
-   if(verify)
-      _verifySolutionReal();
-
-   assert(_solver.nCols() == this->numCols());
-   assert(_solver.nRows() == numRows());
+      _solver.loadLP(*_realLP, false);
+      _solver.setBasis(_basisStatusRows.get_const_ptr(),
+                       _basisStatusCols.get_const_ptr());
+    }
+    // load real LP and set up slack basis
+    else
+      _solver.loadLP(*_realLP, true);
+
+    // if there is no simplifier, then the original and the transformed problem
+    // are identical and it is more memory-efficient to keep only the problem in
+    // the solver
+    if (!copyLP) {
+      _realLP->~SPxLPBase<R>();
+      spx_free(_realLP);
+      _realLP = &_solver;
+      _isRealLPLoaded = true;
+    }
+  }
+
+  // assert that we have two problems if and only if we apply the simplifier
+  assert(_realLP == &_solver || copyLP);
+  assert(_realLP != &_solver || !copyLP);
+
+  // apply problem simplification
+  typename SPxSimplifier<R>::Result simplificationStatus =
+      SPxSimplifier<R>::OKAY;
+
+  if (_simplifier) {
+    assert(!_isRealLPLoaded);
+    // do not remove bounds of boxed variables or sides of ranged rows if bound
+    // flipping is used; also respect row-boundflip parameter
+    bool keepbounds = intParam(SoPlexBase<R>::RATIOTESTER) ==
+                      SoPlexBase<R>::RATIOTESTER_BOUNDFLIPPING;
+
+    if (intParam(SoPlexBase<R>::REPRESENTATION) ==
+            SoPlexBase<R>::REPRESENTATION_ROW ||
+        (intParam(SoPlexBase<R>::REPRESENTATION) ==
+             SoPlexBase<R>::REPRESENTATION_AUTO &&
+         (_solver.nCols() + 1) *
+                 realParam(SoPlexBase<R>::REPRESENTATION_SWITCH) <
+             (_solver.nRows() + 1)))
+      keepbounds &= boolParam(SoPlexBase<R>::ROWBOUNDFLIPS);
+
+    Real remainingTime = _solver.getMaxTime() - _solver.time();
+    simplificationStatus = _simplifier->simplify(
+        _solver, realParam(SoPlexBase<R>::EPSILON_ZERO),
+        realParam(SoPlexBase<R>::FEASTOL), realParam(SoPlexBase<R>::OPTTOL),
+        remainingTime, keepbounds, _solver.random.getSeed());
+    _solver.changeObjOffset(_simplifier->getObjoffset() +
+                            realParam(SoPlexBase<R>::OBJ_OFFSET));
+    _solver.setScalingInfo(false);
+    _applyPolishing = true;
+
+    _solver.setSolutionPolishing(SPxSolverBase<R>::POLISH_OFF);
+  }
+
+  _statistics->preprocessingTime->stop();
+
+  // run the simplex method if problem has not been solved by the simplifier
+  if (simplificationStatus == SPxSimplifier<R>::OKAY) {
+    if (_scaler && !_solver.isScaled()) {
+      _scaler->scale(_solver, false);
+      _solver.invalidateBasis();
+    }
+
+    _solveRealLPAndRecordStatistics(interrupt);
+  }
+
+  _evaluateSolutionReal(simplificationStatus);
 }
 
+/// loads original problem into solver and solves again after it has been solved
+/// to infeasibility or unboundedness with preprocessing
+template <class R>
+void SoPlexBase<R>::_resolveWithoutPreprocessing(
+    typename SPxSimplifier<R>::Result simplificationStatus) {
+  assert(!_isRealLPLoaded || _scaler != nullptr);
+  assert(_simplifier != 0 || _scaler != nullptr);
+  assert(_status == SPxSolverBase<R>::INFEASIBLE ||
+         _status == SPxSolverBase<R>::INForUNBD ||
+         _status == SPxSolverBase<R>::UNBOUNDED);
+
+  // if simplifier was active, then we unsimplify to get the basis
+  if (_simplifier) {
+    assert(!_simplifier->isUnsimplified());
+    assert(simplificationStatus == SPxSimplifier<R>::OKAY);
+
+    // get temporary solution vectors for transformed problem
+    VectorBase<R> primal(_solver.nCols());
+    VectorBase<R> slacks(_solver.nRows());
+    VectorBase<R> dual(_solver.nRows());
+    VectorBase<R> redCost(_solver.nCols());
+
+    _basisStatusRows.reSize(numRows());
+    _basisStatusCols.reSize(numCols());
+    assert(_basisStatusRows.size() >= _solver.nRows());
+    assert(_basisStatusCols.size() >= _solver.nCols());
+
+    // get solution data from transformed problem
+    _solver.getPrimalSol(primal);
+    _solver.getSlacks(slacks);
+    _solver.getDualSol(dual);
+    _solver.getRedCostSol(redCost);
+
+    // unscale vectors
+    if (_scaler && _solver.isScaled()) {
+      _scaler->unscalePrimal(_solver, primal);
+      _scaler->unscaleSlacks(_solver, slacks);
+      _scaler->unscaleDual(_solver, dual);
+      _scaler->unscaleRedCost(_solver, redCost);
+    }
+
+    // get basis of transformed problem
+    _solver.getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr(),
+                     _basisStatusRows.size(), _basisStatusCols.size());
+
+    try {
+      _simplifier->unsimplify(primal, dual, slacks, redCost,
+                              _basisStatusRows.get_ptr(),
+                              _basisStatusCols.get_ptr(), false);
+      _simplifier->getBasis(_basisStatusRows.get_ptr(),
+                            _basisStatusCols.get_ptr(), _basisStatusRows.size(),
+                            _basisStatusCols.size());
+      _hasBasis = true;
+    } catch (const SPxException &E) {
+      MSG_INFO1(spxout, spxout << "Caught exception <" << E.what()
+                               << "> during unsimplification. Resolving "
+                                  "without simplifier and scaler.\n");
+      _hasBasis = false;
+    }
+  }
+  // if the original problem is not in the solver because of scaling, we also
+  // need to store the basis
+  else if (_scaler != nullptr) {
+    _basisStatusRows.reSize(numRows());
+    _basisStatusCols.reSize(numCols());
+    assert(_basisStatusRows.size() == _solver.nRows());
+    assert(_basisStatusCols.size() == _solver.nCols());
+
+    _solver.getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr(),
+                     _basisStatusRows.size(), _basisStatusCols.size());
+    _hasBasis = true;
+  }
+
+  // resolve the original problem
+  _preprocessAndSolveReal(false);
+  return;
+}
 
+/// verify computed solution based on status and resolve if claimed primal or
+/// dual feasibility is not fulfilled
+template <class R> void SoPlexBase<R>::_verifySolutionReal() {
+  assert(_hasSolReal);
+
+  MSG_INFO1(spxout, spxout << " --- verifying computed solution" << std::endl;)
+
+  R sumviol = 0;
+  R boundviol = 0;
+  R rowviol = 0;
+  R dualviol = 0;
+  R redcostviol = 0;
+
+  (void)getBoundViolation(boundviol, sumviol);
+  (void)getRowViolation(rowviol, sumviol);
+  (void)getDualViolation(dualviol, sumviol);
+  (void)getRedCostViolation(redcostviol, sumviol);
+
+  if (boundviol >= _solver.feastol() || rowviol >= _solver.feastol() ||
+      dualviol >= _solver.opttol() || redcostviol >= _solver.opttol()) {
+    assert(&_solver == _realLP);
+    assert(_isRealLPLoaded);
+    MSG_INFO3(spxout,
+              spxout << "bound violation: " << boundviol << ", row violation: "
+                     << rowviol << ", dual violation: " << dualviol
+                     << ", redcost violation: " << redcostviol << std::endl;)
+    MSG_INFO1(spxout, spxout
+                          << " --- detected violations in original problem "
+                             "space -- solve again without presolving/scaling"
+                          << std::endl;)
+
+    if (_isRealLPScaled) {
+      _solver.unscaleLPandReloadBasis();
+      _isRealLPScaled = false;
+      ++_unscaleCalls;
+    }
+
+    _preprocessAndSolveReal(false);
+  }
+}
 
-template <class R>
-void SoPlexBase<R>::_storeSolutionRealFromPresol()
-{
-   assert(_simplifier);
-   assert(_simplifier->result() == SPxSimplifier<R>::VANISHED);
-
-   // prepare storage for basis (enough to fit the original basis)
-   _basisStatusRows.reSize(numRows());
-   _basisStatusCols.reSize(numCols());
-
-   // prepare storage for the solution data and initialize it to zero
-   _solReal._primal.reDim(numCols(), true);
-   _solReal._slacks.reDim(numRows(), true);
-   _solReal._dual.reDim(numRows(), true);
-   _solReal._redCost.reDim(numCols(), true);
-
-   // load original LP and setup slack basis for unsimplifying
-   _loadRealLP(true);
-
-   // store slack basis
-   _solver.getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr(),
-                    _basisStatusRows.size(), _basisStatusCols.size());
-
-   assert(!_simplifier->isUnsimplified());
-
-   try
-   {
-      // unsimplify basis and solution data
-      _simplifier->unsimplify(_solReal._primal, _solReal._dual, _solReal._slacks, _solReal._redCost,
-                              _basisStatusRows.get_ptr(), _basisStatusCols.get_ptr());
-
-   }
-   catch(const SPxException& E)
-   {
-      MSG_INFO1(spxout, spxout << "Caught exception <" << E.what() <<
-                "> during unsimplification. Resolving without simplifier and scaler.\n");
+/// stores solution data from the solver, possibly after applying unscaling and
+/// unsimplifying
+template <class R> void SoPlexBase<R>::_storeSolutionReal(bool verify) {
+  // prepare storage for basis (enough to fit the original basis)
+  _basisStatusRows.reSize(numRows());
+  _basisStatusCols.reSize(numCols());
+
+  // prepare storage for the solution data (only in transformed space due to
+  // unscaling), w/o setting it to zero
+  _solReal._primal.reDim(_solver.nCols(), false);
+  _solReal._slacks.reDim(_solver.nRows(), false);
+  _solReal._dual.reDim(_solver.nRows(), false);
+  _solReal._redCost.reDim(_solver.nCols(), false);
+
+  // check primal status consistency and query solution status
+  assert(_solver.basis().status() != SPxBasisBase<R>::PRIMAL ||
+         status() != SPxSolverBase<R>::ERROR);
+  assert(_solver.basis().status() != SPxBasisBase<R>::PRIMAL ||
+         status() != SPxSolverBase<R>::NO_RATIOTESTER);
+  assert(_solver.basis().status() != SPxBasisBase<R>::PRIMAL ||
+         status() != SPxSolverBase<R>::NO_PRICER);
+  assert(_solver.basis().status() != SPxBasisBase<R>::PRIMAL ||
+         status() != SPxSolverBase<R>::NO_SOLVER);
+  assert(_solver.basis().status() != SPxBasisBase<R>::PRIMAL ||
+         status() != SPxSolverBase<R>::NOT_INIT);
+  assert(_solver.basis().status() != SPxBasisBase<R>::PRIMAL ||
+         status() != SPxSolverBase<R>::SINGULAR);
+  assert(_solver.basis().status() != SPxBasisBase<R>::PRIMAL ||
+         status() != SPxSolverBase<R>::NO_PROBLEM);
+  assert(_solver.basis().status() != SPxBasisBase<R>::PRIMAL ||
+         status() != SPxSolverBase<R>::UNBOUNDED);
+  assert(_solver.basis().status() != SPxBasisBase<R>::PRIMAL ||
+         status() != SPxSolverBase<R>::INFEASIBLE);
+  assert(_solver.basis().status() != SPxBasisBase<R>::UNBOUNDED ||
+         status() == SPxSolverBase<R>::UNBOUNDED);
+  assert(_solver.basis().status() == SPxBasisBase<R>::UNBOUNDED ||
+         _solver.basis().status() == SPxBasisBase<R>::NO_PROBLEM ||
+         status() != SPxSolverBase<R>::UNBOUNDED);
+
+  _solReal._isPrimalFeasible =
+      (status() == SPxSolverBase<R>::OPTIMAL ||
+       ((_solver.basis().status() == SPxBasisBase<R>::PRIMAL ||
+         _solver.basis().status() == SPxBasisBase<R>::UNBOUNDED) &&
+        _solver.shift() < 10.0 * realParam(SoPlexBase<R>::EPSILON_ZERO)));
+
+  _solReal._hasPrimalRay =
+      (status() == SPxSolverBase<R>::UNBOUNDED && _isRealLPLoaded);
+
+  // check dual status consistency and query solution status
+  assert(_solver.basis().status() != SPxBasisBase<R>::DUAL ||
+         status() != SPxSolverBase<R>::ERROR);
+  assert(_solver.basis().status() != SPxBasisBase<R>::DUAL ||
+         status() != SPxSolverBase<R>::NO_RATIOTESTER);
+  assert(_solver.basis().status() != SPxBasisBase<R>::DUAL ||
+         status() != SPxSolverBase<R>::NO_PRICER);
+  assert(_solver.basis().status() != SPxBasisBase<R>::DUAL ||
+         status() != SPxSolverBase<R>::NO_SOLVER);
+  assert(_solver.basis().status() != SPxBasisBase<R>::DUAL ||
+         status() != SPxSolverBase<R>::NOT_INIT);
+  assert(_solver.basis().status() != SPxBasisBase<R>::DUAL ||
+         status() != SPxSolverBase<R>::SINGULAR);
+  assert(_solver.basis().status() != SPxBasisBase<R>::DUAL ||
+         status() != SPxSolverBase<R>::NO_PROBLEM);
+  assert(_solver.basis().status() != SPxBasisBase<R>::DUAL ||
+         status() != SPxSolverBase<R>::UNBOUNDED);
+  assert(_solver.basis().status() != SPxBasisBase<R>::DUAL ||
+         status() != SPxSolverBase<R>::INFEASIBLE);
+  assert(_solver.basis().status() != SPxBasisBase<R>::INFEASIBLE ||
+         status() == SPxSolverBase<R>::INFEASIBLE);
+  assert(_solver.basis().status() == SPxBasisBase<R>::INFEASIBLE ||
+         _solver.basis().status() == SPxBasisBase<R>::NO_PROBLEM ||
+         status() != SPxSolverBase<R>::INFEASIBLE);
+
+  _solReal._isDualFeasible =
+      (status() == SPxSolverBase<R>::OPTIMAL ||
+       ((_solver.basis().status() == SPxBasisBase<R>::DUAL ||
+         _solver.basis().status() == SPxBasisBase<R>::INFEASIBLE) &&
+        _solver.shift() < 10.0 * realParam(SoPlexBase<R>::EPSILON_ZERO)));
+
+  _solReal._hasDualFarkas =
+      (status() == SPxSolverBase<R>::INFEASIBLE && _isRealLPLoaded);
+
+  // get infeasibility or unboundedness proof if available
+  if (_solReal._hasPrimalRay) {
+    _solReal._primalRay.reDim(_solver.nCols(), false);
+    _solver.getPrimalray(_solReal._primalRay);
+  }
+
+  if (_solReal._hasDualFarkas) {
+    _solReal._dualFarkas.reDim(_solver.nRows(), false);
+    _solver.getDualfarkas(_solReal._dualFarkas);
+  }
+
+  // get solution data from the solver; independent of solution status
+  _solver.getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr(),
+                   _basisStatusRows.size(), _basisStatusCols.size());
+
+  _solver.getPrimalSol(_solReal._primal);
+  _solver.getSlacks(_solReal._slacks);
+  _solver.getDualSol(_solReal._dual);
+  _solver.getRedCostSol(_solReal._redCost);
+
+  _hasBasis = true;
+
+  // get primal and/or dual objective function value depending on status
+  _solver.forceRecompNonbasicValue();
+  _solReal._objVal = _solver.objValue();
+
+  // infeasible solutions shall also be stored and be accessible
+  _hasSolReal = true;
+
+  // unscale vectors
+  if (_solver.isScaled() && !_isRealLPLoaded)
+    _unscaleSolutionReal(_solver, false);
+
+  // get unsimplified solution data from simplifier
+  if (_simplifier) {
+    assert(!_simplifier->isUnsimplified());
+    assert(_simplifier->result() == SPxSimplifier<R>::OKAY);
+    assert(_realLP != &_solver);
+
+    typename SPxBasisBase<R>::SPxStatus simplifiedBasisStatus =
+        _solver.getBasisStatus();
+
+    try {
+      // pass solution data of transformed problem to simplifier
+      _simplifier->unsimplify(
+          _solReal._primal, _solReal._dual, _solReal._slacks, _solReal._redCost,
+          _basisStatusRows.get_ptr(), _basisStatusCols.get_ptr(),
+          status() == SPxSolverBase<R>::OPTIMAL);
+    } catch (const SPxException &E) {
+      MSG_INFO1(spxout, spxout << "Caught exception <" << E.what()
+                               << "> during unsimplification. Resolving "
+                                  "without simplifier and scaler.\n");
+      _hasBasis = false;
       _preprocessAndSolveReal(false);
       return;
-   }
-
-   // copy unsimplified solution data from simplifier
-   _solReal._primal  = _simplifier->unsimplifiedPrimal();
-   _solReal._slacks  = _simplifier->unsimplifiedSlacks();
-   _solReal._dual    = _simplifier->unsimplifiedDual();
-   _solReal._redCost = _simplifier->unsimplifiedRedCost();
-
-   // unscale stored solution (removes persistent scaling)
-   if(_isRealLPScaled)
-      _unscaleSolutionReal(*_realLP, true);
-
-   // compute the original objective function value
-   StableSum<R> objVal(realParam(SoPlexBase<R>::OBJ_OFFSET));
-
-   for(int i = 0; i < numCols(); ++i)
-      objVal += _solReal._primal[i] * objReal(i);
-
-   _solReal._objVal = R(objVal);
-
-   // store the unsimplified basis
-   _simplifier->getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr(),
-                         _basisStatusRows.size(), _basisStatusCols.size());
-   _hasBasis = true;
-   _hasSolReal = true;
-   _solReal._isPrimalFeasible = true;
-   _solReal._isDualFeasible = true;
-   _solver.setBasisStatus(SPxBasisBase<R>::OPTIMAL);
-
-   // check solution for violations and solve again if necessary
-   _verifySolutionReal();
+    }
+
+    // copy unsimplified solution data from simplifier (size and dimension is
+    // adapted during copy)
+    _solReal._primal = _simplifier->unsimplifiedPrimal();
+    _solReal._slacks = _simplifier->unsimplifiedSlacks();
+    _solReal._dual = _simplifier->unsimplifiedDual();
+    _solReal._redCost = _simplifier->unsimplifiedRedCost();
+
+    // overwrite the transformed basis with the unsimplified one
+    _simplifier->getBasis(_basisStatusRows.get_ptr(),
+                          _basisStatusCols.get_ptr(), _basisStatusRows.size(),
+                          _basisStatusCols.size());
+
+    // load original problem but don't setup a slack basis
+    _loadRealLP(false);
+
+    // since we presolved the problem, we should not allow access to the dual
+    // norms
+    _solver.weightsAreSetup = false;
+
+    assert(_realLP == &_solver);
+
+    // reset basis status
+    _solver.setBasisStatus(simplifiedBasisStatus);
+
+    _solver.setBasis(_basisStatusRows.get_const_ptr(),
+                     _basisStatusCols.get_const_ptr());
+    // load unsimplified basis into solver
+    assert(_basisStatusRows.size() == numRows());
+    assert(_basisStatusCols.size() == this->numCols());
+    _hasBasis = true;
+  }
+
+  // load realLP into the solver again (internal scaling was applied)
+  else if (_realLP != &_solver) {
+    assert(_solver.isScaled());
+    _loadRealLP(false);
+  }
+
+  // unscale stored solution (removes persistent scaling)
+  if (_isRealLPScaled)
+    _unscaleSolutionReal(*_realLP, true);
+
+  // check solution for violations and solve again if necessary
+  if (verify)
+    _verifySolutionReal();
+
+  assert(_solver.nCols() == this->numCols());
+  assert(_solver.nRows() == numRows());
 }
 
-
+template <class R> void SoPlexBase<R>::_storeSolutionRealFromPresol() {
+  assert(_simplifier);
+  assert(_simplifier->result() == SPxSimplifier<R>::VANISHED);
+
+  // prepare storage for basis (enough to fit the original basis)
+  _basisStatusRows.reSize(numRows());
+  _basisStatusCols.reSize(numCols());
+
+  // prepare storage for the solution data and initialize it to zero
+  _solReal._primal.reDim(numCols(), true);
+  _solReal._slacks.reDim(numRows(), true);
+  _solReal._dual.reDim(numRows(), true);
+  _solReal._redCost.reDim(numCols(), true);
+
+  // load original LP and setup slack basis for unsimplifying
+  _loadRealLP(true);
+
+  // store slack basis
+  _solver.getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr(),
+                   _basisStatusRows.size(), _basisStatusCols.size());
+
+  assert(!_simplifier->isUnsimplified());
+
+  try {
+    // unsimplify basis and solution data
+    _simplifier->unsimplify(_solReal._primal, _solReal._dual, _solReal._slacks,
+                            _solReal._redCost, _basisStatusRows.get_ptr(),
+                            _basisStatusCols.get_ptr());
+
+  } catch (const SPxException &E) {
+    MSG_INFO1(spxout, spxout << "Caught exception <" << E.what()
+                             << "> during unsimplification. Resolving without "
+                                "simplifier and scaler.\n");
+    _preprocessAndSolveReal(false);
+    return;
+  }
+
+  // copy unsimplified solution data from simplifier
+  _solReal._primal = _simplifier->unsimplifiedPrimal();
+  _solReal._slacks = _simplifier->unsimplifiedSlacks();
+  _solReal._dual = _simplifier->unsimplifiedDual();
+  _solReal._redCost = _simplifier->unsimplifiedRedCost();
+
+  // unscale stored solution (removes persistent scaling)
+  if (_isRealLPScaled)
+    _unscaleSolutionReal(*_realLP, true);
+
+  // compute the original objective function value
+  StableSum<R> objVal(realParam(SoPlexBase<R>::OBJ_OFFSET));
+
+  for (int i = 0; i < numCols(); ++i)
+    objVal += _solReal._primal[i] * objReal(i);
+
+  _solReal._objVal = R(objVal);
+
+  // store the unsimplified basis
+  _simplifier->getBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr(),
+                        _basisStatusRows.size(), _basisStatusCols.size());
+  _hasBasis = true;
+  _hasSolReal = true;
+  _solReal._isPrimalFeasible = true;
+  _solReal._isDualFeasible = true;
+  _solver.setBasisStatus(SPxBasisBase<R>::OPTIMAL);
+
+  // check solution for violations and solve again if necessary
+  _verifySolutionReal();
+}
 
 /// load original LP and possibly setup a slack basis
-template <class R>
-void SoPlexBase<R>::_loadRealLP(bool initBasis)
-{
-   _solver.loadLP(*_realLP, initBasis);
-   _isRealLPLoaded = true;
-   _realLP->~SPxLPBase<R>();
-   spx_free(_realLP);
-   _realLP = &_solver;
-
-   if(initBasis)
-      _solver.init();
+template <class R> void SoPlexBase<R>::_loadRealLP(bool initBasis) {
+  _solver.loadLP(*_realLP, initBasis);
+  _isRealLPLoaded = true;
+  _realLP->~SPxLPBase<R>();
+  spx_free(_realLP);
+  _realLP = &_solver;
+
+  if (initBasis)
+    _solver.init();
 }
 
-
-
 /// unscales stored solution to remove internal or external scaling of LP
 template <class R>
-void SoPlexBase<R>::_unscaleSolutionReal(SPxLPBase<R>& LP, bool persistent)
-{
-   MSG_INFO1(spxout, spxout << " --- unscaling " << (persistent ? "external" : "internal") <<
-             " solution" << std::endl;)
-   assert(_scaler);
-   assert(!persistent || (boolParam(SoPlexBase<R>::PERSISTENTSCALING) && _isRealLPScaled));
-   _scaler->unscalePrimal(LP, _solReal._primal);
-   _scaler->unscaleSlacks(LP, _solReal._slacks);
-   _scaler->unscaleDual(LP, _solReal._dual);
-   _scaler->unscaleRedCost(LP, _solReal._redCost);
-
-   if(_solReal.hasPrimalRay())
-      _scaler->unscalePrimalray(LP, _solReal._primalRay);
-
-   if(_solReal.hasDualFarkas())
-      _scaler->unscaleDualray(LP, _solReal._dualFarkas);
+void SoPlexBase<R>::_unscaleSolutionReal(SPxLPBase<R> &LP, bool persistent) {
+  MSG_INFO1(spxout, spxout << " --- unscaling "
+                           << (persistent ? "external" : "internal")
+                           << " solution" << std::endl;)
+  assert(_scaler);
+  assert(!persistent ||
+         (boolParam(SoPlexBase<R>::PERSISTENTSCALING) && _isRealLPScaled));
+  _scaler->unscalePrimal(LP, _solReal._primal);
+  _scaler->unscaleSlacks(LP, _solReal._slacks);
+  _scaler->unscaleDual(LP, _solReal._dual);
+  _scaler->unscaleRedCost(LP, _solReal._redCost);
+
+  if (_solReal.hasPrimalRay())
+    _scaler->unscalePrimalray(LP, _solReal._primalRay);
+
+  if (_solReal.hasDualFarkas())
+    _scaler->unscaleDualray(LP, _solReal._dualFarkas);
 }
 } // namespace soplex
diff --git a/src/soplex/spxautopr.hpp b/src/soplex/spxautopr.hpp
index 306f39b..838252e 100644
--- a/src/soplex/spxautopr.hpp
+++ b/src/soplex/spxautopr.hpp
@@ -21,106 +21,91 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <iostream>
 
 #include "soplex/spxdefines.h"
 #include "soplex/spxout.h"
 
-namespace soplex
-{
+namespace soplex {
 
-template <class R>
-void SPxAutoPR<R>::load(SPxSolverBase<R>* p_solver)
-{
-   steep.load(p_solver);
-   devex.load(p_solver);
-   this->thesolver = p_solver;
-   setType(p_solver->type());
+template <class R> void SPxAutoPR<R>::load(SPxSolverBase<R> *p_solver) {
+  steep.load(p_solver);
+  devex.load(p_solver);
+  this->thesolver = p_solver;
+  setType(p_solver->type());
 }
 
-template <class R>
-void SPxAutoPR<R>::clear()
-{
-   steep.clear();
-   devex.clear();
-   this->thesolver = nullptr;
+template <class R> void SPxAutoPR<R>::clear() {
+  steep.clear();
+  devex.clear();
+  this->thesolver = nullptr;
 }
 
-template <class R>
-void SPxAutoPR<R>::setEpsilon(R eps)
-{
-   steep.setEpsilon(eps);
-   devex.setEpsilon(eps);
-   this->theeps = eps;
+template <class R> void SPxAutoPR<R>::setEpsilon(R eps) {
+  steep.setEpsilon(eps);
+  devex.setEpsilon(eps);
+  this->theeps = eps;
 }
 
 template <class R>
-void SPxAutoPR<R>::setType(typename SPxSolverBase<R>::Type tp)
-{
-   activepricer->setType(tp);
+void SPxAutoPR<R>::setType(typename SPxSolverBase<R>::Type tp) {
+  activepricer->setType(tp);
 }
 
 template <class R>
-void SPxAutoPR<R>::setRep(typename SPxSolverBase<R>::Representation rep)
-{
-   steep.setRep(rep);
-   devex.setRep(rep);
+void SPxAutoPR<R>::setRep(typename SPxSolverBase<R>::Representation rep) {
+  steep.setRep(rep);
+  devex.setRep(rep);
 }
 
 template <class R>
-bool SPxAutoPR<R>::setActivePricer(typename SPxSolverBase<R>::Type type)
-{
-   // switch to steep as soon as switchIters is reached
-   if(activepricer == &devex && this->thesolver->iterations() >= switchIters)
-   {
-      activepricer = &steep;
-      activepricer->setType(type);
-      return true;
-   }
-
-
-   // use devex for the iterations < switchIters
-   else if(activepricer == &steep && this->thesolver->iterations() < switchIters)
-   {
-      activepricer = &devex;
-      activepricer->setType(type);
-      return true;
-   }
-
-   return false;
+bool SPxAutoPR<R>::setActivePricer(typename SPxSolverBase<R>::Type type) {
+  // switch to steep as soon as switchIters is reached
+  if (activepricer == &devex && this->thesolver->iterations() >= switchIters) {
+    activepricer = &steep;
+    activepricer->setType(type);
+    return true;
+  }
+
+  // use devex for the iterations < switchIters
+  else if (activepricer == &steep &&
+           this->thesolver->iterations() < switchIters) {
+    activepricer = &devex;
+    activepricer->setType(type);
+    return true;
+  }
+
+  return false;
 }
 
-template <class R>
-int SPxAutoPR<R>::selectLeave()
-{
-   if(setActivePricer(SPxSolverBase<R>::LEAVE))
-      MSG_INFO1((*this->thesolver->spxout),
-                (*this->thesolver->spxout) << " --- active pricer: " << activepricer->getName() << std::endl;)
+template <class R> int SPxAutoPR<R>::selectLeave() {
+  if (setActivePricer(SPxSolverBase<R>::LEAVE))
+    MSG_INFO1((*this->thesolver->spxout),
+              (*this->thesolver->spxout)
+                  << " --- active pricer: " << activepricer->getName()
+                  << std::endl;)
 
-      return activepricer->selectLeave();
+  return activepricer->selectLeave();
 }
 
-template <class R>
-void SPxAutoPR<R>::left4(int n, SPxId id)
-{
-   activepricer->left4(n, id);
+template <class R> void SPxAutoPR<R>::left4(int n, SPxId id) {
+  activepricer->left4(n, id);
 }
 
-template <class R>
-SPxId SPxAutoPR<R>::selectEnter()
-{
-   if(setActivePricer(SPxSolverBase<R>::ENTER))
-      MSG_INFO1((*this->thesolver->spxout),
-                (*this->thesolver->spxout) << " --- active pricer: " << activepricer->getName() << std::endl;)
+template <class R> SPxId SPxAutoPR<R>::selectEnter() {
+  if (setActivePricer(SPxSolverBase<R>::ENTER))
+    MSG_INFO1((*this->thesolver->spxout),
+              (*this->thesolver->spxout)
+                  << " --- active pricer: " << activepricer->getName()
+                  << std::endl;)
 
-      return activepricer->selectEnter();
+  return activepricer->selectEnter();
 }
 
-template <class R>
-void SPxAutoPR<R>::entered4(SPxId id, int n)
-{
-   activepricer->entered4(id, n);
+template <class R> void SPxAutoPR<R>::entered4(SPxId id, int n) {
+  activepricer->entered4(id, n);
 }
 
 } // namespace soplex
diff --git a/src/soplex/spxbasis.h b/src/soplex/spxbasis.h
index 8717918..2b08a20 100644
--- a/src/soplex/spxbasis.h
+++ b/src/soplex/spxbasis.h
@@ -28,34 +28,33 @@
 #ifndef _SPXBASIS_H_
 #define _SPXBASIS_H_
 
-/* undefine SOPLEX_DEBUG flag from including files; if SOPLEX_DEBUG should be defined in this file, do so below */
+/* undefine SOPLEX_DEBUG flag from including files; if SOPLEX_DEBUG should be
+ * defined in this file, do so below */
 #ifdef SOPLEX_DEBUG
 #define SOPLEX_DEBUG_SPXBASIS
 #undef SOPLEX_DEBUG
 #endif
 
 #include <assert.h>
-#include <iostream>
 #include <iomanip>
-#include <string.h>
+#include <iostream>
 #include <sstream>
+#include <string.h>
 
-#include "soplex/spxdefines.h"
-#include "soplex/spxlp.h"
-#include "soplex/svector.h"
-#include "soplex/ssvector.h"
 #include "soplex/dataarray.h"
-#include "soplex/slinsolver.h"
 #include "soplex/nameset.h"
+#include "soplex/slinsolver.h"
+#include "soplex/spxdefines.h"
+#include "soplex/spxlp.h"
 #include "soplex/spxout.h"
+#include "soplex/ssvector.h"
+#include "soplex/svector.h"
 #include "soplex/timerfactory.h"
 
-//#define MEASUREUPDATETIME
+// #define MEASUREUPDATETIME
 
-namespace soplex
-{
-template <class R>
-class SPxSolverBase;
+namespace soplex {
+template <class R> class SPxSolverBase;
 
 /**@class SPxBasisBase
    @brief   Simplex basis.
@@ -90,931 +89,800 @@ class SPxSolverBase;
    be called for solving linear systems.
 */
 template <class R> // theLP gets templated
-class SPxBasisBase
-{
+class SPxBasisBase {
 public:
-
-   /// basis status.
-   /** Each SPxBasisBase is assigned a status flag, which can take on of the
-       above values.
-   */
-   enum SPxStatus
-   {
-      NO_PROBLEM = -2,  ///< No Problem has been loaded to the basis.
-      SINGULAR   = -1,  ///< Basis is singular.
-      REGULAR    = 0,   ///< Basis is not known to be dual nor primal feasible.
-      DUAL       = 1,   ///< Basis is dual feasible.
-      PRIMAL     = 2,   ///< Basis is primal feasible.
-      OPTIMAL    = 3,   ///< Basis is optimal, i.e. dual and primal feasible.
-      UNBOUNDED  = 4,   ///< LP has been proven to be primal unbounded.
-      INFEASIBLE = 5    ///< LP has been proven to be primal infeasible.
-   };
-
-
-   /// Basis descriptor.
-   class Desc
-   {
-   public:
-
-      //------------------------------------
-      ///@name Status
-      ///@{
-      /// Status of a variable.
-      /** A basis is described by assigning a Status to all of the LP
-          variables and covariables. This assignment is maintained by the
-          basis #Desc%riptor.
-
-          Variables and covariables (slackvariables) may have a primal or dual Status. The
-          first type specifies that a variable is set on a primal bound, while
-          the latter type indicates a dual variable to be set on a bound.
-          If a row variable has a primal status, say #P_ON_UPPER, this means
-          that the upper bound of the inequality is set to be tight. Hence,
-          in this case the upper bound must not be infinity.
-
-          Equivalently, if the status of a variable is dual, say #D_ON_UPPER,
-          it means that the dual variable corresponding to the upper bound
-          inequality of this variable is set to 0.
-
-          For a column basis, primal #Status%es correspond to nonbasic
-          variables, while dual ones are basic. This is reversed for a row
-          basis. We will now reveal in more detail the significance of
-          variable #Status%es.
-
-          <b>Primal Variables</b>
-
-          Consider a range inequality \f$l_r \le a^T x \le u_r\f$ or bounds on
-          a variable \f$l_c \le x_c \le u_c\f$. The following table reveals
-          what is implied if the corresponding variable or covariable is
-          assigned to a primal #Status:
-
-          \f[
-          \begin{array}{lcl}
-          l_c \le x_c \le u_c   & \mbox{Status}(x_i)  & l_r \le a^T x \le u_r \\
-          \hline
-          x_c = u_c < \infty    & \mbox{P\_ON\_UPPER} & a^T x = u_r < \infty  \\
-          x_c = l_c > -\infty   & \mbox{P\_ON\_LOWER} & a^T x = l_r > -\infty \\
-          -\infty < l_c = x_c = u_c < \infty
-          & \mbox{P\_FIXED}     &
-          -\infty < l_r = a^T x = u_r < \infty  \\
-          -\infty = l_i < x_i=0 < u_i = \infty
-          & \mbox{P\_FREE}      &
-          -\infty = l_r < a^T x = 0 < u_r = \infty  \\
-          \end{array}
-          \f]
-
-          Note that to determine whether a variable with #Status stat is set to
-          its upper bound, one can compute the test (-stat | -#P_ON_UPPER).
-          This will yield true even if the variable is fixed, i.e., sitting on
-          both bounds at the same time.
-
-          <b>Dual Variables</b>
-
-          In principle for implementing the Simplex algorithm it would suffice
-          to use only one dual #Status. However, for performance reasons it
-          is advisable to introduce various dual status types, reflecting
-          the structure of the bounds. Given an upper bound \f$u\f$ and a lower
-          bound \f$l\f$ of a constraint or variable, the following table
-          indicates the setting of the dual Status of this variable.
-
-          \f[
-          \begin{array}{cl}
-          l \le ... \le u               & \mbox{Status}        \\
-          \hline
-          -\infty < l \ne u < \infty    & \mbox{D\_ON\_BOTH}   \\
-          -\infty < l \ne u = \infty    & \mbox{D\_ON\_UPPER}  \\
-          -\infty = l \ne u < \infty    & \mbox{D\_ON\_LOWER}  \\
-          -\infty < l  =  u < \infty    & \mbox{D\_FREE}       \\
-          -\infty = l \ne u = \infty    & \mbox{D\_UNDEFINED}  \\
-          \end{array}
-          \f]
-
-          Note that unbounded primal variables are reflected by an #D_UNDEFINED
-          dual variable, since no reduced costs exist for them. To facilitate
-          the assignment of dual #Status%es, class SPxBasisBase provides methods
-          #dualStatus(), #dualColStatus() and #dualRowStatus)().
-      */
-      enum Status
-      {
-         P_ON_LOWER  = -4,  ///< primal variable is set to its lower bound
-         P_ON_UPPER  = -2,  ///< primal variable is set to its upper bound
-         P_FREE      = -1,  ///< primal variable is left free, but unset
-         P_FIXED     = P_ON_UPPER + P_ON_LOWER,  ///< primal variable is fixed to both bounds
-         D_FREE      = 1,   ///< dual variable is left free, but unset
-         D_ON_UPPER  = 2,   ///< dual variable is set to its upper bound
-         D_ON_LOWER  = 4,   ///< dual variable is set to its lower bound
-         D_ON_BOTH   = D_ON_LOWER + D_ON_UPPER,  ///< dual variable has two bounds
-         D_UNDEFINED = 8    ///< primal or dual variable is undefined
-      };
-      ///@}
-
-      friend SPxBasisBase<R>;
-      template <class T> friend std::ostream& operator<< (std::ostream& os,
-            const Status& stat); //@todo is the <> required here?
-
-   private:
-
-      //------------------------------------
-      ///@name Data
-      ///@{
-      DataArray < Status > rowstat;   ///< status of rows.
-      DataArray < Status > colstat;   ///< status of columns.
-      DataArray < Status >* stat;     ///< basis' status.
-      DataArray < Status >* costat;   ///< cobasis' status.
-      ///@}
-
-   public:
-
-      //------------------------------------
-      ///@name Access / modification
-      ///@{
-      /// returns number of columns.
-      int nCols() const
-      {
-         return colstat.size();
-      }
-      /// returns number of rows.
-      int nRows() const
-      {
-         return rowstat.size();
-      }
-      /// returns dimension.
-      int dim() const
-      {
-         return stat->size();
-      }
-      /// returns codimension.
-      int coDim() const
-      {
-         return costat->size();
-      }
-      ///
-      Status& rowStatus(int i)
-      {
-         return rowstat[i];
-      }
-      /// returns status of row \p i.
-      Status rowStatus(int i) const
-      {
-         return rowstat[i];
-      }
-      /// returns the array of row  \ref soplex::SPxBasisBase<R>::Desc::Status "Status"es.
-      const Status* rowStatus(void) const
-      {
-         return rowstat.get_const_ptr();
-      }
-      ///
-      Status& colStatus(int i)
-      {
-         return colstat[i];
-      }
-      /// returns status of column \p i.
-      Status colStatus(int i) const
-      {
-         return colstat[i];
-      }
-      /// returns the array of column \ref soplex::SPxBasisBase<R>::Desc::Status "Status"es.
-      const Status* colStatus(void) const
-      {
-         return colstat.get_const_ptr();
-      }
-      ///
-      Status& status(int i)
-      {
-         return (*stat)[i];
-      }
-      /// returns status of variable \p i.
-      Status status(int i) const
-      {
-         return (*stat)[i];
-      }
-      /// returns the array of variable \ref soplex::SPxBasisBase<R>::Desc::Status "Status"es.
-      const Status* status(void) const
-      {
-         return stat->get_const_ptr();
-      }
-      ///
-      Status& coStatus(int i)
-      {
-         return (*costat)[i];
-      }
-      /// returns status of covariable \p i.
-      Status coStatus(int i) const
-      {
-         return (*costat)[i];
-      }
-      /// returns the array of covariable \ref soplex::SPxBasisBase<R>::Desc::Status "Status"es.
-      const Status* coStatus(void) const
-      {
-         return costat->get_const_ptr();
-      }
-      /// resets dimensions.
-      void reSize(int rowDim, int colDim);
-      ///@}
-
-      //------------------------------------
-      ///@name Debugging
-      ///@{
-      /// Prints out status.
-      void dump() const;
-
-      /// consistency check.
-      bool isConsistent() const;
-      ///@}
-
-      //------------------------------------
-      ///@name Construction / destruction
-      ///@{
-      /// default constructor
-      Desc()
-         : stat(0)
-         , costat(0)
-      {}
-      explicit Desc(const SPxSolverBase<R>& base);
-
-      /// copy constructor
-      Desc(const Desc& old);
-      /// assignment operator
-      Desc& operator=(const Desc& rhs);
-      ///@}
-   };
-
-protected:
-
-   //------------------------------------
-   //**@name Protected data
-   /**
-      For storing the basis matrix we keep two arrays: Array #theBaseId
-      contains the SPxId%s of the basis vectors, and #matrix the pointers to
-      the vectors themselfes. Method #loadMatrixVecs() serves for loading
-      #matrix according to the SPxId%s stored in #theBaseId. This method must
-      be called whenever the VectorBase<R> pointers may have
-      changed due to manipulations of the LP.
-   */
-   ///@{
-   /// the LP
-   SPxSolverBase<R>* theLP;
-   /// SPxId%s of basic vectors.
-   DataArray < SPxId > theBaseId;
-   /// pointers to the vectors of the basis matrix.
-   DataArray < const SVectorBase<R>* > matrix;
-   /// \c true iff the pointers in \ref soplex::SPxBasisBase<R>::matrix "matrix" are set up correctly.
-   bool matrixIsSetup;
-
-   /* @brief LU factorization of basis matrix
-      The factorization of the matrix is stored in #factor if #factorized != 0.
-      Otherwise #factor is undefined.
-   */
-   SLinSolver<R>* factor;
-   /// \c true iff \ref soplex::SPxBasisBase<R>::factor "factor" = \ref soplex::SPxBasisBase<R>::matrix "matrix" \f$^{-1}\f$.
-   bool factorized;
-
-   /// number of updates before refactorization.
-   /** When a vector of the basis matrix is exchanged by a call to method
-       #change(), the LU factorization of the matrix is updated
-       accordingly. However, after atmost #maxUpdates updates of the
-       factorization, it is recomputed in order to regain numerical
-       stability and reduce fill in.
-   */
-   int   maxUpdates;
-
-   /// allowed increase of nonzeros before refactorization.
-   /** When the number of nonzeros in LU factorization exceeds
-       #nonzeroFactor times the number of nonzeros in B, the
-       basis matrix is refactorized.
-   */
-   R   nonzeroFactor;
-
-   /// allowed increase in relative fill before refactorization
-   /** When the real relative fill is bigger than fillFactor times lastFill
-    *  the Basis will be refactorized.
+  /// basis status.
+  /** Each SPxBasisBase is assigned a status flag, which can take on of the
+      above values.
+  */
+  enum SPxStatus {
+    NO_PROBLEM = -2, ///< No Problem has been loaded to the basis.
+    SINGULAR = -1,   ///< Basis is singular.
+    REGULAR = 0,     ///< Basis is not known to be dual nor primal feasible.
+    DUAL = 1,        ///< Basis is dual feasible.
+    PRIMAL = 2,      ///< Basis is primal feasible.
+    OPTIMAL = 3,     ///< Basis is optimal, i.e. dual and primal feasible.
+    UNBOUNDED = 4,   ///< LP has been proven to be primal unbounded.
+    INFEASIBLE = 5   ///< LP has been proven to be primal infeasible.
+  };
+
+  /// Basis descriptor.
+  class Desc {
+  public:
+    //------------------------------------
+    ///@name Status
+    ///@{
+    /// Status of a variable.
+    /** A basis is described by assigning a Status to all of the LP
+        variables and covariables. This assignment is maintained by the
+        basis #Desc%riptor.
+
+        Variables and covariables (slackvariables) may have a primal or dual
+       Status. The first type specifies that a variable is set on a primal
+       bound, while the latter type indicates a dual variable to be set on a
+       bound. If a row variable has a primal status, say #P_ON_UPPER, this means
+        that the upper bound of the inequality is set to be tight. Hence,
+        in this case the upper bound must not be infinity.
+
+        Equivalently, if the status of a variable is dual, say #D_ON_UPPER,
+        it means that the dual variable corresponding to the upper bound
+        inequality of this variable is set to 0.
+
+        For a column basis, primal #Status%es correspond to nonbasic
+        variables, while dual ones are basic. This is reversed for a row
+        basis. We will now reveal in more detail the significance of
+        variable #Status%es.
+
+        <b>Primal Variables</b>
+
+        Consider a range inequality \f$l_r \le a^T x \le u_r\f$ or bounds on
+        a variable \f$l_c \le x_c \le u_c\f$. The following table reveals
+        what is implied if the corresponding variable or covariable is
+        assigned to a primal #Status:
+
+        \f[
+        \begin{array}{lcl}
+        l_c \le x_c \le u_c   & \mbox{Status}(x_i)  & l_r \le a^T x \le u_r \\
+        \hline
+        x_c = u_c < \infty    & \mbox{P\_ON\_UPPER} & a^T x = u_r < \infty  \\
+        x_c = l_c > -\infty   & \mbox{P\_ON\_LOWER} & a^T x = l_r > -\infty \\
+        -\infty < l_c = x_c = u_c < \infty
+        & \mbox{P\_FIXED}     &
+        -\infty < l_r = a^T x = u_r < \infty  \\
+        -\infty = l_i < x_i=0 < u_i = \infty
+        & \mbox{P\_FREE}      &
+        -\infty = l_r < a^T x = 0 < u_r = \infty  \\
+        \end{array}
+        \f]
+
+        Note that to determine whether a variable with #Status stat is set to
+        its upper bound, one can compute the test (-stat | -#P_ON_UPPER).
+        This will yield true even if the variable is fixed, i.e., sitting on
+        both bounds at the same time.
+
+        <b>Dual Variables</b>
+
+        In principle for implementing the Simplex algorithm it would suffice
+        to use only one dual #Status. However, for performance reasons it
+        is advisable to introduce various dual status types, reflecting
+        the structure of the bounds. Given an upper bound \f$u\f$ and a lower
+        bound \f$l\f$ of a constraint or variable, the following table
+        indicates the setting of the dual Status of this variable.
+
+        \f[
+        \begin{array}{cl}
+        l \le ... \le u               & \mbox{Status}        \\
+        \hline
+        -\infty < l \ne u < \infty    & \mbox{D\_ON\_BOTH}   \\
+        -\infty < l \ne u = \infty    & \mbox{D\_ON\_UPPER}  \\
+        -\infty = l \ne u < \infty    & \mbox{D\_ON\_LOWER}  \\
+        -\infty < l  =  u < \infty    & \mbox{D\_FREE}       \\
+        -\infty = l \ne u = \infty    & \mbox{D\_UNDEFINED}  \\
+        \end{array}
+        \f]
+
+        Note that unbounded primal variables are reflected by an #D_UNDEFINED
+        dual variable, since no reduced costs exist for them. To facilitate
+        the assignment of dual #Status%es, class SPxBasisBase provides methods
+        #dualStatus(), #dualColStatus() and #dualRowStatus)().
     */
-   R   fillFactor;
-
-   /// allowed total increase in memory consumption before refactorization
-   R   memFactor;
+    enum Status {
+      P_ON_LOWER = -4, ///< primal variable is set to its lower bound
+      P_ON_UPPER = -2, ///< primal variable is set to its upper bound
+      P_FREE = -1,     ///< primal variable is left free, but unset
+      P_FIXED =
+          P_ON_UPPER + P_ON_LOWER, ///< primal variable is fixed to both bounds
+      D_FREE = 1,                  ///< dual variable is left free, but unset
+      D_ON_UPPER = 2,              ///< dual variable is set to its upper bound
+      D_ON_LOWER = 4,              ///< dual variable is set to its lower bound
+      D_ON_BOTH = D_ON_LOWER + D_ON_UPPER, ///< dual variable has two bounds
+      D_UNDEFINED = 8 ///< primal or dual variable is undefined
+    };
+    ///@}
+
+    friend SPxBasisBase<R>;
+    template <class T>
+    friend std::ostream &
+    operator<<(std::ostream &os,
+               const Status &stat); //@todo is the <> required here?
+
+  private:
+    //------------------------------------
+    ///@name Data
+    ///@{
+    DataArray<Status> rowstat; ///< status of rows.
+    DataArray<Status> colstat; ///< status of columns.
+    DataArray<Status> *stat;   ///< basis' status.
+    DataArray<Status> *costat; ///< cobasis' status.
+                               ///@}
+
+  public:
+    //------------------------------------
+    ///@name Access / modification
+    ///@{
+    /// returns number of columns.
+    int nCols() const { return colstat.size(); }
+    /// returns number of rows.
+    int nRows() const { return rowstat.size(); }
+    /// returns dimension.
+    int dim() const { return stat->size(); }
+    /// returns codimension.
+    int coDim() const { return costat->size(); }
+    ///
+    Status &rowStatus(int i) { return rowstat[i]; }
+    /// returns status of row \p i.
+    Status rowStatus(int i) const { return rowstat[i]; }
+    /// returns the array of row  \ref soplex::SPxBasisBase<R>::Desc::Status
+    /// "Status"es.
+    const Status *rowStatus(void) const { return rowstat.get_const_ptr(); }
+    ///
+    Status &colStatus(int i) { return colstat[i]; }
+    /// returns status of column \p i.
+    Status colStatus(int i) const { return colstat[i]; }
+    /// returns the array of column \ref soplex::SPxBasisBase<R>::Desc::Status
+    /// "Status"es.
+    const Status *colStatus(void) const { return colstat.get_const_ptr(); }
+    ///
+    Status &status(int i) { return (*stat)[i]; }
+    /// returns status of variable \p i.
+    Status status(int i) const { return (*stat)[i]; }
+    /// returns the array of variable \ref soplex::SPxBasisBase<R>::Desc::Status
+    /// "Status"es.
+    const Status *status(void) const { return stat->get_const_ptr(); }
+    ///
+    Status &coStatus(int i) { return (*costat)[i]; }
+    /// returns status of covariable \p i.
+    Status coStatus(int i) const { return (*costat)[i]; }
+    /// returns the array of covariable \ref
+    /// soplex::SPxBasisBase<R>::Desc::Status "Status"es.
+    const Status *coStatus(void) const { return costat->get_const_ptr(); }
+    /// resets dimensions.
+    void reSize(int rowDim, int colDim);
+    ///@}
+
+    //------------------------------------
+    ///@name Debugging
+    ///@{
+    /// Prints out status.
+    void dump() const;
+
+    /// consistency check.
+    bool isConsistent() const;
+    ///@}
+
+    //------------------------------------
+    ///@name Construction / destruction
+    ///@{
+    /// default constructor
+    Desc() : stat(0), costat(0) {}
+    explicit Desc(const SPxSolverBase<R> &base);
+
+    /// copy constructor
+    Desc(const Desc &old);
+    /// assignment operator
+    Desc &operator=(const Desc &rhs);
+    ///@}
+  };
 
-   /* Rank-1-updates to the basis may be performed via method #change(). In
-      this case, the factorization is updated, and the following members are
-      reset.
+protected:
+  //------------------------------------
+  //**@name Protected data
+  /**
+     For storing the basis matrix we keep two arrays: Array #theBaseId
+     contains the SPxId%s of the basis vectors, and #matrix the pointers to
+     the vectors themselfes. Method #loadMatrixVecs() serves for loading
+     #matrix according to the SPxId%s stored in #theBaseId. This method must
+     be called whenever the VectorBase<R> pointers may have
+     changed due to manipulations of the LP.
+  */
+  ///@{
+  /// the LP
+  SPxSolverBase<R> *theLP;
+  /// SPxId%s of basic vectors.
+  DataArray<SPxId> theBaseId;
+  /// pointers to the vectors of the basis matrix.
+  DataArray<const SVectorBase<R> *> matrix;
+  /// \c true iff the pointers in \ref soplex::SPxBasisBase<R>::matrix "matrix"
+  /// are set up correctly.
+  bool matrixIsSetup;
+
+  /* @brief LU factorization of basis matrix
+     The factorization of the matrix is stored in #factor if #factorized != 0.
+     Otherwise #factor is undefined.
+  */
+  SLinSolver<R> *factor;
+  /// \c true iff \ref soplex::SPxBasisBase<R>::factor "factor" = \ref
+  /// soplex::SPxBasisBase<R>::matrix "matrix" \f$^{-1}\f$.
+  bool factorized;
+
+  /// number of updates before refactorization.
+  /** When a vector of the basis matrix is exchanged by a call to method
+      #change(), the LU factorization of the matrix is updated
+      accordingly. However, after atmost #maxUpdates updates of the
+      factorization, it is recomputed in order to regain numerical
+      stability and reduce fill in.
+  */
+  int maxUpdates;
+
+  /// allowed increase of nonzeros before refactorization.
+  /** When the number of nonzeros in LU factorization exceeds
+      #nonzeroFactor times the number of nonzeros in B, the
+      basis matrix is refactorized.
+  */
+  R nonzeroFactor;
+
+  /// allowed increase in relative fill before refactorization
+  /** When the real relative fill is bigger than fillFactor times lastFill
+   *  the Basis will be refactorized.
    */
-   int    iterCount;     ///< number of calls to change() since last manipulation
-   int    lastIterCount; ///< number of calls to change() before halting the simplex
-   int    iterDegenCheck;///< number of calls to change() since last degeneracy check
-   int    updateCount;   ///< number of calls to change() since last factorize()
-   int    totalUpdateCount; ///< number of updates
-   int    nzCount;       ///< number of nonzeros in basis matrix
-   int    lastMem;       ///< memory needed after last fresh factorization
-   R   lastFill;      ///< fill ratio that occured during last factorization
-   int    lastNzCount;   ///< number of nonzeros in basis matrix after last fresh factorization
-
-   Timer* theTime;  ///< time spent in updates
-   Timer::TYPE timerType;   ///< type of timer (user or wallclock)
-
-   SPxId  lastin;        ///< lastEntered(): variable entered the base last
-   SPxId  lastout;       ///< lastLeft(): variable left the base last
-   int    lastidx;       ///< lastIndex(): basis index where last update was done
-   R   minStab;       ///< minimum stability
-   ///@}
+  R fillFactor;
+
+  /// allowed total increase in memory consumption before refactorization
+  R memFactor;
+
+  /* Rank-1-updates to the basis may be performed via method #change(). In
+     this case, the factorization is updated, and the following members are
+     reset.
+  */
+  int iterCount;     ///< number of calls to change() since last manipulation
+  int lastIterCount; ///< number of calls to change() before halting the simplex
+  int iterDegenCheck;   ///< number of calls to change() since last degeneracy
+                        ///< check
+  int updateCount;      ///< number of calls to change() since last factorize()
+  int totalUpdateCount; ///< number of updates
+  int nzCount;          ///< number of nonzeros in basis matrix
+  int lastMem;          ///< memory needed after last fresh factorization
+  R lastFill;           ///< fill ratio that occured during last factorization
+  int lastNzCount;      ///< number of nonzeros in basis matrix after last fresh
+                        ///< factorization
+
+  Timer *theTime;        ///< time spent in updates
+  Timer::TYPE timerType; ///< type of timer (user or wallclock)
+
+  SPxId lastin;  ///< lastEntered(): variable entered the base last
+  SPxId lastout; ///< lastLeft(): variable left the base last
+  int lastidx;   ///< lastIndex(): basis index where last update was done
+  R minStab;     ///< minimum stability
+                 ///@}
 
 private:
+  //------------------------------------
+  //**@name Private data */
+  ///@{
+  SPxStatus thestatus; ///< current status of the basis.
+  Desc thedesc;        ///< the basis' Descriptor
+  bool
+      freeSlinSolver; ///< true iff factor should be freed inside of this object
+  SPxOut *spxout;     ///< message handler
 
-   //------------------------------------
-   //**@name Private data */
-   ///@{
-   SPxStatus thestatus;      ///< current status of the basis.
-   Desc      thedesc;        ///< the basis' Descriptor
-   bool      freeSlinSolver; ///< true iff factor should be freed inside of this object
-   SPxOut*   spxout;         ///< message handler
-
-   ///@}
+  ///@}
 
 public:
+  //------------------------------------------------
+  /**@name Status and Descriptor related Methods */
+  ///@{
+  /// returns current SPxStatus.
+  SPxStatus status() const { return thestatus; }
+
+  /// sets basis SPxStatus to \p stat.
+  void setStatus(SPxStatus stat) {
 
-   //------------------------------------------------
-   /**@name Status and Descriptor related Methods */
-   ///@{
-   /// returns current SPxStatus.
-   SPxStatus status() const
-   {
-      return thestatus;
-   }
-
-   /// sets basis SPxStatus to \p stat.
-   void setStatus(SPxStatus stat)
-   {
-
-      if(thestatus != stat)
-      {
+    if (thestatus != stat) {
 #ifdef SOPLEX_DEBUG
-         MSG_DEBUG(std::cout << "DBSTAT01 SPxBasisBase<R>::setStatus(): status: "
-                   << int(thestatus) << " (" << thestatus << ") -> "
-                   << int(stat) << " (" << stat << ")" << std::endl;)
+      MSG_DEBUG(std::cout << "DBSTAT01 SPxBasisBase<R>::setStatus(): status: "
+                          << int(thestatus) << " (" << thestatus << ") -> "
+                          << int(stat) << " (" << stat << ")" << std::endl;)
 #endif
 
-         thestatus = stat;
-
-         if(stat == NO_PROBLEM)
-            invalidate();
-      }
-   }
-
-   // TODO control factorization frequency dynamically
-   /// change maximum number of iterations until a refactorization is performed
-   void setMaxUpdates(int maxUp)
-   {
-      assert(maxUp >= 0);
-      maxUpdates = maxUp;
-   }
-
-   /// returns maximum number of updates before a refactorization is performed
-   int getMaxUpdates() const
-   {
-      return maxUpdates;
-   }
-
-   ///
-   const Desc& desc() const
-   {
-      return thedesc;
-   }
-   /// returns current basis Descriptor.
-   Desc& desc()
-   {
-      return thedesc;
-   }
-
-   /// dual Status for the \p i'th column variable of the loaded LP.
-   typename Desc::Status dualColStatus(int i) const;
-
-   /// dual Status for the column variable with ID \p id of the loaded LP.
-   typename Desc::Status dualStatus(const SPxColId& id) const;
-
-   /// dual Status for the \p i'th row variable of the loaded LP.
-   typename Desc::Status dualRowStatus(int i) const;
-
-   /// dual Status for the row variable with ID \p id of the loaded LP.
-   typename Desc::Status dualStatus(const SPxRowId& id) const;
-
-   /// dual Status for the variable with ID \p id of the loaded LP.
-   /** It is automatically detected, whether the \p id is one of a
-       row or a column variable, and the correct row or column status
-       is returned.
+      thestatus = stat;
+
+      if (stat == NO_PROBLEM)
+        invalidate();
+    }
+  }
+
+  // TODO control factorization frequency dynamically
+  /// change maximum number of iterations until a refactorization is performed
+  void setMaxUpdates(int maxUp) {
+    assert(maxUp >= 0);
+    maxUpdates = maxUp;
+  }
+
+  /// returns maximum number of updates before a refactorization is performed
+  int getMaxUpdates() const { return maxUpdates; }
+
+  ///
+  const Desc &desc() const { return thedesc; }
+  /// returns current basis Descriptor.
+  Desc &desc() { return thedesc; }
+
+  /// dual Status for the \p i'th column variable of the loaded LP.
+  typename Desc::Status dualColStatus(int i) const;
+
+  /// dual Status for the column variable with ID \p id of the loaded LP.
+  typename Desc::Status dualStatus(const SPxColId &id) const;
+
+  /// dual Status for the \p i'th row variable of the loaded LP.
+  typename Desc::Status dualRowStatus(int i) const;
+
+  /// dual Status for the row variable with ID \p id of the loaded LP.
+  typename Desc::Status dualStatus(const SPxRowId &id) const;
+
+  /// dual Status for the variable with ID \p id of the loaded LP.
+  /** It is automatically detected, whether the \p id is one of a
+      row or a column variable, and the correct row or column status
+      is returned.
+  */
+  typename Desc::Status dualStatus(const SPxId &id) const {
+    return id.isSPxRowId() ? dualStatus(SPxRowId(id))
+                           : dualStatus(SPxColId(id));
+  }
+  ///@}
+
+  //-----------------------------------
+  /**@name Inquiry Methods */
+  ///@{
+  ///
+  inline SPxId &baseId(int i) { return theBaseId[i]; }
+  /// returns the Id of the \p i'th basis vector.
+  inline SPxId baseId(int i) const { return theBaseId[i]; }
+
+  /// returns the \p i'th basic vector.
+  const SVectorBase<R> &baseVec(int i) const {
+    assert(matrixIsSetup);
+    return *matrix[i];
+  }
+
+  /// returns SPxId of last VectorBase<R> included to the basis.
+  inline SPxId lastEntered() const { return lastin; }
+
+  /// returns SPxId of last vector that left the basis.
+  inline SPxId lastLeft() const { return lastout; }
+
+  /// returns index in basis where last update was done.
+  inline int lastIndex() const { return lastidx; }
+
+  /// returns number of basis changes since last refactorization.
+  inline int lastUpdate() const { return updateCount; }
+
+  /// returns number of basis changes since last \ref
+  /// soplex::SPxBasisBase<R>::load() "load()".
+  inline int iteration() const { return iterCount; }
+
+  /// returns the number of iterations prior to the last break in execution
+  inline int prevIteration() const { return lastIterCount; }
+
+  /// returns the number of iterations since the last degeneracy check
+  inline int lastDegenCheck() const { return iterDegenCheck; }
+
+  /// returns loaded solver.
+  inline SPxSolverBase<R> *solver() const { return theLP; }
+  ///@}
+
+  //-----------------------------------
+  /**@name Linear Algebra */
+  ///@{
+  /// Basis-vector product.
+  /** Depending on the representation, for an SPxBasisBase B,
+      B.multBaseWith(x) computes
+      - \f$x \leftarrow Bx\f$    in the columnwise case, and
+      - \f$x \leftarrow x^TB\f$  in the rowwise case.
+
+      Both can be seen uniformly as multiplying the basis matrix \p B with
+      a vector \p x aligned the same way as the \em vectors of \p B.
+  */
+  VectorBase<R> &multBaseWith(VectorBase<R> &x) const;
+
+  /// Basis-vector product
+  void multBaseWith(SSVectorBase<R> &x, SSVectorBase<R> &result) const;
+
+  /// Vector-basis product.
+  /** Depending on the representation, for a #SPxBasisBase B,
+      B.multWithBase(x) computes
+      - \f$x \leftarrow x^TB\f$  in the columnwise case and
+      - \f$x \leftarrow Bx\f$    in the rowwise case.
+
+      Both can be seen uniformly as multiplying the basis matrix \p B with
+      a vector \p x aligned the same way as the \em covectors of \p B.
+  */
+  VectorBase<R> &multWithBase(VectorBase<R> &x) const;
+
+  /// VectorBase<R>-basis product
+  void multWithBase(SSVectorBase<R> &x, SSVectorBase<R> &result) const;
+
+  /* compute an estimated condition number for the current basis matrix
+   * by computing estimates of the norms of B and B^-1 using the power method.
+   * maxiters and tolerance control the accuracy of the estimate.
    */
-   typename Desc::Status dualStatus(const SPxId& id) const
-   {
-      return id.isSPxRowId()
-             ? dualStatus(SPxRowId(id))
-             : dualStatus(SPxColId(id));
-   }
-   ///@}
-
-
-   //-----------------------------------
-   /**@name Inquiry Methods */
-   ///@{
-   ///
-   inline SPxId& baseId(int i)
-   {
-      return theBaseId[i];
-   }
-   /// returns the Id of the \p i'th basis vector.
-   inline SPxId baseId(int i) const
-   {
-      return theBaseId[i];
-   }
-
-   /// returns the \p i'th basic vector.
-   const SVectorBase<R>& baseVec(int i) const
-   {
-      assert(matrixIsSetup);
-      return *matrix[i];
-   }
-
-   /// returns SPxId of last VectorBase<R> included to the basis.
-   inline SPxId lastEntered() const
-   {
-      return lastin;
-   }
-
-   /// returns SPxId of last vector that left the basis.
-   inline SPxId lastLeft() const
-   {
-      return lastout;
-   }
-
-   /// returns index in basis where last update was done.
-   inline int lastIndex() const
-   {
-      return lastidx;
-   }
-
-   /// returns number of basis changes since last refactorization.
-   inline int lastUpdate() const
-   {
-      return updateCount;
-   }
-
-   /// returns number of basis changes since last \ref soplex::SPxBasisBase<R>::load() "load()".
-   inline int iteration() const
-   {
-      return iterCount;
-   }
-
-   /// returns the number of iterations prior to the last break in execution
-   inline int prevIteration() const
-   {
-      return lastIterCount;
-   }
-
-   /// returns the number of iterations since the last degeneracy check
-   inline int lastDegenCheck() const
-   {
-      return iterDegenCheck;
-   }
-
-   /// returns loaded solver.
-   inline SPxSolverBase<R>* solver() const
-   {
-      return theLP;
-   }
-   ///@}
-
-   //-----------------------------------
-   /**@name Linear Algebra */
-   ///@{
-   /// Basis-vector product.
-   /** Depending on the representation, for an SPxBasisBase B,
-       B.multBaseWith(x) computes
-       - \f$x \leftarrow Bx\f$    in the columnwise case, and
-       - \f$x \leftarrow x^TB\f$  in the rowwise case.
-
-       Both can be seen uniformly as multiplying the basis matrix \p B with
-       a vector \p x aligned the same way as the \em vectors of \p B.
-   */
-   VectorBase<R>& multBaseWith(VectorBase<R>& x) const;
-
-   /// Basis-vector product
-   void multBaseWith(SSVectorBase<R>& x, SSVectorBase<R>& result) const;
+  R condition(int maxiters = 10, R tolerance = 1e-6);
 
-   /// Vector-basis product.
-   /** Depending on the representation, for a #SPxBasisBase B,
-       B.multWithBase(x) computes
-       - \f$x \leftarrow x^TB\f$  in the columnwise case and
-       - \f$x \leftarrow Bx\f$    in the rowwise case.
+  /* wrapper to compute an estimate of the condition number of the current basis
+   * matrix */
+  R getEstimatedCondition() { return condition(20, 1e-6); }
 
-       Both can be seen uniformly as multiplying the basis matrix \p B with
-       a vector \p x aligned the same way as the \em covectors of \p B.
+  /* wrapper to compute the exact condition number of the current basis matrix
    */
-   VectorBase<R>& multWithBase(VectorBase<R>& x) const;
+  R getExactCondition() { return condition(1000, 1e-9); }
 
-   /// VectorBase<R>-basis product
-   void multWithBase(SSVectorBase<R>& x, SSVectorBase<R>& result) const;
-
-   /* compute an estimated condition number for the current basis matrix
-    * by computing estimates of the norms of B and B^-1 using the power method.
-    * maxiters and tolerance control the accuracy of the estimate.
-    */
-   R condition(int maxiters = 10, R tolerance = 1e-6);
-
-   /* wrapper to compute an estimate of the condition number of the current basis matrix */
-   R getEstimatedCondition()
-   {
-      return condition(20, 1e-6);
-   }
-
-   /* wrapper to compute the exact condition number of the current basis matrix */
-   R getExactCondition()
-   {
-      return condition(1000, 1e-9);
-   }
-
-   /** compute one of several matrix metrics based on the diagonal of the LU factorization
-     * type = 0: max/min ratio
-     * type = 1: trace of U (sum of diagonal elements)
-    *  type = 2: determinant (product of diagonal elements)
-     */
-   R getMatrixMetric(int type = 0);
-
-   /// returns the stability of the basis matrix.
-   R stability() const
-   {
-      return factor->stability();
-   }
-   ///
-   void solve(VectorBase<R>& x, const VectorBase<R>& rhs)
-   {
-      if(rhs.dim() == 0)
-      {
-         x.clear();
-         return;
-      }
-
-      if(!factorized)
-         SPxBasisBase<R>::factorize();
-
-      factor->solveRight(x, rhs);
-   }
-   ///
-   void solve(SSVectorBase<R>& x, const SVectorBase<R>& rhs)
-   {
-      if(rhs.size() == 0)
-      {
-         x.clear();
-         return;
-      }
-
-      if(!factorized)
-         SPxBasisBase<R>::factorize();
-
-      factor->solveRight(x, rhs);
-   }
-   /// solves linear system with basis matrix.
-   /** Depending on the representation, for a SPxBasisBase B,
-       B.solve(x) computes
-       - \f$x \leftarrow B^{-1}rhs\f$       in the columnwise case and
-       - \f$x \leftarrow rhs^TB^{-1}\f$     in the rowwise case.
-
-       Both can be seen uniformly as solving a linear system with the basis
-       matrix \p B and a right handside vector \p x aligned the same way as
-       the \em vectors of \p B.
-   */
-   void solve4update(SSVectorBase<R>& x, const SVectorBase<R>& rhs)
-   {
-      if(rhs.size() == 0)
-      {
-         x.clear();
-         return;
-      }
-
-      if(!factorized)
-         SPxBasisBase<R>::factorize();
-
-      factor->solveRight4update(x, rhs);
-   }
-   /// solves two systems in one call.
-   void solve4update(SSVectorBase<R>& x, VectorBase<R>& y, const SVectorBase<R>& rhsx,
-                     SSVectorBase<R>& rhsy)
-   {
-      if(!factorized)
-         SPxBasisBase<R>::factorize();
-
-      factor->solve2right4update(x, y, rhsx, rhsy);
-   }
-   /// solves two systems in one call using only sparse data structures
-   void solve4update(SSVectorBase<R>& x, SSVectorBase<R>& y, const SVectorBase<R>& rhsx,
-                     SSVectorBase<R>& rhsy)
-   {
-      if(!factorized)
-         SPxBasisBase<R>::factorize();
-
-      factor->solve2right4update(x, y, rhsx, rhsy);
-   }
-   /// solves three systems in one call.
-   void solve4update(SSVectorBase<R>& x, VectorBase<R>& y, VectorBase<R>& y2,
-                     const SVectorBase<R>& rhsx, SSVectorBase<R>& rhsy, SSVectorBase<R>& rhsy2)
-   {
-      if(!factorized)
-         SPxBasisBase<R>::factorize();
-
-      assert(rhsy.isSetup());
-      assert(rhsy2.isSetup());
-      factor->solve3right4update(x, y, y2, rhsx, rhsy, rhsy2);
-   }
-   /// solves three systems in one call using only sparse data structures
-   void solve4update(SSVectorBase<R>& x, SSVectorBase<R>& y, SSVectorBase<R>& y2,
-                     const SVectorBase<R>& rhsx, SSVectorBase<R>& rhsy, SSVectorBase<R>& rhsy2)
-   {
-      if(!factorized)
-         SPxBasisBase<R>::factorize();
-
-      assert(rhsy.isSetup());
-      assert(rhsy2.isSetup());
-      factor->solve3right4update(x, y, y2, rhsx, rhsy, rhsy2);
-   }
-   /// Cosolves linear system with basis matrix.
-   /** Depending on the representation, for a SPxBasisBase B,
-       B.coSolve(x) computes
-       - \f$x \leftarrow rhs^TB^{-1}\f$     in the columnwise case and
-       - \f$x \leftarrow B^{-1}rhs\f$       in the rowwise case.
-
-       Both can be seen uniformly as solving a linear system with the basis
-       matrix \p B and a right handside vector \p x aligned the same way as
-       the \em covectors of \p B.
+  /** compute one of several matrix metrics based on the diagonal of the LU
+   * factorization type = 0: max/min ratio type = 1: trace of U (sum of diagonal
+   * elements) type = 2: determinant (product of diagonal elements)
    */
-   void coSolve(VectorBase<R>& x, const VectorBase<R>& rhs)
-   {
-      if(rhs.dim() == 0)
-      {
-         x.clear();
-         return;
-      }
-
-      if(!factorized)
-         SPxBasisBase<R>::factorize();
-
-      factor->solveLeft(x, rhs);
-   }
-   /// Sparse version of coSolve
-   void coSolve(SSVectorBase<R>& x, const SVectorBase<R>& rhs)
-   {
-      if(rhs.size() == 0)
-      {
-         x.clear();
-         return;
-      }
-
-      if(!factorized)
-         SPxBasisBase<R>::factorize();
-
-      factor->solveLeft(x, rhs);
-   }
-   /// solves two systems in one call.
-   void coSolve(SSVectorBase<R>& x, VectorBase<R>& y, const SVectorBase<R>& rhsx,
-                SSVectorBase<R>& rhsy)
-   {
-      if(!factorized)
-         SPxBasisBase<R>::factorize();
-
-      factor->solveLeft(x, y, rhsx, rhsy);
-   }
-   /// Sparse version of solving two systems in one call.
-   void coSolve(SSVectorBase<R>& x, SSVectorBase<R>& y, const SVectorBase<R>& rhsx,
-                SSVectorBase<R>& rhsy)
-   {
-      if(!factorized)
-         SPxBasisBase<R>::factorize();
-
-      factor->solveLeft(x, y, rhsx, rhsy);
-   }
-   /// solves three systems in one call. May be improved by using just one pass through the basis.
-   void coSolve(SSVectorBase<R>& x, VectorBase<R>& y, VectorBase<R>& z, const SVectorBase<R>& rhsx,
-                SSVectorBase<R>& rhsy, SSVectorBase<R>& rhsz)
-   {
-      if(!factorized)
-         SPxBasisBase<R>::factorize();
-
-      factor->solveLeft(x, y, z, rhsx, rhsy, rhsz);
-   }
-   /// Sparse version of solving three systems in one call.
-   void coSolve(SSVectorBase<R>& x, SSVectorBase<R>& y, SSVectorBase<R>& z, const SVectorBase<R>& rhsx,
-                SSVectorBase<R>& rhsy, SSVectorBase<R>& rhsz)
-   {
-      if(!factorized)
-         SPxBasisBase<R>::factorize();
-
-      factor->solveLeft(x, y, z, rhsx, rhsy, rhsz);
-   }
-   ///@}
-
-
-   //------------------------------------
-   /**@name Modification notification.
-      These methods must be called after the loaded LP has been modified.
+  R getMatrixMetric(int type = 0);
+
+  /// returns the stability of the basis matrix.
+  R stability() const { return factor->stability(); }
+  ///
+  void solve(VectorBase<R> &x, const VectorBase<R> &rhs) {
+    if (rhs.dim() == 0) {
+      x.clear();
+      return;
+    }
+
+    if (!factorized)
+      SPxBasisBase<R>::factorize();
+
+    factor->solveRight(x, rhs);
+  }
+  ///
+  void solve(SSVectorBase<R> &x, const SVectorBase<R> &rhs) {
+    if (rhs.size() == 0) {
+      x.clear();
+      return;
+    }
+
+    if (!factorized)
+      SPxBasisBase<R>::factorize();
+
+    factor->solveRight(x, rhs);
+  }
+  /// solves linear system with basis matrix.
+  /** Depending on the representation, for a SPxBasisBase B,
+      B.solve(x) computes
+      - \f$x \leftarrow B^{-1}rhs\f$       in the columnwise case and
+      - \f$x \leftarrow rhs^TB^{-1}\f$     in the rowwise case.
+
+      Both can be seen uniformly as solving a linear system with the basis
+      matrix \p B and a right handside vector \p x aligned the same way as
+      the \em vectors of \p B.
+  */
+  void solve4update(SSVectorBase<R> &x, const SVectorBase<R> &rhs) {
+    if (rhs.size() == 0) {
+      x.clear();
+      return;
+    }
+
+    if (!factorized)
+      SPxBasisBase<R>::factorize();
+
+    factor->solveRight4update(x, rhs);
+  }
+  /// solves two systems in one call.
+  void solve4update(SSVectorBase<R> &x, VectorBase<R> &y,
+                    const SVectorBase<R> &rhsx, SSVectorBase<R> &rhsy) {
+    if (!factorized)
+      SPxBasisBase<R>::factorize();
+
+    factor->solve2right4update(x, y, rhsx, rhsy);
+  }
+  /// solves two systems in one call using only sparse data structures
+  void solve4update(SSVectorBase<R> &x, SSVectorBase<R> &y,
+                    const SVectorBase<R> &rhsx, SSVectorBase<R> &rhsy) {
+    if (!factorized)
+      SPxBasisBase<R>::factorize();
+
+    factor->solve2right4update(x, y, rhsx, rhsy);
+  }
+  /// solves three systems in one call.
+  void solve4update(SSVectorBase<R> &x, VectorBase<R> &y, VectorBase<R> &y2,
+                    const SVectorBase<R> &rhsx, SSVectorBase<R> &rhsy,
+                    SSVectorBase<R> &rhsy2) {
+    if (!factorized)
+      SPxBasisBase<R>::factorize();
+
+    assert(rhsy.isSetup());
+    assert(rhsy2.isSetup());
+    factor->solve3right4update(x, y, y2, rhsx, rhsy, rhsy2);
+  }
+  /// solves three systems in one call using only sparse data structures
+  void solve4update(SSVectorBase<R> &x, SSVectorBase<R> &y, SSVectorBase<R> &y2,
+                    const SVectorBase<R> &rhsx, SSVectorBase<R> &rhsy,
+                    SSVectorBase<R> &rhsy2) {
+    if (!factorized)
+      SPxBasisBase<R>::factorize();
+
+    assert(rhsy.isSetup());
+    assert(rhsy2.isSetup());
+    factor->solve3right4update(x, y, y2, rhsx, rhsy, rhsy2);
+  }
+  /// Cosolves linear system with basis matrix.
+  /** Depending on the representation, for a SPxBasisBase B,
+      B.coSolve(x) computes
+      - \f$x \leftarrow rhs^TB^{-1}\f$     in the columnwise case and
+      - \f$x \leftarrow B^{-1}rhs\f$       in the rowwise case.
+
+      Both can be seen uniformly as solving a linear system with the basis
+      matrix \p B and a right handside vector \p x aligned the same way as
+      the \em covectors of \p B.
+  */
+  void coSolve(VectorBase<R> &x, const VectorBase<R> &rhs) {
+    if (rhs.dim() == 0) {
+      x.clear();
+      return;
+    }
+
+    if (!factorized)
+      SPxBasisBase<R>::factorize();
+
+    factor->solveLeft(x, rhs);
+  }
+  /// Sparse version of coSolve
+  void coSolve(SSVectorBase<R> &x, const SVectorBase<R> &rhs) {
+    if (rhs.size() == 0) {
+      x.clear();
+      return;
+    }
+
+    if (!factorized)
+      SPxBasisBase<R>::factorize();
+
+    factor->solveLeft(x, rhs);
+  }
+  /// solves two systems in one call.
+  void coSolve(SSVectorBase<R> &x, VectorBase<R> &y, const SVectorBase<R> &rhsx,
+               SSVectorBase<R> &rhsy) {
+    if (!factorized)
+      SPxBasisBase<R>::factorize();
+
+    factor->solveLeft(x, y, rhsx, rhsy);
+  }
+  /// Sparse version of solving two systems in one call.
+  void coSolve(SSVectorBase<R> &x, SSVectorBase<R> &y,
+               const SVectorBase<R> &rhsx, SSVectorBase<R> &rhsy) {
+    if (!factorized)
+      SPxBasisBase<R>::factorize();
+
+    factor->solveLeft(x, y, rhsx, rhsy);
+  }
+  /// solves three systems in one call. May be improved by using just one pass
+  /// through the basis.
+  void coSolve(SSVectorBase<R> &x, VectorBase<R> &y, VectorBase<R> &z,
+               const SVectorBase<R> &rhsx, SSVectorBase<R> &rhsy,
+               SSVectorBase<R> &rhsz) {
+    if (!factorized)
+      SPxBasisBase<R>::factorize();
+
+    factor->solveLeft(x, y, z, rhsx, rhsy, rhsz);
+  }
+  /// Sparse version of solving three systems in one call.
+  void coSolve(SSVectorBase<R> &x, SSVectorBase<R> &y, SSVectorBase<R> &z,
+               const SVectorBase<R> &rhsx, SSVectorBase<R> &rhsy,
+               SSVectorBase<R> &rhsz) {
+    if (!factorized)
+      SPxBasisBase<R>::factorize();
+
+    factor->solveLeft(x, y, z, rhsx, rhsy, rhsz);
+  }
+  ///@}
+
+  //------------------------------------
+  /**@name Modification notification.
+     These methods must be called after the loaded LP has been modified.
+  */
+  ///@{
+  /// inform SPxBasisBase, that \p n new rows had been added.
+  void addedRows(int n);
+  /// inform SPxBasisBase that row \p i had been removed.
+  void removedRow(int i);
+  /// inform SPxBasisBase that rows in \p perm with negative entry were removed.
+  void removedRows(const int perm[]);
+  /// inform SPxBasisBase that \p n new columns had been added.
+  void addedCols(int n);
+  /// inform SPxBasisBase that column \p i had been removed.
+  void removedCol(int i);
+  /// inform SPxBasisBase that columns in \p perm with negative entry were
+  /// removed.
+  void removedCols(const int perm[]);
+  /// inform SPxBasisBase that a row had been changed.
+  void changedRow(int);
+  /// inform SPxBasisBase that a column had been changed.
+  void changedCol(int);
+  /// inform SPxBasisBase that a matrix entry had been changed.
+  void changedElement(int, int);
+  ///@}
+
+  //--------------------------------
+  /**@name Miscellaneous */
+  ///@{
+  /// performs basis update.
+  /** Changes the \p i 'th vector of the basis with the vector associated to
+      \p id. This includes:
+      - updating the factorization, or recomputing it from scratch by
+      calling   \ref soplex::SPxSolverBase<R>::factorize()   "factorize()",
+      - resetting \ref soplex::SPxSolverBase<R>::lastEntered() "lastEntered()",
+      - resetting \ref soplex::SPxSolverBase<R>::lastIndex()   "lastIndex()",
+      - resetting \ref soplex::SPxSolverBase<R>::lastLeft()    "lastLeft()",
+      - resetting \ref soplex::SPxSolverBase<R>::lastUpdate()  "lastUpdate()",
+      - resetting \ref soplex::SPxSolverBase<R>::iterations()  "iterations()".
+
+      The basis descriptor is \em not \em modified, since #factor()
+      cannot know about how to set up the status of the involved variables
+      correctly.
+
+      A vector \p enterVec may be passed for a fast ETA update of the LU
+      factorization associated to the basis. It must be initialized with
+      the solution vector \f$x\f$ of the right linear system \f$Bx = b\f$
+      with the entering vector as right-hand side vector \f$b\f$, where \f$B\f$
+      denotes the basis matrix. This can be computed using method #solve().
+      When using FAST updates, a vector \p eta may be passed for
+      improved performance. It must be initialized by a call to
+      factor->solveRightUpdate() as described in SLinSolver. The
+      implementation hidden behind FAST updates depends on the
+      SLinSolver implementation class.
+  */
+  virtual void change(int i, SPxId &id, const SVectorBase<R> *enterVec,
+                      const SSVectorBase<R> *eta = 0);
+
+  /** Load basis from \p in in MPS format. If \p rowNames and \p colNames
+   *  are \c NULL, default names are used for the constraints and variables.
    */
-   ///@{
-   /// inform SPxBasisBase, that \p n new rows had been added.
-   void addedRows(int n);
-   /// inform SPxBasisBase that row \p i had been removed.
-   void removedRow(int i);
-   /// inform SPxBasisBase that rows in \p perm with negative entry were removed.
-   void removedRows(const int perm[]);
-   /// inform SPxBasisBase that \p n new columns had been added.
-   void addedCols(int n);
-   /// inform SPxBasisBase that column \p i had been removed.
-   void removedCol(int i);
-   /// inform SPxBasisBase that columns in \p perm with negative entry were removed.
-   void removedCols(const int perm[]);
-   /// inform SPxBasisBase that a row had been changed.
-   void changedRow(int);
-   /// inform SPxBasisBase that a column had been changed.
-   void changedCol(int);
-   /// inform SPxBasisBase that a matrix entry had been changed.
-   void changedElement(int, int);
-   ///@}
-
-
-   //--------------------------------
-   /**@name Miscellaneous */
-   ///@{
-   /// performs basis update.
-   /** Changes the \p i 'th vector of the basis with the vector associated to
-       \p id. This includes:
-       - updating the factorization, or recomputing it from scratch by
-       calling   \ref soplex::SPxSolverBase<R>::factorize()   "factorize()",
-       - resetting \ref soplex::SPxSolverBase<R>::lastEntered() "lastEntered()",
-       - resetting \ref soplex::SPxSolverBase<R>::lastIndex()   "lastIndex()",
-       - resetting \ref soplex::SPxSolverBase<R>::lastLeft()    "lastLeft()",
-       - resetting \ref soplex::SPxSolverBase<R>::lastUpdate()  "lastUpdate()",
-       - resetting \ref soplex::SPxSolverBase<R>::iterations()  "iterations()".
-
-       The basis descriptor is \em not \em modified, since #factor()
-       cannot know about how to set up the status of the involved variables
-       correctly.
-
-       A vector \p enterVec may be passed for a fast ETA update of the LU
-       factorization associated to the basis. It must be initialized with
-       the solution vector \f$x\f$ of the right linear system \f$Bx = b\f$
-       with the entering vector as right-hand side vector \f$b\f$, where \f$B\f$
-       denotes the basis matrix. This can be computed using method #solve().
-       When using FAST updates, a vector \p eta may be passed for
-       improved performance. It must be initialized by a call to
-       factor->solveRightUpdate() as described in SLinSolver. The
-       implementation hidden behind FAST updates depends on the
-       SLinSolver implementation class.
-   */
-   virtual void change(int i, SPxId& id,
-                       const SVectorBase<R>* enterVec, const SSVectorBase<R>* eta = 0);
-
-   /** Load basis from \p in in MPS format. If \p rowNames and \p colNames
-    *  are \c NULL, default names are used for the constraints and variables.
-    */
-   virtual bool readBasis(std::istream& in,
-                          const NameSet* rowNames, const NameSet* colNames);
+  virtual bool readBasis(std::istream &in, const NameSet *rowNames,
+                         const NameSet *colNames);
 
-   /** Write basis to \p os in MPS format. If \p rowNames and \p colNames are
-    *  \c NULL, default names are used for the constraints and variables.
-    */
-   virtual void writeBasis(std::ostream& os,
-                           const NameSet* rownames, const NameSet* colnames, const bool cpxFormat = false) const;
-
-   virtual void printMatrix() const;
-
-   /** Prints current basis matrix to a file using the MatrixMarket format:
-    *  row col value
-    *  The filename is basis/basis[number].mtx where number is a parameter.
-    */
-   void printMatrixMTX(int number);
+  /** Write basis to \p os in MPS format. If \p rowNames and \p colNames are
+   *  \c NULL, default names are used for the constraints and variables.
+   */
+  virtual void writeBasis(std::ostream &os, const NameSet *rownames,
+                          const NameSet *colnames,
+                          const bool cpxFormat = false) const;
 
-   /// checks if a Descriptor is valid for the current LP w.r.t. its bounds
-   virtual bool isDescValid(const Desc& ds);
+  virtual void printMatrix() const;
 
-   /// sets up basis.
-   /** Loads a Descriptor to the basis and sets up the basis matrix and
-       all vectors accordingly. The Descriptor must have the same number of
-       rows and columns as the currently loaded LP.
+  /** Prints current basis matrix to a file using the MatrixMarket format:
+   *  row col value
+   *  The filename is basis/basis[number].mtx where number is a parameter.
    */
-   virtual void loadDesc(const Desc&);
+  void printMatrixMTX(int number);
 
-   /// sets up linear solver to use.
-   /** If destroy is true, solver will be freed inside this object, e.g. in the destructor.
-    */
-   virtual void loadBasisSolver(SLinSolver<R>* solver, const bool destroy = false);
+  /// checks if a Descriptor is valid for the current LP w.r.t. its bounds
+  virtual bool isDescValid(const Desc &ds);
 
-   /// loads the LP \p lp to the basis.
-   /** This involves resetting all counters to 0 and setting up a regular
-       default basis consisting of slacks, artificial variables or bounds.
-   */
-   virtual void load(SPxSolverBase<R>* lp, bool initSlackBasis = true);
-
-   /// unloads the LP from the basis.
-   virtual void unLoad()
-   {
-      theLP = 0;
-      setStatus(NO_PROBLEM);
-   }
-
-   /// invalidates actual basis.
-   /** This method makes the basis matrix and vectors invalid. The basis will
-       be reinitialized if needed.
-   */
-   void invalidate();
+  /// sets up basis.
+  /** Loads a Descriptor to the basis and sets up the basis matrix and
+      all vectors accordingly. The Descriptor must have the same number of
+      rows and columns as the currently loaded LP.
+  */
+  virtual void loadDesc(const Desc &);
 
-   /// Restores initial basis.
-   /** This method changes the basis to that present just after loading the LP
-       (see addedRows() and addedCols()). This may be necessary if a row or a
-       column is changed, since then the current basis may become singular.
+  /// sets up linear solver to use.
+  /** If destroy is true, solver will be freed inside this object, e.g. in the
+   * destructor.
    */
-   void restoreInitialBasis();
-
-   /// output basis entries.
-   void dump();
-
-   /// consistency check.
-   bool isConsistent() const;
-
-   /// time spent in updates
-   Real getTotalUpdateTime() const
-   {
-      return theTime->time();
-   }
-   /// number of updates performed
-   int getTotalUpdateCount() const
-   {
-      return totalUpdateCount;
-   }
-
-   /// returns statistical information in form of a string.
-   std::string statistics() const
-   {
-      std::stringstream s;
-      s  << factor->statistics()
+  virtual void loadBasisSolver(SLinSolver<R> *solver,
+                               const bool destroy = false);
+
+  /// loads the LP \p lp to the basis.
+  /** This involves resetting all counters to 0 and setting up a regular
+      default basis consisting of slacks, artificial variables or bounds.
+  */
+  virtual void load(SPxSolverBase<R> *lp, bool initSlackBasis = true);
+
+  /// unloads the LP from the basis.
+  virtual void unLoad() {
+    theLP = 0;
+    setStatus(NO_PROBLEM);
+  }
+
+  /// invalidates actual basis.
+  /** This method makes the basis matrix and vectors invalid. The basis will
+      be reinitialized if needed.
+  */
+  void invalidate();
+
+  /// Restores initial basis.
+  /** This method changes the basis to that present just after loading the LP
+      (see addedRows() and addedCols()). This may be necessary if a row or a
+      column is changed, since then the current basis may become singular.
+  */
+  void restoreInitialBasis();
+
+  /// output basis entries.
+  void dump();
+
+  /// consistency check.
+  bool isConsistent() const;
+
+  /// time spent in updates
+  Real getTotalUpdateTime() const { return theTime->time(); }
+  /// number of updates performed
+  int getTotalUpdateCount() const { return totalUpdateCount; }
+
+  /// returns statistical information in form of a string.
+  std::string statistics() const {
+    std::stringstream s;
+    s << factor->statistics()
 #ifdef MEASUREUPDATETIME
-         << "Updates            : " << std::setw(10) << getTotalUpdateCount() << std::endl
-         << "  Time spent       : " << std::setw(10) << getTotalUpdateTime() << std::endl
+      << "Updates            : " << std::setw(10) << getTotalUpdateCount()
+      << std::endl
+      << "  Time spent       : " << std::setw(10) << getTotalUpdateTime()
+      << std::endl
 #endif
-         ;
-
-      return s.str();
-   }
-
-   void setOutstream(SPxOut& newOutstream)
-   {
-      spxout = &newOutstream;
-   }
-   ///@}
-
-   //--------------------------------------
-   /**@name Constructors / Destructors */
-   ///@{
-   /// default constructor.
-   SPxBasisBase<R>(Timer::TYPE ttype = Timer::USER_TIME);
-   /// copy constructor
-   SPxBasisBase<R>(const SPxBasisBase<R>& old);
-   /// assignment operator
-   SPxBasisBase<R>& operator=(const SPxBasisBase<R>& rhs);
-   /// destructor.
-   virtual ~SPxBasisBase<R>();
-   ///@}
-
+        ;
+
+    return s.str();
+  }
+
+  void setOutstream(SPxOut &newOutstream) { spxout = &newOutstream; }
+  ///@}
+
+  //--------------------------------------
+  /**@name Constructors / Destructors */
+  ///@{
+  /// default constructor.
+  SPxBasisBase(Timer::TYPE ttype = Timer::USER_TIME);
+  /// copy constructor
+  SPxBasisBase(const SPxBasisBase<R> &old);
+  /// assignment operator
+  SPxBasisBase<R> &operator=(const SPxBasisBase<R> &rhs);
+  /// destructor.
+  virtual ~SPxBasisBase();
+  ///@}
 
 protected:
-
-   //--------------------------------------
-   /**@name Protected helpers */
-   ///@{
-   /// loads \ref soplex::SPxBasisBase<R>::matrix "matrix" according to the SPxId%s stored in \ref soplex::SPxBasisBase<R>::theBaseId "theBaseId".
-   /** This method must  be called whenever there is a chance, that the vector
-       pointers may have changed due to manipulations of the LP.
-   */
-   void loadMatrixVecs();
-
-   /// resizes internal arrays.
-   /** When a new LP is loaded, the basis matrix and vectors become invalid
-       and possibly also of the wrong dimension. Hence, after loading an
-       LP, #reDim() is called to reset all arrays etc. accoriding to the
-       dimensions of the loaded LP.
-   */
-   void reDim();
-
-   /// factorizes the basis matrix.
-   virtual void factorize();
-
-   /// sets descriptor representation according to loaded LP.
-   void setRep();
-   ///@}
-
+  //--------------------------------------
+  /**@name Protected helpers */
+  ///@{
+  /// loads \ref soplex::SPxBasisBase<R>::matrix "matrix" according to the
+  /// SPxId%s stored in \ref soplex::SPxBasisBase<R>::theBaseId "theBaseId".
+  /** This method must  be called whenever there is a chance, that the vector
+      pointers may have changed due to manipulations of the LP.
+  */
+  void loadMatrixVecs();
+
+  /// resizes internal arrays.
+  /** When a new LP is loaded, the basis matrix and vectors become invalid
+      and possibly also of the wrong dimension. Hence, after loading an
+      LP, #reDim() is called to reset all arrays etc. accoriding to the
+      dimensions of the loaded LP.
+  */
+  void reDim();
+
+  /// factorizes the basis matrix.
+  virtual void factorize();
+
+  /// sets descriptor representation according to loaded LP.
+  void setRep();
+  ///@}
 };
 
-
 //
 // Auxiliary functions.
 //
 
 /// Pretty-printing of basis status.
 template <class R>
-std::ostream& operator<<(std::ostream& os,
-                         const typename SPxBasisBase<R>::SPxStatus& status);
-
+std::ostream &operator<<(std::ostream &os,
+                         const typename SPxBasisBase<R>::SPxStatus &status);
 
 /* For backwards compatibility */
 typedef SPxBasisBase<Real> SPxBasis;
diff --git a/src/soplex/spxbasis.hpp b/src/soplex/spxbasis.hpp
index dca1d6c..b7ecb79 100644
--- a/src/soplex/spxbasis.hpp
+++ b/src/soplex/spxbasis.hpp
@@ -21,382 +21,354 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <assert.h>
 #include <cstdio>
-#include <iostream>
 #include <iomanip>
+#include <iostream>
 #include <sstream>
 
-#include "soplex/spxdefines.h"
 #include "soplex/didxset.h"
+#include "soplex/exceptions.h"
 #include "soplex/mpsinput.h"
+#include "soplex/spxdefines.h"
 #include "soplex/spxout.h"
-#include "soplex/exceptions.h"
 
-namespace soplex
-{
+namespace soplex {
 
-template <class R> typename SPxBasisBase<R>::Desc::Status
-SPxBasisBase<R>::dualStatus(const SPxColId& id) const
-{
-   return dualColStatus(static_cast<SPxLPBase<R>*>(theLP)->number(id));
+template <class R>
+typename SPxBasisBase<R>::Desc::Status
+SPxBasisBase<R>::dualStatus(const SPxColId &id) const {
+  return dualColStatus(static_cast<SPxLPBase<R> *>(theLP)->number(id));
 }
 
 template <class R>
 typename SPxBasisBase<R>::Desc::Status
-SPxBasisBase<R>::dualStatus(const SPxRowId& id) const
-{
-   return dualRowStatus((static_cast<SPxLPBase<R>*>(theLP))->number(id));
+SPxBasisBase<R>::dualStatus(const SPxRowId &id) const {
+  return dualRowStatus((static_cast<SPxLPBase<R> *>(theLP))->number(id));
 }
 
 template <class R>
 typename SPxBasisBase<R>::Desc::Status
-SPxBasisBase<R>::dualRowStatus(int i) const
-{
-   assert(theLP != 0);
-
-   if(theLP->rhs(i) < R(infinity))
-   {
-      if(theLP->lhs(i) > R(-infinity))
-      {
-         if(theLP->lhs(i) == theLP->rhs(i))
-            return Desc::D_FREE;
-         else
-            return Desc::D_ON_BOTH;
-      }
+SPxBasisBase<R>::dualRowStatus(int i) const {
+  assert(theLP != 0);
+
+  if (theLP->rhs(i) < R(infinity)) {
+    if (theLP->lhs(i) > R(-infinity)) {
+      if (theLP->lhs(i) == theLP->rhs(i))
+        return Desc::D_FREE;
       else
-         return Desc::D_ON_LOWER;
-   }
-   else if(theLP->lhs(i) > R(-infinity))
-      return Desc::D_ON_UPPER;
-   else
-      return Desc::D_UNDEFINED;
+        return Desc::D_ON_BOTH;
+    } else
+      return Desc::D_ON_LOWER;
+  } else if (theLP->lhs(i) > R(-infinity))
+    return Desc::D_ON_UPPER;
+  else
+    return Desc::D_UNDEFINED;
 }
 
 template <class R>
 typename SPxBasisBase<R>::Desc::Status
-SPxBasisBase<R>::dualColStatus(int i) const
-{
-   assert(theLP != 0);
-
-   if(theLP->SPxLPBase<R>::upper(i) < R(infinity))
-   {
-      if(theLP->SPxLPBase<R>::lower(i) > R(-infinity))
-      {
-         if(theLP->SPxLPBase<R>::lower(i) == theLP->SPxLPBase<R>::upper(i))
-            return Desc::D_FREE;
-         else
-            return Desc::D_ON_BOTH;
-      }
+SPxBasisBase<R>::dualColStatus(int i) const {
+  assert(theLP != 0);
+
+  if (theLP->SPxLPBase<R>::upper(i) < R(infinity)) {
+    if (theLP->SPxLPBase<R>::lower(i) > R(-infinity)) {
+      if (theLP->SPxLPBase<R>::lower(i) == theLP->SPxLPBase<R>::upper(i))
+        return Desc::D_FREE;
       else
-         return Desc::D_ON_LOWER;
-   }
-   else if(theLP->SPxLPBase<R>::lower(i) > R(-infinity))
-      return Desc::D_ON_UPPER;
-   else
-      return Desc::D_UNDEFINED;
+        return Desc::D_ON_BOTH;
+    } else
+      return Desc::D_ON_LOWER;
+  } else if (theLP->SPxLPBase<R>::lower(i) > R(-infinity))
+    return Desc::D_ON_UPPER;
+  else
+    return Desc::D_UNDEFINED;
 }
 
-template <class R>
-void SPxBasisBase<R>::loadMatrixVecs()
-{
-   assert(theLP != 0);
-   assert(theLP->dim() == matrix.size());
+template <class R> void SPxBasisBase<R>::loadMatrixVecs() {
+  assert(theLP != 0);
+  assert(theLP->dim() == matrix.size());
 
-   MSG_INFO3((*this->spxout), (*this->spxout) << "IBASIS01 loadMatrixVecs() invalidates factorization"
-             << std::endl;)
+  MSG_INFO3((*this->spxout),
+            (*this->spxout)
+                << "IBASIS01 loadMatrixVecs() invalidates factorization"
+                << std::endl;)
 
-   int i;
-   nzCount = 0;
+  int i;
+  nzCount = 0;
 
-   for(i = theLP->dim() - 1; i >= 0; --i)
-   {
-      matrix[i] = &theLP->vector(baseId(i));
-      nzCount += matrix[i]->size();
-   }
+  for (i = theLP->dim() - 1; i >= 0; --i) {
+    matrix[i] = &theLP->vector(baseId(i));
+    nzCount += matrix[i]->size();
+  }
 
-   matrixIsSetup = true;
-   factorized = false;
+  matrixIsSetup = true;
+  factorized = false;
 
-   if(factor != 0)
-      factor->clear();
+  if (factor != 0)
+    factor->clear();
 }
 
-template <class R>
-bool SPxBasisBase<R>::isDescValid(const Desc& ds)
-{
-
-   assert(status() > NO_PROBLEM);
-   assert(theLP != 0);
-
-   int basisdim;
-
-   if(ds.nRows() != theLP->nRows() || ds.nCols() != theLP->nCols())
-   {
-      MSG_DEBUG(std::cout << "IBASIS20 Dimension mismatch\n");
-      return false;
-   }
-
-   basisdim = 0;
-
-   for(int row = ds.nRows() - 1; row >= 0; --row)
-   {
-      if(ds.rowstat[row] >= 0)
-      {
-         if(ds.rowstat[row] != dualRowStatus(row))
-         {
-            MSG_DEBUG(std::cout << "IBASIS21 Basic row " << row << " with incorrect dual status " <<
-                      dualRowStatus(row) << "\n");
-            return false;
-         }
+template <class R> bool SPxBasisBase<R>::isDescValid(const Desc &ds) {
+
+  assert(status() > NO_PROBLEM);
+  assert(theLP != 0);
+
+  int basisdim;
+
+  if (ds.nRows() != theLP->nRows() || ds.nCols() != theLP->nCols()) {
+    MSG_DEBUG(std::cout << "IBASIS20 Dimension mismatch\n");
+    return false;
+  }
+
+  basisdim = 0;
+
+  for (int row = ds.nRows() - 1; row >= 0; --row) {
+    if (ds.rowstat[row] >= 0) {
+      if (ds.rowstat[row] != dualRowStatus(row)) {
+        MSG_DEBUG(std::cout << "IBASIS21 Basic row " << row
+                            << " with incorrect dual status "
+                            << dualRowStatus(row) << "\n");
+        return false;
       }
-      else
-      {
-         basisdim++;
-
-         if((ds.rowstat[row] == Desc::P_FIXED
-               && theLP->SPxLPBase<R>::lhs(row) != theLP->SPxLPBase<R>::rhs(row))
-               || (ds.rowstat[row] == Desc::P_ON_UPPER && theLP->SPxLPBase<R>::rhs(row) >= R(infinity))
-               || (ds.rowstat[row] == Desc::P_ON_LOWER && theLP->SPxLPBase<R>::lhs(row) <= R(-infinity)))
-         {
-            MSG_DEBUG(std::cout << "IBASIS22 Nonbasic row with incorrect status: lhs=" <<
-                      theLP->SPxLPBase<R>::lhs(row) << ", rhs=" << theLP->SPxLPBase<R>::rhs(
-                         row) << ", stat=" << ds.rowstat[row] << "\n");
-            return false;
-         }
+    } else {
+      basisdim++;
+
+      if ((ds.rowstat[row] == Desc::P_FIXED &&
+           theLP->SPxLPBase<R>::lhs(row) != theLP->SPxLPBase<R>::rhs(row)) ||
+          (ds.rowstat[row] == Desc::P_ON_UPPER &&
+           theLP->SPxLPBase<R>::rhs(row) >= R(infinity)) ||
+          (ds.rowstat[row] == Desc::P_ON_LOWER &&
+           theLP->SPxLPBase<R>::lhs(row) <= R(-infinity))) {
+        MSG_DEBUG(std::cout
+                  << "IBASIS22 Nonbasic row with incorrect status: lhs="
+                  << theLP->SPxLPBase<R>::lhs(row)
+                  << ", rhs=" << theLP->SPxLPBase<R>::rhs(row)
+                  << ", stat=" << ds.rowstat[row] << "\n");
+        return false;
       }
-   }
-
-   for(int col = ds.nCols() - 1; col >= 0; --col)
-   {
-      if(ds.colstat[col] >= 0)
-      {
-         if(ds.colstat[col] !=  dualColStatus(col))
-         {
-            MSG_DEBUG(std::cout << "IBASIS23 Basic column " << col << " with incorrect dual status " <<
-                      ds.colstat[col] << " != " << dualColStatus(col) << "\n");
-            return false;
-         }
+    }
+  }
+
+  for (int col = ds.nCols() - 1; col >= 0; --col) {
+    if (ds.colstat[col] >= 0) {
+      if (ds.colstat[col] != dualColStatus(col)) {
+        MSG_DEBUG(std::cout << "IBASIS23 Basic column " << col
+                            << " with incorrect dual status " << ds.colstat[col]
+                            << " != " << dualColStatus(col) << "\n");
+        return false;
       }
-      else
-      {
-         basisdim++;
-
-         if((ds.colstat[col] == Desc::P_FIXED
-               && theLP->SPxLPBase<R>::lower(col) != theLP->SPxLPBase<R>::upper(col))
-               || (ds.colstat[col] == Desc::P_ON_UPPER && theLP->SPxLPBase<R>::upper(col) >= R(infinity))
-               || (ds.colstat[col] == Desc::P_ON_LOWER && theLP->SPxLPBase<R>::lower(col) <= R(-infinity)))
-         {
-            MSG_DEBUG(std::cout << "IBASIS24 Nonbasic column " << col << " with incorrect status: lower=" <<
-                      theLP->SPxLPBase<R>::lower(col) << ", upper=" << theLP->SPxLPBase<R>::upper(
-                         col) << ", stat=" << ds.colstat[col] << "\n");
-            return false;
-         }
+    } else {
+      basisdim++;
+
+      if ((ds.colstat[col] == Desc::P_FIXED &&
+           theLP->SPxLPBase<R>::lower(col) !=
+               theLP->SPxLPBase<R>::upper(col)) ||
+          (ds.colstat[col] == Desc::P_ON_UPPER &&
+           theLP->SPxLPBase<R>::upper(col) >= R(infinity)) ||
+          (ds.colstat[col] == Desc::P_ON_LOWER &&
+           theLP->SPxLPBase<R>::lower(col) <= R(-infinity))) {
+        MSG_DEBUG(std::cout << "IBASIS24 Nonbasic column " << col
+                            << " with incorrect status: lower="
+                            << theLP->SPxLPBase<R>::lower(col)
+                            << ", upper=" << theLP->SPxLPBase<R>::upper(col)
+                            << ", stat=" << ds.colstat[col] << "\n");
+        return false;
       }
-   }
+    }
+  }
 
-   if(basisdim != theLP->nCols())
-   {
-      MSG_DEBUG(std::cout << "IBASIS25 Incorrect basis dimension " << basisdim << " != " << theLP->nCols()
-                << "\n");
-      return false;
-   }
+  if (basisdim != theLP->nCols()) {
+    MSG_DEBUG(std::cout << "IBASIS25 Incorrect basis dimension " << basisdim
+                        << " != " << theLP->nCols() << "\n");
+    return false;
+  }
 
-   // basis descriptor valid
-   return true;
+  // basis descriptor valid
+  return true;
 }
 
-
 /*
   Loading a #Desc# into the basis can be done more efficiently, by
   explicitely programming both cases, for the rowwise and for the columnwise
   representation. This implementation hides this distinction in the use of
   methods #isBasic()# and #vector()#.
 */
-template <class R>
-void SPxBasisBase<R>::loadDesc(const Desc& ds)
-{
-   assert(status() > NO_PROBLEM);
-   assert(theLP != 0);
-   assert(ds.nRows() == theLP->nRows());
-   assert(ds.nCols() == theLP->nCols());
-
-   SPxId none;
-   int   i;
-   int   j;
-   bool consistent = true;
-
-   MSG_INFO3((*this->spxout), (*this->spxout) << "IBASIS02 loading of Basis invalidates factorization"
-             << std::endl;)
-
-   lastin      = none;
-   lastout     = none;
-   lastidx     = -1;
-   iterCount   = 0;
-   updateCount = 0;
-
-   if(&ds != &thedesc)
-   {
-      thedesc = ds;
-      setRep();
-   }
-
-   assert(theLP->dim() == matrix.size());
-
-   nzCount = 0;
-
-   for(j = i = 0; i < theLP->nRows(); ++i)
-   {
-      /* for columns and rows with D_... status, the correct D_... status depends on bounds and sides; if a basis
-       * descriptor is loaded after changing bounds or sides, e.g. in the refine() method, we have to correct them
-       */
-      if(thedesc.rowStatus(i) >= 0)
-         thedesc.rowStatus(i) = dualRowStatus(i);
-      else if(thedesc.rowStatus(i) == SPxBasisBase<R>::Desc::P_FIXED
-              && theLP->SPxLPBase<R>::lhs(i) != theLP->SPxLPBase<R>::rhs(i))
-      {
-         if(theLP->SPxLPBase<R>::lhs(i) > R(-infinity) && theLP->SPxLPBase<R>::maxRowObj(i) < 0.0)
-            thedesc.rowStatus(i) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-         else if(theLP->SPxLPBase<R>::rhs(i) < R(infinity))
-            thedesc.rowStatus(i) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         else
-            thedesc.rowStatus(i) = SPxBasisBase<R>::Desc::P_FREE;
-      }
+template <class R> void SPxBasisBase<R>::loadDesc(const Desc &ds) {
+  assert(status() > NO_PROBLEM);
+  assert(theLP != 0);
+  assert(ds.nRows() == theLP->nRows());
+  assert(ds.nCols() == theLP->nCols());
+
+  SPxId none;
+  int i;
+  int j;
+  bool consistent = true;
+
+  MSG_INFO3((*this->spxout),
+            (*this->spxout)
+                << "IBASIS02 loading of Basis invalidates factorization"
+                << std::endl;)
 
-      if(theLP->isBasic(thedesc.rowStatus(i)))
-      {
-         assert(theLP->dim() == matrix.size());
-         assert(j <= matrix.size());
-
-         if(j == matrix.size())
-         {
-            // too many basic variables
-            consistent = false;
-            break;
-         }
-
-         SPxRowId id = theLP->SPxLPBase<R>::rId(i);
-         theBaseId[j] = id;
-         matrix[j] = &theLP->vector(id);
-         nzCount += matrix[j++]->size();
-      }
-   }
-
-   for(i = 0; i < theLP->nCols(); ++i)
-   {
-      /* for columns and rows with D_... status, the correct D_... status depends on bounds and sides; if a basis
-       * descriptor is loaded after changing bounds or sides, e.g. in the refine() method, we have to correct them
-       */
-      if(thedesc.colStatus(i) >= 0)
-         thedesc.colStatus(i) = dualColStatus(i);
-      else if(thedesc.colStatus(i) == SPxBasisBase<R>::Desc::P_FIXED
-              && theLP->SPxLPBase<R>::lower(i) != theLP->SPxLPBase<R>::upper(i))
-      {
-         if(theLP->SPxLPBase<R>::lower(i) <= R(-infinity) && theLP->SPxLPBase<R>::upper(i) >= R(infinity))
-            thedesc.colStatus(i) = SPxBasisBase<R>::Desc::P_FREE;
-         else if(theLP->SPxLPBase<R>::upper(i) >= R(infinity)
-                 || (theLP->SPxLPBase<R>::lower(i) > R(-infinity) && theLP->SPxLPBase<R>::maxObj(i) < 0.0))
-            thedesc.colStatus(i) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-         else
-            thedesc.colStatus(i) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+  lastin = none;
+  lastout = none;
+  lastidx = -1;
+  iterCount = 0;
+  updateCount = 0;
+
+  if (&ds != &thedesc) {
+    thedesc = ds;
+    setRep();
+  }
+
+  assert(theLP->dim() == matrix.size());
+
+  nzCount = 0;
+
+  for (j = i = 0; i < theLP->nRows(); ++i) {
+    /* for columns and rows with D_... status, the correct D_... status depends
+     * on bounds and sides; if a basis descriptor is loaded after changing
+     * bounds or sides, e.g. in the refine() method, we have to correct them
+     */
+    if (thedesc.rowStatus(i) >= 0)
+      thedesc.rowStatus(i) = dualRowStatus(i);
+    else if (thedesc.rowStatus(i) == SPxBasisBase<R>::Desc::P_FIXED &&
+             theLP->SPxLPBase<R>::lhs(i) != theLP->SPxLPBase<R>::rhs(i)) {
+      if (theLP->SPxLPBase<R>::lhs(i) > R(-infinity) &&
+          theLP->SPxLPBase<R>::maxRowObj(i) < 0.0)
+        thedesc.rowStatus(i) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+      else if (theLP->SPxLPBase<R>::rhs(i) < R(infinity))
+        thedesc.rowStatus(i) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      else
+        thedesc.rowStatus(i) = SPxBasisBase<R>::Desc::P_FREE;
+    }
+
+    if (theLP->isBasic(thedesc.rowStatus(i))) {
+      assert(theLP->dim() == matrix.size());
+      assert(j <= matrix.size());
+
+      if (j == matrix.size()) {
+        // too many basic variables
+        consistent = false;
+        break;
       }
 
-      if(theLP->isBasic(thedesc.colStatus(i)))
-      {
-         assert(theLP->dim() == matrix.size());
-         assert(j <= matrix.size());
-
-         if(j == matrix.size())
-         {
-            // too many basic variables
-            consistent = false;
-            break;
-         }
-
-         SPxColId id = theLP->SPxLPBase<R>::cId(i);
-         theBaseId[j] = id;
-         matrix[j] = &theLP->vector(id);
-         nzCount += matrix[j++]->size();
+      SPxRowId id = theLP->SPxLPBase<R>::rId(i);
+      theBaseId[j] = id;
+      matrix[j] = &theLP->vector(id);
+      nzCount += matrix[j++]->size();
+    }
+  }
+
+  for (i = 0; i < theLP->nCols(); ++i) {
+    /* for columns and rows with D_... status, the correct D_... status depends
+     * on bounds and sides; if a basis descriptor is loaded after changing
+     * bounds or sides, e.g. in the refine() method, we have to correct them
+     */
+    if (thedesc.colStatus(i) >= 0)
+      thedesc.colStatus(i) = dualColStatus(i);
+    else if (thedesc.colStatus(i) == SPxBasisBase<R>::Desc::P_FIXED &&
+             theLP->SPxLPBase<R>::lower(i) != theLP->SPxLPBase<R>::upper(i)) {
+      if (theLP->SPxLPBase<R>::lower(i) <= R(-infinity) &&
+          theLP->SPxLPBase<R>::upper(i) >= R(infinity))
+        thedesc.colStatus(i) = SPxBasisBase<R>::Desc::P_FREE;
+      else if (theLP->SPxLPBase<R>::upper(i) >= R(infinity) ||
+               (theLP->SPxLPBase<R>::lower(i) > R(-infinity) &&
+                theLP->SPxLPBase<R>::maxObj(i) < 0.0))
+        thedesc.colStatus(i) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+      else
+        thedesc.colStatus(i) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+    }
+
+    if (theLP->isBasic(thedesc.colStatus(i))) {
+      assert(theLP->dim() == matrix.size());
+      assert(j <= matrix.size());
+
+      if (j == matrix.size()) {
+        // too many basic variables
+        consistent = false;
+        break;
       }
-   }
 
-   if(j < matrix.size())
-      consistent = false;  // not enough basic variables
+      SPxColId id = theLP->SPxLPBase<R>::cId(i);
+      theBaseId[j] = id;
+      matrix[j] = &theLP->vector(id);
+      nzCount += matrix[j++]->size();
+    }
+  }
 
-   /* if dimensions are inconsistent, restore slack basis
-    * if dimensions are consistent, then we have setup a correct matrix
-    */
-   if(!consistent)
-      restoreInitialBasis();
-   else
-      matrixIsSetup = true;
+  if (j < matrix.size())
+    consistent = false; // not enough basic variables
 
-   assert(isDescValid(thedesc));
+  /* if dimensions are inconsistent, restore slack basis
+   * if dimensions are consistent, then we have setup a correct matrix
+   */
+  if (!consistent)
+    restoreInitialBasis();
+  else
+    matrixIsSetup = true;
 
-   factorized = false;
+  assert(isDescValid(thedesc));
 
-   if(factor != 0)
-      factor->clear();
+  factorized = false;
+
+  if (factor != 0)
+    factor->clear();
 }
 
-template <class R>
-void SPxBasisBase<R>::setRep()
-{
-   assert(theLP != 0);
-
-   reDim();
-   minStab = 0.0;
-
-   if(theLP->rep() == SPxSolverBase<R>::ROW)
-   {
-      thedesc.stat   = &thedesc.rowstat;
-      thedesc.costat = &thedesc.colstat;
-   }
-   else
-   {
-      thedesc.stat   = &thedesc.colstat;
-      thedesc.costat = &thedesc.rowstat;
-   }
+template <class R> void SPxBasisBase<R>::setRep() {
+  assert(theLP != 0);
+
+  reDim();
+  minStab = 0.0;
+
+  if (theLP->rep() == SPxSolverBase<R>::ROW) {
+    thedesc.stat = &thedesc.rowstat;
+    thedesc.costat = &thedesc.colstat;
+  } else {
+    thedesc.stat = &thedesc.colstat;
+    thedesc.costat = &thedesc.rowstat;
+  }
 }
 
 template <class R>
-void SPxBasisBase<R>::load(SPxSolverBase<R>* lp, bool initSlackBasis)
-{
-   assert(lp != 0);
-   theLP = lp;
+void SPxBasisBase<R>::load(SPxSolverBase<R> *lp, bool initSlackBasis) {
+  assert(lp != 0);
+  theLP = lp;
 
-   setOutstream(*theLP->spxout);
+  setOutstream(*theLP->spxout);
 
-   setRep();
+  setRep();
 
-   if(initSlackBasis)
-   {
-      restoreInitialBasis();
-      loadDesc(thedesc);
-   }
+  if (initSlackBasis) {
+    restoreInitialBasis();
+    loadDesc(thedesc);
+  }
 }
 
 template <class R>
-void SPxBasisBase<R>::loadBasisSolver(SLinSolver<R>* p_solver, const bool destroy)
-{
-   assert(!freeSlinSolver || factor != 0);
+void SPxBasisBase<R>::loadBasisSolver(SLinSolver<R> *p_solver,
+                                      const bool destroy) {
+  assert(!freeSlinSolver || factor != 0);
 
-   setOutstream(*p_solver->spxout);
+  setOutstream(*p_solver->spxout);
 
-   MSG_INFO3((*this->spxout), (*this->spxout) << "IBASIS03 loading of Solver invalidates factorization"
-             << std::endl;)
+  MSG_INFO3((*this->spxout),
+            (*this->spxout)
+                << "IBASIS03 loading of Solver invalidates factorization"
+                << std::endl;)
 
-   if(freeSlinSolver)
-   {
-      delete factor;
-      factor = 0;
-   }
+  if (freeSlinSolver) {
+    delete factor;
+    factor = 0;
+  }
 
-   factor = p_solver;
-   factorized = false;
-   factor->clear();
-   freeSlinSolver = destroy;
+  factor = p_solver;
+  factorized = false;
+  factor->clear();
+  freeSlinSolver = destroy;
 }
 
 /**
@@ -410,248 +382,217 @@ void SPxBasisBase<R>::loadBasisSolver(SLinSolver<R>* p_solver, const bool destro
  *
  *  Here is a very brief outline of the format:
  *
- *  The format is in a form similar to an MPS file. The basic assumption is that all (column)
- *  variables are nonbasic at their lower bound and all row (variables) are basic; only the
- *  differences to this rule are given. Each data line contains an indicator, a variable name and
- *  possibly a row/constraint name. The following meaning applies with respect to the indicators:
+ *  The format is in a form similar to an MPS file. The basic assumption is that
+ * all (column) variables are nonbasic at their lower bound and all row
+ * (variables) are basic; only the differences to this rule are given. Each data
+ * line contains an indicator, a variable name and possibly a row/constraint
+ * name. The following meaning applies with respect to the indicators:
  *
  *  - XU: the variable is basic, the row is nonbasic at its upper bound
  *  - XL: the variable is basic, the row is nonbasic at its lower bound
  *  - UL: the variable is nonbasic and at its upper bound
  *  - LL: the variable is nonbasic and at its lower bound
  *
- *  The CPLEX format contains an additional indicator 'BS', but this is unsupported here.
+ *  The CPLEX format contains an additional indicator 'BS', but this is
+ * unsupported here.
  *
- *  Nonbasic variables without lower bound have the following default status for SoPlex:
+ *  Nonbasic variables without lower bound have the following default status for
+ * SoPlex:
  *  - at their upper bound if finite,
  *  - at zero if free.
  */
 template <class R>
-bool SPxBasisBase<R>::readBasis(
-   std::istream&  is,
-   const NameSet* rowNames,
-   const NameSet* colNames)
-{
-   assert(theLP != 0);
-
-   /* prepare names */
-   const NameSet* rNames = rowNames;
-   const NameSet* cNames = colNames;
-
-   NameSet* p_colNames = 0;
-   NameSet* p_rowNames = 0;
-
-   if(colNames == 0)
-   {
-      int nCols = theLP->nCols();
-      std::stringstream name;
-
-      spx_alloc(p_colNames);
-      p_colNames = new(p_colNames) NameSet();
-      p_colNames->reMax(nCols);
-
-      for(int j = 0; j < nCols; ++j)
-      {
-         name << "x" << j;
-         DataKey key = theLP->colId(j);
-         p_colNames->add(key, name.str().c_str());
+bool SPxBasisBase<R>::readBasis(std::istream &is, const NameSet *rowNames,
+                                const NameSet *colNames) {
+  assert(theLP != 0);
+
+  /* prepare names */
+  const NameSet *rNames = rowNames;
+  const NameSet *cNames = colNames;
+
+  NameSet *p_colNames = 0;
+  NameSet *p_rowNames = 0;
+
+  if (colNames == 0) {
+    int nCols = theLP->nCols();
+    std::stringstream name;
+
+    spx_alloc(p_colNames);
+    p_colNames = new (p_colNames) NameSet();
+    p_colNames->reMax(nCols);
+
+    for (int j = 0; j < nCols; ++j) {
+      name << "x" << j;
+      DataKey key = theLP->colId(j);
+      p_colNames->add(key, name.str().c_str());
+    }
+
+    cNames = p_colNames;
+  }
+
+  if (rNames == 0) {
+    int nRows = theLP->nRows();
+    std::stringstream name;
+
+    spx_alloc(p_rowNames);
+    p_rowNames = new (p_rowNames) NameSet();
+    p_rowNames->reMax(nRows);
+
+    for (int i = 0; i < nRows; ++i) {
+      name << "C" << i;
+      DataKey key = theLP->rowId(i);
+      p_rowNames->add(key, name.str().c_str());
+    }
+
+    rNames = p_rowNames;
+  }
+
+  /* load default basis if necessary */
+  if (status() == NO_PROBLEM)
+    load(theLP, false);
+
+  /* initialize with standard settings */
+  Desc l_desc(thedesc);
+
+  for (int i = 0; i < theLP->nRows(); i++)
+    l_desc.rowstat[i] = dualRowStatus(i);
+
+  for (int i = 0; i < theLP->nCols(); i++) {
+    if (theLP->SPxLPBase<R>::lower(i) == theLP->SPxLPBase<R>::upper(i))
+      l_desc.colstat[i] = Desc::P_FIXED;
+    else if (theLP->SPxLPBase<R>::lower(i) <= R(-infinity) &&
+             theLP->SPxLPBase<R>::upper(i) >= R(infinity))
+      l_desc.colstat[i] = Desc::P_FREE;
+    else if (theLP->SPxLPBase<R>::lower(i) <= R(-infinity))
+      l_desc.colstat[i] = Desc::P_ON_UPPER;
+    else
+      l_desc.colstat[i] = Desc::P_ON_LOWER;
+  }
+
+  MPSInput mps(is);
+
+  if (mps.readLine() && (mps.field0() != 0) && !strcmp(mps.field0(), "NAME")) {
+    while (mps.readLine()) {
+      int c = -1;
+      int r = -1;
+
+      if ((mps.field0() != 0) && !strcmp(mps.field0(), "ENDATA")) {
+        mps.setSection(MPSInput::ENDATA);
+        break;
       }
 
-      cNames = p_colNames;
-   }
-
-   if(rNames == 0)
-   {
-      int nRows = theLP->nRows();
-      std::stringstream name;
-
-      spx_alloc(p_rowNames);
-      p_rowNames = new(p_rowNames) NameSet();
-      p_rowNames->reMax(nRows);
-
-      for(int i = 0; i < nRows; ++i)
-      {
-         name << "C" << i;
-         DataKey key = theLP->rowId(i);
-         p_rowNames->add(key, name.str().c_str());
-      }
-
-      rNames = p_rowNames;
-   }
-
-   /* load default basis if necessary */
-   if(status() == NO_PROBLEM)
-      load(theLP, false);
-
-   /* initialize with standard settings */
-   Desc l_desc(thedesc);
-
-   for(int i = 0; i < theLP->nRows(); i++)
-      l_desc.rowstat[i] = dualRowStatus(i);
-
-   for(int i = 0; i < theLP->nCols(); i++)
-   {
-      if(theLP->SPxLPBase<R>::lower(i) == theLP->SPxLPBase<R>::upper(i))
-         l_desc.colstat[i] = Desc::P_FIXED;
-      else if(theLP->SPxLPBase<R>::lower(i) <= R(-infinity)
-              && theLP->SPxLPBase<R>::upper(i) >= R(infinity))
-         l_desc.colstat[i] = Desc::P_FREE;
-      else if(theLP->SPxLPBase<R>::lower(i) <= R(-infinity))
-         l_desc.colstat[i] = Desc::P_ON_UPPER;
-      else
-         l_desc.colstat[i] = Desc::P_ON_LOWER;
-   }
-
-   MPSInput mps(is);
-
-   if(mps.readLine() && (mps.field0() != 0) && !strcmp(mps.field0(), "NAME"))
-   {
-      while(mps.readLine())
-      {
-         int c = -1;
-         int r = -1;
-
-         if((mps.field0() != 0) && !strcmp(mps.field0(), "ENDATA"))
-         {
-            mps.setSection(MPSInput::ENDATA);
-            break;
-         }
-
-         if((mps.field1() == 0) || (mps.field2() == 0))
-            break;
-
-         if((c = cNames->number(mps.field2())) < 0)
-            break;
-
-         if(*mps.field1() == 'X')
-            if(mps.field3() == 0 || (r = rNames->number(mps.field3())) < 0)
-               break;
-
-         if(!strcmp(mps.field1(), "XU"))
-         {
-            l_desc.colstat[c] = dualColStatus(c);
-
-            if(theLP->LPRowSetBase<R>::type(r) == LPRowBase<R>::GREATER_EQUAL)
-               l_desc.rowstat[r] = Desc::P_ON_LOWER;
-            else if(theLP->LPRowSetBase<R>::type(r) == LPRowBase<R>::EQUAL)
-               l_desc.rowstat[r] = Desc::P_FIXED;
-            else
-               l_desc.rowstat[r] = Desc::P_ON_UPPER;
-         }
-         else if(!strcmp(mps.field1(), "XL"))
-         {
-            l_desc.colstat[c] = dualColStatus(c);
-
-            if(theLP->LPRowSetBase<R>::type(r) == LPRowBase<R>::LESS_EQUAL)
-               l_desc.rowstat[r] = Desc::P_ON_UPPER;
-            else if(theLP->LPRowSetBase<R>::type(r) == LPRowBase<R>::EQUAL)
-               l_desc.rowstat[r] = Desc::P_FIXED;
-            else
-               l_desc.rowstat[r] = Desc::P_ON_LOWER;
-         }
-         else if(!strcmp(mps.field1(), "UL"))
-         {
-            l_desc.colstat[c] = Desc::P_ON_UPPER;
-         }
-         else if(!strcmp(mps.field1(), "LL"))
-         {
-            l_desc.colstat[c] = Desc::P_ON_LOWER;
-         }
-         else
-         {
-            mps.syntaxError();
-            break;
-         }
-      }
-   }
-
-   if(!mps.hasError())
-   {
-      if(mps.section() == MPSInput::ENDATA)
-      {
-         // force basis to be different from NO_PROBLEM
-         // otherwise the basis will be overwritten at later stages.
-         setStatus(REGULAR);
-         loadDesc(l_desc);
+      if ((mps.field1() == 0) || (mps.field2() == 0))
+        break;
+
+      if ((c = cNames->number(mps.field2())) < 0)
+        break;
+
+      if (*mps.field1() == 'X')
+        if (mps.field3() == 0 || (r = rNames->number(mps.field3())) < 0)
+          break;
+
+      if (!strcmp(mps.field1(), "XU")) {
+        l_desc.colstat[c] = dualColStatus(c);
+
+        if (theLP->LPRowSetBase<R>::type(r) == LPRowBase<R>::GREATER_EQUAL)
+          l_desc.rowstat[r] = Desc::P_ON_LOWER;
+        else if (theLP->LPRowSetBase<R>::type(r) == LPRowBase<R>::EQUAL)
+          l_desc.rowstat[r] = Desc::P_FIXED;
+        else
+          l_desc.rowstat[r] = Desc::P_ON_UPPER;
+      } else if (!strcmp(mps.field1(), "XL")) {
+        l_desc.colstat[c] = dualColStatus(c);
+
+        if (theLP->LPRowSetBase<R>::type(r) == LPRowBase<R>::LESS_EQUAL)
+          l_desc.rowstat[r] = Desc::P_ON_UPPER;
+        else if (theLP->LPRowSetBase<R>::type(r) == LPRowBase<R>::EQUAL)
+          l_desc.rowstat[r] = Desc::P_FIXED;
+        else
+          l_desc.rowstat[r] = Desc::P_ON_LOWER;
+      } else if (!strcmp(mps.field1(), "UL")) {
+        l_desc.colstat[c] = Desc::P_ON_UPPER;
+      } else if (!strcmp(mps.field1(), "LL")) {
+        l_desc.colstat[c] = Desc::P_ON_LOWER;
+      } else {
+        mps.syntaxError();
+        break;
       }
-      else
-         mps.syntaxError();
-   }
-
-   if(rowNames == 0)
-   {
-      p_rowNames->~NameSet();
-      spx_free(p_rowNames);
-   }
-
-   if(colNames == 0)
-   {
-      p_colNames->~NameSet();
-      spx_free(p_colNames);
-   }
+    }
+  }
+
+  if (!mps.hasError()) {
+    if (mps.section() == MPSInput::ENDATA) {
+      // force basis to be different from NO_PROBLEM
+      // otherwise the basis will be overwritten at later stages.
+      setStatus(REGULAR);
+      loadDesc(l_desc);
+    } else
+      mps.syntaxError();
+  }
+
+  if (rowNames == 0) {
+    p_rowNames->~NameSet();
+    spx_free(p_rowNames);
+  }
+
+  if (colNames == 0) {
+    p_colNames->~NameSet();
+    spx_free(p_colNames);
+  }
 
 #ifndef NDEBUG
-   MSG_DEBUG(thedesc.dump());
+  MSG_DEBUG(thedesc.dump());
 #endif
 
-   return !mps.hasError();
+  return !mps.hasError();
 }
 
-
 /* Get row name - copied from spxmpswrite.cpp
  *
- * @todo put this in a common file and unify accross different formats (mps, lp, basis).
+ * @todo put this in a common file and unify accross different formats (mps, lp,
+ * basis).
  */
 template <class R>
-static const char* getRowName(
-   const SPxLPBase<R>*   lp,
-   int            idx,
-   const NameSet* rnames,
-   char*          buf)
-{
-   assert(buf != 0);
-   assert(idx >= 0);
-   assert(idx < lp->nRows());
-
-   if(rnames != 0)
-   {
-      DataKey key = lp->rId(idx);
-
-      if(rnames->has(key))
-         return (*rnames)[key];
-   }
-
-   spxSnprintf(buf, 16, "C%d", idx);
-
-   return buf;
+static const char *getRowName(const SPxLPBase<R> *lp, int idx,
+                              const NameSet *rnames, char *buf) {
+  assert(buf != 0);
+  assert(idx >= 0);
+  assert(idx < lp->nRows());
+
+  if (rnames != 0) {
+    DataKey key = lp->rId(idx);
+
+    if (rnames->has(key))
+      return (*rnames)[key];
+  }
+
+  spxSnprintf(buf, 16, "C%d", idx);
+
+  return buf;
 }
 
 /* Get column name - copied from spxmpswrite.cpp
  *
- * @todo put this in a common file and unify accross different formats (mps, lp, basis).
+ * @todo put this in a common file and unify accross different formats (mps, lp,
+ * basis).
  */
 template <class R>
-static const char* getColName(
-   const SPxLPBase<R>*   lp,
-   int            idx,
-   const NameSet* cnames,
-   char*          buf)
-{
-   assert(buf != 0);
-   assert(idx >= 0);
-   assert(idx < lp->nCols());
-
-   if(cnames != 0)
-   {
-      DataKey key = lp->cId(idx);
-
-      if(cnames->has(key))
-         return (*cnames)[key];
-   }
-
-   spxSnprintf(buf, 16, "x%d", idx);
-
-   return buf;
+static const char *getColName(const SPxLPBase<R> *lp, int idx,
+                              const NameSet *cnames, char *buf) {
+  assert(buf != 0);
+  assert(idx >= 0);
+  assert(idx < lp->nCols());
+
+  if (cnames != 0) {
+    DataKey key = lp->cId(idx);
+
+    if (cnames->has(key))
+      return (*cnames)[key];
+  }
+
+  spxSnprintf(buf, 16, "x%d", idx);
+
+  return buf;
 }
 
 /* writes a file in MPS basis format to \p os.
@@ -659,450 +600,406 @@ static const char* getColName(
  * See SPxBasisBase<R>::readBasis() for a short description of the format.
  */
 template <class R>
-void SPxBasisBase<R>::writeBasis(
-   std::ostream&  os,
-   const NameSet* rowNames,
-   const NameSet* colNames,
-   const bool cpxFormat
-) const
-{
-   assert(theLP != 0);
-
-   os.setf(std::ios::left);
-   os << "NAME  soplex.bas\n";
-
-   /* do not write basis if there is none */
-   if(status() == NO_PROBLEM)
-   {
-      os << "ENDATA" << std::endl;
-      return;
-   }
-
-   /* start writing */
-   char buf[255];
-   int row = 0;
-
-   for(int col = 0; col < theLP->nCols(); col++)
-   {
-      if(thedesc.colStatus(col) > 0)
-      {
-         /* Find non basic row */
-         for(; row < theLP->nRows(); row++)
-         {
-            if(thedesc.rowStatus(row) < 0)
-               break;
-         }
-
-         assert(row != theLP->nRows());
-
-         if(thedesc.rowStatus(row) == Desc::P_ON_UPPER && (!cpxFormat
-               || theLP->LPRowSetBase<R>::type(row) == LPRowBase<R>::RANGE))
-            os << " XU ";
-         else
-            os << " XL ";
-
-         os << std::setw(8) << getColName(theLP, col, colNames, buf);
-
-         /* break in two parts since buf is reused */
-         os << "       "
-            << getRowName(theLP, row, rowNames, buf)
-            << std::endl;
-
-         row++;
+void SPxBasisBase<R>::writeBasis(std::ostream &os, const NameSet *rowNames,
+                                 const NameSet *colNames,
+                                 const bool cpxFormat) const {
+  assert(theLP != 0);
+
+  os.setf(std::ios::left);
+  os << "NAME  soplex.bas\n";
+
+  /* do not write basis if there is none */
+  if (status() == NO_PROBLEM) {
+    os << "ENDATA" << std::endl;
+    return;
+  }
+
+  /* start writing */
+  char buf[255];
+  int row = 0;
+
+  for (int col = 0; col < theLP->nCols(); col++) {
+    if (thedesc.colStatus(col) > 0) {
+      /* Find non basic row */
+      for (; row < theLP->nRows(); row++) {
+        if (thedesc.rowStatus(row) < 0)
+          break;
       }
+
+      assert(row != theLP->nRows());
+
+      if (thedesc.rowStatus(row) == Desc::P_ON_UPPER &&
+          (!cpxFormat ||
+           theLP->LPRowSetBase<R>::type(row) == LPRowBase<R>::RANGE))
+        os << " XU ";
       else
-      {
-         if(thedesc.colStatus(col) == Desc::P_ON_UPPER)
-         {
-            os << " UL "
-               << getColName(theLP, col, colNames, buf)
-               << std::endl;
-         }
-         else
-         {
-            /* Default is all non-basic variables on lower bound (if finite) or at zero (if free).
-             * nothing to do in this case.
-             */
-            assert(theLP->lower(col) <= R(-infinity) || thedesc.colStatus(col) == Desc::P_ON_LOWER
-                   || thedesc.colStatus(col) == Desc::P_FIXED);
-            assert(theLP->lower(col) > R(-infinity) || theLP->upper(col) < R(infinity)
-                   || thedesc.colStatus(col) == Desc::P_FREE);
-         }
+        os << " XL ";
+
+      os << std::setw(8) << getColName(theLP, col, colNames, buf);
+
+      /* break in two parts since buf is reused */
+      os << "       " << getRowName(theLP, row, rowNames, buf) << std::endl;
+
+      row++;
+    } else {
+      if (thedesc.colStatus(col) == Desc::P_ON_UPPER) {
+        os << " UL " << getColName(theLP, col, colNames, buf) << std::endl;
+      } else {
+        /* Default is all non-basic variables on lower bound (if finite) or at
+         * zero (if free). nothing to do in this case.
+         */
+        assert(theLP->lower(col) <= R(-infinity) ||
+               thedesc.colStatus(col) == Desc::P_ON_LOWER ||
+               thedesc.colStatus(col) == Desc::P_FIXED);
+        assert(theLP->lower(col) > R(-infinity) ||
+               theLP->upper(col) < R(infinity) ||
+               thedesc.colStatus(col) == Desc::P_FREE);
       }
-   }
+    }
+  }
 
 #ifndef NDEBUG
-   MSG_DEBUG(thedesc.dump());
+  MSG_DEBUG(thedesc.dump());
 
-   // Check that we covered all nonbasic rows - the remaining should be basic.
-   for(; row < theLP->nRows(); row++)
-   {
-      if(thedesc.rowStatus(row) < 0)
-         break;
-   }
+  // Check that we covered all nonbasic rows - the remaining should be basic.
+  for (; row < theLP->nRows(); row++) {
+    if (thedesc.rowStatus(row) < 0)
+      break;
+  }
 
-   assert(row == theLP->nRows());
+  assert(row == theLP->nRows());
 
 #endif // NDEBUG
 
-   os << "ENDATA" << std::endl;
+  os << "ENDATA" << std::endl;
 }
 
-template <class R>
-void SPxBasisBase<R>::printMatrix() const
-{
+template <class R> void SPxBasisBase<R>::printMatrix() const {
 
-   assert(matrixIsSetup);
+  assert(matrixIsSetup);
 
-   for(int i = 0; i < matrix.size(); i++)
-   {
-      std::cout << "C" << i << "=" << *matrix[i] << std::endl;
-   }
+  for (int i = 0; i < matrix.size(); i++) {
+    std::cout << "C" << i << "=" << *matrix[i] << std::endl;
+  }
 }
 
-template <class R>
-void SPxBasisBase<R>::printMatrixMTX(int number)
-{
-   int dim;
-   int nnz;
-   char filename[SPX_MAXSTRLEN];
-
-   dim = matrix.size();
-   nnz = nzCount;
-   spxSnprintf(filename, SPX_MAXSTRLEN, "basis/basis%d.mtx", number);
-   std::cout << "printing basis matrix to file " << filename << "\n";
-   FILE* basisfile;
-   basisfile = fopen(filename, "w");
-   // print marker necessary for reading the file in Matlab
-   fprintf(basisfile, "%%%%MatrixMarket matrix coordinate Real general\n");
-   // print matrix information
-   fprintf(basisfile, "%d %d %d\n", dim, dim, nnz);
-
-   // print matrix data
-   for(int i = 0; i < matrix.size(); ++i)
-   {
-      for(int j = 0; j < baseVec(i).size(); ++j)
-      {
-         int idx = baseVec(i).index(j);
-         R val = baseVec(i).value(j);
-         fprintf(basisfile, "%d %d %.13" REAL_FORMAT "\n", i + 1, idx + 1, val);
-      }
-   }
-
-   fclose(basisfile);
-
-   return;
+template <class R> void SPxBasisBase<R>::printMatrixMTX(int number) {
+  int dim;
+  int nnz;
+  char filename[SPX_MAXSTRLEN];
+
+  dim = matrix.size();
+  nnz = nzCount;
+  spxSnprintf(filename, SPX_MAXSTRLEN, "basis/basis%d.mtx", number);
+  std::cout << "printing basis matrix to file " << filename << "\n";
+  FILE *basisfile;
+  basisfile = fopen(filename, "w");
+  // print marker necessary for reading the file in Matlab
+  fprintf(basisfile, "%%%%MatrixMarket matrix coordinate Real general\n");
+  // print matrix information
+  fprintf(basisfile, "%d %d %d\n", dim, dim, nnz);
+
+  // print matrix data
+  for (int i = 0; i < matrix.size(); ++i) {
+    for (int j = 0; j < baseVec(i).size(); ++j) {
+      int idx = baseVec(i).index(j);
+      R val = baseVec(i).value(j);
+      fprintf(basisfile, "%d %d %.13" REAL_FORMAT "\n", i + 1, idx + 1, val);
+    }
+  }
+
+  fclose(basisfile);
+
+  return;
 }
 
 template <class R>
-void SPxBasisBase<R>::change(
-   int i,
-   SPxId& id,
-   const SVectorBase<R>* enterVec,
-   const SSVectorBase<R>* eta)
-{
-
-   assert(matrixIsSetup);
-   assert(!id.isValid() || (enterVec != 0));
-   assert(factor != 0);
-
-   lastidx = i;
-   lastin  = id;
-
-   if(id.isValid() && i >= 0)
-   {
-      assert(enterVec != 0);
-
-      // update the counter for nonzeros in the basis matrix
-      nzCount      = nzCount - matrix[i]->size() + enterVec->size();
-      // let the new id enter the basis
-      matrix[i]    = enterVec;
-      lastout      = theBaseId[i];
-      theBaseId[i] = id;
-
-      ++iterCount;
-      ++updateCount;
-
-      MSG_DEBUG(std::cout << "factor_stats: iteration= " << this->iteration()
-                << " update= " << updateCount
-                << " total_update= " << totalUpdateCount
-                << " nonzero_B= " << nzCount
-                << " nonzero_LU= " << factor->memory()
-                << " factor_fill= " << lastFill
-                << " time= " << theLP->time()
-                << std::endl;)
+void SPxBasisBase<R>::change(int i, SPxId &id, const SVectorBase<R> *enterVec,
+                             const SSVectorBase<R> *eta) {
+
+  assert(matrixIsSetup);
+  assert(!id.isValid() || (enterVec != 0));
+  assert(factor != 0);
+
+  lastidx = i;
+  lastin = id;
+
+  if (id.isValid() && i >= 0) {
+    assert(enterVec != 0);
+
+    // update the counter for nonzeros in the basis matrix
+    nzCount = nzCount - matrix[i]->size() + enterVec->size();
+    // let the new id enter the basis
+    matrix[i] = enterVec;
+    lastout = theBaseId[i];
+    theBaseId[i] = id;
+
+    ++iterCount;
+    ++updateCount;
+
+    MSG_DEBUG(std::cout << "factor_stats: iteration= " << this->iteration()
+                        << " update= " << updateCount << " total_update= "
+                        << totalUpdateCount << " nonzero_B= " << nzCount
+                        << " nonzero_LU= " << factor->memory()
+                        << " factor_fill= " << lastFill
+                        << " time= " << theLP->time() << std::endl;)
+
+    // never factorize? Just do it !
+    if (!factorized)
+      factorize();
 
-      // never factorize? Just do it !
-      if(!factorized)
-         factorize();
-
-      // too much memory growth ?
-      else if(R(factor->memory()) > 1000 + factor->dim() + lastMem * memFactor)
-      {
-         MSG_INFO3((*this->spxout), (*this->spxout) <<
-                   "IBASIS04 memory growth factor triggers refactorization"
-                   << " memory= " << factor->memory()
-                   << " lastMem= " << lastMem
-                   << " memFactor= " << memFactor
-                   << std::endl;)
-         factorize();
-      }
+    // too much memory growth ?
+    else if (R(factor->memory()) > 1000 + factor->dim() + lastMem * memFactor) {
+      MSG_INFO3((*this->spxout),
+                (*this->spxout)
+                    << "IBASIS04 memory growth factor triggers refactorization"
+                    << " memory= " << factor->memory() << " lastMem= "
+                    << lastMem << " memFactor= " << memFactor << std::endl;)
+      factorize();
+    }
 
-      // relative fill too high ?
-      else if(R(factor->memory()) > lastFill * R(nzCount))
-      {
-         MSG_INFO3((*this->spxout), (*this->spxout) << "IBASIS04 fill factor triggers refactorization"
-                   << " memory= " << factor->memory()
-                   << " nzCount= " << nzCount
-                   << " lastFill= " << lastFill
-                   << std::endl;)
+    // relative fill too high ?
+    else if (R(factor->memory()) > lastFill * R(nzCount)) {
+      MSG_INFO3((*this->spxout),
+                (*this->spxout)
+                    << "IBASIS04 fill factor triggers refactorization"
+                    << " memory= " << factor->memory() << " nzCount= "
+                    << nzCount << " lastFill= " << lastFill << std::endl;)
 
-         factorize();
-      }
-      // absolute fill in basis matrix too high ?
-      else if(nzCount > lastNzCount)
-      {
-         MSG_INFO3((*this->spxout), (*this->spxout) << "IBASIS05 nonzero factor triggers refactorization"
-                   << " nzCount= " << nzCount
-                   << " lastNzCount= " << lastNzCount
-                   << " nonzeroFactor= " << nonzeroFactor
-                   << std::endl;)
-         factorize();
-      }
-      // too many updates ?
-      else if(updateCount >= maxUpdates)
-      {
-         MSG_INFO3((*this->spxout), (*this->spxout) << "IBASIS06 update count triggers refactorization"
-                   << " updateCount= " << updateCount
-                   << " maxUpdates= " << maxUpdates
-                   << std::endl;)
-         factorize();
-      }
-      else
-      {
-         try
-         {
+      factorize();
+    }
+    // absolute fill in basis matrix too high ?
+    else if (nzCount > lastNzCount) {
+      MSG_INFO3((*this->spxout),
+                (*this->spxout)
+                    << "IBASIS05 nonzero factor triggers refactorization"
+                    << " nzCount= " << nzCount
+                    << " lastNzCount= " << lastNzCount
+                    << " nonzeroFactor= " << nonzeroFactor << std::endl;)
+      factorize();
+    }
+    // too many updates ?
+    else if (updateCount >= maxUpdates) {
+      MSG_INFO3((*this->spxout),
+                (*this->spxout)
+                    << "IBASIS06 update count triggers refactorization"
+                    << " updateCount= " << updateCount
+                    << " maxUpdates= " << maxUpdates << std::endl;)
+      factorize();
+    } else {
+      try {
 #ifdef MEASUREUPDATETIME
-            theTime.start();
+        theTime.start();
 #endif
-            factor->change(i, *enterVec, eta);
-            totalUpdateCount++;
+        factor->change(i, *enterVec, eta);
+        totalUpdateCount++;
 #ifdef MEASUREUPDATETIME
-            theTime.stop();
+        theTime.stop();
 #endif
-         }
-         catch(...)
-         {
-            MSG_INFO3((*this->spxout), (*this->spxout) <<
-                      "IBASIS13 problems updating factorization; refactorizing basis"
-                      << std::endl;)
+      } catch (...) {
+        MSG_INFO3((*this->spxout), (*this->spxout)
+                                       << "IBASIS13 problems updating "
+                                          "factorization; refactorizing basis"
+                                       << std::endl;)
 
 #ifdef MEASUREUPDATETIME
-            theTime.stop();
+        theTime.stop();
 #endif
 
-            // singularity was detected in update; we refactorize
-            factorize();
+        // singularity was detected in update; we refactorize
+        factorize();
 
-            // if factorize() detects singularity, an exception is thrown, hence at this point we have a regular basis
-            // and can try the update again
-            assert(status() >= SPxBasisBase<R>::REGULAR);
+        // if factorize() detects singularity, an exception is thrown, hence at
+        // this point we have a regular basis and can try the update again
+        assert(status() >= SPxBasisBase<R>::REGULAR);
 
-            try
-            {
+        try {
 #ifdef MEASUREUPDATETIME
-               theTime.start();
+          theTime.start();
 #endif
-               factor->change(i, *enterVec, eta);
-               totalUpdateCount++;
+          factor->change(i, *enterVec, eta);
+          totalUpdateCount++;
 #ifdef MEASUREUPDATETIME
-               theTime.stop();
+          theTime.stop();
 #endif
-            }
-            // with a freshly factorized, regular basis, the update is unlikely to fail; if this happens nevertheless,
-            // we have to invalidate the basis to have the statuses correct
-            catch(const SPxException& F)
-            {
-               MSG_INFO3((*this->spxout), (*this->spxout) <<
-                         "IBASIS14 problems updating factorization; invalidating factorization"
-                         << std::endl;)
+        }
+        // with a freshly factorized, regular basis, the update is unlikely to
+        // fail; if this happens nevertheless, we have to invalidate the basis
+        // to have the statuses correct
+        catch (const SPxException &F) {
+          MSG_INFO3((*this->spxout),
+                    (*this->spxout)
+                        << "IBASIS14 problems updating factorization; "
+                           "invalidating factorization"
+                        << std::endl;)
 
 #ifdef MEASUREUPDATETIME
-               theTime.stop();
+          theTime.stop();
 #endif
 
-               factorized = false;
-               throw F;
-            }
-         }
+          factorized = false;
+          throw F;
+        }
+      }
 
-         assert(minStab > 0.0);
+      assert(minStab > 0.0);
 
-         if(factor->status() != SLinSolver<R>::OK || factor->stability() < minStab)
-         {
-            MSG_INFO3((*this->spxout), (*this->spxout) << "IBASIS07 stability triggers refactorization"
+      if (factor->status() != SLinSolver<R>::OK ||
+          factor->stability() < minStab) {
+        MSG_INFO3((*this->spxout),
+                  (*this->spxout)
+                      << "IBASIS07 stability triggers refactorization"
                       << " stability= " << factor->stability()
-                      << " minStab= " << minStab
-                      << std::endl;)
-            factorize();
-         }
+                      << " minStab= " << minStab << std::endl;)
+        factorize();
       }
-   }
-   else
-      lastout = id;
+    }
+  } else
+    lastout = id;
 }
 
-template <class R>
-void SPxBasisBase<R>::factorize()
-{
+template <class R> void SPxBasisBase<R>::factorize() {
 
-   assert(factor != 0);
+  assert(factor != 0);
 
-   if(!matrixIsSetup)
-      loadDesc(thedesc);
+  if (!matrixIsSetup)
+    loadDesc(thedesc);
 
-   assert(matrixIsSetup);
+  assert(matrixIsSetup);
 
-   updateCount = 0;
+  updateCount = 0;
 
-   switch(factor->load(matrix.get_ptr(), matrix.size()))
-   {
-   case SLinSolver<R>::OK :
-      if(status() == SINGULAR)
-         setStatus(REGULAR);
+  switch (factor->load(matrix.get_ptr(), matrix.size())) {
+  case SLinSolver<R>::OK:
+    if (status() == SINGULAR)
+      setStatus(REGULAR);
 
-      factorized = true;
-      minStab = factor->stability();
+    factorized = true;
+    minStab = factor->stability();
 
-      // This seems always to be about 1e-7
-      if(minStab > 1e-4)
-         minStab *= 0.001;
+    // This seems always to be about 1e-7
+    if (minStab > 1e-4)
+      minStab *= 0.001;
 
-      if(minStab > 1e-5)
-         minStab *= 0.01;
+    if (minStab > 1e-5)
+      minStab *= 0.01;
 
-      if(minStab > 1e-6)
-         minStab *= 0.1;
+    if (minStab > 1e-6)
+      minStab *= 0.1;
 
-      break;
+    break;
 
-   case SLinSolver<R>::SINGULAR :
-      setStatus(SINGULAR);
-      factorized = false;
-      break;
+  case SLinSolver<R>::SINGULAR:
+    setStatus(SINGULAR);
+    factorized = false;
+    break;
+
+  default:
+    MSG_ERROR(
+        std::cerr << "EBASIS08 error: unknown status of factorization.\n";)
+    factorized = false;
+    throw SPxInternalCodeException("XBASIS01 This should never happen.");
+  }
 
-   default :
-      MSG_ERROR(std::cerr << "EBASIS08 error: unknown status of factorization.\n";)
-      factorized = false;
-      throw SPxInternalCodeException("XBASIS01 This should never happen.");
-   }
-
-   // get nonzero count of factorization
-   lastMem    = factor->memory();
-   // compute fill ratio between factorization and basis matrix (multiplied with tolerance)
-   lastFill   = fillFactor * R(lastMem) / R(nzCount > 0 ? nzCount : 1);
-   lastNzCount = int(nonzeroFactor * R(nzCount > 0 ? nzCount : 1));
-
-   if(status() == SINGULAR)
-   {
-      throw SPxStatusException("Cannot factorize singular matrix");
-   }
+  // get nonzero count of factorization
+  lastMem = factor->memory();
+  // compute fill ratio between factorization and basis matrix (multiplied with
+  // tolerance)
+  lastFill = fillFactor * R(lastMem) / R(nzCount > 0 ? nzCount : 1);
+  lastNzCount = int(nonzeroFactor * R(nzCount > 0 ? nzCount : 1));
+
+  if (status() == SINGULAR) {
+    throw SPxStatusException("Cannot factorize singular matrix");
+  }
 }
 
 template <class R>
-VectorBase<R>& SPxBasisBase<R>::multWithBase(VectorBase<R>& x) const
-{
-   assert(status() > SINGULAR);
-   assert(theLP->dim() == x.dim());
+VectorBase<R> &SPxBasisBase<R>::multWithBase(VectorBase<R> &x) const {
+  assert(status() > SINGULAR);
+  assert(theLP->dim() == x.dim());
 
-   int i;
-   VectorBase<R> tmp(x);
+  int i;
+  VectorBase<R> tmp(x);
 
-   if(!matrixIsSetup)
-      (const_cast<SPxBasisBase<R>*>(this))->loadDesc(thedesc);
+  if (!matrixIsSetup)
+    (const_cast<SPxBasisBase<R> *>(this))->loadDesc(thedesc);
 
-   assert(matrixIsSetup);
+  assert(matrixIsSetup);
 
-   for(i = x.dim() - 1; i >= 0; --i)
-      x[i] = *(matrix[i]) * tmp;
+  for (i = x.dim() - 1; i >= 0; --i)
+    x[i] = *(matrix[i]) * tmp;
 
-   return x;
+  return x;
 }
 
 template <class R>
-void SPxBasisBase<R>::multWithBase(SSVectorBase<R>& x, SSVectorBase<R>& result) const
-{
-   assert(status() > SINGULAR);
-   assert(theLP->dim() == x.dim());
-   assert(x.dim() == result.dim());
+void SPxBasisBase<R>::multWithBase(SSVectorBase<R> &x,
+                                   SSVectorBase<R> &result) const {
+  assert(status() > SINGULAR);
+  assert(theLP->dim() == x.dim());
+  assert(x.dim() == result.dim());
 
-   if(!matrixIsSetup)
-      (const_cast<SPxBasisBase<R>*>(this))->loadDesc(thedesc);
+  if (!matrixIsSetup)
+    (const_cast<SPxBasisBase<R> *>(this))->loadDesc(thedesc);
 
-   result.clear();
+  result.clear();
 
-   assert(matrixIsSetup);
+  assert(matrixIsSetup);
 
-   for(int i = 0; i < x.dim(); ++i)
-      result.add(i, (*matrix[i]) * x);
+  for (int i = 0; i < x.dim(); ++i)
+    result.add(i, (*matrix[i]) * x);
 
-   return;
+  return;
 }
 
 template <class R>
-VectorBase<R>& SPxBasisBase<R>::multBaseWith(VectorBase<R>& x) const
-{
-   assert(status() > SINGULAR);
-   assert(theLP->dim() == x.dim());
+VectorBase<R> &SPxBasisBase<R>::multBaseWith(VectorBase<R> &x) const {
+  assert(status() > SINGULAR);
+  assert(theLP->dim() == x.dim());
 
-   int i;
-   VectorBase<R> tmp(x);
+  int i;
+  VectorBase<R> tmp(x);
 
-   if(!matrixIsSetup)
-      (const_cast<SPxBasisBase<R>*>(this))->loadDesc(thedesc);
+  if (!matrixIsSetup)
+    (const_cast<SPxBasisBase<R> *>(this))->loadDesc(thedesc);
 
-   assert(matrixIsSetup);
+  assert(matrixIsSetup);
 
-   x.clear();
+  x.clear();
 
-   for(i = x.dim() - 1; i >= 0; --i)
-   {
-      if(tmp[i] != 0.0)
-         x.multAdd(tmp[i], *(matrix[i]));
-   }
+  for (i = x.dim() - 1; i >= 0; --i) {
+    if (tmp[i] != 0.0)
+      x.multAdd(tmp[i], *(matrix[i]));
+  }
 
-   return x;
+  return x;
 }
 
 template <class R>
-void SPxBasisBase<R>::multBaseWith(SSVectorBase<R>& x, SSVectorBase<R>& result) const
-{
-   assert(status() > SINGULAR);
-   assert(theLP->dim() == x.dim());
-   assert(x.dim() == result.dim());
-
-   if(!matrixIsSetup)
-      (const_cast<SPxBasisBase<R>*>(this))->loadDesc(thedesc);
-
-   assert(matrixIsSetup);
-
-   result.clear();
-
-   if(x.isSetup())
-   {
-      for(int i = 0; i < x.size(); ++i)
-      {
-         int idx = x.index(i);
-         result.multAdd(x[idx], (*matrix[idx]));
-      }
-   }
-   else
-   {
-      for(int i = 0; i < x.dim(); ++i)
-         result.multAdd(x[i], (*matrix[i]));
-   }
-
-   return;
+void SPxBasisBase<R>::multBaseWith(SSVectorBase<R> &x,
+                                   SSVectorBase<R> &result) const {
+  assert(status() > SINGULAR);
+  assert(theLP->dim() == x.dim());
+  assert(x.dim() == result.dim());
+
+  if (!matrixIsSetup)
+    (const_cast<SPxBasisBase<R> *>(this))->loadDesc(thedesc);
+
+  assert(matrixIsSetup);
+
+  result.clear();
+
+  if (x.isSetup()) {
+    for (int i = 0; i < x.size(); ++i) {
+      int idx = x.index(i);
+      result.multAdd(x[idx], (*matrix[idx]));
+    }
+  } else {
+    for (int i = 0; i < x.dim(); ++i)
+      result.multAdd(x[i], (*matrix[i]));
+  }
+
+  return;
 }
 
 template <class R>
@@ -1110,351 +1007,288 @@ template <class R>
  * by computing estimates of the norms of B and B^-1 using the power method.
  * maxiters and tolerance control the accuracy of the estimate.
  */
-R SPxBasisBase<R>::condition(int maxiters, R tolerance)
-{
-   int dimension = matrix.size();
-   int miniters = 3;    // minimum number of power method iterations
-   int i;
-   int c;
-   R norm;
-   R norminv;
-   R norm1;
-   R norm2;
-
-   // catch corner case of empty matrix
-   if(dimension <= 0)
-      return 1.0;
-
-   SSVectorBase<R> x(dimension);
-   SSVectorBase<R> y(dimension);
-
-   // check whether a regular basis matrix is available
-   if(status() < REGULAR)
-      return 0;
-
-   if(!matrixIsSetup)
-      (const_cast<SPxBasisBase<R>*>(this))->loadDesc(thedesc);
-
-   if(!factorized)
-      factorize();
+R SPxBasisBase<R>::condition(int maxiters, R tolerance) {
+  int dimension = matrix.size();
+  int miniters = 3; // minimum number of power method iterations
+  int i;
+  int c;
+  R norm;
+  R norminv;
+  R norm1;
+  R norm2;
 
-   // initialize vectors
-   norm1 = 1.0 / (R) dimension;
+  // catch corner case of empty matrix
+  if (dimension <= 0)
+    return 1.0;
 
-   for(i = 0; i < dimension; i++)
-      x.add(i, norm1);
+  SSVectorBase<R> x(dimension);
+  SSVectorBase<R> y(dimension);
 
-   y = x;
+  // check whether a regular basis matrix is available
+  if (status() < REGULAR)
+    return 0;
 
-   // compute norm of B
-   for(c = 0; c < maxiters; ++c)
-   {
-      norm2 = norm1;
+  if (!matrixIsSetup)
+    (const_cast<SPxBasisBase<R> *>(this))->loadDesc(thedesc);
 
-      // y = B*x
-      multBaseWith(x, y);
-      norm1 = y.length();
+  if (!factorized)
+    factorize();
 
-      // stop if converged
-      if(c >= miniters && spxAbs(norm1 - norm2) < tolerance * norm1)
-         break;
+  // initialize vectors
+  norm1 = 1.0 / (R)dimension;
 
-      // x = B^T*y and normalize
-      multWithBase(y, x);
-      norm2 = 1.0 / x.length();
-      x *= norm2;
-   }
+  for (i = 0; i < dimension; i++)
+    x.add(i, norm1);
 
-   norm = norm1;
+  y = x;
 
-   // reinitialize vectors
-   x.clear();
-   y.clear();
-   norm1 = 1.0 / (R) dimension;
+  // compute norm of B
+  for (c = 0; c < maxiters; ++c) {
+    norm2 = norm1;
 
-   for(i = 0; i < dimension; i++)
-      x.add(i, norm1);
+    // y = B*x
+    multBaseWith(x, y);
+    norm1 = y.length();
 
-   y = x;
+    // stop if converged
+    if (c >= miniters && spxAbs(norm1 - norm2) < tolerance * norm1)
+      break;
 
-   // compute norm of B^-1
-   for(c = 0; c < maxiters; ++c)
-   {
-      norm2 = norm1;
+    // x = B^T*y and normalize
+    multWithBase(y, x);
+    norm2 = 1.0 / x.length();
+    x *= norm2;
+  }
 
-      // x = B^-1*y
-      factor->solveRight(x, y);
-      x.setup();
-      norm1 = x.length();
+  norm = norm1;
 
-      // stop if converged
-      if(c >= miniters && spxAbs(norm1 - norm2) < tolerance * norm1)
-         break;
+  // reinitialize vectors
+  x.clear();
+  y.clear();
+  norm1 = 1.0 / (R)dimension;
 
-      // y = B^-T*x and normalize
-      factor->solveLeft(y, x);
-      y.setup();
-      norm2 = 1.0 / y.length();
-      y *= norm2;
-   }
+  for (i = 0; i < dimension; i++)
+    x.add(i, norm1);
 
-   norminv = norm1;
+  y = x;
 
-   return norm * norminv;
-}
+  // compute norm of B^-1
+  for (c = 0; c < maxiters; ++c) {
+    norm2 = norm1;
 
-/* compute one of several matrix metrics based on the diagonal of the LU factorization */
-template <class R>
-R SPxBasisBase<R>::getMatrixMetric(int type)
-{
-   R metric = R(infinity);
+    // x = B^-1*y
+    factor->solveRight(x, y);
+    x.setup();
+    norm1 = x.length();
+
+    // stop if converged
+    if (c >= miniters && spxAbs(norm1 - norm2) < tolerance * norm1)
+      break;
+
+    // y = B^-T*x and normalize
+    factor->solveLeft(y, x);
+    y.setup();
+    norm2 = 1.0 / y.length();
+    y *= norm2;
+  }
 
-   if(factorized)
-      metric = factor->matrixMetric(type);
+  norminv = norm1;
 
-   return metric;
+  return norm * norminv;
 }
 
-template <class R>
-void SPxBasisBase<R>::dump()
-{
-   assert(status() > NO_PROBLEM);
-   assert(theLP != 0);
-   assert(thedesc.nRows() == theLP->nRows());
-   assert(thedesc.nCols() == theLP->nCols());
-   assert(theLP->dim() == matrix.size());
-
-   int i, basesize;
-
-   // Dump regardless of the verbosity level if this method is called.
-
-   std::cout << "DBASIS09 Basis entries:";
-   basesize = 0;
-
-   for(i = 0; i < theLP->nRows(); ++i)
-   {
-      if(theLP->isBasic(thedesc.rowStatus(i)))
-      {
-         if(basesize % 10 == 0)
-            std::cout << std::endl << "DBASIS10 ";
-
-         SPxRowId id = theLP->SPxLPBase<R>::rId(i);
-         std::cout << "\tR" << theLP->number(id);
-         basesize++;
-      }
-   }
-
-   for(i = 0; i < theLP->nCols(); ++i)
-   {
-      if(theLP->isBasic(thedesc.colStatus(i)))
-      {
-         if(basesize % 10 == 0)
-            std::cout << std::endl << "DBASIS11 ";
-
-         SPxColId id = theLP->SPxLPBase<R>::cId(i);
-         std::cout << "\tC" << theLP->number(id);
-         basesize++;
-      }
-   }
+/* compute one of several matrix metrics based on the diagonal of the LU
+ * factorization */
+template <class R> R SPxBasisBase<R>::getMatrixMetric(int type) {
+  R metric = R(infinity);
 
-   std::cout << std::endl;
+  if (factorized)
+    metric = factor->matrixMetric(type);
 
-   assert(basesize == matrix.size());
+  return metric;
 }
 
-template <class R>
+template <class R> void SPxBasisBase<R>::dump() {
+  assert(status() > NO_PROBLEM);
+  assert(theLP != 0);
+  assert(thedesc.nRows() == theLP->nRows());
+  assert(thedesc.nCols() == theLP->nCols());
+  assert(theLP->dim() == matrix.size());
 
-bool SPxBasisBase<R>::isConsistent() const
-{
-#ifdef ENABLE_CONSISTENCY_CHECKS
-   int primals = 0;
-   int i;
-
-   if(status() > NO_PROBLEM)
-   {
-      if(theLP == 0)
-         return MSGinconsistent("SPxBasisBase<R>");
-
-      if(theBaseId.size() != theLP->dim() || matrix.size() != theLP->dim())
-         return MSGinconsistent("SPxBasisBase<R>");
-
-      if(thedesc.nCols() != theLP->nCols() || thedesc.nRows() != theLP->nRows())
-         return MSGinconsistent("SPxBasisBase<R>");
-
-      for(i = 0; i < thedesc.nRows(); ++i)
-      {
-         if(thedesc.rowStatus(i) >= 0)
-         {
-            if(thedesc.rowStatus(i) != dualRowStatus(i))
-               return MSGinconsistent("SPxBasisBase<R>");
-         }
-         else
-            ++primals;
-      }
+  int i, basesize;
 
-      for(i = 0; i < thedesc.nCols(); ++i)
-      {
-         if(thedesc.colStatus(i) >= 0)
-         {
-            if(thedesc.colStatus(i) != dualColStatus(i))
-               return MSGinconsistent("SPxBasisBase<R>");
-         }
-         else
-            ++primals;
-      }
+  // Dump regardless of the verbosity level if this method is called.
+
+  std::cout << "DBASIS09 Basis entries:";
+  basesize = 0;
+
+  for (i = 0; i < theLP->nRows(); ++i) {
+    if (theLP->isBasic(thedesc.rowStatus(i))) {
+      if (basesize % 10 == 0)
+        std::cout << std::endl << "DBASIS10 ";
 
-      if(primals != thedesc.nCols())
-         return MSGinconsistent("SPxBasisBase<R>");
-   }
+      SPxRowId id = theLP->SPxLPBase<R>::rId(i);
+      std::cout << "\tR" << theLP->number(id);
+      basesize++;
+    }
+  }
 
-   return thedesc.isConsistent() && theBaseId.isConsistent()
-          && matrix.isConsistent() && factor->isConsistent();
+  for (i = 0; i < theLP->nCols(); ++i) {
+    if (theLP->isBasic(thedesc.colStatus(i))) {
+      if (basesize % 10 == 0)
+        std::cout << std::endl << "DBASIS11 ";
+
+      SPxColId id = theLP->SPxLPBase<R>::cId(i);
+      std::cout << "\tC" << theLP->number(id);
+      basesize++;
+    }
+  }
+
+  std::cout << std::endl;
+
+  assert(basesize == matrix.size());
+}
+
+template <class R>
+
+bool SPxBasisBase<R>::isConsistent() const {
+#ifdef ENABLE_CONSISTENCY_CHECKS
+  int primals = 0;
+  int i;
+
+  if (status() > NO_PROBLEM) {
+    if (theLP == 0)
+      return MSGinconsistent("SPxBasisBase<R>");
+
+    if (theBaseId.size() != theLP->dim() || matrix.size() != theLP->dim())
+      return MSGinconsistent("SPxBasisBase<R>");
+
+    if (thedesc.nCols() != theLP->nCols() || thedesc.nRows() != theLP->nRows())
+      return MSGinconsistent("SPxBasisBase<R>");
+
+    for (i = 0; i < thedesc.nRows(); ++i) {
+      if (thedesc.rowStatus(i) >= 0) {
+        if (thedesc.rowStatus(i) != dualRowStatus(i))
+          return MSGinconsistent("SPxBasisBase<R>");
+      } else
+        ++primals;
+    }
+
+    for (i = 0; i < thedesc.nCols(); ++i) {
+      if (thedesc.colStatus(i) >= 0) {
+        if (thedesc.colStatus(i) != dualColStatus(i))
+          return MSGinconsistent("SPxBasisBase<R>");
+      } else
+        ++primals;
+    }
+
+    if (primals != thedesc.nCols())
+      return MSGinconsistent("SPxBasisBase<R>");
+  }
+
+  return thedesc.isConsistent() && theBaseId.isConsistent() &&
+         matrix.isConsistent() && factor->isConsistent();
 #else
-   return true;
+  return true;
 #endif // CONSISTENCY_CHECKS
 }
 
 template <class R>
 SPxBasisBase<R>::SPxBasisBase(Timer::TYPE ttype)
-   : theLP(0)
-   , matrixIsSetup(false)
-   , factor(0)
-   , factorized(false)
-   , maxUpdates(200)
-   , nonzeroFactor(10.0)
-   , fillFactor(5.0)
-   , memFactor(1.5)
-   , iterCount(0)
-   , lastIterCount(0)
-   , iterDegenCheck(0)
-   , updateCount(0)
-   , totalUpdateCount(0)
-   , nzCount(1)
-   , lastMem(0)
-   , lastFill(0)
-   , lastNzCount(0)
-   , theTime(0)
-   , timerType(ttype)
-   , lastidx(0)
-   , minStab(0.0)
-   , thestatus(NO_PROBLEM)
-   , freeSlinSolver(false)
-   , spxout(0)
-{
-   // info: is not consistent at this moment, e.g. because theLP == 0
-
-   theTime = TimerFactory::createTimer(timerType);
+    : theLP(0), matrixIsSetup(false), factor(0), factorized(false),
+      maxUpdates(200), nonzeroFactor(10.0), fillFactor(5.0), memFactor(1.5),
+      iterCount(0), lastIterCount(0), iterDegenCheck(0), updateCount(0),
+      totalUpdateCount(0), nzCount(1), lastMem(0), lastFill(0), lastNzCount(0),
+      theTime(0), timerType(ttype), lastidx(0), minStab(0.0),
+      thestatus(NO_PROBLEM), freeSlinSolver(false), spxout(0) {
+  // info: is not consistent at this moment, e.g. because theLP == 0
+
+  theTime = TimerFactory::createTimer(timerType);
 }
 
-
 /**@warning Do not change the LP object.
  *  Only pointer to that object is copied.
  *  Hint: no problem, we use this function for copy
  *   constructor of SPxSolverBase<R>
  */
 template <class R>
-SPxBasisBase<R>::SPxBasisBase(const SPxBasisBase<R>& old)
-   : theLP(old.theLP)
-   , theBaseId(old.theBaseId)
-   , matrix(old.matrix)
-   , matrixIsSetup(old.matrixIsSetup)
-   , factor(old.factor)
-   , factorized(old.factorized)
-   , maxUpdates(old.maxUpdates)
-   , nonzeroFactor(old.nonzeroFactor)
-   , fillFactor(old.fillFactor)
-   , memFactor(old.memFactor)
-   , iterCount(old.iterCount)
-   , lastIterCount(old.lastIterCount)
-   , iterDegenCheck(old.iterDegenCheck)
-   , updateCount(old.updateCount)
-   , totalUpdateCount(old.totalUpdateCount)
-   , nzCount(old.nzCount)
-   , lastMem(old.lastMem)
-   , lastFill(old.lastFill)
-   , lastNzCount(old.lastNzCount)
-   , theTime(old.theTime)
-   , lastin(old.lastin)
-   , lastout(old.lastout)
-   , lastidx(old.lastidx)
-   , minStab(old.minStab)
-   , thestatus(old.thestatus)
-   , thedesc(old.thedesc)
-   , spxout(old.spxout)
-{
-   theTime = TimerFactory::createTimer(old.theTime->type());
-
-   this->factor = old.factor->clone();
-   freeSlinSolver = true;
-
-   assert(SPxBasisBase<R>::isConsistent());
+SPxBasisBase<R>::SPxBasisBase(const SPxBasisBase<R> &old)
+    : theLP(old.theLP), theBaseId(old.theBaseId), matrix(old.matrix),
+      matrixIsSetup(old.matrixIsSetup), factor(old.factor),
+      factorized(old.factorized), maxUpdates(old.maxUpdates),
+      nonzeroFactor(old.nonzeroFactor), fillFactor(old.fillFactor),
+      memFactor(old.memFactor), iterCount(old.iterCount),
+      lastIterCount(old.lastIterCount), iterDegenCheck(old.iterDegenCheck),
+      updateCount(old.updateCount), totalUpdateCount(old.totalUpdateCount),
+      nzCount(old.nzCount), lastMem(old.lastMem), lastFill(old.lastFill),
+      lastNzCount(old.lastNzCount), theTime(old.theTime), lastin(old.lastin),
+      lastout(old.lastout), lastidx(old.lastidx), minStab(old.minStab),
+      thestatus(old.thestatus), thedesc(old.thedesc), spxout(old.spxout) {
+  theTime = TimerFactory::createTimer(old.theTime->type());
+
+  this->factor = old.factor->clone();
+  freeSlinSolver = true;
+
+  assert(SPxBasisBase<R>::isConsistent());
 }
 
-template <class R>
-SPxBasisBase<R>::~SPxBasisBase<R>()
-{
+template <class R> SPxBasisBase<R>::~SPxBasisBase() {
 
-   assert(!freeSlinSolver || factor != 0);
+  assert(!freeSlinSolver || factor != 0);
 
-   if(freeSlinSolver)
-   {
-      delete factor;
-      factor = 0;
-   }
+  if (freeSlinSolver) {
+    delete factor;
+    factor = 0;
+  }
 
-   theTime->~Timer();
-   spx_free(theTime);
+  theTime->~Timer();
+  spx_free(theTime);
 }
 
 template <class R>
 
-/**@warning  Note that we do not create a deep copy of the corresponding SPxSolverBase<R> object.
- *  Only the reference to that object is copied.
+/**@warning  Note that we do not create a deep copy of the corresponding
+ * SPxSolverBase<R> object. Only the reference to that object is copied.
  */
-SPxBasisBase<R>& SPxBasisBase<R>::operator=(const SPxBasisBase<R>& rhs)
-{
-
-   assert(!freeSlinSolver || factor != 0);
-
-   if(this != &rhs)
-   {
-      theLP         = rhs.theLP;
-      theBaseId     = rhs.theBaseId;
-      matrix        = rhs.matrix;
-      matrixIsSetup = rhs.matrixIsSetup;
-
-      if(freeSlinSolver)
-      {
-         delete factor;
-         factor = 0;
-      }
+SPxBasisBase<R> &SPxBasisBase<R>::operator=(const SPxBasisBase<R> &rhs) {
 
-      factor = rhs.factor->clone();
-      freeSlinSolver = true;
-
-      factorized    = rhs.factorized;
-      maxUpdates    = rhs.maxUpdates;
-      nonzeroFactor = rhs.nonzeroFactor;
-      fillFactor    = rhs.fillFactor;
-      memFactor     = rhs.memFactor;
-      iterCount     = rhs.iterCount;
-      nzCount       = rhs.nzCount;
-      lastFill      = rhs.lastFill;
-      lastNzCount   = rhs.lastNzCount;
-      lastin        = rhs.lastin;
-      lastout       = rhs.lastout;
-      lastidx       = rhs.lastidx;
-      minStab       = rhs.minStab;
-      thestatus     = rhs.thestatus;
-      thedesc       = rhs.thedesc;
-
-      assert(SPxBasisBase<R>::isConsistent());
-   }
-
-   return *this;
-}
+  assert(!freeSlinSolver || factor != 0);
 
+  if (this != &rhs) {
+    theLP = rhs.theLP;
+    theBaseId = rhs.theBaseId;
+    matrix = rhs.matrix;
+    matrixIsSetup = rhs.matrixIsSetup;
 
+    if (freeSlinSolver) {
+      delete factor;
+      factor = 0;
+    }
+
+    factor = rhs.factor->clone();
+    freeSlinSolver = true;
+
+    factorized = rhs.factorized;
+    maxUpdates = rhs.maxUpdates;
+    nonzeroFactor = rhs.nonzeroFactor;
+    fillFactor = rhs.fillFactor;
+    memFactor = rhs.memFactor;
+    iterCount = rhs.iterCount;
+    nzCount = rhs.nzCount;
+    lastFill = rhs.lastFill;
+    lastNzCount = rhs.lastNzCount;
+    lastin = rhs.lastin;
+    lastout = rhs.lastout;
+    lastidx = rhs.lastidx;
+    minStab = rhs.minStab;
+    thestatus = rhs.thestatus;
+    thedesc = rhs.thedesc;
+
+    assert(SPxBasisBase<R>::isConsistent());
+  }
+
+  return *this;
+}
 
 //
 // Auxiliary functions.
@@ -1462,50 +1296,47 @@ SPxBasisBase<R>& SPxBasisBase<R>::operator=(const SPxBasisBase<R>& rhs)
 
 // Pretty-printing of basis status.
 template <class R> // Why can't we remove the class R and make it empty?
-std::ostream& operator<<(std::ostream& os,
-                         const typename SPxBasisBase<R>::SPxStatus& status)
-{
-   switch(status)
-   {
-   case SPxBasisBase<R>::NO_PROBLEM:
-      os << "NO_PROBLEM";
-      break;
-
-   case SPxBasisBase<R>::SINGULAR:
-      os << "SINGULAR";
-      break;
-
-   case SPxBasisBase<R>::REGULAR:
-      os << "REGULAR";
-      break;
-
-   case SPxBasisBase<R>::DUAL:
-      os << "DUAL";
-      break;
-
-   case SPxBasisBase<R>::PRIMAL:
-      os << "PRIMAL";
-      break;
-
-   case SPxBasisBase<R>::OPTIMAL:
-      os << "OPTIMAL";
-      break;
-
-   case SPxBasisBase<R>::UNBOUNDED:
-      os << "UNBOUNDED";
-      break;
-
-   case SPxBasisBase<R>::INFEASIBLE:
-      os << "INFEASIBLE";
-      break;
-
-   default:
-      os << "?other?";
-      break;
-   }
-
-   return os;
+std::ostream &operator<<(std::ostream &os,
+                         const typename SPxBasisBase<R>::SPxStatus &status) {
+  switch (status) {
+  case SPxBasisBase<R>::NO_PROBLEM:
+    os << "NO_PROBLEM";
+    break;
+
+  case SPxBasisBase<R>::SINGULAR:
+    os << "SINGULAR";
+    break;
+
+  case SPxBasisBase<R>::REGULAR:
+    os << "REGULAR";
+    break;
+
+  case SPxBasisBase<R>::DUAL:
+    os << "DUAL";
+    break;
+
+  case SPxBasisBase<R>::PRIMAL:
+    os << "PRIMAL";
+    break;
+
+  case SPxBasisBase<R>::OPTIMAL:
+    os << "OPTIMAL";
+    break;
+
+  case SPxBasisBase<R>::UNBOUNDED:
+    os << "UNBOUNDED";
+    break;
+
+  case SPxBasisBase<R>::INFEASIBLE:
+    os << "INFEASIBLE";
+    break;
+
+  default:
+    os << "?other?";
+    break;
+  }
+
+  return os;
 }
 
-
 } // namespace soplex
diff --git a/src/soplex/spxboundflippingrt.hpp b/src/soplex/spxboundflippingrt.hpp
index 55c8579..bba3498 100644
--- a/src/soplex/spxboundflippingrt.hpp
+++ b/src/soplex/spxboundflippingrt.hpp
@@ -21,1268 +21,1127 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
-#include <assert.h>
-#include "soplex/spxdefines.h"
 #include "soplex/sorter.h"
-#include "soplex/spxsolver.h"
-#include "soplex/spxout.h"
+#include "soplex/spxdefines.h"
 #include "soplex/spxid.h"
+#include "soplex/spxout.h"
+#include "soplex/spxsolver.h"
+#include <assert.h>
 
-namespace soplex
-{
-
-#define LOWSTAB          1e-10
-#define MAX_RELAX_COUNT  2
-#define LONGSTEP_FREQ    100
+namespace soplex {
 
+#define LOWSTAB 1e-10
+#define MAX_RELAX_COUNT 2
+#define LONGSTEP_FREQ 100
 
 /** perform necessary bound flips to restore dual feasibility */
 template <class R>
 void SPxBoundFlippingRT<R>::flipAndUpdate(
-   int&                  nflips              /**< number of bounds that should be flipped */
-)
-{
-   assert(nflips > 0);
-
-   // number of bound flips that are not performed
-   int skipped;
-
-   updPrimRhs.setup();
-   updPrimRhs.reDim(this->thesolver->dim());
-   updPrimVec.reDim(this->thesolver->dim());
-   updPrimRhs.clear();
-   updPrimVec.clear();
-
-   skipped = 0;
-
-   for(int i = 0; i < nflips; ++i)
-   {
-      int idx;
-      idx = breakpoints[i].idx;
-
-      if(idx < 0)
-      {
-         ++skipped;
-         continue;
-      }
-
-      R range;
-      R upper;
-      R lower;
-      R objChange = 0.0;
-      typename SPxBasisBase<R>::Desc::Status stat;
-      typename SPxBasisBase<R>::Desc& ds = this->thesolver->basis().desc();
-
-      range = 0;
-
-      if(breakpoints[i].src == PVEC)
-      {
-         assert(this->thesolver->rep() == SPxSolverBase<R>::COLUMN);
-         stat = ds.status(idx);
-         upper = this->thesolver->upper(idx);
-         lower = this->thesolver->lower(idx);
-
-         switch(stat)
-         {
-         case SPxBasisBase<R>::Desc::P_ON_UPPER :
-            ds.status(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-            range = lower - upper;
-            assert((*this->thesolver->theLbound)[idx] == R(-infinity));
-            (*this->thesolver->theLbound)[idx] = (*this->thesolver->theUbound)[idx];
-            (*this->thesolver->theUbound)[idx] = R(infinity);
-            objChange = range * (*this->thesolver->theLbound)[idx];
-            break;
-
-         case SPxBasisBase<R>::Desc::P_ON_LOWER :
-            ds.status(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-            range = upper - lower;
-            assert((*this->thesolver->theUbound)[idx] == R(infinity));
-            (*this->thesolver->theUbound)[idx] = (*this->thesolver->theLbound)[idx];
-            (*this->thesolver->theLbound)[idx] = R(-infinity);
-            objChange = range * (*this->thesolver->theUbound)[idx];
-            break;
-
-         default :
-            ++skipped;
-            MSG_WARNING((*this->thesolver->spxout),
-                        (*this->thesolver->spxout) << "PVEC unexpected status: " << static_cast<int>(stat)
+    int &nflips /**< number of bounds that should be flipped */
+) {
+  assert(nflips > 0);
+
+  // number of bound flips that are not performed
+  int skipped;
+
+  updPrimRhs.setup();
+  updPrimRhs.reDim(this->thesolver->dim());
+  updPrimVec.reDim(this->thesolver->dim());
+  updPrimRhs.clear();
+  updPrimVec.clear();
+
+  skipped = 0;
+
+  for (int i = 0; i < nflips; ++i) {
+    int idx;
+    idx = breakpoints[i].idx;
+
+    if (idx < 0) {
+      ++skipped;
+      continue;
+    }
+
+    R range;
+    R upper;
+    R lower;
+    R objChange = 0.0;
+    typename SPxBasisBase<R>::Desc::Status stat;
+    typename SPxBasisBase<R>::Desc &ds = this->thesolver->basis().desc();
+
+    range = 0;
+
+    if (breakpoints[i].src == PVEC) {
+      assert(this->thesolver->rep() == SPxSolverBase<R>::COLUMN);
+      stat = ds.status(idx);
+      upper = this->thesolver->upper(idx);
+      lower = this->thesolver->lower(idx);
+
+      switch (stat) {
+      case SPxBasisBase<R>::Desc::P_ON_UPPER:
+        ds.status(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+        range = lower - upper;
+        assert((*this->thesolver->theLbound)[idx] == R(-infinity));
+        (*this->thesolver->theLbound)[idx] = (*this->thesolver->theUbound)[idx];
+        (*this->thesolver->theUbound)[idx] = R(infinity);
+        objChange = range * (*this->thesolver->theLbound)[idx];
+        break;
+
+      case SPxBasisBase<R>::Desc::P_ON_LOWER:
+        ds.status(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+        range = upper - lower;
+        assert((*this->thesolver->theUbound)[idx] == R(infinity));
+        (*this->thesolver->theUbound)[idx] = (*this->thesolver->theLbound)[idx];
+        (*this->thesolver->theLbound)[idx] = R(-infinity);
+        objChange = range * (*this->thesolver->theUbound)[idx];
+        break;
+
+      default:
+        ++skipped;
+        MSG_WARNING((*this->thesolver->spxout),
+                    (*this->thesolver->spxout)
+                        << "PVEC unexpected status: " << static_cast<int>(stat)
                         << " index: " << idx
                         << " val: " << this->thesolver->pVec()[idx]
                         << " upd: " << this->thesolver->pVec().delta()[idx]
-                        << " lower: " << lower
-                        << " upper: " << upper
-                        << " bp.val: " << breakpoints[i].val
-                        << std::endl;)
-         }
-
-         MSG_DEBUG(std::cout << "PVEC flipped from: " << stat
-                   << " index: " << idx
-                   << " val: " << this->thesolver->pVec()[idx]
-                   << " upd: " << this->thesolver->pVec().delta()[idx]
-                   << " lower: " << lower
-                   << " upper: " << upper
-                   << " bp.val: " << breakpoints[i].val
-                   << " UCbound: " << this->thesolver->theUCbound[idx]
-                   << " LCbound: " << this->thesolver->theLCbound[idx]
-                   << std::endl;)
-         assert(spxAbs(range) < 1e20);
-         updPrimRhs.multAdd(range, this->thesolver->vector(idx));
-
-         if(objChange != 0.0)
-            this->thesolver->updateNonbasicValue(objChange);
+                        << " lower: " << lower << " upper: " << upper
+                        << " bp.val: " << breakpoints[i].val << std::endl;)
       }
-      else if(breakpoints[i].src == COPVEC)
-      {
-         assert(this->thesolver->rep() == SPxSolverBase<R>::COLUMN);
-         stat = ds.coStatus(idx);
-         upper = this->thesolver->rhs(idx);
-         lower = this->thesolver->lhs(idx);
-
-         switch(stat)
-         {
-         case SPxBasisBase<R>::Desc::P_ON_UPPER :
-            ds.coStatus(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-            range = lower - upper;
-            assert((*this->thesolver->theCoUbound)[idx] == R(infinity));
-            (*this->thesolver->theCoUbound)[idx] = -(*this->thesolver->theCoLbound)[idx];
-            (*this->thesolver->theCoLbound)[idx] = R(-infinity);
-            objChange = range * (*this->thesolver->theCoUbound)[idx];
-            break;
-
-         case SPxBasisBase<R>::Desc::P_ON_LOWER :
-            ds.coStatus(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-            range = upper - lower;
-            assert((*this->thesolver->theCoLbound)[idx] == R(-infinity));
-            (*this->thesolver->theCoLbound)[idx] = -(*this->thesolver->theCoUbound)[idx];
-            (*this->thesolver->theCoUbound)[idx] = R(infinity);
-            objChange = range * (*this->thesolver->theCoLbound)[idx];
-            break;
-
-         default :
-            ++skipped;
-            MSG_WARNING((*this->thesolver->spxout),
-                        (*this->thesolver->spxout) << "COPVEC unexpected status: " << static_cast<int>(stat)
-                        << " index: " << idx
+
+      MSG_DEBUG(std::cout << "PVEC flipped from: " << stat << " index: " << idx
+                          << " val: " << this->thesolver->pVec()[idx]
+                          << " upd: " << this->thesolver->pVec().delta()[idx]
+                          << " lower: " << lower << " upper: " << upper
+                          << " bp.val: " << breakpoints[i].val
+                          << " UCbound: " << this->thesolver->theUCbound[idx]
+                          << " LCbound: " << this->thesolver->theLCbound[idx]
+                          << std::endl;)
+      assert(spxAbs(range) < 1e20);
+      updPrimRhs.multAdd(range, this->thesolver->vector(idx));
+
+      if (objChange != 0.0)
+        this->thesolver->updateNonbasicValue(objChange);
+    } else if (breakpoints[i].src == COPVEC) {
+      assert(this->thesolver->rep() == SPxSolverBase<R>::COLUMN);
+      stat = ds.coStatus(idx);
+      upper = this->thesolver->rhs(idx);
+      lower = this->thesolver->lhs(idx);
+
+      switch (stat) {
+      case SPxBasisBase<R>::Desc::P_ON_UPPER:
+        ds.coStatus(idx) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+        range = lower - upper;
+        assert((*this->thesolver->theCoUbound)[idx] == R(infinity));
+        (*this->thesolver->theCoUbound)[idx] =
+            -(*this->thesolver->theCoLbound)[idx];
+        (*this->thesolver->theCoLbound)[idx] = R(-infinity);
+        objChange = range * (*this->thesolver->theCoUbound)[idx];
+        break;
+
+      case SPxBasisBase<R>::Desc::P_ON_LOWER:
+        ds.coStatus(idx) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+        range = upper - lower;
+        assert((*this->thesolver->theCoLbound)[idx] == R(-infinity));
+        (*this->thesolver->theCoLbound)[idx] =
+            -(*this->thesolver->theCoUbound)[idx];
+        (*this->thesolver->theCoUbound)[idx] = R(infinity);
+        objChange = range * (*this->thesolver->theCoLbound)[idx];
+        break;
+
+      default:
+        ++skipped;
+        MSG_WARNING((*this->thesolver->spxout),
+                    (*this->thesolver->spxout)
+                        << "COPVEC unexpected status: "
+                        << static_cast<int>(stat) << " index: " << idx
                         << " val: " << this->thesolver->coPvec()[idx]
                         << " upd: " << this->thesolver->coPvec().delta()[idx]
-                        << " lower: " << lower
-                        << " upper: " << upper
-                        << " bp.val: " << breakpoints[i].val
-                        << std::endl;)
-         }
-
-         MSG_DEBUG(std::cout << "COPVEC flipped from: " << stat
-                   << " index: " << idx
-                   << " val: " << this->thesolver->coPvec()[idx]
-                   << " upd: " << this->thesolver->coPvec().delta()[idx]
-                   << " lower: " << lower
-                   << " upper: " << upper
-                   << " bp.val: " << breakpoints[i].val
-                   << " URbound: " << this->thesolver->theURbound[idx]
-                   << " LRbound: " << this->thesolver->theLRbound[idx]
-                   << std::endl;)
-         assert(spxAbs(range) < 1e20);
-         updPrimRhs.setValue(idx, updPrimRhs[idx] - range);
-
-         if(objChange != 0.0)
-            this->thesolver->updateNonbasicValue(objChange);
+                        << " lower: " << lower << " upper: " << upper
+                        << " bp.val: " << breakpoints[i].val << std::endl;)
       }
-      else if(breakpoints[i].src == FVEC)
-      {
-         assert(this->thesolver->rep() == SPxSolverBase<R>::ROW);
-         SPxId baseId = this->thesolver->basis().baseId(idx);
-         int IdNumber;
-
-         if(baseId.isSPxRowId())
-         {
-            IdNumber = this->thesolver->number(SPxRowId(baseId));
-            stat = ds.rowStatus(IdNumber);
-            upper = this->thesolver->rhs(IdNumber);
-            lower = this->thesolver->lhs(IdNumber);
-
-            switch(stat)
-            {
-            case SPxBasisBase<R>::Desc::P_ON_UPPER :
-               ds.rowStatus(IdNumber) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-               range = upper - lower;
-               assert(this->thesolver->theUBbound[idx] == R(infinity));
-               this->thesolver->theUBbound[idx] = -this->thesolver->theLBbound[idx];
-               this->thesolver->theLBbound[idx] = R(-infinity);
-               break;
-
-            case SPxBasisBase<R>::Desc::P_ON_LOWER :
-               ds.rowStatus(IdNumber) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-               range = lower - upper;
-               assert(this->thesolver->theLBbound[idx] == R(-infinity));
-               this->thesolver->theLBbound[idx] = -this->thesolver->theUBbound[idx];
-               this->thesolver->theUBbound[idx] = R(infinity);
-               break;
-
-            default :
-               ++skipped;
-               MSG_WARNING((*this->thesolver->spxout),
-                           (*this->thesolver->spxout) << "unexpected basis status: " << static_cast<int>(stat)
-                           << " index: " << idx
-                           << " val: " << this->thesolver->fVec()[idx]
-                           << " upd: " << this->thesolver->fVec().delta()[idx]
-                           << " lower: " << lower
-                           << " upper: " << upper
-                           << " bp.val: " << breakpoints[i].val
-                           << std::endl;)
-            }
-         }
-         else
-         {
-            assert(baseId.isSPxColId());
-            IdNumber = this->thesolver->number(SPxColId(baseId));
-            stat = ds.colStatus(IdNumber);
-            upper = this->thesolver->upper(IdNumber);
-            lower = this->thesolver->lower(IdNumber);
-
-            switch(stat)
-            {
-            case SPxBasisBase<R>::Desc::P_ON_UPPER :
-               ds.colStatus(IdNumber) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-               range = upper - lower;
-               assert(this->thesolver->theUBbound[idx] == R(infinity));
-               this->thesolver->theUBbound[idx] = -this->thesolver->theLBbound[idx];
-               this->thesolver->theLBbound[idx] = R(-infinity);
-               break;
-
-            case SPxBasisBase<R>::Desc::P_ON_LOWER :
-               ds.colStatus(IdNumber) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-               range = lower - upper;
-               assert(this->thesolver->theLBbound[idx] == R(-infinity));
-               this->thesolver->theLBbound[idx] = -this->thesolver->theUBbound[idx];
-               this->thesolver->theUBbound[idx] = R(infinity);
-               break;
-
-            default :
-               ++skipped;
-               MSG_WARNING((*this->thesolver->spxout),
-                           (*this->thesolver->spxout) << "FVEC unexpected status: " << static_cast<int>(stat)
-                           << " index: " << idx
-                           << " val: " << this->thesolver->fVec()[idx]
-                           << " upd: " << this->thesolver->fVec().delta()[idx]
-                           << " lower: " << lower
-                           << " upper: " << upper
-                           << " bp.val: " << breakpoints[i].val
-                           << std::endl;)
-            }
-         }
-
-         MSG_DEBUG(std::cout << "basic row/col flipped from: " << stat
-                   << " index: " << idx
-                   << " val: " << this->thesolver->fVec()[idx]
-                   << " upd: " << this->thesolver->fVec().delta()[idx]
-                   << " lower: " << lower
-                   << " upper: " << upper
-                   << " bp.val: " << breakpoints[i].val
-                   << std::endl;)
-         assert(spxAbs(range) < 1e20);
-         assert(updPrimRhs[idx] == 0);
-         updPrimRhs.add(idx, range);
-      }
-   }
-
-   nflips -= skipped;
 
-   if(nflips > 0)
-   {
-      if(this->thesolver->rep() == SPxSolverBase<R>::ROW)
-      {
-         assert(this->m_type == SPxSolverBase<R>::ENTER);
-         (*this->thesolver->theCoPrhs) -= updPrimRhs;
-         this->thesolver->setup4coSolve2(&updPrimVec, &updPrimRhs);
+      MSG_DEBUG(std::cout << "COPVEC flipped from: " << stat << " index: "
+                          << idx << " val: " << this->thesolver->coPvec()[idx]
+                          << " upd: " << this->thesolver->coPvec().delta()[idx]
+                          << " lower: " << lower << " upper: " << upper
+                          << " bp.val: " << breakpoints[i].val
+                          << " URbound: " << this->thesolver->theURbound[idx]
+                          << " LRbound: " << this->thesolver->theLRbound[idx]
+                          << std::endl;)
+      assert(spxAbs(range) < 1e20);
+      updPrimRhs.setValue(idx, updPrimRhs[idx] - range);
+
+      if (objChange != 0.0)
+        this->thesolver->updateNonbasicValue(objChange);
+    } else if (breakpoints[i].src == FVEC) {
+      assert(this->thesolver->rep() == SPxSolverBase<R>::ROW);
+      SPxId baseId = this->thesolver->basis().baseId(idx);
+      int IdNumber;
+
+      if (baseId.isSPxRowId()) {
+        IdNumber = this->thesolver->number(SPxRowId(baseId));
+        stat = ds.rowStatus(IdNumber);
+        upper = this->thesolver->rhs(IdNumber);
+        lower = this->thesolver->lhs(IdNumber);
+
+        switch (stat) {
+        case SPxBasisBase<R>::Desc::P_ON_UPPER:
+          ds.rowStatus(IdNumber) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+          range = upper - lower;
+          assert(this->thesolver->theUBbound[idx] == R(infinity));
+          this->thesolver->theUBbound[idx] = -this->thesolver->theLBbound[idx];
+          this->thesolver->theLBbound[idx] = R(-infinity);
+          break;
+
+        case SPxBasisBase<R>::Desc::P_ON_LOWER:
+          ds.rowStatus(IdNumber) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+          range = lower - upper;
+          assert(this->thesolver->theLBbound[idx] == R(-infinity));
+          this->thesolver->theLBbound[idx] = -this->thesolver->theUBbound[idx];
+          this->thesolver->theUBbound[idx] = R(infinity);
+          break;
+
+        default:
+          ++skipped;
+          MSG_WARNING((*this->thesolver->spxout),
+                      (*this->thesolver->spxout)
+                          << "unexpected basis status: "
+                          << static_cast<int>(stat) << " index: " << idx
+                          << " val: " << this->thesolver->fVec()[idx]
+                          << " upd: " << this->thesolver->fVec().delta()[idx]
+                          << " lower: " << lower << " upper: " << upper
+                          << " bp.val: " << breakpoints[i].val << std::endl;)
+        }
+      } else {
+        assert(baseId.isSPxColId());
+        IdNumber = this->thesolver->number(SPxColId(baseId));
+        stat = ds.colStatus(IdNumber);
+        upper = this->thesolver->upper(IdNumber);
+        lower = this->thesolver->lower(IdNumber);
+
+        switch (stat) {
+        case SPxBasisBase<R>::Desc::P_ON_UPPER:
+          ds.colStatus(IdNumber) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+          range = upper - lower;
+          assert(this->thesolver->theUBbound[idx] == R(infinity));
+          this->thesolver->theUBbound[idx] = -this->thesolver->theLBbound[idx];
+          this->thesolver->theLBbound[idx] = R(-infinity);
+          break;
+
+        case SPxBasisBase<R>::Desc::P_ON_LOWER:
+          ds.colStatus(IdNumber) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+          range = lower - upper;
+          assert(this->thesolver->theLBbound[idx] == R(-infinity));
+          this->thesolver->theLBbound[idx] = -this->thesolver->theUBbound[idx];
+          this->thesolver->theUBbound[idx] = R(infinity);
+          break;
+
+        default:
+          ++skipped;
+          MSG_WARNING((*this->thesolver->spxout),
+                      (*this->thesolver->spxout)
+                          << "FVEC unexpected status: "
+                          << static_cast<int>(stat) << " index: " << idx
+                          << " val: " << this->thesolver->fVec()[idx]
+                          << " upd: " << this->thesolver->fVec().delta()[idx]
+                          << " lower: " << lower << " upper: " << upper
+                          << " bp.val: " << breakpoints[i].val << std::endl;)
+        }
       }
-      else
-      {
-         assert(this->thesolver->rep() == SPxSolverBase<R>::COLUMN);
-         assert(this->m_type == SPxSolverBase<R>::LEAVE);
-         (*this->thesolver->theFrhs) -= updPrimRhs;
-         this->thesolver->setup4solve2(&updPrimVec, &updPrimRhs);
-      }
-   }
 
-   return;
+      MSG_DEBUG(std::cout << "basic row/col flipped from: " << stat
+                          << " index: " << idx
+                          << " val: " << this->thesolver->fVec()[idx]
+                          << " upd: " << this->thesolver->fVec().delta()[idx]
+                          << " lower: " << lower << " upper: " << upper
+                          << " bp.val: " << breakpoints[i].val << std::endl;)
+      assert(spxAbs(range) < 1e20);
+      assert(updPrimRhs[idx] == 0);
+      updPrimRhs.add(idx, range);
+    }
+  }
+
+  nflips -= skipped;
+
+  if (nflips > 0) {
+    if (this->thesolver->rep() == SPxSolverBase<R>::ROW) {
+      assert(this->m_type == SPxSolverBase<R>::ENTER);
+      (*this->thesolver->theCoPrhs) -= updPrimRhs;
+      this->thesolver->setup4coSolve2(&updPrimVec, &updPrimRhs);
+    } else {
+      assert(this->thesolver->rep() == SPxSolverBase<R>::COLUMN);
+      assert(this->m_type == SPxSolverBase<R>::LEAVE);
+      (*this->thesolver->theFrhs) -= updPrimRhs;
+      this->thesolver->setup4solve2(&updPrimVec, &updPrimRhs);
+    }
+  }
+
+  return;
 }
 
-/** store all available pivots/breakpoints in an array (positive pivot search direction) */
+/** store all available pivots/breakpoints in an array (positive pivot search
+ * direction) */
 template <class R>
 void SPxBoundFlippingRT<R>::collectBreakpointsMax(
-   int&                  nBp,                /**< number of found breakpoints so far */
-   int&                  minIdx,             /**< index to current minimal breakpoint */
-   const int*            idx,                /**< pointer to indices of current VectorBase<R> */
-   int                   nnz,                /**< number of nonzeros in current VectorBase<R> */
-   const R*           upd,                /**< pointer to update values of current VectorBase<R> */
-   const R*           vec,                /**< pointer to values of current VectorBase<R> */
-   const R*           upp,                /**< pointer to upper bound/rhs of current VectorBase<R> */
-   const R*           low,                /**< pointer to lower bound/lhs of current VectorBase<R> */
-   BreakpointSource      src                 /**< type of VectorBase<R> (pVec, coPvec or fVec)*/
-)
-{
-   R minVal;
-   R curVal;
-   const int* last;
-
-   minVal = (nBp == 0) ? R(infinity) : breakpoints[minIdx].val;
-
-   last = idx + nnz;
-
-   for(; idx < last; ++idx)
-   {
-      int i = *idx;
-      R x = upd[i];
-
-      if(x > this->epsilon)
-      {
-         if(upp[i] < R(infinity))
-         {
-            R y = upp[i] - vec[i];
-            curVal = (y <= 0) ? this->fastDelta / x : (y + this->fastDelta) / x;
-            assert(curVal > 0);
-
-            breakpoints[nBp].idx = i;
-            breakpoints[nBp].src = src;
-            breakpoints[nBp].val = curVal;
-
-            if(curVal < minVal)
-            {
-               minVal = curVal;
-               minIdx = nBp;
-            }
-
-            nBp++;
-         }
+    int &nBp,       /**< number of found breakpoints so far */
+    int &minIdx,    /**< index to current minimal breakpoint */
+    const int *idx, /**< pointer to indices of current VectorBase<R> */
+    int nnz,        /**< number of nonzeros in current VectorBase<R> */
+    const R *upd,   /**< pointer to update values of current VectorBase<R> */
+    const R *vec,   /**< pointer to values of current VectorBase<R> */
+    const R *upp,   /**< pointer to upper bound/rhs of current VectorBase<R> */
+    const R *low,   /**< pointer to lower bound/lhs of current VectorBase<R> */
+    BreakpointSource src /**< type of VectorBase<R> (pVec, coPvec or fVec)*/
+) {
+  R minVal;
+  R curVal;
+  const int *last;
+
+  minVal = (nBp == 0) ? R(infinity) : breakpoints[minIdx].val;
+
+  last = idx + nnz;
+
+  for (; idx < last; ++idx) {
+    int i = *idx;
+    R x = upd[i];
+
+    if (x > this->epsilon) {
+      if (upp[i] < R(infinity)) {
+        R y = upp[i] - vec[i];
+        curVal = (y <= 0) ? this->fastDelta / x : (y + this->fastDelta) / x;
+        assert(curVal > 0);
+
+        breakpoints[nBp].idx = i;
+        breakpoints[nBp].src = src;
+        breakpoints[nBp].val = curVal;
+
+        if (curVal < minVal) {
+          minVal = curVal;
+          minIdx = nBp;
+        }
+
+        nBp++;
       }
-      else if(x < -this->epsilon)
-      {
-         if(low[i] > R(-infinity))
-         {
-            R y = low[i] - vec[i];
-            curVal = (y >= 0) ? -this->fastDelta / x : (y - this->fastDelta) / x;
-            assert(curVal > 0);
-
-            breakpoints[nBp].idx = i;
-            breakpoints[nBp].src = src;
-            breakpoints[nBp].val = curVal;
-
-            if(curVal < minVal)
-            {
-               minVal = curVal;
-               minIdx = nBp;
-            }
-
-            nBp++;
-         }
+    } else if (x < -this->epsilon) {
+      if (low[i] > R(-infinity)) {
+        R y = low[i] - vec[i];
+        curVal = (y >= 0) ? -this->fastDelta / x : (y - this->fastDelta) / x;
+        assert(curVal > 0);
+
+        breakpoints[nBp].idx = i;
+        breakpoints[nBp].src = src;
+        breakpoints[nBp].val = curVal;
+
+        if (curVal < minVal) {
+          minVal = curVal;
+          minIdx = nBp;
+        }
+
+        nBp++;
       }
+    }
 
-      if(nBp >= breakpoints.size())
-         breakpoints.reSize(nBp * 2);
-   }
+    if (nBp >= breakpoints.size())
+      breakpoints.reSize(nBp * 2);
+  }
 
-   return;
+  return;
 }
 
-/** store all available pivots/breakpoints in an array (negative pivot search direction) */
+/** store all available pivots/breakpoints in an array (negative pivot search
+ * direction) */
 template <class R>
 void SPxBoundFlippingRT<R>::collectBreakpointsMin(
-   int&                  nBp,                /**< number of found breakpoints so far */
-   int&                  minIdx,             /**< index to current minimal breakpoint */
-   const int*            idx,                /**< pointer to indices of current VectorBase<R> */
-   int                   nnz,                /**< number of nonzeros in current VectorBase<R> */
-   const R*           upd,                /**< pointer to update values of current VectorBase<R> */
-   const R*           vec,                /**< pointer to values of current VectorBase<R> */
-   const R*           upp,                /**< pointer to upper bound/rhs of current VectorBase<R> */
-   const R*           low,                /**< pointer to lower bound/lhs of current VectorBase<R> */
-   BreakpointSource      src                 /**< type of VectorBase<R> (pVec, coPvec or fVec)*/
-)
-{
-   R minVal;
-   R curVal;
-   const int* last;
-
-   minVal = (nBp == 0) ? R(infinity) : breakpoints[minIdx].val;
-
-   last = idx + nnz;
-
-   for(; idx < last; ++idx)
-   {
-      int i = *idx;
-      R x = upd[i];
-
-      if(x > this->epsilon)
-      {
-         if(low[i] > R(-infinity))
-         {
-            R y = low[i] - vec[i];
-
-            curVal = (y >= 0) ? this->fastDelta / x : (this->fastDelta - y) / x;
-            assert(curVal > 0);
-
-            breakpoints[nBp].idx = i;
-            breakpoints[nBp].src = src;
-            breakpoints[nBp].val = curVal;
-
-            if(curVal < minVal)
-            {
-               minVal = curVal;
-               minIdx = nBp;
-            }
-
-            nBp++;
-         }
+    int &nBp,       /**< number of found breakpoints so far */
+    int &minIdx,    /**< index to current minimal breakpoint */
+    const int *idx, /**< pointer to indices of current VectorBase<R> */
+    int nnz,        /**< number of nonzeros in current VectorBase<R> */
+    const R *upd,   /**< pointer to update values of current VectorBase<R> */
+    const R *vec,   /**< pointer to values of current VectorBase<R> */
+    const R *upp,   /**< pointer to upper bound/rhs of current VectorBase<R> */
+    const R *low,   /**< pointer to lower bound/lhs of current VectorBase<R> */
+    BreakpointSource src /**< type of VectorBase<R> (pVec, coPvec or fVec)*/
+) {
+  R minVal;
+  R curVal;
+  const int *last;
+
+  minVal = (nBp == 0) ? R(infinity) : breakpoints[minIdx].val;
+
+  last = idx + nnz;
+
+  for (; idx < last; ++idx) {
+    int i = *idx;
+    R x = upd[i];
+
+    if (x > this->epsilon) {
+      if (low[i] > R(-infinity)) {
+        R y = low[i] - vec[i];
+
+        curVal = (y >= 0) ? this->fastDelta / x : (this->fastDelta - y) / x;
+        assert(curVal > 0);
+
+        breakpoints[nBp].idx = i;
+        breakpoints[nBp].src = src;
+        breakpoints[nBp].val = curVal;
+
+        if (curVal < minVal) {
+          minVal = curVal;
+          minIdx = nBp;
+        }
+
+        nBp++;
       }
-      else if(x < -this->epsilon)
-      {
-         if(upp[i] < R(infinity))
-         {
-            R y = upp[i] - vec[i];
-            curVal = (y <= 0) ? -this->fastDelta / x : -(y + this->fastDelta) / x;
-            assert(curVal > 0);
-
-            breakpoints[nBp].idx = i;
-            breakpoints[nBp].src = src;
-            breakpoints[nBp].val = curVal;
-
-            if(curVal < minVal)
-            {
-               minVal = curVal;
-               minIdx = nBp;
-            }
-
-            nBp++;
-         }
+    } else if (x < -this->epsilon) {
+      if (upp[i] < R(infinity)) {
+        R y = upp[i] - vec[i];
+        curVal = (y <= 0) ? -this->fastDelta / x : -(y + this->fastDelta) / x;
+        assert(curVal > 0);
+
+        breakpoints[nBp].idx = i;
+        breakpoints[nBp].src = src;
+        breakpoints[nBp].val = curVal;
+
+        if (curVal < minVal) {
+          minVal = curVal;
+          minIdx = nBp;
+        }
+
+        nBp++;
       }
+    }
 
-      if(nBp >= breakpoints.size())
-         breakpoints.reSize(nBp * 2);
-   }
+    if (nBp >= breakpoints.size())
+      breakpoints.reSize(nBp * 2);
+  }
 
-   return;
+  return;
 }
 
 /** get values for entering index and perform shifts if necessary */
 template <class R>
-bool SPxBoundFlippingRT<R>::getData(
-   R&                 val,
-   SPxId&                enterId,
-   int                   idx,
-   R                  stab,
-   R                  degeneps,
-   const R*           upd,
-   const R*           vec,
-   const R*           low,
-   const R*           upp,
-   BreakpointSource      src,
-   R                  max
-)
-{
-   if(src == PVEC)
-   {
-      this->thesolver->pVec()[idx] = this->thesolver->vector(idx) * this->thesolver->coPvec();
-      R x = upd[idx];
-
-      // skip breakpoint if it is too small
-      if(spxAbs(x) < stab)
-      {
-         return false;
-      }
+bool SPxBoundFlippingRT<R>::getData(R &val, SPxId &enterId, int idx, R stab,
+                                    R degeneps, const R *upd, const R *vec,
+                                    const R *low, const R *upp,
+                                    BreakpointSource src, R max) {
+  if (src == PVEC) {
+    this->thesolver->pVec()[idx] =
+        this->thesolver->vector(idx) * this->thesolver->coPvec();
+    R x = upd[idx];
+
+    // skip breakpoint if it is too small
+    if (spxAbs(x) < stab) {
+      return false;
+    }
 
-      enterId = this->thesolver->id(idx);
-      val = (max * x > 0) ? upp[idx] : low[idx];
-      val = (val - vec[idx]) / x;
+    enterId = this->thesolver->id(idx);
+    val = (max * x > 0) ? upp[idx] : low[idx];
+    val = (val - vec[idx]) / x;
 
-      if(upp[idx] == low[idx])
-      {
-         val = 0.0;
+    if (upp[idx] == low[idx]) {
+      val = 0.0;
 
-         if(vec[idx] > upp[idx])
-            this->thesolver->theShift += vec[idx] - upp[idx];
-         else
-            this->thesolver->theShift += low[idx] - vec[idx];
+      if (vec[idx] > upp[idx])
+        this->thesolver->theShift += vec[idx] - upp[idx];
+      else
+        this->thesolver->theShift += low[idx] - vec[idx];
 
-         this->thesolver->upBound()[idx] = this->thesolver->lpBound()[idx] = vec[idx];
-      }
-      else if((max > 0 && val < -degeneps) || (max < 0 && val > degeneps))
-      {
-         val = 0.0;
-
-         if(max * x > 0)
-            this->thesolver->shiftUPbound(idx, vec[idx]);
-         else
-            this->thesolver->shiftLPbound(idx, vec[idx]);
-      }
-   }
-   else // src == COPVEC
-   {
-      R x = upd[idx];
-
-      if(spxAbs(x) < stab)
-      {
-         return false;
-      }
+      this->thesolver->upBound()[idx] = this->thesolver->lpBound()[idx] =
+          vec[idx];
+    } else if ((max > 0 && val < -degeneps) || (max < 0 && val > degeneps)) {
+      val = 0.0;
 
-      enterId = this->thesolver->coId(idx);
-      val = (max * x > 0.0) ? upp[idx] : low[idx];
-      val = (val - vec[idx]) / x;
+      if (max * x > 0)
+        this->thesolver->shiftUPbound(idx, vec[idx]);
+      else
+        this->thesolver->shiftLPbound(idx, vec[idx]);
+    }
+  } else // src == COPVEC
+  {
+    R x = upd[idx];
 
-      if(upp[idx] == low[idx])
-      {
-         val = 0.0;
+    if (spxAbs(x) < stab) {
+      return false;
+    }
 
-         if(vec[idx] > upp[idx])
-            this->thesolver->theShift += vec[idx] - upp[idx];
-         else
-            this->thesolver->theShift += low[idx] - vec[idx];
+    enterId = this->thesolver->coId(idx);
+    val = (max * x > 0.0) ? upp[idx] : low[idx];
+    val = (val - vec[idx]) / x;
 
-         this->thesolver->ucBound()[idx] = this->thesolver->lcBound()[idx] = vec[idx];
-      }
-      else if((max > 0 && val < -degeneps) || (max < 0 && val > degeneps))
-      {
-         val = 0.0;
-
-         if(max * x > 0)
-            this->thesolver->shiftUCbound(idx, vec[idx]);
-         else
-            this->thesolver->shiftLCbound(idx, vec[idx]);
-      }
-   }
+    if (upp[idx] == low[idx]) {
+      val = 0.0;
 
-   return true;
-}
+      if (vec[idx] > upp[idx])
+        this->thesolver->theShift += vec[idx] - upp[idx];
+      else
+        this->thesolver->theShift += low[idx] - vec[idx];
 
-/** get values for leaving index and perform shifts if necessary */
-template <class R>
-bool SPxBoundFlippingRT<R>::getData(
-   R&                 val,
-   int&                  leaveIdx,
-   int                   idx,
-   R                  stab,
-   R                  degeneps,
-   const R*           upd,
-   const R*           vec,
-   const R*           low,
-   const R*           upp,
-   BreakpointSource      src,
-   R                  max
-)
-{
-   assert(src == FVEC);
-
-   R x = upd[idx];
-
-   // skip breakpoint if it is too small
-   if(spxAbs(x) < stab)
-   {
-      return false;
-   }
+      this->thesolver->ucBound()[idx] = this->thesolver->lcBound()[idx] =
+          vec[idx];
+    } else if ((max > 0 && val < -degeneps) || (max < 0 && val > degeneps)) {
+      val = 0.0;
 
-   leaveIdx = idx;
-   val = (max * x > 0) ? upp[idx] : low[idx];
-   val = (val - vec[idx]) / x;
+      if (max * x > 0)
+        this->thesolver->shiftUCbound(idx, vec[idx]);
+      else
+        this->thesolver->shiftLCbound(idx, vec[idx]);
+    }
+  }
 
-   if(upp[idx] == low[idx])
-   {
-      val = 0.0;
-      this->thesolver->shiftLBbound(idx, vec[idx]);
-      this->thesolver->shiftUBbound(idx, vec[idx]);
-   }
-   else if((max > 0 && val < -degeneps) || (max < 0 && val > degeneps))
-   {
-      val = 0.0;
+  return true;
+}
 
-      if(this->thesolver->dualStatus(this->thesolver->baseId(idx)) != SPxBasisBase<R>::Desc::D_ON_BOTH)
-      {
-         if(max * x > 0)
-            this->thesolver->shiftUBbound(idx, vec[idx]);
-         else
-            this->thesolver->shiftLBbound(idx, vec[idx]);
-      }
-   }
+/** get values for leaving index and perform shifts if necessary */
+template <class R>
+bool SPxBoundFlippingRT<R>::getData(R &val, int &leaveIdx, int idx, R stab,
+                                    R degeneps, const R *upd, const R *vec,
+                                    const R *low, const R *upp,
+                                    BreakpointSource src, R max) {
+  assert(src == FVEC);
+
+  R x = upd[idx];
+
+  // skip breakpoint if it is too small
+  if (spxAbs(x) < stab) {
+    return false;
+  }
+
+  leaveIdx = idx;
+  val = (max * x > 0) ? upp[idx] : low[idx];
+  val = (val - vec[idx]) / x;
+
+  if (upp[idx] == low[idx]) {
+    val = 0.0;
+    this->thesolver->shiftLBbound(idx, vec[idx]);
+    this->thesolver->shiftUBbound(idx, vec[idx]);
+  } else if ((max > 0 && val < -degeneps) || (max < 0 && val > degeneps)) {
+    val = 0.0;
+
+    if (this->thesolver->dualStatus(this->thesolver->baseId(idx)) !=
+        SPxBasisBase<R>::Desc::D_ON_BOTH) {
+      if (max * x > 0)
+        this->thesolver->shiftUBbound(idx, vec[idx]);
+      else
+        this->thesolver->shiftLBbound(idx, vec[idx]);
+    }
+  }
 
-   return true;
+  return true;
 }
 
 /** determine entering row/column */
 template <class R>
-SPxId SPxBoundFlippingRT<R>::selectEnter(
-   R&                 val,
-   int                   leaveIdx,
-   bool                  polish
-)
-{
-   assert(this->m_type == SPxSolverBase<R>::LEAVE);
-   assert(this->thesolver->boundflips == 0);
-
-   // reset the history and try again to do some long steps
-   if(this->thesolver->leaveCount % LONGSTEP_FREQ == 0)
-   {
-      MSG_DEBUG(std::cout << "DLBFRT06 resetting long step history" << std::endl;)
-      flipPotential = 1;
-   }
-
-   if(!enableBoundFlips || polish || this->thesolver->rep() == SPxSolverBase<R>::ROW
-         || flipPotential <= 0)
-   {
-      MSG_DEBUG(std::cout << "DLBFRT07 switching to fast ratio test" << std::endl;)
-      return SPxFastRT<R>::selectEnter(val, leaveIdx, polish);
-   }
-
-   const R*  pvec = this->thesolver->pVec().get_const_ptr();
-   const R*  pupd = this->thesolver->pVec().delta().values();
-   const int*   pidx = this->thesolver->pVec().delta().indexMem();
-   int          pupdnnz = this->thesolver->pVec().delta().size();
-   const R*  lpb  = this->thesolver->lpBound().get_const_ptr();
-   const R*  upb  = this->thesolver->upBound().get_const_ptr();
-
-   const R*  cvec = this->thesolver->coPvec().get_const_ptr();
-   const R*  cupd = this->thesolver->coPvec().delta().values();
-   const int*   cidx = this->thesolver->coPvec().delta().indexMem();
-   int          cupdnnz = this->thesolver->coPvec().delta().size();
-   const R*  lcb  = this->thesolver->lcBound().get_const_ptr();
-   const R*  ucb  = this->thesolver->ucBound().get_const_ptr();
-
-   this->resetTols();
-
-   R max;
-
-   // index in breakpoint array of minimal value (i.e. choice of normal RT)
-   int minIdx;
-
-   // temporary breakpoint data structure to make swaps possible
-   Breakpoint tmp;
-
-   // most stable pivot value in candidate set
-   R moststable;
-
-   // initialize invalid enterId
-   SPxId enterId;
-
-   // slope of objective function improvement
-   R slope;
-
-   // number of found breakpoints
-   int nBp;
-
-   // number of passed breakpoints
-   int npassedBp;
-
-   R degeneps;
-   R stab;
-   bool instable;
-
-   max = val;
-   val = 0.0;
-   moststable = 0.0;
-   nBp = 0;
-   minIdx = -1;
-
-   // get breakpoints and and determine the index of the minimal value
-   if(max > 0)
-   {
-      collectBreakpointsMax(nBp, minIdx, pidx, pupdnnz, pupd, pvec, upb, lpb, PVEC);
-      // coverity[negative_returns]
-      collectBreakpointsMax(nBp, minIdx, cidx, cupdnnz, cupd, cvec, ucb, lcb, COPVEC);
-   }
-   else
-   {
-      collectBreakpointsMin(nBp, minIdx, pidx, pupdnnz, pupd, pvec, upb, lpb, PVEC);
-      // coverity[negative_returns]
-      collectBreakpointsMin(nBp, minIdx, cidx, cupdnnz, cupd, cvec, ucb, lcb, COPVEC);
-   }
-
-   if(nBp == 0)
-   {
-      val = max;
-      return enterId;
-   }
-
-   assert(minIdx >= 0);
-
-   // swap smallest breakpoint to the front to skip the sorting phase if no bound flip is possible
-   tmp = breakpoints[minIdx];
-   breakpoints[minIdx] = breakpoints[0];
-   breakpoints[0] = tmp;
-
-   // get initial slope
-   slope = spxAbs(this->thesolver->fTest()[leaveIdx]);
-
-   if(slope == 0)
-   {
-      // this may only happen if SoPlex decides to make an instable pivot
-      assert(this->thesolver->instableLeaveNum >= 0);
-      // restore original slope
-      slope = spxAbs(this->thesolver->instableLeaveVal);
-   }
-
-   // set up structures for the quicksort implementation
-   BreakpointCompare compare;
-   compare.entry = breakpoints.get_const_ptr();
-
-   // pointer to end of sorted part of breakpoints
-   int sorted = 0;
-   // minimum number of entries that are supposed to be sorted by partial sort
-   int sortsize = 4;
-
-   // get all skipable breakpoints
-   for(npassedBp = 0; npassedBp < nBp && slope > 0; ++npassedBp)
-   {
-      // sort breakpoints only partially to save time
-      if(npassedBp > sorted)
-      {
-         sorted = SPxQuicksortPart(breakpoints.get_ptr(), compare, sorted + 1, nBp, sortsize);
+SPxId SPxBoundFlippingRT<R>::selectEnter(R &val, int leaveIdx, bool polish) {
+  assert(this->m_type == SPxSolverBase<R>::LEAVE);
+  assert(this->thesolver->boundflips == 0);
+
+  // reset the history and try again to do some long steps
+  if (this->thesolver->leaveCount % LONGSTEP_FREQ == 0) {
+    MSG_DEBUG(std::cout << "DLBFRT06 resetting long step history" << std::endl;)
+    flipPotential = 1;
+  }
+
+  if (!enableBoundFlips || polish ||
+      this->thesolver->rep() == SPxSolverBase<R>::ROW || flipPotential <= 0) {
+    MSG_DEBUG(std::cout << "DLBFRT07 switching to fast ratio test"
+                        << std::endl;)
+    return SPxFastRT<R>::selectEnter(val, leaveIdx, polish);
+  }
+
+  const R *pvec = this->thesolver->pVec().get_const_ptr();
+  const R *pupd = this->thesolver->pVec().delta().values();
+  const int *pidx = this->thesolver->pVec().delta().indexMem();
+  int pupdnnz = this->thesolver->pVec().delta().size();
+  const R *lpb = this->thesolver->lpBound().get_const_ptr();
+  const R *upb = this->thesolver->upBound().get_const_ptr();
+
+  const R *cvec = this->thesolver->coPvec().get_const_ptr();
+  const R *cupd = this->thesolver->coPvec().delta().values();
+  const int *cidx = this->thesolver->coPvec().delta().indexMem();
+  int cupdnnz = this->thesolver->coPvec().delta().size();
+  const R *lcb = this->thesolver->lcBound().get_const_ptr();
+  const R *ucb = this->thesolver->ucBound().get_const_ptr();
+
+  this->resetTols();
+
+  R max;
+
+  // index in breakpoint array of minimal value (i.e. choice of normal RT)
+  int minIdx;
+
+  // temporary breakpoint data structure to make swaps possible
+  Breakpoint tmp;
+
+  // most stable pivot value in candidate set
+  R moststable;
+
+  // initialize invalid enterId
+  SPxId enterId;
+
+  // slope of objective function improvement
+  R slope;
+
+  // number of found breakpoints
+  int nBp;
+
+  // number of passed breakpoints
+  int npassedBp;
+
+  R degeneps;
+  R stab;
+  bool instable;
+
+  max = val;
+  val = 0.0;
+  moststable = 0.0;
+  nBp = 0;
+  minIdx = -1;
+
+  // get breakpoints and and determine the index of the minimal value
+  if (max > 0) {
+    collectBreakpointsMax(nBp, minIdx, pidx, pupdnnz, pupd, pvec, upb, lpb,
+                          PVEC);
+    // coverity[negative_returns]
+    collectBreakpointsMax(nBp, minIdx, cidx, cupdnnz, cupd, cvec, ucb, lcb,
+                          COPVEC);
+  } else {
+    collectBreakpointsMin(nBp, minIdx, pidx, pupdnnz, pupd, pvec, upb, lpb,
+                          PVEC);
+    // coverity[negative_returns]
+    collectBreakpointsMin(nBp, minIdx, cidx, cupdnnz, cupd, cvec, ucb, lcb,
+                          COPVEC);
+  }
+
+  if (nBp == 0) {
+    val = max;
+    return enterId;
+  }
+
+  assert(minIdx >= 0);
+
+  // swap smallest breakpoint to the front to skip the sorting phase if no bound
+  // flip is possible
+  tmp = breakpoints[minIdx];
+  breakpoints[minIdx] = breakpoints[0];
+  breakpoints[0] = tmp;
+
+  // get initial slope
+  slope = spxAbs(this->thesolver->fTest()[leaveIdx]);
+
+  if (slope == 0) {
+    // this may only happen if SoPlex decides to make an instable pivot
+    assert(this->thesolver->instableLeaveNum >= 0);
+    // restore original slope
+    slope = spxAbs(this->thesolver->instableLeaveVal);
+  }
+
+  // set up structures for the quicksort implementation
+  BreakpointCompare compare;
+  compare.entry = breakpoints.get_const_ptr();
+
+  // pointer to end of sorted part of breakpoints
+  int sorted = 0;
+  // minimum number of entries that are supposed to be sorted by partial sort
+  int sortsize = 4;
+
+  // get all skipable breakpoints
+  for (npassedBp = 0; npassedBp < nBp && slope > 0; ++npassedBp) {
+    // sort breakpoints only partially to save time
+    if (npassedBp > sorted) {
+      sorted = SPxQuicksortPart(breakpoints.get_ptr(), compare, sorted + 1, nBp,
+                                sortsize);
+    }
+
+    int i = breakpoints[npassedBp].idx;
+
+    // compute new slope
+    if (breakpoints[npassedBp].src == PVEC) {
+      if (this->thesolver->isBasic(i)) {
+        // mark basic indices
+        breakpoints[npassedBp].idx = -1;
+        this->thesolver->pVec().delta().clearIdx(i);
+      } else {
+        R absupd = spxAbs(pupd[i]);
+        slope -= (this->thesolver->upper(i) * absupd) -
+                 (this->thesolver->lower(i) * absupd);
+
+        // get most stable pivot
+        if (absupd > moststable)
+          moststable = absupd;
       }
-
-      int i = breakpoints[npassedBp].idx;
-
-      // compute new slope
-      if(breakpoints[npassedBp].src == PVEC)
-      {
-         if(this->thesolver->isBasic(i))
-         {
-            // mark basic indices
-            breakpoints[npassedBp].idx = -1;
-            this->thesolver->pVec().delta().clearIdx(i);
-         }
-         else
-         {
-            R absupd = spxAbs(pupd[i]);
-            slope -= (this->thesolver->upper(i) * absupd) - (this->thesolver->lower(i) * absupd);
-
-            // get most stable pivot
-            if(absupd > moststable)
-               moststable = absupd;
-         }
+    } else {
+      assert(breakpoints[npassedBp].src == COPVEC);
+
+      if (this->thesolver->isCoBasic(i)) {
+        // mark basic indices
+        breakpoints[npassedBp].idx = -1;
+        this->thesolver->coPvec().delta().clearIdx(i);
+      } else {
+        R absupd = spxAbs(cupd[i]);
+        slope -= (this->thesolver->rhs(i) * absupd) -
+                 (this->thesolver->lhs(i) * absupd);
+
+        if (absupd > moststable)
+          moststable = absupd;
       }
-      else
-      {
-         assert(breakpoints[npassedBp].src == COPVEC);
-
-         if(this->thesolver->isCoBasic(i))
-         {
-            // mark basic indices
-            breakpoints[npassedBp].idx = -1;
-            this->thesolver->coPvec().delta().clearIdx(i);
-         }
-         else
-         {
-            R absupd = spxAbs(cupd[i]);
-            slope -= (this->thesolver->rhs(i) * absupd) - (this->thesolver->lhs(i) * absupd);
-
-            if(absupd > moststable)
-               moststable = absupd;
-         }
+    }
+  }
+
+  --npassedBp;
+  assert(npassedBp >= 0);
+
+  // check for unboundedness/infeasibility
+  if (slope > this->delta && npassedBp >= nBp - 1) {
+    MSG_DEBUG(std::cout << "DLBFRT02 " << this->thesolver->basis().iteration()
+                        << ": unboundedness in ratio test" << std::endl;)
+    flipPotential -= 0.5;
+    val = max;
+    return SPxFastRT<R>::selectEnter(val, leaveIdx);
+  }
+
+  MSG_DEBUG(std::cout << "DLBFRT01 " << this->thesolver->basis().iteration()
+                      << ": number of flip candidates: " << npassedBp
+                      << std::endl;)
+
+  // try to get a more stable pivot by looking at those with similar step length
+  int stableBp;    // index to walk over additional breakpoints (after slope
+                   // change)
+  int bestBp = -1; // breakpoints index with best possible stability
+  R bestDelta =
+      breakpoints[npassedBp].val; // best step length (after bound flips)
+
+  for (stableBp = npassedBp + 1; stableBp < nBp; ++stableBp) {
+    R stableDelta = 0;
+
+    // get next breakpoints in increasing order
+    if (stableBp > sorted) {
+      sorted = SPxQuicksortPart(breakpoints.get_ptr(), compare, sorted + 1, nBp,
+                                sortsize);
+    }
+
+    int idx = breakpoints[stableBp].idx;
+
+    if (breakpoints[stableBp].src == PVEC) {
+      if (this->thesolver->isBasic(idx)) {
+        // mark basic indices
+        breakpoints[stableBp].idx = -1;
+        this->thesolver->pVec().delta().clearIdx(idx);
+        continue;
       }
-   }
 
-   --npassedBp;
-   assert(npassedBp >= 0);
+      R x = pupd[idx];
 
-   // check for unboundedness/infeasibility
-   if(slope > this->delta && npassedBp >= nBp - 1)
-   {
-      MSG_DEBUG(std::cout << "DLBFRT02 " << this->thesolver->basis().iteration()
-                << ": unboundedness in ratio test" << std::endl;)
-      flipPotential -= 0.5;
-      val = max;
-      return SPxFastRT<R>::selectEnter(val, leaveIdx);
-   }
-
-   MSG_DEBUG(std::cout << "DLBFRT01 "
-             << this->thesolver->basis().iteration()
-             << ": number of flip candidates: "
-             << npassedBp
-             << std::endl;)
-
-   // try to get a more stable pivot by looking at those with similar step length
-   int stableBp;              // index to walk over additional breakpoints (after slope change)
-   int bestBp = -1;           // breakpoints index with best possible stability
-   R bestDelta = breakpoints[npassedBp].val;  // best step length (after bound flips)
-
-   for(stableBp = npassedBp + 1; stableBp < nBp; ++stableBp)
-   {
-      R stableDelta = 0;
-
-      // get next breakpoints in increasing order
-      if(stableBp > sorted)
-      {
-         sorted = SPxQuicksortPart(breakpoints.get_ptr(), compare, sorted + 1, nBp, sortsize);
-      }
+      if (spxAbs(x) > moststable) {
+        this->thesolver->pVec()[idx] =
+            this->thesolver->vector(idx) * this->thesolver->coPvec();
+        stableDelta = (x > 0.0) ? upb[idx] : lpb[idx];
+        stableDelta = (stableDelta - pvec[idx]) / x;
 
-      int idx = breakpoints[stableBp].idx;
-
-      if(breakpoints[stableBp].src == PVEC)
-      {
-         if(this->thesolver->isBasic(idx))
-         {
-            // mark basic indices
-            breakpoints[stableBp].idx = -1;
-            this->thesolver->pVec().delta().clearIdx(idx);
-            continue;
-         }
-
-         R x = pupd[idx];
-
-         if(spxAbs(x) > moststable)
-         {
-            this->thesolver->pVec()[idx] = this->thesolver->vector(idx) * this->thesolver->coPvec();
-            stableDelta = (x > 0.0) ? upb[idx] : lpb[idx];
-            stableDelta = (stableDelta - pvec[idx]) / x;
-
-            if(stableDelta <= bestDelta)
-            {
-               moststable = spxAbs(x);
-               bestBp = stableBp;
-            }
-         }
+        if (stableDelta <= bestDelta) {
+          moststable = spxAbs(x);
+          bestBp = stableBp;
+        }
       }
-      else
-      {
-         if(this->thesolver->isCoBasic(idx))
-         {
-            // mark basic indices
-            breakpoints[stableBp].idx = -1;
-            this->thesolver->coPvec().delta().clearIdx(idx);
-            continue;
-         }
-
-         R x = cupd[idx];
-
-         if(spxAbs(x) > moststable)
-         {
-            stableDelta = (x > 0.0) ? ucb[idx] : lcb[idx];
-            stableDelta = (stableDelta - cvec[idx]) / x;
-
-            if(stableDelta <= bestDelta)
-            {
-               moststable = spxAbs(x);
-               bestBp = stableBp;
-            }
-         }
+    } else {
+      if (this->thesolver->isCoBasic(idx)) {
+        // mark basic indices
+        breakpoints[stableBp].idx = -1;
+        this->thesolver->coPvec().delta().clearIdx(idx);
+        continue;
       }
 
-      // stop searching if the step length is too big
-      if(stableDelta > this->delta + bestDelta)
-         break;
-   }
-
-   degeneps = this->fastDelta / moststable;  /* as in SPxFastRT */
-   // get stability requirements
-   instable = this->thesolver->instableLeave;
-   assert(!instable || this->thesolver->instableLeaveNum >= 0);
-   stab = instable ? LOWSTAB : SPxFastRT<R>::minStability(moststable);
-
-   bool foundStable = false;
-
-   if(bestBp >= 0)
-   {
-      // found a more stable pivot
-      if(moststable > stab)
-      {
-         // stability requirements are satisfied
-         int idx = breakpoints[bestBp].idx;
-         assert(idx >= 0);
-
-         if(breakpoints[bestBp].src == PVEC)
-            foundStable = getData(val, enterId, idx, stab, degeneps, pupd, pvec, lpb, upb, PVEC, max);
-         else
-            foundStable = getData(val, enterId, idx, stab, degeneps, cupd, cvec, lcb, ucb, COPVEC, max);
-      }
-   }
-
-   else
-   {
-      // scan passed breakpoints from back to front and stop as soon as a good one is found
-      while(!foundStable && npassedBp >= 0)
-      {
-         int idx = breakpoints[npassedBp].idx;
-
-         // only look for non-basic variables
-         if(idx >= 0)
-         {
-            if(breakpoints[npassedBp].src == PVEC)
-               foundStable = getData(val, enterId, idx, stab, degeneps, pupd, pvec, lpb, upb, PVEC, max);
-            else
-               foundStable = getData(val, enterId, idx, stab, degeneps, cupd, cvec, lcb, ucb, COPVEC, max);
-         }
-
-         --npassedBp;
-      }
+      R x = cupd[idx];
+
+      if (spxAbs(x) > moststable) {
+        stableDelta = (x > 0.0) ? ucb[idx] : lcb[idx];
+        stableDelta = (stableDelta - cvec[idx]) / x;
 
-      ++npassedBp;
-   }
-
-   if(!foundStable)
-   {
-      assert(!enterId.isValid());
-
-      if(relax_count < MAX_RELAX_COUNT)
-      {
-         MSG_DEBUG(std::cout << "DLBFRT04 "
-                   << this->thesolver->basis().iteration()
-                   << ": no valid enterId found - relaxing..."
-                   << std::endl;)
-         this->relax();
-         ++relax_count;
-         // restore original value
-         val = max;
-         // try again with relaxed delta
-         return SPxBoundFlippingRT<R>::selectEnter(val, leaveIdx);
+        if (stableDelta <= bestDelta) {
+          moststable = spxAbs(x);
+          bestBp = stableBp;
+        }
       }
+    }
+
+    // stop searching if the step length is too big
+    if (stableDelta > this->delta + bestDelta)
+      break;
+  }
+
+  degeneps = this->fastDelta / moststable; /* as in SPxFastRT */
+  // get stability requirements
+  instable = this->thesolver->instableLeave;
+  assert(!instable || this->thesolver->instableLeaveNum >= 0);
+  stab = instable ? LOWSTAB : SPxFastRT<R>::minStability(moststable);
+
+  bool foundStable = false;
+
+  if (bestBp >= 0) {
+    // found a more stable pivot
+    if (moststable > stab) {
+      // stability requirements are satisfied
+      int idx = breakpoints[bestBp].idx;
+      assert(idx >= 0);
+
+      if (breakpoints[bestBp].src == PVEC)
+        foundStable = getData(val, enterId, idx, stab, degeneps, pupd, pvec,
+                              lpb, upb, PVEC, max);
       else
-      {
-         MSG_DEBUG(std::cout << "DLBFRT05 "
-                   << this->thesolver->basis().iteration()
-                   << " no valid enterId found - breaking..."
-                   << std::endl;)
-         return enterId;
+        foundStable = getData(val, enterId, idx, stab, degeneps, cupd, cvec,
+                              lcb, ucb, COPVEC, max);
+    }
+  }
+
+  else {
+    // scan passed breakpoints from back to front and stop as soon as a good one
+    // is found
+    while (!foundStable && npassedBp >= 0) {
+      int idx = breakpoints[npassedBp].idx;
+
+      // only look for non-basic variables
+      if (idx >= 0) {
+        if (breakpoints[npassedBp].src == PVEC)
+          foundStable = getData(val, enterId, idx, stab, degeneps, pupd, pvec,
+                                lpb, upb, PVEC, max);
+        else
+          foundStable = getData(val, enterId, idx, stab, degeneps, cupd, cvec,
+                                lcb, ucb, COPVEC, max);
       }
-   }
-   else
-   {
-      relax_count = 0;
-      this->tighten();
-   }
-
-   // flip bounds of skipped breakpoints only if a nondegenerate step is to be performed
-   if(npassedBp > 0 && spxAbs(breakpoints[npassedBp].val) > this->fastDelta)
-   {
-      flipAndUpdate(npassedBp);
-      this->thesolver->boundflips = npassedBp;
-
-      if(npassedBp >= 10)
-         flipPotential = 1;
-      else
-         flipPotential -= 0.05;
-   }
-   else
-   {
-      this->thesolver->boundflips = 0;
-      flipPotential -= 0.1;
-   }
-
-   MSG_DEBUG(std::cout << "DLBFRT06 "
-             << this->thesolver->basis().iteration()
-             << ": selected Id: "
-             << enterId
-             << " number of candidates: "
-             << nBp
-             << std::endl;)
-   return enterId;
+
+      --npassedBp;
+    }
+
+    ++npassedBp;
+  }
+
+  if (!foundStable) {
+    assert(!enterId.isValid());
+
+    if (relax_count < MAX_RELAX_COUNT) {
+      MSG_DEBUG(std::cout << "DLBFRT04 " << this->thesolver->basis().iteration()
+                          << ": no valid enterId found - relaxing..."
+                          << std::endl;)
+      this->relax();
+      ++relax_count;
+      // restore original value
+      val = max;
+      // try again with relaxed delta
+      return SPxBoundFlippingRT<R>::selectEnter(val, leaveIdx);
+    } else {
+      MSG_DEBUG(std::cout << "DLBFRT05 " << this->thesolver->basis().iteration()
+                          << " no valid enterId found - breaking..."
+                          << std::endl;)
+      return enterId;
+    }
+  } else {
+    relax_count = 0;
+    this->tighten();
+  }
+
+  // flip bounds of skipped breakpoints only if a nondegenerate step is to be
+  // performed
+  if (npassedBp > 0 && spxAbs(breakpoints[npassedBp].val) > this->fastDelta) {
+    flipAndUpdate(npassedBp);
+    this->thesolver->boundflips = npassedBp;
+
+    if (npassedBp >= 10)
+      flipPotential = 1;
+    else
+      flipPotential -= 0.05;
+  } else {
+    this->thesolver->boundflips = 0;
+    flipPotential -= 0.1;
+  }
+
+  MSG_DEBUG(std::cout << "DLBFRT06 " << this->thesolver->basis().iteration()
+                      << ": selected Id: " << enterId
+                      << " number of candidates: " << nBp << std::endl;)
+  return enterId;
 }
 
 /** determine leaving row/column */
 template <class R>
-int SPxBoundFlippingRT<R>::selectLeave(
-   R&                 val,
-   R                  enterTest,
-   bool                  polish
-)
-{
-   assert(this->m_type == SPxSolverBase<R>::ENTER);
-   assert(this->thesolver->boundflips == 0);
-
-   // reset the history and try again to do some long steps
-   if(this->thesolver->enterCount % LONGSTEP_FREQ == 0)
-   {
-      MSG_DEBUG(std::cout << "DEBFRT06 resetting long step history" << std::endl;)
-      flipPotential = 1;
-   }
-
-   if(polish || !enableBoundFlips || !enableRowBoundFlips
-         || this->thesolver->rep() == SPxSolverBase<R>::COLUMN || flipPotential <= 0)
-   {
-      MSG_DEBUG(std::cout << "DEBFRT07 switching to fast ratio test" << std::endl;)
-      return SPxFastRT<R>::selectLeave(val, enterTest, polish);
-   }
-
-   const R*  vec =
-      this->thesolver->fVec().get_const_ptr();         /**< pointer to values of current VectorBase<R> */
-   const R*  upd =
-      this->thesolver->fVec().delta().values();        /**< pointer to update values of current VectorBase<R> */
-   const int*   idx =
-      this->thesolver->fVec().delta().indexMem();      /**< pointer to indices of current VectorBase<R> */
-   int          updnnz =
-      this->thesolver->fVec().delta().size();       /**< number of nonzeros in update VectorBase<R> */
-   const R*  lb  =
-      this->thesolver->lbBound().get_const_ptr();      /**< pointer to lower bound/lhs of current VectorBase<R> */
-   const R*  ub  =
-      this->thesolver->ubBound().get_const_ptr();      /**< pointer to upper bound/rhs of current VectorBase<R> */
-
-   this->resetTols();
-
-   R max;
-
-   // index in breakpoint array of minimal value (i.e. choice of normal RT)
-   int minIdx;
-
-   // temporary breakpoint data structure to make swaps possible
-   Breakpoint tmp;
-
-   // most stable pivot value in candidate set
-   R moststable;
-
-   // initialize invalid leaving index
-   int leaveIdx = -1;
-
-   // slope of objective function improvement
-   R slope;
-
-   // number of found breakpoints
-   int nBp;
-
-   // number of passed breakpoints
-   int npassedBp;
-
-   R degeneps;
-   R stab;
-   bool instable;
-
-   max = val;
-   val = 0.0;
-   moststable = 0.0;
-   nBp = 0;
-   minIdx = -1;
-
-   assert(this->thesolver->fVec().delta().isSetup());
-
-   // get breakpoints and and determine the index of the minimal value
-   if(max > 0)
-   {
-      collectBreakpointsMax(nBp, minIdx, idx, updnnz, upd, vec, ub, lb, FVEC);
-   }
-   else
-   {
-      collectBreakpointsMin(nBp, minIdx, idx, updnnz, upd, vec, ub, lb, FVEC);
-   }
-
-   // return -1 if no BP was found
-   if(nBp == 0)
-   {
-      val = max;
-      return leaveIdx;
-   }
-
-   assert(minIdx >= 0);
-
-   // swap smallest breakpoint to the front to skip the sorting phase if no bound flip is possible
-   tmp = breakpoints[minIdx];
-   breakpoints[minIdx] = breakpoints[0];
-   breakpoints[0] = tmp;
-
-   // get initial slope
-   slope = spxAbs(enterTest);
-
-   if(slope == 0)
-   {
-      // this may only happen if SoPlex decides to make an instable pivot
-      assert(this->thesolver->instableEnterId.isValid());
-      // restore original slope
-      slope = this->thesolver->instableEnterVal;
-   }
-
-   // set up structures for the quicksort implementation
-   BreakpointCompare compare;
-   compare.entry = breakpoints.get_const_ptr();
-
-   // pointer to end of sorted part of breakpoints
-   int sorted = 0;
-   // minimum number of entries that are supposed to be sorted by partial sort
-   int sortsize = 4;
-
-   // get all skipable breakpoints
-   for(npassedBp = 0; npassedBp < nBp && slope > 0; ++npassedBp)
-   {
-      // sort breakpoints only partially to save time
-      if(npassedBp > sorted)
-      {
-         sorted = SPxQuicksortPart(breakpoints.get_ptr(), compare, sorted + 1, nBp, sortsize);
+int SPxBoundFlippingRT<R>::selectLeave(R &val, R enterTest, bool polish) {
+  assert(this->m_type == SPxSolverBase<R>::ENTER);
+  assert(this->thesolver->boundflips == 0);
+
+  // reset the history and try again to do some long steps
+  if (this->thesolver->enterCount % LONGSTEP_FREQ == 0) {
+    MSG_DEBUG(std::cout << "DEBFRT06 resetting long step history" << std::endl;)
+    flipPotential = 1;
+  }
+
+  if (polish || !enableBoundFlips || !enableRowBoundFlips ||
+      this->thesolver->rep() == SPxSolverBase<R>::COLUMN ||
+      flipPotential <= 0) {
+    MSG_DEBUG(std::cout << "DEBFRT07 switching to fast ratio test"
+                        << std::endl;)
+    return SPxFastRT<R>::selectLeave(val, enterTest, polish);
+  }
+
+  const R *vec =
+      this->thesolver->fVec()
+          .get_const_ptr(); /**< pointer to values of current VectorBase<R> */
+  const R *upd =
+      this->thesolver->fVec()
+          .delta()
+          .values(); /**< pointer to update values of current VectorBase<R> */
+  const int *idx =
+      this->thesolver->fVec()
+          .delta()
+          .indexMem(); /**< pointer to indices of current VectorBase<R> */
+  int updnnz = this->thesolver->fVec()
+                   .delta()
+                   .size(); /**< number of nonzeros in update VectorBase<R> */
+  const R *lb = this->thesolver->lbBound()
+                    .get_const_ptr(); /**< pointer to lower bound/lhs of current
+                                         VectorBase<R> */
+  const R *ub = this->thesolver->ubBound()
+                    .get_const_ptr(); /**< pointer to upper bound/rhs of current
+                                         VectorBase<R> */
+
+  this->resetTols();
+
+  R max;
+
+  // index in breakpoint array of minimal value (i.e. choice of normal RT)
+  int minIdx;
+
+  // temporary breakpoint data structure to make swaps possible
+  Breakpoint tmp;
+
+  // most stable pivot value in candidate set
+  R moststable;
+
+  // initialize invalid leaving index
+  int leaveIdx = -1;
+
+  // slope of objective function improvement
+  R slope;
+
+  // number of found breakpoints
+  int nBp;
+
+  // number of passed breakpoints
+  int npassedBp;
+
+  R degeneps;
+  R stab;
+  bool instable;
+
+  max = val;
+  val = 0.0;
+  moststable = 0.0;
+  nBp = 0;
+  minIdx = -1;
+
+  assert(this->thesolver->fVec().delta().isSetup());
+
+  // get breakpoints and and determine the index of the minimal value
+  if (max > 0) {
+    collectBreakpointsMax(nBp, minIdx, idx, updnnz, upd, vec, ub, lb, FVEC);
+  } else {
+    collectBreakpointsMin(nBp, minIdx, idx, updnnz, upd, vec, ub, lb, FVEC);
+  }
+
+  // return -1 if no BP was found
+  if (nBp == 0) {
+    val = max;
+    return leaveIdx;
+  }
+
+  assert(minIdx >= 0);
+
+  // swap smallest breakpoint to the front to skip the sorting phase if no bound
+  // flip is possible
+  tmp = breakpoints[minIdx];
+  breakpoints[minIdx] = breakpoints[0];
+  breakpoints[0] = tmp;
+
+  // get initial slope
+  slope = spxAbs(enterTest);
+
+  if (slope == 0) {
+    // this may only happen if SoPlex decides to make an instable pivot
+    assert(this->thesolver->instableEnterId.isValid());
+    // restore original slope
+    slope = this->thesolver->instableEnterVal;
+  }
+
+  // set up structures for the quicksort implementation
+  BreakpointCompare compare;
+  compare.entry = breakpoints.get_const_ptr();
+
+  // pointer to end of sorted part of breakpoints
+  int sorted = 0;
+  // minimum number of entries that are supposed to be sorted by partial sort
+  int sortsize = 4;
+
+  // get all skipable breakpoints
+  for (npassedBp = 0; npassedBp < nBp && slope > 0; ++npassedBp) {
+    // sort breakpoints only partially to save time
+    if (npassedBp > sorted) {
+      sorted = SPxQuicksortPart(breakpoints.get_ptr(), compare, sorted + 1, nBp,
+                                sortsize);
+    }
+
+    assert(breakpoints[npassedBp].src == FVEC);
+    int breakpointidx = breakpoints[npassedBp].idx;
+    // compute new slope
+    R upper;
+    R lower;
+    R absupd = spxAbs(upd[breakpointidx]);
+    SPxId baseId = this->thesolver->baseId(breakpointidx);
+    int i = this->thesolver->number(baseId);
+
+    if (baseId.isSPxColId()) {
+      upper = this->thesolver->upper(i);
+      lower = this->thesolver->lower(i);
+    } else {
+      assert(baseId.isSPxRowId());
+      upper = this->thesolver->rhs(i);
+      lower = this->thesolver->lhs(i);
+    }
+
+    slope -= (upper * absupd) - (lower * absupd);
+
+    // get most stable pivot
+    if (absupd > moststable)
+      moststable = absupd;
+  }
+
+  --npassedBp;
+  assert(npassedBp >= 0);
+
+  // check for unboundedness/infeasibility
+  if (slope > this->delta && npassedBp >= nBp - 1) {
+    MSG_DEBUG(std::cout << "DEBFRT02 " << this->thesolver->basis().iteration()
+                        << ": unboundedness in ratio test" << std::endl;)
+    flipPotential -= 0.5;
+    val = max;
+    return SPxFastRT<R>::selectLeave(val, enterTest);
+  }
+
+  MSG_DEBUG(std::cout << "DEBFRT01 " << this->thesolver->basis().iteration()
+                      << ": number of flip candidates: " << npassedBp
+                      << std::endl;)
+
+  // try to get a more stable pivot by looking at those with similar step length
+  int stableBp;    // index to walk over additional breakpoints (after slope
+                   // change)
+  int bestBp = -1; // breakpoints index with best possible stability
+  R bestDelta =
+      breakpoints[npassedBp].val; // best step length (after bound flips)
+
+  for (stableBp = npassedBp + 1; stableBp < nBp; ++stableBp) {
+    R stableDelta = 0;
+
+    // get next breakpoints in increasing order
+    if (stableBp > sorted) {
+      sorted = SPxQuicksortPart(breakpoints.get_ptr(), compare, sorted + 1, nBp,
+                                sortsize);
+    }
+
+    int breakpointidx = breakpoints[stableBp].idx;
+    assert(breakpoints[stableBp].src == FVEC);
+    R x = upd[breakpointidx];
+
+    if (spxAbs(x) > moststable) {
+      stableDelta = (x > 0.0) ? ub[breakpointidx] : lb[breakpointidx];
+      stableDelta = (stableDelta - vec[breakpointidx]) / x;
+
+      if (stableDelta <= bestDelta) {
+        moststable = spxAbs(x);
+        bestBp = stableBp;
       }
-
-      assert(breakpoints[npassedBp].src == FVEC);
+    }
+    // stop searching if the step length is too big
+    else if (stableDelta > this->delta + bestDelta)
+      break;
+  }
+
+  degeneps = this->fastDelta / moststable; /* as in SPxFastRT */
+  // get stability requirements
+  instable = this->thesolver->instableEnter;
+  assert(!instable || this->thesolver->instableEnterId.isValid());
+  stab = instable ? LOWSTAB : SPxFastRT<R>::minStability(moststable);
+
+  bool foundStable = false;
+
+  if (bestBp >= 0) {
+    // found a more stable pivot
+    if (moststable > stab) {
+      // stability requirements are satisfied
+      int breakpointidx = breakpoints[bestBp].idx;
+      assert(breakpointidx >= 0);
+      foundStable = getData(val, leaveIdx, breakpointidx, moststable, degeneps,
+                            upd, vec, lb, ub, FVEC, max);
+    }
+  }
+
+  else {
+    // scan passed breakpoints from back to front and stop as soon as a good one
+    // is found
+    while (!foundStable && npassedBp >= 0) {
       int breakpointidx = breakpoints[npassedBp].idx;
-      // compute new slope
-      R upper;
-      R lower;
-      R absupd = spxAbs(upd[breakpointidx]);
-      SPxId baseId = this->thesolver->baseId(breakpointidx);
-      int i = this->thesolver->number(baseId);
-
-      if(baseId.isSPxColId())
-      {
-         upper = this->thesolver->upper(i);
-         lower = this->thesolver->lower(i);
-      }
-      else
-      {
-         assert(baseId.isSPxRowId());
-         upper = this->thesolver->rhs(i);
-         lower = this->thesolver->lhs(i);
-      }
-
-      slope -= (upper * absupd) - (lower * absupd);
-
-      // get most stable pivot
-      if(absupd > moststable)
-         moststable = absupd;
-   }
 
-   --npassedBp;
-   assert(npassedBp >= 0);
-
-   // check for unboundedness/infeasibility
-   if(slope > this->delta && npassedBp >= nBp - 1)
-   {
-      MSG_DEBUG(std::cout << "DEBFRT02 " << this->thesolver->basis().iteration()
-                << ": unboundedness in ratio test" << std::endl;)
-      flipPotential -= 0.5;
-      val = max;
-      return SPxFastRT<R>::selectLeave(val, enterTest);
-   }
-
-   MSG_DEBUG(std::cout << "DEBFRT01 "
-             << this->thesolver->basis().iteration()
-             << ": number of flip candidates: "
-             << npassedBp
-             << std::endl;)
-
-   // try to get a more stable pivot by looking at those with similar step length
-   int stableBp;              // index to walk over additional breakpoints (after slope change)
-   int bestBp = -1;           // breakpoints index with best possible stability
-   R bestDelta = breakpoints[npassedBp].val;  // best step length (after bound flips)
-
-   for(stableBp = npassedBp + 1; stableBp < nBp; ++stableBp)
-   {
-      R stableDelta = 0;
-
-      // get next breakpoints in increasing order
-      if(stableBp > sorted)
-      {
-         sorted = SPxQuicksortPart(breakpoints.get_ptr(), compare, sorted + 1, nBp, sortsize);
+      // only look for non-basic variables
+      if (breakpointidx >= 0) {
+        foundStable = getData(val, leaveIdx, breakpointidx, moststable,
+                              degeneps, upd, vec, lb, ub, FVEC, max);
       }
 
-      int breakpointidx = breakpoints[stableBp].idx;
-      assert(breakpoints[stableBp].src == FVEC);
-      R x = upd[breakpointidx];
+      --npassedBp;
+    }
 
-      if(spxAbs(x) > moststable)
-      {
-         stableDelta = (x > 0.0) ? ub[breakpointidx] : lb[breakpointidx];
-         stableDelta = (stableDelta - vec[breakpointidx]) / x;
+    ++npassedBp;
+  }
 
-         if(stableDelta <= bestDelta)
-         {
-            moststable = spxAbs(x);
-            bestBp = stableBp;
-         }
-      }
-      // stop searching if the step length is too big
-      else if(stableDelta > this->delta + bestDelta)
-         break;
-   }
-
-   degeneps = this->fastDelta / moststable;  /* as in SPxFastRT */
-   // get stability requirements
-   instable = this->thesolver->instableEnter;
-   assert(!instable || this->thesolver->instableEnterId.isValid());
-   stab = instable ? LOWSTAB : SPxFastRT<R>::minStability(moststable);
-
-   bool foundStable = false;
-
-   if(bestBp >= 0)
-   {
-      // found a more stable pivot
-      if(moststable > stab)
-      {
-         // stability requirements are satisfied
-         int breakpointidx = breakpoints[bestBp].idx;
-         assert(breakpointidx >= 0);
-         foundStable = getData(val, leaveIdx, breakpointidx, moststable, degeneps, upd, vec, lb, ub, FVEC,
-                               max);
-      }
-   }
-
-   else
-   {
-      // scan passed breakpoints from back to front and stop as soon as a good one is found
-      while(!foundStable && npassedBp >= 0)
-      {
-         int breakpointidx = breakpoints[npassedBp].idx;
-
-         // only look for non-basic variables
-         if(breakpointidx >= 0)
-         {
-            foundStable = getData(val, leaveIdx, breakpointidx, moststable, degeneps, upd, vec, lb, ub, FVEC,
-                                  max);
-         }
-
-         --npassedBp;
-      }
+  if (!foundStable) {
+    assert(leaveIdx < 0);
 
-      ++npassedBp;
-   }
-
-   if(!foundStable)
-   {
-      assert(leaveIdx < 0);
-
-      if(relax_count < MAX_RELAX_COUNT)
-      {
-         MSG_DEBUG(std::cout << "DEBFRT04 "
-                   << this->thesolver->basis().iteration()
-                   << ": no valid leaveIdx found - relaxing..."
-                   << std::endl;)
-         this->relax();
-         ++relax_count;
-         // restore original value
-         val = max;
-         // try again with relaxed delta
-         return SPxBoundFlippingRT<R>::selectLeave(val, enterTest);
-      }
-      else
-      {
-         MSG_DEBUG(std::cout << "DEBFRT05 "
-                   << this->thesolver->basis().iteration()
-                   << " no valid leaveIdx found - breaking..."
-                   << std::endl;)
-         return leaveIdx;
-      }
-   }
-   else
-   {
-      relax_count = 0;
-      this->tighten();
-   }
-
-   // flip bounds of skipped breakpoints only if a nondegenerate step is to be performed
-   if(npassedBp > 0 && spxAbs(breakpoints[npassedBp].val) > this->fastDelta)
-   {
-      flipAndUpdate(npassedBp);
-      this->thesolver->boundflips = npassedBp;
-
-      if(npassedBp >= 10)
-         flipPotential = 1;
-      else
-         flipPotential -= 0.05;
-   }
-   else
-   {
-      this->thesolver->boundflips = 0;
-      flipPotential -= 0.1;
-   }
-
-   MSG_DEBUG(std::cout << "DEBFRT06 "
-             << this->thesolver->basis().iteration()
-             << ": selected Index: "
-             << leaveIdx
-             << " number of candidates: "
-             << nBp
-             << std::endl;)
-
-   return leaveIdx;
+    if (relax_count < MAX_RELAX_COUNT) {
+      MSG_DEBUG(std::cout << "DEBFRT04 " << this->thesolver->basis().iteration()
+                          << ": no valid leaveIdx found - relaxing..."
+                          << std::endl;)
+      this->relax();
+      ++relax_count;
+      // restore original value
+      val = max;
+      // try again with relaxed delta
+      return SPxBoundFlippingRT<R>::selectLeave(val, enterTest);
+    } else {
+      MSG_DEBUG(std::cout << "DEBFRT05 " << this->thesolver->basis().iteration()
+                          << " no valid leaveIdx found - breaking..."
+                          << std::endl;)
+      return leaveIdx;
+    }
+  } else {
+    relax_count = 0;
+    this->tighten();
+  }
+
+  // flip bounds of skipped breakpoints only if a nondegenerate step is to be
+  // performed
+  if (npassedBp > 0 && spxAbs(breakpoints[npassedBp].val) > this->fastDelta) {
+    flipAndUpdate(npassedBp);
+    this->thesolver->boundflips = npassedBp;
+
+    if (npassedBp >= 10)
+      flipPotential = 1;
+    else
+      flipPotential -= 0.05;
+  } else {
+    this->thesolver->boundflips = 0;
+    flipPotential -= 0.1;
+  }
+
+  MSG_DEBUG(std::cout << "DEBFRT06 " << this->thesolver->basis().iteration()
+                      << ": selected Index: " << leaveIdx
+                      << " number of candidates: " << nBp << std::endl;)
+
+  return leaveIdx;
 }
 
-
 } // namespace soplex
diff --git a/src/soplex/spxbounds.hpp b/src/soplex/spxbounds.hpp
index 73e984f..6466415 100644
--- a/src/soplex/spxbounds.hpp
+++ b/src/soplex/spxbounds.hpp
@@ -21,6 +21,7 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <assert.h>
 #include <iostream>
@@ -28,8 +29,7 @@
 #include "soplex/spxdefines.h"
 #include "soplex/spxsolver.h"
 
-namespace soplex
-{
+namespace soplex {
 /** Setting up the feasiblity bound for normal primal variables is
     straightforward. However, slack variables need some more details
     on how we treat them. This is slightly different from usual
@@ -38,30 +38,26 @@ namespace soplex
     -l_i\f$. Hence, with this definition of slack variables \f$s_i\f$, we
     can directly use vectors \f$l\f$ and \f$u\f$ as feasibility bounds.
 */
-template <class R>
-void SPxSolverBase<R>::setPrimalBounds()
-{
-
-   theUCbound = SPxLPBase<R>::upper();
-   theLCbound = SPxLPBase<R>::lower();
-
-   if(rep() == ROW)
-   {
-      theURbound = this->rhs();
-      theLRbound = this->lhs();
-   }
-   else
-   {
-      theURbound = this->lhs();
-      theLRbound = this->rhs();
-      theURbound *= -1.0;
-      theLRbound *= -1.0;
-   }
+template <class R> void SPxSolverBase<R>::setPrimalBounds() {
+
+  theUCbound = SPxLPBase<R>::upper();
+  theLCbound = SPxLPBase<R>::lower();
+
+  if (rep() == ROW) {
+    theURbound = this->rhs();
+    theLRbound = this->lhs();
+  } else {
+    theURbound = this->lhs();
+    theLRbound = this->rhs();
+    theURbound *= -1.0;
+    theLRbound *= -1.0;
+  }
 }
 
 /** Setting up the basis for dual simplex requires to install upper and lower
     feasibility bounds for dual variables (|Lbound| and |Ubound|). Here is a
-    list of how these must be set for inequalities of type \f$l \le a^Tx \le u\f$:
+    list of how these must be set for inequalities of type \f$l \le a^Tx \le
+   u\f$:
 
     \f[
     \begin{tabular}{cccc}
@@ -76,8 +72,8 @@ void SPxSolverBase<R>::setPrimalBounds()
     $-\infty<l  =  u<\infty$}       & $-\infty$     & $\infty$      \\
     \end{tabular}
     \f]
-    The case \f$l = -\infty\f$, \f$u = \infty\f$ occurs for unbounded primal variables.
-    Such must be treated differently from the general case.
+    The case \f$l = -\infty\f$, \f$u = \infty\f$ occurs for unbounded primal
+   variables. Such must be treated differently from the general case.
 
     Given possible upper and lower bounds to a dual variable with |Status stat|,
     this function clears the bounds according to |stat| by setting them to
@@ -85,91 +81,78 @@ void SPxSolverBase<R>::setPrimalBounds()
 */
 template <class R>
 void SPxSolverBase<R>::clearDualBounds(
-   typename SPxBasisBase<R>::Desc::Status stat,
-   R&                  upp,
-   R&                  lw) const
-{
-
-   switch(stat)
-   {
-   case SPxBasisBase<R>::Desc::P_ON_UPPER + SPxBasisBase<R>::Desc::P_ON_LOWER :
-   case SPxBasisBase<R>::Desc::D_FREE :
-      upp = R(infinity);
-      lw  = R(-infinity);
-      break;
-
-   case SPxBasisBase<R>::Desc::P_ON_UPPER :
-   case SPxBasisBase<R>::Desc::D_ON_LOWER :
-      upp = R(infinity);
-      break;
-
-   case SPxBasisBase<R>::Desc::P_ON_LOWER :
-   case SPxBasisBase<R>::Desc::D_ON_UPPER :
-      lw  = R(-infinity);
-      break;
-
-   default:
-      break;
-   }
+    typename SPxBasisBase<R>::Desc::Status stat, R &upp, R &lw) const {
+
+  switch (stat) {
+  case SPxBasisBase<R>::Desc::P_ON_UPPER + SPxBasisBase<R>::Desc::P_ON_LOWER:
+  case SPxBasisBase<R>::Desc::D_FREE:
+    upp = R(infinity);
+    lw = R(-infinity);
+    break;
+
+  case SPxBasisBase<R>::Desc::P_ON_UPPER:
+  case SPxBasisBase<R>::Desc::D_ON_LOWER:
+    upp = R(infinity);
+    break;
+
+  case SPxBasisBase<R>::Desc::P_ON_LOWER:
+  case SPxBasisBase<R>::Desc::D_ON_UPPER:
+    lw = R(-infinity);
+    break;
+
+  default:
+    break;
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::setDualColBounds()
-{
+template <class R> void SPxSolverBase<R>::setDualColBounds() {
 
-   assert(rep() == COLUMN);
+  assert(rep() == COLUMN);
 
-   const typename SPxBasisBase<R>::Desc& ds = this->desc();
+  const typename SPxBasisBase<R>::Desc &ds = this->desc();
 
-   int i;
+  int i;
 
-   for(i = 0; i < this->nRows(); ++i)
-   {
-      theURbound[i] = this->maxRowObj(i);
-      theLRbound[i] = this->maxRowObj(i);
+  for (i = 0; i < this->nRows(); ++i) {
+    theURbound[i] = this->maxRowObj(i);
+    theLRbound[i] = this->maxRowObj(i);
 
-      clearDualBounds(ds.rowStatus(i), theURbound[i], theLRbound[i]);
-   }
+    clearDualBounds(ds.rowStatus(i), theURbound[i], theLRbound[i]);
+  }
 
-   for(i = 0; i < this->nCols(); ++i)
-   {
-      theUCbound[i] = -this->maxObj(i);
-      theLCbound[i] = -this->maxObj(i);
+  for (i = 0; i < this->nCols(); ++i) {
+    theUCbound[i] = -this->maxObj(i);
+    theLCbound[i] = -this->maxObj(i);
 
-      // exchanged ...                 due to definition of slacks!
-      clearDualBounds(ds.colStatus(i), theLCbound[i], theUCbound[i]);
+    // exchanged ...                 due to definition of slacks!
+    clearDualBounds(ds.colStatus(i), theLCbound[i], theUCbound[i]);
 
-      theUCbound[i] *= -1.0;
-      theLCbound[i] *= -1.0;
-   }
+    theUCbound[i] *= -1.0;
+    theLCbound[i] *= -1.0;
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::setDualRowBounds()
-{
+template <class R> void SPxSolverBase<R>::setDualRowBounds() {
 
-   assert(rep() == ROW);
+  assert(rep() == ROW);
 
-   int i;
+  int i;
 
-   for(i = 0; i < this->nRows(); ++i)
-   {
-      theURbound[i] = 0.0;
-      theLRbound[i] = 0.0;
+  for (i = 0; i < this->nRows(); ++i) {
+    theURbound[i] = 0.0;
+    theLRbound[i] = 0.0;
 
-      clearDualBounds(this->dualRowStatus(i), theURbound[i], theLRbound[i]);
-   }
+    clearDualBounds(this->dualRowStatus(i), theURbound[i], theLRbound[i]);
+  }
 
-   for(i = 0; i < this->nCols(); ++i)
-   {
-      theUCbound[i] = 0.0;
-      theLCbound[i] = 0.0;
+  for (i = 0; i < this->nCols(); ++i) {
+    theUCbound[i] = 0.0;
+    theLCbound[i] = 0.0;
 
-      clearDualBounds(this->dualColStatus(i), theUCbound[i], theLCbound[i]);
-   }
+    clearDualBounds(this->dualColStatus(i), theUCbound[i], theLCbound[i]);
+  }
 }
 
-
 /** This sets up the bounds for basic variables for entering simplex algorithms.
     It requires, that all upper lower feasibility bounds have allready been
     setup. Method |setEnterBound4Row(i, n)| does so for the |i|-th basis
@@ -177,281 +160,271 @@ void SPxSolverBase<R>::setDualRowBounds()
     |setEnterBound4Col(i, n)| does so for the |i|-th basis variable being
     column index |n|.
 */
-template <class R>
-void SPxSolverBase<R>::setEnterBound4Row(int i, int n)
-{
-   assert(this->baseId(i).isSPxRowId());
-   assert(this->number(SPxRowId(this->baseId(i))) == n);
-
-   switch(this->desc().rowStatus(n))
-   {
-   case SPxBasisBase<R>::Desc::P_ON_LOWER :
-      theLBbound[i] = R(-infinity);
-      theUBbound[i] = theURbound[n];
-      break;
-
-   case SPxBasisBase<R>::Desc::P_ON_UPPER :
-      theLBbound[i] = theLRbound[n];
-      theUBbound[i] = R(infinity);
-      break;
-
-   case SPxBasisBase<R>::Desc::P_FIXED:
-      theLBbound[i] = R(-infinity);
-      theUBbound[i] = R(infinity);
-      break;
-
-   default:
-      theUBbound[i] = theURbound[n];
-      theLBbound[i] = theLRbound[n];
-      break;
-   }
+template <class R> void SPxSolverBase<R>::setEnterBound4Row(int i, int n) {
+  assert(this->baseId(i).isSPxRowId());
+  assert(this->number(SPxRowId(this->baseId(i))) == n);
+
+  switch (this->desc().rowStatus(n)) {
+  case SPxBasisBase<R>::Desc::P_ON_LOWER:
+    theLBbound[i] = R(-infinity);
+    theUBbound[i] = theURbound[n];
+    break;
+
+  case SPxBasisBase<R>::Desc::P_ON_UPPER:
+    theLBbound[i] = theLRbound[n];
+    theUBbound[i] = R(infinity);
+    break;
+
+  case SPxBasisBase<R>::Desc::P_FIXED:
+    theLBbound[i] = R(-infinity);
+    theUBbound[i] = R(infinity);
+    break;
+
+  default:
+    theUBbound[i] = theURbound[n];
+    theLBbound[i] = theLRbound[n];
+    break;
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::setEnterBound4Col(int i, int n)
-{
-   assert(this->baseId(i).isSPxColId());
-   assert(this->number(SPxColId(this->baseId(i))) == n);
-
-   switch(this->desc().colStatus(n))
-   {
-   case SPxBasisBase<R>::Desc::P_ON_LOWER :
-      theLBbound[i] = R(-infinity);
-      theUBbound[i] = theUCbound[n];
-      break;
-
-   case SPxBasisBase<R>::Desc::P_ON_UPPER :
-      theLBbound[i] = theLCbound[n];
-      theUBbound[i] = R(infinity);
-      break;
-
-   case SPxBasisBase<R>::Desc::P_FIXED:
-      theLBbound[i] = R(-infinity);
-      theUBbound[i] = R(infinity);
-      break;
-
-   default:
-      theUBbound[i] = theUCbound[n];
-      theLBbound[i] = theLCbound[n];
-      break;
-   }
-}
-template <class R>
-void SPxSolverBase<R>::setEnterBounds()
-{
-
-   for(int i = 0; i < dim(); ++i)
-   {
-      SPxId base_id = this->baseId(i);
-
-      if(base_id.isSPxRowId())
-         setEnterBound4Row(i, this->number(SPxRowId(base_id)));
-      else
-         setEnterBound4Col(i, this->number(SPxColId(base_id)));
-   }
+template <class R> void SPxSolverBase<R>::setEnterBound4Col(int i, int n) {
+  assert(this->baseId(i).isSPxColId());
+  assert(this->number(SPxColId(this->baseId(i))) == n);
+
+  switch (this->desc().colStatus(n)) {
+  case SPxBasisBase<R>::Desc::P_ON_LOWER:
+    theLBbound[i] = R(-infinity);
+    theUBbound[i] = theUCbound[n];
+    break;
+
+  case SPxBasisBase<R>::Desc::P_ON_UPPER:
+    theLBbound[i] = theLCbound[n];
+    theUBbound[i] = R(infinity);
+    break;
+
+  case SPxBasisBase<R>::Desc::P_FIXED:
+    theLBbound[i] = R(-infinity);
+    theUBbound[i] = R(infinity);
+    break;
+
+  default:
+    theUBbound[i] = theUCbound[n];
+    theLBbound[i] = theLCbound[n];
+    break;
+  }
 }
+template <class R> void SPxSolverBase<R>::setEnterBounds() {
 
+  for (int i = 0; i < dim(); ++i) {
+    SPxId base_id = this->baseId(i);
+
+    if (base_id.isSPxRowId())
+      setEnterBound4Row(i, this->number(SPxRowId(base_id)));
+    else
+      setEnterBound4Col(i, this->number(SPxColId(base_id)));
+  }
+}
 
 /** This sets up the bounds for basic variables for leaving simplex algorithms.
     While method |setLeaveBound4Row(i,n)| does so for the |i|-th basic variable
     being the |n|-th row, |setLeaveBound4Col(i,n)| does so for the |i|-th basic
     variable being the |n|-th column.
 */
-template <class R>
-void SPxSolverBase<R>::setLeaveBound4Row(int i, int n)
-{
-   assert(this->baseId(i).isSPxRowId());
-   assert(this->number(SPxRowId(this->baseId(i))) == n);
-
-   switch(this->desc().rowStatus(n))
-   {
-   case SPxBasisBase<R>::Desc::P_ON_LOWER :
-      theLBbound[i] = R(-infinity);
-      theUBbound[i] = -this->maxRowObj(n);
-      break;
-
-   case SPxBasisBase<R>::Desc::P_ON_UPPER :
-      theLBbound[i] = -this->maxRowObj(n);
-      theUBbound[i] = R(infinity);
-      break;
-
-   case SPxBasisBase<R>::Desc::P_ON_UPPER + SPxBasisBase<R>::Desc::P_ON_LOWER :
-      theLBbound[i] = R(-infinity);
-      theUBbound[i] = R(infinity);
-      break;
-
-   case SPxBasisBase<R>::Desc::P_FREE :
-      theLBbound[i] = -this->maxRowObj(n);
-      theUBbound[i] = -this->maxRowObj(n);
-      break;
-
-   default:
-      assert(rep() == COLUMN);
-      theLBbound[i] = -this->rhs(n);                // slacks !
-      theUBbound[i] = -this->lhs(n);                // slacks !
-      break;
-   }
+template <class R> void SPxSolverBase<R>::setLeaveBound4Row(int i, int n) {
+  assert(this->baseId(i).isSPxRowId());
+  assert(this->number(SPxRowId(this->baseId(i))) == n);
+
+  switch (this->desc().rowStatus(n)) {
+  case SPxBasisBase<R>::Desc::P_ON_LOWER:
+    theLBbound[i] = R(-infinity);
+    theUBbound[i] = -this->maxRowObj(n);
+    break;
+
+  case SPxBasisBase<R>::Desc::P_ON_UPPER:
+    theLBbound[i] = -this->maxRowObj(n);
+    theUBbound[i] = R(infinity);
+    break;
+
+  case SPxBasisBase<R>::Desc::P_ON_UPPER + SPxBasisBase<R>::Desc::P_ON_LOWER:
+    theLBbound[i] = R(-infinity);
+    theUBbound[i] = R(infinity);
+    break;
+
+  case SPxBasisBase<R>::Desc::P_FREE:
+    theLBbound[i] = -this->maxRowObj(n);
+    theUBbound[i] = -this->maxRowObj(n);
+    break;
+
+  default:
+    assert(rep() == COLUMN);
+    theLBbound[i] = -this->rhs(n); // slacks !
+    theUBbound[i] = -this->lhs(n); // slacks !
+    break;
+  }
 }
-template <class R>
-void SPxSolverBase<R>::setLeaveBound4Col(int i, int n)
-{
-
-   assert(this->baseId(i).isSPxColId());
-   assert(this->number(SPxColId(this->baseId(i))) == n);
-
-   switch(this->desc().colStatus(n))
-   {
-   case SPxBasisBase<R>::Desc::P_ON_LOWER :
-      theLBbound[i] = R(-infinity);
-      theUBbound[i] = 0;
-      break;
-
-   case SPxBasisBase<R>::Desc::P_ON_UPPER :
-      theLBbound[i] = 0;
-      theUBbound[i] = R(infinity);
-      break;
-
-   case SPxBasisBase<R>::Desc::P_FIXED :
-      theLBbound[i] = R(-infinity);
-      theUBbound[i] = R(infinity);
-      break;
-
-   case SPxBasisBase<R>::Desc::P_FREE :
-      theLBbound[i] = theUBbound[i] = 0;
-      break;
-
-   default:
-      theUBbound[i] = SPxLPBase<R>::upper(n);
-      theLBbound[i] = SPxLPBase<R>::lower(n);
-      break;
-   }
+template <class R> void SPxSolverBase<R>::setLeaveBound4Col(int i, int n) {
+
+  assert(this->baseId(i).isSPxColId());
+  assert(this->number(SPxColId(this->baseId(i))) == n);
+
+  switch (this->desc().colStatus(n)) {
+  case SPxBasisBase<R>::Desc::P_ON_LOWER:
+    theLBbound[i] = R(-infinity);
+    theUBbound[i] = 0;
+    break;
+
+  case SPxBasisBase<R>::Desc::P_ON_UPPER:
+    theLBbound[i] = 0;
+    theUBbound[i] = R(infinity);
+    break;
+
+  case SPxBasisBase<R>::Desc::P_FIXED:
+    theLBbound[i] = R(-infinity);
+    theUBbound[i] = R(infinity);
+    break;
+
+  case SPxBasisBase<R>::Desc::P_FREE:
+    theLBbound[i] = theUBbound[i] = 0;
+    break;
+
+  default:
+    theUBbound[i] = SPxLPBase<R>::upper(n);
+    theLBbound[i] = SPxLPBase<R>::lower(n);
+    break;
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::setLeaveBounds()
-{
-
-   for(int i = 0; i < dim(); ++i)
-   {
-      SPxId base_id = this->baseId(i);
-
-      if(base_id.isSPxRowId())
-         setLeaveBound4Row(i, this->number(SPxRowId(base_id)));
-      else
-         setLeaveBound4Col(i, this->number(SPxColId(base_id)));
-   }
+template <class R> void SPxSolverBase<R>::setLeaveBounds() {
+
+  for (int i = 0; i < dim(); ++i) {
+    SPxId base_id = this->baseId(i);
+
+    if (base_id.isSPxRowId())
+      setLeaveBound4Row(i, this->number(SPxRowId(base_id)));
+    else
+      setLeaveBound4Col(i, this->number(SPxColId(base_id)));
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::testBounds() const
-{
+template <class R> void SPxSolverBase<R>::testBounds() const {
 
-   if(type() == ENTER)
-   {
-      R viol_max = (1 + this->iterCount) * entertol();
-      int nlinesprinted = 0;
-      int m = dim();
+  if (type() == ENTER) {
+    R viol_max = (1 + this->iterCount) * entertol();
+    int nlinesprinted = 0;
+    int m = dim();
 
-      for(int i = 0; i < m; ++i)
+    for (int i = 0; i < m; ++i) {
+      // Minor bound violations happen frequently, so print these
+      // warnings only with verbose level INFO2 and higher.
+      if ((*theFvec)[i] >
+          theUBbound[i] + viol_max) //@ &&  theUBbound[i] != theLBbound[i])
       {
-         // Minor bound violations happen frequently, so print these
-         // warnings only with verbose level INFO2 and higher.
-         if((*theFvec)[i] > theUBbound[i] + viol_max)   //@ &&  theUBbound[i] != theLBbound[i])
-         {
-            MSG_INFO2((*this->spxout), (*this->spxout) << "WBOUND01 Invalid upper enter bound " << i
-                      << " Fvec: " << (*theFvec)[i]
-                      << " UBbound: " << theUBbound[i]
-                      << " tolerance: " << viol_max
-                      << " violation: " << (*theFvec)[i] - theUBbound[i] << std::endl;)
-            nlinesprinted++;
-         }
-
-         if((*theFvec)[i] < theLBbound[i] - viol_max)   //@ &&  theUBbound[i] != theLBbound[i])
-         {
-            MSG_INFO2((*this->spxout), (*this->spxout) << "WBOUND02 Invalid lower enter bound " << i
-                      << " Fvec: " << (*theFvec)[i]
-                      << " LBbound: " << theLBbound[i]
-                      << " tolerance: " << viol_max
-                      << " violation: " << theLBbound[i] - (*theFvec)[i] << std::endl;)
-            nlinesprinted++;
-         }
-
-         if(nlinesprinted >= 3)
-         {
-            MSG_INFO2((*this->spxout), (*this->spxout) <<
-                      "WBOUND10 suppressing further warnings of type WBOUND{01,02} in this round" << std::endl);
-            break;
-         }
+        MSG_INFO2((*this->spxout),
+                  (*this->spxout)
+                      << "WBOUND01 Invalid upper enter bound " << i << " Fvec: "
+                      << (*theFvec)[i] << " UBbound: " << theUBbound[i]
+                      << " tolerance: " << viol_max << " violation: "
+                      << (*theFvec)[i] - theUBbound[i] << std::endl;)
+        nlinesprinted++;
       }
-   }
-   else
-   {
-      R viol_max = (1 + this->iterCount) * leavetol();
-      int nlinesprinted = 0;
-      int m = dim();
-      int n = coDim();
-
-      for(int i = 0; i < m; ++i)
+
+      if ((*theFvec)[i] <
+          theLBbound[i] - viol_max) //@ &&  theUBbound[i] != theLBbound[i])
       {
-         if((*theCoPvec)[i] > (*theCoUbound)[i] + viol_max)  // && (*theCoUbound)[i] != (*theCoLbound)[i])
-         {
-            MSG_INFO2((*this->spxout), (*this->spxout) << "WBOUND03 Invalid upper cobound " << i
-                      << " CoPvec: " << (*theCoPvec)[i]
-                      << " CoUbound: " << (*theCoUbound)[i]
-                      << " tolerance: " << viol_max
-                      << " violation: " << (*theCoPvec)[i] - (*theCoUbound)[i] << std::endl;)
-            nlinesprinted++;
-         }
-
-         if((*theCoPvec)[i] < (*theCoLbound)[i] - viol_max)  // && (*theCoUbound)[i] != (*theCoLbound)[i])
-         {
-            MSG_INFO2((*this->spxout), (*this->spxout) << "WBOUND04 Invalid lower cobound " << i
-                      << " CoPvec: " << (*theCoPvec)[i]
-                      << " CoLbound: " << (*theCoLbound)[i]
-                      << " tolerance: " << viol_max
-                      << " violation: " << (*theCoLbound)[i] - (*theCoPvec)[i] << std::endl;)
-            nlinesprinted++;
-         }
-
-         if(nlinesprinted >= 3)
-         {
-            MSG_INFO2((*this->spxout), (*this->spxout) <<
-                      "WBOUND11 suppressing further warnings of type WBOUND{03,04} in this round" << std::endl);
-            break;
-         }
+        MSG_INFO2((*this->spxout),
+                  (*this->spxout)
+                      << "WBOUND02 Invalid lower enter bound " << i << " Fvec: "
+                      << (*theFvec)[i] << " LBbound: " << theLBbound[i]
+                      << " tolerance: " << viol_max << " violation: "
+                      << theLBbound[i] - (*theFvec)[i] << std::endl;)
+        nlinesprinted++;
       }
 
-      nlinesprinted = 0;
+      if (nlinesprinted >= 3) {
+        MSG_INFO2((*this->spxout),
+                  (*this->spxout) << "WBOUND10 suppressing further warnings of "
+                                     "type WBOUND{01,02} in this round"
+                                  << std::endl);
+        break;
+      }
+    }
+  } else {
+    R viol_max = (1 + this->iterCount) * leavetol();
+    int nlinesprinted = 0;
+    int m = dim();
+    int n = coDim();
+
+    for (int i = 0; i < m; ++i) {
+      if ((*theCoPvec)[i] >
+          (*theCoUbound)[i] +
+              viol_max) // && (*theCoUbound)[i] != (*theCoLbound)[i])
+      {
+        MSG_INFO2((*this->spxout),
+                  (*this->spxout)
+                      << "WBOUND03 Invalid upper cobound " << i << " CoPvec: "
+                      << (*theCoPvec)[i] << " CoUbound: " << (*theCoUbound)[i]
+                      << " tolerance: " << viol_max << " violation: "
+                      << (*theCoPvec)[i] - (*theCoUbound)[i] << std::endl;)
+        nlinesprinted++;
+      }
 
-      for(int i = 0; i < n; ++i)
+      if ((*theCoPvec)[i] <
+          (*theCoLbound)[i] -
+              viol_max) // && (*theCoUbound)[i] != (*theCoLbound)[i])
       {
-         if((*thePvec)[i] > (*theUbound)[i] + viol_max)   // &&  (*theUbound)[i] != (*theLbound)[i])
-         {
-            MSG_INFO2((*this->spxout), (*this->spxout) << "WBOUND05 Invalid upper bound " << i
-                      << " Pvec: " << (*thePvec)[i]
-                      << " Ubound: " << (*theUbound)[i]
-                      << " tolerance: " << viol_max
-                      << " violation: " << (*thePvec)[i] - (*theUbound)[i] << std::endl;)
-            nlinesprinted++;
-         }
-
-         if((*thePvec)[i] < (*theLbound)[i] - viol_max)   // &&  (*theUbound)[i] != (*theLbound)[i])
-         {
-            MSG_INFO2((*this->spxout), (*this->spxout) << "WBOUND06 Invalid lower bound " << i
-                      << " Pvec: " << (*thePvec)[i]
-                      << " Lbound: " << (*theLbound)[i]
-                      << " tolerance: " << viol_max
-                      << " violation: " << (*theLbound)[i] - (*thePvec)[i] << std::endl;)
-            nlinesprinted++;
-         }
-
-         if(nlinesprinted >= 3)
-         {
-            MSG_INFO2((*this->spxout), (*this->spxout) <<
-                      "WBOUND12 suppressing further warnings of type WBOUND{05,06} in this round" << std::endl);
-            break;
-         }
+        MSG_INFO2((*this->spxout),
+                  (*this->spxout)
+                      << "WBOUND04 Invalid lower cobound " << i << " CoPvec: "
+                      << (*theCoPvec)[i] << " CoLbound: " << (*theCoLbound)[i]
+                      << " tolerance: " << viol_max << " violation: "
+                      << (*theCoLbound)[i] - (*theCoPvec)[i] << std::endl;)
+        nlinesprinted++;
+      }
+
+      if (nlinesprinted >= 3) {
+        MSG_INFO2((*this->spxout),
+                  (*this->spxout) << "WBOUND11 suppressing further warnings of "
+                                     "type WBOUND{03,04} in this round"
+                                  << std::endl);
+        break;
+      }
+    }
+
+    nlinesprinted = 0;
+
+    for (int i = 0; i < n; ++i) {
+      if ((*thePvec)[i] >
+          (*theUbound)[i] + viol_max) // &&  (*theUbound)[i] != (*theLbound)[i])
+      {
+        MSG_INFO2((*this->spxout),
+                  (*this->spxout)
+                      << "WBOUND05 Invalid upper bound " << i << " Pvec: "
+                      << (*thePvec)[i] << " Ubound: " << (*theUbound)[i]
+                      << " tolerance: " << viol_max << " violation: "
+                      << (*thePvec)[i] - (*theUbound)[i] << std::endl;)
+        nlinesprinted++;
+      }
+
+      if ((*thePvec)[i] <
+          (*theLbound)[i] - viol_max) // &&  (*theUbound)[i] != (*theLbound)[i])
+      {
+        MSG_INFO2((*this->spxout),
+                  (*this->spxout)
+                      << "WBOUND06 Invalid lower bound " << i << " Pvec: "
+                      << (*thePvec)[i] << " Lbound: " << (*theLbound)[i]
+                      << " tolerance: " << viol_max << " violation: "
+                      << (*theLbound)[i] - (*thePvec)[i] << std::endl;)
+        nlinesprinted++;
+      }
+
+      if (nlinesprinted >= 3) {
+        MSG_INFO2((*this->spxout),
+                  (*this->spxout) << "WBOUND12 suppressing further warnings of "
+                                     "type WBOUND{05,06} in this round"
+                                  << std::endl);
+        break;
       }
-   }
+    }
+  }
 }
 } // namespace soplex
diff --git a/src/soplex/spxchangebasis.hpp b/src/soplex/spxchangebasis.hpp
index 6e3ac1e..6f7050a 100644
--- a/src/soplex/spxchangebasis.hpp
+++ b/src/soplex/spxchangebasis.hpp
@@ -21,466 +21,393 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <iostream>
 
-#include "soplex/spxdefines.h"
 #include "soplex/spxbasis.h"
-#include "soplex/spxsolver.h"
+#include "soplex/spxdefines.h"
 #include "soplex/spxout.h"
+#include "soplex/spxsolver.h"
 
-namespace soplex
-{
-template <class R>
-void SPxBasisBase<R>::reDim()
-{
+namespace soplex {
+template <class R> void SPxBasisBase<R>::reDim() {
 
-   assert(theLP != 0);
+  assert(theLP != 0);
 
-   MSG_DEBUG(std::cout << "DCHBAS01 SPxBasisBase<R>::reDim():"
-             << " matrixIsSetup=" << matrixIsSetup
-             << " fatorized=" << factorized
-             << std::endl;)
+  MSG_DEBUG(std::cout << "DCHBAS01 SPxBasisBase<R>::reDim():"
+                      << " matrixIsSetup=" << matrixIsSetup
+                      << " fatorized=" << factorized << std::endl;)
 
-   thedesc.reSize(theLP->nRows(), theLP->nCols());
+  thedesc.reSize(theLP->nRows(), theLP->nCols());
 
-   if(theLP->dim() != matrix.size())
-   {
-      MSG_INFO3((*this->spxout), (*this->spxout) <<
-                "ICHBAS02 basis redimensioning invalidates factorization"
-                << std::endl;)
+  if (theLP->dim() != matrix.size()) {
+    MSG_INFO3((*this->spxout),
+              (*this->spxout)
+                  << "ICHBAS02 basis redimensioning invalidates factorization"
+                  << std::endl;)
 
-      matrix.reSize(theLP->dim());
-      theBaseId.reSize(theLP->dim());
-      matrixIsSetup = false;
-      factorized    = false;
-   }
+    matrix.reSize(theLP->dim());
+    theBaseId.reSize(theLP->dim());
+    matrixIsSetup = false;
+    factorized = false;
+  }
 
-   MSG_DEBUG(std::cout << "DCHBAS03 SPxBasisBase<R>::reDim(): -->"
-             << " matrixIsSetup=" << matrixIsSetup
-             << " fatorized=" << factorized
-             << std::endl;)
+  MSG_DEBUG(std::cout << "DCHBAS03 SPxBasisBase<R>::reDim(): -->"
+                      << " matrixIsSetup=" << matrixIsSetup
+                      << " fatorized=" << factorized << std::endl;)
 
-   assert(matrix.size()    >= theLP->dim());
-   assert(theBaseId.size() >= theLP->dim());
+  assert(matrix.size() >= theLP->dim());
+  assert(theBaseId.size() >= theLP->dim());
 }
 
 /* adapt basis and basis descriptor to added rows */
-template <class R>
-void SPxBasisBase<R>::addedRows(int n)
-{
-   assert(theLP != 0);
+template <class R> void SPxBasisBase<R>::addedRows(int n) {
+  assert(theLP != 0);
 
-   if(n > 0)
-   {
-      reDim();
+  if (n > 0) {
+    reDim();
 
-      if(theLP->rep() == SPxSolverBase<R>::COLUMN)
-      {
-         /* after adding rows in column representation, reDim() should set these bools to false. */
-         assert(!matrixIsSetup && !factorized);
-
-         for(int i = theLP->nRows() - n; i < theLP->nRows(); ++i)
-         {
-            thedesc.rowStatus(i) = dualRowStatus(i);
-            baseId(i) = theLP->SPxLPBase<R>::rId(i);
-         }
-      }
-      else
-      {
-         assert(theLP->rep() == SPxSolverBase<R>::ROW);
+    if (theLP->rep() == SPxSolverBase<R>::COLUMN) {
+      /* after adding rows in column representation, reDim() should set these
+       * bools to false. */
+      assert(!matrixIsSetup && !factorized);
 
-         for(int i = theLP->nRows() - n; i < theLP->nRows(); ++i)
-            thedesc.rowStatus(i) = dualRowStatus(i);
+      for (int i = theLP->nRows() - n; i < theLP->nRows(); ++i) {
+        thedesc.rowStatus(i) = dualRowStatus(i);
+        baseId(i) = theLP->SPxLPBase<R>::rId(i);
       }
+    } else {
+      assert(theLP->rep() == SPxSolverBase<R>::ROW);
 
-      /* If matrix was set up, load new basis vectors to the matrix.
-       * In the row case, the basis is not effected by adding rows. However,
-       * since @c matrix stores references to the rows in the LP (SPxLPBase<R>), a realloc
-       * in SPxLPBase<R> (e.g. due to space requirements) might invalidate these references.
-       * We therefore have to "reload" the matrix if it is set up. Note that reDim()
-       * leaves @c matrixIsSetup untouched if only row have been added, since the basis
-       * matrix already has the correct size. */
-      if(status() > NO_PROBLEM && matrixIsSetup)
-         loadMatrixVecs();
-
-      /* update basis status */
-      switch(status())
-      {
-      case PRIMAL:
-      case UNBOUNDED:
-         setStatus(REGULAR);
-         break;
-
-      case OPTIMAL:
-      case INFEASIBLE:
-         setStatus(DUAL);
-         break;
-
-      case NO_PROBLEM:
-      case SINGULAR:
-      case REGULAR:
-      case DUAL:
-         break;
-
-      default:
-         MSG_ERROR(std::cerr << "ECHBAS04 Unknown basis status!" << std::endl;)
-         throw SPxInternalCodeException("XCHBAS01 This should never happen.");
-      }
-   }
-}
+      for (int i = theLP->nRows() - n; i < theLP->nRows(); ++i)
+        thedesc.rowStatus(i) = dualRowStatus(i);
+    }
+
+    /* If matrix was set up, load new basis vectors to the matrix.
+     * In the row case, the basis is not effected by adding rows. However,
+     * since @c matrix stores references to the rows in the LP (SPxLPBase<R>), a
+     * realloc in SPxLPBase<R> (e.g. due to space requirements) might invalidate
+     * these references. We therefore have to "reload" the matrix if it is set
+     * up. Note that reDim() leaves @c matrixIsSetup untouched if only row have
+     * been added, since the basis matrix already has the correct size. */
+    if (status() > NO_PROBLEM && matrixIsSetup)
+      loadMatrixVecs();
 
-template <class R>
-void SPxBasisBase<R>::removedRow(int i)
-{
+    /* update basis status */
+    switch (status()) {
+    case PRIMAL:
+    case UNBOUNDED:
+      setStatus(REGULAR);
+      break;
+
+    case OPTIMAL:
+    case INFEASIBLE:
+      setStatus(DUAL);
+      break;
+
+    case NO_PROBLEM:
+    case SINGULAR:
+    case REGULAR:
+    case DUAL:
+      break;
+
+    default:
+      MSG_ERROR(std::cerr << "ECHBAS04 Unknown basis status!" << std::endl;)
+      throw SPxInternalCodeException("XCHBAS01 This should never happen.");
+    }
+  }
+}
 
-   assert(status() >  NO_PROBLEM);
-   assert(theLP    != 0);
+template <class R> void SPxBasisBase<R>::removedRow(int i) {
 
-   if(theLP->rep() == SPxSolverBase<R>::ROW)
-   {
-      if(theLP->isBasic(thedesc.rowStatus(i)))
-      {
-         setStatus(NO_PROBLEM);
-         factorized = false;
+  assert(status() > NO_PROBLEM);
+  assert(theLP != 0);
 
-         MSG_DEBUG(std::cout << "DCHBAS05 Warning: deleting basic row!\n";)
-      }
-   }
-   else
-   {
-      assert(theLP->rep() == SPxSolverBase<R>::COLUMN);
+  if (theLP->rep() == SPxSolverBase<R>::ROW) {
+    if (theLP->isBasic(thedesc.rowStatus(i))) {
+      setStatus(NO_PROBLEM);
       factorized = false;
 
-      if(!theLP->isBasic(thedesc.rowStatus(i)))
-      {
-         setStatus(NO_PROBLEM);
-         MSG_DEBUG(std::cout << "DCHBAS06 Warning: deleting nonbasic row!\n";)
-      }
-      else if(status() > NO_PROBLEM && matrixIsSetup)
-      {
-         for(int j = theLP->dim(); j >= 0; --j)
-         {
-            SPxId id = baseId(j);
+      MSG_DEBUG(std::cout << "DCHBAS05 Warning: deleting basic row!\n";)
+    }
+  } else {
+    assert(theLP->rep() == SPxSolverBase<R>::COLUMN);
+    factorized = false;
+
+    if (!theLP->isBasic(thedesc.rowStatus(i))) {
+      setStatus(NO_PROBLEM);
+      MSG_DEBUG(std::cout << "DCHBAS06 Warning: deleting nonbasic row!\n";)
+    } else if (status() > NO_PROBLEM && matrixIsSetup) {
+      for (int j = theLP->dim(); j >= 0; --j) {
+        SPxId id = baseId(j);
 
-            if(id.isSPxRowId() && !theLP->has(SPxRowId(id)))
-            {
-               baseId(j) = baseId(theLP->dim());
+        if (id.isSPxRowId() && !theLP->has(SPxRowId(id))) {
+          baseId(j) = baseId(theLP->dim());
 
-               if(j < theLP->dim())
-                  matrix[j] = &theLP->vector(baseId(j));
+          if (j < theLP->dim())
+            matrix[j] = &theLP->vector(baseId(j));
 
-               break;
-            }
-         }
+          break;
+        }
       }
-   }
+    }
+  }
 
-   thedesc.rowStatus(i) = thedesc.rowStatus(theLP->nRows());
-   reDim();
+  thedesc.rowStatus(i) = thedesc.rowStatus(theLP->nRows());
+  reDim();
 }
 
-template <class R>
-void SPxBasisBase<R>::removedRows(const int perm[])
-{
-   assert(status() > NO_PROBLEM);
-   assert(theLP != 0);
-
-   int i;
-   int n = thedesc.nRows();
-
-   if(theLP->rep() == SPxSolverBase<R>::ROW)
-   {
-      for(i = 0; i < n; ++i)
-      {
-         if(perm[i] != i)
-         {
-            if(perm[i] < 0)                // row got removed
-            {
-               if(theLP->isBasic(thedesc.rowStatus(i)))
-               {
-                  setStatus(NO_PROBLEM);
-                  factorized = matrixIsSetup = false;
-                  MSG_DEBUG(std::cout << "DCHBAS07 Warning: deleting basic row!\n";)
-               }
-            }
-            else                            // row was moved
-               thedesc.rowStatus(perm[i]) = thedesc.rowStatus(i);
-         }
+template <class R> void SPxBasisBase<R>::removedRows(const int perm[]) {
+  assert(status() > NO_PROBLEM);
+  assert(theLP != 0);
+
+  int i;
+  int n = thedesc.nRows();
+
+  if (theLP->rep() == SPxSolverBase<R>::ROW) {
+    for (i = 0; i < n; ++i) {
+      if (perm[i] != i) {
+        if (perm[i] < 0) // row got removed
+        {
+          if (theLP->isBasic(thedesc.rowStatus(i))) {
+            setStatus(NO_PROBLEM);
+            factorized = matrixIsSetup = false;
+            MSG_DEBUG(std::cout << "DCHBAS07 Warning: deleting basic row!\n";)
+          }
+        } else // row was moved
+          thedesc.rowStatus(perm[i]) = thedesc.rowStatus(i);
       }
-   }
-   else
-   {
-      assert(theLP->rep() == SPxSolverBase<R>::COLUMN);
-
-      factorized    = false;
-      matrixIsSetup = false;
-
-      for(i = 0; i < n; ++i)
-      {
-         if(perm[i] != i)
-         {
-            if(perm[i] < 0)                // row got removed
-            {
-               if(!theLP->isBasic(thedesc.rowStatus(i)))
-                  setStatus(NO_PROBLEM);
-            }
-            else                            // row was moved
-               thedesc.rowStatus(perm[i]) = thedesc.rowStatus(i);
-         }
+    }
+  } else {
+    assert(theLP->rep() == SPxSolverBase<R>::COLUMN);
+
+    factorized = false;
+    matrixIsSetup = false;
+
+    for (i = 0; i < n; ++i) {
+      if (perm[i] != i) {
+        if (perm[i] < 0) // row got removed
+        {
+          if (!theLP->isBasic(thedesc.rowStatus(i)))
+            setStatus(NO_PROBLEM);
+        } else // row was moved
+          thedesc.rowStatus(perm[i]) = thedesc.rowStatus(i);
       }
-   }
+    }
+  }
 
-   reDim();
+  reDim();
 }
 
 template <class R>
 static typename SPxBasisBase<R>::Desc::Status
-primalColStatus(int i, const SPxLPBase<R>* theLP)
-{
-   assert(theLP != 0);
-
-   if(theLP->upper(i) < R(infinity))
-   {
-      if(theLP->lower(i) > R(-infinity))
-      {
-         if(theLP->lower(i) == theLP->SPxLPBase<R>::upper(i))
-            return SPxBasisBase<R>::Desc::P_FIXED;
-         /*
-           else
-           return (-theLP->lower(i) < theLP->upper(i))
-           ? SPxBasisBase<R>::Desc::P_ON_LOWER
-           : SPxBasisBase<R>::Desc::P_ON_UPPER;
-         */
-         else if(theLP->maxObj(i) == 0)
-            return (-theLP->lower(i) < theLP->upper(i))
+primalColStatus(int i, const SPxLPBase<R> *theLP) {
+  assert(theLP != 0);
+
+  if (theLP->upper(i) < R(infinity)) {
+    if (theLP->lower(i) > R(-infinity)) {
+      if (theLP->lower(i) == theLP->SPxLPBase<R>::upper(i))
+        return SPxBasisBase<R>::Desc::P_FIXED;
+      /*
+        else
+        return (-theLP->lower(i) < theLP->upper(i))
+        ? SPxBasisBase<R>::Desc::P_ON_LOWER
+        : SPxBasisBase<R>::Desc::P_ON_UPPER;
+      */
+      else if (theLP->maxObj(i) == 0)
+        return (-theLP->lower(i) < theLP->upper(i))
                    ? SPxBasisBase<R>::Desc::P_ON_LOWER
                    : SPxBasisBase<R>::Desc::P_ON_UPPER;
-         else
-            return (theLP->maxObj(i) < 0)
-                   ? SPxBasisBase<R>::Desc::P_ON_LOWER
-                   : SPxBasisBase<R>::Desc::P_ON_UPPER;
-      }
       else
-         return SPxBasisBase<R>::Desc::P_ON_UPPER;
-   }
-   else if(theLP->lower(i) > R(-infinity))
-      return SPxBasisBase<R>::Desc::P_ON_LOWER;
-   else
-      return SPxBasisBase<R>::Desc::P_FREE;
+        return (theLP->maxObj(i) < 0) ? SPxBasisBase<R>::Desc::P_ON_LOWER
+                                      : SPxBasisBase<R>::Desc::P_ON_UPPER;
+    } else
+      return SPxBasisBase<R>::Desc::P_ON_UPPER;
+  } else if (theLP->lower(i) > R(-infinity))
+    return SPxBasisBase<R>::Desc::P_ON_LOWER;
+  else
+    return SPxBasisBase<R>::Desc::P_FREE;
 }
 
-
 /* adapt basis and basis descriptor to added columns */
-template <class R>
-void SPxBasisBase<R>::addedCols(int n)
-{
-   assert(theLP != 0);
+template <class R> void SPxBasisBase<R>::addedCols(int n) {
+  assert(theLP != 0);
 
-   if(n > 0)
-   {
-      reDim();
+  if (n > 0) {
+    reDim();
 
-      if(theLP->rep() == SPxSolverBase<R>::ROW)
-      {
-         /* after adding columns in row representation, reDim() should set these bools to false. */
-         assert(!matrixIsSetup && !factorized);
-
-         for(int i = theLP->nCols() - n; i < theLP->nCols(); ++i)
-         {
-            thedesc.colStatus(i) = primalColStatus(i, theLP);
-            baseId(i) = theLP->SPxLPBase<R>::cId(i);
-         }
-      }
-      else
-      {
-         assert(theLP->rep() == SPxSolverBase<R>::COLUMN);
+    if (theLP->rep() == SPxSolverBase<R>::ROW) {
+      /* after adding columns in row representation, reDim() should set these
+       * bools to false. */
+      assert(!matrixIsSetup && !factorized);
 
-         for(int i = theLP->nCols() - n; i < theLP->nCols(); ++i)
-            thedesc.colStatus(i) = primalColStatus(i, theLP);
+      for (int i = theLP->nCols() - n; i < theLP->nCols(); ++i) {
+        thedesc.colStatus(i) = primalColStatus(i, theLP);
+        baseId(i) = theLP->SPxLPBase<R>::cId(i);
       }
+    } else {
+      assert(theLP->rep() == SPxSolverBase<R>::COLUMN);
 
-      /* If matrix was set up, load new basis vectors to the matrix
-       * In the column case, the basis is not effected by adding columns. However,
-       * since @c matrix stores references to the columns in the LP (SPxLPBase<R>), a realloc
-       * in SPxLPBase<R> (e.g. due to space requirements) might invalidate these references.
-       * We therefore have to "reload" the matrix if it is set up. Note that reDim()
-       * leaves @c matrixIsSetup untouched if only columns have been added, since the
-       * basis matrix already has the correct size. */
-      if(status() > NO_PROBLEM && matrixIsSetup)
-         loadMatrixVecs();
-
-      switch(status())
-      {
-      case DUAL:
-      case INFEASIBLE:
-         setStatus(REGULAR);
-         break;
-
-      case OPTIMAL:
-      case UNBOUNDED:
-         setStatus(PRIMAL);
-         break;
-
-      case NO_PROBLEM:
-      case SINGULAR:
-      case REGULAR:
-      case PRIMAL:
-         break;
-
-      default:
-         MSG_ERROR(std::cerr << "ECHBAS08 Unknown basis status!" << std::endl;)
-         throw SPxInternalCodeException("XCHBAS02 This should never happen.");
-      }
-   }
+      for (int i = theLP->nCols() - n; i < theLP->nCols(); ++i)
+        thedesc.colStatus(i) = primalColStatus(i, theLP);
+    }
+
+    /* If matrix was set up, load new basis vectors to the matrix
+     * In the column case, the basis is not effected by adding columns. However,
+     * since @c matrix stores references to the columns in the LP
+     * (SPxLPBase<R>), a realloc in SPxLPBase<R> (e.g. due to space
+     * requirements) might invalidate these references. We therefore have to
+     * "reload" the matrix if it is set up. Note that reDim() leaves @c
+     * matrixIsSetup untouched if only columns have been added, since the basis
+     * matrix already has the correct size. */
+    if (status() > NO_PROBLEM && matrixIsSetup)
+      loadMatrixVecs();
+
+    switch (status()) {
+    case DUAL:
+    case INFEASIBLE:
+      setStatus(REGULAR);
+      break;
+
+    case OPTIMAL:
+    case UNBOUNDED:
+      setStatus(PRIMAL);
+      break;
+
+    case NO_PROBLEM:
+    case SINGULAR:
+    case REGULAR:
+    case PRIMAL:
+      break;
+
+    default:
+      MSG_ERROR(std::cerr << "ECHBAS08 Unknown basis status!" << std::endl;)
+      throw SPxInternalCodeException("XCHBAS02 This should never happen.");
+    }
+  }
 }
 
-template <class R>
-void SPxBasisBase<R>::removedCol(int i)
-{
-   assert(status() > NO_PROBLEM);
-   assert(theLP != 0);
-
-   if(theLP->rep() == SPxSolverBase<R>::COLUMN)
-   {
-      if(theLP->isBasic(thedesc.colStatus(i)))
-         setStatus(NO_PROBLEM);
-   }
-   else
-   {
-      assert(theLP->rep() == SPxSolverBase<R>::ROW);
-      factorized = false;
+template <class R> void SPxBasisBase<R>::removedCol(int i) {
+  assert(status() > NO_PROBLEM);
+  assert(theLP != 0);
 
-      if(!theLP->isBasic(thedesc.colStatus(i)))
-         setStatus(NO_PROBLEM);
-      else if(status() > NO_PROBLEM)
-      {
-         for(int j = theLP->dim(); j >= 0; --j)
-         {
-            SPxId id = baseId(j);
+  if (theLP->rep() == SPxSolverBase<R>::COLUMN) {
+    if (theLP->isBasic(thedesc.colStatus(i)))
+      setStatus(NO_PROBLEM);
+  } else {
+    assert(theLP->rep() == SPxSolverBase<R>::ROW);
+    factorized = false;
+
+    if (!theLP->isBasic(thedesc.colStatus(i)))
+      setStatus(NO_PROBLEM);
+    else if (status() > NO_PROBLEM) {
+      for (int j = theLP->dim(); j >= 0; --j) {
+        SPxId id = baseId(j);
 
-            if(id.isSPxColId() && !theLP->has(SPxColId(id)))
-            {
-               baseId(j) = baseId(theLP->dim());
+        if (id.isSPxColId() && !theLP->has(SPxColId(id))) {
+          baseId(j) = baseId(theLP->dim());
 
-               if(matrixIsSetup &&
-                     j < theLP->dim())
-                  matrix[j] = &theLP->vector(baseId(j));
+          if (matrixIsSetup && j < theLP->dim())
+            matrix[j] = &theLP->vector(baseId(j));
 
-               break;
-            }
-         }
+          break;
+        }
       }
-   }
+    }
+  }
 
-   thedesc.colStatus(i) = thedesc.colStatus(theLP->nCols());
-   reDim();
+  thedesc.colStatus(i) = thedesc.colStatus(theLP->nCols());
+  reDim();
 }
 
-template <class R>
-void SPxBasisBase<R>::removedCols(const int perm[])
-{
-   assert(status() > NO_PROBLEM);
-   assert(theLP != 0);
-
-   int i;
-   int n = thedesc.nCols();
+template <class R> void SPxBasisBase<R>::removedCols(const int perm[]) {
+  assert(status() > NO_PROBLEM);
+  assert(theLP != 0);
 
-   if(theLP->rep() == SPxSolverBase<R>::COLUMN)
-   {
-      for(i = 0; i < n; ++i)
-      {
-         if(perm[i] < 0)            // column got removed
-         {
-            if(theLP->isBasic(thedesc.colStatus(i)))
-               setStatus(NO_PROBLEM);
-         }
-         else                        // column was potentially moved
-            thedesc.colStatus(perm[i]) = thedesc.colStatus(i);
-      }
-   }
-   else
-   {
-      assert(theLP->rep() == SPxSolverBase<R>::ROW);
-      factorized = matrixIsSetup = false;
+  int i;
+  int n = thedesc.nCols();
 
-      for(i = 0; i < n; ++i)
+  if (theLP->rep() == SPxSolverBase<R>::COLUMN) {
+    for (i = 0; i < n; ++i) {
+      if (perm[i] < 0) // column got removed
       {
-         if(perm[i] != i)
-         {
-            if(perm[i] < 0)                // column got removed
-            {
-               if(!theLP->isBasic(thedesc.colStatus(i)))
-                  setStatus(NO_PROBLEM);
-            }
-            else                            // column was moved
-               thedesc.colStatus(perm[i]) = thedesc.colStatus(i);
-         }
+        if (theLP->isBasic(thedesc.colStatus(i)))
+          setStatus(NO_PROBLEM);
+      } else // column was potentially moved
+        thedesc.colStatus(perm[i]) = thedesc.colStatus(i);
+    }
+  } else {
+    assert(theLP->rep() == SPxSolverBase<R>::ROW);
+    factorized = matrixIsSetup = false;
+
+    for (i = 0; i < n; ++i) {
+      if (perm[i] != i) {
+        if (perm[i] < 0) // column got removed
+        {
+          if (!theLP->isBasic(thedesc.colStatus(i)))
+            setStatus(NO_PROBLEM);
+        } else // column was moved
+          thedesc.colStatus(perm[i]) = thedesc.colStatus(i);
       }
-   }
+    }
+  }
 
-   reDim();
+  reDim();
 }
 
-
 /**
  * mark the basis as not factorized
  */
-template <class R>
-void SPxBasisBase<R>::invalidate()
-{
-   if(factorized || matrixIsSetup)
-   {
-      MSG_INFO3((*this->spxout), (*this->spxout) << "ICHBAS09 explicit invalidation of factorization" <<
-                std::endl;)
-   }
-
-   factorized    = false;
-   matrixIsSetup = false;
+template <class R> void SPxBasisBase<R>::invalidate() {
+  if (factorized || matrixIsSetup) {
+    MSG_INFO3((*this->spxout),
+              (*this->spxout)
+                  << "ICHBAS09 explicit invalidation of factorization"
+                  << std::endl;)
+  }
+
+  factorized = false;
+  matrixIsSetup = false;
 }
 
 /**
- * Create the initial slack basis descriptor and set up the basis matrix accordingly.
- * This code has been adapted from SPxBasisBase<R>::addedRows() and SPxBasisBase<R>::addedCols().
+ * Create the initial slack basis descriptor and set up the basis matrix
+ * accordingly. This code has been adapted from SPxBasisBase<R>::addedRows() and
+ * SPxBasisBase<R>::addedCols().
  */
-template <class R>
-void SPxBasisBase<R>::restoreInitialBasis()
-{
-   assert(!factorized);
-
-   MSG_INFO3((*this->spxout), (*this->spxout) << "ICHBAS10 setup slack basis" << std::endl;)
-
-   if(theLP->rep() == SPxSolverBase<R>::COLUMN)
-   {
-      for(int i = 0; i < theLP->nRows(); ++i)
-      {
-         thedesc.rowStatus(i) = dualRowStatus(i);
-         baseId(i) = theLP->SPxLPBase<R>::rId(i);
-      }
-
-      for(int i = 0; i < theLP->nCols(); ++i)
-         thedesc.colStatus(i) = primalColStatus(i, theLP);
-   }
-   else
-   {
-      assert(theLP->rep() == SPxSolverBase<R>::ROW);
-
-      for(int i = 0; i < theLP->nRows(); ++i)
-         thedesc.rowStatus(i) = dualRowStatus(i);
-
-      for(int i = 0; i < theLP->nCols(); ++i)
-      {
-         thedesc.colStatus(i) = primalColStatus(i, theLP);
-         baseId(i) = theLP->SPxLPBase<R>::cId(i);
-      }
-   }
-
-   /* if matrix was set up, load new basis vectors to the matrix */
-   if(status() > NO_PROBLEM && matrixIsSetup)
-      loadMatrixVecs();
-
-   /* update basis status */
-   setStatus(REGULAR);
+template <class R> void SPxBasisBase<R>::restoreInitialBasis() {
+  assert(!factorized);
+
+  MSG_INFO3((*this->spxout), (*this->spxout)
+                                 << "ICHBAS10 setup slack basis" << std::endl;)
+
+  if (theLP->rep() == SPxSolverBase<R>::COLUMN) {
+    for (int i = 0; i < theLP->nRows(); ++i) {
+      thedesc.rowStatus(i) = dualRowStatus(i);
+      baseId(i) = theLP->SPxLPBase<R>::rId(i);
+    }
+
+    for (int i = 0; i < theLP->nCols(); ++i)
+      thedesc.colStatus(i) = primalColStatus(i, theLP);
+  } else {
+    assert(theLP->rep() == SPxSolverBase<R>::ROW);
+
+    for (int i = 0; i < theLP->nRows(); ++i)
+      thedesc.rowStatus(i) = dualRowStatus(i);
+
+    for (int i = 0; i < theLP->nCols(); ++i) {
+      thedesc.colStatus(i) = primalColStatus(i, theLP);
+      baseId(i) = theLP->SPxLPBase<R>::cId(i);
+    }
+  }
+
+  /* if matrix was set up, load new basis vectors to the matrix */
+  if (status() > NO_PROBLEM && matrixIsSetup)
+    loadMatrixVecs();
+
+  /* update basis status */
+  setStatus(REGULAR);
 }
 
 /**
@@ -488,37 +415,32 @@ void SPxBasisBase<R>::restoreInitialBasis()
  * way. For instance, the basis won't be singular (but maybe infeasible) if the
  * change doesn't affect the basis rows/columns.
  *
- * The following methods (changedRow(), changedCol(), changedElement()) radically
- * change the current basis to the original (slack) basis also present after
- * loading the LP. The reason is that through the changes, the current basis may
- * become singular. Going back to the initial basis is quite inefficient, but
- * correct.
+ * The following methods (changedRow(), changedCol(), changedElement())
+ * radically change the current basis to the original (slack) basis also present
+ * after loading the LP. The reason is that through the changes, the current
+ * basis may become singular. Going back to the initial basis is quite
+ * inefficient, but correct.
  */
 
 /**@todo is this correctly implemented?
  */
-template <class R>
-void SPxBasisBase<R>::changedRow(int /*row*/)
-{
-   invalidate();
-   restoreInitialBasis();
+template <class R> void SPxBasisBase<R>::changedRow(int /*row*/) {
+  invalidate();
+  restoreInitialBasis();
 }
 
 /**@todo is this correctly implemented?
  */
-template <class R>
-void SPxBasisBase<R>::changedCol(int /*col*/)
-{
-   invalidate();
-   restoreInitialBasis();
+template <class R> void SPxBasisBase<R>::changedCol(int /*col*/) {
+  invalidate();
+  restoreInitialBasis();
 }
 
 /**@todo is this correctly implemented?
  */
 template <class R>
-void SPxBasisBase<R>::changedElement(int /*row*/, int /*col*/)
-{
-   invalidate();
-   restoreInitialBasis();
+void SPxBasisBase<R>::changedElement(int /*row*/, int /*col*/) {
+  invalidate();
+  restoreInitialBasis();
 }
 } // namespace soplex
diff --git a/src/soplex/spxdantzigpr.hpp b/src/soplex/spxdantzigpr.hpp
index 35e8748..474f261 100644
--- a/src/soplex/spxdantzigpr.hpp
+++ b/src/soplex/spxdantzigpr.hpp
@@ -21,6 +21,7 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <assert.h>
 #include <iostream>
@@ -29,230 +30,195 @@
 
 #include "soplex/spxdefines.h"
 
-namespace soplex
-{
+namespace soplex {
 
-template <class R>
-int SPxDantzigPR<R>::selectLeave()
-{
-   assert(this->thesolver != 0);
-
-   if(this->thesolver->sparsePricingLeave)
-      return selectLeaveSparse();
-
-   //    const R* up  = this->thesolver->ubBound();
-   //    const R* low = this->thesolver->lbBound();
-
-   R best = -this->theeps;
-   int  n    = -1;
-
-   for(int i = this->thesolver->dim() - 1; i >= 0; --i)
-   {
-      R x = this->thesolver->fTest()[i];
-
-      if(x < -this->theeps)
-      {
-         // x *= EQ_PREF * (1 + (up[i] == low[i]));
-         if(x < best)
-         {
-            n    = i;
-            best = x;
-         }
-      }
-   }
+template <class R> int SPxDantzigPR<R>::selectLeave() {
+  assert(this->thesolver != 0);
 
-   return n;
-}
+  if (this->thesolver->sparsePricingLeave)
+    return selectLeaveSparse();
 
-template <class R>
-int SPxDantzigPR<R>::selectLeaveSparse()
-{
-   assert(this->thesolver != 0);
-
-   R best   = -this->theeps;
-   R x;
-   int  n      = -1;
-   int  index;
-
-   for(int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i)
-   {
-      index = this->thesolver->infeasibilities.index(i);
-      x = this->thesolver->fTest()[index];
-
-      if(x < -this->theeps)
-      {
-         if(x < best)
-         {
-            n    = index;
-            best = x;
-         }
-      }
-      else
-      {
-         this->thesolver->infeasibilities.remove(i);
-         assert(this->thesolver->isInfeasible[index] > 0);
-         this->thesolver->isInfeasible[index] = 0;
+  //    const R* up  = this->thesolver->ubBound();
+  //    const R* low = this->thesolver->lbBound();
+
+  R best = -this->theeps;
+  int n = -1;
+
+  for (int i = this->thesolver->dim() - 1; i >= 0; --i) {
+    R x = this->thesolver->fTest()[i];
+
+    if (x < -this->theeps) {
+      // x *= EQ_PREF * (1 + (up[i] == low[i]));
+      if (x < best) {
+        n = i;
+        best = x;
       }
-   }
+    }
+  }
 
-   return n;
+  return n;
 }
 
-template <class R>
-SPxId SPxDantzigPR<R>::selectEnter()
-{
-   assert(this->thesolver != 0);
+template <class R> int SPxDantzigPR<R>::selectLeaveSparse() {
+  assert(this->thesolver != 0);
 
-   // const SPxBasisBase<R>::Desc&    ds   = this->thesolver->basis().desc();
+  R best = -this->theeps;
+  R x;
+  int n = -1;
+  int index;
 
-   SPxId enterId;
-   enterId = selectEnterX();
+  for (int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i) {
+    index = this->thesolver->infeasibilities.index(i);
+    x = this->thesolver->fTest()[index];
 
-   return enterId;
+    if (x < -this->theeps) {
+      if (x < best) {
+        n = index;
+        best = x;
+      }
+    } else {
+      this->thesolver->infeasibilities.remove(i);
+      assert(this->thesolver->isInfeasible[index] > 0);
+      this->thesolver->isInfeasible[index] = 0;
+    }
+  }
+
+  return n;
 }
 
-template <class R>
-SPxId SPxDantzigPR<R>::selectEnterX()
-{
-   SPxId enterId;
-   SPxId enterIdCo;
-   R best;
-   R bestCo;
-
-   best = -this->theeps;
-   bestCo = -this->theeps;
-   enterId = (this->thesolver->sparsePricingEnter) ? selectEnterSparseDim(best,
-             enterId) : selectEnterDenseDim(best, enterId);
-   enterIdCo = (this->thesolver->sparsePricingEnterCo) ? selectEnterSparseCoDim(bestCo,
-               enterId) : selectEnterDenseCoDim(bestCo, enterId);
-
-   // prefer slack indices to reduce nonzeros in basis matrix
-   if(enterId.isValid() && (best > SPARSITY_TRADEOFF * bestCo || !enterIdCo.isValid()))
-      return enterId;
-   else
-      return enterIdCo;
+template <class R> SPxId SPxDantzigPR<R>::selectEnter() {
+  assert(this->thesolver != 0);
+
+  // const SPxBasisBase<R>::Desc&    ds   = this->thesolver->basis().desc();
+
+  SPxId enterId;
+  enterId = selectEnterX();
+
+  return enterId;
 }
 
+template <class R> SPxId SPxDantzigPR<R>::selectEnterX() {
+  SPxId enterId;
+  SPxId enterIdCo;
+  R best;
+  R bestCo;
+
+  best = -this->theeps;
+  bestCo = -this->theeps;
+  enterId = (this->thesolver->sparsePricingEnter)
+                ? selectEnterSparseDim(best, enterId)
+                : selectEnterDenseDim(best, enterId);
+  enterIdCo = (this->thesolver->sparsePricingEnterCo)
+                  ? selectEnterSparseCoDim(bestCo, enterId)
+                  : selectEnterDenseCoDim(bestCo, enterId);
+
+  // prefer slack indices to reduce nonzeros in basis matrix
+  if (enterId.isValid() &&
+      (best > SPARSITY_TRADEOFF * bestCo || !enterIdCo.isValid()))
+    return enterId;
+  else
+    return enterIdCo;
+}
 
 template <class R>
-SPxId SPxDantzigPR<R>::selectEnterSparseDim(R& best, SPxId& enterId)
-{
-   assert(this->thesolver != 0);
-
-   int idx;
-   R x;
-
-   for(int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->infeasibilities.index(i);
-      x = this->thesolver->coTest()[idx];
-
-      if(x < -this->theeps)
-      {
-         // x *= EQ_PREF * (1 + (ds.coStatus(i) == SPxBasisBase<R>::Desc::P_FREE
-         //                || ds.coStatus(i) == SPxBasisBase<R>::Desc::D_FREE));
-         if(x < best)
-         {
-            enterId = this->thesolver->coId(idx);
-            best = x;
-         }
+SPxId SPxDantzigPR<R>::selectEnterSparseDim(R &best, SPxId &enterId) {
+  assert(this->thesolver != 0);
+
+  int idx;
+  R x;
+
+  for (int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->infeasibilities.index(i);
+    x = this->thesolver->coTest()[idx];
+
+    if (x < -this->theeps) {
+      // x *= EQ_PREF * (1 + (ds.coStatus(i) == SPxBasisBase<R>::Desc::P_FREE
+      //                || ds.coStatus(i) == SPxBasisBase<R>::Desc::D_FREE));
+      if (x < best) {
+        enterId = this->thesolver->coId(idx);
+        best = x;
       }
-      else
-      {
-         this->thesolver->infeasibilities.remove(i);
+    } else {
+      this->thesolver->infeasibilities.remove(i);
 
-         assert(this->thesolver->isInfeasible[idx]);
-         this->thesolver->isInfeasible[idx] = 0;
-      }
-   }
+      assert(this->thesolver->isInfeasible[idx]);
+      this->thesolver->isInfeasible[idx] = 0;
+    }
+  }
 
-   return enterId;
+  return enterId;
 }
 
 template <class R>
-SPxId SPxDantzigPR<R>::selectEnterSparseCoDim(R& best, SPxId& enterId)
-{
-   assert(this->thesolver != 0);
-
-   int idx;
-   R x;
-
-   for(int i = this->thesolver->infeasibilitiesCo.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->infeasibilitiesCo.index(i);
-      x = this->thesolver->test()[idx];
-
-      if(x < -this->theeps)
-      {
-         // x *= EQ_PREF * (1 + (ds.coStatus(i) == SPxBasisBase<R>::Desc::P_FREE
-         //                || ds.coStatus(i) == SPxBasisBase<R>::Desc::D_FREE));
-         if(x < best)
-         {
-            enterId = this->thesolver->id(idx);
-            best = x;
-         }
-      }
-      else
-      {
-         this->thesolver->infeasibilitiesCo.remove(i);
-         assert(this->thesolver->isInfeasibleCo[idx] > 0);
-         this->thesolver->isInfeasibleCo[idx] = 0;
+SPxId SPxDantzigPR<R>::selectEnterSparseCoDim(R &best, SPxId &enterId) {
+  assert(this->thesolver != 0);
+
+  int idx;
+  R x;
+
+  for (int i = this->thesolver->infeasibilitiesCo.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->infeasibilitiesCo.index(i);
+    x = this->thesolver->test()[idx];
+
+    if (x < -this->theeps) {
+      // x *= EQ_PREF * (1 + (ds.coStatus(i) == SPxBasisBase<R>::Desc::P_FREE
+      //                || ds.coStatus(i) == SPxBasisBase<R>::Desc::D_FREE));
+      if (x < best) {
+        enterId = this->thesolver->id(idx);
+        best = x;
       }
-   }
-
-   return enterId;
+    } else {
+      this->thesolver->infeasibilitiesCo.remove(i);
+      assert(this->thesolver->isInfeasibleCo[idx] > 0);
+      this->thesolver->isInfeasibleCo[idx] = 0;
+    }
+  }
+
+  return enterId;
 }
 
 template <class R>
-SPxId SPxDantzigPR<R>::selectEnterDenseDim(R& best, SPxId& enterId)
-{
-   assert(this->thesolver != 0);
-
-   R x;
-
-   for(int i = this->thesolver->dim() - 1; i >= 0; --i)
-   {
-      x = this->thesolver->coTest()[i];
-
-      if(x < -this->theeps)
-      {
-         // x *= EQ_PREF * (1 + (ds.coStatus(i) == SPxBasisBase<R>::Desc::P_FREE
-         //                || ds.coStatus(i) == SPxBasisBase<R>::Desc::D_FREE));
-         if(x < best)
-         {
-            enterId   = this->thesolver->coId(i);
-            best = x;
-         }
+SPxId SPxDantzigPR<R>::selectEnterDenseDim(R &best, SPxId &enterId) {
+  assert(this->thesolver != 0);
+
+  R x;
+
+  for (int i = this->thesolver->dim() - 1; i >= 0; --i) {
+    x = this->thesolver->coTest()[i];
+
+    if (x < -this->theeps) {
+      // x *= EQ_PREF * (1 + (ds.coStatus(i) == SPxBasisBase<R>::Desc::P_FREE
+      //                || ds.coStatus(i) == SPxBasisBase<R>::Desc::D_FREE));
+      if (x < best) {
+        enterId = this->thesolver->coId(i);
+        best = x;
       }
-   }
+    }
+  }
 
-   return enterId;
+  return enterId;
 }
 
 template <class R>
-SPxId SPxDantzigPR<R>::selectEnterDenseCoDim(R& best, SPxId& enterId)
-{
-   assert(this->thesolver != 0);
-
-   R x;
-
-   for(int i = this->thesolver->coDim() - 1; i >= 0; --i)
-   {
-      x = this->thesolver->test()[i];
-
-      if(x < -this->theeps)
-      {
-         // x *= EQ_PREF * (1 + (ds.status(i) == SPxBasisBase<R>::Desc::P_FREE
-         //                || ds.status(i) == SPxBasisBase<R>::Desc::D_FREE));
-         if(x < best)
-         {
-            enterId   = this->thesolver->id(i);
-            best = x;
-         }
+SPxId SPxDantzigPR<R>::selectEnterDenseCoDim(R &best, SPxId &enterId) {
+  assert(this->thesolver != 0);
+
+  R x;
+
+  for (int i = this->thesolver->coDim() - 1; i >= 0; --i) {
+    x = this->thesolver->test()[i];
+
+    if (x < -this->theeps) {
+      // x *= EQ_PREF * (1 + (ds.status(i) == SPxBasisBase<R>::Desc::P_FREE
+      //                || ds.status(i) == SPxBasisBase<R>::Desc::D_FREE));
+      if (x < best) {
+        enterId = this->thesolver->id(i);
+        best = x;
       }
-   }
+    }
+  }
 
-   return enterId;
+  return enterId;
 }
 
 } // namespace soplex
diff --git a/src/soplex/spxdefaultrt.hpp b/src/soplex/spxdefaultrt.hpp
index ec14eda..7c23ca1 100644
--- a/src/soplex/spxdefaultrt.hpp
+++ b/src/soplex/spxdefaultrt.hpp
@@ -21,14 +21,14 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <assert.h>
 #include <iostream>
 
 #include "soplex/spxdefines.h"
 
-namespace soplex
-{
+namespace soplex {
 /**
  * Here comes the ratio test for selecting a variable to leave the basis.
  * It is assumed that Vec.delta() and fVec.idx() have been setup
@@ -45,370 +45,297 @@ namespace soplex
  * basis selected to leave the basis. -1 indicates that no variable could be
  * selected. Otherwise, parameter \p val contains the chosen fVec.value().
  */
-template <class R>
-int SPxDefaultRT<R>::selectLeave(R& val, R, bool)
-{
-   this->solver()->fVec().delta().setup();
-
-   const R*   vec = this->solver()->fVec().get_const_ptr();
-   const R*   upd = this->solver()->fVec().delta().values();
-   const IdxSet& idx = this->solver()->fVec().idx();
-   const R*   ub  = this->solver()->ubBound().get_const_ptr();
-   const R*   lb  = this->solver()->lbBound().get_const_ptr();
-
-   R epsilon = this->solver()->epsilon();
-   int  leave   = -1;
-
-   R x;
-   int  i;
-   int  j;
-
-   // PARALLEL the j loop could be parallelized
-   if(val > 0)
-   {
-      // Loop over NZEs of delta vector.
-      for(j = 0; j < idx.size(); ++j)
-      {
-         i = idx.index(j);
-         x = upd[i];
-
-         if(x > epsilon)
-         {
-            if(ub[i] < R(infinity))
-            {
-               R y = (ub[i] - vec[i] + this->delta) / x;
-
-               if(y < val)
-               {
-                  leave = i;
-                  val   = y;
-               }
-            }
-         }
-         else if(x < -epsilon)
-         {
-            if(lb[i] > R(-infinity))
-            {
-               R y = (lb[i] - vec[i] - this->delta) / x;
-
-               if(y < val)
-               {
-                  leave = i;
-                  val   = y;
-               }
-            }
-         }
+template <class R> int SPxDefaultRT<R>::selectLeave(R &val, R, bool) {
+  this->solver()->fVec().delta().setup();
+
+  const R *vec = this->solver()->fVec().get_const_ptr();
+  const R *upd = this->solver()->fVec().delta().values();
+  const IdxSet &idx = this->solver()->fVec().idx();
+  const R *ub = this->solver()->ubBound().get_const_ptr();
+  const R *lb = this->solver()->lbBound().get_const_ptr();
+
+  R epsilon = this->solver()->epsilon();
+  int leave = -1;
+
+  R x;
+  int i;
+  int j;
+
+  // PARALLEL the j loop could be parallelized
+  if (val > 0) {
+    // Loop over NZEs of delta vector.
+    for (j = 0; j < idx.size(); ++j) {
+      i = idx.index(j);
+      x = upd[i];
+
+      if (x > epsilon) {
+        if (ub[i] < R(infinity)) {
+          R y = (ub[i] - vec[i] + this->delta) / x;
+
+          if (y < val) {
+            leave = i;
+            val = y;
+          }
+        }
+      } else if (x < -epsilon) {
+        if (lb[i] > R(-infinity)) {
+          R y = (lb[i] - vec[i] - this->delta) / x;
+
+          if (y < val) {
+            leave = i;
+            val = y;
+          }
+        }
       }
-
-      if(leave >= 0)
-      {
-         x   = upd[leave];
-
-         // BH 2005-11-30: It may well happen that the basis is degenerate and the
-         // selected leaving variable is (at most this->delta) beyond its bound. (This
-         // happens for instance on LP/netlib/adlittle.mps with setting -r -t0.)
-         // In that case we do a pivot step with length zero to avoid difficulties.
-         if((x > epsilon  && vec[leave] >= ub[leave]) ||
-               (x < -epsilon && vec[leave] <= lb[leave]))
-         {
-            val = 0.0;
-         }
-         else
-         {
-            val = (x > epsilon) ? ub[leave] : lb[leave];
-            val = (val - vec[leave]) / x;
-         }
+    }
+
+    if (leave >= 0) {
+      x = upd[leave];
+
+      // BH 2005-11-30: It may well happen that the basis is degenerate and the
+      // selected leaving variable is (at most this->delta) beyond its bound.
+      // (This happens for instance on LP/netlib/adlittle.mps with setting -r
+      // -t0.) In that case we do a pivot step with length zero to avoid
+      // difficulties.
+      if ((x > epsilon && vec[leave] >= ub[leave]) ||
+          (x < -epsilon && vec[leave] <= lb[leave])) {
+        val = 0.0;
+      } else {
+        val = (x > epsilon) ? ub[leave] : lb[leave];
+        val = (val - vec[leave]) / x;
       }
-
-      ASSERT_WARN("WDEFRT01", val > -epsilon);
-   }
-   else
-   {
-      for(j = 0; j < idx.size(); ++j)
-      {
-         i = idx.index(j);
-         x = upd[i];
-
-         if(x < -epsilon)
-         {
-            if(ub[i] < R(infinity))
-            {
-               R y = (ub[i] - vec[i] + this->delta) / x;
-
-               if(y > val)
-               {
-                  leave = i;
-                  val   = y;
-               }
-            }
-         }
-         else if(x > epsilon)
-         {
-            if(lb[i] > R(-infinity))
-            {
-               R y = (lb[i] - vec[i] - this->delta) / x;
-
-               if(y > val)
-               {
-                  leave = i;
-                  val   = y;
-               }
-            }
-         }
+    }
+
+    ASSERT_WARN("WDEFRT01", val > -epsilon);
+  } else {
+    for (j = 0; j < idx.size(); ++j) {
+      i = idx.index(j);
+      x = upd[i];
+
+      if (x < -epsilon) {
+        if (ub[i] < R(infinity)) {
+          R y = (ub[i] - vec[i] + this->delta) / x;
+
+          if (y > val) {
+            leave = i;
+            val = y;
+          }
+        }
+      } else if (x > epsilon) {
+        if (lb[i] > R(-infinity)) {
+          R y = (lb[i] - vec[i] - this->delta) / x;
+
+          if (y > val) {
+            leave = i;
+            val = y;
+          }
+        }
       }
-
-      if(leave >= 0)
-      {
-         x   = upd[leave];
-
-         // See comment above.
-         if((x < -epsilon && vec[leave] >= ub[leave]) ||
-               (x > epsilon  && vec[leave] <= lb[leave]))
-         {
-            val = 0.0;
-         }
-         else
-         {
-            val = (x < epsilon) ? ub[leave] : lb[leave];
-            val = (val - vec[leave]) / x;
-         }
+    }
+
+    if (leave >= 0) {
+      x = upd[leave];
+
+      // See comment above.
+      if ((x < -epsilon && vec[leave] >= ub[leave]) ||
+          (x > epsilon && vec[leave] <= lb[leave])) {
+        val = 0.0;
+      } else {
+        val = (x < epsilon) ? ub[leave] : lb[leave];
+        val = (val - vec[leave]) / x;
       }
+    }
 
-      ASSERT_WARN("WDEFRT02", val < epsilon);
-   }
+    ASSERT_WARN("WDEFRT02", val < epsilon);
+  }
 
-   return leave;
+  return leave;
 }
 
 /**
    Here comes the ratio test. It is assumed that theCoPvec.this->delta() and
    theCoPvec.idx() have been setup correctly!
 */
-template <class R>
-SPxId SPxDefaultRT<R>::selectEnter(R& max, int, bool)
-{
-   this->solver()->coPvec().delta().setup();
-   this->solver()->pVec().delta().setup();
-
-   const R*   pvec = this->solver()->pVec().get_const_ptr();
-   const R*   pupd = this->solver()->pVec().delta().values();
-   const IdxSet& pidx = this->solver()->pVec().idx();
-   const R*   lpb  = this->solver()->lpBound().get_const_ptr();
-   const R*   upb  = this->solver()->upBound().get_const_ptr();
-
-   const R*   cvec = this->solver()->coPvec().get_const_ptr();
-   const R*   cupd = this->solver()->coPvec().delta().values();
-   const IdxSet& cidx = this->solver()->coPvec().idx();
-   const R*   lcb  = this->solver()->lcBound().get_const_ptr();
-   const R*   ucb  = this->solver()->ucBound().get_const_ptr();
-
-   R epsilon = this->solver()->epsilon();
-   R val     = max;
-   int  pnum    = -1;
-   int  cnum    = -1;
-
-   SPxId enterId;
-   int   i;
-   int   j;
-   R  x;
-
-   // PARALLEL the j loops could be parallelized
-   if(val > 0)
-   {
-      for(j = 0; j < pidx.size(); ++j)
-      {
-         i = pidx.index(j);
-         x = pupd[i];
-
-         if(x > epsilon)
-         {
-            if(upb[i] < R(infinity))
-            {
-               R y = (upb[i] - pvec[i] + this->delta) / x;
-
-               if(y < val)
-               {
-                  enterId = this->solver()->id(i);
-                  val     = y;
-                  pnum    = j;
-               }
-            }
-         }
-         else if(x < -epsilon)
-         {
-            if(lpb[i] > R(-infinity))
-            {
-               R y = (lpb[i] - pvec[i] - this->delta) / x;
-
-               if(y < val)
-               {
-                  enterId = this->solver()->id(i);
-                  val     = y;
-                  pnum    = j;
-               }
-            }
-         }
+template <class R> SPxId SPxDefaultRT<R>::selectEnter(R &max, int, bool) {
+  this->solver()->coPvec().delta().setup();
+  this->solver()->pVec().delta().setup();
+
+  const R *pvec = this->solver()->pVec().get_const_ptr();
+  const R *pupd = this->solver()->pVec().delta().values();
+  const IdxSet &pidx = this->solver()->pVec().idx();
+  const R *lpb = this->solver()->lpBound().get_const_ptr();
+  const R *upb = this->solver()->upBound().get_const_ptr();
+
+  const R *cvec = this->solver()->coPvec().get_const_ptr();
+  const R *cupd = this->solver()->coPvec().delta().values();
+  const IdxSet &cidx = this->solver()->coPvec().idx();
+  const R *lcb = this->solver()->lcBound().get_const_ptr();
+  const R *ucb = this->solver()->ucBound().get_const_ptr();
+
+  R epsilon = this->solver()->epsilon();
+  R val = max;
+  int pnum = -1;
+  int cnum = -1;
+
+  SPxId enterId;
+  int i;
+  int j;
+  R x;
+
+  // PARALLEL the j loops could be parallelized
+  if (val > 0) {
+    for (j = 0; j < pidx.size(); ++j) {
+      i = pidx.index(j);
+      x = pupd[i];
+
+      if (x > epsilon) {
+        if (upb[i] < R(infinity)) {
+          R y = (upb[i] - pvec[i] + this->delta) / x;
+
+          if (y < val) {
+            enterId = this->solver()->id(i);
+            val = y;
+            pnum = j;
+          }
+        }
+      } else if (x < -epsilon) {
+        if (lpb[i] > R(-infinity)) {
+          R y = (lpb[i] - pvec[i] - this->delta) / x;
+
+          if (y < val) {
+            enterId = this->solver()->id(i);
+            val = y;
+            pnum = j;
+          }
+        }
       }
-
-      for(j = 0; j < cidx.size(); ++j)
-      {
-         i = cidx.index(j);
-         x = cupd[i];
-
-         if(x > epsilon)
-         {
-            if(ucb[i] < R(infinity))
-            {
-               R y = (ucb[i] - cvec[i] + this->delta) / x;
-
-               if(y < val)
-               {
-                  enterId = this->solver()->coId(i);
-                  val     = y;
-                  cnum    = j;
-               }
-            }
-         }
-         else if(x < -epsilon)
-         {
-            if(lcb[i] > R(-infinity))
-            {
-               R y = (lcb[i] - cvec[i] - this->delta) / x;
-
-               if(y < val)
-               {
-                  enterId = this->solver()->coId(i);
-                  val     = y;
-                  cnum    = j;
-               }
-            }
-         }
+    }
+
+    for (j = 0; j < cidx.size(); ++j) {
+      i = cidx.index(j);
+      x = cupd[i];
+
+      if (x > epsilon) {
+        if (ucb[i] < R(infinity)) {
+          R y = (ucb[i] - cvec[i] + this->delta) / x;
+
+          if (y < val) {
+            enterId = this->solver()->coId(i);
+            val = y;
+            cnum = j;
+          }
+        }
+      } else if (x < -epsilon) {
+        if (lcb[i] > R(-infinity)) {
+          R y = (lcb[i] - cvec[i] - this->delta) / x;
+
+          if (y < val) {
+            enterId = this->solver()->coId(i);
+            val = y;
+            cnum = j;
+          }
+        }
       }
-
-      if(cnum >= 0)
-      {
-         i   = cidx.index(cnum);
-         x   = cupd[i];
-         val = (x > epsilon) ? ucb[i] : lcb[i];
-         val = (val - cvec[i]) / x;
+    }
+
+    if (cnum >= 0) {
+      i = cidx.index(cnum);
+      x = cupd[i];
+      val = (x > epsilon) ? ucb[i] : lcb[i];
+      val = (val - cvec[i]) / x;
+    } else if (pnum >= 0) {
+      i = pidx.index(pnum);
+      x = pupd[i];
+      val = (x > epsilon) ? upb[i] : lpb[i];
+      val = (val - pvec[i]) / x;
+    }
+  } else {
+    for (j = 0; j < pidx.size(); ++j) {
+      i = pidx.index(j);
+      x = pupd[i];
+
+      if (x > epsilon) {
+        if (lpb[i] > R(-infinity)) {
+          R y = (lpb[i] - pvec[i] - this->delta) / x;
+
+          if (y > val) {
+            enterId = this->solver()->id(i);
+            val = y;
+            pnum = j;
+          }
+        }
+      } else if (x < -epsilon) {
+        if (upb[i] < R(infinity)) {
+          R y = (upb[i] - pvec[i] + this->delta) / x;
+
+          if (y > val) {
+            enterId = this->solver()->id(i);
+            val = y;
+            pnum = j;
+          }
+        }
       }
-      else if(pnum >= 0)
-      {
-         i   = pidx.index(pnum);
-         x   = pupd[i];
-         val = (x > epsilon) ? upb[i] : lpb[i];
-         val = (val - pvec[i]) / x;
+    }
+
+    for (j = 0; j < cidx.size(); ++j) {
+      i = cidx.index(j);
+      x = cupd[i];
+
+      if (x > epsilon) {
+        if (lcb[i] > R(-infinity)) {
+          R y = (lcb[i] - cvec[i] - this->delta) / x;
+
+          if (y > val) {
+            enterId = this->solver()->coId(i);
+            val = y;
+            cnum = j;
+          }
+        }
+      } else if (x < -epsilon) {
+        if (ucb[i] < R(infinity)) {
+          R y = (ucb[i] - cvec[i] + this->delta) / x;
+
+          if (y > val) {
+            enterId = this->solver()->coId(i);
+            val = y;
+            cnum = j;
+          }
+        }
       }
-   }
-   else
-   {
-      for(j = 0; j < pidx.size(); ++j)
-      {
-         i = pidx.index(j);
-         x = pupd[i];
-
-         if(x > epsilon)
-         {
-            if(lpb[i] > R(-infinity))
-            {
-               R y = (lpb[i] - pvec[i] - this->delta) / x;
-
-               if(y > val)
-               {
-                  enterId = this->solver()->id(i);
-                  val     = y;
-                  pnum    = j;
-               }
-            }
-         }
-         else if(x < -epsilon)
-         {
-            if(upb[i] < R(infinity))
-            {
-               R y = (upb[i] - pvec[i] + this->delta) / x;
-
-               if(y > val)
-               {
-                  enterId = this->solver()->id(i);
-                  val     = y;
-                  pnum    = j;
-               }
-            }
-         }
-      }
-
-      for(j = 0; j < cidx.size(); ++j)
-      {
-         i = cidx.index(j);
-         x = cupd[i];
-
-         if(x > epsilon)
-         {
-            if(lcb[i] > R(-infinity))
-            {
-               R y = (lcb[i] - cvec[i] - this->delta) / x;
-
-               if(y > val)
-               {
-                  enterId = this->solver()->coId(i);
-                  val     = y;
-                  cnum    = j;
-               }
-            }
-         }
-         else if(x < -epsilon)
-         {
-            if(ucb[i] < R(infinity))
-            {
-               R y = (ucb[i] - cvec[i] + this->delta) / x;
-
-               if(y > val)
-               {
-                  enterId = this->solver()->coId(i);
-                  val     = y;
-                  cnum    = j;
-               }
-            }
-         }
-      }
-
-      if(cnum >= 0)
-      {
-         i   = cidx.index(cnum);
-         x   = cupd[i];
-         val = (x < epsilon) ? ucb[i] : lcb[i];
-         val = (val - cvec[i]) / x;
-      }
-      else if(pnum >= 0)
-      {
-         i   = pidx.index(pnum);
-         x   = pupd[i];
-         val = (x < epsilon) ? upb[i] : lpb[i];
-         val = (val - pvec[i]) / x;
-      }
-   }
-
-   if(enterId.isValid() && this->solver()->isBasic(enterId))
-   {
-      MSG_DEBUG(std::cout << "DDEFRT01 isValid() && isBasic(): max=" << max
-                << std::endl;)
-
-      if(cnum >= 0)
-         this->solver()->coPvec().delta().clearNum(cnum);
-      else if(pnum >= 0)
-         this->solver()->pVec().delta().clearNum(pnum);
-
-      return SPxDefaultRT<R>::selectEnter(max, 0, false);
-   }
-
-   MSG_DEBUG(
-
-      if(!enterId.isValid())
-      std::cout << "DDEFRT02 !isValid(): max=" << max << ", x=" << x << std::endl;
-   )
-      max = val;
-
-   return enterId;
+    }
+
+    if (cnum >= 0) {
+      i = cidx.index(cnum);
+      x = cupd[i];
+      val = (x < epsilon) ? ucb[i] : lcb[i];
+      val = (val - cvec[i]) / x;
+    } else if (pnum >= 0) {
+      i = pidx.index(pnum);
+      x = pupd[i];
+      val = (x < epsilon) ? upb[i] : lpb[i];
+      val = (val - pvec[i]) / x;
+    }
+  }
+
+  if (enterId.isValid() && this->solver()->isBasic(enterId)) {
+    MSG_DEBUG(std::cout << "DDEFRT01 isValid() && isBasic(): max=" << max
+                        << std::endl;)
+
+    if (cnum >= 0)
+      this->solver()->coPvec().delta().clearNum(cnum);
+    else if (pnum >= 0)
+      this->solver()->pVec().delta().clearNum(pnum);
+
+    return SPxDefaultRT<R>::selectEnter(max, 0, false);
+  }
+
+  MSG_DEBUG(
+
+      if (!enterId.isValid()) std::cout << "DDEFRT02 !isValid(): max=" << max
+                                        << ", x=" << x << std::endl;)
+  max = val;
+
+  return enterId;
 }
 
 } // namespace soplex
diff --git a/src/soplex/spxdefines.hpp b/src/soplex/spxdefines.hpp
index 78ad9f9..3b8ed12 100644
--- a/src/soplex/spxdefines.hpp
+++ b/src/soplex/spxdefines.hpp
@@ -21,6 +21,7 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 /**@file  spxdefines.hpp
  * @brief General templated functions for SoPlex
@@ -29,8 +30,7 @@
 // Defining the static members of the Param class
 // THREADLOCAL is a #define to thread_local. (Is it really needed?)
 
-namespace soplex
-{
+namespace soplex {
 
 //   template <class R>
 // THREADLOCAL R Param::s_epsilon               = DEFAULT_EPS_ZERO;
@@ -44,114 +44,85 @@ namespace soplex
 //   template <class R>
 // THREADLOCAL R Param::s_epsilon_pivot         = DEFAULT_EPS_PIVOT;
 
-
 /// returns \c true iff |a-b| <= eps
-template <class R, class S>
-inline bool EQ(R a, S b, R eps = Param::epsilon())
-{
-   return spxAbs(R(a - b)) <= eps;
+template <class R, class S> inline bool EQ(R a, S b, R eps = Param::epsilon()) {
+  return spxAbs(R(a - b)) <= eps;
 }
 
 /// returns \c true iff |a-b| > eps
-template <class R, class S>
-inline bool NE(R a, S b, R eps = Param::epsilon())
-{
-   return spxAbs(a - b) > eps;
+template <class R, class S> inline bool NE(R a, S b, R eps = Param::epsilon()) {
+  return spxAbs(a - b) > eps;
 }
 
 /// returns \c true iff a < b + eps
-template <class R, class S>
-inline bool LT(R a, S b, R eps = Param::epsilon())
-{
-   return (a - b) < -eps;
+template <class R, class S> inline bool LT(R a, S b, R eps = Param::epsilon()) {
+  return (a - b) < -eps;
 }
 
 /// returns \c true iff a <= b + eps
-template <class R, class S>
-inline bool LE(R a, S b, R eps = Param::epsilon())
-{
-   return (a - b) < eps;
+template <class R, class S> inline bool LE(R a, S b, R eps = Param::epsilon()) {
+  return (a - b) < eps;
 }
 
 /// returns \c true iff a > b + eps
-template <class R, class S>
-inline bool GT(R a, S b, R eps = Param::epsilon())
-{
-   return (a - b) > eps;
+template <class R, class S> inline bool GT(R a, S b, R eps = Param::epsilon()) {
+  return (a - b) > eps;
 }
 
 /// returns \c true iff a >= b + eps
-template <class R, class S>
-inline bool GE(R a, S b, R eps = Param::epsilon())
-{
-   return (a - b) > -eps;
+template <class R, class S> inline bool GE(R a, S b, R eps = Param::epsilon()) {
+  return (a - b) > -eps;
 }
 
 /// returns \c true iff |a| <= eps
-template <class R>
-inline bool isZero(R a, R eps = Param::epsilon())
-{
-   return spxAbs(a) <= eps;
+template <class R> inline bool isZero(R a, R eps = Param::epsilon()) {
+  return spxAbs(a) <= eps;
 }
 
 /// returns \c true iff |a| > eps
-template <class R>
-inline bool isNotZero(R a, R eps = Param::epsilon())
-{
-   return spxAbs(a) > eps;
+template <class R> inline bool isNotZero(R a, R eps = Param::epsilon()) {
+  return spxAbs(a) > eps;
 }
 
 /// returns \c true iff |relDiff(a,b)| <= eps
 template <class R, class S>
-inline bool EQrel(R a, S b, R eps = Param::epsilon())
-{
-   return spxAbs(relDiff(a, b)) <= eps;
+inline bool EQrel(R a, S b, R eps = Param::epsilon()) {
+  return spxAbs(relDiff(a, b)) <= eps;
 }
 
 /// returns \c true iff |relDiff(a,b)| > eps
 template <class R, class S>
-inline bool NErel(R a, S b, R eps = Param::epsilon())
-{
-   return spxAbs(relDiff(a, b)) > eps;
+inline bool NErel(R a, S b, R eps = Param::epsilon()) {
+  return spxAbs(relDiff(a, b)) > eps;
 }
 
 /// returns \c true iff relDiff(a,b) <= -eps
 template <class R, class S>
-inline bool LTrel(R a, S b, R eps = Param::epsilon())
-{
-   return relDiff(a, b) <= -eps;
+inline bool LTrel(R a, S b, R eps = Param::epsilon()) {
+  return relDiff(a, b) <= -eps;
 }
 
 /// returns \c true iff relDiff(a,b) <= eps
 template <class R, class S>
-inline bool LErel(R a, S b, R eps = Param::epsilon())
-{
-   return relDiff(a, b) <= eps;
+inline bool LErel(R a, S b, R eps = Param::epsilon()) {
+  return relDiff(a, b) <= eps;
 }
 
 /// returns \c true iff relDiff(a,b) > eps
 template <class R, class S>
-inline bool GTrel(R a, S b, R eps = Param::epsilon())
-{
-   return relDiff(a, b) > eps;
+inline bool GTrel(R a, S b, R eps = Param::epsilon()) {
+  return relDiff(a, b) > eps;
 }
 
 /// returns \c true iff relDiff(a,b) > -eps
 template <class R, class S>
-inline bool GErel(R a, S b, R eps = Param::epsilon())
-{
-   return relDiff(a, b) > -eps;
+inline bool GErel(R a, S b, R eps = Param::epsilon()) {
+  return relDiff(a, b) > -eps;
 }
 
 // Instantiation for Real
-inline Real spxLdexp(Real x, int exp)
-{
-   return std::ldexp(x, exp);
-}
+inline Real spxLdexp(Real x, int exp) { return std::ldexp(x, exp); }
 
-inline Real spxFrexp(Real x, int* exp)
-{
-   return std::frexp(x, exp);
-}
+inline Real spxFrexp(Real x, int *exp) { return std::frexp(x, exp); }
 
 } // namespace soplex
diff --git a/src/soplex/spxdesc.hpp b/src/soplex/spxdesc.hpp
index 8618556..59171d0 100644
--- a/src/soplex/spxdesc.hpp
+++ b/src/soplex/spxdesc.hpp
@@ -21,192 +21,170 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <iostream>
 
 #include "soplex/spxdefines.h"
 #include "soplex/spxsolver.h"
 
-namespace soplex
-{
+namespace soplex {
+
+template <class R> SPxBasisBase<R>::Desc::Desc(const SPxSolverBase<R> &base) {
+  reSize(base.nRows(), base.nCols());
+
+  if (base.rep() == SPxSolverBase<R>::ROW) {
+    stat = &rowstat;
+    costat = &colstat;
+  } else {
+    assert(base.rep() == SPxSolverBase<R>::COLUMN);
+
+    stat = &colstat;
+    costat = &rowstat;
+  }
+
+  assert(Desc::isConsistent());
+}
 
 template <class R>
-SPxBasisBase<R>::Desc::Desc(const SPxSolverBase<R>& base)
-{
-   reSize(base.nRows(), base.nCols());
+SPxBasisBase<R>::Desc::Desc(const Desc &old)
+    : rowstat(old.rowstat), colstat(old.colstat) {
+  if (old.stat == &old.rowstat) {
+    assert(old.costat == &old.colstat);
 
-   if(base.rep() == SPxSolverBase<R>::ROW)
-   {
-      stat   = &rowstat;
-      costat = &colstat;
-   }
-   else
-   {
-      assert(base.rep() == SPxSolverBase<R>::COLUMN);
+    stat = &rowstat;
+    costat = &colstat;
+  } else {
+    assert(old.costat == &old.rowstat);
 
-      stat   = &colstat;
-      costat = &rowstat;
-   }
+    stat = &colstat;
+    costat = &rowstat;
+  }
 
-   assert(Desc::isConsistent());
+  assert(Desc::isConsistent());
 }
 
 template <class R>
-SPxBasisBase<R>::Desc::Desc(const Desc& old)
-   : rowstat(old.rowstat)
-   , colstat(old.colstat)
-{
-   if(old.stat == &old.rowstat)
-   {
-      assert(old.costat == &old.colstat);
-
-      stat   = &rowstat;
+typename SPxBasisBase<R>::Desc &
+SPxBasisBase<R>::Desc::operator=(const typename SPxBasisBase<R>::Desc &rhs) {
+  if (this != &rhs) {
+    rowstat = rhs.rowstat;
+    colstat = rhs.colstat;
+
+    if (rhs.stat == &rhs.rowstat) {
+      assert(rhs.costat == &rhs.colstat);
+
+      stat = &rowstat;
       costat = &colstat;
-   }
-   else
-   {
-      assert(old.costat == &old.rowstat);
+    } else {
+      assert(rhs.costat == &rhs.rowstat);
 
-      stat   = &colstat;
+      stat = &colstat;
       costat = &rowstat;
-   }
+    }
 
-   assert(Desc::isConsistent());
-}
+    assert(Desc::isConsistent());
+  }
 
-template <class R>
-typename SPxBasisBase<R>::Desc& SPxBasisBase<R>::Desc::operator=(const typename
-      SPxBasisBase<R>::Desc& rhs)
-{
-   if(this != &rhs)
-   {
-      rowstat = rhs.rowstat;
-      colstat = rhs.colstat;
-
-      if(rhs.stat == &rhs.rowstat)
-      {
-         assert(rhs.costat == &rhs.colstat);
-
-         stat   = &rowstat;
-         costat = &colstat;
-      }
-      else
-      {
-         assert(rhs.costat == &rhs.rowstat);
-
-         stat   = &colstat;
-         costat = &rowstat;
-      }
-
-      assert(Desc::isConsistent());
-   }
-
-   return *this;
+  return *this;
 }
 
-template <class R>
-void SPxBasisBase<R>::Desc::reSize(int rowDim, int colDim)
-{
+template <class R> void SPxBasisBase<R>::Desc::reSize(int rowDim, int colDim) {
 
-   assert(rowDim >= 0);
-   assert(colDim >= 0);
+  assert(rowDim >= 0);
+  assert(colDim >= 0);
 
-   int noldrows = rowstat.size();
-   int noldcols = colstat.size();
+  int noldrows = rowstat.size();
+  int noldcols = colstat.size();
 
-   rowstat.reSize(rowDim);
-   colstat.reSize(colDim);
+  rowstat.reSize(rowDim);
+  colstat.reSize(colDim);
 
-   for(int i = rowDim - 1; i >= noldrows; i--)
-      rowstat[i] = D_UNDEFINED;
+  for (int i = rowDim - 1; i >= noldrows; i--)
+    rowstat[i] = D_UNDEFINED;
 
-   for(int i = colDim - 1; i >= noldcols; i--)
-      colstat[i] = D_UNDEFINED;
+  for (int i = colDim - 1; i >= noldcols; i--)
+    colstat[i] = D_UNDEFINED;
 }
 
-template <class R>
-void SPxBasisBase<R>::Desc::dump() const
-{
-   int i;
+template <class R> void SPxBasisBase<R>::Desc::dump() const {
+  int i;
 
-   // Dump regardless of the verbosity level if this method is called.
+  // Dump regardless of the verbosity level if this method is called.
 
-   std::cout << "DBDESC01 column status: ";
+  std::cout << "DBDESC01 column status: ";
 
-   for(i = 0; i < nCols(); i++)
-      std::cout << static_cast<int>(colStatus(i));
+  for (i = 0; i < nCols(); i++)
+    std::cout << static_cast<int>(colStatus(i));
 
-   std::cout << std::endl;
+  std::cout << std::endl;
 
-   std::cout << "DBDESC02 row status:    ";
+  std::cout << "DBDESC02 row status:    ";
 
-   for(i = 0; i < nRows(); i++)
-      std::cout << static_cast<int>(rowStatus(i));
+  for (i = 0; i < nRows(); i++)
+    std::cout << static_cast<int>(rowStatus(i));
 
-   std::cout << std::endl;
+  std::cout << std::endl;
 }
 
-template <class R>
-bool SPxBasisBase<R>::Desc::isConsistent() const
-{
+template <class R> bool SPxBasisBase<R>::Desc::isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
-   return rowstat.isConsistent() && colstat.isConsistent();
+  return rowstat.isConsistent() && colstat.isConsistent();
 #else
-   return true;
+  return true;
 #endif
 }
 
 template <class R>
-std::ostream& operator<<(std::ostream& os, const typename SPxBasisBase<R>::Desc::Status& stat)
-{
-   char text;
+std::ostream &operator<<(std::ostream &os,
+                         const typename SPxBasisBase<R>::Desc::Status &stat) {
+  char text;
 
-   switch(stat)
-   {
-   case SPxBasisBase<R>::Desc::P_ON_LOWER :
-      text = 'L';
-      break;
+  switch (stat) {
+  case SPxBasisBase<R>::Desc::P_ON_LOWER:
+    text = 'L';
+    break;
 
-   case SPxBasisBase<R>::Desc::P_ON_UPPER :
-      text = 'U';
-      break;
+  case SPxBasisBase<R>::Desc::P_ON_UPPER:
+    text = 'U';
+    break;
 
-   case SPxBasisBase<R>::Desc::P_FREE :
-      text = 'F';
-      break;
+  case SPxBasisBase<R>::Desc::P_FREE:
+    text = 'F';
+    break;
 
-   case SPxBasisBase<R>::Desc::P_FIXED :
-      text = 'X';
-      break;
+  case SPxBasisBase<R>::Desc::P_FIXED:
+    text = 'X';
+    break;
 
-   case SPxBasisBase<R>::Desc::D_FREE :
-      text = 'f';
-      break;
+  case SPxBasisBase<R>::Desc::D_FREE:
+    text = 'f';
+    break;
 
-   case SPxBasisBase<R>::Desc::D_ON_UPPER :
-      text = 'u';
-      break;
+  case SPxBasisBase<R>::Desc::D_ON_UPPER:
+    text = 'u';
+    break;
 
-   case SPxBasisBase<R>::Desc::D_ON_LOWER :
-      text = 'l';
-      break;
+  case SPxBasisBase<R>::Desc::D_ON_LOWER:
+    text = 'l';
+    break;
 
-   case SPxBasisBase<R>::Desc::D_ON_BOTH :
-      text = 'x';
-      break;
+  case SPxBasisBase<R>::Desc::D_ON_BOTH:
+    text = 'x';
+    break;
 
-   case SPxBasisBase<R>::Desc::D_UNDEFINED :
-      text = '.';
-      break;
+  case SPxBasisBase<R>::Desc::D_UNDEFINED:
+    text = '.';
+    break;
 
-   default :
-      os << std::endl << "Invalid status <" << int(stat) << ">" << std::endl;
-      throw SPxInternalCodeException("XSPXDE01 This should never happen.");
-   }
+  default:
+    os << std::endl << "Invalid status <" << int(stat) << ">" << std::endl;
+    throw SPxInternalCodeException("XSPXDE01 This should never happen.");
+  }
 
-   os << text;
+  os << text;
 
-   return os;
+  return os;
 }
 
 } // namespace soplex
diff --git a/src/soplex/spxdevexpr.hpp b/src/soplex/spxdevexpr.hpp
index 9a918ae..5ae6919 100644
--- a/src/soplex/spxdevexpr.hpp
+++ b/src/soplex/spxdevexpr.hpp
@@ -21,956 +21,838 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include "soplex/spxdefines.h"
 
 #define DEVEX_REFINETOL 2.0
 
-namespace soplex
-{
+namespace soplex {
 // Definition of signature to avoid the specialization after instantiation error
 
-template <class R>
-void SPxDevexPR<R>::load(SPxSolverBase<R>* base)
-{
-   this->thesolver = base;
-   setRep(base->rep());
-   assert(isConsistent());
+template <class R> void SPxDevexPR<R>::load(SPxSolverBase<R> *base) {
+  this->thesolver = base;
+  setRep(base->rep());
+  assert(isConsistent());
 }
 
-template <class R>
-bool SPxDevexPR<R>::isConsistent() const
-{
+template <class R> bool SPxDevexPR<R>::isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
 
-   if(this->thesolver != 0)
-      if(this->thesolver->weights.dim() != this->thesolver->coDim()
-            || this->thesolver->coWeights.dim() != this->thesolver->dim())
-         return MSGinconsistent("SPxDevexPR");
+  if (this->thesolver != 0)
+    if (this->thesolver->weights.dim() != this->thesolver->coDim() ||
+        this->thesolver->coWeights.dim() != this->thesolver->dim())
+      return MSGinconsistent("SPxDevexPR");
 
 #endif
 
-   return true;
+  return true;
 }
 
 template <class R>
-void SPxDevexPR<R>::setupWeights(typename SPxSolverBase<R>::Type tp)
-{
-   int i;
-   int coWeightSize = 0;
-   int weightSize = 0;
+void SPxDevexPR<R>::setupWeights(typename SPxSolverBase<R>::Type tp) {
+  int i;
+  int coWeightSize = 0;
+  int weightSize = 0;
 
-   VectorBase<R>& weights = this->thesolver->weights;
-   VectorBase<R>& coWeights = this->thesolver->coWeights;
+  VectorBase<R> &weights = this->thesolver->weights;
+  VectorBase<R> &coWeights = this->thesolver->coWeights;
 
-   if(tp == SPxSolverBase<R>::ENTER)
-   {
-      coWeights.reDim(this->thesolver->dim(), false);
+  if (tp == SPxSolverBase<R>::ENTER) {
+    coWeights.reDim(this->thesolver->dim(), false);
 
-      for(i = this->thesolver->dim() - 1; i >= coWeightSize; --i)
-         coWeights[i] = 2.0;
+    for (i = this->thesolver->dim() - 1; i >= coWeightSize; --i)
+      coWeights[i] = 2.0;
 
-      weights.reDim(this->thesolver->coDim(), false);
+    weights.reDim(this->thesolver->coDim(), false);
 
-      for(i = this->thesolver->coDim() - 1; i >= weightSize; --i)
-         weights[i] = 2.0;
-   }
-   else
-   {
-      coWeights.reDim(this->thesolver->dim(), false);
+    for (i = this->thesolver->coDim() - 1; i >= weightSize; --i)
+      weights[i] = 2.0;
+  } else {
+    coWeights.reDim(this->thesolver->dim(), false);
 
-      for(i = this->thesolver->dim() - 1; i >= coWeightSize; --i)
-         coWeights[i] = 1.0;
-   }
+    for (i = this->thesolver->dim() - 1; i >= coWeightSize; --i)
+      coWeights[i] = 1.0;
+  }
 
-   this->thesolver->weightsAreSetup = true;
+  this->thesolver->weightsAreSetup = true;
 }
 
 template <class R>
-void SPxDevexPR<R>::setType(typename SPxSolverBase<R>::Type tp)
-{
-   setupWeights(tp);
-   refined = false;
-
-   bestPrices.clear();
-   bestPrices.setMax(this->thesolver->dim());
-   prices.reSize(this->thesolver->dim());
-
-   if(tp == SPxSolverBase<R>::ENTER)
-   {
-      bestPricesCo.clear();
-      bestPricesCo.setMax(this->thesolver->coDim());
-      pricesCo.reSize(this->thesolver->coDim());
-   }
-
-   assert(isConsistent());
+void SPxDevexPR<R>::setType(typename SPxSolverBase<R>::Type tp) {
+  setupWeights(tp);
+  refined = false;
+
+  bestPrices.clear();
+  bestPrices.setMax(this->thesolver->dim());
+  prices.reSize(this->thesolver->dim());
+
+  if (tp == SPxSolverBase<R>::ENTER) {
+    bestPricesCo.clear();
+    bestPricesCo.setMax(this->thesolver->coDim());
+    pricesCo.reSize(this->thesolver->coDim());
+  }
+
+  assert(isConsistent());
 }
 
 /**@todo suspicious: Shouldn't the relation between dim, coDim, Vecs,
  *       and CoVecs be influenced by the representation ?
  */
 template <class R>
-void SPxDevexPR<R>::setRep(typename SPxSolverBase<R>::Representation)
-{
-   if(this->thesolver != 0)
-   {
-      // resize weights and initialize new entries
-      addedVecs(this->thesolver->coDim());
-      addedCoVecs(this->thesolver->dim());
-      assert(isConsistent());
-   }
+void SPxDevexPR<R>::setRep(typename SPxSolverBase<R>::Representation) {
+  if (this->thesolver != 0) {
+    // resize weights and initialize new entries
+    addedVecs(this->thesolver->coDim());
+    addedCoVecs(this->thesolver->dim());
+    assert(isConsistent());
+  }
 }
 
 // A namespace to avoid collision with other pricers
-namespace devexpr
-{
-template <class R>
-R computePrice(R viol, R weight, R tol)
-{
-   if(weight < tol)
-      return viol * viol / tol;
-   else
-      return viol * viol / weight;
+namespace devexpr {
+template <class R> R computePrice(R viol, R weight, R tol) {
+  if (weight < tol)
+    return viol * viol / tol;
+  else
+    return viol * viol / weight;
 }
+} // namespace devexpr
+
+template <class R> int SPxDevexPR<R>::buildBestPriceVectorLeave(R feastol) {
+  int idx;
+  int nsorted;
+  R fTesti;
+  const R *fTest = this->thesolver->fTest().get_const_ptr();
+  const R *cpen = this->thesolver->coWeights.get_const_ptr();
+  typename SPxPricer<R>::IdxElement price;
+  prices.clear();
+  bestPrices.clear();
+
+  // TODO we should check infeasiblities for duplicates or loop over dimension
+  //      bestPrices may then also contain duplicates!
+  // construct vector of all prices
+  for (int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->infeasibilities.index(i);
+    fTesti = fTest[idx];
+
+    if (fTesti < -feastol) {
+      this->thesolver->isInfeasible[idx] = this->VIOLATED;
+      price.idx = idx;
+      price.val = devexpr::computePrice(fTesti, cpen[idx], feastol);
+      prices.append(price);
+    }
+  }
+
+  // set up structures for the quicksort implementation
+  this->compare.elements = prices.get_const_ptr();
+  // do a partial sort to move the best ones to the front
+  // TODO this can be done more efficiently, since we only need the indices
+  nsorted = SPxQuicksortPart(prices.get_ptr(), this->compare, 0, prices.size(),
+                             HYPERPRICINGSIZE);
+
+  // copy indices of best values to bestPrices
+  for (int i = 0; i < nsorted; ++i) {
+    bestPrices.addIdx(prices[i].idx);
+    this->thesolver->isInfeasible[prices[i].idx] = this->VIOLATED_AND_CHECKED;
+  }
+
+  if (nsorted > 0)
+    return prices[0].idx;
+  else
+    return -1;
 }
 
-template <class R>
-int SPxDevexPR<R>::buildBestPriceVectorLeave(R feastol)
-{
-   int idx;
-   int nsorted;
-   R fTesti;
-   const R* fTest = this->thesolver->fTest().get_const_ptr();
-   const R* cpen = this->thesolver->coWeights.get_const_ptr();
-   typename SPxPricer<R>::IdxElement price;
-   prices.clear();
-   bestPrices.clear();
-
-   // TODO we should check infeasiblities for duplicates or loop over dimension
-   //      bestPrices may then also contain duplicates!
-   // construct vector of all prices
-   for(int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->infeasibilities.index(i);
-      fTesti = fTest[idx];
-
-      if(fTesti < -feastol)
-      {
-         this->thesolver->isInfeasible[idx] = this->VIOLATED;
-         price.idx = idx;
-         price.val = devexpr::computePrice(fTesti, cpen[idx], feastol);
-         prices.append(price);
-      }
-   }
-
-   // set up structures for the quicksort implementation
-   this->compare.elements = prices.get_const_ptr();
-   // do a partial sort to move the best ones to the front
-   // TODO this can be done more efficiently, since we only need the indices
-   nsorted = SPxQuicksortPart(prices.get_ptr(), this->compare, 0, prices.size(), HYPERPRICINGSIZE);
-
-   // copy indices of best values to bestPrices
-   for(int i = 0; i < nsorted; ++i)
-   {
-      bestPrices.addIdx(prices[i].idx);
-      this->thesolver->isInfeasible[prices[i].idx] = this->VIOLATED_AND_CHECKED;
-   }
-
-   if(nsorted > 0)
-      return prices[0].idx;
-   else
-      return -1;
+template <class R> int SPxDevexPR<R>::selectLeave() {
+  int retid;
+
+  if (this->thesolver->hyperPricingLeave &&
+      this->thesolver->sparsePricingLeave) {
+    if (bestPrices.size() < 2 || this->thesolver->basis().lastUpdate() == 0) {
+      // call init method to build up price-vector and return index of largest
+      // price
+      retid = buildBestPriceVectorLeave(this->theeps);
+    } else
+      retid = selectLeaveHyper(this->theeps);
+  } else if (this->thesolver->sparsePricingLeave)
+    retid = selectLeaveSparse(this->theeps);
+  else
+    retid = selectLeaveX(this->theeps);
+
+  if (retid < 0 && !refined) {
+    refined = true;
+    MSG_INFO3((*this->thesolver->spxout),
+              (*this->thesolver->spxout)
+                  << "WDEVEX02 trying refinement step..\n";)
+    retid = selectLeaveX(this->theeps / DEVEX_REFINETOL);
+  }
+
+  assert(retid < this->thesolver->dim());
+
+  return retid;
 }
 
 template <class R>
-int SPxDevexPR<R>::selectLeave()
-{
-   int retid;
-
-   if(this->thesolver->hyperPricingLeave && this->thesolver->sparsePricingLeave)
-   {
-      if(bestPrices.size() < 2 || this->thesolver->basis().lastUpdate() == 0)
-      {
-         // call init method to build up price-vector and return index of largest price
-         retid = buildBestPriceVectorLeave(this->theeps);
+int SPxDevexPR<R>::selectLeaveX(R feastol, int start, int incr) {
+  R x;
+
+  const R *fTest = this->thesolver->fTest().get_const_ptr();
+  const R *cpen = this->thesolver->coWeights.get_const_ptr();
+  R best = 0;
+  int bstI = -1;
+  int end = this->thesolver->coWeights.dim();
+
+  for (; start < end; start += incr) {
+    if (fTest[start] < -feastol) {
+      x = devexpr::computePrice(fTest[start], cpen[start], feastol);
+
+      if (x > best) {
+        best = x;
+        bstI = start;
+        last = cpen[start];
       }
-      else
-         retid = selectLeaveHyper(this->theeps);
-   }
-   else if(this->thesolver->sparsePricingLeave)
-      retid = selectLeaveSparse(this->theeps);
-   else
-      retid = selectLeaveX(this->theeps);
-
-   if(retid < 0 && !refined)
-   {
-      refined = true;
-      MSG_INFO3((*this->thesolver->spxout),
-                (*this->thesolver->spxout) << "WDEVEX02 trying refinement step..\n";)
-      retid = selectLeaveX(this->theeps / DEVEX_REFINETOL);
-   }
+    }
+  }
 
-   assert(retid < this->thesolver->dim());
-
-   return retid;
+  return bstI;
 }
 
-template <class R>
-int SPxDevexPR<R>::selectLeaveX(R feastol, int start, int incr)
-{
-   R x;
-
-   const R* fTest = this->thesolver->fTest().get_const_ptr();
-   const R* cpen = this->thesolver->coWeights.get_const_ptr();
-   R best = 0;
-   int bstI = -1;
-   int end = this->thesolver->coWeights.dim();
-
-   for(; start < end; start += incr)
-   {
-      if(fTest[start] < -feastol)
-      {
-         x = devexpr::computePrice(fTest[start], cpen[start], feastol);
-
-         if(x > best)
-         {
-            best = x;
-            bstI = start;
-            last = cpen[start];
-         }
-      }
-   }
+template <class R> int SPxDevexPR<R>::selectLeaveSparse(R feastol) {
+  R x;
 
-   return bstI;
-}
+  const R *fTest = this->thesolver->fTest().get_const_ptr();
+  const R *cpen = this->thesolver->coWeights.get_const_ptr();
+  R best = 0;
+  int bstI = -1;
+  int idx = -1;
 
-template <class R>
-int SPxDevexPR<R>::selectLeaveSparse(R feastol)
-{
-   R x;
-
-   const R* fTest = this->thesolver->fTest().get_const_ptr();
-   const R* cpen = this->thesolver->coWeights.get_const_ptr();
-   R best = 0;
-   int bstI = -1;
-   int idx = -1;
-
-   for(int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->infeasibilities.index(i);
-      x = fTest[idx];
+  for (int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->infeasibilities.index(i);
+    x = fTest[idx];
 
-      if(x < -feastol)
-      {
-         x = devexpr::computePrice(x, cpen[idx], feastol);
+    if (x < -feastol) {
+      x = devexpr::computePrice(x, cpen[idx], feastol);
 
-         if(x > best)
-         {
-            best = x;
-            bstI = idx;
-            last = cpen[idx];
-         }
-      }
-      else
-      {
-         this->thesolver->infeasibilities.remove(i);
-         assert(this->thesolver->isInfeasible[idx] == this->VIOLATED
-                || this->thesolver->isInfeasible[idx] == this->VIOLATED_AND_CHECKED);
-         this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
+      if (x > best) {
+        best = x;
+        bstI = idx;
+        last = cpen[idx];
       }
-   }
-
-   return bstI;
+    } else {
+      this->thesolver->infeasibilities.remove(i);
+      assert(this->thesolver->isInfeasible[idx] == this->VIOLATED ||
+             this->thesolver->isInfeasible[idx] == this->VIOLATED_AND_CHECKED);
+      this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
+    }
+  }
+
+  return bstI;
 }
 
-template <class R>
-int SPxDevexPR<R>::selectLeaveHyper(R feastol)
-{
-   R x;
-
-   const R* fTest = this->thesolver->fTest().get_const_ptr();
-   const R* cpen = this->thesolver->coWeights.get_const_ptr();
-   R best = 0;
-   R leastBest = -1;
-   int bstI = -1;
-   int idx = -1;
-
-   // find the best price from the short candidate list
-   for(int i = bestPrices.size() - 1; i >= 0; --i)
-   {
-      idx = bestPrices.index(i);
-      x = fTest[idx];
+template <class R> int SPxDevexPR<R>::selectLeaveHyper(R feastol) {
+  R x;
 
-      if(x < -feastol)
-      {
-         x = devexpr::computePrice(x, cpen[idx], feastol);
+  const R *fTest = this->thesolver->fTest().get_const_ptr();
+  const R *cpen = this->thesolver->coWeights.get_const_ptr();
+  R best = 0;
+  R leastBest = -1;
+  int bstI = -1;
+  int idx = -1;
 
-         assert(x >= 0);
+  // find the best price from the short candidate list
+  for (int i = bestPrices.size() - 1; i >= 0; --i) {
+    idx = bestPrices.index(i);
+    x = fTest[idx];
 
-         // update the best price of candidate list
-         if(x > best)
-         {
-            best = x;
-            bstI = idx;
-            last = cpen[idx];
-         }
+    if (x < -feastol) {
+      x = devexpr::computePrice(x, cpen[idx], feastol);
 
-         // update the smallest price of candidate list
-         if(x < leastBest || leastBest < 0)
-            leastBest = x;
-      }
-      else
-      {
-         bestPrices.remove(i);
-         this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
+      assert(x >= 0);
+
+      // update the best price of candidate list
+      if (x > best) {
+        best = x;
+        bstI = idx;
+        last = cpen[idx];
       }
-   }
-
-   // scan the updated indices for a better price
-   for(int i = this->thesolver->updateViols.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->updateViols.index(i);
-
-      // only look at indeces that were not checked already
-      if(this->thesolver->isInfeasible[idx] == this->VIOLATED)
-      {
-         x = fTest[idx];
-         assert(x < -feastol);
-         x = devexpr::computePrice(x, cpen[idx], feastol);
-
-         if(x > leastBest)
-         {
-            if(x > best)
-            {
-               best = x;
-               bstI = idx;
-               last = cpen[idx];
-            }
-
-            // put index into candidate list
-            this->thesolver->isInfeasible[idx] = this->VIOLATED_AND_CHECKED;
-            bestPrices.addIdx(idx);
-         }
+
+      // update the smallest price of candidate list
+      if (x < leastBest || leastBest < 0)
+        leastBest = x;
+    } else {
+      bestPrices.remove(i);
+      this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
+    }
+  }
+
+  // scan the updated indices for a better price
+  for (int i = this->thesolver->updateViols.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->updateViols.index(i);
+
+    // only look at indeces that were not checked already
+    if (this->thesolver->isInfeasible[idx] == this->VIOLATED) {
+      x = fTest[idx];
+      assert(x < -feastol);
+      x = devexpr::computePrice(x, cpen[idx], feastol);
+
+      if (x > leastBest) {
+        if (x > best) {
+          best = x;
+          bstI = idx;
+          last = cpen[idx];
+        }
+
+        // put index into candidate list
+        this->thesolver->isInfeasible[idx] = this->VIOLATED_AND_CHECKED;
+        bestPrices.addIdx(idx);
       }
-   }
+    }
+  }
 
-   return bstI;
+  return bstI;
 }
 
-template <class R>
-void SPxDevexPR<R>::left4(int n, SPxId id)
-{
-   VectorBase<R>& coWeights = this->thesolver->coWeights;
-
-   if(id.isValid())
-   {
-      int i, j;
-      R x;
-      const R* rhoVec = this->thesolver->fVec().delta().values();
-      R rhov_1 = 1 / rhoVec[n];
-      R beta_q = this->thesolver->coPvec().delta().length2() * rhov_1 * rhov_1;
-
-#ifndef NDEBUG
-
-      if(spxAbs(rhoVec[n]) < this->theeps)
-      {
-         MSG_INFO3((*this->thesolver->spxout), (*this->thesolver->spxout) << "WDEVEX01: rhoVec = "
-                   << rhoVec[n] << " with smaller absolute value than this->theeps = " << this->theeps << std::endl;)
-      }
-
-#endif  // NDEBUG
+template <class R> void SPxDevexPR<R>::left4(int n, SPxId id) {
+  VectorBase<R> &coWeights = this->thesolver->coWeights;
 
-      //  Update #coPenalty# vector
-      const IdxSet& rhoIdx = this->thesolver->fVec().idx();
-      int len = this->thesolver->fVec().idx().size();
+  if (id.isValid()) {
+    int i, j;
+    R x;
+    const R *rhoVec = this->thesolver->fVec().delta().values();
+    R rhov_1 = 1 / rhoVec[n];
+    R beta_q = this->thesolver->coPvec().delta().length2() * rhov_1 * rhov_1;
 
-      for(i = len - 1; i >= 0; --i)
-      {
-         j = rhoIdx.index(i);
-         x = rhoVec[j] * rhoVec[j] * beta_q;
-         // if(x > coPenalty[j])
-         coWeights[j] += x;
-      }
+#ifndef NDEBUG
 
-      coWeights[n] = beta_q;
-   }
+    if (spxAbs(rhoVec[n]) < this->theeps) {
+      MSG_INFO3((*this->thesolver->spxout),
+                (*this->thesolver->spxout)
+                    << "WDEVEX01: rhoVec = " << rhoVec[n]
+                    << " with smaller absolute value than this->theeps = "
+                    << this->theeps << std::endl;)
+    }
+
+#endif // NDEBUG
+
+    //  Update #coPenalty# vector
+    const IdxSet &rhoIdx = this->thesolver->fVec().idx();
+    int len = this->thesolver->fVec().idx().size();
+
+    for (i = len - 1; i >= 0; --i) {
+      j = rhoIdx.index(i);
+      x = rhoVec[j] * rhoVec[j] * beta_q;
+      // if(x > coPenalty[j])
+      coWeights[j] += x;
+    }
+
+    coWeights[n] = beta_q;
+  }
 }
 
 template <class R>
-SPxId SPxDevexPR<R>::buildBestPriceVectorEnterDim(R& best, R feastol)
-{
-   int idx;
-   int nsorted;
-   R x;
-   const R* coTest = this->thesolver->coTest().get_const_ptr();
-   const R* cpen = this->thesolver->coWeights.get_const_ptr();
-   typename SPxPricer<R>::IdxElement price;
-   prices.clear();
-   bestPrices.clear();
-
-   // construct vector of all prices
-   for(int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->infeasibilities.index(i);
-      x = coTest[idx];
-
-      if(x < -feastol)
-      {
-         this->thesolver->isInfeasible[idx] = this->VIOLATED;
-         price.idx = idx;
-         price.val = devexpr::computePrice(x, cpen[idx], feastol);
-         prices.append(price);
-      }
-      else
-      {
-         this->thesolver->infeasibilities.remove(i);
-         this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
-      }
-   }
-
-   // set up structures for the quicksort implementation
-   this->compare.elements = prices.get_const_ptr();
-   // do a partial sort to move the best ones to the front
-   // TODO this can be done more efficiently, since we only need the indices
-   nsorted = SPxQuicksortPart(prices.get_ptr(), this->compare, 0, prices.size(), HYPERPRICINGSIZE);
-
-   // copy indices of best values to bestPrices
-   for(int i = 0; i < nsorted; ++i)
-   {
-      bestPrices.addIdx(prices[i].idx);
-      this->thesolver->isInfeasible[prices[i].idx] = this->VIOLATED_AND_CHECKED;
-   }
-
-   if(nsorted > 0)
-   {
-      best = prices[0].val;
-      return this->thesolver->coId(prices[0].idx);
-   }
-   else
-      return SPxId();
+SPxId SPxDevexPR<R>::buildBestPriceVectorEnterDim(R &best, R feastol) {
+  int idx;
+  int nsorted;
+  R x;
+  const R *coTest = this->thesolver->coTest().get_const_ptr();
+  const R *cpen = this->thesolver->coWeights.get_const_ptr();
+  typename SPxPricer<R>::IdxElement price;
+  prices.clear();
+  bestPrices.clear();
+
+  // construct vector of all prices
+  for (int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->infeasibilities.index(i);
+    x = coTest[idx];
+
+    if (x < -feastol) {
+      this->thesolver->isInfeasible[idx] = this->VIOLATED;
+      price.idx = idx;
+      price.val = devexpr::computePrice(x, cpen[idx], feastol);
+      prices.append(price);
+    } else {
+      this->thesolver->infeasibilities.remove(i);
+      this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
+    }
+  }
+
+  // set up structures for the quicksort implementation
+  this->compare.elements = prices.get_const_ptr();
+  // do a partial sort to move the best ones to the front
+  // TODO this can be done more efficiently, since we only need the indices
+  nsorted = SPxQuicksortPart(prices.get_ptr(), this->compare, 0, prices.size(),
+                             HYPERPRICINGSIZE);
+
+  // copy indices of best values to bestPrices
+  for (int i = 0; i < nsorted; ++i) {
+    bestPrices.addIdx(prices[i].idx);
+    this->thesolver->isInfeasible[prices[i].idx] = this->VIOLATED_AND_CHECKED;
+  }
+
+  if (nsorted > 0) {
+    best = prices[0].val;
+    return this->thesolver->coId(prices[0].idx);
+  } else
+    return SPxId();
 }
 
 template <class R>
-SPxId SPxDevexPR<R>::buildBestPriceVectorEnterCoDim(R& best, R feastol)
-{
-   int idx;
-   int nsorted;
-   R x;
-   const R* test = this->thesolver->test().get_const_ptr();
-   const R* pen = this->thesolver->weights.get_const_ptr();
-   typename SPxPricer<R>::IdxElement price;
-   pricesCo.clear();
-   bestPricesCo.clear();
-
-   // construct vector of all prices
-   for(int i = this->thesolver->infeasibilitiesCo.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->infeasibilitiesCo.index(i);
-      x = test[idx];
-
-      if(x < -feastol)
-      {
-         this->thesolver->isInfeasibleCo[idx] = this->VIOLATED;
-         price.idx = idx;
-         price.val = devexpr::computePrice(x, pen[idx], feastol);
-         pricesCo.append(price);
-      }
-      else
-      {
-         this->thesolver->infeasibilitiesCo.remove(i);
-         this->thesolver->isInfeasibleCo[idx] = this->NOT_VIOLATED;
-      }
-   }
-
-   // set up structures for the quicksort implementation
-   this->compare.elements = pricesCo.get_const_ptr();
-   // do a partial sort to move the best ones to the front
-   // TODO this can be done more efficiently, since we only need the indices
-   nsorted = SPxQuicksortPart(pricesCo.get_ptr(), this->compare, 0, pricesCo.size(), HYPERPRICINGSIZE);
-
-   // copy indices of best values to bestPrices
-   for(int i = 0; i < nsorted; ++i)
-   {
-      bestPricesCo.addIdx(pricesCo[i].idx);
-      this->thesolver->isInfeasibleCo[pricesCo[i].idx] = this->VIOLATED_AND_CHECKED;
-   }
-
-   if(nsorted > 0)
-   {
-      best = pricesCo[0].val;
-      return this->thesolver->id(pricesCo[0].idx);
-   }
-   else
-      return SPxId();
+SPxId SPxDevexPR<R>::buildBestPriceVectorEnterCoDim(R &best, R feastol) {
+  int idx;
+  int nsorted;
+  R x;
+  const R *test = this->thesolver->test().get_const_ptr();
+  const R *pen = this->thesolver->weights.get_const_ptr();
+  typename SPxPricer<R>::IdxElement price;
+  pricesCo.clear();
+  bestPricesCo.clear();
+
+  // construct vector of all prices
+  for (int i = this->thesolver->infeasibilitiesCo.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->infeasibilitiesCo.index(i);
+    x = test[idx];
+
+    if (x < -feastol) {
+      this->thesolver->isInfeasibleCo[idx] = this->VIOLATED;
+      price.idx = idx;
+      price.val = devexpr::computePrice(x, pen[idx], feastol);
+      pricesCo.append(price);
+    } else {
+      this->thesolver->infeasibilitiesCo.remove(i);
+      this->thesolver->isInfeasibleCo[idx] = this->NOT_VIOLATED;
+    }
+  }
+
+  // set up structures for the quicksort implementation
+  this->compare.elements = pricesCo.get_const_ptr();
+  // do a partial sort to move the best ones to the front
+  // TODO this can be done more efficiently, since we only need the indices
+  nsorted = SPxQuicksortPart(pricesCo.get_ptr(), this->compare, 0,
+                             pricesCo.size(), HYPERPRICINGSIZE);
+
+  // copy indices of best values to bestPrices
+  for (int i = 0; i < nsorted; ++i) {
+    bestPricesCo.addIdx(pricesCo[i].idx);
+    this->thesolver->isInfeasibleCo[pricesCo[i].idx] =
+        this->VIOLATED_AND_CHECKED;
+  }
+
+  if (nsorted > 0) {
+    best = pricesCo[0].val;
+    return this->thesolver->id(pricesCo[0].idx);
+  } else
+    return SPxId();
 }
 
-template <class R>
-SPxId SPxDevexPR<R>::selectEnter()
-{
-   assert(this->thesolver != 0);
+template <class R> SPxId SPxDevexPR<R>::selectEnter() {
+  assert(this->thesolver != 0);
 
-   SPxId enterId;
+  SPxId enterId;
 
-   enterId = selectEnterX(this->theeps);
+  enterId = selectEnterX(this->theeps);
 
-   if(enterId.isSPxColId() && this->thesolver->isBasic(SPxColId(enterId)))
-      enterId.info = 0;
+  if (enterId.isSPxColId() && this->thesolver->isBasic(SPxColId(enterId)))
+    enterId.info = 0;
 
-   if(enterId.isSPxRowId() && this->thesolver->isBasic(SPxRowId(enterId)))
-      enterId.info = 0;
+  if (enterId.isSPxRowId() && this->thesolver->isBasic(SPxRowId(enterId)))
+    enterId.info = 0;
 
-   if(!enterId.isValid() && !refined)
-   {
-      refined = true;
-      MSG_INFO3((*this->thesolver->spxout),
-                (*this->thesolver->spxout) << "WDEVEX02 trying refinement step..\n";)
-      enterId = selectEnterX(this->theeps / DEVEX_REFINETOL);
+  if (!enterId.isValid() && !refined) {
+    refined = true;
+    MSG_INFO3((*this->thesolver->spxout),
+              (*this->thesolver->spxout)
+                  << "WDEVEX02 trying refinement step..\n";)
+    enterId = selectEnterX(this->theeps / DEVEX_REFINETOL);
 
-      if(enterId.isSPxColId() && this->thesolver->isBasic(SPxColId(enterId)))
-         enterId.info = 0;
+    if (enterId.isSPxColId() && this->thesolver->isBasic(SPxColId(enterId)))
+      enterId.info = 0;
 
-      if(enterId.isSPxRowId() && this->thesolver->isBasic(SPxRowId(enterId)))
-         enterId.info = 0;
-   }
+    if (enterId.isSPxRowId() && this->thesolver->isBasic(SPxRowId(enterId)))
+      enterId.info = 0;
+  }
 
-   return enterId;
+  return enterId;
 }
 
 // choose the best entering index among columns and rows but prefer sparsity
-template <class R>
-SPxId SPxDevexPR<R>::selectEnterX(R tol)
-{
-   SPxId enterId;
-   SPxId enterCoId;
-   R best;
-   R bestCo;
-
-   best = 0;
-   bestCo = 0;
-   last = 1.0;
-
-   // avoid uninitialized value later on in entered4X()
-   last = 1.0;
-
-   if(this->thesolver->hyperPricingEnter && !refined)
-   {
-      if(bestPrices.size() < 2 || this->thesolver->basis().lastUpdate() == 0)
-         enterCoId = (this->thesolver->sparsePricingEnter) ? buildBestPriceVectorEnterDim(best,
-                     tol) : selectEnterDenseDim(best, tol);
-      else
-         enterCoId = (this->thesolver->sparsePricingEnter) ? selectEnterHyperDim(best,
-                     tol) : selectEnterDenseDim(best, tol);
-
-      if(bestPricesCo.size() < 2 || this->thesolver->basis().lastUpdate() == 0)
-         enterId = (this->thesolver->sparsePricingEnterCo) ? buildBestPriceVectorEnterCoDim(bestCo,
-                   tol) : selectEnterDenseCoDim(bestCo, tol);
-      else
-         enterId = (this->thesolver->sparsePricingEnterCo) ? selectEnterHyperCoDim(bestCo,
-                   tol) : selectEnterDenseCoDim(bestCo, tol);
-   }
-   else
-   {
-      enterCoId = (this->thesolver->sparsePricingEnter
-                   && !refined) ? selectEnterSparseDim(best, tol) : selectEnterDenseDim(best, tol);
-      enterId = (this->thesolver->sparsePricingEnterCo
-                 && !refined) ? selectEnterSparseCoDim(bestCo, tol) : selectEnterDenseCoDim(bestCo, tol);
-   }
-
-   // prefer coIds to increase the number of unit vectors in the basis matrix, i.e., rows in colrep and cols in rowrep
-   if(enterCoId.isValid() && (best > SPARSITY_TRADEOFF * bestCo || !enterId.isValid()))
-      return enterCoId;
-   else
-      return enterId;
+template <class R> SPxId SPxDevexPR<R>::selectEnterX(R tol) {
+  SPxId enterId;
+  SPxId enterCoId;
+  R best;
+  R bestCo;
+
+  best = 0;
+  bestCo = 0;
+  last = 1.0;
+
+  // avoid uninitialized value later on in entered4X()
+  last = 1.0;
+
+  if (this->thesolver->hyperPricingEnter && !refined) {
+    if (bestPrices.size() < 2 || this->thesolver->basis().lastUpdate() == 0)
+      enterCoId = (this->thesolver->sparsePricingEnter)
+                      ? buildBestPriceVectorEnterDim(best, tol)
+                      : selectEnterDenseDim(best, tol);
+    else
+      enterCoId = (this->thesolver->sparsePricingEnter)
+                      ? selectEnterHyperDim(best, tol)
+                      : selectEnterDenseDim(best, tol);
+
+    if (bestPricesCo.size() < 2 || this->thesolver->basis().lastUpdate() == 0)
+      enterId = (this->thesolver->sparsePricingEnterCo)
+                    ? buildBestPriceVectorEnterCoDim(bestCo, tol)
+                    : selectEnterDenseCoDim(bestCo, tol);
+    else
+      enterId = (this->thesolver->sparsePricingEnterCo)
+                    ? selectEnterHyperCoDim(bestCo, tol)
+                    : selectEnterDenseCoDim(bestCo, tol);
+  } else {
+    enterCoId = (this->thesolver->sparsePricingEnter && !refined)
+                    ? selectEnterSparseDim(best, tol)
+                    : selectEnterDenseDim(best, tol);
+    enterId = (this->thesolver->sparsePricingEnterCo && !refined)
+                  ? selectEnterSparseCoDim(bestCo, tol)
+                  : selectEnterDenseCoDim(bestCo, tol);
+  }
+
+  // prefer coIds to increase the number of unit vectors in the basis matrix,
+  // i.e., rows in colrep and cols in rowrep
+  if (enterCoId.isValid() &&
+      (best > SPARSITY_TRADEOFF * bestCo || !enterId.isValid()))
+    return enterCoId;
+  else
+    return enterId;
 }
 
 template <class R>
-SPxId SPxDevexPR<R>::selectEnterHyperDim(R& best, R feastol)
-{
-   const R* cTest = this->thesolver->coTest().get_const_ptr();
-   const R* cpen = this->thesolver->coWeights.get_const_ptr();
-   R leastBest = -1;
-   R x;
-   int enterIdx = -1;
-   int idx;
-
-   // find the best price from short candidate list
-   for(int i = bestPrices.size() - 1; i >= 0; --i)
-   {
-      idx = bestPrices.index(i);
-      x = cTest[idx];
+SPxId SPxDevexPR<R>::selectEnterHyperDim(R &best, R feastol) {
+  const R *cTest = this->thesolver->coTest().get_const_ptr();
+  const R *cpen = this->thesolver->coWeights.get_const_ptr();
+  R leastBest = -1;
+  R x;
+  int enterIdx = -1;
+  int idx;
+
+  // find the best price from short candidate list
+  for (int i = bestPrices.size() - 1; i >= 0; --i) {
+    idx = bestPrices.index(i);
+    x = cTest[idx];
+
+    if (x < -feastol) {
+      x = devexpr::computePrice(x, cpen[idx], feastol);
+
+      assert(x >= 0);
+
+      // update the best price of candidate list
+      if (x > best) {
+        best = x;
+        enterIdx = idx;
+        last = cpen[idx];
+      }
 
-      if(x < -feastol)
-      {
-         x = devexpr::computePrice(x, cpen[idx], feastol);
+      // update the smallest price of candidate list
+      if (x < leastBest || leastBest < 0)
+        leastBest = x;
+    } else {
+      bestPrices.remove(i);
+      this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
+    }
+  }
+
+  // scan the updated indeces for a better price
+  for (int i = this->thesolver->updateViols.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->updateViols.index(i);
+
+    // only look at indeces that were not checked already
+    if (this->thesolver->isInfeasible[idx] == this->VIOLATED) {
+      x = cTest[idx];
 
-         assert(x >= 0);
+      if (x < -feastol) {
+        x = devexpr::computePrice(x, cpen[idx], feastol);
 
-         // update the best price of candidate list
-         if(x > best)
-         {
+        if (x > leastBest) {
+          if (x > best) {
             best = x;
             enterIdx = idx;
             last = cpen[idx];
-         }
-
-         // update the smallest price of candidate list
-         if(x < leastBest || leastBest < 0)
-            leastBest = x;
-      }
-      else
-      {
-         bestPrices.remove(i);
-         this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
+          }
+
+          // put index into candidate list
+          this->thesolver->isInfeasible[idx] = this->VIOLATED_AND_CHECKED;
+          bestPrices.addIdx(idx);
+        }
+      } else {
+        this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
       }
-   }
-
-   // scan the updated indeces for a better price
-   for(int i = this->thesolver->updateViols.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->updateViols.index(i);
-
-      // only look at indeces that were not checked already
-      if(this->thesolver->isInfeasible[idx] == this->VIOLATED)
-      {
-         x = cTest[idx];
-
-         if(x < -feastol)
-         {
-            x = devexpr::computePrice(x, cpen[idx], feastol);
-
-            if(x > leastBest)
-            {
-               if(x > best)
-               {
-                  best = x;
-                  enterIdx = idx;
-                  last = cpen[idx];
-               }
-
-               // put index into candidate list
-               this->thesolver->isInfeasible[idx] = this->VIOLATED_AND_CHECKED;
-               bestPrices.addIdx(idx);
-            }
-         }
-         else
-         {
-            this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
-         }
-      }
-   }
+    }
+  }
 
-   if(enterIdx >= 0)
-      return this->thesolver->coId(enterIdx);
-   else
-      return SPxId();
+  if (enterIdx >= 0)
+    return this->thesolver->coId(enterIdx);
+  else
+    return SPxId();
 }
 
 template <class R>
-SPxId SPxDevexPR<R>::selectEnterHyperCoDim(R& best, R feastol)
-{
-   const R* test = this->thesolver->test().get_const_ptr();
-   const R* pen = this->thesolver->weights.get_const_ptr();
-   R leastBest = -1;
-   R x;
-   int enterIdx = -1;
-   int idx;
-
-   // find the best price from short candidate list
-   for(int i = bestPricesCo.size() - 1; i >= 0; --i)
-   {
-      idx = bestPricesCo.index(i);
-      x = test[idx];
+SPxId SPxDevexPR<R>::selectEnterHyperCoDim(R &best, R feastol) {
+  const R *test = this->thesolver->test().get_const_ptr();
+  const R *pen = this->thesolver->weights.get_const_ptr();
+  R leastBest = -1;
+  R x;
+  int enterIdx = -1;
+  int idx;
+
+  // find the best price from short candidate list
+  for (int i = bestPricesCo.size() - 1; i >= 0; --i) {
+    idx = bestPricesCo.index(i);
+    x = test[idx];
+
+    if (x < -feastol) {
+      x = devexpr::computePrice(x, pen[idx], feastol);
+
+      assert(x >= 0);
+
+      // update the best price of candidate list
+      if (x > best) {
+        best = x;
+        enterIdx = idx;
+        last = pen[idx];
+      }
 
-      if(x < -feastol)
-      {
-         x = devexpr::computePrice(x, pen[idx], feastol);
+      // update the smallest price of candidate list
+      if (x < leastBest || leastBest < 0)
+        leastBest = x;
+    } else {
+      bestPricesCo.remove(i);
+      this->thesolver->isInfeasibleCo[idx] = this->NOT_VIOLATED;
+    }
+  }
+
+  // scan the updated indeces for a better price
+  for (int i = this->thesolver->updateViolsCo.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->updateViolsCo.index(i);
+
+    // only look at indeces that were not checked already
+    if (this->thesolver->isInfeasibleCo[idx] == this->VIOLATED) {
+      x = test[idx];
 
-         assert(x >= 0);
+      if (x < -feastol) {
+        x = devexpr::computePrice(x, pen[idx], feastol);
 
-         // update the best price of candidate list
-         if(x > best)
-         {
+        if (x > leastBest) {
+          if (x > best) {
             best = x;
             enterIdx = idx;
             last = pen[idx];
-         }
-
-         // update the smallest price of candidate list
-         if(x < leastBest || leastBest < 0)
-            leastBest = x;
-      }
-      else
-      {
-         bestPricesCo.remove(i);
-         this->thesolver->isInfeasibleCo[idx] = this->NOT_VIOLATED;
+          }
+
+          // put index into candidate list
+          this->thesolver->isInfeasibleCo[idx] = this->VIOLATED_AND_CHECKED;
+          bestPricesCo.addIdx(idx);
+        }
+      } else {
+        this->thesolver->isInfeasibleCo[idx] = this->NOT_VIOLATED;
       }
-   }
-
-   //scan the updated indeces for a better price
-   for(int i = this->thesolver->updateViolsCo.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->updateViolsCo.index(i);
-
-      // only look at indeces that were not checked already
-      if(this->thesolver->isInfeasibleCo[idx] == this->VIOLATED)
-      {
-         x = test[idx];
-
-         if(x < -feastol)
-         {
-            x = devexpr::computePrice(x, pen[idx], feastol);
-
-            if(x > leastBest)
-            {
-               if(x > best)
-               {
-                  best = x;
-                  enterIdx = idx;
-                  last = pen[idx];
-               }
-
-               // put index into candidate list
-               this->thesolver->isInfeasibleCo[idx] = this->VIOLATED_AND_CHECKED;
-               bestPricesCo.addIdx(idx);
-            }
-         }
-         else
-         {
-            this->thesolver->isInfeasibleCo[idx] = this->NOT_VIOLATED;
-         }
-      }
-   }
+    }
+  }
 
-   if(enterIdx >= 0)
-      return this->thesolver->id(enterIdx);
-   else
-      return SPxId();
+  if (enterIdx >= 0)
+    return this->thesolver->id(enterIdx);
+  else
+    return SPxId();
 }
 
-
 template <class R>
-SPxId SPxDevexPR<R>::selectEnterSparseDim(R& best, R feastol)
-{
-   const R* cTest = this->thesolver->coTest().get_const_ptr();
-   const R* cpen = this->thesolver->coWeights.get_const_ptr();
-   int enterIdx = -1;
-   int idx;
-   R x;
-
-   assert(this->thesolver->coWeights.dim() == this->thesolver->coTest().dim());
-
-   for(int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->infeasibilities.index(i);
-      x = cTest[idx];
-
-      if(x < -feastol)
-      {
-         x = devexpr::computePrice(x, cpen[idx], feastol);
-
-         if(x > best)
-         {
-            best = x;
-            enterIdx = idx;
-            last = cpen[idx];
-         }
+SPxId SPxDevexPR<R>::selectEnterSparseDim(R &best, R feastol) {
+  const R *cTest = this->thesolver->coTest().get_const_ptr();
+  const R *cpen = this->thesolver->coWeights.get_const_ptr();
+  int enterIdx = -1;
+  int idx;
+  R x;
+
+  assert(this->thesolver->coWeights.dim() == this->thesolver->coTest().dim());
+
+  for (int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->infeasibilities.index(i);
+    x = cTest[idx];
+
+    if (x < -feastol) {
+      x = devexpr::computePrice(x, cpen[idx], feastol);
+
+      if (x > best) {
+        best = x;
+        enterIdx = idx;
+        last = cpen[idx];
       }
-      else
-      {
-         this->thesolver->infeasibilities.remove(i);
-         this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
-      }
-   }
+    } else {
+      this->thesolver->infeasibilities.remove(i);
+      this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
+    }
+  }
 
-   if(enterIdx >= 0)
-      return this->thesolver->coId(enterIdx);
+  if (enterIdx >= 0)
+    return this->thesolver->coId(enterIdx);
 
-   return SPxId();
+  return SPxId();
 }
 
-
 template <class R>
-SPxId SPxDevexPR<R>::selectEnterSparseCoDim(R& best, R feastol)
-{
-   const R* test = this->thesolver->test().get_const_ptr();
-   const R* pen = this->thesolver->weights.get_const_ptr();
-   int enterIdx = -1;
-   int idx;
-   R x;
-
-   assert(this->thesolver->weights.dim() == this->thesolver->test().dim());
-
-   for(int i = this->thesolver->infeasibilitiesCo.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->infeasibilitiesCo.index(i);
-      x = test[idx];
-
-      if(x < -feastol)
-      {
-         x = devexpr::computePrice(x, pen[idx], feastol);
-
-         if(x > best)
-         {
-            best = x;
-            enterIdx = idx;
-            last = pen[idx];
-         }
+SPxId SPxDevexPR<R>::selectEnterSparseCoDim(R &best, R feastol) {
+  const R *test = this->thesolver->test().get_const_ptr();
+  const R *pen = this->thesolver->weights.get_const_ptr();
+  int enterIdx = -1;
+  int idx;
+  R x;
+
+  assert(this->thesolver->weights.dim() == this->thesolver->test().dim());
+
+  for (int i = this->thesolver->infeasibilitiesCo.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->infeasibilitiesCo.index(i);
+    x = test[idx];
+
+    if (x < -feastol) {
+      x = devexpr::computePrice(x, pen[idx], feastol);
+
+      if (x > best) {
+        best = x;
+        enterIdx = idx;
+        last = pen[idx];
       }
-      else
-      {
-         this->thesolver->infeasibilitiesCo.remove(i);
-         this->thesolver->isInfeasibleCo[idx] = this->NOT_VIOLATED;
-      }
-   }
+    } else {
+      this->thesolver->infeasibilitiesCo.remove(i);
+      this->thesolver->isInfeasibleCo[idx] = this->NOT_VIOLATED;
+    }
+  }
 
-   if(enterIdx >= 0)
-      return this->thesolver->id(enterIdx);
+  if (enterIdx >= 0)
+    return this->thesolver->id(enterIdx);
 
-   return SPxId();
+  return SPxId();
 }
 
-
 template <class R>
-SPxId SPxDevexPR<R>::selectEnterDenseDim(R& best, R feastol, int start, int incr)
-{
-   const R* cTest = this->thesolver->coTest().get_const_ptr();
-   const R* cpen = this->thesolver->coWeights.get_const_ptr();
-   int end = this->thesolver->coWeights.dim();
-   int enterIdx = -1;
-   R x;
-
-   assert(end == this->thesolver->coTest().dim());
-
-   for(; start < end; start += incr)
-   {
-      x = cTest[start];
-
-      if(x < -feastol)
-      {
-         x = devexpr::computePrice(x, cpen[start], feastol);
-
-         if(x > best)
-         {
-            best = x;
-            enterIdx = start;
-            last = cpen[start];
-         }
+SPxId SPxDevexPR<R>::selectEnterDenseDim(R &best, R feastol, int start,
+                                         int incr) {
+  const R *cTest = this->thesolver->coTest().get_const_ptr();
+  const R *cpen = this->thesolver->coWeights.get_const_ptr();
+  int end = this->thesolver->coWeights.dim();
+  int enterIdx = -1;
+  R x;
+
+  assert(end == this->thesolver->coTest().dim());
+
+  for (; start < end; start += incr) {
+    x = cTest[start];
+
+    if (x < -feastol) {
+      x = devexpr::computePrice(x, cpen[start], feastol);
+
+      if (x > best) {
+        best = x;
+        enterIdx = start;
+        last = cpen[start];
       }
-   }
+    }
+  }
 
-   if(enterIdx >= 0)
-      return this->thesolver->coId(enterIdx);
+  if (enterIdx >= 0)
+    return this->thesolver->coId(enterIdx);
 
-   return SPxId();
+  return SPxId();
 }
 
 template <class R>
-SPxId SPxDevexPR<R>::selectEnterDenseCoDim(R& best, R feastol, int start, int incr)
-{
-   const R* test = this->thesolver->test().get_const_ptr();
-   const R* pen = this->thesolver->weights.get_const_ptr();
-   int end = this->thesolver->weights.dim();
-   int enterIdx = -1;
-   R x;
-
-   assert(end == this->thesolver->test().dim());
-
-   for(; start < end; start += incr)
-   {
-      x = test[start];
-
-      if(test[start] < -feastol)
-      {
-         x = devexpr::computePrice(x, pen[start], feastol);
-
-         if(x > best)
-         {
-            best = x;
-            enterIdx = start;
-            last = pen[start];
-         }
+SPxId SPxDevexPR<R>::selectEnterDenseCoDim(R &best, R feastol, int start,
+                                           int incr) {
+  const R *test = this->thesolver->test().get_const_ptr();
+  const R *pen = this->thesolver->weights.get_const_ptr();
+  int end = this->thesolver->weights.dim();
+  int enterIdx = -1;
+  R x;
+
+  assert(end == this->thesolver->test().dim());
+
+  for (; start < end; start += incr) {
+    x = test[start];
+
+    if (test[start] < -feastol) {
+      x = devexpr::computePrice(x, pen[start], feastol);
+
+      if (x > best) {
+        best = x;
+        enterIdx = start;
+        last = pen[start];
       }
-   }
+    }
+  }
 
-   if(enterIdx >= 0)
-      return this->thesolver->id(enterIdx);
+  if (enterIdx >= 0)
+    return this->thesolver->id(enterIdx);
 
-   return SPxId();
+  return SPxId();
 }
 
-
 /**@todo suspicious: the pricer should be informed, that variable id
    has entered the basis at position n, but the id is not used here
    (this is true for all pricers)
 */
-template <class R>
-void SPxDevexPR<R>::entered4(SPxId /*id*/, int n)
-{
-   VectorBase<R>& weights = this->thesolver->weights;
-   VectorBase<R>& coWeights = this->thesolver->coWeights;
-
-   if(n >= 0 && n < this->thesolver->dim())
-   {
-      const R* pVec = this->thesolver->pVec().delta().values();
-      const IdxSet& pIdx = this->thesolver->pVec().idx();
-      const R* coPvec = this->thesolver->coPvec().delta().values();
-      const IdxSet& coPidx = this->thesolver->coPvec().idx();
-      R xi_p = 1 / this->thesolver->fVec().delta()[n];
-      int i, j;
-
-      assert(this->thesolver->fVec().delta()[n] > this->thesolver->epsilon()
-             || this->thesolver->fVec().delta()[n] < -this->thesolver->epsilon());
-
-      xi_p = xi_p * xi_p * last;
-
-      for(j = coPidx.size() - 1; j >= 0; --j)
-      {
-         i = coPidx.index(j);
-         coWeights[i] += xi_p * coPvec[i] * coPvec[i];
-
-         if(coWeights[i] <= 1 || coWeights[i] > 1e+6)
-         {
-            setupWeights(SPxSolverBase<R>::ENTER);
-            return;
-         }
+template <class R> void SPxDevexPR<R>::entered4(SPxId /*id*/, int n) {
+  VectorBase<R> &weights = this->thesolver->weights;
+  VectorBase<R> &coWeights = this->thesolver->coWeights;
+
+  if (n >= 0 && n < this->thesolver->dim()) {
+    const R *pVec = this->thesolver->pVec().delta().values();
+    const IdxSet &pIdx = this->thesolver->pVec().idx();
+    const R *coPvec = this->thesolver->coPvec().delta().values();
+    const IdxSet &coPidx = this->thesolver->coPvec().idx();
+    R xi_p = 1 / this->thesolver->fVec().delta()[n];
+    int i, j;
+
+    assert(this->thesolver->fVec().delta()[n] > this->thesolver->epsilon() ||
+           this->thesolver->fVec().delta()[n] < -this->thesolver->epsilon());
+
+    xi_p = xi_p * xi_p * last;
+
+    for (j = coPidx.size() - 1; j >= 0; --j) {
+      i = coPidx.index(j);
+      coWeights[i] += xi_p * coPvec[i] * coPvec[i];
+
+      if (coWeights[i] <= 1 || coWeights[i] > 1e+6) {
+        setupWeights(SPxSolverBase<R>::ENTER);
+        return;
       }
+    }
 
-      for(j = pIdx.size() - 1; j >= 0; --j)
-      {
-         i = pIdx.index(j);
-         weights[i] += xi_p * pVec[i] * pVec[i];
+    for (j = pIdx.size() - 1; j >= 0; --j) {
+      i = pIdx.index(j);
+      weights[i] += xi_p * pVec[i] * pVec[i];
 
-         if(weights[i] <= 1 || weights[i] > 1e+6)
-         {
-            setupWeights(SPxSolverBase<R>::ENTER);
-            return;
-         }
+      if (weights[i] <= 1 || weights[i] > 1e+6) {
+        setupWeights(SPxSolverBase<R>::ENTER);
+        return;
       }
-   }
+    }
+  }
 }
 
-template <class R>
-void SPxDevexPR<R>::addedVecs(int n)
-{
-   int initval = (this->thesolver->type() == SPxSolverBase<R>::ENTER) ? 2 : 1;
-   VectorBase<R>& weights = this->thesolver->weights;
-   n = weights.dim();
-   weights.reDim(this->thesolver->coDim());
-
-   for(int i = weights.dim() - 1; i >= n; --i)
-      weights[i] = initval;
+template <class R> void SPxDevexPR<R>::addedVecs(int n) {
+  int initval = (this->thesolver->type() == SPxSolverBase<R>::ENTER) ? 2 : 1;
+  VectorBase<R> &weights = this->thesolver->weights;
+  n = weights.dim();
+  weights.reDim(this->thesolver->coDim());
+
+  for (int i = weights.dim() - 1; i >= n; --i)
+    weights[i] = initval;
 }
 
-template <class R>
-void SPxDevexPR<R>::addedCoVecs(int n)
-{
-   int initval = (this->thesolver->type() == SPxSolverBase<R>::ENTER) ? 2 : 1;
-   VectorBase<R>& coWeights = this->thesolver->coWeights;
-   n = coWeights.dim();
-   coWeights.reDim(this->thesolver->dim());
-
-   for(int i = coWeights.dim() - 1; i >= n; --i)
-      coWeights[i] = initval;
+template <class R> void SPxDevexPR<R>::addedCoVecs(int n) {
+  int initval = (this->thesolver->type() == SPxSolverBase<R>::ENTER) ? 2 : 1;
+  VectorBase<R> &coWeights = this->thesolver->coWeights;
+  n = coWeights.dim();
+  coWeights.reDim(this->thesolver->dim());
+
+  for (int i = coWeights.dim() - 1; i >= n; --i)
+    coWeights[i] = initval;
 }
 
 } // namespace soplex
diff --git a/src/soplex/spxequilisc.hpp b/src/soplex/spxequilisc.hpp
index 4c43d6f..531e00d 100644
--- a/src/soplex/spxequilisc.hpp
+++ b/src/soplex/spxequilisc.hpp
@@ -21,246 +21,233 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 /**@file  spxequilisc.hpp
  * @brief Equilibrium row/column scaling.
  */
 #include <assert.h>
 
-#include "soplex/spxout.h"
-#include "soplex/spxlpbase.h"
-#include "soplex/spxlp.h"
 #include "soplex.h"
+#include "soplex/spxlp.h"
+#include "soplex/spxlpbase.h"
+#include "soplex/spxout.h"
 
-namespace soplex
-{
-static inline const char* makename(bool doBoth)
-{
-   return doBoth ? "bi-Equilibrium" : "uni-Equilibrium";
+namespace soplex {
+static inline const char *makename(bool doBoth) {
+  return doBoth ? "bi-Equilibrium" : "uni-Equilibrium";
 }
 
-/// maximum ratio between absolute biggest and smallest element in any scaled row/column.
+/// maximum ratio between absolute biggest and smallest element in any scaled
+/// row/column.
 template <class R>
-static R maxPrescaledRatio(const SPxLPBase<R>& lp, const std::vector<R>& coScaleval, bool rowRatio)
-{
-   R pmax = 0.0;
-   const int n = rowRatio ? lp.nRows() : lp.nCols();
+static R maxPrescaledRatio(const SPxLPBase<R> &lp,
+                           const std::vector<R> &coScaleval, bool rowRatio) {
+  R pmax = 0.0;
+  const int n = rowRatio ? lp.nRows() : lp.nCols();
 
-   for(int i = 0; i < n; ++i)
-   {
-      const SVectorBase<R>& vec = rowRatio ? lp.rowVector(i) : lp.colVector(i);
-      R mini = R(infinity);
-      R maxi = 0.0;
+  for (int i = 0; i < n; ++i) {
+    const SVectorBase<R> &vec = rowRatio ? lp.rowVector(i) : lp.colVector(i);
+    R mini = R(infinity);
+    R maxi = 0.0;
 
-      for(int j = 0; j < vec.size(); ++j)
-      {
-         assert(vec.index(j) >= 0);
-         const R x = spxAbs(vec.value(j)) * coScaleval[unsigned(vec.index(j))];
+    for (int j = 0; j < vec.size(); ++j) {
+      assert(vec.index(j) >= 0);
+      const R x = spxAbs(vec.value(j)) * coScaleval[unsigned(vec.index(j))];
 
-         if(isZero(x))
-            continue;
+      if (isZero(x))
+        continue;
 
-         if(x < mini)
-            mini = x;
+      if (x < mini)
+        mini = x;
 
-         if(x > maxi)
-            maxi = x;
-      }
+      if (x > maxi)
+        maxi = x;
+    }
 
-      if(mini == R(infinity))
-         continue;
+    if (mini == R(infinity))
+      continue;
 
-      const R p = maxi / mini;
+    const R p = maxi / mini;
 
-      if(p > pmax)
-         pmax = p;
-   }
+    if (p > pmax)
+      pmax = p;
+  }
 
-   return pmax;
+  return pmax;
 }
 
 template <class R>
-void SPxEquiliSC<R>::computeEquiExpVec(const SVSetBase<R>* vecset, const DataArray<int>& coScaleExp,
-                                       DataArray<int>& scaleExp)
-{
-   assert(vecset != nullptr);
+void SPxEquiliSC<R>::computeEquiExpVec(const SVSetBase<R> *vecset,
+                                       const DataArray<int> &coScaleExp,
+                                       DataArray<int> &scaleExp) {
+  assert(vecset != nullptr);
 
-   for(int i = 0; i < vecset->num(); ++i)
-   {
-      const SVectorBase<R>& vec = (*vecset)[i];
+  for (int i = 0; i < vecset->num(); ++i) {
+    const SVectorBase<R> &vec = (*vecset)[i];
 
-      R maxi = 0.0;
+    R maxi = 0.0;
 
-      for(int j = 0; j < vec.size(); ++j)
-      {
-         const R x = spxAbs(spxLdexp(vec.value(j), coScaleExp[vec.index(j)]));
+    for (int j = 0; j < vec.size(); ++j) {
+      const R x = spxAbs(spxLdexp(vec.value(j), coScaleExp[vec.index(j)]));
 
-         if(GT(x, maxi))
-            maxi = x;
-      }
+      if (GT(x, maxi))
+        maxi = x;
+    }
 
-      // empty rows/cols are possible
-      if(maxi == 0.0)
-         maxi = 1.0;
+    // empty rows/cols are possible
+    if (maxi == 0.0)
+      maxi = 1.0;
 
-      assert(maxi > 0.0);
+    assert(maxi > 0.0);
 
-      spxFrexp(Real(1.0 / maxi), &(scaleExp[i]));
+    spxFrexp(Real(1.0 / maxi), &(scaleExp[i]));
 
-      scaleExp[i] -= 1;
-   }
+    scaleExp[i] -= 1;
+  }
 }
 
 template <class R>
-void SPxEquiliSC<R>::computeEquiExpVec(const SVSetBase<R>* vecset, const std::vector<R>& coScaleVal,
-                                       DataArray<int>& scaleExp)
-{
-   assert(vecset != nullptr);
+void SPxEquiliSC<R>::computeEquiExpVec(const SVSetBase<R> *vecset,
+                                       const std::vector<R> &coScaleVal,
+                                       DataArray<int> &scaleExp) {
+  assert(vecset != nullptr);
 
-   for(int i = 0; i < vecset->num(); ++i)
-   {
-      const SVectorBase<R>& vec = (*vecset)[i];
+  for (int i = 0; i < vecset->num(); ++i) {
+    const SVectorBase<R> &vec = (*vecset)[i];
 
-      R maxi = 0.0;
+    R maxi = 0.0;
 
-      for(int j = 0; j < vec.size(); ++j)
-      {
-         assert(vec.index(j) >= 0);
-         const R x = spxAbs(vec.value(j) * coScaleVal[unsigned(vec.index(j))]);
+    for (int j = 0; j < vec.size(); ++j) {
+      assert(vec.index(j) >= 0);
+      const R x = spxAbs(vec.value(j) * coScaleVal[unsigned(vec.index(j))]);
 
-         if(GT(x, maxi))
-            maxi = x;
-      }
+      if (GT(x, maxi))
+        maxi = x;
+    }
 
-      // empty rows/cols are possible
-      if(maxi == 0.0)
-         maxi = 1.0;
+    // empty rows/cols are possible
+    if (maxi == 0.0)
+      maxi = 1.0;
 
-      assert(maxi > 0.0);
+    assert(maxi > 0.0);
 
-      spxFrexp(Real(1.0 / maxi), &(scaleExp[i]));
+    spxFrexp(Real(1.0 / maxi), &(scaleExp[i]));
 
-      scaleExp[i] -= 1;
-   }
+    scaleExp[i] -= 1;
+  }
 }
 
 template <class R>
-void SPxEquiliSC<R>::computePostequiExpVecs(const SPxLPBase<R>& lp,
-      const std::vector<R>& preRowscale, const std::vector<R>& preColscale,
-      DataArray<int>& rowscaleExp, DataArray<int>& colscaleExp)
-{
-   const R colratio = maxPrescaledRatio(lp, preRowscale, false);
-   const R rowratio = maxPrescaledRatio(lp, preColscale, true);
-
-   const bool colFirst = colratio < rowratio;
-
-   // see SPxEquiliSC<R>::scale for reason behind this branch
-   if(colFirst)
-   {
-      computeEquiExpVec(lp.colSet(), preRowscale, colscaleExp);
-      computeEquiExpVec(lp.rowSet(), colscaleExp, rowscaleExp);
-   }
-   else
-   {
-      computeEquiExpVec(lp.rowSet(), preColscale, rowscaleExp);
-      computeEquiExpVec(lp.colSet(), rowscaleExp, colscaleExp);
-   }
+void SPxEquiliSC<R>::computePostequiExpVecs(const SPxLPBase<R> &lp,
+                                            const std::vector<R> &preRowscale,
+                                            const std::vector<R> &preColscale,
+                                            DataArray<int> &rowscaleExp,
+                                            DataArray<int> &colscaleExp) {
+  const R colratio = maxPrescaledRatio(lp, preRowscale, false);
+  const R rowratio = maxPrescaledRatio(lp, preColscale, true);
+
+  const bool colFirst = colratio < rowratio;
+
+  // see SPxEquiliSC<R>::scale for reason behind this branch
+  if (colFirst) {
+    computeEquiExpVec(lp.colSet(), preRowscale, colscaleExp);
+    computeEquiExpVec(lp.rowSet(), colscaleExp, rowscaleExp);
+  } else {
+    computeEquiExpVec(lp.rowSet(), preColscale, rowscaleExp);
+    computeEquiExpVec(lp.colSet(), rowscaleExp, colscaleExp);
+  }
 }
 
 template <class R>
 SPxEquiliSC<R>::SPxEquiliSC(bool doBoth)
-   : SPxScaler<R>(makename(doBoth), false, doBoth)
-{}
+    : SPxScaler<R>(makename(doBoth), false, doBoth) {}
 
 template <class R>
-SPxEquiliSC<R>::SPxEquiliSC(const SPxEquiliSC<R>& old)
-   : SPxScaler<R>(old)
-{}
+SPxEquiliSC<R>::SPxEquiliSC(const SPxEquiliSC<R> &old) : SPxScaler<R>(old) {}
 
 template <class R>
-SPxEquiliSC<R>& SPxEquiliSC<R>::operator=(const SPxEquiliSC<R>& rhs)
-{
-   if(this != &rhs)
-   {
-      SPxScaler<R>::operator=(rhs);
-   }
-
-   return *this;
+SPxEquiliSC<R> &SPxEquiliSC<R>::operator=(const SPxEquiliSC<R> &rhs) {
+  if (this != &rhs) {
+    SPxScaler<R>::operator=(rhs);
+  }
+
+  return *this;
 }
 
 template <class R>
-void SPxEquiliSC<R>::scale(SPxLPBase<R>& lp, bool persistent)
-{
-
-   MSG_INFO1((*this->spxout), (*this->spxout) << "Equilibrium scaling LP" <<
-             (persistent ? " (persistent)" : "") << std::endl;)
-
-   this->setup(lp);
-
-   /* We want to do the direction first, which has a lower maximal ratio,
-    * since the lowest value in the scaled matrix is bounded from below by
-    * the inverse of the maximum ratio of the direction that is done first
-    * Example:
-    *
-    *                     Rowratio
-    *            0.1  1   10
-    *            10   1   10
-    *
-    * Colratio   100  1
-    *
-    * Row first =>         Col next =>
-    *            0.1  1          0.1  1
-    *            1    0.1        1    0.1
-    *
-    * Col first =>         Row next =>
-    *            0.01 1          0.01 1
-    *            1    1          1    1
-    *
-    */
-   R colratio = this->maxColRatio(lp);
-   R rowratio = this->maxRowRatio(lp);
-
-   bool colFirst = colratio < rowratio;
-
-   MSG_INFO2((*this->spxout), (*this->spxout) << "before scaling:"
-             << " min= " << lp.minAbsNzo()
-             << " max= " << lp.maxAbsNzo()
-             << " col-ratio= " << colratio
-             << " row-ratio= " << rowratio
-             << std::endl;)
-
-   if(colFirst)
-   {
-      computeEquiExpVec(lp.colSet(), *this->m_activeRowscaleExp, *this->m_activeColscaleExp);
-
-      if(this->m_doBoth)
-         computeEquiExpVec(lp.rowSet(), *this->m_activeColscaleExp, *this->m_activeRowscaleExp);
-   }
-   else
-   {
-      computeEquiExpVec(lp.rowSet(), *this->m_activeColscaleExp, *this->m_activeRowscaleExp);
-
-      if(this->m_doBoth)
-         computeEquiExpVec(lp.colSet(), *this->m_activeRowscaleExp, *this->m_activeColscaleExp);
-   }
-
-   /* scale */
-   this->applyScaling(lp);
-
-   MSG_INFO3((*this->spxout), (*this->spxout) << "Row scaling min= " << this->minAbsRowscale()
-             << " max= " << this->maxAbsRowscale()
-             << std::endl
-             << "Col scaling min= " << this->minAbsColscale()
-             << " max= " << this->maxAbsColscale()
-             << std::endl;)
-
-   MSG_INFO2((*this->spxout), (*this->spxout) << "after scaling: "
-             << " min= " << lp.minAbsNzo(false)
-             << " max= " << lp.maxAbsNzo(false)
-             << " col-ratio= " << this->maxColRatio(lp)
-             << " row-ratio= " << this->maxRowRatio(lp)
-             << std::endl;)
-
+void SPxEquiliSC<R>::scale(SPxLPBase<R> &lp, bool persistent) {
+
+  MSG_INFO1((*this->spxout), (*this->spxout)
+                                 << "Equilibrium scaling LP"
+                                 << (persistent ? " (persistent)" : "")
+                                 << std::endl;)
+
+  this->setup(lp);
+
+  /* We want to do the direction first, which has a lower maximal ratio,
+   * since the lowest value in the scaled matrix is bounded from below by
+   * the inverse of the maximum ratio of the direction that is done first
+   * Example:
+   *
+   *                     Rowratio
+   *            0.1  1   10
+   *            10   1   10
+   *
+   * Colratio   100  1
+   *
+   * Row first =>         Col next =>
+   *            0.1  1          0.1  1
+   *            1    0.1        1    0.1
+   *
+   * Col first =>         Row next =>
+   *            0.01 1          0.01 1
+   *            1    1          1    1
+   *
+   */
+  R colratio = this->maxColRatio(lp);
+  R rowratio = this->maxRowRatio(lp);
+
+  bool colFirst = colratio < rowratio;
+
+  MSG_INFO2((*this->spxout), (*this->spxout)
+                                 << "before scaling:"
+                                 << " min= " << lp.minAbsNzo() << " max= "
+                                 << lp.maxAbsNzo() << " col-ratio= " << colratio
+                                 << " row-ratio= " << rowratio << std::endl;)
+
+  if (colFirst) {
+    computeEquiExpVec(lp.colSet(), *this->m_activeRowscaleExp,
+                      *this->m_activeColscaleExp);
+
+    if (this->m_doBoth)
+      computeEquiExpVec(lp.rowSet(), *this->m_activeColscaleExp,
+                        *this->m_activeRowscaleExp);
+  } else {
+    computeEquiExpVec(lp.rowSet(), *this->m_activeColscaleExp,
+                      *this->m_activeRowscaleExp);
+
+    if (this->m_doBoth)
+      computeEquiExpVec(lp.colSet(), *this->m_activeRowscaleExp,
+                        *this->m_activeColscaleExp);
+  }
+
+  /* scale */
+  this->applyScaling(lp);
+
+  MSG_INFO3((*this->spxout),
+            (*this->spxout) << "Row scaling min= " << this->minAbsRowscale()
+                            << " max= " << this->maxAbsRowscale() << std::endl
+                            << "Col scaling min= " << this->minAbsColscale()
+                            << " max= " << this->maxAbsColscale() << std::endl;)
+
+  MSG_INFO2((*this->spxout), (*this->spxout)
+                                 << "after scaling: "
+                                 << " min= " << lp.minAbsNzo(false)
+                                 << " max= " << lp.maxAbsNzo(false)
+                                 << " col-ratio= " << this->maxColRatio(lp)
+                                 << " row-ratio= " << this->maxRowRatio(lp)
+                                 << std::endl;)
 }
 
 } // namespace soplex
diff --git a/src/soplex/spxfastrt.hpp b/src/soplex/spxfastrt.hpp
index 7add394..221118d 100644
--- a/src/soplex/spxfastrt.hpp
+++ b/src/soplex/spxfastrt.hpp
@@ -21,6 +21,7 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <assert.h>
 #include <stdio.h>
@@ -35,1542 +36,1338 @@
   improvements.
 
   The algorithms operates in two phases. In a first phase, the maximum value
-  |val| is determined, when infeasibility within |delta| is allowed. In the second
-  phase, between all variables with value < |val| the one is selected which
-  has the largest update Vector component. However, this may not
-  always yield an improvement. In that case, we shift the variable towards
+  |val| is determined, when infeasibility within |delta| is allowed. In the
+  second phase, between all variables with value < |val| the one is selected
+  which has the largest update Vector component. However, this may not always
+  yield an improvement. In that case, we shift the variable towards
   infeasibility and retry. This avoids cycling in the shifted LP.
 */
 
-namespace soplex
-{
-
-#define MINSTAB         1e-5
-#define LOWSTAB         1e-10
-#define TRIES           2
-#define SHORTVAL           1e-5
-#define DELTA_SHIFT     1e-5
-#define EPSILON         1e-10
+namespace soplex {
+
+#define MINSTAB 1e-5
+#define LOWSTAB 1e-10
+#define TRIES 2
+#define SHORTVAL 1e-5
+#define DELTA_SHIFT 1e-5
+#define EPSILON 1e-10
+
+template <class R> void SPxFastRT<R>::resetTols() {
+  // epsilon = thesolver->epsilon();
+  epsilon = EPSILON;
+  /*
+    if(thesolver->basis().stability() < 1e-4)
+    epsilon *= 1e-4 / thesolver->basis().stability();
+  */
+}
 
+template <class R> void SPxFastRT<R>::tighten() {
+  /*
+    if((delta > 1.99 * DELTA_SHIFT  &&  thesolver->theShift < 1e-4) ||
+    (delta > 1e-4   &&  thesolver->theShift > 1e-4))
+  */
+  // if(delta > 1.99 * DELTA_SHIFT)
+  if (fastDelta >= this->delta + DELTA_SHIFT) {
+    fastDelta -= DELTA_SHIFT;
 
+    if (fastDelta > 1e-4)
+      fastDelta -= 2 * DELTA_SHIFT;
+  }
 
-template <class R>
-void SPxFastRT<R>::resetTols()
-{
-   // epsilon = thesolver->epsilon();
-   epsilon = EPSILON;
-   /*
-     if(thesolver->basis().stability() < 1e-4)
-     epsilon *= 1e-4 / thesolver->basis().stability();
-   */
-}
+  if (minStab < MINSTAB) {
+    minStab /= 0.90;
 
-template <class R>
-void SPxFastRT<R>::tighten()
-{
-   /*
-     if((delta > 1.99 * DELTA_SHIFT  &&  thesolver->theShift < 1e-4) ||
-     (delta > 1e-4   &&  thesolver->theShift > 1e-4))
-   */
-   // if(delta > 1.99 * DELTA_SHIFT)
-   if(fastDelta >= this->delta + DELTA_SHIFT)
-   {
-      fastDelta -= DELTA_SHIFT;
-
-      if(fastDelta > 1e-4)
-         fastDelta -= 2 * DELTA_SHIFT;
-   }
-
-   if(minStab < MINSTAB)
-   {
+    if (minStab < 1e-6)
       minStab /= 0.90;
-
-      if(minStab < 1e-6)
-         minStab /= 0.90;
-   }
+  }
 }
 
-template <class R>
-void SPxFastRT<R>::relax()
-{
-   minStab *= 0.95;
-   fastDelta += 3 * DELTA_SHIFT;
-   // delta   += 2 * (thesolver->theShift > delta) * DELTA_SHIFT;
+template <class R> void SPxFastRT<R>::relax() {
+  minStab *= 0.95;
+  fastDelta += 3 * DELTA_SHIFT;
+  // delta   += 2 * (thesolver->theShift > delta) * DELTA_SHIFT;
 }
 
-template <class R>
-R SPxFastRT<R>::minStability(R maxabs)
-{
-   if(maxabs < 1000.0)
-      return minStab;
+template <class R> R SPxFastRT<R>::minStability(R maxabs) {
+  if (maxabs < 1000.0)
+    return minStab;
 
-   return maxabs * minStab / 1000.0;
+  return maxabs * minStab / 1000.0;
 }
 
-/* The code below implements phase 1 of the ratio test. It differs from the description in the
- * Ph.D. thesis page 57 as follows: It uses \f$\delta_i = d_i - s_i - \delta\f$ if \f$d_i > s_i\f$.
+/* The code below implements phase 1 of the ratio test. It differs from the
+ * description in the Ph.D. thesis page 57 as follows: It uses \f$\delta_i = d_i
+ * - s_i - \delta\f$ if \f$d_i > s_i\f$.
  *
- * This change leads to the following behavior of the source code. Consider the first case (x >
- * epsilon, u < infinity): If u - vec[i] <= 0, vec[i] violates the upper bound. In the Harris ratio
- * test, we would compute (u - vec[i] + delta)/upd[i]. The code computes instead delta/upd[i].
+ * This change leads to the following behavior of the source code. Consider the
+ * first case (x > epsilon, u < infinity): If u - vec[i] <= 0, vec[i] violates
+ * the upper bound. In the Harris ratio test, we would compute (u - vec[i] +
+ * delta)/upd[i]. The code computes instead delta/upd[i].
  */
 template <class R>
 int SPxFastRT<R>::maxDelta(
-   R& val,                                /* on return: maximum step length */
-   R& maxabs,                             /* on return: maximum absolute value in upd VectorBase<R> */
-   UpdateVector<R>& update,
-   const VectorBase<R>& lowBound,
-   const VectorBase<R>& upBound,
-   int start,
-   int incr) const
-{
-   int i, sel;
-   R x, y, max;
-   R u, l;
-   bool leaving = this->m_type == SPxSolverBase<R>::LEAVE;
-   bool enterrowrep = !leaving && this->thesolver->theRep == SPxSolverBase<R>::ROW;
-
-   R mabs = maxabs;
+    R &val,    /* on return: maximum step length */
+    R &maxabs, /* on return: maximum absolute value in upd VectorBase<R> */
+    UpdateVector<R> &update, const VectorBase<R> &lowBound,
+    const VectorBase<R> &upBound, int start, int incr) const {
+  int i, sel;
+  R x, y, max;
+  R u, l;
+  bool leaving = this->m_type == SPxSolverBase<R>::LEAVE;
+  bool enterrowrep =
+      !leaving && this->thesolver->theRep == SPxSolverBase<R>::ROW;
+
+  R mabs = maxabs;
+
+  const R *up = upBound.get_const_ptr();
+  const R *low = lowBound.get_const_ptr();
+  const R *vec = update.get_const_ptr();
+  const R *upd = update.delta().values();
+  const int *idx = update.delta().indexMem();
+
+  sel = -1;
+  max = val;
+
+  if (update.delta().isSetup()) {
+    const int *last = idx + update.delta().size();
+
+    for (idx += start; idx < last; idx += incr) {
+      i = *idx;
 
-   const R* up = upBound.get_const_ptr();
-   const R* low = lowBound.get_const_ptr();
-   const R* vec = update.get_const_ptr();
-   const R* upd = update.delta().values();
-   const int* idx = update.delta().indexMem();
+      /* in the dual algorithm, bound flips cannot happen, hence we only
+       * consider nonbasic variables */
+      if (leaving && ((iscoid && this->thesolver->isCoBasic(i)) ||
+                      (!iscoid && this->thesolver->isBasic(i))))
+        continue;
 
-   sel = -1;
-   max = val;
+      if (enterrowrep && this->thesolver->baseId(i).isSPxColId() &&
+          this->thesolver->desc().colStatus(this->thesolver->number(SPxColId(
+              this->thesolver->baseId(i)))) == SPxBasisBase<R>::Desc::P_FIXED)
+        continue;
 
-   if(update.delta().isSetup())
-   {
-      const int* last = idx + update.delta().size();
+      x = upd[i];
 
-      for(idx += start; idx < last; idx += incr)
-      {
-         i = *idx;
-
-         /* in the dual algorithm, bound flips cannot happen, hence we only consider nonbasic variables */
-         if(leaving && ((iscoid && this->thesolver->isCoBasic(i)) || (!iscoid
-                        && this->thesolver->isBasic(i))))
-            continue;
-
-         if(enterrowrep && this->thesolver->baseId(i).isSPxColId()
-               && this->thesolver->desc().colStatus(this->thesolver->number(SPxColId(this->thesolver->baseId(i))))
-               == SPxBasisBase<R>::Desc::P_FIXED)
-            continue;
-
-         x = upd[i];
-
-         if(x > epsilon)
-         {
-            // @todo check wether mabs should be computed only over bounded vars, i.e., in the if block below
-            mabs = (x > mabs) ? x : mabs;
-            u = up[i];
-
-            if(u < R(infinity))
-            {
-               y = u - vec[i];
-
-               if(y <= 0)
-                  x = fastDelta / x;
-               else
-                  x = (y + fastDelta) / x;
-
-               if(x < max)
-               {
-                  max = x;
-                  sel = i;
-               }
-            }
-         }
-         else if(x < -epsilon)
-         {
-            // @todo check wether mabs should be computed only over bounded vars, i.e., in the if block below
-            mabs = (-x > mabs) ? -x : mabs;
-            l = low[i];
-
-            if(l > R(-infinity))
-            {
-               y = l - vec[i];
-
-               if(y >= 0)
-                  x = - fastDelta / x;
-               else
-                  x = (y - fastDelta) / x;
-
-               if(x < max)
-               {
-                  max = x;
-                  sel = i;
-               }
-            }
-         }
+      if (x > epsilon) {
+        // @todo check wether mabs should be computed only over bounded vars,
+        // i.e., in the if block below
+        mabs = (x > mabs) ? x : mabs;
+        u = up[i];
+
+        if (u < R(infinity)) {
+          y = u - vec[i];
+
+          if (y <= 0)
+            x = fastDelta / x;
+          else
+            x = (y + fastDelta) / x;
+
+          if (x < max) {
+            max = x;
+            sel = i;
+          }
+        }
+      } else if (x < -epsilon) {
+        // @todo check wether mabs should be computed only over bounded vars,
+        // i.e., in the if block below
+        mabs = (-x > mabs) ? -x : mabs;
+        l = low[i];
+
+        if (l > R(-infinity)) {
+          y = l - vec[i];
+
+          if (y >= 0)
+            x = -fastDelta / x;
+          else
+            x = (y - fastDelta) / x;
+
+          if (x < max) {
+            max = x;
+            sel = i;
+          }
+        }
       }
-   }
-   else
-   {
-      /* In this case, the indices of the semi-sparse Vector update.delta() are not set up and are filled below. */
-      int* l_idx = update.delta().altIndexMem();
-      R* uval = update.delta().altValues();
-      const R* uend = uval + update.dim();
-      assert(uval == upd);
-
-      for(i = 0; uval < uend; ++uval, ++i)
-      {
-         x = *uval;
-
-         if(x != 0.0)
-         {
-            if(x >= -epsilon && x <= epsilon)
-            {
-               *uval = 0.0;
-               continue;
-            }
+    }
+  } else {
+    /* In this case, the indices of the semi-sparse Vector update.delta() are
+     * not set up and are filled below. */
+    int *l_idx = update.delta().altIndexMem();
+    R *uval = update.delta().altValues();
+    const R *uend = uval + update.dim();
+    assert(uval == upd);
+
+    for (i = 0; uval < uend; ++uval, ++i) {
+      x = *uval;
+
+      if (x != 0.0) {
+        if (x >= -epsilon && x <= epsilon) {
+          *uval = 0.0;
+          continue;
+        } else
+          *l_idx++ = i;
+
+        /* in the dual algorithm, bound flips cannot happen, hence we only
+         * consider nonbasic variables */
+        if (leaving && ((iscoid && this->thesolver->isCoBasic(i)) ||
+                        (!iscoid && this->thesolver->isBasic(i))))
+          continue;
+
+        if (enterrowrep && this->thesolver->baseId(i).isSPxColId() &&
+            this->thesolver->desc().colStatus(this->thesolver->number(SPxColId(
+                this->thesolver->baseId(i)))) == SPxBasisBase<R>::Desc::P_FIXED)
+          continue;
+
+        if (x > epsilon) {
+          mabs = (x > mabs) ? x : mabs;
+          u = up[i];
+
+          if (u < R(infinity)) {
+            y = u - vec[i];
+
+            if (y <= 0)
+              x = fastDelta / x;
             else
-               *l_idx++ = i;
-
-            /* in the dual algorithm, bound flips cannot happen, hence we only consider nonbasic variables */
-            if(leaving && ((iscoid && this->thesolver->isCoBasic(i)) || (!iscoid
-                           && this->thesolver->isBasic(i))))
-               continue;
-
-            if(enterrowrep && this->thesolver->baseId(i).isSPxColId()
-                  && this->thesolver->desc().colStatus(this->thesolver->number(SPxColId(this->thesolver->baseId(i))))
-                  == SPxBasisBase<R>::Desc::P_FIXED)
-               continue;
-
-            if(x > epsilon)
-            {
-               mabs = (x > mabs) ? x : mabs;
-               u = up[i];
-
-               if(u < R(infinity))
-               {
-                  y = u - vec[i];
-
-                  if(y <= 0)
-                     x = fastDelta / x;
-                  else
-                     x = (y + fastDelta) / x;
-
-                  if(x < max)
-                  {
-                     max = x;
-                     sel = i;
-                  }
-               }
+              x = (y + fastDelta) / x;
+
+            if (x < max) {
+              max = x;
+              sel = i;
             }
-            else if(x < -epsilon)
-            {
-               mabs = (-x > mabs) ? -x : mabs;
-               l = low[i];
-
-               if(l > R(-infinity))
-               {
-                  y = l - vec[i];
-
-                  if(y >= 0)
-                     x = - fastDelta / x;
-                  else
-                     x = (y - fastDelta) / x;
-
-                  if(x < max)
-                  {
-                     max = x;
-                     sel = i;
-                  }
-               }
+          }
+        } else if (x < -epsilon) {
+          mabs = (-x > mabs) ? -x : mabs;
+          l = low[i];
+
+          if (l > R(-infinity)) {
+            y = l - vec[i];
+
+            if (y >= 0)
+              x = -fastDelta / x;
+            else
+              x = (y - fastDelta) / x;
+
+            if (x < max) {
+              max = x;
+              sel = i;
             }
-         }
+          }
+        }
       }
+    }
 
-      update.delta().setSize(int(l_idx - update.delta().indexMem()));
-      update.delta().forceSetup();
-   }
+    update.delta().setSize(int(l_idx - update.delta().indexMem()));
+    update.delta().forceSetup();
+  }
 
-   val = max;
-   maxabs = mabs;
-   return sel;
+  val = max;
+  maxabs = mabs;
+  return sel;
 }
 
 /* See maxDelta() */
 template <class R>
-int SPxFastRT<R>::minDelta(
-   R& val,
-   R& maxabs,
-   UpdateVector<R>& update,
-   const VectorBase<R>& lowBound,
-   const VectorBase<R>& upBound,
-   int start,
-   int incr) const
-{
-   int i, sel;
-   R x, y, max;
-   R u, l;
-   bool leaving = (this->m_type == SPxSolverBase<R>::LEAVE);
-   bool enterrowrep = !leaving && this->thesolver->theRep == SPxSolverBase<R>::ROW;
-
-   R mabs = maxabs;
+int SPxFastRT<R>::minDelta(R &val, R &maxabs, UpdateVector<R> &update,
+                           const VectorBase<R> &lowBound,
+                           const VectorBase<R> &upBound, int start,
+                           int incr) const {
+  int i, sel;
+  R x, y, max;
+  R u, l;
+  bool leaving = (this->m_type == SPxSolverBase<R>::LEAVE);
+  bool enterrowrep =
+      !leaving && this->thesolver->theRep == SPxSolverBase<R>::ROW;
+
+  R mabs = maxabs;
+
+  const R *up = upBound.get_const_ptr();
+  const R *low = lowBound.get_const_ptr();
+  const R *vec = update.get_const_ptr();
+  const R *upd = update.delta().values();
+  const int *idx = update.delta().indexMem();
+
+  sel = -1;
+  max = val;
+
+  if (update.delta().isSetup()) {
+    const int *last = idx + update.delta().size();
+
+    for (idx += start; idx < last; idx += incr) {
+      i = *idx;
+      x = upd[i];
 
-   const R* up = upBound.get_const_ptr();
-   const R* low = lowBound.get_const_ptr();
-   const R* vec = update.get_const_ptr();
-   const R* upd = update.delta().values();
-   const int* idx = update.delta().indexMem();
+      /* in the dual algorithm, bound flips cannot happen, hence we only
+       * consider nonbasic variables */
+      if (leaving && ((iscoid && this->thesolver->isCoBasic(i)) ||
+                      (!iscoid && this->thesolver->isBasic(i))))
+        continue;
+
+      if (enterrowrep && this->thesolver->baseId(i).isSPxColId() &&
+          this->thesolver->desc().colStatus(this->thesolver->number(SPxColId(
+              this->thesolver->baseId(i)))) == SPxBasisBase<R>::Desc::P_FIXED)
+        continue;
+
+      if (x > epsilon) {
+        // @todo check wether mabs should be computed only over bounded vars,
+        // i.e., in the if block below
+        mabs = (x > mabs) ? x : mabs;
+        l = low[i];
+
+        if (l > R(-infinity)) {
+          y = l - vec[i];
+
+          if (y >= 0)
+            x = -fastDelta / x;
+          else
+            x = (y - fastDelta) / x;
+
+          if (x > max) {
+            max = x;
+            sel = i;
+          }
+        }
+      } else if (x < -epsilon) {
+        // @todo check wether mabs should be computed only over bounded vars,
+        // i.e., in the if block below
+        mabs = (-x > mabs) ? -x : mabs;
+        u = up[i];
+
+        if (u < R(infinity)) {
+          y = u - vec[i];
+
+          if (y <= 0)
+            x = fastDelta / x;
+          else
+            x = (y + fastDelta) / x;
+
+          if (x > max) {
+            max = x;
+            sel = i;
+          }
+        }
+      }
+    }
+  } else {
+    /* In this case, the indices of the semi-sparse VectorBase<R> update.delta()
+     * are not set up and are filled below. */
+    int *l_idx = update.delta().altIndexMem();
+    R *uval = update.delta().altValues();
+    const R *uend = uval + update.dim();
+    assert(uval == upd);
+
+    for (i = 0; uval < uend; ++uval, ++i) {
+      x = *uval;
+
+      if (x != 0.0) {
+        if (x >= -epsilon && x <= epsilon) {
+          *uval = 0.0;
+          continue;
+        } else
+          *l_idx++ = i;
+
+        /* in the dual algorithm, bound flips cannot happen, hence we only
+         * consider nonbasic variables */
+        if (leaving && ((iscoid && this->thesolver->isCoBasic(i)) ||
+                        (!iscoid && this->thesolver->isBasic(i))))
+          continue;
+
+        if (enterrowrep && this->thesolver->baseId(i).isSPxColId() &&
+            this->thesolver->desc().colStatus(this->thesolver->number(SPxColId(
+                this->thesolver->baseId(i)))) == SPxBasisBase<R>::Desc::P_FIXED)
+          continue;
+
+        if (x > epsilon) {
+          mabs = (x > mabs) ? x : mabs;
+          l = low[i];
+
+          if (l > R(-infinity)) {
+            y = l - vec[i];
+
+            if (y >= 0)
+              x = -fastDelta / x;
+            else
+              x = (y - fastDelta) / x;
 
-   sel = -1;
-   max = val;
+            if (x > max) {
+              max = x;
+              sel = i;
+            }
+          }
+        } else if (x < -epsilon) {
+          mabs = (-x > mabs) ? -x : mabs;
+          u = up[i];
 
-   if(update.delta().isSetup())
-   {
-      const int* last = idx + update.delta().size();
+          if (u < R(infinity)) {
+            y = u - vec[i];
 
-      for(idx += start; idx < last; idx += incr)
-      {
-         i = *idx;
-         x = upd[i];
-
-         /* in the dual algorithm, bound flips cannot happen, hence we only consider nonbasic variables */
-         if(leaving && ((iscoid && this->thesolver->isCoBasic(i)) || (!iscoid
-                        && this->thesolver->isBasic(i))))
-            continue;
-
-         if(enterrowrep && this->thesolver->baseId(i).isSPxColId()
-               && this->thesolver->desc().colStatus(this->thesolver->number(SPxColId(this->thesolver->baseId(i))))
-               == SPxBasisBase<R>::Desc::P_FIXED)
-            continue;
-
-         if(x > epsilon)
-         {
-            // @todo check wether mabs should be computed only over bounded vars, i.e., in the if block below
-            mabs = (x > mabs) ? x : mabs;
-            l = low[i];
-
-            if(l > R(-infinity))
-            {
-               y = l - vec[i];
-
-               if(y >= 0)
-                  x = - fastDelta / x;
-               else
-                  x = (y - fastDelta) / x;
-
-               if(x > max)
-               {
-                  max = x;
-                  sel = i;
-               }
-            }
-         }
-         else if(x < -epsilon)
-         {
-            // @todo check wether mabs should be computed only over bounded vars, i.e., in the if block below
-            mabs = (-x > mabs) ? -x : mabs;
-            u = up[i];
-
-            if(u < R(infinity))
-            {
-               y = u - vec[i];
-
-               if(y <= 0)
-                  x = fastDelta / x;
-               else
-                  x = (y + fastDelta) / x;
-
-               if(x > max)
-               {
-                  max = x;
-                  sel = i;
-               }
-            }
-         }
-      }
-   }
-   else
-   {
-      /* In this case, the indices of the semi-sparse VectorBase<R> update.delta() are not set up and are filled below. */
-      int* l_idx = update.delta().altIndexMem();
-      R* uval = update.delta().altValues();
-      const R* uend = uval + update.dim();
-      assert(uval == upd);
-
-      for(i = 0; uval < uend; ++uval, ++i)
-      {
-         x = *uval;
-
-         if(x != 0.0)
-         {
-            if(x >= -epsilon && x <= epsilon)
-            {
-               *uval = 0.0;
-               continue;
-            }
+            if (y <= 0)
+              x = fastDelta / x;
             else
-               *l_idx++ = i;
-
-            /* in the dual algorithm, bound flips cannot happen, hence we only consider nonbasic variables */
-            if(leaving && ((iscoid && this->thesolver->isCoBasic(i)) || (!iscoid
-                           && this->thesolver->isBasic(i))))
-               continue;
-
-            if(enterrowrep && this->thesolver->baseId(i).isSPxColId()
-                  && this->thesolver->desc().colStatus(this->thesolver->number(SPxColId(this->thesolver->baseId(i))))
-                  == SPxBasisBase<R>::Desc::P_FIXED)
-               continue;
-
-
-            if(x > epsilon)
-            {
-               mabs = (x > mabs) ? x : mabs;
-               l = low[i];
-
-               if(l > R(-infinity))
-               {
-                  y = l - vec[i];
-
-                  if(y >= 0)
-                     x = - fastDelta / x;
-                  else
-                     x = (y - fastDelta) / x;
-
-                  if(x > max)
-                  {
-                     max = x;
-                     sel = i;
-                  }
-               }
-            }
-            else if(x < -epsilon)
-            {
-               mabs = (-x > mabs) ? -x : mabs;
-               u = up[i];
-
-               if(u < R(infinity))
-               {
-                  y = u - vec[i];
-
-                  if(y <= 0)
-                     x = fastDelta / x;
-                  else
-                     x = (y + fastDelta) / x;
-
-                  if(x > max)
-                  {
-                     max = x;
-                     sel = i;
-                  }
-               }
+              x = (y + fastDelta) / x;
+
+            if (x > max) {
+              max = x;
+              sel = i;
             }
-         }
+          }
+        }
       }
+    }
 
-      update.delta().setSize(int(l_idx - update.delta().indexMem()));
-      update.delta().forceSetup();
-   }
+    update.delta().setSize(int(l_idx - update.delta().indexMem()));
+    update.delta().forceSetup();
+  }
 
-   val = max;
-   maxabs = mabs;
+  val = max;
+  maxabs = mabs;
 
-   return sel;
+  return sel;
 }
 
-template <class R>
-int SPxFastRT<R>::maxDelta(
-   R& val,
-   R& maxabs)
-{
-   assert(this->m_type == SPxSolverBase<R>::ENTER);
-   return maxDelta(val, maxabs,
-                   this->thesolver->fVec(), this->thesolver->lbBound(), this->thesolver->ubBound(), 0, 1);
+template <class R> int SPxFastRT<R>::maxDelta(R &val, R &maxabs) {
+  assert(this->m_type == SPxSolverBase<R>::ENTER);
+  return maxDelta(val, maxabs, this->thesolver->fVec(),
+                  this->thesolver->lbBound(), this->thesolver->ubBound(), 0, 1);
 }
 
-template <class R>
-int SPxFastRT<R>::minDelta(
-   R& val,
-   R& maxabs)
-{
-   assert(this->m_type == SPxSolverBase<R>::ENTER);
-   return minDelta(val, maxabs,
-                   this->thesolver->fVec(), this->thesolver->lbBound(), this->thesolver->ubBound(), 0, 1);
+template <class R> int SPxFastRT<R>::minDelta(R &val, R &maxabs) {
+  assert(this->m_type == SPxSolverBase<R>::ENTER);
+  return minDelta(val, maxabs, this->thesolver->fVec(),
+                  this->thesolver->lbBound(), this->thesolver->ubBound(), 0, 1);
 }
 
 template <class R>
 SPxId SPxFastRT<R>::maxDelta(
-   int& nr,
-   R& max,                                /* on return: maximum step length */
-   R& maxabs)                             /* on return: maximum absolute value in delta VectorBase<R> */
+    int &nr, R &max, /* on return: maximum step length */
+    R &maxabs) /* on return: maximum absolute value in delta VectorBase<R> */
 {
-   /* The following cause side effects on coPvec and pVec - both changes may be needed later in
-      maxSelect(). We can therefore not move the first function after the (indp >= 0) check. */
-   iscoid = true;
-   int indc = maxDelta(max, maxabs,
-                       this->thesolver->coPvec(), this->thesolver->lcBound(), this->thesolver->ucBound(), 0, 1);
-   iscoid = false;
-   int indp = maxDelta(max, maxabs,
-                       this->thesolver->pVec(), this->thesolver->lpBound(), this->thesolver->upBound(), 0, 1);
-
-   if(indp >= 0)
-   {
-      nr = indp;
-      return this->thesolver->id(indp);
-   }
-
-   if(indc >= 0)
-   {
-      nr = indc;
-      return this->thesolver->coId(indc);
-   }
-
-   nr = -1;
-   return SPxId();
+  /* The following cause side effects on coPvec and pVec - both changes may be
+     needed later in maxSelect(). We can therefore not move the first function
+     after the (indp >= 0) check. */
+  iscoid = true;
+  int indc =
+      maxDelta(max, maxabs, this->thesolver->coPvec(),
+               this->thesolver->lcBound(), this->thesolver->ucBound(), 0, 1);
+  iscoid = false;
+  int indp =
+      maxDelta(max, maxabs, this->thesolver->pVec(), this->thesolver->lpBound(),
+               this->thesolver->upBound(), 0, 1);
+
+  if (indp >= 0) {
+    nr = indp;
+    return this->thesolver->id(indp);
+  }
+
+  if (indc >= 0) {
+    nr = indc;
+    return this->thesolver->coId(indc);
+  }
+
+  nr = -1;
+  return SPxId();
 }
 
-template <class R>
-SPxId SPxFastRT<R>::minDelta(
-   int& nr,
-   R& max,
-   R& maxabs)
-{
-   /* The following cause side effects on coPvec and pVec - both changes may be needed later in
-      minSelect(). We can therefore not move the first function after the (indp >= 0) check. */
-   iscoid = true;
-   const int indc = minDelta(max, maxabs,
-                             this->thesolver->coPvec(), this->thesolver->lcBound(), this->thesolver->ucBound(), 0, 1);
-   iscoid = false;
-   const int indp = minDelta(max, maxabs,
-                             this->thesolver->pVec(), this->thesolver->lpBound(), this->thesolver->upBound(), 0, 1);
-
-   if(indp >= 0)
-   {
-      nr = indp;
-      return this->thesolver->id(indp);
-   }
-
-   if(indc >= 0)
-   {
-      nr = indc;
-      return this->thesolver->coId(indc);
-   }
-
-   nr = -1;
-   return SPxId();
+template <class R> SPxId SPxFastRT<R>::minDelta(int &nr, R &max, R &maxabs) {
+  /* The following cause side effects on coPvec and pVec - both changes may be
+     needed later in minSelect(). We can therefore not move the first function
+     after the (indp >= 0) check. */
+  iscoid = true;
+  const int indc =
+      minDelta(max, maxabs, this->thesolver->coPvec(),
+               this->thesolver->lcBound(), this->thesolver->ucBound(), 0, 1);
+  iscoid = false;
+  const int indp =
+      minDelta(max, maxabs, this->thesolver->pVec(), this->thesolver->lpBound(),
+               this->thesolver->upBound(), 0, 1);
+
+  if (indp >= 0) {
+    nr = indp;
+    return this->thesolver->id(indp);
+  }
+
+  if (indc >= 0) {
+    nr = indc;
+    return this->thesolver->coId(indc);
+  }
+
+  nr = -1;
+  return SPxId();
 }
 
-/* \p best returns the minimum update value such that the corresponding value of \p upd.delta() is
- * at least \p stab and the update value is smaller than \p max. If no valid update value has been
- * found \p bestDelta returns the slack to the bound corresponding to the index used for \p best. */
+/* \p best returns the minimum update value such that the corresponding value of
+ * \p upd.delta() is at least \p stab and the update value is smaller than \p
+ * max. If no valid update value has been found \p bestDelta returns the slack
+ * to the bound corresponding to the index used for \p best. */
 template <class R>
-int SPxFastRT<R>::minSelect(
-   R& val,
-   R& stab,
-   R& best,
-   R& bestDelta,
-   R max,
-   const UpdateVector<R>& update,
-   const VectorBase<R>& lowBound,
-   const VectorBase<R>& upBound,
-   int start,
-   int incr) const
-{
-   int i;
-   R x, y;
-   bool leaving = this->m_type == SPxSolverBase<R>::LEAVE;
-   bool enterrowrep = !leaving && this->thesolver->theRep == SPxSolverBase<R>::ROW;
-
-   const R* up = upBound.get_const_ptr();
-   const R* low = lowBound.get_const_ptr();
-   const R* vec = update.get_const_ptr();
-   const R* upd = update.delta().values();
-   const int* idx = update.delta().indexMem();
-   const int* last = idx + update.delta().size();
-
-   int nr = -1;
-   int bestNr = -1;
-
-   for(idx += start; idx < last; idx += incr)
-   {
-      i = *idx;
-      x = upd[i];
-
-      // in the dual algorithm, bound flips cannot happen, hence we only consider nonbasic variables
-      if(leaving && ((iscoid && this->thesolver->isCoBasic(i)) || (!iscoid
-                     && this->thesolver->isBasic(i))))
-         continue;
-
-      if(enterrowrep && this->thesolver->baseId(i).isSPxColId()
-            && this->thesolver->desc().colStatus(this->thesolver->number(SPxColId(this->thesolver->baseId(i))))
-            == SPxBasisBase<R>::Desc::P_FIXED)
-         continue;
-
-      if(x > stab)
-      {
-         y = (low[i] - vec[i]) / x;
-
-         if(y >= max)
-         {
-            val = y;
-            nr = i;
-            stab = x;
-         }
-         else if(y < best)
-         {
-            best = y;
-            bestNr = i;
-         }
+int SPxFastRT<R>::minSelect(R &val, R &stab, R &best, R &bestDelta, R max,
+                            const UpdateVector<R> &update,
+                            const VectorBase<R> &lowBound,
+                            const VectorBase<R> &upBound, int start,
+                            int incr) const {
+  int i;
+  R x, y;
+  bool leaving = this->m_type == SPxSolverBase<R>::LEAVE;
+  bool enterrowrep =
+      !leaving && this->thesolver->theRep == SPxSolverBase<R>::ROW;
+
+  const R *up = upBound.get_const_ptr();
+  const R *low = lowBound.get_const_ptr();
+  const R *vec = update.get_const_ptr();
+  const R *upd = update.delta().values();
+  const int *idx = update.delta().indexMem();
+  const int *last = idx + update.delta().size();
+
+  int nr = -1;
+  int bestNr = -1;
+
+  for (idx += start; idx < last; idx += incr) {
+    i = *idx;
+    x = upd[i];
+
+    // in the dual algorithm, bound flips cannot happen, hence we only consider
+    // nonbasic variables
+    if (leaving && ((iscoid && this->thesolver->isCoBasic(i)) ||
+                    (!iscoid && this->thesolver->isBasic(i))))
+      continue;
+
+    if (enterrowrep && this->thesolver->baseId(i).isSPxColId() &&
+        this->thesolver->desc().colStatus(this->thesolver->number(SPxColId(
+            this->thesolver->baseId(i)))) == SPxBasisBase<R>::Desc::P_FIXED)
+      continue;
+
+    if (x > stab) {
+      y = (low[i] - vec[i]) / x;
+
+      if (y >= max) {
+        val = y;
+        nr = i;
+        stab = x;
+      } else if (y < best) {
+        best = y;
+        bestNr = i;
       }
-      else if(x < -stab)
-      {
-         y = (up[i] - vec[i]) / x;
-
-         if(y >= max)
-         {
-            val = y;
-            nr = i;
-            stab = -x;
-         }
-         else if(y < best)
-         {
-            best = y;
-            bestNr = i;
-         }
+    } else if (x < -stab) {
+      y = (up[i] - vec[i]) / x;
+
+      if (y >= max) {
+        val = y;
+        nr = i;
+        stab = -x;
+      } else if (y < best) {
+        best = y;
+        bestNr = i;
       }
-   }
+    }
+  }
 
-   if(nr < 0 && bestNr > 0)
-   {
-      if(upd[bestNr] < 0)
-         bestDelta = up[bestNr] - vec[bestNr];
-      else
-         bestDelta = vec[bestNr] - low[bestNr];
-   }
+  if (nr < 0 && bestNr > 0) {
+    if (upd[bestNr] < 0)
+      bestDelta = up[bestNr] - vec[bestNr];
+    else
+      bestDelta = vec[bestNr] - low[bestNr];
+  }
 
-   return nr;
+  return nr;
 }
 
 /* See minSelect() */
 template <class R>
-int SPxFastRT<R>::maxSelect(
-   R& val,
-   R& stab,
-   R& best,
-   R& bestDelta,
-   R max,
-   const UpdateVector<R>& update,
-   const VectorBase<R>& lowBound,
-   const VectorBase<R>& upBound,
-   int start,
-   int incr) const
-{
-   int i;
-   R x, y;
-   bool leaving = this->m_type == SPxSolverBase<R>::LEAVE;
-   bool enterrowrep = !leaving && this->thesolver->theRep == SPxSolverBase<R>::ROW;
-
-   const R* up = upBound.get_const_ptr();
-   const R* low = lowBound.get_const_ptr();
-   const R* vec = update.get_const_ptr();
-   const R* upd = update.delta().values();
-   const int* idx = update.delta().indexMem();
-   const int* last = idx + update.delta().size();
-
-   int nr = -1;
-   int bestNr = -1;
-
-   for(idx += start; idx < last; idx += incr)
-   {
-      i = *idx;
-      x = upd[i];
-
-      // in the dual algorithm, bound flips cannot happen, hence we only consider nonbasic variables
-      if(leaving && ((iscoid && this->thesolver->isCoBasic(i)) || (!iscoid
-                     && this->thesolver->isBasic(i))))
-         continue;
-
-      if(enterrowrep && this->thesolver->baseId(i).isSPxColId()
-            && this->thesolver->desc().colStatus(this->thesolver->number(SPxColId(this->thesolver->baseId(i))))
-            == SPxBasisBase<R>::Desc::P_FIXED)
-         continue;
-
-      if(x > stab)
-      {
-         y = (up[i] - vec[i]) / x;
-
-         if(y <= max)
-         {
-            val = y;
-            nr = i;
-            stab = x;
-         }
-         else if(y > best)
-         {
-            best = y;
-            bestNr = i;
-         }
+int SPxFastRT<R>::maxSelect(R &val, R &stab, R &best, R &bestDelta, R max,
+                            const UpdateVector<R> &update,
+                            const VectorBase<R> &lowBound,
+                            const VectorBase<R> &upBound, int start,
+                            int incr) const {
+  int i;
+  R x, y;
+  bool leaving = this->m_type == SPxSolverBase<R>::LEAVE;
+  bool enterrowrep =
+      !leaving && this->thesolver->theRep == SPxSolverBase<R>::ROW;
+
+  const R *up = upBound.get_const_ptr();
+  const R *low = lowBound.get_const_ptr();
+  const R *vec = update.get_const_ptr();
+  const R *upd = update.delta().values();
+  const int *idx = update.delta().indexMem();
+  const int *last = idx + update.delta().size();
+
+  int nr = -1;
+  int bestNr = -1;
+
+  for (idx += start; idx < last; idx += incr) {
+    i = *idx;
+    x = upd[i];
+
+    // in the dual algorithm, bound flips cannot happen, hence we only consider
+    // nonbasic variables
+    if (leaving && ((iscoid && this->thesolver->isCoBasic(i)) ||
+                    (!iscoid && this->thesolver->isBasic(i))))
+      continue;
+
+    if (enterrowrep && this->thesolver->baseId(i).isSPxColId() &&
+        this->thesolver->desc().colStatus(this->thesolver->number(SPxColId(
+            this->thesolver->baseId(i)))) == SPxBasisBase<R>::Desc::P_FIXED)
+      continue;
+
+    if (x > stab) {
+      y = (up[i] - vec[i]) / x;
+
+      if (y <= max) {
+        val = y;
+        nr = i;
+        stab = x;
+      } else if (y > best) {
+        best = y;
+        bestNr = i;
       }
-      else if(x < -stab)
-      {
-         y = (low[i] - vec[i]) / x;
-
-         if(y <= max)
-         {
-            val = y;
-            nr = i;
-            stab = -x;
-         }
-         else if(y > best)
-         {
-            best = y;
-            bestNr = i;
-         }
+    } else if (x < -stab) {
+      y = (low[i] - vec[i]) / x;
+
+      if (y <= max) {
+        val = y;
+        nr = i;
+        stab = -x;
+      } else if (y > best) {
+        best = y;
+        bestNr = i;
       }
-   }
+    }
+  }
 
-   if(nr < 0 && bestNr > 0)
-   {
-      if(upd[bestNr] > 0)
-         bestDelta = up[bestNr] - vec[bestNr];
-      else
-         bestDelta = vec[bestNr] - low[bestNr];
-   }
+  if (nr < 0 && bestNr > 0) {
+    if (upd[bestNr] > 0)
+      bestDelta = up[bestNr] - vec[bestNr];
+    else
+      bestDelta = vec[bestNr] - low[bestNr];
+  }
 
-   return nr;
+  return nr;
 }
 
 template <class R>
-int SPxFastRT<R>::maxSelect(
-   R& val,
-   R& stab,
-   R& bestDelta,
-   R max)
-{
-   R best = R(-infinity);
-   bestDelta = 0.0;
-   assert(this->m_type == SPxSolverBase<R>::ENTER);
-   return maxSelect(val, stab, best, bestDelta, max,
-                    this->thesolver->fVec(), this->thesolver->lbBound(), this->thesolver->ubBound(),  0, 1);
+int SPxFastRT<R>::maxSelect(R &val, R &stab, R &bestDelta, R max) {
+  R best = R(-infinity);
+  bestDelta = 0.0;
+  assert(this->m_type == SPxSolverBase<R>::ENTER);
+  return maxSelect(val, stab, best, bestDelta, max, this->thesolver->fVec(),
+                   this->thesolver->lbBound(), this->thesolver->ubBound(), 0,
+                   1);
 }
 
 template <class R>
-SPxId SPxFastRT<R>::maxSelect(
-   int& nr,
-   R& val,
-   R& stab,
-   R& bestDelta,
-   R max
-)
-{
-   int indp, indc;
-   R best = R(-infinity);
-   bestDelta = 0.0;
-   iscoid = true;
-   indc = maxSelect(val, stab, best, bestDelta, max,
-                    this->thesolver->coPvec(), this->thesolver->lcBound(), this->thesolver->ucBound(), 0, 1);
-   iscoid = false;
-   indp = maxSelect(val, stab, best, bestDelta, max,
-                    this->thesolver->pVec(), this->thesolver->lpBound(), this->thesolver->upBound(), 0, 1);
-
-   if(indp >= 0)
-   {
-      nr = indp;
-      return this->thesolver->id(indp);
-   }
-
-   if(indc >= 0)
-   {
-      nr = indc;
-      return this->thesolver->coId(indc);
-   }
-
-   nr = -1;
-   return SPxId();
+SPxId SPxFastRT<R>::maxSelect(int &nr, R &val, R &stab, R &bestDelta, R max) {
+  int indp, indc;
+  R best = R(-infinity);
+  bestDelta = 0.0;
+  iscoid = true;
+  indc =
+      maxSelect(val, stab, best, bestDelta, max, this->thesolver->coPvec(),
+                this->thesolver->lcBound(), this->thesolver->ucBound(), 0, 1);
+  iscoid = false;
+  indp =
+      maxSelect(val, stab, best, bestDelta, max, this->thesolver->pVec(),
+                this->thesolver->lpBound(), this->thesolver->upBound(), 0, 1);
+
+  if (indp >= 0) {
+    nr = indp;
+    return this->thesolver->id(indp);
+  }
+
+  if (indc >= 0) {
+    nr = indc;
+    return this->thesolver->coId(indc);
+  }
+
+  nr = -1;
+  return SPxId();
 }
 
 template <class R>
-int SPxFastRT<R>::minSelect(
-   R& val,
-   R& stab,
-   R& bestDelta,
-   R max)
-{
-   R best = R(infinity);
-   bestDelta = 0.0;
-   assert(this->m_type == SPxSolverBase<R>::ENTER);
-   return minSelect(val, stab, best, bestDelta, max,
-                    this->thesolver->fVec(), this->thesolver->lbBound(), this->thesolver->ubBound(), 0, 1);
+int SPxFastRT<R>::minSelect(R &val, R &stab, R &bestDelta, R max) {
+  R best = R(infinity);
+  bestDelta = 0.0;
+  assert(this->m_type == SPxSolverBase<R>::ENTER);
+  return minSelect(val, stab, best, bestDelta, max, this->thesolver->fVec(),
+                   this->thesolver->lbBound(), this->thesolver->ubBound(), 0,
+                   1);
 }
 
 template <class R>
-SPxId SPxFastRT<R>::minSelect(
-   int& nr,
-   R& val,
-   R& stab,
-   R& bestDelta,
-   R max)
-{
-   R best = R(infinity);
-   bestDelta = 0.0;
-   iscoid = true;
-   int indc = minSelect(val, stab, best, bestDelta, max,
-                        this->thesolver->coPvec(), this->thesolver->lcBound(), this->thesolver->ucBound(), 0, 1);
-   iscoid = false;
-   int indp = minSelect(val, stab, best, bestDelta, max,
-                        this->thesolver->pVec(), this->thesolver->lpBound(), this->thesolver->upBound(), 0, 1);
-
-   if(indp >= 0)
-   {
-      nr = indp;
-      return this->thesolver->id(indp);
-   }
-
-   if(indc >= 0)
-   {
-      nr = indc;
-      return this->thesolver->coId(indc);
-   }
-
-   nr = -1;
-   return SPxId();
+SPxId SPxFastRT<R>::minSelect(int &nr, R &val, R &stab, R &bestDelta, R max) {
+  R best = R(infinity);
+  bestDelta = 0.0;
+  iscoid = true;
+  int indc =
+      minSelect(val, stab, best, bestDelta, max, this->thesolver->coPvec(),
+                this->thesolver->lcBound(), this->thesolver->ucBound(), 0, 1);
+  iscoid = false;
+  int indp =
+      minSelect(val, stab, best, bestDelta, max, this->thesolver->pVec(),
+                this->thesolver->lpBound(), this->thesolver->upBound(), 0, 1);
+
+  if (indp >= 0) {
+    nr = indp;
+    return this->thesolver->id(indp);
+  }
+
+  if (indc >= 0) {
+    nr = indc;
+    return this->thesolver->coId(indc);
+  }
+
+  nr = -1;
+  return SPxId();
 }
 
 template <class R>
-bool SPxFastRT<R>::maxShortLeave(R& sel, int leave, R maxabs)
-{
-   assert(leave >= 0);
-   assert(maxabs >= 0);
+bool SPxFastRT<R>::maxShortLeave(R &sel, int leave, R maxabs) {
+  assert(leave >= 0);
+  assert(maxabs >= 0);
 
-   sel = this->thesolver->fVec().delta()[leave];
+  sel = this->thesolver->fVec().delta()[leave];
 
-   if(sel > maxabs * SHORTVAL)
-   {
-      sel = (this->thesolver->ubBound()[leave] - this->thesolver->fVec()[leave]) / sel;
-      return true;
-   }
+  if (sel > maxabs * SHORTVAL) {
+    sel = (this->thesolver->ubBound()[leave] - this->thesolver->fVec()[leave]) /
+          sel;
+    return true;
+  }
 
-   if(sel < -maxabs * SHORTVAL)
-   {
-      sel = (this->thesolver->lbBound()[leave] - this->thesolver->fVec()[leave]) / sel;
-      return true;
-   }
+  if (sel < -maxabs * SHORTVAL) {
+    sel = (this->thesolver->lbBound()[leave] - this->thesolver->fVec()[leave]) /
+          sel;
+    return true;
+  }
 
-   return false;
+  return false;
 }
 
 template <class R>
-bool SPxFastRT<R>::minShortLeave(R& sel, int leave, R maxabs)
-{
-   assert(leave >= 0);
-   assert(maxabs >= 0);
+bool SPxFastRT<R>::minShortLeave(R &sel, int leave, R maxabs) {
+  assert(leave >= 0);
+  assert(maxabs >= 0);
 
-   sel = this->thesolver->fVec().delta()[leave];
+  sel = this->thesolver->fVec().delta()[leave];
 
-   if(sel > maxabs * SHORTVAL)
-   {
-      sel = (this->thesolver->lbBound()[leave] - this->thesolver->fVec()[leave]) / sel;
-      return true;
-   }
+  if (sel > maxabs * SHORTVAL) {
+    sel = (this->thesolver->lbBound()[leave] - this->thesolver->fVec()[leave]) /
+          sel;
+    return true;
+  }
 
-   if(sel < -maxabs * SHORTVAL)
-   {
-      sel = (this->thesolver->ubBound()[leave] - this->thesolver->fVec()[leave]) / sel;
-      return true;
-   }
+  if (sel < -maxabs * SHORTVAL) {
+    sel = (this->thesolver->ubBound()[leave] - this->thesolver->fVec()[leave]) /
+          sel;
+    return true;
+  }
 
-   return false;
+  return false;
 }
 
 template <class R>
-bool SPxFastRT<R>::maxReLeave(R& sel, int leave, R maxabs, bool polish)
-{
-   UpdateVector<R>& vec = this->thesolver->fVec();
-   VectorBase<R>& low = this->thesolver->lbBound();
-   VectorBase<R>& up = this->thesolver->ubBound();
+bool SPxFastRT<R>::maxReLeave(R &sel, int leave, R maxabs, bool polish) {
+  UpdateVector<R> &vec = this->thesolver->fVec();
+  VectorBase<R> &low = this->thesolver->lbBound();
+  VectorBase<R> &up = this->thesolver->ubBound();
 
-   if(leave < 0)
-      return true;
+  if (leave < 0)
+    return true;
 
-   if(up[leave] > low[leave])
-   {
-      R x = vec.delta()[leave];
+  if (up[leave] > low[leave]) {
+    R x = vec.delta()[leave];
 
-      if(sel < -fastDelta / maxabs)
-      {
-         sel = 0.0;
-
-         // prevent shifts in polishing mode to avoid a final cleanup step (i.e. simplex type switch)
-         if(!polish
-               && this->thesolver->dualStatus(this->thesolver->baseId(leave)) != SPxBasisBase<R>::Desc::D_ON_BOTH)
-         {
-            if(x < 0.0)
-               this->thesolver->shiftLBbound(leave, vec[leave]);
-            else
-               this->thesolver->shiftUBbound(leave, vec[leave]);
-         }
-      }
-   }
-   else
-   {
+    if (sel < -fastDelta / maxabs) {
       sel = 0.0;
 
-      // prevent shifts in polishing mode to avoid a final cleanup step (i.e. simplex type switch)
-      if(!polish)
-      {
-         this->thesolver->shiftLBbound(leave, vec[leave]);
-         this->thesolver->shiftUBbound(leave, vec[leave]);
+      // prevent shifts in polishing mode to avoid a final cleanup step (i.e.
+      // simplex type switch)
+      if (!polish && this->thesolver->dualStatus(this->thesolver->baseId(
+                         leave)) != SPxBasisBase<R>::Desc::D_ON_BOTH) {
+        if (x < 0.0)
+          this->thesolver->shiftLBbound(leave, vec[leave]);
+        else
+          this->thesolver->shiftUBbound(leave, vec[leave]);
       }
-   }
-
-   return false;
+    }
+  } else {
+    sel = 0.0;
+
+    // prevent shifts in polishing mode to avoid a final cleanup step (i.e.
+    // simplex type switch)
+    if (!polish) {
+      this->thesolver->shiftLBbound(leave, vec[leave]);
+      this->thesolver->shiftUBbound(leave, vec[leave]);
+    }
+  }
+
+  return false;
 }
 
 template <class R>
-bool SPxFastRT<R>::minReLeave(R& sel, int leave, R maxabs, bool polish)
-{
-   UpdateVector<R>& vec = this->thesolver->fVec();
-   VectorBase<R>& low = this->thesolver->lbBound();
-   VectorBase<R>& up = this->thesolver->ubBound();
+bool SPxFastRT<R>::minReLeave(R &sel, int leave, R maxabs, bool polish) {
+  UpdateVector<R> &vec = this->thesolver->fVec();
+  VectorBase<R> &low = this->thesolver->lbBound();
+  VectorBase<R> &up = this->thesolver->ubBound();
 
-   if(leave < 0)
-      return true;
+  if (leave < 0)
+    return true;
 
-   if(up[leave] > low[leave])
-   {
-      R x = vec.delta()[leave];
+  if (up[leave] > low[leave]) {
+    R x = vec.delta()[leave];
 
-      if(sel > fastDelta / maxabs)
-      {
-         sel = 0.0;
-
-         if(!polish
-               && this->thesolver->dualStatus(this->thesolver->baseId(leave)) != SPxBasisBase<R>::Desc::D_ON_BOTH)
-            // prevent shifts in polishing mode to avoid a final cleanup step (i.e. simplex type switch)
-         {
-            if(x > 0.0)
-               this->thesolver->shiftLBbound(leave, vec[leave]);
-            else
-               this->thesolver->shiftUBbound(leave, vec[leave]);
-         }
-      }
-   }
-   else
-   {
+    if (sel > fastDelta / maxabs) {
       sel = 0.0;
 
-      // prevent shifts in polishing mode to avoid a final cleanup step (i.e. simplex type switch)
-      if(!polish)
+      if (!polish && this->thesolver->dualStatus(this->thesolver->baseId(
+                         leave)) != SPxBasisBase<R>::Desc::D_ON_BOTH)
+      // prevent shifts in polishing mode to avoid a final cleanup step (i.e.
+      // simplex type switch)
       {
-         this->thesolver->shiftLBbound(leave, vec[leave]);
-         this->thesolver->shiftUBbound(leave, vec[leave]);
+        if (x > 0.0)
+          this->thesolver->shiftLBbound(leave, vec[leave]);
+        else
+          this->thesolver->shiftUBbound(leave, vec[leave]);
       }
-   }
-
-   return false;
+    }
+  } else {
+    sel = 0.0;
+
+    // prevent shifts in polishing mode to avoid a final cleanup step (i.e.
+    // simplex type switch)
+    if (!polish) {
+      this->thesolver->shiftLBbound(leave, vec[leave]);
+      this->thesolver->shiftUBbound(leave, vec[leave]);
+    }
+  }
+
+  return false;
 }
 
-template <class R>
-int SPxFastRT<R>::selectLeave(R& val, R, bool polish)
-{
-   R maxabs, max, sel;
-   int leave = -1;
-   int cnt = 0;
-
-   assert(this->m_type == SPxSolverBase<R>::ENTER);
+template <class R> int SPxFastRT<R>::selectLeave(R &val, R, bool polish) {
+  R maxabs, max, sel;
+  int leave = -1;
+  int cnt = 0;
 
-   // force instable pivot iff true (see explanation in enter.cpp and spxsolve.hpp)
-   bool instable = this->solver()->instableEnter;
-   R lowstab = LOWSTAB;
-   assert(!instable || this->solver()->instableEnterId.isValid());
+  assert(this->m_type == SPxSolverBase<R>::ENTER);
 
-   resetTols();
+  // force instable pivot iff true (see explanation in enter.cpp and
+  // spxsolve.hpp)
+  bool instable = this->solver()->instableEnter;
+  R lowstab = LOWSTAB;
+  assert(!instable || this->solver()->instableEnterId.isValid());
 
-   if(val > epsilon)
-   {
-      do
-      {
-         // phase 1:
-         max = val;
-         maxabs = 0.0;
-         leave = maxDelta(max, maxabs);
-
-         assert(leave < 0 || !(this->thesolver->baseId(leave).isSPxColId()) ||
-                this->thesolver->desc().colStatus(this->thesolver->number(SPxColId(this->thesolver->baseId(
-                         leave)))) != SPxBasisBase<R>::Desc::P_FIXED);
-
-         if(max == val || leave == -1)
-         {
-            assert(max == val && leave == -1);
-            return -1;
-         }
-
-         if(!maxShortLeave(sel, leave, maxabs))
-         {
-            // phase 2:
-            R stab, bestDelta;
-
-            stab = 100.0 * minStability(maxabs);
-
-            // force instable pivot iff instable is true (see explanation in enter.hpp and spxsolve.hpp)
-            if(instable)
-               leave = maxSelect(sel, lowstab, bestDelta, max);
-            else
-               leave = maxSelect(sel, stab, bestDelta, max);
+  resetTols();
 
-            if(bestDelta < DELTA_SHIFT * TRIES)
-               cnt++;
-            else
-               cnt += TRIES;
-         }
+  if (val > epsilon) {
+    do {
+      // phase 1:
+      max = val;
+      maxabs = 0.0;
+      leave = maxDelta(max, maxabs);
 
-         if(!maxReLeave(sel, leave, maxabs, polish))
-            break;
+      assert(leave < 0 || !(this->thesolver->baseId(leave).isSPxColId()) ||
+             this->thesolver->desc().colStatus(this->thesolver->number(
+                 SPxColId(this->thesolver->baseId(leave)))) !=
+                 SPxBasisBase<R>::Desc::P_FIXED);
 
-         relax();
+      if (max == val || leave == -1) {
+        assert(max == val && leave == -1);
+        return -1;
       }
-      while(cnt < TRIES);
-   }
-   else if(val < -epsilon)
-   {
-      do
-      {
-         max = val;
-         maxabs = 0;
-         leave = minDelta(max, maxabs);
-
-         assert(leave < 0 || !(this->thesolver->baseId(leave).isSPxColId()) ||
-                this->thesolver->desc().colStatus(this->thesolver->number(SPxColId(this->thesolver->baseId(
-                         leave)))) != SPxBasisBase<R>::Desc::P_FIXED);
-
-         if(max == val || leave == -1)
-         {
-            assert(max == val && leave == -1);
-            return -1;
-         }
-
-         if(!minShortLeave(sel, leave, maxabs))
-         {
-            // phase 2:
-            R stab, bestDelta;
-
-            stab = 100.0 * minStability(maxabs);
-
-            // force instable pivot iff instable is true (see explanation in enter.hpp and spxsolve.hpp)
-            if(instable)
-               leave = minSelect(sel, lowstab, bestDelta, max);
-            else
-               leave = minSelect(sel, stab, bestDelta, max);
 
-            assert(leave < 0 || !(this->thesolver->baseId(leave).isSPxColId())
-                   || this->thesolver->desc().colStatus(this->thesolver->number(SPxColId(this->thesolver->baseId(
-                            leave)))) != SPxBasisBase<R>::Desc::P_FIXED);
+      if (!maxShortLeave(sel, leave, maxabs)) {
+        // phase 2:
+        R stab, bestDelta;
 
-            if(bestDelta < DELTA_SHIFT * TRIES)
-               cnt++;
-            else
-               cnt += TRIES;
-         }
+        stab = 100.0 * minStability(maxabs);
 
-         if(!minReLeave(sel, leave, maxabs, polish))
-            break;
+        // force instable pivot iff instable is true (see explanation in
+        // enter.hpp and spxsolve.hpp)
+        if (instable)
+          leave = maxSelect(sel, lowstab, bestDelta, max);
+        else
+          leave = maxSelect(sel, stab, bestDelta, max);
 
-         relax();
+        if (bestDelta < DELTA_SHIFT * TRIES)
+          cnt++;
+        else
+          cnt += TRIES;
       }
-      while(cnt < TRIES);
-   }
-   else
-      return -1;
-
-   MSG_DEBUG(
-
-      if(leave >= 0)
-      std::cout
-      << "DFSTRT01 "
-      << this->thesolver->basis().iteration() << "("
-      << std::setprecision(6) << this->thesolver->value() << ","
-      << std::setprecision(2) << this->thesolver->basis().stability() << "):"
-      << leave << "\t"
-      << std::setprecision(4) << sel << " "
-      << std::setprecision(4) << this->thesolver->fVec().delta()[leave] << " "
-      << std::setprecision(6) << maxabs
-      << std::endl;
-      else
-         std::cout << "DFSTRT02 " << this->thesolver->basis().iteration()
-         << ": skipping instable pivot" << std::endl;
-      )
-
-         if(polish && leave >= 0)
-         {
-            assert(this->thesolver->rep() == SPxSolverBase<R>::COLUMN);
-            SPxId leaveId = this->thesolver->baseId(leave);
-
-            // decide whether the chosen leave index contributes to the polishing objective
-            if(this->thesolver->polishObj == SPxSolverBase<R>::POLISH_INTEGRALITY)
-            {
-               // only allow (integer) variables to leave the basis
-               if(leaveId.isSPxRowId())
-                  return -1;
-               else if(this->thesolver->integerVariables.size() == this->thesolver->nCols())
-               {
-                  if(leaveId.isSPxColId() && this->thesolver->integerVariables[this->thesolver->number(leaveId)] == 0)
-                     return -1;
-               }
-            }
-            else if(this->thesolver->polishObj == SPxSolverBase<R>::POLISH_FRACTIONALITY)
-            {
-               // only allow slacks and continuous variables to leave the basis
-               if(this->thesolver->integerVariables.size() == this->thesolver->nCols())
-               {
-                  if(this->thesolver->baseId(leave).isSPxColId()
-                        && this->thesolver->integerVariables[this->thesolver->number(leaveId)] == 1)
-                     return -1;
-               }
-               else if(this->thesolver->baseId(leave).isSPxColId())
-                  return -1;
-            }
-         }
 
-   if(leave >= 0 || minStab > 2 * this->solver()->epsilon())
-   {
-      val = sel;
+      if (!maxReLeave(sel, leave, maxabs, polish))
+        break;
+
+      relax();
+    } while (cnt < TRIES);
+  } else if (val < -epsilon) {
+    do {
+      max = val;
+      maxabs = 0;
+      leave = minDelta(max, maxabs);
+
+      assert(leave < 0 || !(this->thesolver->baseId(leave).isSPxColId()) ||
+             this->thesolver->desc().colStatus(this->thesolver->number(
+                 SPxColId(this->thesolver->baseId(leave)))) !=
+                 SPxBasisBase<R>::Desc::P_FIXED);
+
+      if (max == val || leave == -1) {
+        assert(max == val && leave == -1);
+        return -1;
+      }
 
-      if(leave >= 0)
-         tighten();
-   }
+      if (!minShortLeave(sel, leave, maxabs)) {
+        // phase 2:
+        R stab, bestDelta;
 
-   assert(leave < 0 || !(this->thesolver->baseId(leave).isSPxColId())
-          || this->thesolver->desc().colStatus(this->thesolver->number(SPxColId(this->thesolver->baseId(
-                   leave)))) != SPxBasisBase<R>::Desc::P_FIXED);
+        stab = 100.0 * minStability(maxabs);
 
-   return leave;
-}
+        // force instable pivot iff instable is true (see explanation in
+        // enter.hpp and spxsolve.hpp)
+        if (instable)
+          leave = minSelect(sel, lowstab, bestDelta, max);
+        else
+          leave = minSelect(sel, stab, bestDelta, max);
 
+        assert(leave < 0 || !(this->thesolver->baseId(leave).isSPxColId()) ||
+               this->thesolver->desc().colStatus(this->thesolver->number(
+                   SPxColId(this->thesolver->baseId(leave)))) !=
+                   SPxBasisBase<R>::Desc::P_FIXED);
 
-template <class R>
-bool SPxFastRT<R>::maxReEnter(R& sel,
-                              R maxabs,
-                              const SPxId& id,
-                              int nr,
-                              bool polish)
-{
-   R x, d;
-   VectorBase<R>* up;
-   VectorBase<R>* low;
-
-   UpdateVector<R>& pvec = this->thesolver->pVec();
-   SSVectorBase<R>& pupd = this->thesolver->pVec().delta();
-   VectorBase<R>& upb = this->thesolver->upBound();
-   VectorBase<R>& lpb = this->thesolver->lpBound();
-   UpdateVector<R>& cvec = this->thesolver->coPvec();
-   SSVectorBase<R>& cupd = this->thesolver->coPvec().delta();
-   VectorBase<R>& ucb = this->thesolver->ucBound();
-   VectorBase<R>& lcb = this->thesolver->lcBound();
-
-   if(this->thesolver->isCoId(id))
-   {
-      if(this->thesolver->isCoBasic(nr))
-      {
-         cupd.clearIdx(nr);
-         return true;
+        if (bestDelta < DELTA_SHIFT * TRIES)
+          cnt++;
+        else
+          cnt += TRIES;
       }
 
-      x = cvec[nr];
-      d = cupd[nr];
-      up = &ucb;
-      low = &lcb;
-
-      if(d < 0.0)
-         sel = (lcb[nr] - cvec[nr]) / d;
-      else
-         sel = (ucb[nr] - cvec[nr]) / d;
-   }
-   else if(this->thesolver->isId(id))
-   {
-      pvec[nr] = this->thesolver->vector(nr) * cvec;
-
-      if(this->thesolver->isBasic(nr))
-      {
-         pupd.clearIdx(nr);
-         return true;
+      if (!minReLeave(sel, leave, maxabs, polish))
+        break;
+
+      relax();
+    } while (cnt < TRIES);
+  } else
+    return -1;
+
+  MSG_DEBUG(
+
+      if (leave >= 0) std::cout
+          << "DFSTRT01 " << this->thesolver->basis().iteration() << "("
+          << std::setprecision(6) << this->thesolver->value() << ","
+          << std::setprecision(2) << this->thesolver->basis().stability()
+          << "):" << leave << "\t" << std::setprecision(4) << sel << " "
+          << std::setprecision(4) << this->thesolver->fVec().delta()[leave]
+          << " " << std::setprecision(6) << maxabs << std::endl;
+      else std::cout << "DFSTRT02 " << this->thesolver->basis().iteration()
+                     << ": skipping instable pivot" << std::endl;)
+
+  if (polish && leave >= 0) {
+    assert(this->thesolver->rep() == SPxSolverBase<R>::COLUMN);
+    SPxId leaveId = this->thesolver->baseId(leave);
+
+    // decide whether the chosen leave index contributes to the polishing
+    // objective
+    if (this->thesolver->polishObj == SPxSolverBase<R>::POLISH_INTEGRALITY) {
+      // only allow (integer) variables to leave the basis
+      if (leaveId.isSPxRowId())
+        return -1;
+      else if (this->thesolver->integerVariables.size() ==
+               this->thesolver->nCols()) {
+        if (leaveId.isSPxColId() &&
+            this->thesolver
+                    ->integerVariables[this->thesolver->number(leaveId)] == 0)
+          return -1;
       }
+    } else if (this->thesolver->polishObj ==
+               SPxSolverBase<R>::POLISH_FRACTIONALITY) {
+      // only allow slacks and continuous variables to leave the basis
+      if (this->thesolver->integerVariables.size() ==
+          this->thesolver->nCols()) {
+        if (this->thesolver->baseId(leave).isSPxColId() &&
+            this->thesolver
+                    ->integerVariables[this->thesolver->number(leaveId)] == 1)
+          return -1;
+      } else if (this->thesolver->baseId(leave).isSPxColId())
+        return -1;
+    }
+  }
+
+  if (leave >= 0 || minStab > 2 * this->solver()->epsilon()) {
+    val = sel;
+
+    if (leave >= 0)
+      tighten();
+  }
+
+  assert(leave < 0 || !(this->thesolver->baseId(leave).isSPxColId()) ||
+         this->thesolver->desc().colStatus(this->thesolver->number(
+             SPxColId(this->thesolver->baseId(leave)))) !=
+             SPxBasisBase<R>::Desc::P_FIXED);
+
+  return leave;
+}
 
-      x = pvec[nr];
-      d = pupd[nr];
-      up = &upb;
-      low = &lpb;
-
-      if(d < 0.0)
-         sel = (lpb[nr] - pvec[nr]) / d;
-      else
-         sel = (upb[nr] - pvec[nr]) / d;
-   }
-   else
+template <class R>
+bool SPxFastRT<R>::maxReEnter(R &sel, R maxabs, const SPxId &id, int nr,
+                              bool polish) {
+  R x, d;
+  VectorBase<R> *up;
+  VectorBase<R> *low;
+
+  UpdateVector<R> &pvec = this->thesolver->pVec();
+  SSVectorBase<R> &pupd = this->thesolver->pVec().delta();
+  VectorBase<R> &upb = this->thesolver->upBound();
+  VectorBase<R> &lpb = this->thesolver->lpBound();
+  UpdateVector<R> &cvec = this->thesolver->coPvec();
+  SSVectorBase<R> &cupd = this->thesolver->coPvec().delta();
+  VectorBase<R> &ucb = this->thesolver->ucBound();
+  VectorBase<R> &lcb = this->thesolver->lcBound();
+
+  if (this->thesolver->isCoId(id)) {
+    if (this->thesolver->isCoBasic(nr)) {
+      cupd.clearIdx(nr);
       return true;
-
-   if((*up)[nr] != (*low)[nr])
-   {
-      if(sel < -fastDelta / maxabs)
-      {
-         sel = 0.0;
-
-         // prevent shifts in polishing mode to avoid a final cleanup step (i.e. simplex type switch)
-         if(!polish)
-         {
-            if(d > 0.0)
-            {
-               this->thesolver->theShift -= (*up)[nr];
-               (*up)[nr] = x;
-               this->thesolver->theShift += (*up)[nr];
-            }
-            else
-            {
-               this->thesolver->theShift += (*low)[nr];
-               (*low)[nr] = x;
-               this->thesolver->theShift -= (*low)[nr];
-            }
-         }
-      }
-   }
-   else
-   {
+    }
+
+    x = cvec[nr];
+    d = cupd[nr];
+    up = &ucb;
+    low = &lcb;
+
+    if (d < 0.0)
+      sel = (lcb[nr] - cvec[nr]) / d;
+    else
+      sel = (ucb[nr] - cvec[nr]) / d;
+  } else if (this->thesolver->isId(id)) {
+    pvec[nr] = this->thesolver->vector(nr) * cvec;
+
+    if (this->thesolver->isBasic(nr)) {
+      pupd.clearIdx(nr);
+      return true;
+    }
+
+    x = pvec[nr];
+    d = pupd[nr];
+    up = &upb;
+    low = &lpb;
+
+    if (d < 0.0)
+      sel = (lpb[nr] - pvec[nr]) / d;
+    else
+      sel = (upb[nr] - pvec[nr]) / d;
+  } else
+    return true;
+
+  if ((*up)[nr] != (*low)[nr]) {
+    if (sel < -fastDelta / maxabs) {
       sel = 0.0;
 
-      // prevent shifts in polishing mode to avoid a final cleanup step (i.e. simplex type switch)
-      if(!polish)
-      {
-         if(x > (*up)[nr])
-            this->thesolver->theShift += x - (*up)[nr];
-         else
-            this->thesolver->theShift += (*low)[nr] - x;
-
-         (*up)[nr] = (*low)[nr] = x;
+      // prevent shifts in polishing mode to avoid a final cleanup step (i.e.
+      // simplex type switch)
+      if (!polish) {
+        if (d > 0.0) {
+          this->thesolver->theShift -= (*up)[nr];
+          (*up)[nr] = x;
+          this->thesolver->theShift += (*up)[nr];
+        } else {
+          this->thesolver->theShift += (*low)[nr];
+          (*low)[nr] = x;
+          this->thesolver->theShift -= (*low)[nr];
+        }
       }
-   }
+    }
+  } else {
+    sel = 0.0;
+
+    // prevent shifts in polishing mode to avoid a final cleanup step (i.e.
+    // simplex type switch)
+    if (!polish) {
+      if (x > (*up)[nr])
+        this->thesolver->theShift += x - (*up)[nr];
+      else
+        this->thesolver->theShift += (*low)[nr] - x;
+
+      (*up)[nr] = (*low)[nr] = x;
+    }
+  }
 
-   return false;
+  return false;
 }
 
 template <class R>
-bool SPxFastRT<R>::minReEnter(
-   R& sel,
-   R maxabs,
-   const SPxId& id,
-   int nr,
-   bool polish)
-{
-   R x, d;
-   VectorBase<R>* up;
-   VectorBase<R>* low;
-
-   UpdateVector<R>& pvec = this->thesolver->pVec();
-   SSVectorBase<R>& pupd = this->thesolver->pVec().delta();
-   VectorBase<R>& upb = this->thesolver->upBound();
-   VectorBase<R>& lpb = this->thesolver->lpBound();
-   UpdateVector<R>& cvec = this->thesolver->coPvec();
-   SSVectorBase<R>& cupd = this->thesolver->coPvec().delta();
-   VectorBase<R>& ucb = this->thesolver->ucBound();
-   VectorBase<R>& lcb = this->thesolver->lcBound();
-
-   if(this->thesolver->isCoId(id))
-   {
-      if(this->thesolver->isCoBasic(nr))
-      {
-         cupd.clearIdx(nr);
-         return true;
-      }
+bool SPxFastRT<R>::minReEnter(R &sel, R maxabs, const SPxId &id, int nr,
+                              bool polish) {
+  R x, d;
+  VectorBase<R> *up;
+  VectorBase<R> *low;
+
+  UpdateVector<R> &pvec = this->thesolver->pVec();
+  SSVectorBase<R> &pupd = this->thesolver->pVec().delta();
+  VectorBase<R> &upb = this->thesolver->upBound();
+  VectorBase<R> &lpb = this->thesolver->lpBound();
+  UpdateVector<R> &cvec = this->thesolver->coPvec();
+  SSVectorBase<R> &cupd = this->thesolver->coPvec().delta();
+  VectorBase<R> &ucb = this->thesolver->ucBound();
+  VectorBase<R> &lcb = this->thesolver->lcBound();
+
+  if (this->thesolver->isCoId(id)) {
+    if (this->thesolver->isCoBasic(nr)) {
+      cupd.clearIdx(nr);
+      return true;
+    }
 
-      x = cvec[nr];
-      d = cupd[nr];
-      up = &ucb;
-      low = &lcb;
+    x = cvec[nr];
+    d = cupd[nr];
+    up = &ucb;
+    low = &lcb;
 
-      if(d > 0.0)
-         sel = (this->thesolver->lcBound()[nr] - cvec[nr]) / d;
-      else
-         sel = (this->thesolver->ucBound()[nr] - cvec[nr]) / d;
-   }
+    if (d > 0.0)
+      sel = (this->thesolver->lcBound()[nr] - cvec[nr]) / d;
+    else
+      sel = (this->thesolver->ucBound()[nr] - cvec[nr]) / d;
+  }
 
-   else if(this->thesolver->isId(id))
-   {
-      pvec[nr] = this->thesolver->vector(nr) * cvec;
+  else if (this->thesolver->isId(id)) {
+    pvec[nr] = this->thesolver->vector(nr) * cvec;
 
-      if(this->thesolver->isBasic(nr))
-      {
-         pupd.clearIdx(nr);
-         return true;
-      }
+    if (this->thesolver->isBasic(nr)) {
+      pupd.clearIdx(nr);
+      return true;
+    }
 
-      x = pvec[nr];
-      d = pupd[nr];
-      up = &upb;
-      low = &lpb;
+    x = pvec[nr];
+    d = pupd[nr];
+    up = &upb;
+    low = &lpb;
 
-      if(d > 0.0)
-         sel = (this->thesolver->lpBound()[nr] - pvec[nr]) / d;
-      else
-         sel = (this->thesolver->upBound()[nr] - pvec[nr]) / d;
-   }
+    if (d > 0.0)
+      sel = (this->thesolver->lpBound()[nr] - pvec[nr]) / d;
+    else
+      sel = (this->thesolver->upBound()[nr] - pvec[nr]) / d;
+  }
 
-   else
-      return true;
+  else
+    return true;
 
-   if((*up)[nr] != (*low)[nr])
-   {
-      if(sel > fastDelta / maxabs)
-      {
-         sel = 0.0;
-
-         // prevent shifts in polishing mode to avoid a final cleanup step (i.e. simplex type switch)
-         if(!polish)
-         {
-            if(d < 0.0)
-            {
-               this->thesolver->theShift -= (*up)[nr];
-               (*up)[nr] = x;
-               this->thesolver->theShift += (*up)[nr];
-            }
-            else
-            {
-               this->thesolver->theShift += (*low)[nr];
-               (*low)[nr] = x;
-               this->thesolver->theShift -= (*low)[nr];
-            }
-         }
-      }
-   }
-   else
-   {
+  if ((*up)[nr] != (*low)[nr]) {
+    if (sel > fastDelta / maxabs) {
       sel = 0.0;
 
-      // prevent shifts in polishing mode to avoid a final cleanup step (i.e. simplex type switch)
-      if(!polish)
-      {
-         if(x > (*up)[nr])
-            this->thesolver->theShift += x - (*up)[nr];
-         else
-            this->thesolver->theShift += (*low)[nr] - x;
-
-         (*up)[nr] = (*low)[nr] = x;
+      // prevent shifts in polishing mode to avoid a final cleanup step (i.e.
+      // simplex type switch)
+      if (!polish) {
+        if (d < 0.0) {
+          this->thesolver->theShift -= (*up)[nr];
+          (*up)[nr] = x;
+          this->thesolver->theShift += (*up)[nr];
+        } else {
+          this->thesolver->theShift += (*low)[nr];
+          (*low)[nr] = x;
+          this->thesolver->theShift -= (*low)[nr];
+        }
       }
-   }
+    }
+  } else {
+    sel = 0.0;
+
+    // prevent shifts in polishing mode to avoid a final cleanup step (i.e.
+    // simplex type switch)
+    if (!polish) {
+      if (x > (*up)[nr])
+        this->thesolver->theShift += x - (*up)[nr];
+      else
+        this->thesolver->theShift += (*low)[nr] - x;
 
-   return false;
+      (*up)[nr] = (*low)[nr] = x;
+    }
+  }
+
+  return false;
 }
 
 template <class R>
-bool SPxFastRT<R>::shortEnter(
-   const SPxId& enterId,
-   int nr,
-   R max,
-   R maxabs) const
-{
-   if(this->thesolver->isCoId(enterId))
-   {
-      if(max != 0.0)
-      {
-         R x = this->thesolver->coPvec().delta()[nr];
+bool SPxFastRT<R>::shortEnter(const SPxId &enterId, int nr, R max,
+                              R maxabs) const {
+  if (this->thesolver->isCoId(enterId)) {
+    if (max != 0.0) {
+      R x = this->thesolver->coPvec().delta()[nr];
 
-         if(x < maxabs * SHORTVAL && -x < maxabs * SHORTVAL)
-            return false;
-      }
+      if (x < maxabs * SHORTVAL && -x < maxabs * SHORTVAL)
+        return false;
+    }
 
-      return true;
-   }
-   else if(this->thesolver->isId(enterId))
-   {
-      if(max != 0.0)
-      {
-         R x = this->thesolver->pVec().delta()[nr];
+    return true;
+  } else if (this->thesolver->isId(enterId)) {
+    if (max != 0.0) {
+      R x = this->thesolver->pVec().delta()[nr];
 
-         if(x < maxabs * SHORTVAL && -x < maxabs * SHORTVAL)
-            return false;
-      }
+      if (x < maxabs * SHORTVAL && -x < maxabs * SHORTVAL)
+        return false;
+    }
 
-      return true;
-   }
+    return true;
+  }
 
-   return false;
+  return false;
 }
 
-template <class R>
-SPxId SPxFastRT<R>::selectEnter(R& val, int, bool polish)
-{
-   SPxId enterId;
-   R max, sel;
-   R maxabs = 0.0;
-   int nr;
-   int cnt = 0;
-
-   assert(this->m_type == SPxSolverBase<R>::LEAVE);
+template <class R> SPxId SPxFastRT<R>::selectEnter(R &val, int, bool polish) {
+  SPxId enterId;
+  R max, sel;
+  R maxabs = 0.0;
+  int nr;
+  int cnt = 0;
 
-   // force instable pivot iff true (see explanation in leave.hpp and spxsolve.hpp)
-   bool instable = this->solver()->instableLeave;
-   R lowstab = LOWSTAB;
-   assert(!instable || this->solver()->instableLeaveNum >= 0);
+  assert(this->m_type == SPxSolverBase<R>::LEAVE);
 
-   resetTols();
-   sel = 0.0;
+  // force instable pivot iff true (see explanation in leave.hpp and
+  // spxsolve.hpp)
+  bool instable = this->solver()->instableLeave;
+  R lowstab = LOWSTAB;
+  assert(!instable || this->solver()->instableLeaveNum >= 0);
 
-   if(val > epsilon)
-   {
-      do
-      {
-         maxabs = 0.0;
-         max = val;
+  resetTols();
+  sel = 0.0;
 
-         enterId = maxDelta(nr, max, maxabs);
+  if (val > epsilon) {
+    do {
+      maxabs = 0.0;
+      max = val;
 
-         if(!enterId.isValid())
-            return enterId;
+      enterId = maxDelta(nr, max, maxabs);
 
-         assert(max >= 0.0);
-         assert(!enterId.isValid() || !this->solver()->isBasic(enterId));
+      if (!enterId.isValid())
+        return enterId;
 
-         if(!shortEnter(enterId, nr, max, maxabs))
-         {
-            R bestDelta, stab;
+      assert(max >= 0.0);
+      assert(!enterId.isValid() || !this->solver()->isBasic(enterId));
 
-            stab = minStability(maxabs);
+      if (!shortEnter(enterId, nr, max, maxabs)) {
+        R bestDelta, stab;
 
-            // force instable pivot iff instable is true (see explanation in leave.hpp and spxsolve.hpp)
-            if(instable)
-            {
-               enterId = maxSelect(nr, sel, lowstab, bestDelta, max);
-            }
-            else
-            {
-               enterId = maxSelect(nr, sel, stab, bestDelta, max);
-            }
-
-            if(bestDelta < DELTA_SHIFT * TRIES)
-               cnt++;
-            else
-               cnt += TRIES;
-         }
+        stab = minStability(maxabs);
 
-         if(!maxReEnter(sel, maxabs, enterId, nr, polish))
-            break;
+        // force instable pivot iff instable is true (see explanation in
+        // leave.hpp and spxsolve.hpp)
+        if (instable) {
+          enterId = maxSelect(nr, sel, lowstab, bestDelta, max);
+        } else {
+          enterId = maxSelect(nr, sel, stab, bestDelta, max);
+        }
 
-         relax();
+        if (bestDelta < DELTA_SHIFT * TRIES)
+          cnt++;
+        else
+          cnt += TRIES;
       }
-      while(cnt < TRIES);
-   }
-   else if(val < -epsilon)
-   {
-      do
-      {
-         maxabs = 0.0;
-         max = val;
-         enterId = minDelta(nr, max, maxabs);
 
-         if(!enterId.isValid())
-            return enterId;
+      if (!maxReEnter(sel, maxabs, enterId, nr, polish))
+        break;
 
-         assert(max <= 0.0);
-         assert(!enterId.isValid() || !this->solver()->isBasic(enterId));
+      relax();
+    } while (cnt < TRIES);
+  } else if (val < -epsilon) {
+    do {
+      maxabs = 0.0;
+      max = val;
+      enterId = minDelta(nr, max, maxabs);
 
-         if(!shortEnter(enterId, nr, max, maxabs))
-         {
-            R bestDelta, stab;
+      if (!enterId.isValid())
+        return enterId;
 
-            stab = minStability(maxabs);
+      assert(max <= 0.0);
+      assert(!enterId.isValid() || !this->solver()->isBasic(enterId));
 
-            // force instable pivot iff instable is true (see explanation in leave.hpp and spxsolve.hpp)
-            if(instable)
-            {
-               enterId = minSelect(nr, sel, lowstab, bestDelta, max);
-            }
-            else
-            {
-               enterId = minSelect(nr, sel, stab, bestDelta, max);
-            }
+      if (!shortEnter(enterId, nr, max, maxabs)) {
+        R bestDelta, stab;
 
-            if(bestDelta < DELTA_SHIFT * TRIES)
-               cnt++;
-            else
-               cnt += TRIES;
-         }
+        stab = minStability(maxabs);
 
-         if(!minReEnter(sel, maxabs, enterId, nr, polish))
-            break;
+        // force instable pivot iff instable is true (see explanation in
+        // leave.hpp and spxsolve.hpp)
+        if (instable) {
+          enterId = minSelect(nr, sel, lowstab, bestDelta, max);
+        } else {
+          enterId = minSelect(nr, sel, stab, bestDelta, max);
+        }
 
-         relax();
+        if (bestDelta < DELTA_SHIFT * TRIES)
+          cnt++;
+        else
+          cnt += TRIES;
       }
-      while(cnt < TRIES);
-   }
-
-   MSG_DEBUG(
-
-      if(enterId.isValid())
-{
-   assert(!enterId.isValid() || !this->solver()->isBasic(enterId));
-
-      R x;
-
-      if(this->thesolver->isCoId(enterId))
-         x = this->thesolver->coPvec().delta()[ this->thesolver->number(enterId) ];
-      else
-         x = this->thesolver->pVec().delta()[ this->thesolver->number(enterId) ];
-
-      std::cout << "DFSTRT03 " << this->thesolver->basis().iteration() << ": "
-                << sel << '\t' << x << " (" << maxabs << ")" << std::endl;
-   }
-   else
-      std::cout << "DFSTRT04 " << this->thesolver->basis().iteration()
-                << ": skipping instable pivot" << std::endl;
-      )
 
-      if(polish && enterId.isValid())
-      {
-         assert(this->thesolver->rep() == SPxSolverBase<R>::ROW);
-
-         // decide whether the chosen entering index contributes to the polishing objective
-         if(this->thesolver->polishObj == SPxSolverBase<R>::POLISH_INTEGRALITY)
-         {
-            // only allow (integer) variables to enter the basis
-            if(enterId.isSPxRowId())
-               return SPxId();
-            else if(this->thesolver->integerVariables.size() == this->thesolver->nCols()
-                    && this->thesolver->integerVariables[this->thesolver->number(enterId)] == 0)
-               return SPxId();
-         }
-         else if(this->thesolver->polishObj == SPxSolverBase<R>::POLISH_FRACTIONALITY)
-         {
-            // only allow slacks and continuous variables to enter the basis
-            if(this->thesolver->integerVariables.size() == this->thesolver->nCols())
-            {
-               if(enterId.isSPxColId() && this->thesolver->integerVariables[this->thesolver->number(enterId)] == 1)
-                  return SPxId();
-            }
-            else if(enterId.isSPxColId())
-               return SPxId();
-         }
-      }
-
-
-   if(enterId.isValid() || minStab > 2 * epsilon)
-   {
-      val = sel;
-
-      if(enterId.isValid())
-         tighten();
-   }
-
-   assert(!enterId.isValid() || !this->solver()->isBasic(enterId));
-
-   return enterId;
+      if (!minReEnter(sel, maxabs, enterId, nr, polish))
+        break;
+
+      relax();
+    } while (cnt < TRIES);
+  }
+
+  MSG_DEBUG(
+
+      if (enterId.isValid()) {
+        assert(!enterId.isValid() || !this->solver()->isBasic(enterId));
+
+        R x;
+
+        if (this->thesolver->isCoId(enterId))
+          x = this->thesolver->coPvec()
+                  .delta()[this->thesolver->number(enterId)];
+        else
+          x = this->thesolver->pVec().delta()[this->thesolver->number(enterId)];
+
+        std::cout << "DFSTRT03 " << this->thesolver->basis().iteration() << ": "
+                  << sel << '\t' << x << " (" << maxabs << ")" << std::endl;
+      } else std::cout
+          << "DFSTRT04 " << this->thesolver->basis().iteration()
+          << ": skipping instable pivot" << std::endl;)
+
+  if (polish && enterId.isValid()) {
+    assert(this->thesolver->rep() == SPxSolverBase<R>::ROW);
+
+    // decide whether the chosen entering index contributes to the polishing
+    // objective
+    if (this->thesolver->polishObj == SPxSolverBase<R>::POLISH_INTEGRALITY) {
+      // only allow (integer) variables to enter the basis
+      if (enterId.isSPxRowId())
+        return SPxId();
+      else if (this->thesolver->integerVariables.size() ==
+                   this->thesolver->nCols() &&
+               this->thesolver
+                       ->integerVariables[this->thesolver->number(enterId)] ==
+                   0)
+        return SPxId();
+    } else if (this->thesolver->polishObj ==
+               SPxSolverBase<R>::POLISH_FRACTIONALITY) {
+      // only allow slacks and continuous variables to enter the basis
+      if (this->thesolver->integerVariables.size() ==
+          this->thesolver->nCols()) {
+        if (enterId.isSPxColId() &&
+            this->thesolver
+                    ->integerVariables[this->thesolver->number(enterId)] == 1)
+          return SPxId();
+      } else if (enterId.isSPxColId())
+        return SPxId();
+    }
+  }
+
+  if (enterId.isValid() || minStab > 2 * epsilon) {
+    val = sel;
+
+    if (enterId.isValid())
+      tighten();
+  }
+
+  assert(!enterId.isValid() || !this->solver()->isBasic(enterId));
+
+  return enterId;
 }
 
-template <class R>
-void SPxFastRT<R>::load(SPxSolverBase<R>* spx)
-{
-   this->thesolver = spx;
-   setType(spx->type());
+template <class R> void SPxFastRT<R>::load(SPxSolverBase<R> *spx) {
+  this->thesolver = spx;
+  setType(spx->type());
 }
 
 template <class R>
-void SPxFastRT<R>::setType(typename SPxSolverBase<R>::Type type)
-{
-   this->m_type = type;
+void SPxFastRT<R>::setType(typename SPxSolverBase<R>::Type type) {
+  this->m_type = type;
 
-   minStab = MINSTAB;
-   fastDelta = this->delta;
+  minStab = MINSTAB;
+  fastDelta = this->delta;
 }
 } // namespace soplex
diff --git a/src/soplex/spxfileio.hpp b/src/soplex/spxfileio.hpp
index 3b7e15d..1e40eeb 100644
--- a/src/soplex/spxfileio.hpp
+++ b/src/soplex/spxfileio.hpp
@@ -21,43 +21,39 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <assert.h>
 
 #include "soplex/spxdefines.h"
-#include "soplex/spxsolver.h"
 #include "soplex/spxfileio.h"
+#include "soplex/spxsolver.h"
 
-namespace soplex
-{
+namespace soplex {
 template <class R>
-bool SPxSolverBase<R>::readBasisFile(
-   const char*    filename,
-   const NameSet* rowNames,
-   const NameSet* colNames)
-{
-   spxifstream file(filename);
+bool SPxSolverBase<R>::readBasisFile(const char *filename,
+                                     const NameSet *rowNames,
+                                     const NameSet *colNames) {
+  spxifstream file(filename);
 
-   if(!file)
-      return false;
+  if (!file)
+    return false;
 
-   return this->readBasis(file, rowNames, colNames);
+  return this->readBasis(file, rowNames, colNames);
 }
 
 template <class R>
-bool SPxSolverBase<R>::writeBasisFile
-(const char*    filename,
- const NameSet* rowNames,
- const NameSet* colNames,
- const bool cpxFormat) const
-{
-   std::ofstream file(filename);
-
-   if(!file)
-      return false;
-
-   this->writeBasis(file, rowNames, colNames);
-   return true;
+bool SPxSolverBase<R>::writeBasisFile(const char *filename,
+                                      const NameSet *rowNames,
+                                      const NameSet *colNames,
+                                      const bool cpxFormat) const {
+  std::ofstream file(filename);
+
+  if (!file)
+    return false;
+
+  this->writeBasis(file, rowNames, colNames);
+  return true;
 }
 
 } // namespace soplex
diff --git a/src/soplex/spxgeometsc.hpp b/src/soplex/spxgeometsc.hpp
index b7062a3..0435dd5 100644
--- a/src/soplex/spxgeometsc.hpp
+++ b/src/soplex/spxgeometsc.hpp
@@ -21,249 +21,228 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 /**@file  spxgeometsc.hpp
  * @brief Geometric mean row/column scaling.
  */
 #include <assert.h>
 
-#include "soplex/spxout.h"
-#include "soplex/spxlpbase.h"
 #include "soplex/spxequilisc.h"
+#include "soplex/spxlpbase.h"
+#include "soplex/spxout.h"
 
-namespace soplex
-{
+namespace soplex {
 
 template <class R>
-static R computeScalingVec(
-   const SVSetBase<R>*             vecset,
-   const std::vector<R>& coScaleval,
-   std::vector<R>&       scaleval)
-{
-   R pmax = 0.0;
-
-   assert(scaleval.size() == unsigned(vecset->num()));
-
-   for(int i = 0; i < vecset->num(); ++i)
-   {
-      const SVectorBase<R>& vec = (*vecset)[i];
-
-      R maxi = 0.0;
-      R mini = R(infinity);
-
-      for(int j = 0; j < vec.size(); ++j)
-      {
-         const R x = spxAbs(vec.value(j) * coScaleval[unsigned(vec.index(j))]);
-
-         if(!isZero(x))
-         {
-            if(x > maxi)
-               maxi = x;
-
-            if(x < mini)
-               mini = x;
-         }
-      }
+static R computeScalingVec(const SVSetBase<R> *vecset,
+                           const std::vector<R> &coScaleval,
+                           std::vector<R> &scaleval) {
+  R pmax = 0.0;
+
+  assert(scaleval.size() == unsigned(vecset->num()));
+
+  for (int i = 0; i < vecset->num(); ++i) {
+    const SVectorBase<R> &vec = (*vecset)[i];
 
-      // empty rows/cols are possible
-      if(mini == R(infinity) || maxi == 0.0)
-      {
-         mini = 1.0;
-         maxi = 1.0;
+    R maxi = 0.0;
+    R mini = R(infinity);
+
+    for (int j = 0; j < vec.size(); ++j) {
+      const R x = spxAbs(vec.value(j) * coScaleval[unsigned(vec.index(j))]);
+
+      if (!isZero(x)) {
+        if (x > maxi)
+          maxi = x;
+
+        if (x < mini)
+          mini = x;
       }
+    }
+
+    // empty rows/cols are possible
+    if (mini == R(infinity) || maxi == 0.0) {
+      mini = 1.0;
+      maxi = 1.0;
+    }
 
-      assert(mini < R(infinity));
-      assert(maxi > 0.0);
+    assert(mini < R(infinity));
+    assert(maxi > 0.0);
 
-      scaleval[unsigned(i)] = 1.0 / spxSqrt(mini * maxi);
+    scaleval[unsigned(i)] = 1.0 / spxSqrt(mini * maxi);
 
-      const R p = maxi / mini;
+    const R p = maxi / mini;
 
-      if(p > pmax)
-         pmax = p;
-   }
+    if (p > pmax)
+      pmax = p;
+  }
 
-   return pmax;
+  return pmax;
 }
 
 template <class R>
-SPxGeometSC<R>::SPxGeometSC(bool equilibrate, int maxIters, R minImpr, R goodEnough)
-   : SPxScaler<R>("Geometric")
-   , postequilibration(equilibrate)
-   , m_maxIterations(maxIters)
-   , m_minImprovement(minImpr)
-   , m_goodEnoughRatio(goodEnough)
-{
-   assert(maxIters > 0);
-   assert(minImpr > 0.0 && minImpr <= 1.0);
-   assert(goodEnough >= 0.0);
+SPxGeometSC<R>::SPxGeometSC(bool equilibrate, int maxIters, R minImpr,
+                            R goodEnough)
+    : SPxScaler<R>("Geometric"), postequilibration(equilibrate),
+      m_maxIterations(maxIters), m_minImprovement(minImpr),
+      m_goodEnoughRatio(goodEnough) {
+  assert(maxIters > 0);
+  assert(minImpr > 0.0 && minImpr <= 1.0);
+  assert(goodEnough >= 0.0);
 }
 
 template <class R>
-SPxGeometSC<R>::SPxGeometSC(const SPxGeometSC<R>& old)
-   : SPxScaler<R>(old)
-   , postequilibration(old.postequilibration)
-   , m_maxIterations(old.m_maxIterations)
-   , m_minImprovement(old.m_minImprovement)
-   , m_goodEnoughRatio(old.m_goodEnoughRatio)
-{
-   assert(m_maxIterations > 0);
-   assert(m_minImprovement > 0.0 && m_minImprovement <= 1.0);
-   assert(m_goodEnoughRatio >= 0.0);
+SPxGeometSC<R>::SPxGeometSC(const SPxGeometSC<R> &old)
+    : SPxScaler<R>(old), postequilibration(old.postequilibration),
+      m_maxIterations(old.m_maxIterations),
+      m_minImprovement(old.m_minImprovement),
+      m_goodEnoughRatio(old.m_goodEnoughRatio) {
+  assert(m_maxIterations > 0);
+  assert(m_minImprovement > 0.0 && m_minImprovement <= 1.0);
+  assert(m_goodEnoughRatio >= 0.0);
 }
 
 template <class R>
-SPxGeometSC<R>& SPxGeometSC<R>::operator=(const SPxGeometSC<R>& rhs)
-{
-   if(this != &rhs)
-   {
-      SPxScaler<R>::operator=(rhs);
-   }
-
-   return *this;
+SPxGeometSC<R> &SPxGeometSC<R>::operator=(const SPxGeometSC<R> &rhs) {
+  if (this != &rhs) {
+    SPxScaler<R>::operator=(rhs);
+  }
+
+  return *this;
 }
 
 template <class R>
-void SPxGeometSC<R>::scale(SPxLPBase<R>& lp, bool persistent)
-{
-
-   MSG_INFO1((*this->spxout), (*this->spxout) << "Geometric scaling LP" <<
-             (persistent ? " (persistent)" : "") << (postequilibration ? " with post-equilibration" : "") <<
-             std::endl;)
-
-   this->setup(lp);
-
-   /* We want to do that direction first, with the lower ratio.
-    * See SPxEquiliSC<R>::scale() for a reasoning.
-    */
-   const R colratio = this->maxColRatio(lp);
-   const R rowratio = this->maxRowRatio(lp);
-
-   const bool colFirst = colratio < rowratio;
-
-   R p0start;
-   R p1start;
-
-   if(colFirst)
-   {
-      p0start = colratio;
-      p1start = rowratio;
-   }
-   else
-   {
-      p0start = rowratio;
-      p1start = colratio;
-   }
-
-   MSG_INFO2((*this->spxout), (*this->spxout) << "before scaling:"
-             << " min= " << lp.minAbsNzo()
-             << " max= " << lp.maxAbsNzo()
-             << " col-ratio= " << colratio
-             << " row-ratio= " << rowratio
-             << std::endl;)
-
-   // perform geometric scaling only if maximum ratio is above threshold
-   bool geoscale = p1start > m_goodEnoughRatio;
-
-   if(!geoscale)
-   {
-      MSG_INFO2((*this->spxout), (*this->spxout) << "No geometric scaling done, ratio good enough" <<
-                std::endl;)
-
-      if(!postequilibration)
-      {
-         lp.setScalingInfo(true);
-         return;
-      }
+void SPxGeometSC<R>::scale(SPxLPBase<R> &lp, bool persistent) {
 
-      MSG_INFO2((*this->spxout), (*this->spxout) << " ... but will still perform equilibrium scaling" <<
-                std::endl;)
-   }
-
-   std::vector<R> rowscale(unsigned(lp.nRows()), 1.0);
-   std::vector<R> colscale(unsigned(lp.nCols()), 1.0);
-
-   R p0 = 0.0;
-   R p1 = 0.0;
-
-   if(geoscale)
-   {
-      R p0prev = p0start;
-      R p1prev = p1start;
-
-      // we make at most maxIterations.
-      for(int count = 0; count < m_maxIterations; count++)
-      {
-         if(colFirst)
-         {
-            p0 = computeScalingVec(lp.colSet(), rowscale, colscale);
-            p1 = computeScalingVec(lp.rowSet(), colscale, rowscale);
-         }
-         else
-         {
-            p0 = computeScalingVec(lp.rowSet(), colscale, rowscale);
-            p1 = computeScalingVec(lp.colSet(), rowscale, colscale);
-         }
-
-         MSG_INFO3((*this->spxout), (*this->spxout) << "Geometric scaling round " << count
-                   << " col-ratio= " << (colFirst ? p0 : p1)
-                   << " row-ratio= " << (colFirst ? p1 : p0)
-                   << std::endl;)
-
-         if(p0 > m_minImprovement * p0prev && p1 > m_minImprovement * p1prev)
-            break;
-
-         p0prev = p0;
-         p1prev = p1;
-      }
+  MSG_INFO1((*this->spxout),
+            (*this->spxout)
+                << "Geometric scaling LP" << (persistent ? " (persistent)" : "")
+                << (postequilibration ? " with post-equilibration" : "")
+                << std::endl;)
+
+  this->setup(lp);
+
+  /* We want to do that direction first, with the lower ratio.
+   * See SPxEquiliSC<R>::scale() for a reasoning.
+   */
+  const R colratio = this->maxColRatio(lp);
+  const R rowratio = this->maxRowRatio(lp);
+
+  const bool colFirst = colratio < rowratio;
+
+  R p0start;
+  R p1start;
+
+  if (colFirst) {
+    p0start = colratio;
+    p1start = rowratio;
+  } else {
+    p0start = rowratio;
+    p1start = colratio;
+  }
+
+  MSG_INFO2((*this->spxout), (*this->spxout)
+                                 << "before scaling:"
+                                 << " min= " << lp.minAbsNzo() << " max= "
+                                 << lp.maxAbsNzo() << " col-ratio= " << colratio
+                                 << " row-ratio= " << rowratio << std::endl;)
 
-      // perform geometric scaling only if there is enough (default 15%) improvement.
-      geoscale = (p0 <= m_minImprovement * p0start || p1 <= m_minImprovement * p1start);
-   }
+  // perform geometric scaling only if maximum ratio is above threshold
+  bool geoscale = p1start > m_goodEnoughRatio;
 
-   if(!geoscale && !postequilibration)
-   {
-      MSG_INFO2((*this->spxout), (*this->spxout) << "No geometric scaling done." << std::endl;)
+  if (!geoscale) {
+    MSG_INFO2((*this->spxout),
+              (*this->spxout) << "No geometric scaling done, ratio good enough"
+                              << std::endl;)
+
+    if (!postequilibration) {
       lp.setScalingInfo(true);
-   }
-   else
-   {
-      DataArray<int>& colscaleExp = *this->m_activeColscaleExp;
-      DataArray<int>& rowscaleExp = *this->m_activeRowscaleExp;
-
-      if(postequilibration)
-      {
-         if(!geoscale)
-         {
-            std::fill(rowscale.begin(), rowscale.end(), 1.0);
-            std::fill(colscale.begin(), colscale.end(), 1.0);
-         }
-
-         SPxEquiliSC<R>::computePostequiExpVecs(lp, rowscale, colscale, rowscaleExp, colscaleExp);
-      }
-      else
-      {
-         this->computeExpVec(colscale, colscaleExp);
-         this->computeExpVec(rowscale, rowscaleExp);
+      return;
+    }
+
+    MSG_INFO2((*this->spxout),
+              (*this->spxout)
+                  << " ... but will still perform equilibrium scaling"
+                  << std::endl;)
+  }
+
+  std::vector<R> rowscale(unsigned(lp.nRows()), 1.0);
+  std::vector<R> colscale(unsigned(lp.nCols()), 1.0);
+
+  R p0 = 0.0;
+  R p1 = 0.0;
+
+  if (geoscale) {
+    R p0prev = p0start;
+    R p1prev = p1start;
+
+    // we make at most maxIterations.
+    for (int count = 0; count < m_maxIterations; count++) {
+      if (colFirst) {
+        p0 = computeScalingVec(lp.colSet(), rowscale, colscale);
+        p1 = computeScalingVec(lp.rowSet(), colscale, rowscale);
+      } else {
+        p0 = computeScalingVec(lp.rowSet(), colscale, rowscale);
+        p1 = computeScalingVec(lp.colSet(), rowscale, colscale);
       }
 
-      this->applyScaling(lp);
-
-      MSG_INFO3((*this->spxout), (*this->spxout) << "Row scaling min= " << this->minAbsRowscale()
-                << " max= " << this->maxAbsRowscale()
-                << std::endl
-                << "IGEOSC06 Col scaling min= " << this->minAbsColscale()
-                << " max= " << this->maxAbsColscale()
-                << std::endl;)
+      MSG_INFO3((*this->spxout), (*this->spxout)
+                                     << "Geometric scaling round " << count
+                                     << " col-ratio= " << (colFirst ? p0 : p1)
+                                     << " row-ratio= " << (colFirst ? p1 : p0)
+                                     << std::endl;)
+
+      if (p0 > m_minImprovement * p0prev && p1 > m_minImprovement * p1prev)
+        break;
+
+      p0prev = p0;
+      p1prev = p1;
+    }
+
+    // perform geometric scaling only if there is enough (default 15%)
+    // improvement.
+    geoscale =
+        (p0 <= m_minImprovement * p0start || p1 <= m_minImprovement * p1start);
+  }
+
+  if (!geoscale && !postequilibration) {
+    MSG_INFO2((*this->spxout),
+              (*this->spxout) << "No geometric scaling done." << std::endl;)
+    lp.setScalingInfo(true);
+  } else {
+    DataArray<int> &colscaleExp = *this->m_activeColscaleExp;
+    DataArray<int> &rowscaleExp = *this->m_activeRowscaleExp;
+
+    if (postequilibration) {
+      if (!geoscale) {
+        std::fill(rowscale.begin(), rowscale.end(), 1.0);
+        std::fill(colscale.begin(), colscale.end(), 1.0);
+      }
 
-      MSG_INFO2((*this->spxout), (*this->spxout) << "after scaling: "
-                << " min= " << lp.minAbsNzo(false)
-                << " max= " << lp.maxAbsNzo(false)
-                << " col-ratio= " << this->maxColRatio(lp)
-                << " row-ratio= " << this->maxRowRatio(lp)
-                << std::endl;)
-   }
+      SPxEquiliSC<R>::computePostequiExpVecs(lp, rowscale, colscale,
+                                             rowscaleExp, colscaleExp);
+    } else {
+      this->computeExpVec(colscale, colscaleExp);
+      this->computeExpVec(rowscale, rowscaleExp);
+    }
+
+    this->applyScaling(lp);
+
+    MSG_INFO3((*this->spxout),
+              (*this->spxout)
+                  << "Row scaling min= " << this->minAbsRowscale()
+                  << " max= " << this->maxAbsRowscale() << std::endl
+                  << "IGEOSC06 Col scaling min= " << this->minAbsColscale()
+                  << " max= " << this->maxAbsColscale() << std::endl;)
+
+    MSG_INFO2((*this->spxout), (*this->spxout)
+                                   << "after scaling: "
+                                   << " min= " << lp.minAbsNzo(false)
+                                   << " max= " << lp.maxAbsNzo(false)
+                                   << " col-ratio= " << this->maxColRatio(lp)
+                                   << " row-ratio= " << this->maxRowRatio(lp)
+                                   << std::endl;)
+  }
 }
 
-
 } // namespace soplex
diff --git a/src/soplex/spxharrisrt.hpp b/src/soplex/spxharrisrt.hpp
index 9641366..5ab4333 100644
--- a/src/soplex/spxharrisrt.hpp
+++ b/src/soplex/spxharrisrt.hpp
@@ -21,9 +21,9 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
-namespace soplex
-{
+namespace soplex {
 /**@todo suspicious: *max is not set, but it is used
  * (with the default setting *max=1) in selectLeave and selectEnter
  * The question might be if max shouldn't be updated with themax?
@@ -33,63 +33,56 @@ namespace soplex
  * 0 until numCycle >= 2 * maxCycle, after wich it becomes
  * negative. This does not look ok.
  */
-template <class R>
-R SPxHarrisRT<R>::degenerateEps() const
-{
-   return this->solver()->delta()
-          * (1.0 - this->solver()->numCycle() / this->solver()->maxCycle());
+template <class R> R SPxHarrisRT<R>::degenerateEps() const {
+  return this->solver()->delta() *
+         (1.0 - this->solver()->numCycle() / this->solver()->maxCycle());
 }
 
 template <class R>
-int SPxHarrisRT<R>::maxDelta(
-   R* /*max*/,             /* max abs value in upd */
-   R* val,             /* initial and chosen value */
-   int num,             /* # of indices in idx */
-   const int* idx,             /* nonzero indices in upd */
-   const R* upd,             /* update VectorBase<R> for vec */
-   const R* vec,             /* current VectorBase<R> */
-   const R* low,             /* lower bounds for vec */
-   const R* up,              /* upper bounds for vec */
-   R epsilon)  const       /* what is 0? */
+int SPxHarrisRT<R>::maxDelta(R * /*max*/,     /* max abs value in upd */
+                             R *val,          /* initial and chosen value */
+                             int num,         /* # of indices in idx */
+                             const int *idx,  /* nonzero indices in upd */
+                             const R *upd,    /* update VectorBase<R> for vec */
+                             const R *vec,    /* current VectorBase<R> */
+                             const R *low,    /* lower bounds for vec */
+                             const R *up,     /* upper bounds for vec */
+                             R epsilon) const /* what is 0? */
 {
-   R x;
-   R theval;
-   /**@todo patch suggests using *max instead of themax */
-   R themax;
-   int sel;
-   int i;
-
-   assert(*val >= 0);
-
-   theval = *val;
-   themax = 0;
-   sel = -1;
-
-   while(num--)
-   {
-      i = idx[num];
-      x = upd[i];
-
-      if(x > epsilon)
-      {
-         themax = (x > themax) ? x : themax;
-         x = (up[i] - vec[i] + this->delta) / x;
-
-         if(x < theval && up[i] < R(infinity))
-            theval = x;
-      }
-      else if(x < -epsilon)
-      {
-         themax = (-x > themax) ? -x : themax;
-         x = (low[i] - vec[i] - this->delta) / x;
-
-         if(x < theval && low[i] > R(-infinity))
-            theval = x;
-      }
-   }
-
-   *val = theval;
-   return sel;
+  R x;
+  R theval;
+  /**@todo patch suggests using *max instead of themax */
+  R themax;
+  int sel;
+  int i;
+
+  assert(*val >= 0);
+
+  theval = *val;
+  themax = 0;
+  sel = -1;
+
+  while (num--) {
+    i = idx[num];
+    x = upd[i];
+
+    if (x > epsilon) {
+      themax = (x > themax) ? x : themax;
+      x = (up[i] - vec[i] + this->delta) / x;
+
+      if (x < theval && up[i] < R(infinity))
+        theval = x;
+    } else if (x < -epsilon) {
+      themax = (-x > themax) ? -x : themax;
+      x = (low[i] - vec[i] - this->delta) / x;
+
+      if (x < theval && low[i] > R(-infinity))
+        theval = x;
+    }
+  }
+
+  *val = theval;
+  return sel;
 }
 
 /**@todo suspicious: *max is not set, but it is used
@@ -97,55 +90,50 @@ int SPxHarrisRT<R>::maxDelta(
    in selectLeave and selectEnter
 */
 template <class R>
-int SPxHarrisRT<R>::minDelta(
-   R* /*max*/,             /* max abs value in upd */
-   R* val,             /* initial and chosen value */
-   int num,             /* # of indices in idx */
-   const int* idx,             /* nonzero indices in upd */
-   const R* upd,             /* update VectorBase<R> for vec */
-   const R* vec,             /* current VectorBase<R> */
-   const R* low,             /* lower bounds for vec */
-   const R* up,              /* upper bounds for vec */
-   R epsilon) const         /* what is 0? */
+int SPxHarrisRT<R>::minDelta(R * /*max*/,     /* max abs value in upd */
+                             R *val,          /* initial and chosen value */
+                             int num,         /* # of indices in idx */
+                             const int *idx,  /* nonzero indices in upd */
+                             const R *upd,    /* update VectorBase<R> for vec */
+                             const R *vec,    /* current VectorBase<R> */
+                             const R *low,    /* lower bounds for vec */
+                             const R *up,     /* upper bounds for vec */
+                             R epsilon) const /* what is 0? */
 {
-   R x;
-   R theval;
-   /**@todo patch suggests using *max instead of themax */
-   R themax;
-   int sel;
-   int i;
-
-   assert(*val < 0);
-
-   theval = *val;
-   themax = 0;
-   sel = -1;
-
-   while(num--)
-   {
-      i = idx[num];
-      x = upd[i];
-
-      if(x > epsilon)
-      {
-         themax = (x > themax) ? x : themax;
-         x = (low[i] - vec[i] - this->delta) / x;
-
-         if(x > theval && low[i] > R(-infinity))
-            theval = x;
-      }
-      else if(x < -epsilon)
-      {
-         themax = (-x > themax) ? -x : themax;
-         x = (up[i] - vec[i] + this->delta) / x;
-
-         if(x > theval && up[i] < R(infinity))
-            theval = x;
-      }
-   }
-
-   *val = theval;
-   return sel;
+  R x;
+  R theval;
+  /**@todo patch suggests using *max instead of themax */
+  R themax;
+  int sel;
+  int i;
+
+  assert(*val < 0);
+
+  theval = *val;
+  themax = 0;
+  sel = -1;
+
+  while (num--) {
+    i = idx[num];
+    x = upd[i];
+
+    if (x > epsilon) {
+      themax = (x > themax) ? x : themax;
+      x = (low[i] - vec[i] - this->delta) / x;
+
+      if (x > theval && low[i] > R(-infinity))
+        theval = x;
+    } else if (x < -epsilon) {
+      themax = (-x > themax) ? -x : themax;
+      x = (up[i] - vec[i] + this->delta) / x;
+
+      if (x > theval && up[i] < R(infinity))
+        theval = x;
+    }
+  }
+
+  *val = theval;
+  return sel;
 }
 
 /**
@@ -154,668 +142,569 @@ int SPxHarrisRT<R>::minDelta(
    solver()->entertol() for searching numerically stable pivots.
 
    The algorithms operates in two phases. In a first phase, the maximum \p val
-   is determined, when infeasibility within solver()->entertol() is allowed. In the second
-   phase, between all variables with values < \p val the one is selected which
-   gives the best step forward in the simplex iteration. However, this may not
-   allways yield an improvement. In that case, we shift the variable toward
-   infeasibility and retry. This avoids cycling in the shifted LP.
+   is determined, when infeasibility within solver()->entertol() is allowed. In
+   the second phase, between all variables with values < \p val the one is
+   selected which gives the best step forward in the simplex iteration. However,
+   this may not allways yield an improvement. In that case, we shift the
+   variable toward infeasibility and retry. This avoids cycling in the shifted
+   LP.
 */
-template <class R>
-int SPxHarrisRT<R>::selectLeave(R& val, R, bool)
-{
-   int i, j;
-   R stab, x, y;
-   R max;
-   R sel;
-   R lastshift;
-   R useeps;
-   int leave = -1;
-   R maxabs = 1;
+template <class R> int SPxHarrisRT<R>::selectLeave(R &val, R, bool) {
+  int i, j;
+  R stab, x, y;
+  R max;
+  R sel;
+  R lastshift;
+  R useeps;
+  int leave = -1;
+  R maxabs = 1;
+
+  R epsilon = this->solver()->epsilon();
+  R degeneps = degenerateEps();
+
+  SSVectorBase<R> &upd = this->solver()->fVec().delta();
+  VectorBase<R> &vec = this->solver()->fVec();
+
+  const VectorBase<R> &up = this->solver()->ubBound();
+  const VectorBase<R> &low = this->solver()->lbBound();
+
+  assert(this->delta > epsilon);
+  assert(epsilon > 0);
+  assert(this->solver()->maxCycle() > 0);
+
+  max = val;
+  lastshift = this->solver()->shift();
+
+  this->solver()->fVec().delta().setup();
+
+  if (max > epsilon) {
+    // phase 1:
+    maxDelta(&maxabs,             /* max abs value in upd */
+             &max,                /* initial and chosen value */
+             upd.size(),          /* # of indices in upd */
+             upd.indexMem(),      /* nonzero indices in upd */
+             upd.values(),        /* update VectorBase<R> for vec */
+             vec.get_const_ptr(), /* current VectorBase<R> */
+             low.get_const_ptr(), /* lower bounds for vec */
+             up.get_const_ptr(),  /* upper bounds for vec */
+             epsilon);            /* what is 0? */
+
+    if (max == val)
+      return -1;
 
-   R epsilon  = this->solver()->epsilon();
-   R degeneps = degenerateEps();
+    // phase 2:
+    stab = 0;
+    sel = R(-infinity);
+    useeps = maxabs * epsilon * 0.001;
 
-   SSVectorBase<R>& upd = this->solver()->fVec().delta();
-   VectorBase<R>& vec = this->solver()->fVec();
+    if (useeps < epsilon)
+      useeps = epsilon;
 
-   const VectorBase<R>& up = this->solver()->ubBound();
-   const VectorBase<R>& low = this->solver()->lbBound();
+    for (j = upd.size() - 1; j >= 0; --j) {
+      i = upd.index(j);
+      x = upd[i];
 
-   assert(this->delta > epsilon);
-   assert(epsilon > 0);
-   assert(this->solver()->maxCycle() > 0);
+      if (x > useeps) {
+        y = up[i] - vec[i];
+
+        if (y < -degeneps)
+          this->solver()->shiftUBbound(i, vec[i]); // ensure simplex improvement
+        else {
+          y /= x;
+
+          if (y <= max && y > sel - epsilon && x > stab) {
+            sel = y;
+            leave = i;
+            stab = x;
+          }
+        }
+      } else if (x < -useeps) {
+        y = low[i] - vec[i];
+
+        if (y > degeneps)
+          this->solver()->shiftLBbound(i, vec[i]); // ensure simplex improvement
+        else {
+          y /= x;
+
+          if (y <= max && y > sel - epsilon && -x > stab) {
+            sel = y;
+            leave = i;
+            stab = -x;
+          }
+        }
+      } else
+        upd.clearNum(j);
+    }
+  }
+
+  else if (max < -epsilon) {
+    // phase 1:
+    minDelta(&maxabs,             /* max abs value in upd */
+             &max,                /* initial and chosen value */
+             upd.size(),          /* # of indices in upd */
+             upd.indexMem(),      /* nonzero indices in upd */
+             upd.values(),        /* update VectorBase<R> for vec */
+             vec.get_const_ptr(), /* current VectorBase<R> */
+             low.get_const_ptr(), /* lower bounds for vec */
+             up.get_const_ptr(),  /* upper bounds for vec */
+             epsilon);            /* what is 0? */
+
+    if (max == val)
+      return -1;
 
-   max = val;
-   lastshift = this->solver()->shift();
+    // phase 2:
+    stab = 0;
+    sel = R(infinity);
+    useeps = maxabs * epsilon * 0.001;
 
-   this->solver()->fVec().delta().setup();
+    if (useeps < epsilon)
+      useeps = epsilon;
 
-   if(max > epsilon)
-   {
-      // phase 1:
-      maxDelta(
-         &maxabs,             /* max abs value in upd */
-         &max,                /* initial and chosen value */
-         upd.size(),          /* # of indices in upd */
-         upd.indexMem(),      /* nonzero indices in upd */
-         upd.values(),        /* update VectorBase<R> for vec */
-         vec.get_const_ptr(),         /* current VectorBase<R> */
-         low.get_const_ptr(),                 /* lower bounds for vec */
-         up.get_const_ptr(),                  /* upper bounds for vec */
-         epsilon);             /* what is 0? */
+    for (j = upd.size() - 1; j >= 0; --j) {
+      i = upd.index(j);
+      x = upd[i];
+
+      if (x < -useeps) {
+        y = up[i] - vec[i];
+
+        if (y < -degeneps)
+          this->solver()->shiftUBbound(i, vec[i]); // ensure simplex improvement
+        else {
+          y /= x;
+
+          if (y >= max && y < sel + epsilon && -x > stab) {
+            sel = y;
+            leave = i;
+            stab = -x;
+          }
+        }
+      } else if (x > useeps) {
+        y = low[i] - vec[i];
+
+        if (y > degeneps)
+          this->solver()->shiftLBbound(i, vec[i]); // ensure simplex improvement
+        else {
+          y /= x;
+
+          if (y >= max && y < sel + epsilon && x > stab) {
+            sel = y;
+            leave = i;
+            stab = x;
+          }
+        }
+      } else
+        upd.clearNum(j);
+    }
+  }
+
+  else
+    return -1;
+
+  if (lastshift != this->solver()->shift())
+    return selectLeave(val, 0, false);
+
+  assert(leave >= 0);
+
+  val = sel;
+  return leave;
+}
 
-      if(max == val)
-         return -1;
+template <class R> SPxId SPxHarrisRT<R>::selectEnter(R &val, int, bool) {
+  int i, j;
+  SPxId enterId;
+  R stab, x, y;
+  R max = 0.0;
+  R sel = 0.0;
+  R lastshift;
+  R cuseeps;
+  R ruseeps;
+  R cmaxabs = 1;
+  R rmaxabs = 1;
+  int pnr, cnr;
+
+  R minStability = 0.0001;
+  R epsilon = this->solver()->epsilon();
+  R degeneps = degenerateEps();
+
+  VectorBase<R> &pvec = this->solver()->pVec();
+  SSVectorBase<R> &pupd = this->solver()->pVec().delta();
+
+  VectorBase<R> &cvec = this->solver()->coPvec();
+  SSVectorBase<R> &cupd = this->solver()->coPvec().delta();
+
+  const VectorBase<R> &upb = this->solver()->upBound();
+  const VectorBase<R> &lpb = this->solver()->lpBound();
+  const VectorBase<R> &ucb = this->solver()->ucBound();
+  const VectorBase<R> &lcb = this->solver()->lcBound();
+
+  assert(this->delta > epsilon);
+  assert(epsilon > 0);
+  assert(this->solver()->maxCycle() > 0);
+
+  this->solver()->coPvec().delta().setup();
+  this->solver()->pVec().delta().setup();
+
+  if (val > epsilon) {
+    for (;;) {
+      pnr = -1;
+      cnr = -1;
+      max = val;
+      lastshift = this->solver()->shift();
+      assert(this->delta > epsilon);
 
+      // phase 1:
+      maxDelta(&rmaxabs,             /* max abs value in upd */
+               &max,                 /* initial and chosen value */
+               pupd.size(),          /* # of indices in pupd */
+               pupd.indexMem(),      /* nonzero indices in pupd */
+               pupd.values(),        /* update VectorBase<R> for vec */
+               pvec.get_const_ptr(), /* current VectorBase<R> */
+               lpb.get_const_ptr(),  /* lower bounds for vec */
+               upb.get_const_ptr(),  /* upper bounds for vec */
+               epsilon);             /* what is 0? */
+
+      maxDelta(&cmaxabs,             /* max abs value in upd */
+               &max,                 /* initial and chosen value */
+               cupd.size(),          /* # of indices in cupd */
+               cupd.indexMem(),      /* nonzero indices in cupd */
+               cupd.values(),        /* update VectorBase<R> for vec */
+               cvec.get_const_ptr(), /* current VectorBase<R> */
+               lcb.get_const_ptr(),  /* lower bounds for vec */
+               ucb.get_const_ptr(),  /* upper bounds for vec */
+               epsilon);             /* what is 0? */
+
+      if (max == val)
+        return enterId;
 
       // phase 2:
       stab = 0;
       sel = R(-infinity);
-      useeps = maxabs * epsilon * 0.001;
+      ruseeps = rmaxabs * 0.001 * epsilon;
+
+      if (ruseeps < epsilon)
+        ruseeps = epsilon;
+
+      cuseeps = cmaxabs * 0.001 * epsilon;
 
-      if(useeps < epsilon)
-         useeps = epsilon;
+      if (cuseeps < epsilon)
+        cuseeps = epsilon;
 
-      for(j = upd.size() - 1; j >= 0; --j)
-      {
-         i = upd.index(j);
-         x = upd[i];
+      for (j = pupd.size() - 1; j >= 0; --j) {
+        i = pupd.index(j);
+        x = pupd[i];
 
-         if(x > useeps)
-         {
-            y = up[i] - vec[i];
+        if (x > ruseeps) {
+          y = upb[i] - pvec[i];
 
-            if(y < -degeneps)
-               this->solver()->shiftUBbound(i, vec[i]); // ensure simplex improvement
-            else
+          if (y < -degeneps)
+            this->solver()->shiftUPbound(i, pvec[i] - degeneps);
+          else {
+            y /= x;
+
+            if (y <= max && x >= stab) // &&  y > sel-epsilon
             {
-               y /= x;
-
-               if(y <= max && y > sel - epsilon && x > stab)
-               {
-                  sel = y;
-                  leave = i;
-                  stab = x;
-               }
+              enterId = this->solver()->id(i);
+              sel = y;
+              pnr = i;
+              stab = x;
             }
-         }
-         else if(x < -useeps)
-         {
-            y = low[i] - vec[i];
-
-            if(y > degeneps)
-               this->solver()->shiftLBbound(i, vec[i]); // ensure simplex improvement
-            else
+          }
+        } else if (x < -ruseeps) {
+          y = lpb[i] - pvec[i];
+
+          if (y > degeneps)
+            this->solver()->shiftLPbound(i, pvec[i] + degeneps);
+          else {
+            y /= x;
+
+            if (y <= max && -x >= stab) // &&  y > sel-epsilon
             {
-               y /= x;
-
-               if(y <= max && y > sel - epsilon && -x > stab)
-               {
-                  sel = y;
-                  leave = i;
-                  stab = -x;
-               }
+              enterId = this->solver()->id(i);
+              sel = y;
+              pnr = i;
+              stab = -x;
             }
-         }
-         else
-            upd.clearNum(j);
+          }
+        } else {
+          MSG_DEBUG(std::cout << "DHARRI01 removing value " << pupd[i]
+                              << std::endl;)
+          pupd.clearNum(j);
+        }
       }
-   }
 
+      for (j = cupd.size() - 1; j >= 0; --j) {
+        i = cupd.index(j);
+        x = cupd[i];
 
-   else if(max < -epsilon)
-   {
-      // phase 1:
-      minDelta(
-         &maxabs,             /* max abs value in upd */
-         &max,                /* initial and chosen value */
-         upd.size(),          /* # of indices in upd */
-         upd.indexMem(),      /* nonzero indices in upd */
-         upd.values(),        /* update VectorBase<R> for vec */
-         vec.get_const_ptr(),                 /* current VectorBase<R> */
-         low.get_const_ptr(),                 /* lower bounds for vec */
-         up.get_const_ptr(),                  /* upper bounds for vec */
-         epsilon);             /* what is 0? */
-
-      if(max == val)
-         return -1;
-
-      // phase 2:
-      stab = 0;
-      sel = R(infinity);
-      useeps = maxabs * epsilon * 0.001;
+        if (x > cuseeps) {
+          y = ucb[i] - cvec[i];
 
-      if(useeps < epsilon)
-         useeps = epsilon;
+          if (y < -degeneps)
+            this->solver()->shiftUCbound(i, cvec[i] - degeneps);
+          else {
+            y /= x;
 
-      for(j = upd.size() - 1; j >= 0; --j)
-      {
-         i = upd.index(j);
-         x = upd[i];
+            if (y <= max && x >= stab) // &&  y > sel-epsilon
+            {
+              enterId = this->solver()->coId(i);
+              sel = y;
+              cnr = j;
+              stab = x;
+            }
+          }
+        } else if (x < -cuseeps) {
+          y = lcb[i] - cvec[i];
 
-         if(x < -useeps)
-         {
-            y = up[i] - vec[i];
+          if (y > degeneps)
+            this->solver()->shiftLCbound(i, cvec[i] + degeneps);
+          else {
+            y /= x;
 
-            if(y < -degeneps)
-               this->solver()->shiftUBbound(i, vec[i]);   // ensure simplex improvement
-            else
+            if (y <= max && -x >= stab) // &&  y > sel-epsilon
             {
-               y /= x;
-
-               if(y >= max && y < sel + epsilon && -x > stab)
-               {
-                  sel = y;
-                  leave = i;
-                  stab = -x;
-               }
+              enterId = this->solver()->coId(i);
+              sel = y;
+              cnr = j;
+              stab = -x;
             }
-         }
-         else if(x > useeps)
-         {
-            y = low[i] - vec[i];
-
-            if(y > degeneps)
-               this->solver()->shiftLBbound(i, vec[i]); // ensure simplex improvement
-            else
-            {
-               y /= x;
-
-               if(y >= max && y < sel + epsilon && x > stab)
-               {
-                  sel = y;
-                  leave = i;
-                  stab = x;
-               }
+          }
+        } else {
+          MSG_DEBUG(std::cout << "DHARRI02 removing value " << cupd[i]
+                              << std::endl;)
+          cupd.clearNum(j);
+        }
+      }
+
+      if (lastshift == this->solver()->shift()) {
+        if (cnr >= 0) {
+          if (this->solver()->isBasic(enterId)) {
+            cupd.clearNum(cnr);
+            continue;
+          } else
+            break;
+        } else if (pnr >= 0) {
+          pvec[pnr] = this->solver()->vector(pnr) * cvec;
+
+          if (this->solver()->isBasic(enterId)) {
+            pupd.setValue(pnr, 0.0);
+            continue;
+          } else {
+            x = pupd[pnr];
+
+            if (x > 0) {
+              sel = upb[pnr] - pvec[pnr];
+
+              if (x < minStability && sel < this->delta) {
+                minStability /= 2.0;
+                this->solver()->shiftUPbound(pnr, pvec[pnr]);
+                continue;
+              }
+            } else {
+              sel = lpb[pnr] - pvec[pnr];
+
+              if (-x < minStability && -sel < this->delta) {
+                minStability /= 2.0;
+                this->solver()->shiftLPbound(pnr, pvec[pnr]);
+                continue;
+              }
             }
-         }
-         else
-            upd.clearNum(j);
+
+            sel /= x;
+          }
+        } else {
+          val = 0;
+          enterId.inValidate();
+          return enterId;
+        }
+
+        if (sel > max) // instability detected => recompute
+          continue;    // ratio test with corrected value
+
+        break;
       }
-   }
+    }
+  } else if (val < -epsilon) {
+    for (;;) {
+      pnr = -1;
+      cnr = -1;
+      max = val;
+      lastshift = this->solver()->shift();
+      assert(this->delta > epsilon);
 
-   else
-      return -1;
+      // phase 1:
+      minDelta(&rmaxabs,             /* max abs value in upd */
+               &max,                 /* initial and chosen value */
+               pupd.size(),          /* # of indices in pupd */
+               pupd.indexMem(),      /* nonzero indices in pupd */
+               pupd.values(),        /* update VectorBase<R> for vec */
+               pvec.get_const_ptr(), /* current VectorBase<R> */
+               lpb.get_const_ptr(),  /* lower bounds for vec */
+               upb.get_const_ptr(),  /* upper bounds for vec */
+               epsilon);             /* what is 0? */
+
+      minDelta(&cmaxabs,             /* max abs value in upd */
+               &max,                 /* initial and chosen value */
+               cupd.size(),          /* # of indices in cupd */
+               cupd.indexMem(),      /* nonzero indices in cupd */
+               cupd.values(),        /* update VectorBase<R> for vec */
+               cvec.get_const_ptr(), /* current VectorBase<R> */
+               lcb.get_const_ptr(),  /* lower bounds for vec */
+               ucb.get_const_ptr(),  /* upper bounds for vec */
+               epsilon);             /* what is 0? */
+
+      if (max == val)
+        return enterId;
 
+      // phase 2:
+      stab = 0;
+      sel = R(infinity);
+      ruseeps = rmaxabs * epsilon * 0.001;
+      cuseeps = cmaxabs * epsilon * 0.001;
 
-   if(lastshift != this->solver()->shift())
-      return selectLeave(val, 0, false);
+      for (j = pupd.size() - 1; j >= 0; --j) {
+        i = pupd.index(j);
+        x = pupd[i];
 
-   assert(leave >= 0);
+        if (x > ruseeps) {
+          y = lpb[i] - pvec[i];
 
-   val = sel;
-   return leave;
-}
+          if (y > degeneps)
+            this->solver()->shiftLPbound(i,
+                                         pvec[i]); // ensure simplex improvement
+          else {
+            y /= x;
 
-template <class R>
-SPxId SPxHarrisRT<R>::selectEnter(R& val, int, bool)
-{
-   int i, j;
-   SPxId enterId;
-   R stab, x, y;
-   R max = 0.0;
-   R sel = 0.0;
-   R lastshift;
-   R cuseeps;
-   R ruseeps;
-   R cmaxabs = 1;
-   R rmaxabs = 1;
-   int pnr, cnr;
-
-   R minStability = 0.0001;
-   R epsilon      = this->solver()->epsilon();
-   R degeneps     = degenerateEps();
-
-   VectorBase<R>& pvec = this->solver()->pVec();
-   SSVectorBase<R>& pupd = this->solver()->pVec().delta();
-
-   VectorBase<R>& cvec = this->solver()->coPvec();
-   SSVectorBase<R>& cupd = this->solver()->coPvec().delta();
-
-   const VectorBase<R>& upb = this->solver()->upBound();
-   const VectorBase<R>& lpb = this->solver()->lpBound();
-   const VectorBase<R>& ucb = this->solver()->ucBound();
-   const VectorBase<R>& lcb = this->solver()->lcBound();
-
-   assert(this->delta > epsilon);
-   assert(epsilon > 0);
-   assert(this->solver()->maxCycle() > 0);
-
-   this->solver()->coPvec().delta().setup();
-   this->solver()->pVec().delta().setup();
-
-   if(val > epsilon)
-   {
-      for(;;)
-      {
-         pnr = -1;
-         cnr = -1;
-         max = val;
-         lastshift = this->solver()->shift();
-         assert(this->delta > epsilon);
-
-         // phase 1:
-         maxDelta(
-            &rmaxabs,            /* max abs value in upd */
-            &max,                /* initial and chosen value */
-            pupd.size(),         /* # of indices in pupd */
-            pupd.indexMem(),     /* nonzero indices in pupd */
-            pupd.values(),       /* update VectorBase<R> for vec */
-            pvec.get_const_ptr(),                /* current VectorBase<R> */
-            lpb.get_const_ptr(),                 /* lower bounds for vec */
-            upb.get_const_ptr(),                 /* upper bounds for vec */
-            epsilon);             /* what is 0? */
-
-         maxDelta(
-            &cmaxabs,            /* max abs value in upd */
-            &max,                /* initial and chosen value */
-            cupd.size(),         /* # of indices in cupd */
-            cupd.indexMem(),     /* nonzero indices in cupd */
-            cupd.values(),       /* update VectorBase<R> for vec */
-            cvec.get_const_ptr(),                /* current VectorBase<R> */
-            lcb.get_const_ptr(),                 /* lower bounds for vec */
-            ucb.get_const_ptr(),                 /* upper bounds for vec */
-            epsilon);            /* what is 0? */
-
-         if(max == val)
-            return enterId;
-
-
-         // phase 2:
-         stab = 0;
-         sel = R(-infinity);
-         ruseeps = rmaxabs * 0.001 * epsilon;
-
-         if(ruseeps < epsilon)
-            ruseeps = epsilon;
-
-         cuseeps = cmaxabs * 0.001 * epsilon;
-
-         if(cuseeps < epsilon)
-            cuseeps = epsilon;
-
-         for(j = pupd.size() - 1; j >= 0; --j)
-         {
-            i = pupd.index(j);
-            x = pupd[i];
-
-            if(x > ruseeps)
-            {
-               y = upb[i] - pvec[i];
-
-               if(y < -degeneps)
-                  this->solver()->shiftUPbound(i, pvec[i] - degeneps);
-               else
-               {
-                  y /= x;
-
-                  if(y <= max && x >= stab)        // &&  y > sel-epsilon
-                  {
-                     enterId = this->solver()->id(i);
-                     sel = y;
-                     pnr = i;
-                     stab = x;
-                  }
-               }
-            }
-            else if(x < -ruseeps)
+            if (y >= max && x > stab) // &&  y < sel+epsilon
             {
-               y = lpb[i] - pvec[i];
-
-               if(y > degeneps)
-                  this->solver()->shiftLPbound(i, pvec[i] + degeneps);
-               else
-               {
-                  y /= x;
-
-                  if(y <= max && -x >= stab)       // &&  y > sel-epsilon
-                  {
-                     enterId = this->solver()->id(i);
-                     sel = y;
-                     pnr = i;
-                     stab = -x;
-                  }
-               }
+              enterId = this->solver()->id(i);
+              sel = y;
+              pnr = i;
+              stab = x;
             }
-            else
-            {
-               MSG_DEBUG(std::cout << "DHARRI01 removing value " << pupd[i] << std::endl;)
-               pupd.clearNum(j);
-            }
-         }
+          }
+        } else if (x < -ruseeps) {
+          y = upb[i] - pvec[i];
 
-         for(j = cupd.size() - 1; j >= 0; --j)
-         {
-            i = cupd.index(j);
-            x = cupd[i];
+          if (y < -degeneps)
+            this->solver()->shiftUPbound(i,
+                                         pvec[i]); // ensure simplex improvement
+          else {
+            y /= x;
 
-            if(x > cuseeps)
-            {
-               y = ucb[i] - cvec[i];
-
-               if(y < -degeneps)
-                  this->solver()->shiftUCbound(i, cvec[i] - degeneps);
-               else
-               {
-                  y /= x;
-
-                  if(y <= max && x >= stab)        // &&  y > sel-epsilon
-                  {
-                     enterId = this->solver()->coId(i);
-                     sel = y;
-                     cnr = j;
-                     stab = x;
-                  }
-               }
-            }
-            else if(x < -cuseeps)
-            {
-               y = lcb[i] - cvec[i];
-
-               if(y > degeneps)
-                  this->solver()->shiftLCbound(i, cvec[i] + degeneps);
-               else
-               {
-                  y /= x;
-
-                  if(y <= max && -x >= stab)       // &&  y > sel-epsilon
-                  {
-                     enterId = this->solver()->coId(i);
-                     sel = y;
-                     cnr = j;
-                     stab = -x;
-                  }
-               }
-            }
-            else
+            if (y >= max && -x > stab) // &&  y < sel+epsilon
             {
-               MSG_DEBUG(std::cout << "DHARRI02 removing value " << cupd[i] << std::endl;)
-               cupd.clearNum(j);
+              enterId = this->solver()->id(i);
+              sel = y;
+              pnr = i;
+              stab = -x;
             }
-         }
+          }
+        } else {
+          MSG_DEBUG(std::cout << "DHARRI03 removing value " << pupd[i]
+                              << std::endl;)
+          pupd.clearNum(j);
+        }
+      }
 
-         if(lastshift == this->solver()->shift())
-         {
-            if(cnr >= 0)
-            {
-               if(this->solver()->isBasic(enterId))
-               {
-                  cupd.clearNum(cnr);
-                  continue;
-               }
-               else
-                  break;
-            }
-            else if(pnr >= 0)
-            {
-               pvec[pnr] = this->solver()->vector(pnr) * cvec;
-
-               if(this->solver()->isBasic(enterId))
-               {
-                  pupd.setValue(pnr, 0.0);
-                  continue;
-               }
-               else
-               {
-                  x = pupd[pnr];
-
-                  if(x > 0)
-                  {
-                     sel = upb[pnr] - pvec[pnr];
-
-                     if(x < minStability && sel < this->delta)
-                     {
-                        minStability /= 2.0;
-                        this->solver()->shiftUPbound(pnr, pvec[pnr]);
-                        continue;
-                     }
-                  }
-                  else
-                  {
-                     sel = lpb[pnr] - pvec[pnr];
-
-                     if(-x < minStability && -sel < this->delta)
-                     {
-                        minStability /= 2.0;
-                        this->solver()->shiftLPbound(pnr, pvec[pnr]);
-                        continue;
-                     }
-                  }
-
-                  sel /= x;
-               }
-            }
-            else
-            {
-               val = 0;
-               enterId.inValidate();
-               return enterId;
-            }
+      for (j = cupd.size() - 1; j >= 0; --j) {
+        i = cupd.index(j);
+        x = cupd[i];
 
-            if(sel > max)              // instability detected => recompute
-               continue;               // ratio test with corrected value
+        if (x > cuseeps) {
+          y = lcb[i] - cvec[i];
 
-            break;
-         }
-      }
-   }
-   else if(val < -epsilon)
-   {
-      for(;;)
-      {
-         pnr = -1;
-         cnr = -1;
-         max = val;
-         lastshift = this->solver()->shift();
-         assert(this->delta > epsilon);
-
-
-         // phase 1:
-         minDelta
-         (
-            &rmaxabs,            /* max abs value in upd */
-            &max,                /* initial and chosen value */
-            pupd.size(),         /* # of indices in pupd */
-            pupd.indexMem(),     /* nonzero indices in pupd */
-            pupd.values(),       /* update VectorBase<R> for vec */
-            pvec.get_const_ptr(),                /* current VectorBase<R> */
-            lpb.get_const_ptr(),                 /* lower bounds for vec */
-            upb.get_const_ptr(),                 /* upper bounds for vec */
-            epsilon);             /* what is 0? */
-
-         minDelta
-         (
-            &cmaxabs,            /* max abs value in upd */
-            &max,                /* initial and chosen value */
-            cupd.size(),         /* # of indices in cupd */
-            cupd.indexMem(),     /* nonzero indices in cupd */
-            cupd.values(),       /* update VectorBase<R> for vec */
-            cvec.get_const_ptr(),                /* current VectorBase<R> */
-            lcb.get_const_ptr(),                 /* lower bounds for vec */
-            ucb.get_const_ptr(),                 /* upper bounds for vec */
-            epsilon);             /* what is 0? */
-
-         if(max == val)
-            return enterId;
-
-
-         // phase 2:
-         stab = 0;
-         sel = R(infinity);
-         ruseeps = rmaxabs * epsilon * 0.001;
-         cuseeps = cmaxabs * epsilon * 0.001;
-
-         for(j = pupd.size() - 1; j >= 0; --j)
-         {
-            i = pupd.index(j);
-            x = pupd[i];
-
-            if(x > ruseeps)
-            {
-               y = lpb[i] - pvec[i];
-
-               if(y > degeneps)
-                  this->solver()->shiftLPbound(i, pvec[i]);  // ensure simplex improvement
-               else
-               {
-                  y /= x;
-
-                  if(y >= max && x > stab)         // &&  y < sel+epsilon
-                  {
-                     enterId = this->solver()->id(i);
-                     sel = y;
-                     pnr = i;
-                     stab = x;
-                  }
-               }
-            }
-            else if(x < -ruseeps)
-            {
-               y = upb[i] - pvec[i];
-
-               if(y < -degeneps)
-                  this->solver()->shiftUPbound(i, pvec[i]);  // ensure simplex improvement
-               else
-               {
-                  y /= x;
-
-                  if(y >= max && -x > stab)        // &&  y < sel+epsilon
-                  {
-                     enterId = this->solver()->id(i);
-                     sel = y;
-                     pnr = i;
-                     stab = -x;
-                  }
-               }
-            }
-            else
+          if (y > degeneps)
+            this->solver()->shiftLCbound(i,
+                                         cvec[i]); // ensure simplex improvement
+          else {
+            y /= x;
+
+            if (y >= max && x > stab) // &&  y < sel+epsilon
             {
-               MSG_DEBUG(std::cout << "DHARRI03 removing value " << pupd[i] << std::endl;)
-               pupd.clearNum(j);
+              enterId = this->solver()->coId(i);
+              sel = y;
+              cnr = j;
+              stab = x;
             }
-         }
+          }
+        } else if (x < -cuseeps) {
+          y = ucb[i] - cvec[i];
 
-         for(j = cupd.size() - 1; j >= 0; --j)
-         {
-            i = cupd.index(j);
-            x = cupd[i];
+          if (y < -degeneps)
+            this->solver()->shiftUCbound(i,
+                                         cvec[i]); // ensure simplex improvement
+          else {
+            y /= x;
 
-            if(x > cuseeps)
-            {
-               y = lcb[i] - cvec[i];
-
-               if(y > degeneps)
-                  this->solver()->shiftLCbound(i, cvec[i]);  // ensure simplex improvement
-               else
-               {
-                  y /= x;
-
-                  if(y >= max && x > stab)         // &&  y < sel+epsilon
-                  {
-                     enterId = this->solver()->coId(i);
-                     sel = y;
-                     cnr = j;
-                     stab = x;
-                  }
-               }
-            }
-            else if(x < -cuseeps)
+            if (y >= max && -x > stab) // &&  y < sel+epsilon
             {
-               y = ucb[i] - cvec[i];
-
-               if(y < -degeneps)
-                  this->solver()->shiftUCbound(i, cvec[i]);  // ensure simplex improvement
-               else
-               {
-                  y /= x;
-
-                  if(y >= max && -x > stab)        // &&  y < sel+epsilon
-                  {
-                     enterId = this->solver()->coId(i);
-                     sel = y;
-                     cnr = j;
-                     stab = -x;
-                  }
-               }
+              enterId = this->solver()->coId(i);
+              sel = y;
+              cnr = j;
+              stab = -x;
             }
-            else
-            {
-               MSG_DEBUG(std::cout << "DHARRI04 removing value " << x << std::endl;);
-               cupd.clearNum(j);
-            }
-         }
+          }
+        } else {
+          MSG_DEBUG(std::cout << "DHARRI04 removing value " << x << std::endl;);
+          cupd.clearNum(j);
+        }
+      }
 
-         if(lastshift == this->solver()->shift())
-         {
-            if(cnr >= 0)
-            {
-               if(this->solver()->isBasic(enterId))
-               {
-                  cupd.clearNum(cnr);
-                  continue;
-               }
-               else
-                  break;
-            }
-            else if(pnr >= 0)
-            {
-               pvec[pnr] = this->solver()->vector(pnr) * cvec;
-
-               if(this->solver()->isBasic(enterId))
-               {
-                  pupd.setValue(pnr, 0.0);
-                  continue;
-               }
-               else
-               {
-                  x = pupd[pnr];
-
-                  if(x > 0)
-                  {
-                     sel = lpb[pnr] - pvec[pnr];
-
-                     if(x < minStability && -sel < this->delta)
-                     {
-                        minStability /= 2;
-                        this->solver()->shiftLPbound(pnr, pvec[pnr]);
-                        continue;
-                     }
-                  }
-                  else
-                  {
-                     sel = upb[pnr] - pvec[pnr];
-
-                     if(-x < minStability && sel < this->delta)
-                     {
-                        minStability /= 2;
-                        this->solver()->shiftUPbound(pnr, pvec[pnr]);
-                        continue;
-                     }
-                  }
-
-                  sel /= x;
-               }
-            }
-            else
-            {
-               val = 0;
-               enterId.inValidate();
-               return enterId;
+      if (lastshift == this->solver()->shift()) {
+        if (cnr >= 0) {
+          if (this->solver()->isBasic(enterId)) {
+            cupd.clearNum(cnr);
+            continue;
+          } else
+            break;
+        } else if (pnr >= 0) {
+          pvec[pnr] = this->solver()->vector(pnr) * cvec;
+
+          if (this->solver()->isBasic(enterId)) {
+            pupd.setValue(pnr, 0.0);
+            continue;
+          } else {
+            x = pupd[pnr];
+
+            if (x > 0) {
+              sel = lpb[pnr] - pvec[pnr];
+
+              if (x < minStability && -sel < this->delta) {
+                minStability /= 2;
+                this->solver()->shiftLPbound(pnr, pvec[pnr]);
+                continue;
+              }
+            } else {
+              sel = upb[pnr] - pvec[pnr];
+
+              if (-x < minStability && sel < this->delta) {
+                minStability /= 2;
+                this->solver()->shiftUPbound(pnr, pvec[pnr]);
+                continue;
+              }
             }
 
-            if(sel < max)              // instability detected => recompute
-               continue;               // ratio test with corrected value
+            sel /= x;
+          }
+        } else {
+          val = 0;
+          enterId.inValidate();
+          return enterId;
+        }
 
-            break;
-         }
+        if (sel < max) // instability detected => recompute
+          continue;    // ratio test with corrected value
+
+        break;
       }
-   }
+    }
+  }
 
-   assert(max * val >= 0);
-   assert(enterId.type() != SPxId::INVALID);
+  assert(max * val >= 0);
+  assert(enterId.type() != SPxId::INVALID);
 
-   val = sel;
+  val = sel;
 
-   return enterId;
+  return enterId;
 }
 } // namespace soplex
diff --git a/src/soplex/spxhybridpr.hpp b/src/soplex/spxhybridpr.hpp
index 4003ca1..45ab361 100644
--- a/src/soplex/spxhybridpr.hpp
+++ b/src/soplex/spxhybridpr.hpp
@@ -21,139 +21,109 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <iostream>
 
 #include "soplex/spxdefines.h"
 #include "soplex/spxout.h"
 
-namespace soplex
-{
-template <class R>
-bool SPxHybridPR<R>::isConsistent() const
-{
+namespace soplex {
+template <class R> bool SPxHybridPR<R>::isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
 
-   if(this->thesolver != 0 &&
-         (this->thesolver != steep.solver() ||
-          this->thesolver != devex.solver() ||
-          this->thesolver != parmult.solver()))
-      return MSGinconsistent("SPxHybridPR");
+  if (this->thesolver != 0 &&
+      (this->thesolver != steep.solver() || this->thesolver != devex.solver() ||
+       this->thesolver != parmult.solver()))
+    return MSGinconsistent("SPxHybridPR");
 
-   return steep.isConsistent()
-          && devex.isConsistent()
-          && parmult.isConsistent();
+  return steep.isConsistent() && devex.isConsistent() && parmult.isConsistent();
 #else
-   return true;
+  return true;
 #endif
 }
 
-template <class R>
-void SPxHybridPR<R>::load(SPxSolverBase<R>* p_solver)
-{
-   steep.load(p_solver);
-   devex.load(p_solver);
-   parmult.load(p_solver);
-   this->thesolver = p_solver;
-   setType(p_solver->type());
+template <class R> void SPxHybridPR<R>::load(SPxSolverBase<R> *p_solver) {
+  steep.load(p_solver);
+  devex.load(p_solver);
+  parmult.load(p_solver);
+  this->thesolver = p_solver;
+  setType(p_solver->type());
 }
 
-template <class R>
-void SPxHybridPR<R>::clear()
-{
-   steep.clear();
-   devex.clear();
-   parmult.clear();
-   this->thesolver = 0;
+template <class R> void SPxHybridPR<R>::clear() {
+  steep.clear();
+  devex.clear();
+  parmult.clear();
+  this->thesolver = 0;
 }
 
-template <class R>
-void SPxHybridPR<R>::setEpsilon(R eps)
-{
-   steep.setEpsilon(eps);
-   devex.setEpsilon(eps);
-   parmult.setEpsilon(eps);
+template <class R> void SPxHybridPR<R>::setEpsilon(R eps) {
+  steep.setEpsilon(eps);
+  devex.setEpsilon(eps);
+  parmult.setEpsilon(eps);
 }
 
 template <class R>
-void SPxHybridPR<R>::setType(typename SPxSolverBase<R>::Type tp)
-{
-   if(tp == SPxSolverBase<R>::LEAVE)
-   {
+void SPxHybridPR<R>::setType(typename SPxSolverBase<R>::Type tp) {
+  if (tp == SPxSolverBase<R>::LEAVE) {
+    thepricer = &steep;
+    this->thesolver->setPricing(SPxSolverBase<R>::FULL);
+  } else {
+    if (this->thesolver->dim() > hybridFactor * this->thesolver->coDim()) {
+      /**@todo I changed from devex to steepest edge pricing here
+       *       because of numerical difficulties, this should be
+       *       investigated.
+       */
+      // thepricer = &devex;
       thepricer = &steep;
       this->thesolver->setPricing(SPxSolverBase<R>::FULL);
-   }
-   else
-   {
-      if(this->thesolver->dim() > hybridFactor * this->thesolver->coDim())
-      {
-         /**@todo I changed from devex to steepest edge pricing here
-          *       because of numerical difficulties, this should be
-          *       investigated.
-          */
-         // thepricer = &devex;
-         thepricer = &steep;
-         this->thesolver->setPricing(SPxSolverBase<R>::FULL);
-      }
-      else
-      {
-         thepricer = &parmult;
-         this->thesolver->setPricing(SPxSolverBase<R>::PARTIAL);
-      }
-   }
-
-   MSG_INFO1((*this->thesolver->spxout), (*this->thesolver->spxout) << "IPRHYB01 switching to "
-             << thepricer->getName() << std::endl;)
-
-   thepricer->setType(tp);
+    } else {
+      thepricer = &parmult;
+      this->thesolver->setPricing(SPxSolverBase<R>::PARTIAL);
+    }
+  }
+
+  MSG_INFO1((*this->thesolver->spxout),
+            (*this->thesolver->spxout) << "IPRHYB01 switching to "
+                                       << thepricer->getName() << std::endl;)
+
+  thepricer->setType(tp);
 }
 
 template <class R>
-void SPxHybridPR<R>::setRep(typename SPxSolverBase<R>::Representation rep)
-{
-   steep.setRep(rep);
-   devex.setRep(rep);
-   parmult.setRep(rep);
+void SPxHybridPR<R>::setRep(typename SPxSolverBase<R>::Representation rep) {
+  steep.setRep(rep);
+  devex.setRep(rep);
+  parmult.setRep(rep);
 }
 
-template <class R>
-int SPxHybridPR<R>::selectLeave()
-{
-   return thepricer->selectLeave();
+template <class R> int SPxHybridPR<R>::selectLeave() {
+  return thepricer->selectLeave();
 }
 
-template <class R>
-void SPxHybridPR<R>::left4(int n, SPxId id)
-{
-   thepricer->left4(n, id);
+template <class R> void SPxHybridPR<R>::left4(int n, SPxId id) {
+  thepricer->left4(n, id);
 }
 
-template <class R>
-SPxId SPxHybridPR<R>::selectEnter()
-{
-   return thepricer->selectEnter();
+template <class R> SPxId SPxHybridPR<R>::selectEnter() {
+  return thepricer->selectEnter();
 }
 
-template <class R>
-void SPxHybridPR<R>::entered4(SPxId id, int n)
-{
-   thepricer->entered4(id, n);
+template <class R> void SPxHybridPR<R>::entered4(SPxId id, int n) {
+  thepricer->entered4(id, n);
 }
 
-template <class R>
-void SPxHybridPR<R>::addedVecs(int n)
-{
-   steep.addedVecs(n);
-   devex.addedVecs(n);
-   parmult.addedVecs(n);
+template <class R> void SPxHybridPR<R>::addedVecs(int n) {
+  steep.addedVecs(n);
+  devex.addedVecs(n);
+  parmult.addedVecs(n);
 }
 
-template <class R>
-void SPxHybridPR<R>::addedCoVecs(int n)
-{
-   steep.addedCoVecs(n);
-   devex.addedCoVecs(n);
-   parmult.addedCoVecs(n);
+template <class R> void SPxHybridPR<R>::addedCoVecs(int n) {
+  steep.addedCoVecs(n);
+  devex.addedCoVecs(n);
+  parmult.addedCoVecs(n);
 }
 
 } // namespace soplex
diff --git a/src/soplex/spxleastsqsc.hpp b/src/soplex/spxleastsqsc.hpp
index 62ef0f3..9a3448d 100644
--- a/src/soplex/spxleastsqsc.hpp
+++ b/src/soplex/spxleastsqsc.hpp
@@ -21,415 +21,379 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 /**@file  spxleastsqsc.hpp
  * @brief LP least squares scaling.
  */
 
-#include <assert.h>
-#include <cmath>
-#include "soplex/spxout.h"
 #include "soplex/basevectors.h"
-#include "soplex/svsetbase.h"
-#include "soplex/svectorbase.h"
+#include "soplex/spxout.h"
 #include "soplex/ssvectorbase.h"
+#include "soplex/svectorbase.h"
+#include "soplex/svsetbase.h"
 #include <array>
+#include <assert.h>
+#include <cmath>
 
-namespace soplex
-{
+namespace soplex {
 
 /* update scaling VectorBase<R> */
 template <class R>
-static void updateScale(
-   const SSVectorBase<R> vecnnzeroes,
-   const SSVectorBase<R> resnvec,
-   SSVectorBase<R>& tmpvec,
-   SSVectorBase<R>*& psccurr,
-   SSVectorBase<R>*& pscprev,
-   R qcurr,
-   R qprev,
-   R eprev1,
-   R eprev2)
-{
-   assert(psccurr != NULL);
-   assert(pscprev != NULL);
-   assert(qcurr * qprev != 0.0);
-
-   R fac = -(eprev1 * eprev2);
-
-   SSVectorBase<R>* pssv;
-
-   *pscprev -= *psccurr;
-
-   if(isZero(fac))
-      (*pscprev).clear();
-   else
-      *pscprev *= fac;
-
-   *pscprev += tmpvec.assignPWproduct4setup(resnvec, vecnnzeroes);
-
-   *pscprev *= 1.0 / (qcurr * qprev);
-   *pscprev += *psccurr;
-
-   /* swap pointers */
-   pssv = psccurr;
-   psccurr = pscprev;
-   pscprev = pssv;
+static void updateScale(const SSVectorBase<R> vecnnzeroes,
+                        const SSVectorBase<R> resnvec, SSVectorBase<R> &tmpvec,
+                        SSVectorBase<R> *&psccurr, SSVectorBase<R> *&pscprev,
+                        R qcurr, R qprev, R eprev1, R eprev2) {
+  assert(psccurr != NULL);
+  assert(pscprev != NULL);
+  assert(qcurr * qprev != 0.0);
+
+  R fac = -(eprev1 * eprev2);
+
+  SSVectorBase<R> *pssv;
+
+  *pscprev -= *psccurr;
+
+  if (isZero(fac))
+    (*pscprev).clear();
+  else
+    *pscprev *= fac;
+
+  *pscprev += tmpvec.assignPWproduct4setup(resnvec, vecnnzeroes);
+
+  *pscprev *= 1.0 / (qcurr * qprev);
+  *pscprev += *psccurr;
+
+  /* swap pointers */
+  pssv = psccurr;
+  psccurr = pscprev;
+  pscprev = pssv;
 }
 
 /* update scaling VectorBase<R> after main loop */
 template <class R>
-static void updateScaleFinal(
-   const SSVectorBase<R> vecnnzeroes,
-   const SSVectorBase<R> resnvec,
-   SSVectorBase<R>& tmpvec,
-   SSVectorBase<R>*& psccurr,
-   SSVectorBase<R>*& pscprev,
-   R q,
-   R eprev1,
-   R eprev2)
-{
-   assert(q != 0);
-   assert(psccurr != NULL);
-   assert(pscprev != NULL);
-
-   R fac = -(eprev1 * eprev2);
-
-   *pscprev -= *psccurr;
-
-   if(isZero(fac))
-      (*pscprev).clear();
-   else
-      *pscprev *= fac;
-
-   *pscprev += tmpvec.assignPWproduct4setup(resnvec, vecnnzeroes);
-   *pscprev *= 1.0 / q;
-   *pscprev += *psccurr;
-
-   psccurr = pscprev;
+static void updateScaleFinal(const SSVectorBase<R> vecnnzeroes,
+                             const SSVectorBase<R> resnvec,
+                             SSVectorBase<R> &tmpvec, SSVectorBase<R> *&psccurr,
+                             SSVectorBase<R> *&pscprev, R q, R eprev1,
+                             R eprev2) {
+  assert(q != 0);
+  assert(psccurr != NULL);
+  assert(pscprev != NULL);
+
+  R fac = -(eprev1 * eprev2);
+
+  *pscprev -= *psccurr;
+
+  if (isZero(fac))
+    (*pscprev).clear();
+  else
+    *pscprev *= fac;
+
+  *pscprev += tmpvec.assignPWproduct4setup(resnvec, vecnnzeroes);
+  *pscprev *= 1.0 / q;
+  *pscprev += *psccurr;
+
+  psccurr = pscprev;
 }
 
 /* update residual VectorBase<R> */
 template <class R>
-static inline void updateRes(
-   const SVSetBase<R> facset,
-   const SSVectorBase<R> resvecprev,
-   SSVectorBase<R>& resvec,
-   SSVectorBase<R>& tmpvec,
-   R eprev,
-   R qcurr)
-{
-   assert(qcurr != 0.0);
-
-   if(isZero(eprev))
-      resvec.clear();
-   else
-      resvec *= eprev;
-
-   int dummy1 = 0;
-   int dummy2 = 0;
-   tmpvec.assign2product4setup(facset, resvecprev, 0, 0, dummy1, dummy2);
-   tmpvec.setup();
-   resvec += tmpvec;
-
-   resvec *= (-1.0 / qcurr);
-   resvec.setup();
+static inline void
+updateRes(const SVSetBase<R> facset, const SSVectorBase<R> resvecprev,
+          SSVectorBase<R> &resvec, SSVectorBase<R> &tmpvec, R eprev, R qcurr) {
+  assert(qcurr != 0.0);
+
+  if (isZero(eprev))
+    resvec.clear();
+  else
+    resvec *= eprev;
+
+  int dummy1 = 0;
+  int dummy2 = 0;
+  tmpvec.assign2product4setup(facset, resvecprev, 0, 0, dummy1, dummy2);
+  tmpvec.setup();
+  resvec += tmpvec;
+
+  resvec *= (-1.0 / qcurr);
+  resvec.setup();
 }
 
-
 /* initialize constant vectors and matrices */
 template <class R>
-static void initConstVecs(
-   const SVSetBase<R>* vecset,
-   SVSetBase<R>& facset,
-   SSVectorBase<R>& veclogs,
-   SSVectorBase<R>& vecnnzinv)
-{
-   assert(vecset != NULL);
-
-   const int nvec = vecset->num();
-
-   for(int k = 0; k < nvec; ++k)
-   {
-      R logsum = 0.0;
-      int nnz = 0;
-      // get kth row or column of LP
-      const SVectorBase<R>& lpvec = (*vecset)[k];
-      const int size = lpvec.size();
-
-      for(int i = 0; i < size; ++i)
-      {
-         const R a = lpvec.value(i);
-
-         if(!isZero(a))
-         {
-            logsum += log2(double(spxAbs(a))); // todo spxLog2?
-            nnz++;
-         }
+static void initConstVecs(const SVSetBase<R> *vecset, SVSetBase<R> &facset,
+                          SSVectorBase<R> &veclogs,
+                          SSVectorBase<R> &vecnnzinv) {
+  assert(vecset != NULL);
+
+  const int nvec = vecset->num();
+
+  for (int k = 0; k < nvec; ++k) {
+    R logsum = 0.0;
+    int nnz = 0;
+    // get kth row or column of LP
+    const SVectorBase<R> &lpvec = (*vecset)[k];
+    const int size = lpvec.size();
+
+    for (int i = 0; i < size; ++i) {
+      const R a = lpvec.value(i);
+
+      if (!isZero(a)) {
+        logsum += log2(double(spxAbs(a))); // todo spxLog2?
+        nnz++;
       }
+    }
 
-      R nnzinv;
+    R nnzinv;
 
-      if(nnz > 0)
-      {
-         nnzinv = 1.0 / nnz;
-      }
-      else
-      {
-         /* all-0 entries */
-         logsum = 1.0;
-         nnzinv = 1.0;
-      }
+    if (nnz > 0) {
+      nnzinv = 1.0 / nnz;
+    } else {
+      /* all-0 entries */
+      logsum = 1.0;
+      nnzinv = 1.0;
+    }
 
-      veclogs.add(k, logsum);
-      vecnnzinv.add(k, nnzinv);
+    veclogs.add(k, logsum);
+    vecnnzinv.add(k, nnzinv);
 
-      /* create new VectorBase<R> for facset */
-      SVectorBase<R>& vecnew = (*(facset.create(nnz)));
+    /* create new VectorBase<R> for facset */
+    SVectorBase<R> &vecnew = (*(facset.create(nnz)));
 
-      for(int i = 0; i < size; ++i)
-      {
-         if(!isZero(lpvec.value(i)))
-            vecnew.add(lpvec.index(i), nnzinv);
-      }
+    for (int i = 0; i < size; ++i) {
+      if (!isZero(lpvec.value(i)))
+        vecnew.add(lpvec.index(i), nnzinv);
+    }
 
-      vecnew.sort();
-   }
+    vecnew.sort();
+  }
 
-   assert(veclogs.isSetup());
-   assert(vecnnzinv.isSetup());
+  assert(veclogs.isSetup());
+  assert(vecnnzinv.isSetup());
 }
 
 /* return name of scaler */
-static inline const char* makename()
-{
-   return "Least squares";
-}
+static inline const char *makename() { return "Least squares"; }
 
 template <class R>
-SPxLeastSqSC<R>::SPxLeastSqSC()
-   : SPxScaler<R>(makename(), false, false)
-{}
+SPxLeastSqSC<R>::SPxLeastSqSC() : SPxScaler<R>(makename(), false, false) {}
 
 template <class R>
-SPxLeastSqSC<R>::SPxLeastSqSC(const SPxLeastSqSC<R>& old)
-   : SPxScaler<R>(old), acrcydivisor(old.acrcydivisor), maxrounds(old.maxrounds)
-{}
+SPxLeastSqSC<R>::SPxLeastSqSC(const SPxLeastSqSC<R> &old)
+    : SPxScaler<R>(old), acrcydivisor(old.acrcydivisor),
+      maxrounds(old.maxrounds) {}
 
 template <class R>
-SPxLeastSqSC<R>& SPxLeastSqSC<R>::operator=(const SPxLeastSqSC<R>& rhs)
-{
-   if(this != &rhs)
-   {
-      SPxScaler<R>::operator=(rhs);
-   }
-
-   return *this;
+SPxLeastSqSC<R> &SPxLeastSqSC<R>::operator=(const SPxLeastSqSC<R> &rhs) {
+  if (this != &rhs) {
+    SPxScaler<R>::operator=(rhs);
+  }
+
+  return *this;
 }
 
 template <class R>
-void SPxLeastSqSC<R>::setRealParam(R param, const char* name)
-{
-   assert(param >= 1.0);
-   acrcydivisor = param;
+void SPxLeastSqSC<R>::setRealParam(R param, const char *name) {
+  assert(param >= 1.0);
+  acrcydivisor = param;
 }
 
 template <class R>
-void SPxLeastSqSC<R>::setIntParam(int param, const char* name)
-{
-   assert(param >= 0);
-   maxrounds = param;
+void SPxLeastSqSC<R>::setIntParam(int param, const char *name) {
+  assert(param >= 0);
+  maxrounds = param;
 }
 
 // todo refactor this method. Has no abstraction and is too long
 template <class R>
-void SPxLeastSqSC<R>::scale(SPxLPBase<R>& lp,  bool persistent)
-{
-   MSG_INFO1((*this->spxout), (*this->spxout) << "Least squares LP scaling" <<
-             (persistent ? " (persistent)" : "") << std::endl;)
-
-   this->setup(lp);
-
-   const int nrows = lp.nRows();
-   const int ncols = lp.nCols();
-   const int lpnnz = lp.nNzos();
-
-   // is contraints matrix empty?
-   //todo don't create the scaler in this case!
-   if(lpnnz == 0)
-   {
-      // to keep the invariants, we still need to call this method
-      this->applyScaling(lp);
-
-      return;
-   }
-
-   assert(nrows > 0 && ncols > 0 && lpnnz > 0);
-
-   /* constant factor matrices;
-    * in Curtis-Reid article
-    * facnrows equals E^T M^(-1)
-    * facncols equals E N^(-1)
-    * */
-   SVSetBase<R> facnrows(nrows, nrows, 1.1, 1.2);
-   SVSetBase<R> facncols(ncols, ncols, 1.1, 1.2);
-
-   /* column scaling factor vectors */
-   SSVectorBase<R> colscale1(ncols);
-   SSVectorBase<R> colscale2(ncols);
-
-   /* row scaling factor vectors */
-   SSVectorBase<R> rowscale1(nrows);
-   SSVectorBase<R> rowscale2(nrows);
-
-   /* residual vectors */
-   SSVectorBase<R> resnrows(nrows);
-   SSVectorBase<R> resncols(ncols);
-
-   /* vectors to store temporary values */
-   SSVectorBase<R> tmprows(nrows);
-   SSVectorBase<R> tmpcols(ncols);
-
-   /* vectors storing the row and column sums (respectively) of logarithms of
-    *(absolute values of) non-zero elements of left hand matrix of LP
-    */
-   SSVectorBase<R> rowlogs(nrows);
-   SSVectorBase<R> collogs(ncols);
-
-   /* vectors storing the inverted number of non-zeros in each row and column
-    *(respectively) of left hand matrix of LP
-    */
-   SSVectorBase<R> rownnzinv(nrows);
-   SSVectorBase<R> colnnzinv(ncols);
-
-   /* VectorBase<R> pointers */
-   SSVectorBase<R>* csccurr = &colscale1;
-   SSVectorBase<R>* cscprev = &colscale2;
-   SSVectorBase<R>* rsccurr = &rowscale1;
-   SSVectorBase<R>* rscprev = &rowscale2;
-
-   MSG_INFO2((*this->spxout), (*this->spxout) << "before scaling:"
-             << " min= " << lp.minAbsNzo()
-             << " max= " << lp.maxAbsNzo()
-             << " col-ratio= " << this->maxColRatio(lp)
-             << " row-ratio= " << this->maxRowRatio(lp)
-             << std::endl;)
-
-   /* initialize scalars, vectors and matrices */
-
-   assert(acrcydivisor > 0.0);
-
-   const R smax = lpnnz / acrcydivisor;
-   R qcurr = 1.0;
-   R qprev = 0.0;
-
-   std::array<R, 3> eprev;
-   eprev.fill(0.0);
-
-   initConstVecs(lp.rowSet(), facnrows, rowlogs, rownnzinv);
-   initConstVecs(lp.colSet(), facncols, collogs, colnnzinv);
-
-   assert(tmprows.isSetup() && tmpcols.isSetup());
-   assert(rowscale1.isSetup() && rowscale2.isSetup());
-   assert(colscale1.isSetup() && colscale2.isSetup());
-
-   // compute first residual vector r0
-   int dummy1 = 0;
-   int dummy2 = 0;
-   resncols = collogs - tmpcols.assign2product4setup(facnrows, rowlogs, 0, 0, dummy1, dummy2);
-
-   resncols.setup();
-   resnrows.setup();
-
-   rowscale1.assignPWproduct4setup(rownnzinv, rowlogs);
-   rowscale2 = rowscale1;
-
-   R scurr = resncols * tmpcols.assignPWproduct4setup(colnnzinv, resncols);
-
-   int k;
-
-   /* conjugate gradient loop */
-   for(k = 0; k < maxrounds; ++k)
-   {
-      const R sprev = scurr;
-
-      // termination criterion met?
-      if(scurr < smax)
-         break;
-
-      // is k even?
-      if((k % 2) == 0)
-      {
-         // not in first iteration?
-         if(k != 0)   // true, then update row scaling factor vector
-            updateScale(rownnzinv, resnrows, tmprows, rsccurr, rscprev, qcurr, qprev, eprev[1], eprev[2]);
-
-         updateRes(facncols, resncols, resnrows, tmprows, eprev[0], qcurr);
-         scurr = resnrows * tmprows.assignPWproduct4setup(resnrows, rownnzinv);
-      }
-      else // k is odd
-      {
-         // update column scaling factor vector
-         updateScale(colnnzinv, resncols, tmpcols, csccurr, cscprev, qcurr, qprev, eprev[1], eprev[2]);
-
-         updateRes(facnrows, resnrows, resncols, tmpcols, eprev[0], qcurr);
-         scurr = resncols * tmpcols.assignPWproduct4setup(resncols, colnnzinv);
-      }
-
-      // shift eprev entries one to the right
-      for(unsigned l = 2; l > 0; --l)
-         eprev[l] = eprev[l - 1];
-
-      assert(isNotZero(sprev));
-
-      eprev[0] = (qcurr * scurr) / sprev;
-
-      const R tmp = qcurr;
-      qcurr = 1.0 - eprev[0];
-      qprev = tmp;
-   }
+void SPxLeastSqSC<R>::scale(SPxLPBase<R> &lp, bool persistent) {
+  MSG_INFO1((*this->spxout), (*this->spxout)
+                                 << "Least squares LP scaling"
+                                 << (persistent ? " (persistent)" : "")
+                                 << std::endl;)
 
-   if(k > 0 && (k % 2) == 0)
-   {
+  this->setup(lp);
+
+  const int nrows = lp.nRows();
+  const int ncols = lp.nCols();
+  const int lpnnz = lp.nNzos();
+
+  // is contraints matrix empty?
+  // todo don't create the scaler in this case!
+  if (lpnnz == 0) {
+    // to keep the invariants, we still need to call this method
+    this->applyScaling(lp);
+
+    return;
+  }
+
+  assert(nrows > 0 && ncols > 0 && lpnnz > 0);
+
+  /* constant factor matrices;
+   * in Curtis-Reid article
+   * facnrows equals E^T M^(-1)
+   * facncols equals E N^(-1)
+   * */
+  SVSetBase<R> facnrows(nrows, nrows, 1.1, 1.2);
+  SVSetBase<R> facncols(ncols, ncols, 1.1, 1.2);
+
+  /* column scaling factor vectors */
+  SSVectorBase<R> colscale1(ncols);
+  SSVectorBase<R> colscale2(ncols);
+
+  /* row scaling factor vectors */
+  SSVectorBase<R> rowscale1(nrows);
+  SSVectorBase<R> rowscale2(nrows);
+
+  /* residual vectors */
+  SSVectorBase<R> resnrows(nrows);
+  SSVectorBase<R> resncols(ncols);
+
+  /* vectors to store temporary values */
+  SSVectorBase<R> tmprows(nrows);
+  SSVectorBase<R> tmpcols(ncols);
+
+  /* vectors storing the row and column sums (respectively) of logarithms of
+   *(absolute values of) non-zero elements of left hand matrix of LP
+   */
+  SSVectorBase<R> rowlogs(nrows);
+  SSVectorBase<R> collogs(ncols);
+
+  /* vectors storing the inverted number of non-zeros in each row and column
+   *(respectively) of left hand matrix of LP
+   */
+  SSVectorBase<R> rownnzinv(nrows);
+  SSVectorBase<R> colnnzinv(ncols);
+
+  /* VectorBase<R> pointers */
+  SSVectorBase<R> *csccurr = &colscale1;
+  SSVectorBase<R> *cscprev = &colscale2;
+  SSVectorBase<R> *rsccurr = &rowscale1;
+  SSVectorBase<R> *rscprev = &rowscale2;
+
+  MSG_INFO2((*this->spxout),
+            (*this->spxout)
+                << "before scaling:"
+                << " min= " << lp.minAbsNzo() << " max= " << lp.maxAbsNzo()
+                << " col-ratio= " << this->maxColRatio(lp)
+                << " row-ratio= " << this->maxRowRatio(lp) << std::endl;)
+
+  /* initialize scalars, vectors and matrices */
+
+  assert(acrcydivisor > 0.0);
+
+  const R smax = lpnnz / acrcydivisor;
+  R qcurr = 1.0;
+  R qprev = 0.0;
+
+  std::array<R, 3> eprev;
+  eprev.fill(0.0);
+
+  initConstVecs(lp.rowSet(), facnrows, rowlogs, rownnzinv);
+  initConstVecs(lp.colSet(), facncols, collogs, colnnzinv);
+
+  assert(tmprows.isSetup() && tmpcols.isSetup());
+  assert(rowscale1.isSetup() && rowscale2.isSetup());
+  assert(colscale1.isSetup() && colscale2.isSetup());
+
+  // compute first residual vector r0
+  int dummy1 = 0;
+  int dummy2 = 0;
+  resncols = collogs - tmpcols.assign2product4setup(facnrows, rowlogs, 0, 0,
+                                                    dummy1, dummy2);
+
+  resncols.setup();
+  resnrows.setup();
+
+  rowscale1.assignPWproduct4setup(rownnzinv, rowlogs);
+  rowscale2 = rowscale1;
+
+  R scurr = resncols * tmpcols.assignPWproduct4setup(colnnzinv, resncols);
+
+  int k;
+
+  /* conjugate gradient loop */
+  for (k = 0; k < maxrounds; ++k) {
+    const R sprev = scurr;
+
+    // termination criterion met?
+    if (scurr < smax)
+      break;
+
+    // is k even?
+    if ((k % 2) == 0) {
+      // not in first iteration?
+      if (k != 0) // true, then update row scaling factor vector
+        updateScale(rownnzinv, resnrows, tmprows, rsccurr, rscprev, qcurr,
+                    qprev, eprev[1], eprev[2]);
+
+      updateRes(facncols, resncols, resnrows, tmprows, eprev[0], qcurr);
+      scurr = resnrows * tmprows.assignPWproduct4setup(resnrows, rownnzinv);
+    } else // k is odd
+    {
       // update column scaling factor vector
-      updateScaleFinal(colnnzinv, resncols, tmpcols, csccurr, cscprev, qprev, eprev[1], eprev[2]);
-   }
-   else if(k > 0)
-   {
-      // update row scaling factor vector
-      updateScaleFinal(rownnzinv, resnrows, tmprows, rsccurr, rscprev, qprev, eprev[1], eprev[2]);
-   }
-
-   /* compute actual scaling factors */
-
-   const SSVectorBase<R>& rowscale = *rsccurr;
-   const SSVectorBase<R>& colscale = *csccurr;
-
-   DataArray<int>& colscaleExp = *this->m_activeColscaleExp;
-   DataArray<int>& rowscaleExp = *this->m_activeRowscaleExp;
-
-   for(k = 0; k < nrows; ++k)
-      rowscaleExp[k] = -int(rowscale[k] + ((rowscale[k] >= 0.0) ? (+0.5) : (-0.5)));
-
-   for(k = 0; k < ncols; ++k)
-      colscaleExp[k] = -int(colscale[k] + ((colscale[k] >= 0.0) ? (+0.5) : (-0.5)));
-
-   // scale
-   this->applyScaling(lp);
-
-   MSG_INFO3((*this->spxout), (*this->spxout) << "Row scaling min= " << this->minAbsRowscale()
-             << " max= " << this->maxAbsRowscale()
-             << std::endl
-             << "Col scaling min= " << this->minAbsColscale()
-             << " max= " << this->maxAbsColscale()
-             << std::endl;)
-
-   MSG_INFO2((*this->spxout), (*this->spxout) << "after scaling: "
-             << " min= " << lp.minAbsNzo(false)
-             << " max= " << lp.maxAbsNzo(false)
-             << " col-ratio= " << this->maxColRatio(lp)
-             << " row-ratio= " << this->maxRowRatio(lp)
-             << std::endl;)
+      updateScale(colnnzinv, resncols, tmpcols, csccurr, cscprev, qcurr, qprev,
+                  eprev[1], eprev[2]);
+
+      updateRes(facnrows, resnrows, resncols, tmpcols, eprev[0], qcurr);
+      scurr = resncols * tmpcols.assignPWproduct4setup(resncols, colnnzinv);
+    }
+
+    // shift eprev entries one to the right
+    for (unsigned l = 2; l > 0; --l)
+      eprev[l] = eprev[l - 1];
+
+    assert(isNotZero(sprev));
+
+    eprev[0] = (qcurr * scurr) / sprev;
+
+    const R tmp = qcurr;
+    qcurr = 1.0 - eprev[0];
+    qprev = tmp;
+  }
+
+  if (k > 0 && (k % 2) == 0) {
+    // update column scaling factor vector
+    updateScaleFinal(colnnzinv, resncols, tmpcols, csccurr, cscprev, qprev,
+                     eprev[1], eprev[2]);
+  } else if (k > 0) {
+    // update row scaling factor vector
+    updateScaleFinal(rownnzinv, resnrows, tmprows, rsccurr, rscprev, qprev,
+                     eprev[1], eprev[2]);
+  }
+
+  /* compute actual scaling factors */
+
+  const SSVectorBase<R> &rowscale = *rsccurr;
+  const SSVectorBase<R> &colscale = *csccurr;
+
+  DataArray<int> &colscaleExp = *this->m_activeColscaleExp;
+  DataArray<int> &rowscaleExp = *this->m_activeRowscaleExp;
+
+  for (k = 0; k < nrows; ++k)
+    rowscaleExp[k] =
+        -int(rowscale[k] + ((rowscale[k] >= 0.0) ? (+0.5) : (-0.5)));
+
+  for (k = 0; k < ncols; ++k)
+    colscaleExp[k] =
+        -int(colscale[k] + ((colscale[k] >= 0.0) ? (+0.5) : (-0.5)));
+
+  // scale
+  this->applyScaling(lp);
+
+  MSG_INFO3((*this->spxout),
+            (*this->spxout) << "Row scaling min= " << this->minAbsRowscale()
+                            << " max= " << this->maxAbsRowscale() << std::endl
+                            << "Col scaling min= " << this->minAbsColscale()
+                            << " max= " << this->maxAbsColscale() << std::endl;)
+
+  MSG_INFO2((*this->spxout), (*this->spxout)
+                                 << "after scaling: "
+                                 << " min= " << lp.minAbsNzo(false)
+                                 << " max= " << lp.maxAbsNzo(false)
+                                 << " col-ratio= " << this->maxColRatio(lp)
+                                 << " row-ratio= " << this->maxRowRatio(lp)
+                                 << std::endl;)
 }
 
 } // namespace soplex
diff --git a/src/soplex/spxlpbase.h b/src/soplex/spxlpbase.h
index 0841e97..f7ca75a 100644
--- a/src/soplex/spxlpbase.h
+++ b/src/soplex/spxlpbase.h
@@ -28,60 +28,50 @@
 #ifndef _SPXLPBASE_H_
 #define _SPXLPBASE_H_
 
-/* undefine SOPLEX_DEBUG flag from including files; if SOPLEX_DEBUG should be defined in this file, do so below */
+/* undefine SOPLEX_DEBUG flag from including files; if SOPLEX_DEBUG should be
+ * defined in this file, do so below */
 #ifdef SOPLEX_DEBUG
 #define SOPLEX_DEBUG_SPXLPBASE
 #undef SOPLEX_DEBUG
 #endif
 
 #include <assert.h>
-#include <iostream>
 #include <iomanip>
+#include <iostream>
 #include <typeinfo>
 
-#include "soplex/spxdefines.h"
 #include "soplex/basevectors.h"
 #include "soplex/dataarray.h"
 #include "soplex/datakey.h"
-#include "soplex/spxid.h"
-#include "soplex/lprowbase.h"
+#include "soplex/didxset.h"
 #include "soplex/lpcolbase.h"
-#include "soplex/lprowsetbase.h"
 #include "soplex/lpcolsetbase.h"
+#include "soplex/lprowbase.h"
+#include "soplex/lprowsetbase.h"
 #include "soplex/nameset.h"
-#include "soplex/didxset.h"
+#include "soplex/rational.h"
+#include "soplex/spxdefines.h"
 #include "soplex/spxfileio.h"
+#include "soplex/spxid.h"
 #include "soplex/spxscaler.h"
-#include "soplex/rational.h"
 
-namespace soplex
-{
+namespace soplex {
 // Declarations to fix errors of the form "SPxMainSM is not a type"
-template <class R>
-class SPxSolverBase;
-template <class R>
-class SPxMainSM;
-template <class R>
-class SPxLPBase;
-template <class R>
-class SPxBasisBase;
-
-template <class R>
-class SPxEquiliSC;
-template <class R>
-class SPxLeastSqSC;
-template <class R>
-class SPxGeometSC;
-template <class R>
-class SPxMainSM;
+template <class R> class SPxSolverBase;
+template <class R> class SPxMainSM;
+template <class R> class SPxLPBase;
+template <class R> class SPxBasisBase;
 
+template <class R> class SPxEquiliSC;
+template <class R> class SPxLeastSqSC;
+template <class R> class SPxGeometSC;
+template <class R> class SPxMainSM;
 
 /**@brief   Saving LPs in a form suitable for SoPlex.
  * @ingroup Algo
  *
- *  Class SPxLPBase provides the data structures required for saving a linear program in the form
- *  \f[
- *  \begin{array}{rl}
+ *  Class SPxLPBase provides the data structures required for saving a linear
+ * program in the form \f[ \begin{array}{rl}
  *      \hbox{max}  & c^T x              \\
  *      \hbox{s.t.} & l_r \le Ax \le u_r \\
  *                  & l_c \le x \le u_c
@@ -93,2811 +83,2521 @@ class SPxMainSM;
  *  - upper and lower bound Vectors for variables (\f$l_c\f$ and \f$u_c\f$)
  *  - upper and lower bound Vectors for inequalities (\f$l_r\f$ and \f$u_r\f$)
  *
- *  Note, that the optimization sense is not saved directly. Instead, the objective function are multiplied by -1 to
- *  transform the LP to our standard form maximizing the objective function. However, the sense of the loaded LP can be
- *  retrieved with method #spxSense().
+ *  Note, that the optimization sense is not saved directly. Instead, the
+ * objective function are multiplied by -1 to transform the LP to our standard
+ * form maximizing the objective function. However, the sense of the loaded LP
+ * can be retrieved with method #spxSense().
  *
- *  Further, equality constraints are modeled by \f$l_r = u_r\f$.  Analogously, fixed variables have \f$l_c = u_c\f$.
+ *  Further, equality constraints are modeled by \f$l_r = u_r\f$.  Analogously,
+ * fixed variables have \f$l_c = u_c\f$.
  *
- *  #SPxLPBase%s are saved as an SVSet, both for columns and rows. Note that this is redundant but eases the access.
+ *  #SPxLPBase%s are saved as an SVSet, both for columns and rows. Note that
+ * this is redundant but eases the access.
  */
 
-
 template <class R>
-class SPxLPBase : protected LPRowSetBase<R>, protected LPColSetBase<R>
-{
-   template <class S> friend class SPxLPBase;
-   friend SPxBasisBase<R>;
-   friend SPxScaler<R>;
-   friend SPxEquiliSC<R>;
-   friend SPxLeastSqSC<R>;
-   friend SPxGeometSC<R>;
-   friend SPxMainSM<R>;
+class SPxLPBase : protected LPRowSetBase<R>, protected LPColSetBase<R> {
+  template <class S> friend class SPxLPBase;
+  friend SPxBasisBase<R>;
+  friend SPxScaler<R>;
+  friend SPxEquiliSC<R>;
+  friend SPxLeastSqSC<R>;
+  friend SPxGeometSC<R>;
+  friend SPxMainSM<R>;
 
 public:
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Types */
+  ///@{
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Types */
-   ///@{
-
-   /// Optimization sense.
-   enum SPxSense
-   {
-      MAXIMIZE = 1,
-      MINIMIZE = -1
-   };
+  /// Optimization sense.
+  enum SPxSense { MAXIMIZE = 1, MINIMIZE = -1 };
 
-   ///@}
+  ///@}
 
 private:
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Data */
+  ///@{
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Data */
-   ///@{
+  SPxSense thesense;       ///< optimization sense.
+  R offset;                ///< offset computed, e.g., in simplification step
+  bool _isScaled;          ///< true, if scaling has been performed
+  SPxScaler<R> *lp_scaler; ///< points to the scaler if the lp has been scaled,
+                           ///< to nullptr otherwise
 
-   SPxSense thesense;                ///< optimization sense.
-   R offset;                         ///< offset computed, e.g., in simplification step
-   bool _isScaled;                   ///< true, if scaling has been performed
-   SPxScaler<R>*
-   lp_scaler;             ///< points to the scaler if the lp has been scaled, to nullptr otherwise
-
-   ///@}
+  ///@}
 
 public:
-
-   // message handler
-   SPxOut* spxout;
+  // message handler
+  SPxOut *spxout;
 
 public:
+  void setOutstream(SPxOut &newOutstream) { spxout = &newOutstream; }
 
-   void setOutstream(SPxOut& newOutstream)
-   {
-      spxout = &newOutstream;
-   }
-
-   // ------------------------------------------------------------------------------------------------------------------
-
-   /// unscales the lp and clears basis
-   void unscaleLP();
-
-   /**@name Inquiry */
-   ///@{
-
-   /// Returns true if and only if the LP is scaled
-   bool isScaled() const
-   {
-      return _isScaled;
-   }
-
-   /// set whether the LP is scaled or not
-   void setScalingInfo(bool scaled)
-   {
-      _isScaled = scaled;
-   }
-
-   /// Returns number of rows in LP.
-   int nRows() const
-   {
-      return LPRowSetBase<R>::num();
-   }
-
-   /// Returns number of columns in LP.
-   int nCols() const
-   {
-      return LPColSetBase<R>::num();
-   }
-
-   /// Returns number of nonzeros in LP.
-   int nNzos() const
-   {
-
-      int n = 0;
-
-      for(int i = 0; i < nCols(); ++i)
-         n += colVector(i).size();
-
-      return n;
-   }
-
-   /// Absolute smallest non-zero element in (possibly scaled) LP.
-   virtual R minAbsNzo(bool unscaled = true) const;
-
-   /// Absolute biggest non-zero element in (in rational case possibly scaled) LP.
-   virtual R maxAbsNzo(bool unscaled = true) const;
-
-   /// Gets \p i 'th row.
-   void getRow(int i, LPRowBase<R>& row) const
-   {
-      row.setLhs(lhs(i));
-      row.setRhs(rhs(i));
-      row.setObj(rowObj(i));
-      row.setRowVector(DSVectorBase<R>(rowVector(i)));
-   }
-
-   /// Gets row with identifier \p id.
-   void getRow(const SPxRowId& id, LPRowBase<R>& row) const
-   {
-      getRow(number(id), row);
-   }
-
-   /// Gets rows \p start, ... \p end.
-   void getRows(int start, int end, LPRowSetBase<R>& set) const
-   {
-      set.clear();
+  // ------------------------------------------------------------------------------------------------------------------
 
-      for(int i = start; i <= end; i++)
-         set.add(lhs(i), rowVector(i), rhs(i), rowObj(i));
-   }
-
-   /// Gets row vector of row \p i.
-   const SVectorBase<R>& rowVector(int i) const
-   {
-      return LPRowSetBase<R>::rowVector(i);
-   }
-
-   /// Gets row vector of row with identifier \p id.
-   const SVectorBase<R>& rowVector(const SPxRowId& id) const
-   {
-      return LPRowSetBase<R>::rowVector(id);
-   }
-
-   /// Gets unscaled row vector of row \p i.
-   void getRowVectorUnscaled(int i, DSVectorBase<R>& vec) const;
-
-   /// Returns right hand side vector.
-   const VectorBase<R>& rhs() const
-   {
-      return LPRowSetBase<R>::rhs();
-   }
-
-   /// Returns right hand side of row number \p i.
-   const R& rhs(int i) const
-   {
-      return LPRowSetBase<R>::rhs(i);
-   }
-
-
-   /// Returns right hand side of row with identifier \p id.
-   const R& rhs(const SPxRowId& id) const
-   {
-      return LPRowSetBase<R>::rhs(id);
-   }
-
-   /// Gets (internal and possibly scaled) right hand side vector.
-   void getRhs(VectorBase<R>& vec) const
-   {
-      vec = LPRowSetBase<R>::rhs();
-   }
-
-   /// Gets unscaled right hand side vector.
-   void getRhsUnscaled(VectorBase<R>& vec) const;
-
-   /// Returns unscaled right hand side of row number \p i.
-   R rhsUnscaled(int i) const;
-
-   /// Returns unscaled right hand side of row with identifier \p id.
-   R rhsUnscaled(const SPxRowId& id) const;
-
-   /// Returns left hand side vector.
-   const VectorBase<R>& lhs() const
-   {
-      return LPRowSetBase<R>::lhs();
-   }
-
-   /// Returns left hand side of row number \p i.
-   const R& lhs(int i) const
-   {
-      return LPRowSetBase<R>::lhs(i);
-   }
-
-   /// Returns left hand side of row with identifier \p id.
-   const R& lhs(const SPxRowId& id) const
-   {
-      return LPRowSetBase<R>::lhs(id);
-   }
-
-   /// Gets row objective function vector.
-   void getRowObj(VectorBase<R>& prowobj) const
-   {
-      prowobj = LPRowSetBase<R>::obj();
-
-      if(spxSense() == MINIMIZE)
-         prowobj *= -1.0;
-   }
-
-   ///
-   R rowObj(int i) const
-   {
-      if(spxSense() == MINIMIZE)
-         return -maxRowObj(i);
-      else
-         return maxRowObj(i);
-   }
-
-   /// Returns row objective function value of row with identifier \p id.
-   R rowObj(const SPxRowId& id) const
-   {
-      if(spxSense() == MINIMIZE)
-         return -maxRowObj(id);
-      else
-         return maxRowObj(id);
-   }
-
-   ///
-   const VectorBase<R>& maxRowObj() const
-   {
-      return LPRowSetBase<R>::obj();
-   }
-
-   ///
-   const R& maxRowObj(int i) const
-   {
-      return LPRowSetBase<R>::obj(i);
-   }
-
-   /// Returns row objective function value of row with identifier \p id.
-   const R& maxRowObj(const SPxRowId& id) const
-   {
-      return LPRowSetBase<R>::obj(id);
-   }
-
-   /// Returns unscaled left hand side vector.
-   void getLhsUnscaled(VectorBase<R>& vec) const;
-
-   /// Returns unscaled left hand side of row number \p i.
-   R lhsUnscaled(int i) const;
-
-   /// Returns left hand side of row with identifier \p id.
-   R lhsUnscaled(const SPxRowId& id) const;
-
-   /// Returns the inequality type of the \p i'th LPRow.
-   typename LPRowBase<R>::Type rowType(int i) const
-   {
-      return LPRowSetBase<R>::type(i);
-   }
-
-   /// Returns the inequality type of the row with identifier \p key.
-   typename LPRowBase<R>::Type rowType(const SPxRowId& id) const
-   {
-      return LPRowSetBase<R>::type(id);
-   }
-
-   /// Gets \p i 'th column.
-   void getCol(int i, LPColBase<R>& col) const
-   {
-      col.setUpper(upper(i));
-      col.setLower(lower(i));
-      col.setObj(obj(i));
-      col.setColVector(colVector(i));
-   }
-
-   /// Gets column with identifier \p id.
-   void getCol(const SPxColId& id, LPColBase<R>& col) const
-   {
-      getCol(number(id), col);
-   }
-
-   /// Gets columns \p start, ..., \p end.
-   void getCols(int start, int end, LPColSetBase<R>& set) const
-   {
-      if(_isScaled)
-      {
-         LPColBase<R> lpcol;
+  /// unscales the lp and clears basis
+  void unscaleLP();
 
-         for(int i = start; i <= end; i++)
-         {
-            getCol(i, lpcol);
-            set.add(lpcol);
-         }
+  /**@name Inquiry */
+  ///@{
 
-      }
-      else
-      {
-         set.clear();
+  /// Returns true if and only if the LP is scaled
+  bool isScaled() const { return _isScaled; }
 
-         for(int i = start; i <= end; i++)
-            set.add(obj(i), lower(i), colVector(i), upper(i));
-      }
-   }
-
-   /// Returns column vector of column \p i.
-   const SVectorBase<R>& colVector(int i) const
-   {
-      return LPColSetBase<R>::colVector(i);
-   }
-
-   /// Returns column vector of column with identifier \p id.
-   const SVectorBase<R>& colVector(const SPxColId& id) const
-   {
-      return LPColSetBase<R>::colVector(id);
-   }
-
-   /// Gets column vector of column \p i.
-   void getColVectorUnscaled(int i, DSVectorBase<R>& vec) const;
-
-   /// Gets column vector of column with identifier \p id.
-   void getColVectorUnscaled(const SPxColId& id, DSVectorBase<R>& vec) const;
-
-   /// Gets unscaled objective vector.
-   void getObjUnscaled(VectorBase<R>& pobj) const;
-
-   /// Gets objective vector.
-   void getObj(VectorBase<R>& pobj) const
-   {
-      pobj = LPColSetBase<R>::maxObj();
-
-      if(spxSense() == MINIMIZE)
-         pobj *= -1.0;
-   }
-
-   /// Returns objective value of column \p i.
-   R obj(int i) const
-   {
-      R res = maxObj(i);
-
-      if(spxSense() == MINIMIZE)
-         res *= -1;
-
-      return res;
-   }
-
-   /// Returns objective value of column with identifier \p id.
-   R obj(const SPxColId& id) const
-   {
-      return obj(number(id));
-   }
-
-   /// Returns unscaled objective value of column \p i.
-   R objUnscaled(int i) const;
-
-   /// Returns unscaled objective value of column with identifier \p id.
-   R objUnscaled(const SPxColId& id) const;
-
-   /// Returns objective vector for maximization problem.
-   /** Methods #maxObj() return the objective vector or its elements, after transformation to a maximization
-    *  problem. Since this is how SPxLPBase internally stores any LP these methods are generally faster. The following
-    *  condition holds: #obj() = #spxSense() * maxObj().
-    */
-   const VectorBase<R>& maxObj() const
-   {
-      return LPColSetBase<R>::maxObj();
-   }
-
-   /// Returns objective value of column \p i for maximization problem.
-   const R& maxObj(int i) const
-   {
-      return LPColSetBase<R>::maxObj(i);
-   }
-
-   /// Returns objective value of column with identifier \p id for maximization problem.
-   const R& maxObj(const SPxColId& id) const
-   {
-      return maxObj(number(id));
-   }
-
-   /// Returns unscaled objective vector for maximization problem.
-   void maxObjUnscaled(VectorBase<R>& vec) const;
-
-   /// Returns unscaled objective value of column \p i for maximization problem.
-   R maxObjUnscaled(int i) const;
-
-   /// Returns unscaled objective value of column with identifier \p id for maximization problem.
-   R maxObjUnscaled(const SPxColId& id) const;
-
-   /// Returns upper bound vector.
-   const VectorBase<R>& upper() const
-   {
-      return LPColSetBase<R>::upper();
-   }
-
-   /// Returns upper bound of column \p i.
-   const R& upper(int i) const
-   {
-      return LPColSetBase<R>::upper(i);
-   }
-
-   /// Returns upper bound of column with identifier \p id.
-   const R& upper(const SPxColId& id) const
-   {
-      return LPColSetBase<R>::upper(id);
-   }
-
-   /// Gets unscaled upper bound vector
-   void getUpperUnscaled(VectorBase<R>& vec) const;
-
-   /// Returns unscaled upper bound of column \p i.
-   R upperUnscaled(int i) const;
-
-   /// Returns unscaled upper bound of column with identifier \p id.
-   R upperUnscaled(const SPxColId& id) const;
-
-   /// Returns (internal and possibly scaled) lower bound vector.
-   const VectorBase<R>& lower() const
-   {
-      return LPColSetBase<R>::lower();
-   }
-
-   /// Returns (internal and possibly scaled) lower bound of column \p i.
-   const R& lower(int i) const
-   {
-      return LPColSetBase<R>::lower(i);
-   }
-
-   /// Returns (internal and possibly scaled) lower bound of column with identifier \p id.
-   const R& lower(const SPxColId& id) const
-   {
-      return LPColSetBase<R>::lower(id);
-   }
-
-   /// Gets unscaled lower bound vector.
-   void getLowerUnscaled(VectorBase<R>& vec) const;
-
-   /// Returns unscaled lower bound of column \p i.
-   R lowerUnscaled(int i) const;
-
-   /// Returns unscaled lower bound of column with identifier \p id.
-   R lowerUnscaled(const SPxColId& id) const;
-
-   /// Returns the optimization sense.
-   SPxSense spxSense() const
-   {
-      return thesense;
-   }
-
-   /// Returns the objective function value offset
-   const R& objOffset() const
-   {
-      return offset;
-   }
-
-   /// Returns the row number of the row with identifier \p id.
-   int number(const SPxRowId& id) const
-   {
-      return LPRowSetBase<R>::number(id);
-   }
-
-   /// Returns the column number of the column with identifier \p id.
-   int number(const SPxColId& id) const
-   {
-      return LPColSetBase<R>::number(id);
-   }
-
-   /// Returns the row or column number for identifier \p id.
-   int number(const SPxId& id) const
-   {
-      return (id.type() == SPxId::COL_ID)
-             ? LPColSetBase<R>::number(id)
-             : LPRowSetBase<R>::number(id);
-   }
-
-   /// Returns the row number of the row with identifier \p id.
-   bool has(const SPxRowId& id) const
-   {
-      return LPRowSetBase<R>::has(id);
-   }
-
-   /// Returns the column number of the column with identifier \p id.
-   bool has(const SPxColId& id) const
-   {
-      return LPColSetBase<R>::has(id);
-   }
-
-   /// Returns the row or column number for identifier \p id.
-   bool has(const SPxId& id) const
-   {
-      return (id.type() == SPxId::COL_ID)
-             ? LPColSetBase<R>::has(id)
-             : LPRowSetBase<R>::has(id);
-   }
-
-   /// Returns the row identifier for row \p n.
-   SPxRowId rId(int n) const
-   {
-      return SPxRowId(LPRowSetBase<R>::key(n));
-   }
-
-   /// Returns the column identifier for column \p n.
-   SPxColId cId(int n) const
-   {
-      return SPxColId(LPColSetBase<R>::key(n));
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Extension */
-   ///@{
-
-   ///
-   virtual void addRow(const LPRowBase<R>& row, bool scale = false)
-   {
-      doAddRow(row, scale);
-   }
-
-   ///
-   virtual void addRow(const R& lhsValue, const SVectorBase<R>& rowVec, const R& rhsValue,
-                       bool scale = false)
-   {
-      doAddRow(lhsValue, rowVec, rhsValue, scale);
-   }
-
-   ///
-   template < class S >
-   void addRow(const S* lhsValue, const S* rowValues, const int* rowIndices, int rowSize,
-               const S* rhsValue)
-   {
-      assert(lhsValue != 0);
-      assert(rowSize <= 0 || rowValues != 0);
-      assert(rowSize <= 0 || rowIndices != 0);
-      assert(rhsValue != 0);
-
-      int idx = nRows();
-      int oldColNumber = nCols();
-
-      LPRowSetBase<R>::add(lhsValue, rowValues, rowIndices, rowSize, rhsValue);
-
-      // now insert nonzeros to column file also
-      for(int j = rowSize - 1; j >= 0; --j)
-      {
-         const S& val = rowValues[j];
-         int i = rowIndices[j];
+  /// set whether the LP is scaled or not
+  void setScalingInfo(bool scaled) { _isScaled = scaled; }
 
-         // create new columns if required
-         if(i >= nCols())
-         {
-            LPColBase<R> empty;
+  /// Returns number of rows in LP.
+  int nRows() const { return LPRowSetBase<R>::num(); }
 
-            for(int k = nCols(); k <= i; ++k)
-               LPColSetBase<R>::add(empty);
-         }
+  /// Returns number of columns in LP.
+  int nCols() const { return LPColSetBase<R>::num(); }
 
-         assert(i < nCols());
-         LPColSetBase<R>::add2(i, 1, &idx, &val);
-      }
+  /// Returns number of nonzeros in LP.
+  int nNzos() const {
 
-      addedRows(1);
-      addedCols(nCols() - oldColNumber);
-   }
-
-   /// Adds \p row to LPRowSetBase.
-   virtual void addRow(SPxRowId& id, const LPRowBase<R>& row, bool scale = false)
-   {
-      addRow(row, scale);
-      id = rId(nRows() - 1);
-   }
-
-   ///
-   virtual void addRows(const LPRowSetBase<R>& pset, bool scale = false)
-   {
-      doAddRows(pset, scale);
-   }
-
-   ///
-   template < class S >
-   void addRows(const S* lhsValues, const S* rowValues, const int* rowIndices, const int* rowStarts,
-                const int* rowLengths, const int numRows, const int numValues, const S* rhsValues)
-   {
-      assert(lhsValues != 0);
-      assert(numValues <= 0 || rowValues != 0);
-      assert(numValues <= 0 || rowIndices != 0);
-      assert(numValues <= 0 || rowStarts != 0);
-      assert(numValues <= 0 || rowLengths != 0);
-      assert(rhsValues != 0);
-
-      int i, j, k, idx;
-      SVectorBase<R>* col;
-      DataArray < int > newCols(nCols());
-      int oldRowNumber = nRows();
-      int oldColNumber = nCols();
-
-      LPRowSetBase<R>::memRemax(oldRowNumber + numRows);
-
-      for(i = 0; i < numRows; i++)
-      {
-         assert(numValues <= 0 || rowStarts[i] + rowLengths[i] <= numValues);
+    int n = 0;
 
-         if(numValues <= 0)
-            LPRowSetBase<R>::add(&(lhsValues[i]), (S*)0, (int*)0, 0, &(rhsValues[i]));
-         else
-            LPRowSetBase<R>::add(&(lhsValues[i]), &(rowValues[rowStarts[i]]), &(rowIndices[rowStarts[i]]),
-                                 rowLengths[i], &(rhsValues[i]));
-      }
+    for (int i = 0; i < nCols(); ++i)
+      n += colVector(i).size();
 
-      assert(LPRowSetBase<R>::isConsistent());
-      assert(LPColSetBase<R>::isConsistent());
+    return n;
+  }
 
-      // count additional nonzeros per column
-      for(i = nCols() - 1; i >= 0; --i)
-         newCols[i] = 0;
+  /// Absolute smallest non-zero element in (possibly scaled) LP.
+  virtual R minAbsNzo(bool unscaled = true) const;
 
-      if(numValues > 0)
-      {
-         for(i = 0; i < numRows; i++)
-         {
-            for(j = rowStarts[i]; j < rowStarts[i] + rowLengths[i]; j++)
-            {
-               ///@todo implement the addition of new columns as in doAddRows()
-               assert(rowIndices[j] >= 0);
-               assert(rowIndices[j] < oldColNumber);
-               newCols[rowIndices[j]]++;
-            }
-         }
-      }
+  /// Absolute biggest non-zero element in (in rational case possibly scaled)
+  /// LP.
+  virtual R maxAbsNzo(bool unscaled = true) const;
 
-      // extend columns as required (backward because of memory efficiency reasons)
-      for(i = nCols() - 1; i >= 0; --i)
-      {
-         if(newCols[i] > 0)
-         {
-            int len = newCols[i] + colVector(i).size();
-            LPColSetBase<R>::xtend(i, len);
-
-            /* preset the sizes: beware that this can irritate a consistency check call from xtend(). We need to set the
-             * sizes here, because a possible garbage collection called from xtend might destroy the sizes again. */
-            colVector_w(i).set_size(len);
-         }
-      }
+  /// Gets \p i 'th row.
+  void getRow(int i, LPRowBase<R> &row) const {
+    row.setLhs(lhs(i));
+    row.setRhs(rhs(i));
+    row.setObj(rowObj(i));
+    row.setRowVector(DSVectorBase<R>(rowVector(i)));
+  }
 
-      // insert new elements to column file
-      for(i = nRows() - 1; i >= oldRowNumber; --i)
-      {
-         const SVectorBase<R>& vec = rowVector(i);
-
-         for(j = vec.size() - 1; j >= 0; --j)
-         {
-            k = vec.index(j);
-            col = &colVector_w(k);
-            idx = col->size() - newCols[k];
-            assert(newCols[k] > 0);
-            assert(idx >= 0);
-            newCols[k]--;
-            col->index(idx) = i;
-            col->value(idx) = vec.value(j);
-         }
-      }
+  /// Gets row with identifier \p id.
+  void getRow(const SPxRowId &id, LPRowBase<R> &row) const {
+    getRow(number(id), row);
+  }
 
-#ifndef NDEBUG
+  /// Gets rows \p start, ... \p end.
+  void getRows(int start, int end, LPRowSetBase<R> &set) const {
+    set.clear();
 
-      for(i = 0; i < nCols(); ++i)
-         assert(newCols[i] == 0);
+    for (int i = start; i <= end; i++)
+      set.add(lhs(i), rowVector(i), rhs(i), rowObj(i));
+  }
 
-#endif
+  /// Gets row vector of row \p i.
+  const SVectorBase<R> &rowVector(int i) const {
+    return LPRowSetBase<R>::rowVector(i);
+  }
 
-      assert(SPxLPBase<R>::isConsistent());
-
-      assert(numRows == nRows() - oldRowNumber);
-      addedRows(nRows() - oldRowNumber);
-      addedCols(nCols() - oldColNumber);
-   }
-
-   /// adds all LPRowBase%s of \p pset to LPRowSetBase.
-   virtual void addRows(SPxRowId id[], const LPRowSetBase<R>& set, bool scale = false)
-   {
-      int i = nRows();
-      addRows(set, scale);
-
-      for(int j = 0; i < nRows(); ++i, ++j)
-         id[j] = rId(i);
-   }
-
-   ///
-   virtual void addCol(const LPColBase<R>& col, bool scale = false)
-   {
-      doAddCol(col, scale);
-   }
-
-   ///
-   virtual void addCol(const R& objValue, const R& lowerValue, const SVectorBase<R>& colVec,
-                       const R& upperValue, bool scale = false)
-   {
-      doAddCol(objValue, lowerValue, colVec, upperValue, scale);
-   }
-
-   ///
-   template < class S >
-   void addCol(const S* objValue, const S* lowerValue, const S* colValues, const int* colIndices,
-               int colSize, const S* upperValue)
-   {
-      int idx = nCols();
-      int oldRowNumber = nRows();
-
-      LPColSetBase<R>::add(objValue, lowerValue, colValues, colIndices, colSize, upperValue);
-
-      if(thesense != MAXIMIZE)
-         LPColSetBase<R>::maxObj_w(idx) *= -1;
-
-      // now insert nonzeros to column file also
-      for(int j = colSize - 1; j >= 0; --j)
-      {
-         const S& val = colValues[j];
-         int i = colIndices[j];
+  /// Gets row vector of row with identifier \p id.
+  const SVectorBase<R> &rowVector(const SPxRowId &id) const {
+    return LPRowSetBase<R>::rowVector(id);
+  }
 
-         // create new rows if required
-         if(i >= nRows())
-         {
-            LPRowBase<R> empty;
+  /// Gets unscaled row vector of row \p i.
+  void getRowVectorUnscaled(int i, DSVectorBase<R> &vec) const;
 
-            for(int k = nRows(); k <= i; ++k)
-               LPRowSetBase<R>::add(empty);
-         }
+  /// Returns right hand side vector.
+  const VectorBase<R> &rhs() const { return LPRowSetBase<R>::rhs(); }
 
-         assert(i < nRows());
-         LPRowSetBase<R>::add2(i, 1, &idx, &val);
-      }
+  /// Returns right hand side of row number \p i.
+  const R &rhs(int i) const { return LPRowSetBase<R>::rhs(i); }
 
-      addedCols(1);
-      addedRows(nRows() - oldRowNumber);
-   }
-
-   /// Adds \p col to LPColSetVBase.
-   virtual void addCol(SPxColId& id, const LPColBase<R>& col, bool scale = false)
-   {
-      addCol(col, scale);
-      id = cId(nCols() - 1);
-   }
-
-   ///
-   virtual void addCols(const LPColSetBase<R>& pset, bool scale = false)
-   {
-      doAddCols(pset, scale);
-   }
-
-   ///
-   template < class S >
-   void addCols(const S* objValue, const S* lowerValues, const S* colValues, const int* colIndices,
-                const int* colStarts, const int* colLengths, const int numCols, const int numValues,
-                const S* upperValues)
-   {
-      assert(lowerValues != 0);
-      assert(numValues <= 0 || colValues != 0);
-      assert(numValues <= 0 || colIndices != 0);
-      assert(numValues <= 0 || colStarts != 0);
-      assert(numValues <= 0 || colLengths != 0);
-      assert(upperValues != 0);
-
-      int i, j, k, idx;
-      SVectorBase<R>* row;
-      DataArray < int > newRows(nRows());
-      int oldColNumber = nCols();
-      int oldRowNumber = nRows();
-      idx = nCols();
-
-      LPColSetBase<R>::memRemax(oldColNumber + numCols);
-
-      for(i = 0; i < numCols; i++)
-      {
-         assert(numValues <= 0 || colStarts[i] + colLengths[i] <= numValues);
+  /// Returns right hand side of row with identifier \p id.
+  const R &rhs(const SPxRowId &id) const { return LPRowSetBase<R>::rhs(id); }
 
-         if(numValues <= 0)
-            LPColSetBase<R>::add(&(objValue[i]), &(lowerValues[i]), (S*)0, (int*)0, 0, &(upperValues[i]));
-         else
-            LPColSetBase<R>::add(&(objValue[i]), &(lowerValues[i]), &(colValues[colStarts[i]]),
-                                 &(colIndices[colStarts[i]]), colLengths[i], &(upperValues[i]));
+  /// Gets (internal and possibly scaled) right hand side vector.
+  void getRhs(VectorBase<R> &vec) const { vec = LPRowSetBase<R>::rhs(); }
 
-         if(thesense != MAXIMIZE)
-            LPColSetBase<R>::maxObj_w(idx + i) *= -1;
-      }
+  /// Gets unscaled right hand side vector.
+  void getRhsUnscaled(VectorBase<R> &vec) const;
 
-      assert(LPColSetBase<R>::isConsistent());
-      assert(LPRowSetBase<R>::isConsistent());
+  /// Returns unscaled right hand side of row number \p i.
+  R rhsUnscaled(int i) const;
 
-      // count additional nonzeros per rows
-      for(i = nRows() - 1; i >= 0; --i)
-         newRows[i] = 0;
+  /// Returns unscaled right hand side of row with identifier \p id.
+  R rhsUnscaled(const SPxRowId &id) const;
 
-      for(i = numValues - 1; i >= 0; --i)
-      {
-         ///@todo implement the addition of new rows as in doAddCols()
-         assert(colIndices[i] >= 0);
-         assert(colIndices[i] < oldRowNumber);
-         newRows[colIndices[i]]++;
-      }
+  /// Returns left hand side vector.
+  const VectorBase<R> &lhs() const { return LPRowSetBase<R>::lhs(); }
 
-      // extend rows as required (backward because of memory efficiency reasons)
-      for(i = nRows() - 1; i >= 0; --i)
-      {
-         if(newRows[i] > 0)
-         {
-            int len = newRows[i] + rowVector(i).size();
-            LPRowSetBase<R>::xtend(i, len);
-
-            /* preset the sizes: beware that this can irritate a consistency check call from xtend(). We need to set the
-             * sizes here, because a possible garbage collection called from xtend might destroy the sizes again. */
-            rowVector_w(i).set_size(len);
-         }
-      }
+  /// Returns left hand side of row number \p i.
+  const R &lhs(int i) const { return LPRowSetBase<R>::lhs(i); }
 
-      // insert new elements to row file
-      for(i = nCols() - 1; i >= oldColNumber; --i)
-      {
-         const SVectorBase<R>& vec = colVector(i);
-
-         for(j = vec.size() - 1; j >= 0; --j)
-         {
-            k = vec.index(j);
-            row = &rowVector_w(k);
-            idx = row->size() - newRows[k];
-            assert(newRows[k] > 0);
-            assert(idx >= 0);
-            newRows[k]--;
-            row->index(idx) = i;
-            row->value(idx) = vec.value(j);
-         }
-      }
+  /// Returns left hand side of row with identifier \p id.
+  const R &lhs(const SPxRowId &id) const { return LPRowSetBase<R>::lhs(id); }
 
-#ifndef NDEBUG
+  /// Gets row objective function vector.
+  void getRowObj(VectorBase<R> &prowobj) const {
+    prowobj = LPRowSetBase<R>::obj();
 
-      for(i = 0; i < nRows(); ++i)
-         assert(newRows[i] == 0);
+    if (spxSense() == MINIMIZE)
+      prowobj *= -1.0;
+  }
 
-#endif
+  ///
+  R rowObj(int i) const {
+    if (spxSense() == MINIMIZE)
+      return -maxRowObj(i);
+    else
+      return maxRowObj(i);
+  }
 
-      assert(SPxLPBase<R>::isConsistent());
+  /// Returns row objective function value of row with identifier \p id.
+  R rowObj(const SPxRowId &id) const {
+    if (spxSense() == MINIMIZE)
+      return -maxRowObj(id);
+    else
+      return maxRowObj(id);
+  }
 
-      assert(numCols == nCols() - oldColNumber);
-      addedCols(nCols() - oldColNumber);
-      addedRows(nRows() - oldRowNumber);
-   }
+  ///
+  const VectorBase<R> &maxRowObj() const { return LPRowSetBase<R>::obj(); }
+
+  ///
+  const R &maxRowObj(int i) const { return LPRowSetBase<R>::obj(i); }
+
+  /// Returns row objective function value of row with identifier \p id.
+  const R &maxRowObj(const SPxRowId &id) const {
+    return LPRowSetBase<R>::obj(id);
+  }
+
+  /// Returns unscaled left hand side vector.
+  void getLhsUnscaled(VectorBase<R> &vec) const;
+
+  /// Returns unscaled left hand side of row number \p i.
+  R lhsUnscaled(int i) const;
 
-   /// Adds all LPColBase%s of \p set to LPColSetBase.
-   virtual void addCols(SPxColId id[], const LPColSetBase<R>& set, bool scale = false)
-   {
+  /// Returns left hand side of row with identifier \p id.
+  R lhsUnscaled(const SPxRowId &id) const;
 
-      int i = nCols();
-      addCols(set, scale);
+  /// Returns the inequality type of the \p i'th LPRow.
+  typename LPRowBase<R>::Type rowType(int i) const {
+    return LPRowSetBase<R>::type(i);
+  }
 
-      for(int j = 0; i < nCols(); ++i, ++j)
-         id[j] = cId(i);
-   }
+  /// Returns the inequality type of the row with identifier \p key.
+  typename LPRowBase<R>::Type rowType(const SPxRowId &id) const {
+    return LPRowSetBase<R>::type(id);
+  }
 
-   ///@}
+  /// Gets \p i 'th column.
+  void getCol(int i, LPColBase<R> &col) const {
+    col.setUpper(upper(i));
+    col.setLower(lower(i));
+    col.setObj(obj(i));
+    col.setColVector(colVector(i));
+  }
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Shrinking */
-   ///@{
+  /// Gets column with identifier \p id.
+  void getCol(const SPxColId &id, LPColBase<R> &col) const {
+    getCol(number(id), col);
+  }
 
-   /// Removes \p i 'th row.
-   virtual void removeRow(int i)
-   {
-      if(i < 0)
-         return;
+  /// Gets columns \p start, ..., \p end.
+  void getCols(int start, int end, LPColSetBase<R> &set) const {
+    if (_isScaled) {
+      LPColBase<R> lpcol;
 
-      doRemoveRow(i);
-   }
+      for (int i = start; i <= end; i++) {
+        getCol(i, lpcol);
+        set.add(lpcol);
+      }
 
-   /// Removes row with identifier \p id.
-   virtual void removeRow(SPxRowId id)
-   {
-      removeRow(number(id));
-   }
+    } else {
+      set.clear();
 
-   /// Removes multiple rows.
-   /** This method removes all LPRowBase%s from the SPxLPBase with an index \p i such that \p perm[i] < 0. Upon
-    *  completion, \p perm[i] >= 0 indicates the new index where the \p i'th LPRowBase<R> has been moved to due to this
-    *  removal. Note that \p perm must point to an array of at least #nRows() ints.
-    */
-   virtual void removeRows(int perm[])
-   {
-      doRemoveRows(perm);
-   }
+      for (int i = start; i <= end; i++)
+        set.add(obj(i), lower(i), colVector(i), upper(i));
+    }
+  }
 
-   ///
-   virtual void removeRows(SPxRowId id[], int n, int perm[] = 0)
-   {
+  /// Returns column vector of column \p i.
+  const SVectorBase<R> &colVector(int i) const {
+    return LPColSetBase<R>::colVector(i);
+  }
 
-      if(perm == 0)
-      {
-         DataArray < int > p(nRows());
-         removeRows(id, n, p.get_ptr());
-         return;
-      }
+  /// Returns column vector of column with identifier \p id.
+  const SVectorBase<R> &colVector(const SPxColId &id) const {
+    return LPColSetBase<R>::colVector(id);
+  }
 
-      for(int i = nRows() - 1; i >= 0; --i)
-         perm[i] = i;
+  /// Gets column vector of column \p i.
+  void getColVectorUnscaled(int i, DSVectorBase<R> &vec) const;
 
-      while(n--)
-         perm[number(id[n])] = -1;
+  /// Gets column vector of column with identifier \p id.
+  void getColVectorUnscaled(const SPxColId &id, DSVectorBase<R> &vec) const;
 
-      removeRows(perm);
-   }
+  /// Gets unscaled objective vector.
+  void getObjUnscaled(VectorBase<R> &pobj) const;
 
-   /// Removes \p n LPRowBase%s.
-   /** Removing multiple rows with one method invocation is available in two flavours. An array \p perm can be passed as
-    *  third argument or not. If given, \p perm must be an array at least of size #nRows(). It is used to return the
-    *  permutations resulting from this removal: \p perm[i] < 0 indicates, that the element to index \p i has been
-    *  removed.  Otherwise, \p perm[i] is the new index of the element with index \p i before the removal.
-    */
-   virtual void removeRows(int nums[], int n, int perm[] = 0)
-   {
+  /// Gets objective vector.
+  void getObj(VectorBase<R> &pobj) const {
+    pobj = LPColSetBase<R>::maxObj();
 
-      if(perm == 0)
-      {
-         DataArray < int > p(nRows());
-         removeRows(nums, n, p.get_ptr());
-         return;
-      }
+    if (spxSense() == MINIMIZE)
+      pobj *= -1.0;
+  }
 
-      for(int i = nRows() - 1; i >= 0; --i)
-         perm[i] = i;
+  /// Returns objective value of column \p i.
+  R obj(int i) const {
+    R res = maxObj(i);
 
-      while(n--)
-         perm[nums[n]] = -1;
+    if (spxSense() == MINIMIZE)
+      res *= -1;
 
-      removeRows(perm);
-   }
+    return res;
+  }
 
-   /// Removes rows from \p start to \p end (including both).
-   virtual void removeRowRange(int start, int end, int perm[] = 0)
-   {
+  /// Returns objective value of column with identifier \p id.
+  R obj(const SPxColId &id) const { return obj(number(id)); }
 
-      if(perm == 0)
-      {
-         int i = end - start + 1;
-         DataArray < int > p(i);
+  /// Returns unscaled objective value of column \p i.
+  R objUnscaled(int i) const;
 
-         while(--i >= 0)
-            p[i] = start + i;
+  /// Returns unscaled objective value of column with identifier \p id.
+  R objUnscaled(const SPxColId &id) const;
 
-         removeRows(p.get_ptr(), end - start + 1);
-         return;
-      }
+  /// Returns objective vector for maximization problem.
+  /** Methods #maxObj() return the objective vector or its elements, after
+   * transformation to a maximization problem. Since this is how SPxLPBase
+   * internally stores any LP these methods are generally faster. The following
+   *  condition holds: #obj() = #spxSense() * maxObj().
+   */
+  const VectorBase<R> &maxObj() const { return LPColSetBase<R>::maxObj(); }
 
-      int i;
+  /// Returns objective value of column \p i for maximization problem.
+  const R &maxObj(int i) const { return LPColSetBase<R>::maxObj(i); }
 
-      for(i = 0; i < start; ++i)
-         perm[i] = i;
+  /// Returns objective value of column with identifier \p id for maximization
+  /// problem.
+  const R &maxObj(const SPxColId &id) const { return maxObj(number(id)); }
 
-      for(; i <= end; ++i)
-         perm[i] = -1;
+  /// Returns unscaled objective vector for maximization problem.
+  void maxObjUnscaled(VectorBase<R> &vec) const;
 
-      for(; i < nRows(); ++i)
-         perm[i] = i;
+  /// Returns unscaled objective value of column \p i for maximization problem.
+  R maxObjUnscaled(int i) const;
 
-      removeRows(perm);
-   }
+  /// Returns unscaled objective value of column with identifier \p id for
+  /// maximization problem.
+  R maxObjUnscaled(const SPxColId &id) const;
 
-   /// Removes \p i 'th column.
-   virtual void removeCol(int i)
-   {
-      if(i < 0)
-         return;
+  /// Returns upper bound vector.
+  const VectorBase<R> &upper() const { return LPColSetBase<R>::upper(); }
 
-      doRemoveCol(i);
-   }
+  /// Returns upper bound of column \p i.
+  const R &upper(int i) const { return LPColSetBase<R>::upper(i); }
 
-   /// Removes column with identifier \p id.
-   virtual void removeCol(SPxColId id)
-   {
-      removeCol(number(id));
-   }
+  /// Returns upper bound of column with identifier \p id.
+  const R &upper(const SPxColId &id) const {
+    return LPColSetBase<R>::upper(id);
+  }
 
-   /// Removes multiple columns.
-   /** This method removes all LPColBase%s from the SPxLPBase with an index \p i such that \p perm[i] < 0. Upon
-    *  completion, \p perm[i] >= 0 indicates the new index where the \p i 'th LPColBase has been moved to due to this
-    *  removal. Note, that \p perm must point to an array of at least #nCols() ints.
-    */
-   virtual void removeCols(int perm[])
-   {
-      doRemoveCols(perm);
-   }
+  /// Gets unscaled upper bound vector
+  void getUpperUnscaled(VectorBase<R> &vec) const;
 
-   ///
-   virtual void removeCols(SPxColId id[], int n, int perm[] = 0)
-   {
+  /// Returns unscaled upper bound of column \p i.
+  R upperUnscaled(int i) const;
 
-      if(perm == 0)
-      {
-         DataArray < int > p(nCols());
-         removeCols(id, n, p.get_ptr());
-         return;
-      }
+  /// Returns unscaled upper bound of column with identifier \p id.
+  R upperUnscaled(const SPxColId &id) const;
 
-      for(int i = nCols() - 1; i >= 0; --i)
-         perm[i] = i;
+  /// Returns (internal and possibly scaled) lower bound vector.
+  const VectorBase<R> &lower() const { return LPColSetBase<R>::lower(); }
 
-      while(n--)
-         perm[number(id[n])] = -1;
+  /// Returns (internal and possibly scaled) lower bound of column \p i.
+  const R &lower(int i) const { return LPColSetBase<R>::lower(i); }
 
-      removeCols(perm);
-   }
+  /// Returns (internal and possibly scaled) lower bound of column with
+  /// identifier \p id.
+  const R &lower(const SPxColId &id) const {
+    return LPColSetBase<R>::lower(id);
+  }
 
-   /// Removes \p n LPCols.
-   /** Removing multiple columns with one method invocation is available in two flavours. An array \p perm can be passed
-    *  as third argument or not. If given, \p perm must be an array at least of size #nCols(). It is used to return the
-    *  permutations resulting from this removal: \p perm[i] < 0 indicates, that the element to index \p i has been
-    *  removed.  Otherwise, \p perm[i] is the new index of the element with index \p i before the removal.
-    */
-   virtual void removeCols(int nums[], int n, int perm[] = 0)
-   {
+  /// Gets unscaled lower bound vector.
+  void getLowerUnscaled(VectorBase<R> &vec) const;
 
-      if(perm == 0)
-      {
-         DataArray < int > p(nCols());
-         removeCols(nums, n, p.get_ptr());
-         return;
-      }
+  /// Returns unscaled lower bound of column \p i.
+  R lowerUnscaled(int i) const;
 
-      for(int i = nCols() - 1; i >= 0; --i)
-         perm[i] = i;
+  /// Returns unscaled lower bound of column with identifier \p id.
+  R lowerUnscaled(const SPxColId &id) const;
 
-      while(n--)
-         perm[nums[n]] = -1;
+  /// Returns the optimization sense.
+  SPxSense spxSense() const { return thesense; }
 
-      removeCols(perm);
-   }
+  /// Returns the objective function value offset
+  const R &objOffset() const { return offset; }
 
-   /// Removes columns from \p start to \p end (including both).
-   virtual void removeColRange(int start, int end, int perm[] = 0)
-   {
+  /// Returns the row number of the row with identifier \p id.
+  int number(const SPxRowId &id) const { return LPRowSetBase<R>::number(id); }
 
-      if(perm == 0)
-      {
-         int i = end - start + 1;
-         DataArray < int > p(i);
+  /// Returns the column number of the column with identifier \p id.
+  int number(const SPxColId &id) const { return LPColSetBase<R>::number(id); }
 
-         while(--i >= 0)
-            p[i] = start + i;
+  /// Returns the row or column number for identifier \p id.
+  int number(const SPxId &id) const {
+    return (id.type() == SPxId::COL_ID) ? LPColSetBase<R>::number(id)
+                                        : LPRowSetBase<R>::number(id);
+  }
 
-         removeCols(p.get_ptr(), end - start + 1);
-         return;
-      }
+  /// Returns the row number of the row with identifier \p id.
+  bool has(const SPxRowId &id) const { return LPRowSetBase<R>::has(id); }
 
-      int i;
+  /// Returns the column number of the column with identifier \p id.
+  bool has(const SPxColId &id) const { return LPColSetBase<R>::has(id); }
 
-      for(i = 0; i < start; ++i)
-         perm[i] = i;
+  /// Returns the row or column number for identifier \p id.
+  bool has(const SPxId &id) const {
+    return (id.type() == SPxId::COL_ID) ? LPColSetBase<R>::has(id)
+                                        : LPRowSetBase<R>::has(id);
+  }
 
-      for(; i <= end; ++i)
-         perm[i] = -1;
+  /// Returns the row identifier for row \p n.
+  SPxRowId rId(int n) const { return SPxRowId(LPRowSetBase<R>::key(n)); }
 
-      for(; i < nCols(); ++i)
-         perm[i] = i;
+  /// Returns the column identifier for column \p n.
+  SPxColId cId(int n) const { return SPxColId(LPColSetBase<R>::key(n)); }
 
-      removeCols(perm);
-   }
+  ///@}
 
-   /// clears the LP.
-   virtual void clear()
-   {
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Extension */
+  ///@{
 
-      LPRowSetBase<R>::clear();
-      LPColSetBase<R>::clear();
-      thesense = MAXIMIZE;
-      offset = 0;
-      _isScaled = false;
-      lp_scaler = nullptr;
-      LPColSetBase<R>::scaleExp.clear();
-      LPRowSetBase<R>::scaleExp.clear();
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name IO */
-   ///@{
-
-   /// Reads LP in LP format from input stream \p in.
-   virtual bool readLPF(std::istream& in, NameSet* rowNames = 0, NameSet* colNames = 0,
-                        DIdxSet* intVars = 0);
-
-   /// Reads an LP in MPS format from input stream \p in.
-   virtual bool readMPS(std::istream& in, NameSet* rowNames = 0, NameSet* colNames = 0,
-                        DIdxSet* intVars = 0);
-
-   /// Reads LP in LP or MPS format from input stream \p in.
-   /**@param in       input stream.
-    * @param rowNames contains after the call the names of the constraints (rows) in the same order as the rows in the
-    *                 LP.  Constraints without a name (only possible with LPF files) are automatically assigned a name.
-    *                 Maybe 0 if the names are not needed.
-    * @param colNames contains after the call the names of the variables (columns) in the same order as the columns in
-    *                 the LP.  Maybe 0 if the names are not needed.
-    * @param intVars contains after the call the indices of those variables that where marked as beeing integer in the
-    *                 file.  Maybe 0 if the information is not needed.
-    * @todo Make sure the Id's in the NameSet%s are the same as in the LP.
-    */
-   virtual bool read(std::istream& in, NameSet* rowNames = 0, NameSet* colNames = 0,
-                     DIdxSet* intVars  = 0)
-   {
-      bool ok;
-      char c;
-
-      in.get(c);
-      in.putback(c);
-
-      /* MPS starts either with a comment mark '*' or with the keyword 'NAME' at the first column.  LPF starts either
-       * with blanks, a comment mark '\' or with the keyword "MAX" or "MIN" in upper or lower case.  There is no
-       * possible valid LPF file starting with a '*' or 'N'.
-       */
-      ok = ((c == '*') || (c == 'N'))
-           ? readMPS(in, rowNames, colNames, intVars)
-           : readLPF(in, rowNames, colNames, intVars);
-
-      return ok;
-   }
-
-   /// Reads LP from a file.
-   virtual bool readFile(const char* filename, NameSet* rowNames = 0, NameSet* colNames = 0,
-                         DIdxSet* intVars = 0)
-   {
-
-      spxifstream file(filename);
-
-      if(!file)
-         return false;
-
-      return read(file, rowNames, colNames, intVars);
-   }
-
-   /** Writes a file in LP format to \p out. If \p rowNames and \p colNames are \c NULL, default names are used for the
-    *  constraints and variables. If \p intVars is not \c NULL, the variables contained in it are marked as integer in
-    *  the output.
-    */
-   virtual void writeLPF(std::ostream&  out, const NameSet* rowNames, const NameSet* colNames,
-                         const DIdxSet* p_intvars = 0) const;
-
-   /// Writes a file in MPS format to \p out.
-   virtual void writeMPS(std::ostream&  out, const NameSet* rowNames, const NameSet* colNames,
-                         const DIdxSet* p_intvars = 0) const;
-
-   /// Write loaded LP to \p filename.
-   virtual void writeFileLPBase(const char* filename, const NameSet* rowNames = 0,
-                                const NameSet* colNames = 0, const DIdxSet* p_intvars = 0) const
-   {
-
-      std::ofstream tmp(filename);
-      size_t len_f = strlen(filename);
-
-      if(len_f > 4 && filename[len_f - 1] == 's' && filename[len_f - 2] == 'p'
-            && filename[len_f - 3] == 'm' && filename[len_f - 4] == '.')
-      {
-         writeMPS(tmp, rowNames, colNames, p_intvars);
-      }
-      else
-      {
-         writeLPF(tmp, rowNames, colNames, p_intvars);
-      }
-   }
-
-   /** prints problem statistics */
-   void printProblemStatistics(std::ostream& os)
-   {
-      int countLower = 0;
-      int countUpper = 0;
-      int countBoxed = 0;
-      int countFreeCol = 0;
-
-      int countEqual = 0;
-      int countLhs = 0;
-      int countRhs = 0;
-      int countRanged = 0;
-      int countFreeRow = 0;
-
-      for(int i = 0; i < nCols(); i++)
-      {
-         bool hasLower = false;
-         bool hasUpper = false;
-
-         if(lower(i) > R(-infinity))
-         {
-            countLower++;
-            hasLower = true;
-         }
-
-         if(upper(i) < R(infinity))
-         {
-            countUpper++;
-            hasUpper = true;
-         }
-
-         if(hasUpper && hasLower)
-         {
-            countBoxed++;
-            countLower--;
-            countUpper--;
-         }
-
-         if(!hasUpper && !hasLower)
-            countFreeCol++;
-      }
-
-      for(int i = 0; i < nRows(); i++)
-      {
-         bool hasRhs = false;
-         bool hasLhs = false;
-
-         if(lhs(i) > R(-infinity))
-         {
-            countLhs++;
-            hasLhs = true;
-         }
-
-         if(rhs(i) < R(infinity))
-         {
-            countRhs++;
-            hasRhs = true;
-         }
-
-         if(hasRhs && hasLhs)
-         {
-            if(EQ(lhs(i), rhs(i)))
-               countEqual++;
-            else
-               countRanged++;
-
-            countLhs--;
-            countRhs--;
-         }
-
-         if(!hasRhs && !hasLhs)
-            countFreeRow++;
-      }
+  ///
+  virtual void addRow(const LPRowBase<R> &row, bool scale = false) {
+    doAddRow(row, scale);
+  }
 
-      SPxOut::setFixed(os);
-      os << "  Columns           : " << nCols() << "\n"
-         << "              boxed : " << countBoxed << "\n"
-         << "        lower bound : " << countLower << "\n"
-         << "        upper bound : " << countUpper << "\n"
-         << "               free : " << countFreeCol << "\n"
-         << "  Rows              : " << nRows() << "\n"
-         << "              equal : " << countEqual << "\n"
-         << "             ranged : " << countRanged << "\n"
-         << "                lhs : " << countLhs << "\n"
-         << "                rhs : " << countRhs << "\n"
-         << "               free : " << countFreeRow << "\n"
-         << "  Nonzeros          : " << nNzos() << "\n"
-         << "         per column : " << R(nNzos()) / R(nCols()) << "\n"
-         << "            per row : " << R(nNzos()) / R(nRows()) << "\n"
-         << "           sparsity : " << R(nNzos()) / R(nCols()) / R(nRows()) << "\n"
-         << "    min. abs. value : " << R(minAbsNzo()) << "\n"
-         << "    max. abs. value : " << R(maxAbsNzo()) << "\n";
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Manipulation */
-   ///@{
-
-   /// Changes objective vector to \p newObj. \p scale determines whether the new data should be scaled
-   virtual void changeObj(const VectorBase<R>& newObj, bool scale = false)
-   {
-      changeMaxObj(newObj, scale);
-
-      if(spxSense() == MINIMIZE)
-         LPColSetBase<R>::maxObj_w() *= -1;
-   }
-
-   /// changes \p i 'th objective vector element to \p newVal. \p scale determines whether the new data should be scaled
-   virtual void changeObj(int i, const R& newVal, bool scale = false)
-   {
-      changeMaxObj(i, newVal, scale);
-
-      if(spxSense() == MINIMIZE)
-         LPColSetBase<R>::maxObj_w(i) *= -1;
-   }
-
-   /// changes \p i 'th objective vector element to \p newVal.
-   template < class S >
-   void changeObj(int i, const S* newVal)
-   {
-      LPColSetBase<R>::maxObj_w(i) = *newVal;
-
-      if(spxSense() == MINIMIZE)
-         LPColSetBase<R>::maxObj_w(i) *= -1;
+  ///
+  virtual void addRow(const R &lhsValue, const SVectorBase<R> &rowVec,
+                      const R &rhsValue, bool scale = false) {
+    doAddRow(lhsValue, rowVec, rhsValue, scale);
+  }
 
-      assert(isConsistent());
-   }
+  ///
+  template <class S>
+  void addRow(const S *lhsValue, const S *rowValues, const int *rowIndices,
+              int rowSize, const S *rhsValue) {
+    assert(lhsValue != 0);
+    assert(rowSize <= 0 || rowValues != 0);
+    assert(rowSize <= 0 || rowIndices != 0);
+    assert(rhsValue != 0);
 
-   /// Changes objective value of column with identifier \p id to \p newVal. \p scale determines whether the new data should be scaled
-   virtual void changeObj(SPxColId id, const R& newVal, bool scale = false)
-   {
-      this->changeObj(number(id), newVal, scale);
-   }
+    int idx = nRows();
+    int oldColNumber = nCols();
 
-   /// Changes objective vector to \p newObj. \p scale determines whether the new data should be scaled
-   virtual void changeMaxObj(const VectorBase<R>& newObj, bool scale = false)
-   {
-      assert(maxObj().dim() == newObj.dim());
+    LPRowSetBase<R>::add(lhsValue, rowValues, rowIndices, rowSize, rhsValue);
+
+    // now insert nonzeros to column file also
+    for (int j = rowSize - 1; j >= 0; --j) {
+      const S &val = rowValues[j];
+      int i = rowIndices[j];
 
-      if(scale)
-      {
-         assert(_isScaled);
-         assert(lp_scaler);
+      // create new columns if required
+      if (i >= nCols()) {
+        LPColBase<R> empty;
 
-         for(int i = 0; i < maxObj().dim(); i++)
-            LPColSetBase<R>::maxObj_w(i) = lp_scaler->scaleObj(*this, i, newObj[i]);
-      }
+        for (int k = nCols(); k <= i; ++k)
+          LPColSetBase<R>::add(empty);
+      }
+
+      assert(i < nCols());
+      LPColSetBase<R>::add2(i, 1, &idx, &val);
+    }
+
+    addedRows(1);
+    addedCols(nCols() - oldColNumber);
+  }
+
+  /// Adds \p row to LPRowSetBase.
+  virtual void addRow(SPxRowId &id, const LPRowBase<R> &row,
+                      bool scale = false) {
+    addRow(row, scale);
+    id = rId(nRows() - 1);
+  }
+
+  ///
+  virtual void addRows(const LPRowSetBase<R> &pset, bool scale = false) {
+    doAddRows(pset, scale);
+  }
+
+  ///
+  template <class S>
+  void addRows(const S *lhsValues, const S *rowValues, const int *rowIndices,
+               const int *rowStarts, const int *rowLengths, const int numRows,
+               const int numValues, const S *rhsValues) {
+    assert(lhsValues != 0);
+    assert(numValues <= 0 || rowValues != 0);
+    assert(numValues <= 0 || rowIndices != 0);
+    assert(numValues <= 0 || rowStarts != 0);
+    assert(numValues <= 0 || rowLengths != 0);
+    assert(rhsValues != 0);
+
+    int i, j, k, idx;
+    SVectorBase<R> *col;
+    DataArray<int> newCols(nCols());
+    int oldRowNumber = nRows();
+    int oldColNumber = nCols();
+
+    LPRowSetBase<R>::memRemax(oldRowNumber + numRows);
+
+    for (i = 0; i < numRows; i++) {
+      assert(numValues <= 0 || rowStarts[i] + rowLengths[i] <= numValues);
+
+      if (numValues <= 0)
+        LPRowSetBase<R>::add(&(lhsValues[i]), (S *)0, (int *)0, 0,
+                             &(rhsValues[i]));
       else
-         LPColSetBase<R>::maxObj_w() = newObj;
-
-      assert(isConsistent());
-   }
+        LPRowSetBase<R>::add(&(lhsValues[i]), &(rowValues[rowStarts[i]]),
+                             &(rowIndices[rowStarts[i]]), rowLengths[i],
+                             &(rhsValues[i]));
+    }
+
+    assert(LPRowSetBase<R>::isConsistent());
+    assert(LPColSetBase<R>::isConsistent());
+
+    // count additional nonzeros per column
+    for (i = nCols() - 1; i >= 0; --i)
+      newCols[i] = 0;
+
+    if (numValues > 0) {
+      for (i = 0; i < numRows; i++) {
+        for (j = rowStarts[i]; j < rowStarts[i] + rowLengths[i]; j++) {
+          ///@todo implement the addition of new columns as in doAddRows()
+          assert(rowIndices[j] >= 0);
+          assert(rowIndices[j] < oldColNumber);
+          newCols[rowIndices[j]]++;
+        }
+      }
+    }
+
+    // extend columns as required (backward because of memory efficiency
+    // reasons)
+    for (i = nCols() - 1; i >= 0; --i) {
+      if (newCols[i] > 0) {
+        int len = newCols[i] + colVector(i).size();
+        LPColSetBase<R>::xtend(i, len);
+
+        /* preset the sizes: beware that this can irritate a consistency check
+         * call from xtend(). We need to set the sizes here, because a possible
+         * garbage collection called from xtend might destroy the sizes again.
+         */
+        colVector_w(i).set_size(len);
+      }
+    }
+
+    // insert new elements to column file
+    for (i = nRows() - 1; i >= oldRowNumber; --i) {
+      const SVectorBase<R> &vec = rowVector(i);
+
+      for (j = vec.size() - 1; j >= 0; --j) {
+        k = vec.index(j);
+        col = &colVector_w(k);
+        idx = col->size() - newCols[k];
+        assert(newCols[k] > 0);
+        assert(idx >= 0);
+        newCols[k]--;
+        col->index(idx) = i;
+        col->value(idx) = vec.value(j);
+      }
+    }
 
-   /// changes \p i 'th objective vector element to \p newVal. \p scale determines whether the new data should be scaled
-   virtual void changeMaxObj(int i, const R& newVal, bool scale = false)
-   {
-      if(scale)
-      {
-         assert(_isScaled);
-         assert(lp_scaler);
-         LPColSetBase<R>::maxObj_w(i) = lp_scaler->scaleObj(*this, i, newVal);
-      }
-      else
-         LPColSetBase<R>::maxObj_w(i) = newVal;
+#ifndef NDEBUG
 
-      assert(isConsistent());
-   }
+    for (i = 0; i < nCols(); ++i)
+      assert(newCols[i] == 0);
 
-   /// changes \p i 'th objective vector element to \p newVal.
-   template < class S >
-   void changeMaxObj(int i, const S* newVal)
-   {
-      LPColSetBase<R>::maxObj_w(i) = *newVal;
-      assert(isConsistent());
-   }
+#endif
 
-   /// Changes objective value of column with identifier \p id to \p newVal. \p scale determines whether the new data should be scaled
-   virtual void changeMaxObj(SPxColId id, const R& newVal, bool scale = false)
-   {
-      changeMaxObj(number(id), newVal, scale);
-   }
+    assert(SPxLPBase<R>::isConsistent());
+
+    assert(numRows == nRows() - oldRowNumber);
+    addedRows(nRows() - oldRowNumber);
+    addedCols(nCols() - oldColNumber);
+  }
+
+  /// adds all LPRowBase%s of \p pset to LPRowSetBase.
+  virtual void addRows(SPxRowId id[], const LPRowSetBase<R> &set,
+                       bool scale = false) {
+    int i = nRows();
+    addRows(set, scale);
+
+    for (int j = 0; i < nRows(); ++i, ++j)
+      id[j] = rId(i);
+  }
+
+  ///
+  virtual void addCol(const LPColBase<R> &col, bool scale = false) {
+    doAddCol(col, scale);
+  }
+
+  ///
+  virtual void addCol(const R &objValue, const R &lowerValue,
+                      const SVectorBase<R> &colVec, const R &upperValue,
+                      bool scale = false) {
+    doAddCol(objValue, lowerValue, colVec, upperValue, scale);
+  }
+
+  ///
+  template <class S>
+  void addCol(const S *objValue, const S *lowerValue, const S *colValues,
+              const int *colIndices, int colSize, const S *upperValue) {
+    int idx = nCols();
+    int oldRowNumber = nRows();
+
+    LPColSetBase<R>::add(objValue, lowerValue, colValues, colIndices, colSize,
+                         upperValue);
+
+    if (thesense != MAXIMIZE)
+      LPColSetBase<R>::maxObj_w(idx) *= -1;
+
+    // now insert nonzeros to column file also
+    for (int j = colSize - 1; j >= 0; --j) {
+      const S &val = colValues[j];
+      int i = colIndices[j];
+
+      // create new rows if required
+      if (i >= nRows()) {
+        LPRowBase<R> empty;
+
+        for (int k = nRows(); k <= i; ++k)
+          LPRowSetBase<R>::add(empty);
+      }
+
+      assert(i < nRows());
+      LPRowSetBase<R>::add2(i, 1, &idx, &val);
+    }
+
+    addedCols(1);
+    addedRows(nRows() - oldRowNumber);
+  }
+
+  /// Adds \p col to LPColSetVBase.
+  virtual void addCol(SPxColId &id, const LPColBase<R> &col,
+                      bool scale = false) {
+    addCol(col, scale);
+    id = cId(nCols() - 1);
+  }
+
+  ///
+  virtual void addCols(const LPColSetBase<R> &pset, bool scale = false) {
+    doAddCols(pset, scale);
+  }
+
+  ///
+  template <class S>
+  void addCols(const S *objValue, const S *lowerValues, const S *colValues,
+               const int *colIndices, const int *colStarts,
+               const int *colLengths, const int numCols, const int numValues,
+               const S *upperValues) {
+    assert(lowerValues != 0);
+    assert(numValues <= 0 || colValues != 0);
+    assert(numValues <= 0 || colIndices != 0);
+    assert(numValues <= 0 || colStarts != 0);
+    assert(numValues <= 0 || colLengths != 0);
+    assert(upperValues != 0);
+
+    int i, j, k, idx;
+    SVectorBase<R> *row;
+    DataArray<int> newRows(nRows());
+    int oldColNumber = nCols();
+    int oldRowNumber = nRows();
+    idx = nCols();
+
+    LPColSetBase<R>::memRemax(oldColNumber + numCols);
+
+    for (i = 0; i < numCols; i++) {
+      assert(numValues <= 0 || colStarts[i] + colLengths[i] <= numValues);
+
+      if (numValues <= 0)
+        LPColSetBase<R>::add(&(objValue[i]), &(lowerValues[i]), (S *)0,
+                             (int *)0, 0, &(upperValues[i]));
+      else
+        LPColSetBase<R>::add(
+            &(objValue[i]), &(lowerValues[i]), &(colValues[colStarts[i]]),
+            &(colIndices[colStarts[i]]), colLengths[i], &(upperValues[i]));
+
+      if (thesense != MAXIMIZE)
+        LPColSetBase<R>::maxObj_w(idx + i) *= -1;
+    }
+
+    assert(LPColSetBase<R>::isConsistent());
+    assert(LPRowSetBase<R>::isConsistent());
+
+    // count additional nonzeros per rows
+    for (i = nRows() - 1; i >= 0; --i)
+      newRows[i] = 0;
+
+    for (i = numValues - 1; i >= 0; --i) {
+      ///@todo implement the addition of new rows as in doAddCols()
+      assert(colIndices[i] >= 0);
+      assert(colIndices[i] < oldRowNumber);
+      newRows[colIndices[i]]++;
+    }
+
+    // extend rows as required (backward because of memory efficiency reasons)
+    for (i = nRows() - 1; i >= 0; --i) {
+      if (newRows[i] > 0) {
+        int len = newRows[i] + rowVector(i).size();
+        LPRowSetBase<R>::xtend(i, len);
+
+        /* preset the sizes: beware that this can irritate a consistency check
+         * call from xtend(). We need to set the sizes here, because a possible
+         * garbage collection called from xtend might destroy the sizes again.
+         */
+        rowVector_w(i).set_size(len);
+      }
+    }
+
+    // insert new elements to row file
+    for (i = nCols() - 1; i >= oldColNumber; --i) {
+      const SVectorBase<R> &vec = colVector(i);
+
+      for (j = vec.size() - 1; j >= 0; --j) {
+        k = vec.index(j);
+        row = &rowVector_w(k);
+        idx = row->size() - newRows[k];
+        assert(newRows[k] > 0);
+        assert(idx >= 0);
+        newRows[k]--;
+        row->index(idx) = i;
+        row->value(idx) = vec.value(j);
+      }
+    }
 
-   /// Changes vector of lower bounds to \p newLower. \p scale determines whether the new data should be scaled
-   virtual void changeLower(const VectorBase<R>& newLower, bool scale = false)
-   {
-      assert(lower().dim() == newLower.dim());
+#ifndef NDEBUG
 
-      if(scale)
-      {
-         assert(_isScaled);
-         assert(lp_scaler);
+    for (i = 0; i < nRows(); ++i)
+      assert(newRows[i] == 0);
 
-         for(int i = 0; i < lower().dim(); i++)
-            LPColSetBase<R>::lower_w(i) = lp_scaler->scaleLower(*this, i, newLower[i]);
-      }
-      else
-         LPColSetBase<R>::lower_w() = newLower;
+#endif
 
-      assert(isConsistent());
-   }
+    assert(SPxLPBase<R>::isConsistent());
 
-   /// changes \p i 'th lower bound to \p newLower. \p scale determines whether the new data should be scaled
-   virtual void changeLower(int i, const R& newLower, bool scale = false)
-   {
-      if(scale && newLower > R(-infinity))
-      {
-         assert(_isScaled);
-         assert(lp_scaler);
-         LPColSetBase<R>::lower_w(i) = lp_scaler->scaleLower(*this, i, newLower);
-      }
-      else
-         LPColSetBase<R>::lower_w(i) = newLower;
+    assert(numCols == nCols() - oldColNumber);
+    addedCols(nCols() - oldColNumber);
+    addedRows(nRows() - oldRowNumber);
+  }
 
-      assert(isConsistent());
-   }
+  /// Adds all LPColBase%s of \p set to LPColSetBase.
+  virtual void addCols(SPxColId id[], const LPColSetBase<R> &set,
+                       bool scale = false) {
 
-   /// changes \p i 'th lower bound to \p newLower.
-   template < class S >
-   void changeLower(int i, const S* newLower)
-   {
-      LPColSetBase<R>::lower_w(i) = *newLower;
-      assert(isConsistent());
-   }
+    int i = nCols();
+    addCols(set, scale);
 
-   /// changes lower bound of column with identifier \p id to \p newLower. \p scale determines whether the new data should be scaled
-   virtual void changeLower(SPxColId id, const R& newLower, bool scale = false)
-   {
-      changeLower(number(id), newLower, scale);
-   }
+    for (int j = 0; i < nCols(); ++i, ++j)
+      id[j] = cId(i);
+  }
 
-   /// Changes vector of upper bounds to \p newUpper. \p scale determines whether the new data should be scaled
-   virtual void changeUpper(const VectorBase<R>& newUpper, bool scale = false)
-   {
-      assert(upper().dim() == newUpper.dim());
+  ///@}
 
-      if(scale)
-      {
-         assert(_isScaled);
-         assert(lp_scaler);
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Shrinking */
+  ///@{
 
-         for(int i = 0; i < upper().dim(); i++)
-            LPColSetBase<R>::upper_w(i) = lp_scaler->scaleUpper(*this, i, newUpper[i]);
-      }
-      else
-         LPColSetBase<R>::upper_w() = newUpper;
+  /// Removes \p i 'th row.
+  virtual void removeRow(int i) {
+    if (i < 0)
+      return;
 
-      assert(isConsistent());
-   }
+    doRemoveRow(i);
+  }
 
-   /// Changes \p i 'th upper bound to \p newUpper. \p scale determines whether the new data should be scaled
-   virtual void changeUpper(int i, const R& newUpper, bool scale = false)
-   {
-      if(scale && newUpper < R(infinity))
-      {
-         assert(_isScaled);
-         assert(lp_scaler);
-         LPColSetBase<R>::upper_w(i) = lp_scaler->scaleUpper(*this, i, newUpper);
-      }
-      else
-         LPColSetBase<R>::upper_w(i) = newUpper;
+  /// Removes row with identifier \p id.
+  virtual void removeRow(SPxRowId id) { removeRow(number(id)); }
 
-      assert(isConsistent());
-   }
+  /// Removes multiple rows.
+  /** This method removes all LPRowBase%s from the SPxLPBase with an index \p i
+   * such that \p perm[i] < 0. Upon completion, \p perm[i] >= 0 indicates the
+   * new index where the \p i'th LPRowBase<R> has been moved to due to this
+   *  removal. Note that \p perm must point to an array of at least #nRows()
+   * ints.
+   */
+  virtual void removeRows(int perm[]) { doRemoveRows(perm); }
 
-   /// Changes \p i 'th upper bound to \p newUpper.
-   template < class S >
-   void changeUpper(int i, const S* newUpper)
-   {
-      LPColSetBase<R>::upper_w(i) = *newUpper;
-      assert(isConsistent());
-   }
-
-   /// Changes upper bound of column with identifier \p id to \p newLower. \p scale determines whether the new data should be scaled
-   virtual void changeUpper(SPxColId id, const R& newUpper, bool scale = false)
-   {
-      changeUpper(number(id), newUpper, scale);
-   }
-
-   /// Changes variable bounds to \p newLower and \p newUpper. \p scale determines whether the new data should be scaled
-   virtual void changeBounds(const VectorBase<R>& newLower, const VectorBase<R>& newUpper,
-                             bool scale = false)
-   {
-      changeLower(newLower, scale);
-      changeUpper(newUpper, scale);
-      assert(isConsistent());
-   }
+  ///
+  virtual void removeRows(SPxRowId id[], int n, int perm[] = 0) {
 
-   /// Changes bounds of column \p i to \p newLower and \p newUpper. \p scale determines whether the new data should be scaled
-   virtual void changeBounds(int i, const R& newLower, const R& newUpper, bool scale = false)
-   {
-      changeLower(i, newLower, scale);
-      changeUpper(i, newUpper, scale);
-      assert(isConsistent());
-   }
-
-   /// Changes bounds of column \p i to \p newLower and \p newUpper.
-   template < class S >
-   void changeBounds(int i, const S* newLower, const S* newUpper)
-   {
-      LPColSetBase<R>::lower_w(i) = *newLower;
-      LPColSetBase<R>::upper_w(i) = *newUpper;
-      assert(isConsistent());
-   }
+    if (perm == 0) {
+      DataArray<int> p(nRows());
+      removeRows(id, n, p.get_ptr());
+      return;
+    }
 
-   /// Changes bounds of column with identifier \p id. \p scale determines whether the new data should be scaled
-   virtual void changeBounds(SPxColId id, const R& newLower, const R& newUpper, bool scale = false)
-   {
-      changeBounds(number(id), newLower, newUpper, scale);
-   }
+    for (int i = nRows() - 1; i >= 0; --i)
+      perm[i] = i;
 
-   /// Changes left hand side vector for constraints to \p newLhs. \p scale determines whether the new data should be scaled
-   virtual void changeLhs(const VectorBase<R>& newLhs, bool scale = false)
-   {
-      assert(lhs().dim() == newLhs.dim());
+    while (n--)
+      perm[number(id[n])] = -1;
 
-      if(scale)
-      {
-         assert(_isScaled);
-         assert(lp_scaler);
+    removeRows(perm);
+  }
 
-         for(int i = 0; i < lhs().dim(); i++)
-            LPRowSetBase<R>::lhs_w(i) = lp_scaler->scaleLhs(*this, i, newLhs[i]);
-      }
-      else
-         LPRowSetBase<R>::lhs_w() = newLhs;
+  /// Removes \p n LPRowBase%s.
+  /** Removing multiple rows with one method invocation is available in two
+   * flavours. An array \p perm can be passed as third argument or not. If
+   * given, \p perm must be an array at least of size #nRows(). It is used to
+   * return the permutations resulting from this removal: \p perm[i] < 0
+   * indicates, that the element to index \p i has been removed.  Otherwise, \p
+   * perm[i] is the new index of the element with index \p i before the removal.
+   */
+  virtual void removeRows(int nums[], int n, int perm[] = 0) {
 
-      assert(isConsistent());
-   }
+    if (perm == 0) {
+      DataArray<int> p(nRows());
+      removeRows(nums, n, p.get_ptr());
+      return;
+    }
 
-   /// Changes \p i 'th left hand side value to \p newLhs. \p scale determines whether the new data should be scaled
-   virtual void changeLhs(int i, const R& newLhs, bool scale = false)
-   {
-      if(scale && newLhs > R(-infinity))
-      {
-         assert(_isScaled);
-         assert(lp_scaler);
-         LPRowSetBase<R>::lhs_w(i) = lp_scaler->scaleLhs(*this, i, newLhs);
-      }
-      else
-         LPRowSetBase<R>::lhs_w(i) = newLhs;
+    for (int i = nRows() - 1; i >= 0; --i)
+      perm[i] = i;
 
-      assert(isConsistent());
-   }
+    while (n--)
+      perm[nums[n]] = -1;
 
-   /// Changes \p i 'th left hand side value to \p newLhs.
-   template < class S >
-   void changeLhs(int i, const S* newLhs)
-   {
-      LPRowSetBase<R>::lhs_w(i) = *newLhs;
-      assert(isConsistent());
-   }
+    removeRows(perm);
+  }
 
-   /// Changes left hand side value for row with identifier \p id. \p scale determines whether the new data should be scaled
-   virtual void changeLhs(SPxRowId id, const R& newLhs, bool scale = false)
-   {
-      changeLhs(number(id), newLhs, scale);
-   }
+  /// Removes rows from \p start to \p end (including both).
+  virtual void removeRowRange(int start, int end, int perm[] = 0) {
 
-   /// Changes right hand side vector for constraints to \p newRhs. \p scale determines whether the new data should be scaled
-   virtual void changeRhs(const VectorBase<R>& newRhs, bool scale = false)
-   {
-      assert(rhs().dim() == newRhs.dim());
+    if (perm == 0) {
+      int i = end - start + 1;
+      DataArray<int> p(i);
 
-      if(scale)
-      {
-         assert(_isScaled);
-         assert(lp_scaler);
+      while (--i >= 0)
+        p[i] = start + i;
 
-         for(int i = 0; i < rhs().dim(); i++)
-            LPRowSetBase<R>::rhs_w(i) = lp_scaler->scaleRhs(*this, i, newRhs[i]);
-      }
-      else
-         LPRowSetBase<R>::rhs_w() = newRhs;
+      removeRows(p.get_ptr(), end - start + 1);
+      return;
+    }
 
-      assert(isConsistent());
-   }
+    int i;
 
-   /// Changes \p i 'th right hand side value to \p newRhs. \p scale determines whether the new data should be scaled
-   virtual void changeRhs(int i, const R& newRhs, bool scale = false)
-   {
-      if(scale && newRhs < R(infinity))
-      {
-         assert(_isScaled);
-         assert(lp_scaler);
-         LPRowSetBase<R>::rhs_w(i) = lp_scaler->scaleRhs(*this, i, newRhs);
-      }
-      else
-         LPRowSetBase<R>::rhs_w(i) = newRhs;
+    for (i = 0; i < start; ++i)
+      perm[i] = i;
 
-      assert(isConsistent());
-   }
-
-   /// Changes right hand side value for row with identifier \p id. \p scale determines whether the new data should be scaled
-   virtual void changeRhs(SPxRowId id, const R& newRhs, bool scale = false)
-   {
-      changeRhs(number(id), newRhs, scale);
-   }
-
-   /// Changes left and right hand side vectors. \p scale determines whether the new data should be scaled
-   virtual void changeRange(const VectorBase<R>& newLhs, const VectorBase<R>& newRhs,
-                            bool scale = false)
-   {
-      changeLhs(newLhs, scale);
-      changeRhs(newRhs, scale);
-      assert(isConsistent());
-   }
+    for (; i <= end; ++i)
+      perm[i] = -1;
 
-   /// Changes left and right hand side of row \p i. \p scale determines whether the new data should be scaled
-   virtual void changeRange(int i, const R& newLhs, const R& newRhs, bool scale = false)
-   {
-      changeLhs(i, newLhs, scale);
-      changeRhs(i, newRhs, scale);
-      assert(isConsistent());
-   }
-
-   /// Changes left and right hand side of row \p i.
-   template < class S >
-   void changeRange(int i, const S* newLhs, const S* newRhs)
-   {
-      LPRowSetBase<R>::lhs_w(i) = *newLhs;
-      LPRowSetBase<R>::rhs_w(i) = *newRhs;
-      assert(isConsistent());
-   }
+    for (; i < nRows(); ++i)
+      perm[i] = i;
 
-   /// Changes left and right hand side of row with identifier \p id. \p scale determines whether the new data should be scaled
-   virtual void changeRange(SPxRowId id, const R& newLhs, const R& newRhs, bool scale = false)
-   {
-      changeRange(number(id), newLhs, newRhs, scale);
-   }
+    removeRows(perm);
+  }
 
-   /// Changes row objective function vector to \p newRowObj. \p scale determines whether the new data should be scaled
-   virtual void changeRowObj(const VectorBase<R>& newRowObj, bool scale = false)
-   {
-      assert(maxRowObj().dim() == newRowObj.dim());
-      LPRowSetBase<R>::obj_w() = newRowObj;
+  /// Removes \p i 'th column.
+  virtual void removeCol(int i) {
+    if (i < 0)
+      return;
 
-      if(spxSense() == MINIMIZE)
-         LPRowSetBase<R>::obj_w() *= -1;
+    doRemoveCol(i);
+  }
 
-      assert(isConsistent());
-   }
+  /// Removes column with identifier \p id.
+  virtual void removeCol(SPxColId id) { removeCol(number(id)); }
 
-   /// Changes \p i 'th row objective function value to \p newRowObj. \p scale determines whether the new data should be scaled
-   virtual void changeRowObj(int i, const R& newRowObj, bool scale = false)
-   {
-      LPRowSetBase<R>::obj_w(i) = newRowObj;
+  /// Removes multiple columns.
+  /** This method removes all LPColBase%s from the SPxLPBase with an index \p i
+   * such that \p perm[i] < 0. Upon completion, \p perm[i] >= 0 indicates the
+   * new index where the \p i 'th LPColBase has been moved to due to this
+   *  removal. Note, that \p perm must point to an array of at least #nCols()
+   * ints.
+   */
+  virtual void removeCols(int perm[]) { doRemoveCols(perm); }
 
-      if(spxSense() == MINIMIZE)
-         LPRowSetBase<R>::obj_w(i) *= -1;
+  ///
+  virtual void removeCols(SPxColId id[], int n, int perm[] = 0) {
+
+    if (perm == 0) {
+      DataArray<int> p(nCols());
+      removeCols(id, n, p.get_ptr());
+      return;
+    }
+
+    for (int i = nCols() - 1; i >= 0; --i)
+      perm[i] = i;
+
+    while (n--)
+      perm[number(id[n])] = -1;
+
+    removeCols(perm);
+  }
+
+  /// Removes \p n LPCols.
+  /** Removing multiple columns with one method invocation is available in two
+   * flavours. An array \p perm can be passed as third argument or not. If
+   * given, \p perm must be an array at least of size #nCols(). It is used to
+   * return the permutations resulting from this removal: \p perm[i] < 0
+   * indicates, that the element to index \p i has been removed.  Otherwise, \p
+   * perm[i] is the new index of the element with index \p i before the removal.
+   */
+  virtual void removeCols(int nums[], int n, int perm[] = 0) {
+
+    if (perm == 0) {
+      DataArray<int> p(nCols());
+      removeCols(nums, n, p.get_ptr());
+      return;
+    }
+
+    for (int i = nCols() - 1; i >= 0; --i)
+      perm[i] = i;
+
+    while (n--)
+      perm[nums[n]] = -1;
+
+    removeCols(perm);
+  }
 
-      assert(isConsistent());
-   }
-
-   /// Changes row objective function value for row with identifier \p id. \p scale determines whether the new data should be scaled
-   virtual void changeRowObj(SPxRowId id, const R& newRowObj, bool scale = false)
-   {
-      changeRowObj(number(id), newRowObj, scale);
-   }
-
-   /// Clears row objective function values for all rows
-   virtual void clearRowObjs()
-   {
-      LPRowSetBase<R>::obj_w().clear();
-   }
-
-   /// Replaces \p i 'th row of LP with \p newRow. \p scale determines whether the new data should be scaled
-   virtual void changeRow(int n, const LPRowBase<R>& newRow, bool scale = false)
-   {
-      if(n < 0)
-         return;
-
-      int j;
-      SVectorBase<R>& row = rowVector_w(n);
-
-      for(j = row.size() - 1; j >= 0; --j)
-      {
-         SVectorBase<R>& col = colVector_w(row.index(j));
-         int position = col.pos(n);
+  /// Removes columns from \p start to \p end (including both).
+  virtual void removeColRange(int start, int end, int perm[] = 0) {
+
+    if (perm == 0) {
+      int i = end - start + 1;
+      DataArray<int> p(i);
+
+      while (--i >= 0)
+        p[i] = start + i;
+
+      removeCols(p.get_ptr(), end - start + 1);
+      return;
+    }
+
+    int i;
+
+    for (i = 0; i < start; ++i)
+      perm[i] = i;
+
+    for (; i <= end; ++i)
+      perm[i] = -1;
+
+    for (; i < nCols(); ++i)
+      perm[i] = i;
+
+    removeCols(perm);
+  }
+
+  /// clears the LP.
+  virtual void clear() {
+
+    LPRowSetBase<R>::clear();
+    LPColSetBase<R>::clear();
+    thesense = MAXIMIZE;
+    offset = 0;
+    _isScaled = false;
+    lp_scaler = nullptr;
+    LPColSetBase<R>::scaleExp.clear();
+    LPRowSetBase<R>::scaleExp.clear();
+  }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name IO */
+  ///@{
+
+  /// Reads LP in LP format from input stream \p in.
+  virtual bool readLPF(std::istream &in, NameSet *rowNames = 0,
+                       NameSet *colNames = 0, DIdxSet *intVars = 0);
+
+  /// Reads an LP in MPS format from input stream \p in.
+  virtual bool readMPS(std::istream &in, NameSet *rowNames = 0,
+                       NameSet *colNames = 0, DIdxSet *intVars = 0);
+
+  /// Reads LP in LP or MPS format from input stream \p in.
+  /**@param in       input stream.
+   * @param rowNames contains after the call the names of the constraints (rows)
+   * in the same order as the rows in the LP.  Constraints without a name (only
+   * possible with LPF files) are automatically assigned a name. Maybe 0 if the
+   * names are not needed.
+   * @param colNames contains after the call the names of the variables
+   * (columns) in the same order as the columns in the LP.  Maybe 0 if the names
+   * are not needed.
+   * @param intVars contains after the call the indices of those variables that
+   * where marked as beeing integer in the file.  Maybe 0 if the information is
+   * not needed.
+   * @todo Make sure the Id's in the NameSet%s are the same as in the LP.
+   */
+  virtual bool read(std::istream &in, NameSet *rowNames = 0,
+                    NameSet *colNames = 0, DIdxSet *intVars = 0) {
+    bool ok;
+    char c;
+
+    in.get(c);
+    in.putback(c);
+
+    /* MPS starts either with a comment mark '*' or with the keyword 'NAME' at
+     * the first column.  LPF starts either with blanks, a comment mark '\' or
+     * with the keyword "MAX" or "MIN" in upper or lower case.  There is no
+     * possible valid LPF file starting with a '*' or 'N'.
+     */
+    ok = ((c == '*') || (c == 'N')) ? readMPS(in, rowNames, colNames, intVars)
+                                    : readLPF(in, rowNames, colNames, intVars);
+
+    return ok;
+  }
+
+  /// Reads LP from a file.
+  virtual bool readFile(const char *filename, NameSet *rowNames = 0,
+                        NameSet *colNames = 0, DIdxSet *intVars = 0) {
+
+    spxifstream file(filename);
+
+    if (!file)
+      return false;
+
+    return read(file, rowNames, colNames, intVars);
+  }
+
+  /** Writes a file in LP format to \p out. If \p rowNames and \p colNames are
+   * \c NULL, default names are used for the constraints and variables. If \p
+   * intVars is not \c NULL, the variables contained in it are marked as integer
+   * in the output.
+   */
+  virtual void writeLPF(std::ostream &out, const NameSet *rowNames,
+                        const NameSet *colNames,
+                        const DIdxSet *p_intvars = 0) const;
+
+  /// Writes a file in MPS format to \p out.
+  virtual void writeMPS(std::ostream &out, const NameSet *rowNames,
+                        const NameSet *colNames,
+                        const DIdxSet *p_intvars = 0) const;
+
+  /// Write loaded LP to \p filename.
+  virtual void writeFileLPBase(const char *filename,
+                               const NameSet *rowNames = 0,
+                               const NameSet *colNames = 0,
+                               const DIdxSet *p_intvars = 0) const {
+
+    std::ofstream tmp(filename);
+    size_t len_f = strlen(filename);
+
+    if (len_f > 4 && filename[len_f - 1] == 's' && filename[len_f - 2] == 'p' &&
+        filename[len_f - 3] == 'm' && filename[len_f - 4] == '.') {
+      writeMPS(tmp, rowNames, colNames, p_intvars);
+    } else {
+      writeLPF(tmp, rowNames, colNames, p_intvars);
+    }
+  }
+
+  /** prints problem statistics */
+  void printProblemStatistics(std::ostream &os) {
+    int countLower = 0;
+    int countUpper = 0;
+    int countBoxed = 0;
+    int countFreeCol = 0;
+
+    int countEqual = 0;
+    int countLhs = 0;
+    int countRhs = 0;
+    int countRanged = 0;
+    int countFreeRow = 0;
+
+    for (int i = 0; i < nCols(); i++) {
+      bool hasLower = false;
+      bool hasUpper = false;
+
+      if (lower(i) > R(-infinity)) {
+        countLower++;
+        hasLower = true;
+      }
+
+      if (upper(i) < R(infinity)) {
+        countUpper++;
+        hasUpper = true;
+      }
+
+      if (hasUpper && hasLower) {
+        countBoxed++;
+        countLower--;
+        countUpper--;
+      }
+
+      if (!hasUpper && !hasLower)
+        countFreeCol++;
+    }
+
+    for (int i = 0; i < nRows(); i++) {
+      bool hasRhs = false;
+      bool hasLhs = false;
+
+      if (lhs(i) > R(-infinity)) {
+        countLhs++;
+        hasLhs = true;
+      }
+
+      if (rhs(i) < R(infinity)) {
+        countRhs++;
+        hasRhs = true;
+      }
+
+      if (hasRhs && hasLhs) {
+        if (EQ(lhs(i), rhs(i)))
+          countEqual++;
+        else
+          countRanged++;
+
+        countLhs--;
+        countRhs--;
+      }
+
+      if (!hasRhs && !hasLhs)
+        countFreeRow++;
+    }
+
+    SPxOut::setFixed(os);
+    os << "  Columns           : " << nCols() << "\n"
+       << "              boxed : " << countBoxed << "\n"
+       << "        lower bound : " << countLower << "\n"
+       << "        upper bound : " << countUpper << "\n"
+       << "               free : " << countFreeCol << "\n"
+       << "  Rows              : " << nRows() << "\n"
+       << "              equal : " << countEqual << "\n"
+       << "             ranged : " << countRanged << "\n"
+       << "                lhs : " << countLhs << "\n"
+       << "                rhs : " << countRhs << "\n"
+       << "               free : " << countFreeRow << "\n"
+       << "  Nonzeros          : " << nNzos() << "\n"
+       << "         per column : " << R(nNzos()) / R(nCols()) << "\n"
+       << "            per row : " << R(nNzos()) / R(nRows()) << "\n"
+       << "           sparsity : " << R(nNzos()) / R(nCols()) / R(nRows())
+       << "\n"
+       << "    min. abs. value : " << R(minAbsNzo()) << "\n"
+       << "    max. abs. value : " << R(maxAbsNzo()) << "\n";
+  }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Manipulation */
+  ///@{
+
+  /// Changes objective vector to \p newObj. \p scale determines whether the new
+  /// data should be scaled
+  virtual void changeObj(const VectorBase<R> &newObj, bool scale = false) {
+    changeMaxObj(newObj, scale);
+
+    if (spxSense() == MINIMIZE)
+      LPColSetBase<R>::maxObj_w() *= -1;
+  }
+
+  /// changes \p i 'th objective vector element to \p newVal. \p scale
+  /// determines whether the new data should be scaled
+  virtual void changeObj(int i, const R &newVal, bool scale = false) {
+    changeMaxObj(i, newVal, scale);
+
+    if (spxSense() == MINIMIZE)
+      LPColSetBase<R>::maxObj_w(i) *= -1;
+  }
+
+  /// changes \p i 'th objective vector element to \p newVal.
+  template <class S> void changeObj(int i, const S *newVal) {
+    LPColSetBase<R>::maxObj_w(i) = *newVal;
+
+    if (spxSense() == MINIMIZE)
+      LPColSetBase<R>::maxObj_w(i) *= -1;
+
+    assert(isConsistent());
+  }
+
+  /// Changes objective value of column with identifier \p id to \p newVal. \p
+  /// scale determines whether the new data should be scaled
+  virtual void changeObj(SPxColId id, const R &newVal, bool scale = false) {
+    this->changeObj(number(id), newVal, scale);
+  }
+
+  /// Changes objective vector to \p newObj. \p scale determines whether the new
+  /// data should be scaled
+  virtual void changeMaxObj(const VectorBase<R> &newObj, bool scale = false) {
+    assert(maxObj().dim() == newObj.dim());
+
+    if (scale) {
+      assert(_isScaled);
+      assert(lp_scaler);
+
+      for (int i = 0; i < maxObj().dim(); i++)
+        LPColSetBase<R>::maxObj_w(i) = lp_scaler->scaleObj(*this, i, newObj[i]);
+    } else
+      LPColSetBase<R>::maxObj_w() = newObj;
+
+    assert(isConsistent());
+  }
+
+  /// changes \p i 'th objective vector element to \p newVal. \p scale
+  /// determines whether the new data should be scaled
+  virtual void changeMaxObj(int i, const R &newVal, bool scale = false) {
+    if (scale) {
+      assert(_isScaled);
+      assert(lp_scaler);
+      LPColSetBase<R>::maxObj_w(i) = lp_scaler->scaleObj(*this, i, newVal);
+    } else
+      LPColSetBase<R>::maxObj_w(i) = newVal;
+
+    assert(isConsistent());
+  }
+
+  /// changes \p i 'th objective vector element to \p newVal.
+  template <class S> void changeMaxObj(int i, const S *newVal) {
+    LPColSetBase<R>::maxObj_w(i) = *newVal;
+    assert(isConsistent());
+  }
+
+  /// Changes objective value of column with identifier \p id to \p newVal. \p
+  /// scale determines whether the new data should be scaled
+  virtual void changeMaxObj(SPxColId id, const R &newVal, bool scale = false) {
+    changeMaxObj(number(id), newVal, scale);
+  }
+
+  /// Changes vector of lower bounds to \p newLower. \p scale determines whether
+  /// the new data should be scaled
+  virtual void changeLower(const VectorBase<R> &newLower, bool scale = false) {
+    assert(lower().dim() == newLower.dim());
+
+    if (scale) {
+      assert(_isScaled);
+      assert(lp_scaler);
+
+      for (int i = 0; i < lower().dim(); i++)
+        LPColSetBase<R>::lower_w(i) =
+            lp_scaler->scaleLower(*this, i, newLower[i]);
+    } else
+      LPColSetBase<R>::lower_w() = newLower;
+
+    assert(isConsistent());
+  }
+
+  /// changes \p i 'th lower bound to \p newLower. \p scale determines whether
+  /// the new data should be scaled
+  virtual void changeLower(int i, const R &newLower, bool scale = false) {
+    if (scale && newLower > R(-infinity)) {
+      assert(_isScaled);
+      assert(lp_scaler);
+      LPColSetBase<R>::lower_w(i) = lp_scaler->scaleLower(*this, i, newLower);
+    } else
+      LPColSetBase<R>::lower_w(i) = newLower;
+
+    assert(isConsistent());
+  }
+
+  /// changes \p i 'th lower bound to \p newLower.
+  template <class S> void changeLower(int i, const S *newLower) {
+    LPColSetBase<R>::lower_w(i) = *newLower;
+    assert(isConsistent());
+  }
+
+  /// changes lower bound of column with identifier \p id to \p newLower. \p
+  /// scale determines whether the new data should be scaled
+  virtual void changeLower(SPxColId id, const R &newLower, bool scale = false) {
+    changeLower(number(id), newLower, scale);
+  }
+
+  /// Changes vector of upper bounds to \p newUpper. \p scale determines whether
+  /// the new data should be scaled
+  virtual void changeUpper(const VectorBase<R> &newUpper, bool scale = false) {
+    assert(upper().dim() == newUpper.dim());
+
+    if (scale) {
+      assert(_isScaled);
+      assert(lp_scaler);
+
+      for (int i = 0; i < upper().dim(); i++)
+        LPColSetBase<R>::upper_w(i) =
+            lp_scaler->scaleUpper(*this, i, newUpper[i]);
+    } else
+      LPColSetBase<R>::upper_w() = newUpper;
+
+    assert(isConsistent());
+  }
+
+  /// Changes \p i 'th upper bound to \p newUpper. \p scale determines whether
+  /// the new data should be scaled
+  virtual void changeUpper(int i, const R &newUpper, bool scale = false) {
+    if (scale && newUpper < R(infinity)) {
+      assert(_isScaled);
+      assert(lp_scaler);
+      LPColSetBase<R>::upper_w(i) = lp_scaler->scaleUpper(*this, i, newUpper);
+    } else
+      LPColSetBase<R>::upper_w(i) = newUpper;
+
+    assert(isConsistent());
+  }
+
+  /// Changes \p i 'th upper bound to \p newUpper.
+  template <class S> void changeUpper(int i, const S *newUpper) {
+    LPColSetBase<R>::upper_w(i) = *newUpper;
+    assert(isConsistent());
+  }
+
+  /// Changes upper bound of column with identifier \p id to \p newLower. \p
+  /// scale determines whether the new data should be scaled
+  virtual void changeUpper(SPxColId id, const R &newUpper, bool scale = false) {
+    changeUpper(number(id), newUpper, scale);
+  }
+
+  /// Changes variable bounds to \p newLower and \p newUpper. \p scale
+  /// determines whether the new data should be scaled
+  virtual void changeBounds(const VectorBase<R> &newLower,
+                            const VectorBase<R> &newUpper, bool scale = false) {
+    changeLower(newLower, scale);
+    changeUpper(newUpper, scale);
+    assert(isConsistent());
+  }
+
+  /// Changes bounds of column \p i to \p newLower and \p newUpper. \p scale
+  /// determines whether the new data should be scaled
+  virtual void changeBounds(int i, const R &newLower, const R &newUpper,
+                            bool scale = false) {
+    changeLower(i, newLower, scale);
+    changeUpper(i, newUpper, scale);
+    assert(isConsistent());
+  }
+
+  /// Changes bounds of column \p i to \p newLower and \p newUpper.
+  template <class S>
+  void changeBounds(int i, const S *newLower, const S *newUpper) {
+    LPColSetBase<R>::lower_w(i) = *newLower;
+    LPColSetBase<R>::upper_w(i) = *newUpper;
+    assert(isConsistent());
+  }
+
+  /// Changes bounds of column with identifier \p id. \p scale determines
+  /// whether the new data should be scaled
+  virtual void changeBounds(SPxColId id, const R &newLower, const R &newUpper,
+                            bool scale = false) {
+    changeBounds(number(id), newLower, newUpper, scale);
+  }
+
+  /// Changes left hand side vector for constraints to \p newLhs. \p scale
+  /// determines whether the new data should be scaled
+  virtual void changeLhs(const VectorBase<R> &newLhs, bool scale = false) {
+    assert(lhs().dim() == newLhs.dim());
+
+    if (scale) {
+      assert(_isScaled);
+      assert(lp_scaler);
+
+      for (int i = 0; i < lhs().dim(); i++)
+        LPRowSetBase<R>::lhs_w(i) = lp_scaler->scaleLhs(*this, i, newLhs[i]);
+    } else
+      LPRowSetBase<R>::lhs_w() = newLhs;
+
+    assert(isConsistent());
+  }
+
+  /// Changes \p i 'th left hand side value to \p newLhs. \p scale determines
+  /// whether the new data should be scaled
+  virtual void changeLhs(int i, const R &newLhs, bool scale = false) {
+    if (scale && newLhs > R(-infinity)) {
+      assert(_isScaled);
+      assert(lp_scaler);
+      LPRowSetBase<R>::lhs_w(i) = lp_scaler->scaleLhs(*this, i, newLhs);
+    } else
+      LPRowSetBase<R>::lhs_w(i) = newLhs;
+
+    assert(isConsistent());
+  }
+
+  /// Changes \p i 'th left hand side value to \p newLhs.
+  template <class S> void changeLhs(int i, const S *newLhs) {
+    LPRowSetBase<R>::lhs_w(i) = *newLhs;
+    assert(isConsistent());
+  }
+
+  /// Changes left hand side value for row with identifier \p id. \p scale
+  /// determines whether the new data should be scaled
+  virtual void changeLhs(SPxRowId id, const R &newLhs, bool scale = false) {
+    changeLhs(number(id), newLhs, scale);
+  }
+
+  /// Changes right hand side vector for constraints to \p newRhs. \p scale
+  /// determines whether the new data should be scaled
+  virtual void changeRhs(const VectorBase<R> &newRhs, bool scale = false) {
+    assert(rhs().dim() == newRhs.dim());
+
+    if (scale) {
+      assert(_isScaled);
+      assert(lp_scaler);
+
+      for (int i = 0; i < rhs().dim(); i++)
+        LPRowSetBase<R>::rhs_w(i) = lp_scaler->scaleRhs(*this, i, newRhs[i]);
+    } else
+      LPRowSetBase<R>::rhs_w() = newRhs;
+
+    assert(isConsistent());
+  }
+
+  /// Changes \p i 'th right hand side value to \p newRhs. \p scale determines
+  /// whether the new data should be scaled
+  virtual void changeRhs(int i, const R &newRhs, bool scale = false) {
+    if (scale && newRhs < R(infinity)) {
+      assert(_isScaled);
+      assert(lp_scaler);
+      LPRowSetBase<R>::rhs_w(i) = lp_scaler->scaleRhs(*this, i, newRhs);
+    } else
+      LPRowSetBase<R>::rhs_w(i) = newRhs;
+
+    assert(isConsistent());
+  }
+
+  /// Changes right hand side value for row with identifier \p id. \p scale
+  /// determines whether the new data should be scaled
+  virtual void changeRhs(SPxRowId id, const R &newRhs, bool scale = false) {
+    changeRhs(number(id), newRhs, scale);
+  }
+
+  /// Changes left and right hand side vectors. \p scale determines whether the
+  /// new data should be scaled
+  virtual void changeRange(const VectorBase<R> &newLhs,
+                           const VectorBase<R> &newRhs, bool scale = false) {
+    changeLhs(newLhs, scale);
+    changeRhs(newRhs, scale);
+    assert(isConsistent());
+  }
+
+  /// Changes left and right hand side of row \p i. \p scale determines whether
+  /// the new data should be scaled
+  virtual void changeRange(int i, const R &newLhs, const R &newRhs,
+                           bool scale = false) {
+    changeLhs(i, newLhs, scale);
+    changeRhs(i, newRhs, scale);
+    assert(isConsistent());
+  }
+
+  /// Changes left and right hand side of row \p i.
+  template <class S> void changeRange(int i, const S *newLhs, const S *newRhs) {
+    LPRowSetBase<R>::lhs_w(i) = *newLhs;
+    LPRowSetBase<R>::rhs_w(i) = *newRhs;
+    assert(isConsistent());
+  }
+
+  /// Changes left and right hand side of row with identifier \p id. \p scale
+  /// determines whether the new data should be scaled
+  virtual void changeRange(SPxRowId id, const R &newLhs, const R &newRhs,
+                           bool scale = false) {
+    changeRange(number(id), newLhs, newRhs, scale);
+  }
+
+  /// Changes row objective function vector to \p newRowObj. \p scale determines
+  /// whether the new data should be scaled
+  virtual void changeRowObj(const VectorBase<R> &newRowObj,
+                            bool scale = false) {
+    assert(maxRowObj().dim() == newRowObj.dim());
+    LPRowSetBase<R>::obj_w() = newRowObj;
+
+    if (spxSense() == MINIMIZE)
+      LPRowSetBase<R>::obj_w() *= -1;
+
+    assert(isConsistent());
+  }
+
+  /// Changes \p i 'th row objective function value to \p newRowObj. \p scale
+  /// determines whether the new data should be scaled
+  virtual void changeRowObj(int i, const R &newRowObj, bool scale = false) {
+    LPRowSetBase<R>::obj_w(i) = newRowObj;
+
+    if (spxSense() == MINIMIZE)
+      LPRowSetBase<R>::obj_w(i) *= -1;
+
+    assert(isConsistent());
+  }
+
+  /// Changes row objective function value for row with identifier \p id. \p
+  /// scale determines whether the new data should be scaled
+  virtual void changeRowObj(SPxRowId id, const R &newRowObj,
+                            bool scale = false) {
+    changeRowObj(number(id), newRowObj, scale);
+  }
+
+  /// Clears row objective function values for all rows
+  virtual void clearRowObjs() { LPRowSetBase<R>::obj_w().clear(); }
+
+  /// Replaces \p i 'th row of LP with \p newRow. \p scale determines whether
+  /// the new data should be scaled
+  virtual void changeRow(int n, const LPRowBase<R> &newRow,
+                         bool scale = false) {
+    if (n < 0)
+      return;
+
+    int j;
+    SVectorBase<R> &row = rowVector_w(n);
+
+    for (j = row.size() - 1; j >= 0; --j) {
+      SVectorBase<R> &col = colVector_w(row.index(j));
+      int position = col.pos(n);
+
+      assert(position != -1);
+
+      if (position >= 0)
+        col.remove(position);
+    }
+
+    row.clear();
+
+    changeLhs(n, newRow.lhs(), scale);
+    changeRhs(n, newRow.rhs(), scale);
+    changeRowObj(n, newRow.obj(), scale);
+
+    const SVectorBase<R> &newrow = newRow.rowVector();
+
+    for (j = newrow.size() - 1; j >= 0; --j) {
+      int idx = newrow.index(j);
+      R val = newrow.value(j);
+
+      if (scale)
+        val = spxLdexp(val, LPRowSetBase<R>::scaleExp[n] +
+                                LPColSetBase<R>::scaleExp[idx]);
+
+      LPRowSetBase<R>::add2(n, 1, &idx, &val);
+      LPColSetBase<R>::add2(idx, 1, &n, &val);
+    }
+
+    assert(isConsistent());
+  }
+
+  /// Replaces row with identifier \p id with \p newRow. \p scale determines
+  /// whether the new data should be scaled
+  virtual void changeRow(SPxRowId id, const LPRowBase<R> &newRow,
+                         bool scale = false) {
+    changeRow(number(id), newRow, scale);
+  }
+
+  /// Replaces \p i 'th column of LP with \p newCol. \p scale determines whether
+  /// the new data should be scaled
+  virtual void changeCol(int n, const LPColBase<R> &newCol,
+                         bool scale = false) {
+    if (n < 0)
+      return;
+
+    int j;
+    SVectorBase<R> &col = colVector_w(n);
+
+    for (j = col.size() - 1; j >= 0; --j) {
+      SVectorBase<R> &row = rowVector_w(col.index(j));
+      int position = row.pos(n);
+
+      assert(position != -1);
+
+      if (position >= 0)
+        row.remove(position);
+    }
+
+    col.clear();
+
+    changeUpper(n, newCol.upper(), scale);
+    changeLower(n, newCol.lower(), scale);
+    changeObj(n, newCol.obj(), scale);
+
+    const SVectorBase<R> &newcol = newCol.colVector();
+
+    for (j = newcol.size() - 1; j >= 0; --j) {
+      int idx = newcol.index(j);
+      R val = newcol.value(j);
+
+      if (scale)
+        val = spxLdexp(val, LPColSetBase<R>::scaleExp[n] +
+                                LPRowSetBase<R>::scaleExp[idx]);
+
+      LPColSetBase<R>::add2(n, 1, &idx, &val);
+      LPRowSetBase<R>::add2(idx, 1, &n, &val);
+    }
+
+    assert(isConsistent());
+  }
+
+  /// Replaces column with identifier \p id with \p newCol. \p scale determines
+  /// whether the new data should be scaled
+  virtual void changeCol(SPxColId id, const LPColBase<R> &newCol,
+                         bool scale = false) {
+    changeCol(number(id), newCol, scale);
+  }
+
+  /// Changes LP element (\p i, \p j) to \p val. \p scale determines whether the
+  /// new data should be scaled
+  virtual void changeElement(int i, int j, const R &val, bool scale = false) {
+    if (i < 0 || j < 0)
+      return;
+
+    SVectorBase<R> &row = rowVector_w(i);
+    SVectorBase<R> &col = colVector_w(j);
+
+    if (isNotZero(val)) {
+      R newVal;
+
+      if (scale) {
+        assert(_isScaled);
+        assert(lp_scaler);
+        newVal = lp_scaler->scaleElement(*this, i, j, val);
+      } else
+        newVal = val;
+
+      if (row.pos(j) >= 0 && col.pos(i) >= 0) {
+        row.value(row.pos(j)) = newVal;
+        col.value(col.pos(i)) = newVal;
+      } else {
+        LPRowSetBase<R>::add2(i, 1, &j, &newVal);
+        LPColSetBase<R>::add2(j, 1, &i, &newVal);
+      }
+    } else if (row.pos(j) >= 0 && col.pos(i) >= 0) {
+      row.remove(row.pos(j));
+      col.remove(col.pos(i));
+    }
+
+    assert(isConsistent());
+  }
+
+  /// Changes LP element (\p i, \p j) to \p val.
+  template <class S> void changeElement(int i, int j, const S *val) {
+    if (i < 0 || j < 0)
+      return;
+
+    SVectorBase<R> &row = rowVector_w(i);
+    SVectorBase<R> &col = colVector_w(j);
+
+    if (mpq_get_d(*val) != R(0)) {
+      if (row.pos(j) >= 0 && col.pos(i) >= 0) {
+        row.value(row.pos(j)) = *val;
+        col.value(col.pos(i)) = *val;
+      } else {
+        LPRowSetBase<R>::add2(i, 1, &j, val);
+        LPColSetBase<R>::add2(j, 1, &i, val);
+      }
+    } else if (row.pos(j) >= 0 && col.pos(i) >= 0) {
+      row.remove(row.pos(j));
+      col.remove(col.pos(i));
+    }
+
+    assert(isConsistent());
+  }
+
+  /// Changes LP element identified by (\p rid, \p cid) to \p val. \p scale
+  /// determines whether the new data should be scaled
+  virtual void changeElement(SPxRowId rid, SPxColId cid, const R &val,
+                             bool scale = false) {
+    changeElement(number(rid), number(cid), val, scale);
+  }
+
+  /// Changes optimization sense to \p sns.
+  virtual void changeSense(SPxSense sns) {
+    if (sns != thesense) {
+      LPColSetBase<R>::maxObj_w() *= -1;
+      LPRowSetBase<R>::obj_w() *= -1;
+    }
+
+    thesense = sns;
+  }
+
+  template <typename T> void changeObjOffset(const T &o) {
+    offset = o; // Converts o into type R. Example Rational into
+                // R
+  }
+
+  /// Computes activity of the rows for a given primal vector; activity does not
+  /// need to be zero
+  /// @throw SPxInternalCodeException if the dimension of primal vector does not
+  /// match number of columns or if the
+  ///        dimension of the activity vector does not match the number of rows
+  /// \p unscaled determines whether the returned data should be unscaled (if
+  /// scaling was applied prior)
+  virtual void computePrimalActivity(const VectorBase<R> &primal,
+                                     VectorBase<R> &activity,
+                                     const bool unscaled = true) const;
+
+  /// Updates activity of the rows for a given primal vector; activity does not
+  /// need to be zero
+  /// @throw SPxInternalCodeException if the dimension of primal vector does not
+  /// match number of columns or if the
+  ///        dimension of the activity vector does not match the number of rows
+  virtual void addPrimalActivity(const SVectorBase<R> &primal,
+                                 VectorBase<R> &activity) const {
+    if (activity.dim() != nRows()) {
+      throw SPxInternalCodeException("XSPXLP03 Activity vector computing row "
+                                     "activity has wrong dimension");
+    }
+
+    for (int i = primal.size() - 1; i >= 0; i--) {
+      assert(primal.index(i) >= 0);
+      assert(primal.index(i) < nCols());
+      activity.multAdd(primal.value(i), colVector(primal.index(i)));
+    }
+  }
+
+  /// Computes "dual" activity of the columns for a given dual vector, i.e., y^T
+  /// A; activity does not need to be zero
+  /// @throw SPxInternalCodeException if dimension of dual vector does not match
+  /// number of rows or if the dimension of
+  ///        the activity vector does not match the number of columns
+  virtual void computeDualActivity(const VectorBase<R> &dual,
+                                   VectorBase<R> &activity,
+                                   const bool unscaled = true) const;
+
+  /// Updates "dual" activity of the columns for a given dual vector, i.e., y^T
+  /// A; activity does not need to be zero
+  /// @throw SPxInternalCodeException if dimension of dual vector does not match
+  /// number of rows or if the dimension of
+  ///        the activity vector does not match the number of columns
+  virtual void addDualActivity(const SVectorBase<R> &dual,
+                               VectorBase<R> &activity) const {
+    if (activity.dim() != nCols()) {
+      throw SPxInternalCodeException("XSPXLP04 Activity vector computing dual "
+                                     "activity has wrong dimension");
+    }
+
+    for (int i = dual.size() - 1; i >= 0; i--) {
+      assert(dual.index(i) >= 0);
+      assert(dual.index(i) < nRows());
+      activity.multAdd(dual.value(i), rowVector(dual.index(i)));
+    }
+  }
+
+  /// Updates "dual" activity of the columns for a given dual vector, i.e., y^T
+  /// A; activity does not need to be zero
+  /// @throw SPxInternalCodeException if dimension of dual vector does not match
+  /// number of rows or if the dimension of
+  ///        the activity vector does not match the number of columns
+  virtual void subDualActivity(const VectorBase<R> &dual,
+                               VectorBase<R> &activity) const {
+    if (dual.dim() != nRows()) {
+      throw SPxInternalCodeException("XSPXLP02 Dual vector for computing dual "
+                                     "activity has wrong dimension");
+    }
+
+    if (activity.dim() != nCols()) {
+      throw SPxInternalCodeException("XSPXLP04 Activity vector computing dual "
+                                     "activity has wrong dimension");
+    }
+
+    for (int r = 0; r < nRows(); r++) {
+      if (dual[r] != 0)
+        activity.multSub(dual[r], rowVector(r));
+    }
+  }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Construction of dual problem */
+  ///@{
+
+  /// Building the dual problem from a given LP
+  /// @note primalRows must be as large as the number of unranged primal rows +
+  /// 2 * the number of ranged primal rows.
+  ///       dualCols must have the identical size to the primal rows.
+  virtual void buildDualProblem(SPxLPBase<R> &dualLP,
+                                SPxRowId primalRowIds[] = 0,
+                                SPxColId primalColIds[] = 0,
+                                SPxRowId dualRowIds[] = 0,
+                                SPxColId dualColIds[] = 0, int *nprimalrows = 0,
+                                int *nprimalcols = 0, int *ndualrows = 0,
+                                int *ndualcols = 0);
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Miscellaneous */
+  ///@{
+
+  /// Consistency check.
+  bool isConsistent() const {
+#ifdef ENABLE_CONSISTENCY_CHECKS
 
-         assert(position != -1);
+    for (int i = nCols() - 1; i >= 0; --i) {
+      const SVectorBase<R> &v = colVector(i);
 
-         if(position >= 0)
-            col.remove(position);
-      }
+      for (int j = v.size() - 1; j >= 0; --j) {
+        const SVectorBase<R> &w = rowVector(v.index(j));
+        int n = w.pos(i);
 
-      row.clear();
+        if (n < 0)
+          return MSGinconsistent("SPxLPBase");
 
-      changeLhs(n, newRow.lhs(), scale);
-      changeRhs(n, newRow.rhs(), scale);
-      changeRowObj(n, newRow.obj(), scale);
+        if (v.value(j) != w.value(n))
+          return MSGinconsistent("SPxLPBase");
+      }
+    }
 
-      const SVectorBase<R>& newrow = newRow.rowVector();
+    for (int i = nRows() - 1; i >= 0; --i) {
+      const SVectorBase<R> &v = rowVector(i);
 
-      for(j = newrow.size() - 1; j >= 0; --j)
-      {
-         int idx = newrow.index(j);
-         R val = newrow.value(j);
+      for (int j = v.size() - 1; j >= 0; --j) {
+        const SVectorBase<R> &w = colVector(v.index(j));
+        int n = w.pos(i);
 
-         if(scale)
-            val = spxLdexp(val, LPRowSetBase<R>::scaleExp[n] + LPColSetBase<R>::scaleExp[idx]);
+        if (n < 0)
+          return MSGinconsistent("SPxLPBase");
 
-         LPRowSetBase<R>::add2(n, 1, &idx, &val);
-         LPColSetBase<R>::add2(idx, 1, &n, &val);
+        if (v.value(j) != w.value(n))
+          return MSGinconsistent("SPxLPBase");
       }
+    }
 
-      assert(isConsistent());
-   }
+    return LPRowSetBase<R>::isConsistent() && LPColSetBase<R>::isConsistent();
+#else
+    return true;
+#endif
+  }
 
-   /// Replaces row with identifier \p id with \p newRow. \p scale determines whether the new data should be scaled
-   virtual void changeRow(SPxRowId id, const LPRowBase<R>& newRow, bool scale = false)
-   {
-      changeRow(number(id), newRow, scale);
-   }
+  ///@}
 
-   /// Replaces \p i 'th column of LP with \p newCol. \p scale determines whether the new data should be scaled
-   virtual void changeCol(int n, const LPColBase<R>& newCol, bool scale = false)
-   {
-      if(n < 0)
-         return;
+protected:
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Protected write access */
+  ///@{
 
-      int j;
-      SVectorBase<R>& col = colVector_w(n);
+  /// Returns right hand side of row \p i.
+  R &rhs_w(int i) { return LPRowSetBase<R>::rhs_w(i); }
 
-      for(j = col.size() - 1; j >= 0; --j)
-      {
-         SVectorBase<R>& row = rowVector_w(col.index(j));
-         int position = row.pos(n);
+  /// Returns left hand side of row \p i.
+  R &lhs_w(int i) { return LPRowSetBase<R>::lhs_w(i); }
 
-         assert(position != -1);
+  /// Returns objective function value of row \p i.
+  R &maxRowObj_w(int i) { return LPRowSetBase<R>::obj_w(i); }
 
-         if(position >= 0)
-            row.remove(position);
-      }
+  /// Returns objective value of column \p i for maximization problem.
+  R &maxObj_w(int i) { return LPColSetBase<R>::maxObj_w(i); }
 
-      col.clear();
+  /// Returns upper bound of column \p i.
+  R &upper_w(int i) { return LPColSetBase<R>::upper_w(i); }
 
-      changeUpper(n, newCol.upper(), scale);
-      changeLower(n, newCol.lower(), scale);
-      changeObj(n, newCol.obj(), scale);
+  /// Returns lower bound of column \p i.
+  R &lower_w(int i) { return LPColSetBase<R>::lower_w(i); }
 
-      const SVectorBase<R>& newcol = newCol.colVector();
+  ///@}
 
-      for(j = newcol.size() - 1; j >= 0; --j)
-      {
-         int idx = newcol.index(j);
-         R val = newcol.value(j);
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Protected helpers */
+  ///@{
 
-         if(scale)
-            val = spxLdexp(val, LPColSetBase<R>::scaleExp[n] + LPRowSetBase<R>::scaleExp[idx]);
+  /// Returns the LP as an LPRowSetBase.
+  const LPRowSetBase<R> *lprowset() const {
+    return static_cast<const LPRowSetBase<R> *>(this);
+  }
 
-         LPColSetBase<R>::add2(n, 1, &idx, &val);
-         LPRowSetBase<R>::add2(idx, 1, &n, &val);
-      }
+  /// Returns the LP as an LPColSetBase.
+  const LPColSetBase<R> *lpcolset() const {
+    return static_cast<const LPColSetBase<R> *>(this);
+  }
 
-      assert(isConsistent());
-   }
+  /// Internal helper method.
+  virtual void doRemoveRow(int j) {
 
-   /// Replaces column with identifier \p id with \p newCol. \p scale determines whether the new data should be scaled
-   virtual void changeCol(SPxColId id, const LPColBase<R>& newCol, bool scale = false)
-   {
-      changeCol(number(id), newCol, scale);
-   }
+    const SVectorBase<R> &vec = rowVector(j);
 
-   /// Changes LP element (\p i, \p j) to \p val. \p scale determines whether the new data should be scaled
-   virtual void changeElement(int i, int j, const R& val, bool scale = false)
-   {
-      if(i < 0 || j < 0)
-         return;
+    // remove row vector from column file
+    for (int i = vec.size() - 1; i >= 0; --i) {
+      SVectorBase<R> &remvec = colVector_w(vec.index(i));
+      int position = remvec.pos(j);
 
-      SVectorBase<R>& row = rowVector_w(i);
-      SVectorBase<R>& col = colVector_w(j);
+      if (position >= 0)
+        remvec.remove(position);
+    }
 
-      if(isNotZero(val))
-      {
-         R newVal;
-
-         if(scale)
-         {
-            assert(_isScaled);
-            assert(lp_scaler);
-            newVal = lp_scaler->scaleElement(*this, i, j, val);
-         }
-         else
-            newVal = val;
-
-         if(row.pos(j) >= 0 && col.pos(i) >= 0)
-         {
-            row.value(row.pos(j)) = newVal;
-            col.value(col.pos(i)) = newVal;
-         }
-         else
-         {
-            LPRowSetBase<R>::add2(i, 1, &j, &newVal);
-            LPColSetBase<R>::add2(j, 1, &i, &newVal);
-         }
-      }
-      else if(row.pos(j) >= 0 && col.pos(i) >= 0)
-      {
-         row.remove(row.pos(j));
-         col.remove(col.pos(i));
-      }
+    // move last row to removed position
+    int idx = nRows() - 1;
 
-      assert(isConsistent());
-   }
+    if (j != idx) {
+      const SVectorBase<R> &l_vec = rowVector(idx);
 
-   /// Changes LP element (\p i, \p j) to \p val.
-   template < class S >
-   void changeElement(int i, int j, const S* val)
-   {
-      if(i < 0 || j < 0)
-         return;
+      for (int i = l_vec.size() - 1; i >= 0; --i) {
+        SVectorBase<R> &movevec = colVector_w(l_vec.index(i));
+        int position = movevec.pos(idx);
 
-      SVectorBase<R>& row = rowVector_w(i);
-      SVectorBase<R>& col = colVector_w(j);
+        assert(position != -1);
 
-      if(mpq_get_d(*val) != R(0))
-      {
-         if(row.pos(j) >= 0 && col.pos(i) >= 0)
-         {
-            row.value(row.pos(j)) = *val;
-            col.value(col.pos(i)) = *val;
-         }
-         else
-         {
-            LPRowSetBase<R>::add2(i, 1, &j, val);
-            LPColSetBase<R>::add2(j, 1, &i, val);
-         }
-      }
-      else if(row.pos(j) >= 0 && col.pos(i) >= 0)
-      {
-         row.remove(row.pos(j));
-         col.remove(col.pos(i));
+        if (position >= 0)
+          movevec.index(position) = j;
       }
+    }
 
-      assert(isConsistent());
-   }
-
-   /// Changes LP element identified by (\p rid, \p cid) to \p val. \p scale determines whether the new data should be scaled
-   virtual void changeElement(SPxRowId rid, SPxColId cid, const R& val, bool scale = false)
-   {
-      changeElement(number(rid), number(cid), val, scale);
-   }
-
-   /// Changes optimization sense to \p sns.
-   virtual void changeSense(SPxSense sns)
-   {
-      if(sns != thesense)
-      {
-         LPColSetBase<R>::maxObj_w() *= -1;
-         LPRowSetBase<R>::obj_w() *= -1;
-      }
+    LPRowSetBase<R>::remove(j);
+  }
 
-      thesense = sns;
-   }
-
-   template <typename T>
-   void changeObjOffset(const T& o)
-   {
-      offset = o;               // Converts o into type R. Example Rational into
-      // R
-   }
-
-   /// Computes activity of the rows for a given primal vector; activity does not need to be zero
-   /// @throw SPxInternalCodeException if the dimension of primal vector does not match number of columns or if the
-   ///        dimension of the activity vector does not match the number of rows
-   /// \p unscaled determines whether the returned data should be unscaled (if scaling was applied prior)
-   virtual void computePrimalActivity(const VectorBase<R>& primal, VectorBase<R>& activity,
-                                      const bool unscaled = true) const;
-
-   /// Updates activity of the rows for a given primal vector; activity does not need to be zero
-   /// @throw SPxInternalCodeException if the dimension of primal vector does not match number of columns or if the
-   ///        dimension of the activity vector does not match the number of rows
-   virtual void addPrimalActivity(const SVectorBase<R>& primal, VectorBase<R>& activity) const
-   {
-      if(activity.dim() != nRows())
-      {
-         throw SPxInternalCodeException("XSPXLP03 Activity vector computing row activity has wrong dimension");
-      }
+  /// Internal helper method.
+  virtual void doRemoveRows(int perm[]) {
+    int j = nCols();
 
-      for(int i = primal.size() - 1; i >= 0; i--)
-      {
-         assert(primal.index(i) >= 0);
-         assert(primal.index(i) < nCols());
-         activity.multAdd(primal.value(i), colVector(primal.index(i)));
-      }
-   }
-
-   /// Computes "dual" activity of the columns for a given dual vector, i.e., y^T A; activity does not need to be zero
-   /// @throw SPxInternalCodeException if dimension of dual vector does not match number of rows or if the dimension of
-   ///        the activity vector does not match the number of columns
-   virtual void computeDualActivity(const VectorBase<R>& dual, VectorBase<R>& activity,
-                                    const bool unscaled = true) const;
-
-   /// Updates "dual" activity of the columns for a given dual vector, i.e., y^T A; activity does not need to be zero
-   /// @throw SPxInternalCodeException if dimension of dual vector does not match number of rows or if the dimension of
-   ///        the activity vector does not match the number of columns
-   virtual void addDualActivity(const SVectorBase<R>& dual, VectorBase<R>& activity) const
-   {
-      if(activity.dim() != nCols())
-      {
-         throw SPxInternalCodeException("XSPXLP04 Activity vector computing dual activity has wrong dimension");
-      }
+    LPRowSetBase<R>::remove(perm);
 
-      for(int i = dual.size() - 1; i >= 0; i--)
-      {
-         assert(dual.index(i) >= 0);
-         assert(dual.index(i) < nRows());
-         activity.multAdd(dual.value(i), rowVector(dual.index(i)));
-      }
-   }
-
-   /// Updates "dual" activity of the columns for a given dual vector, i.e., y^T A; activity does not need to be zero
-   /// @throw SPxInternalCodeException if dimension of dual vector does not match number of rows or if the dimension of
-   ///        the activity vector does not match the number of columns
-   virtual void subDualActivity(const VectorBase<R>& dual, VectorBase<R>& activity) const
-   {
-      if(dual.dim() != nRows())
-      {
-         throw SPxInternalCodeException("XSPXLP02 Dual vector for computing dual activity has wrong dimension");
-      }
+    for (int i = 0; i < j; ++i) {
+      SVectorBase<R> &vec = colVector_w(i);
 
-      if(activity.dim() != nCols())
-      {
-         throw SPxInternalCodeException("XSPXLP04 Activity vector computing dual activity has wrong dimension");
-      }
+      for (int k = vec.size() - 1; k >= 0; --k) {
+        int idx = vec.index(k);
 
-      for(int r = 0; r < nRows(); r++)
-      {
-         if(dual[r] != 0)
-            activity.multSub(dual[r], rowVector(r));
+        if (perm[idx] < 0)
+          vec.remove(k);
+        else
+          vec.index(k) = perm[idx];
       }
-   }
+    }
+  }
 
-   ///@}
+  /// Internal helper method.
+  virtual void doRemoveCol(int j) {
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Construction of dual problem */
-   ///@{
+    const SVectorBase<R> &vec = colVector(j);
+    int i;
 
-   /// Building the dual problem from a given LP
-   /// @note primalRows must be as large as the number of unranged primal rows + 2 * the number of ranged primal rows.
-   ///       dualCols must have the identical size to the primal rows.
-   virtual void buildDualProblem(SPxLPBase<R>& dualLP, SPxRowId primalRowIds[] = 0,
-                                 SPxColId primalColIds[] = 0,
-                                 SPxRowId dualRowIds[] = 0, SPxColId dualColIds[] = 0, int* nprimalrows = 0, int* nprimalcols = 0,
-                                 int* ndualrows = 0, int* ndualcols = 0);
+    // remove column vector from row file
+    for (i = vec.size() - 1; i >= 0; --i) {
+      SVectorBase<R> &remvec = rowVector_w(vec.index(i));
+      int position = remvec.pos(j);
 
-   ///@}
+      assert(position != -1);
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Miscellaneous */
-   ///@{
+      if (position >= 0)
+        remvec.remove(position);
+    }
 
-   /// Consistency check.
-   bool isConsistent() const
-   {
-#ifdef ENABLE_CONSISTENCY_CHECKS
+    // move last column to removed position
+    int idx = nCols() - 1;
 
-      for(int i = nCols() - 1; i >= 0; --i)
-      {
-         const SVectorBase<R>& v = colVector(i);
+    if (j != idx) {
+      const SVectorBase<R> &l_vec = colVector(idx);
 
-         for(int j = v.size() - 1; j >= 0; --j)
-         {
-            const SVectorBase<R>& w = rowVector(v.index(j));
-            int n = w.pos(i);
+      for (i = l_vec.size() - 1; i >= 0; --i) {
+        SVectorBase<R> &movevec = rowVector_w(l_vec.index(i));
+        int position = movevec.pos(idx);
 
-            if(n < 0)
-               return MSGinconsistent("SPxLPBase");
+        assert(position != -1);
 
-            if(v.value(j) != w.value(n))
-               return MSGinconsistent("SPxLPBase");
-         }
+        if (position >= 0)
+          movevec.index(position) = j;
       }
+    }
 
-      for(int i = nRows() - 1; i >= 0; --i)
-      {
-         const SVectorBase<R>& v = rowVector(i);
+    LPColSetBase<R>::remove(j);
+  }
 
-         for(int j = v.size() - 1; j >= 0; --j)
-         {
-            const SVectorBase<R>& w = colVector(v.index(j));
-            int n = w.pos(i);
+  /// Internal helper method.
+  virtual void doRemoveCols(int perm[]) {
+    int nrows = nRows();
 
-            if(n < 0)
-               return MSGinconsistent("SPxLPBase");
+    LPColSetBase<R>::remove(perm);
 
-            if(v.value(j) != w.value(n))
-               return MSGinconsistent("SPxLPBase");
-         }
-      }
+    for (int i = 0; i < nrows; ++i) {
+      SVectorBase<R> &vec = rowVector_w(i);
 
-      return LPRowSetBase<R>::isConsistent() && LPColSetBase<R>::isConsistent();
-#else
-      return true;
-#endif
-   }
+      for (int k = vec.size() - 1; k >= 0; --k) {
+        int idx = vec.index(k);
 
-   ///@}
+        if (perm[idx] < 0)
+          vec.remove(k);
+        else
+          vec.index(k) = perm[idx];
+      }
+    }
+  }
 
-protected:
+  /// Called after the last \p n rows have just been added.
+  virtual void addedRows(int newrows) {}
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Protected write access */
-   ///@{
-
-   /// Returns right hand side of row \p i.
-   R& rhs_w(int i)
-   {
-      return LPRowSetBase<R>::rhs_w(i);
-   }
-
-   /// Returns left hand side of row \p i.
-   R& lhs_w(int i)
-   {
-      return LPRowSetBase<R>::lhs_w(i);
-   }
-
-   /// Returns objective function value of row \p i.
-   R& maxRowObj_w(int i)
-   {
-      return LPRowSetBase<R>::obj_w(i);
-   }
-
-   /// Returns objective value of column \p i for maximization problem.
-   R& maxObj_w(int i)
-   {
-      return LPColSetBase<R>::maxObj_w(i);
-   }
-
-   /// Returns upper bound of column \p i.
-   R& upper_w(int i)
-   {
-      return LPColSetBase<R>::upper_w(i);
-   }
-
-   /// Returns lower bound of column \p i.
-   R& lower_w(int i)
-   {
-      return LPColSetBase<R>::lower_w(i);
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Protected helpers */
-   ///@{
-
-   /// Returns the LP as an LPRowSetBase.
-   const LPRowSetBase<R>* lprowset() const
-   {
-      return static_cast<const LPRowSetBase<R>*>(this);
-   }
-
-   /// Returns the LP as an LPColSetBase.
-   const LPColSetBase<R>* lpcolset() const
-   {
-      return static_cast<const LPColSetBase<R>*>(this);
-   }
-
-   /// Internal helper method.
-   virtual void doRemoveRow(int j)
-   {
-
-      const SVectorBase<R>& vec = rowVector(j);
-
-      // remove row vector from column file
-      for(int i = vec.size() - 1; i >= 0; --i)
-      {
-         SVectorBase<R>& remvec = colVector_w(vec.index(i));
-         int position = remvec.pos(j);
+  /// Called after the last \p n columns have just been added.
+  virtual void addedCols(int newcols) {}
 
-         if(position >= 0)
-            remvec.remove(position);
-      }
+  ///
+  void added2Set(SVSetBase<R> &set, const SVSetBase<R> &addset, int n) {
 
-      // move last row to removed position
-      int idx = nRows() - 1;
+    if (n == 0)
+      return;
 
-      if(j != idx)
-      {
-         const SVectorBase<R>& l_vec = rowVector(idx);
+    DataArray<int> moreArray(set.num());
+    int *more = moreArray.get_ptr();
 
-         for(int i = l_vec.size() - 1; i >= 0; --i)
-         {
-            SVectorBase<R>& movevec = colVector_w(l_vec.index(i));
-            int position = movevec.pos(idx);
+    for (int i = set.num() - 1; i >= 0; --i)
+      more[i] = 0;
 
-            assert(position != -1);
+    int tot = 0;
+    int end = addset.num();
 
-            if(position >= 0)
-               movevec.index(position) = j;
-         }
-      }
+    for (int i = addset.num() - n; i < end; ++i) {
+      const SVectorBase<R> &vec = addset[i];
 
-      LPRowSetBase<R>::remove(j);
-   }
+      tot += vec.size();
 
-   /// Internal helper method.
-   virtual void doRemoveRows(int perm[])
-   {
-      int j = nCols();
+      for (int j = vec.size() - 1; j >= 0; --j)
+        more[vec.index(j)]++;
+    }
 
-      LPRowSetBase<R>::remove(perm);
+    if (set.memMax() < tot)
+      set.memRemax(tot);
 
-      for(int i = 0; i < j; ++i)
-      {
-         SVectorBase<R>& vec = colVector_w(i);
+    for (int i = set.num() - 1; i >= 0; --i) {
+      int j = set[i].size();
+      set.xtend(set[i], j + more[i]);
+      set[i].set_size(j + more[i]);
+      more[i] = j;
+    }
 
-         for(int k = vec.size() - 1; k >= 0; --k)
-         {
-            int idx = vec.index(k);
+    for (int i = addset.num() - n; i < addset.num(); ++i) {
+      const SVectorBase<R> &vec = addset[i];
 
-            if(perm[idx] < 0)
-               vec.remove(k);
-            else
-               vec.index(k) = perm[idx];
-         }
+      for (int j = vec.size() - 1; j >= 0; --j) {
+        int k = vec.index(j);
+        int m = more[k]++;
+        SVectorBase<R> &l_xtend = set[k];
+        l_xtend.index(m) = i;
+        l_xtend.value(m) = vec.value(j);
       }
-   }
+    }
+  }
 
-   /// Internal helper method.
-   virtual void doRemoveCol(int j)
-   {
+  ///@}
 
-      const SVectorBase<R>& vec = colVector(j);
-      int i;
+private:
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Private helpers */
+  ///@{
 
-      // remove column vector from row file
-      for(i = vec.size() - 1; i >= 0; --i)
-      {
-         SVectorBase<R>& remvec = rowVector_w(vec.index(i));
-         int position = remvec.pos(j);
+  /// Returns the LP as an LPRowBase<R>Set.
+  SVectorBase<R> &colVector_w(int i) { return LPColSetBase<R>::colVector_w(i); }
 
-         assert(position != -1);
+  ///
+  SVectorBase<R> &rowVector_w(int i) { return LPRowSetBase<R>::rowVector_w(i); }
 
-         if(position >= 0)
-            remvec.remove(position);
-      }
+  ///
+  void doAddRow(const LPRowBase<R> &row, bool scale = false) {
+    int idx = nRows();
+    int oldColNumber = nCols();
+    int newRowScaleExp = 0;
 
-      // move last column to removed position
-      int idx = nCols() - 1;
+    LPRowSetBase<R>::add(row);
 
-      if(j != idx)
-      {
-         const SVectorBase<R>& l_vec = colVector(idx);
+    SVectorBase<R> &vec = rowVector_w(idx);
 
-         for(i = l_vec.size() - 1; i >= 0; --i)
-         {
-            SVectorBase<R>& movevec = rowVector_w(l_vec.index(i));
-            int position = movevec.pos(idx);
+    DataArray<int> &colscaleExp = LPColSetBase<R>::scaleExp;
 
-            assert(position != -1);
+    // compute new row scaling factor and apply it to the sides
+    if (scale && lp_scaler) {
+      newRowScaleExp = lp_scaler->computeScaleExp(vec, colscaleExp);
 
-            if(position >= 0)
-               movevec.index(position) = j;
-         }
-      }
+      if (rhs(idx) < R(infinity))
+        rhs_w(idx) = spxLdexp(rhs_w(idx), newRowScaleExp);
 
-      LPColSetBase<R>::remove(j);
-   }
+      if (lhs(idx) > R(-infinity))
+        lhs_w(idx) = spxLdexp(lhs_w(idx), newRowScaleExp);
 
-   /// Internal helper method.
-   virtual void doRemoveCols(int perm[])
-   {
-      int nrows = nRows();
+      maxRowObj_w(idx) = spxLdexp(maxRowObj_w(idx), newRowScaleExp);
 
-      LPColSetBase<R>::remove(perm);
+      LPRowSetBase<R>::scaleExp[idx] = newRowScaleExp;
+    }
 
-      for(int i = 0; i < nrows; ++i)
-      {
-         SVectorBase<R>& vec = rowVector_w(i);
+    // now insert nonzeros to column file also
+    for (int j = vec.size() - 1; j >= 0; --j) {
+      int i = vec.index(j);
 
-         for(int k = vec.size() - 1; k >= 0; --k)
-         {
-            int idx = vec.index(k);
+      // apply new row and existing column scaling factors to new values in
+      // RowSet
+      if (scale)
+        vec.value(j) = spxLdexp(vec.value(j), newRowScaleExp + colscaleExp[i]);
 
-            if(perm[idx] < 0)
-               vec.remove(k);
-            else
-               vec.index(k) = perm[idx];
-         }
-      }
-   }
+      R val = vec.value(j);
 
-   /// Called after the last \p n rows have just been added.
-   virtual void addedRows(int newrows)
-   {}
+      // create new columns if required
+      if (i >= nCols()) {
+        LPColBase<R> empty;
 
-   /// Called after the last \p n columns have just been added.
-   virtual void addedCols(int newcols)
-   {}
+        for (int k = nCols(); k <= i; ++k)
+          LPColSetBase<R>::add(empty);
+      }
 
-   ///
-   void added2Set(SVSetBase<R>& set, const SVSetBase<R>& addset, int n)
-   {
+      assert(i < nCols());
+      LPColSetBase<R>::add2(i, 1, &idx, &val);
+    }
 
-      if(n == 0)
-         return;
+    addedRows(1);
+    addedCols(nCols() - oldColNumber);
+  }
 
-      DataArray<int> moreArray(set.num());
-      int* more = moreArray.get_ptr();
+  ///
+  void doAddRow(const R &lhsValue, const SVectorBase<R> &rowVec,
+                const R &rhsValue, bool scale = false) {
+    int idx = nRows();
+    int oldColNumber = nCols();
+    int newRowScaleExp = 0;
 
-      for(int i = set.num() - 1; i >= 0; --i)
-         more[i] = 0;
+    LPRowSetBase<R>::add(lhsValue, rowVec, rhsValue);
 
-      int tot = 0;
-      int end = addset.num();
+    DataArray<int> &colscaleExp = LPColSetBase<R>::scaleExp;
 
-      for(int i = addset.num() - n; i < end; ++i)
-      {
-         const SVectorBase<R>& vec = addset[i];
+    // compute new row scaling factor and apply it to the sides
+    if (scale) {
+      newRowScaleExp = lp_scaler->computeScaleExp(rowVec, colscaleExp);
 
-         tot += vec.size();
+      if (rhs(idx) < R(infinity))
+        rhs_w(idx) = spxLdexp(rhs_w(idx), newRowScaleExp);
 
-         for(int j = vec.size() - 1; j >= 0; --j)
-            more[vec.index(j)]++;
-      }
+      if (lhs(idx) > R(-infinity))
+        lhs_w(idx) = spxLdexp(lhs_w(idx), newRowScaleExp);
 
-      if(set.memMax() < tot)
-         set.memRemax(tot);
+      maxRowObj_w(idx) = spxLdexp(maxRowObj_w(idx), newRowScaleExp);
 
-      for(int i = set.num() - 1; i >= 0; --i)
-      {
-         int j = set[i].size();
-         set.xtend(set[i], j + more[i]);
-         set[i].set_size(j + more[i]);
-         more[i] = j;
-      }
+      LPRowSetBase<R>::scaleExp[idx] = newRowScaleExp;
+    }
 
-      for(int i = addset.num() - n; i < addset.num(); ++i)
-      {
-         const SVectorBase<R>& vec = addset[i];
-
-         for(int j = vec.size() - 1; j >= 0; --j)
-         {
-            int k = vec.index(j);
-            int m = more[k]++;
-            SVectorBase<R>& l_xtend = set[k];
-            l_xtend.index(m) = i;
-            l_xtend.value(m) = vec.value(j);
-         }
-      }
-   }
+    SVectorBase<R> &vec = rowVector_w(idx);
 
-   ///@}
+    // now insert nonzeros to column file also
+    for (int j = vec.size() - 1; j >= 0; --j) {
+      int i = vec.index(j);
 
+      // apply new row and existing column scaling factors to new values in
+      // RowSet
+      if (scale)
+        vec.value(j) = spxLdexp(vec.value(j), newRowScaleExp + colscaleExp[i]);
 
-private:
+      R val = vec.value(j);
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Private helpers */
-   ///@{
-
-   /// Returns the LP as an LPRowBase<R>Set.
-   SVectorBase<R>& colVector_w(int i)
-   {
-      return LPColSetBase<R>::colVector_w(i);
-   }
-
-   ///
-   SVectorBase<R>& rowVector_w(int i)
-   {
-      return LPRowSetBase<R>::rowVector_w(i);
-   }
-
-   ///
-   void doAddRow(const LPRowBase<R>& row, bool scale = false)
-   {
-      int idx = nRows();
-      int oldColNumber = nCols();
-      int newRowScaleExp = 0;
+      // create new columns if required
+      if (i >= nCols()) {
+        LPColBase<R> empty;
 
-      LPRowSetBase<R>::add(row);
+        for (int k = nCols(); k <= i; ++k)
+          LPColSetBase<R>::add(empty);
+      }
 
-      SVectorBase<R>& vec = rowVector_w(idx);
+      assert(i < nCols());
+      LPColSetBase<R>::add2(i, 1, &idx, &val);
+    }
 
-      DataArray <int>& colscaleExp = LPColSetBase<R>::scaleExp;
+    addedRows(1);
+    addedCols(nCols() - oldColNumber);
+  }
 
-      // compute new row scaling factor and apply it to the sides
-      if(scale && lp_scaler)
-      {
-         newRowScaleExp = lp_scaler->computeScaleExp(vec, colscaleExp);
+  ///
+  void doAddRows(const LPRowSetBase<R> &set, bool scale = false) {
+    int i, j, k, ii, idx;
+    SVectorBase<R> *col;
+    DataArray<int> newCols(nCols());
+    int oldRowNumber = nRows();
+    int oldColNumber = nCols();
 
-         if(rhs(idx) < R(infinity))
-            rhs_w(idx) = spxLdexp(rhs_w(idx), newRowScaleExp);
+    if (&set != this)
+      LPRowSetBase<R>::add(set);
 
-         if(lhs(idx) > R(-infinity))
-            lhs_w(idx) = spxLdexp(lhs_w(idx), newRowScaleExp);
+    assert(LPRowSetBase<R>::isConsistent());
+    assert(LPColSetBase<R>::isConsistent());
 
-         maxRowObj_w(idx) = spxLdexp(maxRowObj_w(idx), newRowScaleExp);
+    // count additional nonzeros per column
+    for (i = nCols() - 1; i >= 0; --i)
+      newCols[i] = 0;
 
-         LPRowSetBase<R>::scaleExp[idx] = newRowScaleExp;
-      }
+    for (i = set.num() - 1; i >= 0; --i) {
+      const SVectorBase<R> &vec = set.rowVector(i);
 
-      // now insert nonzeros to column file also
-      for(int j = vec.size() - 1; j >= 0; --j)
-      {
-         int i = vec.index(j);
+      for (j = vec.size() - 1; j >= 0; --j) {
+        // create new columns if required
+        ii = vec.index(j);
 
-         // apply new row and existing column scaling factors to new values in RowSet
-         if(scale)
-            vec.value(j) = spxLdexp(vec.value(j), newRowScaleExp + colscaleExp[i]);
+        if (ii >= nCols()) {
+          LPColBase<R> empty;
+          newCols.reSize(ii + 1);
 
-         R val = vec.value(j);
+          for (k = nCols(); k <= ii; ++k) {
+            newCols[k] = 0;
+            LPColSetBase<R>::add(empty);
+          }
+        }
 
-         // create new columns if required
-         if(i >= nCols())
-         {
-            LPColBase<R> empty;
+        assert(ii < nCols());
+        newCols[ii]++;
+      }
+    }
 
-            for(int k = nCols(); k <= i; ++k)
-               LPColSetBase<R>::add(empty);
-         }
+    // extend columns as required (backward because of memory efficiency
+    // reasons)
+    for (i = nCols() - 1; i >= 0; --i) {
+      if (newCols[i] > 0) {
+        int len = newCols[i] + colVector(i).size();
+        LPColSetBase<R>::xtend(i, len);
 
-         assert(i < nCols());
-         LPColSetBase<R>::add2(i, 1, &idx, &val);
+        /* preset the sizes: beware that this can irritate a consistency check
+         * call from xtend(). We need to set the sizes here, because a possible
+         * garbage collection called from xtend might destroy the sizes again.
+         */
+        colVector_w(i).set_size(len);
       }
+    }
 
-      addedRows(1);
-      addedCols(nCols() - oldColNumber);
-   }
-
-   ///
-   void doAddRow(const R& lhsValue, const SVectorBase<R>& rowVec, const R& rhsValue,
-                 bool scale = false)
-   {
-      int idx = nRows();
-      int oldColNumber = nCols();
+    // compute new row scaling factor and insert new elements to column file
+    for (i = nRows() - 1; i >= oldRowNumber; --i) {
+      SVectorBase<R> &vec = rowVector_w(i);
       int newRowScaleExp = 0;
 
-      LPRowSetBase<R>::add(lhsValue, rowVec, rhsValue);
-
-      DataArray <int>& colscaleExp = LPColSetBase<R>::scaleExp;
+      DataArray<int> &colscaleExp = LPColSetBase<R>::scaleExp;
 
       // compute new row scaling factor and apply it to the sides
-      if(scale)
-      {
-         newRowScaleExp = lp_scaler->computeScaleExp(rowVec, colscaleExp);
+      if (scale) {
+        newRowScaleExp = lp_scaler->computeScaleExp(vec, colscaleExp);
 
-         if(rhs(idx) < R(infinity))
-            rhs_w(idx) = spxLdexp(rhs_w(idx), newRowScaleExp);
+        if (rhs(i) < R(infinity))
+          rhs_w(i) = spxLdexp(rhs_w(i), newRowScaleExp);
 
-         if(lhs(idx) > R(-infinity))
-            lhs_w(idx) = spxLdexp(lhs_w(idx), newRowScaleExp);
+        if (lhs(i) > R(-infinity))
+          lhs_w(i) = spxLdexp(lhs_w(i), newRowScaleExp);
 
-         maxRowObj_w(idx) = spxLdexp(maxRowObj_w(idx), newRowScaleExp);
+        maxRowObj_w(i) = spxLdexp(maxRowObj_w(i), newRowScaleExp);
 
-         LPRowSetBase<R>::scaleExp[idx] = newRowScaleExp;
+        LPRowSetBase<R>::scaleExp[i] = newRowScaleExp;
       }
 
-      SVectorBase<R>& vec = rowVector_w(idx);
-
-      // now insert nonzeros to column file also
-      for(int j = vec.size() - 1; j >= 0; --j)
-      {
-         int i = vec.index(j);
-
-         // apply new row and existing column scaling factors to new values in RowSet
-         if(scale)
-            vec.value(j) = spxLdexp(vec.value(j), newRowScaleExp + colscaleExp[i]);
-
-         R val = vec.value(j);
-
-         // create new columns if required
-         if(i >= nCols())
-         {
-            LPColBase<R> empty;
+      for (j = vec.size() - 1; j >= 0; --j) {
+        k = vec.index(j);
+        col = &colVector_w(k);
+        idx = col->size() - newCols[k];
+        assert(newCols[k] > 0);
+        assert(idx >= 0);
+        newCols[k]--;
+        col->index(idx) = i;
 
-            for(int k = nCols(); k <= i; ++k)
-               LPColSetBase<R>::add(empty);
-         }
+        // apply new row and existing column scaling factors to both ColSet and
+        // RowSet
+        if (scale)
+          vec.value(j) =
+              spxLdexp(vec.value(j), newRowScaleExp + colscaleExp[k]);
 
-         assert(i < nCols());
-         LPColSetBase<R>::add2(i, 1, &idx, &val);
+        col->value(idx) = vec.value(j);
       }
+    }
 
-      addedRows(1);
-      addedCols(nCols() - oldColNumber);
-   }
+#ifndef NDEBUG
 
-   ///
-   void doAddRows(const LPRowSetBase<R>& set, bool scale = false)
-   {
-      int i, j, k, ii, idx;
-      SVectorBase<R>* col;
-      DataArray < int > newCols(nCols());
-      int oldRowNumber = nRows();
-      int oldColNumber = nCols();
+    for (i = 0; i < nCols(); ++i)
+      assert(newCols[i] == 0);
 
-      if(&set != this)
-         LPRowSetBase<R>::add(set);
+#endif
 
-      assert(LPRowSetBase<R>::isConsistent());
-      assert(LPColSetBase<R>::isConsistent());
+    assert(SPxLPBase<R>::isConsistent());
 
-      // count additional nonzeros per column
-      for(i = nCols() - 1; i >= 0; --i)
-         newCols[i] = 0;
+    assert(set.num() == nRows() - oldRowNumber);
+    addedRows(nRows() - oldRowNumber);
+    addedCols(nCols() - oldColNumber);
+  }
 
-      for(i = set.num() - 1; i >= 0; --i)
-      {
-         const SVectorBase<R>& vec = set.rowVector(i);
-
-         for(j = vec.size() - 1; j >= 0; --j)
-         {
-            // create new columns if required
-            ii = vec.index(j);
-
-            if(ii >= nCols())
-            {
-               LPColBase<R> empty;
-               newCols.reSize(ii + 1);
-
-               for(k = nCols(); k <= ii; ++k)
-               {
-                  newCols[k] = 0;
-                  LPColSetBase<R>::add(empty);
-               }
-            }
-
-            assert(ii < nCols());
-            newCols[ii]++;
-         }
-      }
+  ///
+  void doAddCol(const LPColBase<R> &col, bool scale = false) {
+    int idx = nCols();
+    int oldRowNumber = nRows();
+    int newColScaleExp = 0;
 
-      // extend columns as required (backward because of memory efficiency reasons)
-      for(i = nCols() - 1; i >= 0; --i)
-      {
-         if(newCols[i] > 0)
-         {
-            int len = newCols[i] + colVector(i).size();
-            LPColSetBase<R>::xtend(i, len);
-
-            /* preset the sizes: beware that this can irritate a consistency check call from xtend(). We need to set the
-             * sizes here, because a possible garbage collection called from xtend might destroy the sizes again. */
-            colVector_w(i).set_size(len);
-         }
-      }
+    LPColSetBase<R>::add(col);
 
-      // compute new row scaling factor and insert new elements to column file
-      for(i = nRows() - 1; i >= oldRowNumber; --i)
-      {
-         SVectorBase<R>& vec = rowVector_w(i);
-         int newRowScaleExp = 0;
+    if (thesense != MAXIMIZE)
+      LPColSetBase<R>::maxObj_w(idx) *= -1;
 
-         DataArray <int>& colscaleExp = LPColSetBase<R>::scaleExp;
+    SVectorBase<R> &vec = colVector_w(idx);
 
-         // compute new row scaling factor and apply it to the sides
-         if(scale)
-         {
-            newRowScaleExp = lp_scaler->computeScaleExp(vec, colscaleExp);
+    DataArray<int> &rowscaleExp = LPRowSetBase<R>::scaleExp;
 
-            if(rhs(i) < R(infinity))
-               rhs_w(i) = spxLdexp(rhs_w(i), newRowScaleExp);
+    // compute new column scaling factor and apply it to the bounds
+    if (scale) {
+      newColScaleExp = lp_scaler->computeScaleExp(vec, rowscaleExp);
 
-            if(lhs(i) > R(-infinity))
-               lhs_w(i) = spxLdexp(lhs_w(i), newRowScaleExp);
+      if (upper(idx) < R(infinity))
+        upper_w(idx) = spxLdexp(upper_w(idx), -newColScaleExp);
 
-            maxRowObj_w(i) = spxLdexp(maxRowObj_w(i), newRowScaleExp);
+      if (lower(idx) > R(-infinity))
+        lower_w(idx) = spxLdexp(lower_w(idx), -newColScaleExp);
 
-            LPRowSetBase<R>::scaleExp[i] = newRowScaleExp;
-         }
+      maxObj_w(idx) = spxLdexp(maxObj_w(idx), newColScaleExp);
 
-         for(j = vec.size() - 1; j >= 0; --j)
-         {
-            k = vec.index(j);
-            col = &colVector_w(k);
-            idx = col->size() - newCols[k];
-            assert(newCols[k] > 0);
-            assert(idx >= 0);
-            newCols[k]--;
-            col->index(idx) = i;
+      LPColSetBase<R>::scaleExp[idx] = newColScaleExp;
+    }
 
-            // apply new row and existing column scaling factors to both ColSet and RowSet
-            if(scale)
-               vec.value(j) = spxLdexp(vec.value(j), newRowScaleExp + colscaleExp[k]);
+    // now insert nonzeros to row file also
+    for (int j = vec.size() - 1; j >= 0; --j) {
+      int i = vec.index(j);
 
-            col->value(idx) = vec.value(j);
-         }
-      }
+      // apply new column and existing row scaling factors to new values in
+      // ColSet
+      if (scale)
+        vec.value(j) = spxLdexp(vec.value(j), newColScaleExp + rowscaleExp[i]);
 
-#ifndef NDEBUG
+      R val = vec.value(j);
 
-      for(i = 0; i < nCols(); ++i)
-         assert(newCols[i] == 0);
+      // create new rows if required
+      if (i >= nRows()) {
+        LPRowBase<R> empty;
 
-#endif
-
-      assert(SPxLPBase<R>::isConsistent());
+        for (int k = nRows(); k <= i; ++k)
+          LPRowSetBase<R>::add(empty);
+      }
 
-      assert(set.num() == nRows() - oldRowNumber);
-      addedRows(nRows() - oldRowNumber);
-      addedCols(nCols() - oldColNumber);
-   }
+      assert(i < nRows());
+      LPRowSetBase<R>::add2(i, 1, &idx, &val);
+    }
 
-   ///
-   void doAddCol(const LPColBase<R>& col, bool scale = false)
-   {
-      int idx = nCols();
-      int oldRowNumber = nRows();
-      int newColScaleExp = 0;
+    addedCols(1);
+    addedRows(nRows() - oldRowNumber);
+  }
 
-      LPColSetBase<R>::add(col);
+  ///
+  void doAddCol(const R &objValue, const R &lowerValue,
+                const SVectorBase<R> &colVec, const R &upperValue,
+                bool scale = false) {
+    int idx = nCols();
+    int oldRowNumber = nRows();
+    int newColScaleExp = 0;
 
-      if(thesense != MAXIMIZE)
-         LPColSetBase<R>::maxObj_w(idx) *= -1;
+    LPColSetBase<R>::add(objValue, lowerValue, colVec, upperValue);
 
-      SVectorBase<R>& vec = colVector_w(idx);
+    if (thesense != MAXIMIZE)
+      LPColSetBase<R>::maxObj_w(idx) *= -1;
 
-      DataArray <int>& rowscaleExp = LPRowSetBase<R>::scaleExp;
+    DataArray<int> &rowscaleExp = LPRowSetBase<R>::scaleExp;
 
-      // compute new column scaling factor and apply it to the bounds
-      if(scale)
-      {
-         newColScaleExp = lp_scaler->computeScaleExp(vec, rowscaleExp);
+    // compute new column scaling factor and apply it to the bounds
+    if (scale) {
+      newColScaleExp = lp_scaler->computeScaleExp(colVec, rowscaleExp);
 
-         if(upper(idx) < R(infinity))
-            upper_w(idx) = spxLdexp(upper_w(idx), - newColScaleExp);
+      if (upper(idx) < R(infinity))
+        upper_w(idx) = spxLdexp(upper_w(idx), -newColScaleExp);
 
-         if(lower(idx) > R(-infinity))
-            lower_w(idx) = spxLdexp(lower_w(idx), - newColScaleExp);
+      if (lower(idx) > R(-infinity))
+        lower_w(idx) = spxLdexp(lower_w(idx), -newColScaleExp);
 
-         maxObj_w(idx) = spxLdexp(maxObj_w(idx), newColScaleExp);
+      maxObj_w(idx) = spxLdexp(maxObj_w(idx), newColScaleExp);
 
-         LPColSetBase<R>::scaleExp[idx] = newColScaleExp;
-      }
+      LPColSetBase<R>::scaleExp[idx] = newColScaleExp;
+    }
 
-      // now insert nonzeros to row file also
-      for(int j = vec.size() - 1; j >= 0; --j)
-      {
-         int i = vec.index(j);
+    SVectorBase<R> &vec = colVector_w(idx);
 
-         // apply new column and existing row scaling factors to new values in ColSet
-         if(scale)
-            vec.value(j) = spxLdexp(vec.value(j), newColScaleExp + rowscaleExp[i]);
+    // now insert nonzeros to row file also
+    for (int j = vec.size() - 1; j >= 0; --j) {
+      int i = vec.index(j);
 
-         R val = vec.value(j);
+      if (scale)
+        vec.value(j) = spxLdexp(vec.value(j), newColScaleExp + rowscaleExp[i]);
 
-         // create new rows if required
-         if(i >= nRows())
-         {
-            LPRowBase<R> empty;
+      R val = vec.value(j);
 
-            for(int k = nRows(); k <= i; ++k)
-               LPRowSetBase<R>::add(empty);
-         }
+      // create new rows if required
+      if (i >= nRows()) {
+        LPRowBase<R> empty;
 
-         assert(i < nRows());
-         LPRowSetBase<R>::add2(i, 1, &idx, &val);
+        for (int k = nRows(); k <= i; ++k)
+          LPRowSetBase<R>::add(empty);
       }
 
-      addedCols(1);
-      addedRows(nRows() - oldRowNumber);
-   }
+      assert(i < nRows());
+      LPRowSetBase<R>::add2(i, 1, &idx, &val);
+    }
 
-   ///
-   void doAddCol(const R& objValue, const R& lowerValue, const SVectorBase<R>& colVec,
-                 const R& upperValue, bool scale = false)
-   {
-      int idx = nCols();
-      int oldRowNumber = nRows();
-      int newColScaleExp = 0;
+    addedCols(1);
+    addedRows(nRows() - oldRowNumber);
+  }
 
-      LPColSetBase<R>::add(objValue, lowerValue, colVec, upperValue);
+  ///
+  void doAddCols(const LPColSetBase<R> &set, bool scale = false) {
+    int i, j;
+    int oldColNumber = nCols();
+    int oldRowNumber = nRows();
+    DataArray<int> newRows(nRows());
 
-      if(thesense != MAXIMIZE)
-         LPColSetBase<R>::maxObj_w(idx) *= -1;
+    if (&set != this)
+      LPColSetBase<R>::add(set);
 
-      DataArray <int>& rowscaleExp = LPRowSetBase<R>::scaleExp;
+    assert(LPColSetBase<R>::isConsistent());
+    assert(LPRowSetBase<R>::isConsistent());
 
-      // compute new column scaling factor and apply it to the bounds
-      if(scale)
-      {
-         newColScaleExp = lp_scaler->computeScaleExp(colVec, rowscaleExp);
+    // count additional nonzeros per row
+    for (i = nRows() - 1; i >= 0; --i)
+      newRows[i] = 0;
 
-         if(upper(idx) < R(infinity))
-            upper_w(idx) = spxLdexp(upper_w(idx), - newColScaleExp);
+    for (i = set.num() - 1; i >= 0; --i) {
+      const SVectorBase<R> &vec = set.colVector(i);
 
-         if(lower(idx) > R(-infinity))
-            lower_w(idx) = spxLdexp(lower_w(idx), - newColScaleExp);
+      for (j = vec.size() - 1; j >= 0; --j) {
+        // create new rows if required
+        int l = vec.index(j);
 
-         maxObj_w(idx) = spxLdexp(maxObj_w(idx), newColScaleExp);
+        if (l >= nRows()) {
+          LPRowBase<R> empty;
+          newRows.reSize(l + 1);
 
-         LPColSetBase<R>::scaleExp[idx] = newColScaleExp;
+          for (int k = nRows(); k <= l; ++k) {
+            newRows[k] = 0;
+            LPRowSetBase<R>::add(empty);
+          }
+        }
+
+        assert(l < nRows());
+        newRows[l]++;
       }
+    }
 
-      SVectorBase<R>& vec = colVector_w(idx);
+    // extend rows as required
+    for (i = 0; i < nRows(); ++i) {
+      if (newRows[i] > 0) {
+        int len = newRows[i] + rowVector(i).size();
+        LPRowSetBase<R>::xtend(i, len);
+        rowVector_w(i).set_size(len);
+      }
+    }
 
-      // now insert nonzeros to row file also
-      for(int j = vec.size() - 1; j >= 0; --j)
+    // insert new elements to row file
+    for (i = oldColNumber; i < nCols(); ++i) {
+      // @todo: Is there a better way to write the following if, else?
+      if (thesense == MAXIMIZE) {
+        LPColSetBase<R>::maxObj_w(i) *= 1;
+      } else // thesense is MINIMIZE = -1
       {
-         int i = vec.index(j);
-
-         if(scale)
-            vec.value(j) = spxLdexp(vec.value(j), newColScaleExp + rowscaleExp[i]);
-
-         R val = vec.value(j);
-
-         // create new rows if required
-         if(i >= nRows())
-         {
-            LPRowBase<R> empty;
-
-            for(int k = nRows(); k <= i; ++k)
-               LPRowSetBase<R>::add(empty);
-         }
-
-         assert(i < nRows());
-         LPRowSetBase<R>::add2(i, 1, &idx, &val);
+        LPColSetBase<R>::maxObj_w(i) *= -1;
       }
 
-      addedCols(1);
-      addedRows(nRows() - oldRowNumber);
-   }
-
-   ///
-   void doAddCols(const LPColSetBase<R>& set, bool scale = false)
-   {
-      int i, j;
-      int oldColNumber = nCols();
-      int oldRowNumber = nRows();
-      DataArray < int > newRows(nRows());
-
-      if(&set != this)
-         LPColSetBase<R>::add(set);
-
-      assert(LPColSetBase<R>::isConsistent());
-      assert(LPRowSetBase<R>::isConsistent());
-
-      // count additional nonzeros per row
-      for(i = nRows() - 1; i >= 0; --i)
-         newRows[i] = 0;
+      SVectorBase<R> &vec = colVector_w(i);
+      int newColScaleExp = 0;
 
-      for(i = set.num() - 1; i >= 0; --i)
-      {
-         const SVectorBase<R>& vec = set.colVector(i);
+      DataArray<int> &rowscaleExp = LPRowSetBase<R>::scaleExp;
 
-         for(j = vec.size() - 1; j >= 0; --j)
-         {
-            // create new rows if required
-            int l = vec.index(j);
+      // compute new column scaling factor and apply it to the bounds
+      if (scale) {
+        newColScaleExp = lp_scaler->computeScaleExp(vec, rowscaleExp);
 
-            if(l >= nRows())
-            {
-               LPRowBase<R> empty;
-               newRows.reSize(l + 1);
+        if (upper(i) < R(infinity))
+          upper_w(i) = spxLdexp(upper_w(i), -newColScaleExp);
 
-               for(int k = nRows(); k <= l; ++k)
-               {
-                  newRows[k] = 0;
-                  LPRowSetBase<R>::add(empty);
-               }
+        if (lower(i) > R(-infinity))
+          lower_w(i) = spxLdexp(lower_w(i), -newColScaleExp);
 
-            }
+        maxObj_w(i) = spxLdexp(maxObj_w(i), newColScaleExp);
 
-            assert(l < nRows());
-            newRows[l]++;
-         }
+        LPColSetBase<R>::scaleExp[i] = newColScaleExp;
       }
 
-      // extend rows as required
-      for(i = 0; i < nRows(); ++i)
-      {
-         if(newRows[i] > 0)
-         {
-            int len = newRows[i] + rowVector(i).size();
-            LPRowSetBase<R>::xtend(i, len);
-            rowVector_w(i).set_size(len);
-         }
-      }
+      for (j = vec.size() - 1; j >= 0; --j) {
+        int k = vec.index(j);
+        SVectorBase<R> &row = rowVector_w(k);
+        int idx = row.size() - newRows[k];
+        assert(newRows[k] > 0);
+        newRows[k]--;
+        row.index(idx) = i;
 
-      // insert new elements to row file
-      for(i = oldColNumber; i < nCols(); ++i)
-      {
-         // @todo: Is there a better way to write the following if, else?
-         if(thesense == MAXIMIZE)
-         {
-            LPColSetBase<R>::maxObj_w(i) *= 1;
-         }
-         else                  // thesense is MINIMIZE = -1
-         {
-            LPColSetBase<R>::maxObj_w(i) *= -1;
-         }
-
-         SVectorBase<R>& vec = colVector_w(i);
-         int newColScaleExp = 0;
-
-         DataArray <int>& rowscaleExp = LPRowSetBase<R>::scaleExp;
-
-         // compute new column scaling factor and apply it to the bounds
-         if(scale)
-         {
-            newColScaleExp = lp_scaler->computeScaleExp(vec, rowscaleExp);
-
-            if(upper(i) < R(infinity))
-               upper_w(i) = spxLdexp(upper_w(i), - newColScaleExp);
-
-            if(lower(i) > R(-infinity))
-               lower_w(i) = spxLdexp(lower_w(i), - newColScaleExp);
-
-            maxObj_w(i) = spxLdexp(maxObj_w(i), newColScaleExp);
-
-            LPColSetBase<R>::scaleExp[i] = newColScaleExp;
-         }
-
-         for(j = vec.size() - 1; j >= 0; --j)
-         {
-            int k = vec.index(j);
-            SVectorBase<R>& row = rowVector_w(k);
-            int idx = row.size() - newRows[k];
-            assert(newRows[k] > 0);
-            newRows[k]--;
-            row.index(idx) = i;
-
-            // apply new column and existing row scaling factors to both ColSet and RowSet
-            if(scale)
-               vec.value(j) = spxLdexp(vec.value(j), newColScaleExp + rowscaleExp[k]);
-
-            row.value(idx) = vec.value(j);
-         }
+        // apply new column and existing row scaling factors to both ColSet and
+        // RowSet
+        if (scale)
+          vec.value(j) =
+              spxLdexp(vec.value(j), newColScaleExp + rowscaleExp[k]);
+
+        row.value(idx) = vec.value(j);
       }
+    }
 
 #ifndef NDEBUG
 
-      for(i = 0; i < nRows(); ++i)
-         assert(newRows[i] == 0);
+    for (i = 0; i < nRows(); ++i)
+      assert(newRows[i] == 0);
 
 #endif
 
-      assert(SPxLPBase<R>::isConsistent());
+    assert(SPxLPBase<R>::isConsistent());
 
-      assert(set.num() == nCols() - oldColNumber);
-      addedCols(nCols() - oldColNumber);
-      addedRows(nRows() - oldRowNumber);
-   }
+    assert(set.num() == nCols() - oldColNumber);
+    addedCols(nCols() - oldColNumber);
+    addedRows(nRows() - oldRowNumber);
+  }
 
-   ///@}
+  ///@}
 
 public:
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Constructors / Destructors */
+  ///@{
+
+  /// Default constructor.
+  SPxLPBase() {
+    SPxLPBase<R>::clear(); // clear is virtual.
+
+    assert(isConsistent());
+  }
+
+  /// Destructor.
+  virtual ~SPxLPBase() {}
+
+  /// Copy constructor.
+  SPxLPBase(const SPxLPBase<R> &old)
+      : LPRowSetBase<R>(old), LPColSetBase<R>(old), thesense(old.thesense),
+        offset(old.offset), _isScaled(old._isScaled), lp_scaler(old.lp_scaler),
+        spxout(old.spxout) {
+    assert(isConsistent());
+  }
+
+  /// Copy constructor.
+  template <class S>
+  SPxLPBase(const SPxLPBase<S> &old)
+      : LPRowSetBase<R>(old), LPColSetBase<R>(old),
+        thesense(old.thesense == SPxLPBase<S>::MINIMIZE
+                     ? SPxLPBase<R>::MINIMIZE
+                     : SPxLPBase<R>::MAXIMIZE),
+        offset(old.offset), _isScaled(old._isScaled), spxout(old.spxout) {
+    lp_scaler = nullptr;
+    assert(isConsistent());
+  }
+
+  /// Assignment operator.
+  SPxLPBase<R> &operator=(const SPxLPBase<R> &old) {
+    if (this != &old) {
+      LPRowSetBase<R>::operator=(old);
+      LPColSetBase<R>::operator=(old);
+      thesense = old.thesense;
+      offset = old.offset;
+      _isScaled = old._isScaled;
+      lp_scaler = old.lp_scaler;
+      spxout = old.spxout;
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Constructors / Destructors */
-   ///@{
-
-   /// Default constructor.
-   SPxLPBase<R>()
-   {
-      SPxLPBase<R>::clear(); // clear is virtual.
-
-      assert(isConsistent());
-   }
-
-   /// Destructor.
-   virtual ~SPxLPBase<R>()
-   {}
-
-   /// Copy constructor.
-   SPxLPBase<R>(const SPxLPBase<R>& old)
-      : LPRowSetBase<R>(old)
-      , LPColSetBase<R>(old)
-      , thesense(old.thesense)
-      , offset(old.offset)
-      , _isScaled(old._isScaled)
-      , lp_scaler(old.lp_scaler)
-      , spxout(old.spxout)
-   {
       assert(isConsistent());
-   }
-
-   /// Copy constructor.
-   template < class S >
-   SPxLPBase<R>(const SPxLPBase<S>& old)
-      : LPRowSetBase<R>(old)
-      , LPColSetBase<R>(old)
-      , thesense(old.thesense == SPxLPBase<S>::MINIMIZE ? SPxLPBase<R>::MINIMIZE : SPxLPBase<R>::MAXIMIZE)
-      , offset(old.offset)
-      , _isScaled(old._isScaled)
-      , spxout(old.spxout)
-   {
+    }
+
+    return *this;
+  }
+
+  /// Assignment operator.
+  template <class S> SPxLPBase<R> &operator=(const SPxLPBase<S> &old) {
+    if (this != (const SPxLPBase<R> *)(&old)) {
+      // The value of old.lp_scaler has to be nullptr
+      // Refer to issue #161 in soplex gitlab
+      assert(old.lp_scaler == nullptr);
+
+      LPRowSetBase<R>::operator=(old);
+      LPColSetBase<R>::operator=(old);
+      thesense = (old.thesense) == SPxLPBase<S>::MINIMIZE
+                     ? SPxLPBase<R>::MINIMIZE
+                     : SPxLPBase<R>::MAXIMIZE;
+      offset = R(old.offset);
+      _isScaled = old._isScaled;
+
+      // this may have un-intended consequences in the future
       lp_scaler = nullptr;
-      assert(isConsistent());
-   }
+      spxout = old.spxout;
 
-   /// Assignment operator.
-   SPxLPBase<R>& operator=(const SPxLPBase<R>& old)
-   {
-      if(this != &old)
-      {
-         LPRowSetBase<R>::operator=(old);
-         LPColSetBase<R>::operator=(old);
-         thesense = old.thesense;
-         offset = old.offset;
-         _isScaled = old._isScaled;
-         lp_scaler = old.lp_scaler;
-         spxout = old.spxout;
-
-         assert(isConsistent());
-      }
-
-      return *this;
-   }
-
-   /// Assignment operator.
-   template < class S >
-   SPxLPBase<R>& operator=(const SPxLPBase<S>& old)
-   {
-      if(this != (const SPxLPBase<R>*)(&old))
-      {
-         // The value of old.lp_scaler has to be nullptr
-         // Refer to issue #161 in soplex gitlab
-         assert(old.lp_scaler == nullptr);
-
-         LPRowSetBase<R>::operator=(old);
-         LPColSetBase<R>::operator=(old);
-         thesense = (old.thesense) == SPxLPBase<S>::MINIMIZE ? SPxLPBase<R>::MINIMIZE :
-                    SPxLPBase<R>::MAXIMIZE;
-         offset = R(old.offset);
-         _isScaled = old._isScaled;
-
-         // this may have un-intended consequences in the future
-         lp_scaler = nullptr;
-         spxout = old.spxout;
-
-         assert(isConsistent());
-      }
+      assert(isConsistent());
+    }
 
-      return *this;
-   }
+    return *this;
+  }
 
-   ///@}
+  ///@}
 };
 
 } // namespace soplex
 
 // For the general templated functions
-#include "spxlpbase_real.hpp"
 #include "spxlpbase_rational.hpp"
+#include "spxlpbase_real.hpp"
 
 /* reset the SOPLEX_DEBUG flag to its original value */
 #undef SOPLEX_DEBUG
diff --git a/src/soplex/spxlpbase_rational.hpp b/src/soplex/spxlpbase_rational.hpp
index c95d246..f6f177e 100644
--- a/src/soplex/spxlpbase_rational.hpp
+++ b/src/soplex/spxlpbase_rational.hpp
@@ -21,2237 +21,2034 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 /**@file  spxlpbase_rational.hpp
  * @brief Saving LPs with Rational values in a form suitable for SoPlex.
  */
 
 #include <assert.h>
-#include <stdio.h>
 #include <ctype.h>
 #include <iostream>
+#include <stdio.h>
 
-#include "soplex/spxdefines.h"
-#include "soplex/spxout.h"
-#include "soplex/mpsinput.h"
 #include "soplex/exceptions.h"
+#include "soplex/mpsinput.h"
 #include "soplex/rational.h"
+#include "soplex/spxdefines.h"
+#include "soplex/spxlpbase_real.hpp"
+#include "soplex/spxout.h"
 
-#define MAX_LINE_WRITE_LEN 65536   ///< maximum length allowed for writing lines
+#define MAX_LINE_WRITE_LEN 65536 ///< maximum length allowed for writing lines
 
-namespace soplex
-{
-template<> inline
-void SPxLPBase<Rational>::computePrimalActivity(const VectorBase<Rational>& primal,
-      VectorBase<Rational>& activity, const bool unscaled) const
-{
-   if(primal.dim() != nCols())
-   {
-      throw SPxInternalCodeException("XSPXLP01 Primal vector for computing row activity has wrong dimension");
-   }
+namespace soplex {
+template <>
+inline void
+SPxLPBase<Rational>::computePrimalActivity(const VectorBase<Rational> &primal,
+                                           VectorBase<Rational> &activity,
+                                           const bool unscaled) const {
+  if (primal.dim() != nCols()) {
+    throw SPxInternalCodeException("XSPXLP01 Primal vector for computing row "
+                                   "activity has wrong dimension");
+  }
 
-   if(activity.dim() != nRows())
-   {
-      throw SPxInternalCodeException("XSPXLP03 Activity vector computing row activity has wrong dimension");
-   }
+  if (activity.dim() != nRows()) {
+    throw SPxInternalCodeException(
+        "XSPXLP03 Activity vector computing row activity has wrong dimension");
+  }
 
-   int c;
+  int c;
 
-   for(c = 0; c < nCols() && primal[c] == 0; c++)
-      ;
+  for (c = 0; c < nCols() && primal[c] == 0; c++)
+    ;
 
-   if(c >= nCols())
-   {
-      activity.clear();
-      return;
-   }
+  if (c >= nCols()) {
+    activity.clear();
+    return;
+  }
 
-   activity = colVector(c);
+  activity = colVector(c);
 
-   activity *= primal[c];
-   c++;
+  activity *= primal[c];
+  c++;
 
-   for(; c < nCols(); c++)
-   {
-      if(primal[c] != 0)
-      {
-         activity.multAdd(primal[c], colVector(c));
-      }
-   }
+  for (; c < nCols(); c++) {
+    if (primal[c] != 0) {
+      activity.multAdd(primal[c], colVector(c));
+    }
+  }
 }
 
-template<> inline
-void SPxLPBase<Rational>::computeDualActivity(const VectorBase<Rational>& dual,
-      VectorBase<Rational>& activity, const bool unscaled) const
-{
-   if(dual.dim() != nRows())
-   {
-      throw SPxInternalCodeException("XSPXLP02 Dual vector for computing dual activity has wrong dimension");
-   }
-
-   if(activity.dim() != nCols())
-   {
-      throw SPxInternalCodeException("XSPXLP04 Activity vector computing dual activity has wrong dimension");
-   }
-
-   int r;
-
-   for(r = 0; r < nRows() && dual[r] == 0; r++)
-      ;
-
-   if(r >= nRows())
-   {
-      activity.clear();
-      return;
-   }
-
-   activity = rowVector(r);
-
-   activity *= dual[r];
-   r++;
-
-   for(; r < nRows(); r++)
-   {
-      if(dual[r] != 0)
-      {
-         activity.multAdd(dual[r], rowVector(r));
-      }
-   }
+template <>
+inline void
+SPxLPBase<Rational>::computeDualActivity(const VectorBase<Rational> &dual,
+                                         VectorBase<Rational> &activity,
+                                         const bool unscaled) const {
+  if (dual.dim() != nRows()) {
+    throw SPxInternalCodeException(
+        "XSPXLP02 Dual vector for computing dual activity has wrong dimension");
+  }
+
+  if (activity.dim() != nCols()) {
+    throw SPxInternalCodeException(
+        "XSPXLP04 Activity vector computing dual activity has wrong dimension");
+  }
+
+  int r;
+
+  for (r = 0; r < nRows() && dual[r] == 0; r++)
+    ;
+
+  if (r >= nRows()) {
+    activity.clear();
+    return;
+  }
+
+  activity = rowVector(r);
+
+  activity *= dual[r];
+  r++;
+
+  for (; r < nRows(); r++) {
+    if (dual[r] != 0) {
+      activity.multAdd(dual[r], rowVector(r));
+    }
+  }
 }
 
-template<> inline
-Rational SPxLPBase<Rational>::maxAbsNzo(bool /* unscaled */) const
-{
-   Rational maxi = Rational(0);
+template <>
+inline Rational SPxLPBase<Rational>::maxAbsNzo(bool /* unscaled */) const {
+  Rational maxi = Rational(0);
 
-   for(int i = 0; i < nCols(); ++i)
-   {
-      Rational m = colVector(i).maxAbs();
+  for (int i = 0; i < nCols(); ++i) {
+    Rational m = colVector(i).maxAbs();
 
-      if(m > maxi)
-         maxi = m;
-   }
+    if (m > maxi)
+      maxi = m;
+  }
 
-   assert(maxi >= Rational(0));
+  assert(maxi >= Rational(0));
 
-   return maxi;
+  return maxi;
 }
 
-template<> inline
-Rational SPxLPBase<Rational>::minAbsNzo(bool /* unscaled */) const
-{
-   Rational mini = infinity;
+template <>
+inline Rational SPxLPBase<Rational>::minAbsNzo(bool /* unscaled */) const {
+  Rational mini = infinity;
 
-   for(int i = 0; i < nCols(); ++i)
-   {
-      Rational m = colVector(i).minAbs();
+  for (int i = 0; i < nCols(); ++i) {
+    Rational m = colVector(i).minAbs();
 
-      if(m < mini)
-         mini = m;
-   }
+    if (m < mini)
+      mini = m;
+  }
 
-   assert(mini >= Rational(0));
+  assert(mini >= Rational(0));
 
-   return mini;
+  return mini;
 }
 
 // ---------------------------------------------------------------------------------------------------------------------
 //  Specialization for reading LP format
 // ---------------------------------------------------------------------------------------------------------------------
 
-#define LPF_MAX_LINE_LEN  8192     ///< maximum length of a line (8190 + \\n + \\0)
+#define LPF_MAX_LINE_LEN 8192 ///< maximum length of a line (8190 + \\n + \\0)
 
 /// Read the next number and advance \p pos.
-/** If only a sign is encountered, the number is assumed to be \c sign * 1.  This routine will not catch malformatted
- *  numbers like .e10 !
+/** If only a sign is encountered, the number is assumed to be \c sign * 1. This
+ * routine will not catch malformatted numbers like .e10 !
  */
-static Rational LPFreadValue(char*& pos, SPxOut* spxout, const int lineno = -1)
-{
-   assert(LPFisValue(pos));
-
-   char        tmp[LPF_MAX_LINE_LEN];
-   const char* s = pos;
-   char*       t;
-   Rational        value = 1;
-   bool        has_digits = false;
-   bool        has_emptyexponent = false;
-   bool        has_dot = false;
-   bool        has_exponent = false;
-   bool        has_emptydivisor = false;
-
-   // 1. sign
-   if((*s == '+') || (*s == '-'))
-      s++;
-
-   // 2. Digits before the decimal dot
-   while((*s >= '0') && (*s <= '9'))
-   {
+static Rational LPFreadValue(char *&pos, SPxOut *spxout,
+                             const int lineno = -1) {
+  assert(LPFisValue(pos));
+
+  char tmp[LPF_MAX_LINE_LEN];
+  const char *s = pos;
+  char *t;
+  Rational value = 1;
+  bool has_digits = false;
+  bool has_emptyexponent = false;
+  bool has_dot = false;
+  bool has_exponent = false;
+  bool has_emptydivisor = false;
+
+  // 1. sign
+  if ((*s == '+') || (*s == '-'))
+    s++;
+
+  // 2. Digits before the decimal dot
+  while ((*s >= '0') && (*s <= '9')) {
+    has_digits = true;
+    s++;
+  }
+
+  // 3. Decimal dot
+  if (*s == '.') {
+    has_dot = true;
+    s++;
+
+    // 4. If there was a dot, possible digit behind it
+    while ((*s >= '0') && (*s <= '9')) {
       has_digits = true;
       s++;
-   }
-
-   // 3. Decimal dot
-   if(*s == '.')
-   {
-      has_dot = true;
-      s++;
+    }
+  }
 
-      // 4. If there was a dot, possible digit behind it
-      while((*s >= '0') && (*s <= '9'))
-      {
-         has_digits = true;
-         s++;
-      }
-   }
+  // 5. Exponent
+  if (tolower(*s) == 'e') {
+    has_exponent = true;
+    has_emptyexponent = true;
+    s++;
 
-   // 5. Exponent
-   if(tolower(*s) == 'e')
-   {
-      has_exponent = true;
-      has_emptyexponent = true;
+    // 6. Exponent sign
+    if ((*s == '+') || (*s == '-'))
       s++;
 
-      // 6. Exponent sign
-      if((*s == '+') || (*s == '-'))
-         s++;
-
-      // 7. Exponent digits
-      while((*s >= '0') && (*s <= '9'))
-      {
-         has_emptyexponent = false;
-         s++;
-      }
-   }
-
-   // 8. Division
-   if(*s == '/')
-   {
+    // 7. Exponent digits
+    while ((*s >= '0') && (*s <= '9')) {
+      has_emptyexponent = false;
       s++;
-      has_emptydivisor = true;
-
-      while((*s >= '0') && (*s <= '9'))
-      {
-         has_emptydivisor = false;
-         s++;
-      }
-
-      if(has_dot || has_exponent || has_emptydivisor ||
-            (*s == '.') || (*s == '+') || (*s == '-') || (tolower(*s) == 'e'))
-      {
-         MSG_WARNING((*spxout), (*spxout) << "WLPFRD03 Warning: In line " << lineno <<
-                     ": malformed rational value in LP file\n";)
-      }
-   }
+    }
+  }
 
+  // 8. Division
+  if (*s == '/') {
+    s++;
+    has_emptydivisor = true;
 
-   assert(s != pos);
-
-   if(has_emptyexponent)
-   {
-      MSG_WARNING((*spxout), (*spxout) << "WLPFRD01 Warning: In line " << lineno <<
-                  ": found empty exponent in LP file - check for forbidden variable names with initial 'e' or 'E'\n");
-   }
-
-   if(!has_digits)
-      value = (*pos == '-') ? -1 : 1;
-   else
-   {
-      for(t = tmp; pos != s; pos++)
-         *t++ = *pos;
-
-      *t = '\0';
-
-      try
-      {
-         value = ratFromString(tmp);
-      }
-      catch(const std::exception& e)
-      {
-         MSG_WARNING((*spxout), (*spxout) << "WLPFRD04 Warning: In line " << lineno <<
-                     ": malformed rational value in LP file\n");
-         std::cerr << e.what() << '\n';
-      }
-   }
-
-   pos += s - pos;
-
-   assert(pos == s);
-
-   MSG_DEBUG(std::cout << "DLPFRD01 LPFreadValue = " << value << std::endl;)
-
-   if(LPFisSpace(*pos))
-      pos++;
-
-   return value;
+    while ((*s >= '0') && (*s <= '9')) {
+      has_emptydivisor = false;
+      s++;
+    }
+
+    if (has_dot || has_exponent || has_emptydivisor || (*s == '.') ||
+        (*s == '+') || (*s == '-') || (tolower(*s) == 'e')) {
+      MSG_WARNING((*spxout), (*spxout)
+                                 << "WLPFRD03 Warning: In line " << lineno
+                                 << ": malformed rational value in LP file\n";)
+    }
+  }
+
+  assert(s != pos);
+
+  if (has_emptyexponent) {
+    MSG_WARNING(
+        (*spxout), (*spxout)
+                       << "WLPFRD01 Warning: In line " << lineno
+                       << ": found empty exponent in LP file - check for "
+                          "forbidden variable names with initial 'e' or 'E'\n");
+  }
+
+  if (!has_digits)
+    value = (*pos == '-') ? -1 : 1;
+  else {
+    for (t = tmp; pos != s; pos++)
+      *t++ = *pos;
+
+    *t = '\0';
+
+    try {
+      value = ratFromString(tmp);
+    } catch (const std::exception &e) {
+      MSG_WARNING((*spxout), (*spxout)
+                                 << "WLPFRD04 Warning: In line " << lineno
+                                 << ": malformed rational value in LP file\n");
+      std::cerr << e.what() << '\n';
+    }
+  }
+
+  pos += s - pos;
+
+  assert(pos == s);
+
+  MSG_DEBUG(std::cout << "DLPFRD01 LPFreadValue = " << value << std::endl;)
+
+  if (LPFisSpace(*pos))
+    pos++;
+
+  return value;
 }
 
-
-
 /// Read the next column name from the input.
 /** The name read is looked up and if not found \p emptycol
  *  is added to \p colset. \p pos is advanced behind the name.
  *  @return The Index of the named column.
  */
-static int LPFreadColName(char*& pos, NameSet* colnames, LPColSetBase<Rational>& colset,
-                          const LPColBase<Rational>* emptycol, SPxOut* spxout)
-{
-   assert(LPFisColName(pos));
-   assert(colnames != 0);
-
-   char        name[LPF_MAX_LINE_LEN];
-   const char* s = pos;
-   int         i;
-   int         colidx;
-
-   // These are the characters that are not allowed in a column name.
-   while((strchr("+-.<>= ", *s) == 0) && (*s != '\0'))
-      s++;
-
-   for(i = 0; pos != s; i++, pos++)
-      name[i] = *pos;
-
-   name[i] = '\0';
-
-   if((colidx = colnames->number(name)) < 0)
-   {
-      // We only add the name if we got an empty column.
-      if(emptycol == 0)
-         MSG_WARNING((*spxout), (*spxout) << "WLPFRD02 Unknown variable \"" << name << "\" ";)
-         else
-         {
-            colidx = colnames->num();
-            colnames->add(name);
-            colset.add(*emptycol);
-         }
-   }
-
-   MSG_DEBUG(std::cout << "DLPFRD03 LPFreadColName [" << name << "] = " << colidx << std::endl;)
-
-   if(LPFisSpace(*pos))
-      pos++;
-
-   return colidx;
+static int LPFreadColName(char *&pos, NameSet *colnames,
+                          LPColSetBase<Rational> &colset,
+                          const LPColBase<Rational> *emptycol, SPxOut *spxout) {
+  assert(LPFisColName(pos));
+  assert(colnames != 0);
+
+  char name[LPF_MAX_LINE_LEN];
+  const char *s = pos;
+  int i;
+  int colidx;
+
+  // These are the characters that are not allowed in a column name.
+  while ((strchr("+-.<>= ", *s) == 0) && (*s != '\0'))
+    s++;
+
+  for (i = 0; pos != s; i++, pos++)
+    name[i] = *pos;
+
+  name[i] = '\0';
+
+  if ((colidx = colnames->number(name)) < 0) {
+    // We only add the name if we got an empty column.
+    if (emptycol == 0)
+      MSG_WARNING((*spxout),
+                  (*spxout) << "WLPFRD02 Unknown variable \"" << name << "\" ";)
+    else {
+      colidx = colnames->num();
+      colnames->add(name);
+      colset.add(*emptycol);
+    }
+  }
+
+  MSG_DEBUG(std::cout << "DLPFRD03 LPFreadColName [" << name << "] = " << colidx
+                      << std::endl;)
+
+  if (LPFisSpace(*pos))
+    pos++;
+
+  return colidx;
 }
 
-static Rational LPFreadInfinity(char*& pos)
-{
-   assert(LPFisInfinity(pos));
+static Rational LPFreadInfinity(char *&pos) {
+  assert(LPFisInfinity(pos));
 
-   Rational sense = (*pos == '-') ? -1 : 1;
+  Rational sense = (*pos == '-') ? -1 : 1;
 
-   (void) LPFhasKeyword(++pos, "inf[inity]");
+  (void)LPFhasKeyword(++pos, "inf[inity]");
 
-   sense *= Rational(infinity);
-   return sense;
+  sense *= Rational(infinity);
+  return sense;
 }
 
 /// Read LP in "CPLEX LP File Format".
-/** The specification is taken from the ILOG CPLEX 7.0 Reference Manual, Appendix E, Page 527.
+/** The specification is taken from the ILOG CPLEX 7.0 Reference Manual,
+ * Appendix E, Page 527.
  *
- *  This routine should read (most?) valid LP format files.  What it will not do, is find all cases where a file is ill
- *  formed.  If this happens it may complain and read nothing or read "something".
+ *  This routine should read (most?) valid LP format files.  What it will not
+ * do, is find all cases where a file is ill formed.  If this happens it may
+ * complain and read nothing or read "something".
  *
- *  Problem: A line ending in '+' or '-' followed by a line starting with a number, will be regarded as an error.
+ *  Problem: A line ending in '+' or '-' followed by a line starting with a
+ * number, will be regarded as an error.
  *
- *  The reader will accept the keyword INT[egers] as a synonym for GEN[erals] which is an undocumented feature in CPLEX.
+ *  The reader will accept the keyword INT[egers] as a synonym for GEN[erals]
+ * which is an undocumented feature in CPLEX.
  *
- *  A difference to the CPLEX reader, is that no name for the objective row is required.
+ *  A difference to the CPLEX reader, is that no name for the objective row is
+ * required.
  *
- * The manual says the maximum allowed line length is 255 characters, but CPLEX does not complain if the lines are
- * longer.
+ * The manual says the maximum allowed line length is 255 characters, but CPLEX
+ * does not complain if the lines are longer.
  *
  *  @return true if the file was read correctly
  */
-template <> inline
-bool SPxLPBase<Rational>::readLPF(
-   std::istream& p_input,                ///< input stream.
-   NameSet*      p_rnames,               ///< row names.
-   NameSet*      p_cnames,               ///< column names.
-   DIdxSet*      p_intvars)              ///< integer variables.
+template <>
+inline bool
+SPxLPBase<Rational>::readLPF(std::istream &p_input, ///< input stream.
+                             NameSet *p_rnames,     ///< row names.
+                             NameSet *p_cnames,     ///< column names.
+                             DIdxSet *p_intvars)    ///< integer variables.
 {
-   enum
-   {
-      START, OBJECTIVE, CONSTRAINTS, BOUNDS, INTEGERS, BINARIES
-   } section = START;
-
-   NameSet* rnames;                      ///< row names.
-   NameSet* cnames;                      ///< column names.
-
-   LPColSetBase<Rational> cset;              ///< the set of columns read.
-   LPRowSetBase<Rational> rset;              ///< the set of rows read.
-   LPColBase<Rational> emptycol;             ///< reusable empty column.
-   LPRowBase<Rational> row;                  ///< last assembled row.
-   DSVectorBase<Rational> vec;               ///< last assembled vector (from row).
-
-   Rational val = 1;
-   int colidx;
-   int sense = 0;
-
-   char buf[LPF_MAX_LINE_LEN];
-   char tmp[LPF_MAX_LINE_LEN];
-   char line[LPF_MAX_LINE_LEN];
-   int lineno = 0;
-   bool unnamed = true;
-   bool finished = false;
-   bool other;
-   bool have_value = true;
-   int i;
-   int k;
-   char* s;
-   char* pos;
-   char* pos_old = 0;
-
-   if(p_cnames)
-      cnames = p_cnames;
-   else
-   {
-      cnames = 0;
-      spx_alloc(cnames);
-      cnames = new(cnames) NameSet();
-   }
-
-   cnames->clear();
-
-   if(p_rnames)
-      rnames = p_rnames;
-   else
-   {
-      try
-      {
-         rnames = 0;
-         spx_alloc(rnames);
-         rnames = new(rnames) NameSet();
+  enum {
+    START,
+    OBJECTIVE,
+    CONSTRAINTS,
+    BOUNDS,
+    INTEGERS,
+    BINARIES
+  } section = START;
+
+  NameSet *rnames; ///< row names.
+  NameSet *cnames; ///< column names.
+
+  LPColSetBase<Rational> cset;  ///< the set of columns read.
+  LPRowSetBase<Rational> rset;  ///< the set of rows read.
+  LPColBase<Rational> emptycol; ///< reusable empty column.
+  LPRowBase<Rational> row;      ///< last assembled row.
+  DSVectorBase<Rational> vec;   ///< last assembled vector (from row).
+
+  Rational val = 1;
+  int colidx;
+  int sense = 0;
+
+  char buf[LPF_MAX_LINE_LEN];
+  char tmp[LPF_MAX_LINE_LEN];
+  char line[LPF_MAX_LINE_LEN];
+  int lineno = 0;
+  bool unnamed = true;
+  bool finished = false;
+  bool other;
+  bool have_value = true;
+  int i;
+  int k;
+  char *s;
+  char *pos;
+  char *pos_old = 0;
+
+  if (p_cnames)
+    cnames = p_cnames;
+  else {
+    cnames = 0;
+    spx_alloc(cnames);
+    cnames = new (cnames) NameSet();
+  }
+
+  cnames->clear();
+
+  if (p_rnames)
+    rnames = p_rnames;
+  else {
+    try {
+      rnames = 0;
+      spx_alloc(rnames);
+      rnames = new (rnames) NameSet();
+    } catch (const SPxMemoryException &x) {
+      if (!p_cnames) {
+        cnames->~NameSet();
+        spx_free(cnames);
       }
-      catch(const SPxMemoryException& x)
-      {
-         if(!p_cnames)
-         {
-            cnames->~NameSet();
-            spx_free(cnames);
-         }
-
-         throw x;
-      }
-   }
-
-   rnames->clear();
-
-   SPxLPBase<Rational>::clear(); // clear the LP.
-
-   //--------------------------------------------------------------------------
-   //--- Main Loop
-   //--------------------------------------------------------------------------
-   for(;;)
-   {
-      // 0. Read a line from the file.
-      if(!p_input.getline(buf, sizeof(buf)))
-      {
-         if(strlen(buf) == LPF_MAX_LINE_LEN - 1)
-         {
-            MSG_ERROR(std::cerr << "ELPFRD06 Line exceeds " << LPF_MAX_LINE_LEN - 2
-                      << " characters" << std::endl;)
-         }
-         else
-         {
-            MSG_ERROR(std::cerr << "ELPFRD07 No 'End' marker found" << std::endl;)
-            finished = true;
-         }
-
-         break;
+
+      throw x;
+    }
+  }
+
+  rnames->clear();
+
+  SPxLPBase<Rational>::clear(); // clear the LP.
+
+  //--------------------------------------------------------------------------
+  //--- Main Loop
+  //--------------------------------------------------------------------------
+  for (;;) {
+    // 0. Read a line from the file.
+    if (!p_input.getline(buf, sizeof(buf))) {
+      if (strlen(buf) == LPF_MAX_LINE_LEN - 1) {
+        MSG_ERROR(std::cerr << "ELPFRD06 Line exceeds " << LPF_MAX_LINE_LEN - 2
+                            << " characters" << std::endl;)
+      } else {
+        MSG_ERROR(std::cerr << "ELPFRD07 No 'End' marker found" << std::endl;)
+        finished = true;
       }
 
-      lineno++;
-      i   = 0;
-      pos = buf;
-
-      MSG_DEBUG(std::cout << "DLPFRD08 Reading line " << lineno
-                << " (pos=" << pos << ")" << std::endl;)
-
-      // 1. Remove comments.
-      if(0 != (s = strchr(buf, '\\')))
-         * s = '\0';
-
-      // 2. Look for keywords.
-      if(section == START)
-      {
-         if(LPFhasKeyword(pos, "max[imize]"))
-         {
-            changeSense(SPxLPBase<Rational>::MAXIMIZE);
-            section = OBJECTIVE;
-         }
-         else if(LPFhasKeyword(pos, "min[imize]"))
-         {
-            changeSense(SPxLPBase<Rational>::MINIMIZE);
-            section = OBJECTIVE;
-         }
+      break;
+    }
+
+    lineno++;
+    i = 0;
+    pos = buf;
+
+    MSG_DEBUG(std::cout << "DLPFRD08 Reading line " << lineno << " (pos=" << pos
+                        << ")" << std::endl;)
+
+    // 1. Remove comments.
+    if (0 != (s = strchr(buf, '\\')))
+      *s = '\0';
+
+    // 2. Look for keywords.
+    if (section == START) {
+      if (LPFhasKeyword(pos, "max[imize]")) {
+        changeSense(SPxLPBase<Rational>::MAXIMIZE);
+        section = OBJECTIVE;
+      } else if (LPFhasKeyword(pos, "min[imize]")) {
+        changeSense(SPxLPBase<Rational>::MINIMIZE);
+        section = OBJECTIVE;
       }
-      else if(section == OBJECTIVE)
-      {
-         if(LPFhasKeyword(pos, "s[ubject][   ]t[o]")
-               || LPFhasKeyword(pos, "s[uch][    ]t[hat]")
-               || LPFhasKeyword(pos, "s[.][    ]t[.]")
-               || LPFhasKeyword(pos, "lazy con[straints]"))
-         {
-            // store objective vector
-            for(int j = vec.size() - 1; j >= 0; --j)
-               cset.maxObj_w(vec.index(j)) = vec.value(j);
-
-            // multiplication with -1 for minimization is done below
-            vec.clear();
-            have_value = true;
-            val = 1;
-            section = CONSTRAINTS;
-         }
+    } else if (section == OBJECTIVE) {
+      if (LPFhasKeyword(pos, "s[ubject][   ]t[o]") ||
+          LPFhasKeyword(pos, "s[uch][    ]t[hat]") ||
+          LPFhasKeyword(pos, "s[.][    ]t[.]") ||
+          LPFhasKeyword(pos, "lazy con[straints]")) {
+        // store objective vector
+        for (int j = vec.size() - 1; j >= 0; --j)
+          cset.maxObj_w(vec.index(j)) = vec.value(j);
+
+        // multiplication with -1 for minimization is done below
+        vec.clear();
+        have_value = true;
+        val = 1;
+        section = CONSTRAINTS;
       }
-      else if(section == CONSTRAINTS &&
-              (LPFhasKeyword(pos, "s[ubject][   ]t[o]")
-               || LPFhasKeyword(pos, "s[uch][    ]t[hat]")
-               || LPFhasKeyword(pos, "s[.][    ]t[.]")))
-      {
-         have_value = true;
-         val = 1;
+    } else if (section == CONSTRAINTS &&
+               (LPFhasKeyword(pos, "s[ubject][   ]t[o]") ||
+                LPFhasKeyword(pos, "s[uch][    ]t[hat]") ||
+                LPFhasKeyword(pos, "s[.][    ]t[.]"))) {
+      have_value = true;
+      val = 1;
+    } else {
+      if (LPFhasKeyword(pos, "lazy con[straints]"))
+        ;
+      else if (LPFhasKeyword(pos, "bound[s]"))
+        section = BOUNDS;
+      else if (LPFhasKeyword(pos, "bin[ary]"))
+        section = BINARIES;
+      else if (LPFhasKeyword(pos, "bin[aries]"))
+        section = BINARIES;
+      else if (LPFhasKeyword(pos, "gen[erals]"))
+        section = INTEGERS;
+      else if (LPFhasKeyword(pos, "int[egers]")) // this is undocumented
+        section = INTEGERS;
+      else if (LPFhasKeyword(pos, "end")) {
+        finished = true;
+        break;
+      } else if (LPFhasKeyword(pos, "s[ubject][   ]t[o]") // second time
+                 || LPFhasKeyword(pos, "s[uch][    ]t[hat]") ||
+                 LPFhasKeyword(pos, "s[.][    ]t[.]") ||
+                 LPFhasKeyword(pos, "lazy con[straints]")) {
+        // In principle this has to checked for all keywords above,
+        // otherwise we just ignore any half finished constraint
+        if (have_value)
+          goto syntax_error;
+
+        have_value = true;
+        val = 1;
       }
-      else
-      {
-         if(LPFhasKeyword(pos, "lazy con[straints]"))
-            ;
-         else if(LPFhasKeyword(pos, "bound[s]"))
-            section = BOUNDS;
-         else if(LPFhasKeyword(pos, "bin[ary]"))
-            section = BINARIES;
-         else if(LPFhasKeyword(pos, "bin[aries]"))
-            section = BINARIES;
-         else if(LPFhasKeyword(pos, "gen[erals]"))
-            section = INTEGERS;
-         else if(LPFhasKeyword(pos, "int[egers]"))   // this is undocumented
-            section = INTEGERS;
-         else if(LPFhasKeyword(pos, "end"))
-         {
-            finished = true;
-            break;
-         }
-         else if(LPFhasKeyword(pos, "s[ubject][   ]t[o]")  // second time
-                 || LPFhasKeyword(pos, "s[uch][    ]t[hat]")
-                 || LPFhasKeyword(pos, "s[.][    ]t[.]")
-                 || LPFhasKeyword(pos, "lazy con[straints]"))
-         {
-            // In principle this has to checked for all keywords above,
-            // otherwise we just ignore any half finished constraint
-            if(have_value)
-               goto syntax_error;
-
-            have_value = true;
-            val = 1;
-         }
+    }
+
+    // 3a. Look for row names in objective and drop it.
+    if (section == OBJECTIVE)
+      LPFhasRowName(pos, 0);
+
+    // 3b. Look for row name in constraint and store it.
+    if (section == CONSTRAINTS)
+      if (LPFhasRowName(pos, rnames))
+        unnamed = false;
+
+    // 4a. Remove initial spaces.
+    while (LPFisSpace(pos[i]))
+      i++;
+
+    // 4b. remove spaces if they do not appear before the name of a vaiable.
+    for (k = 0; pos[i] != '\0'; i++)
+      if (!LPFisSpace(pos[i]) || LPFisColName(&pos[i + 1]))
+        tmp[k++] = pos[i];
+
+    tmp[k] = '\0';
+
+    // 5. Is this an empty line ?
+    if (tmp[0] == '\0')
+      continue;
+
+    // 6. Collapse sequences of '+' and '-'. e.g ++---+ => -
+    for (i = 0, k = 0; tmp[i] != '\0'; i++) {
+      while (((tmp[i] == '+') || (tmp[i] == '-')) &&
+             ((tmp[i + 1] == '+') || (tmp[i + 1] == '-'))) {
+        if (tmp[i++] == '-')
+          tmp[i] = (tmp[i] == '-') ? '+' : '-';
       }
 
-      // 3a. Look for row names in objective and drop it.
-      if(section == OBJECTIVE)
-         LPFhasRowName(pos, 0);
+      line[k++] = tmp[i];
+    }
+
+    line[k] = '\0';
+
+    //-----------------------------------------------------------------------
+    //--- Line processing loop
+    //-----------------------------------------------------------------------
+    pos = line;
+
+    MSG_DEBUG(std::cout << "DLPFRD09 pos=" << pos << std::endl;)
+
+    // 7. We have something left to process.
+    while ((pos != 0) && (*pos != '\0')) {
+      // remember our position, so we are sure we make progress.
+      pos_old = pos;
+
+      // now process the sections
+      switch (section) {
+      case OBJECTIVE:
+        if (LPFisValue(pos)) {
+          Rational pre_sign = 1;
+
+          /* Already having here a value could only result from being the first
+           * number in a constraint, or a sign
+           * '+' or '-' as last token on the previous line.
+           */
+          if (have_value) {
+            if (spxAbs(val) != 1)
+              goto syntax_error;
+
+            if (val == -1)
+              pre_sign = val;
+          }
+
+          have_value = true;
+          val = LPFreadValue(pos, spxout, lineno);
+          val *= pre_sign;
+        }
+
+        if (*pos == '\0')
+          continue;
+
+        if (!have_value || !LPFisColName(pos))
+          goto syntax_error;
+
+        have_value = false;
+        colidx = LPFreadColName(pos, cnames, cset, &emptycol, spxout);
+        vec.add(colidx, val);
+        break;
+
+      case CONSTRAINTS:
+        if (LPFisValue(pos)) {
+          Rational pre_sign = 1;
+
+          /* Already having here a value could only result from being the first
+           * number in a constraint, or a sign
+           * '+' or '-' as last token on the previous line.
+           */
+          if (have_value) {
+            if (spxAbs(val) != 1)
+              goto syntax_error;
+
+            if (val == -1)
+              pre_sign = val;
+          }
+
+          have_value = true;
+          val = LPFreadValue(pos, spxout, lineno);
+          val *= pre_sign;
+
+          if (sense != 0) {
+            if (sense == '<') {
+              row.setLhs(-infinity);
+              row.setRhs(val);
+            } else if (sense == '>') {
+              row.setLhs(val);
+              row.setRhs(infinity);
+            } else {
+              assert(sense == '=');
+
+              row.setLhs(val);
+              row.setRhs(val);
+            }
 
-      // 3b. Look for row name in constraint and store it.
-      if(section == CONSTRAINTS)
-         if(LPFhasRowName(pos, rnames))
-            unnamed = false;
+            row.setRowVector(vec);
+            rset.add(row);
+            vec.clear();
 
-      // 4a. Remove initial spaces.
-      while(LPFisSpace(pos[i]))
-         i++;
+            if (!unnamed)
+              unnamed = true;
+            else {
+              char name[16];
+              spxSnprintf(name, 16, "C%d", rset.num());
+              rnames->add(name);
+            }
 
-      // 4b. remove spaces if they do not appear before the name of a vaiable.
-      for(k = 0; pos[i] != '\0'; i++)
-         if(!LPFisSpace(pos[i]) || LPFisColName(&pos[i + 1]))
-            tmp[k++] = pos[i];
+            have_value = true;
+            val = 1;
+            sense = 0;
+            pos = 0;
+            // next line
+            continue;
+          }
+        }
 
-      tmp[k] = '\0';
+        if (*pos == '\0')
+          continue;
 
-      // 5. Is this an empty line ?
-      if(tmp[0] == '\0')
-         continue;
+        if (have_value) {
+          if (LPFisColName(pos)) {
+            colidx = LPFreadColName(pos, cnames, cset, &emptycol, spxout);
 
-      // 6. Collapse sequences of '+' and '-'. e.g ++---+ => -
-      for(i = 0, k = 0; tmp[i] != '\0'; i++)
-      {
-         while(((tmp[i] == '+') || (tmp[i] == '-')) && ((tmp[i + 1] == '+') || (tmp[i + 1] == '-')))
-         {
-            if(tmp[i++] == '-')
-               tmp[i] = (tmp[i] == '-') ? '+' : '-';
-         }
+            if (val != 0) {
+              // Do we have this index already in the row?
+              int n = vec.pos(colidx);
 
-         line[k++] = tmp[i];
-      }
+              // if not, add it
+              if (n < 0)
+                vec.add(colidx, val);
+              // if yes, add them up and remove the element if it amounts to
+              // zero
+              else {
+                assert(vec.index(n) == colidx);
 
-      line[k] = '\0';
-
-      //-----------------------------------------------------------------------
-      //--- Line processing loop
-      //-----------------------------------------------------------------------
-      pos = line;
-
-      MSG_DEBUG(std::cout << "DLPFRD09 pos=" << pos << std::endl;)
-
-      // 7. We have something left to process.
-      while((pos != 0) && (*pos != '\0'))
-      {
-         // remember our position, so we are sure we make progress.
-         pos_old = pos;
-
-         // now process the sections
-         switch(section)
-         {
-         case OBJECTIVE:
-            if(LPFisValue(pos))
-            {
-               Rational pre_sign = 1;
-
-               /* Already having here a value could only result from being the first number in a constraint, or a sign
-                * '+' or '-' as last token on the previous line.
-                */
-               if(have_value)
-               {
-                  if(spxAbs(val) != 1)
-                     goto syntax_error;
-
-                  if(val == -1)
-                     pre_sign = val;
-               }
-
-               have_value = true;
-               val = LPFreadValue(pos, spxout, lineno);
-               val *= pre_sign;
-            }
+                val += vec.value(n);
 
-            if(*pos == '\0')
-               continue;
+                if (val == 0)
+                  vec.remove(n);
+                else
+                  vec.value(n) = val;
 
-            if(!have_value || !LPFisColName(pos))
-               goto syntax_error;
+                assert(cnames->has(colidx));
 
-            have_value = false;
-            colidx = LPFreadColName(pos, cnames, cset, &emptycol, spxout);
-            vec.add(colidx, val);
-            break;
-
-         case CONSTRAINTS:
-            if(LPFisValue(pos))
-            {
-               Rational pre_sign = 1;
-
-               /* Already having here a value could only result from being the first number in a constraint, or a sign
-                * '+' or '-' as last token on the previous line.
-                */
-               if(have_value)
-               {
-                  if(spxAbs(val) != 1)
-                     goto syntax_error;
-
-                  if(val == -1)
-                     pre_sign = val;
-               }
-
-               have_value = true;
-               val = LPFreadValue(pos, spxout, lineno);
-               val *= pre_sign;
-
-               if(sense != 0)
-               {
-                  if(sense == '<')
-                  {
-                     row.setLhs(-infinity);
-                     row.setRhs(val);
-                  }
-                  else if(sense == '>')
-                  {
-                     row.setLhs(val);
-                     row.setRhs(infinity);
-                  }
-                  else
-                  {
-                     assert(sense == '=');
-
-                     row.setLhs(val);
-                     row.setRhs(val);
-                  }
-
-                  row.setRowVector(vec);
-                  rset.add(row);
-                  vec.clear();
-
-                  if(!unnamed)
-                     unnamed = true;
-                  else
-                  {
-                     char name[16];
-                     spxSnprintf(name, 16, "C%d", rset.num());
-                     rnames->add(name);
-                  }
-
-                  have_value = true;
-                  val = 1;
-                  sense = 0;
-                  pos = 0;
-                  // next line
-                  continue;
-               }
+                MSG_WARNING((*this->spxout),
+                            (*this->spxout) << "WLPFRD10 Duplicate index "
+                                            << (*cnames)[colidx] << " in line "
+                                            << lineno << std::endl;)
+              }
             }
 
-            if(*pos == '\0')
-               continue;
-
-            if(have_value)
-            {
-               if(LPFisColName(pos))
-               {
-                  colidx = LPFreadColName(pos, cnames, cset, &emptycol, spxout);
-
-                  if(val != 0)
-                  {
-                     // Do we have this index already in the row?
-                     int n = vec.pos(colidx);
-
-                     // if not, add it
-                     if(n < 0)
-                        vec.add(colidx, val);
-                     // if yes, add them up and remove the element if it amounts to zero
-                     else
-                     {
-                        assert(vec.index(n) == colidx);
-
-                        val += vec.value(n);
-
-                        if(val == 0)
-                           vec.remove(n);
-                        else
-                           vec.value(n) = val;
-
-                        assert(cnames->has(colidx));
-
-                        MSG_WARNING((*this->spxout), (*this->spxout) << "WLPFRD10 Duplicate index "
-                                    << (*cnames)[colidx]
-                                    << " in line " << lineno
-                                    << std::endl;)
-                     }
-                  }
-
-                  have_value = false;
-               }
-               else
-               {
-                  // We have a row like c1: <= 5 with no variables. We can not handle 10 <= 5; issue a syntax error.
-                  if(val != 1)
-                     goto syntax_error;
-
-                  // If the next thing is not the sense we give up also.
-                  if(!LPFisSense(pos))
-                     goto syntax_error;
-
-                  have_value = false;
-               }
-            }
+            have_value = false;
+          } else {
+            // We have a row like c1: <= 5 with no variables. We can not handle
+            // 10 <= 5; issue a syntax error.
+            if (val != 1)
+              goto syntax_error;
 
-            assert(!have_value);
+            // If the next thing is not the sense we give up also.
+            if (!LPFisSense(pos))
+              goto syntax_error;
 
-            if(LPFisSense(pos))
-               sense = LPFreadSense(pos);
+            have_value = false;
+          }
+        }
 
-            break;
+        assert(!have_value);
 
-         case BOUNDS:
-            other = false;
-            sense = 0;
+        if (LPFisSense(pos))
+          sense = LPFreadSense(pos);
 
-            if(LPFisValue(pos))
-            {
-               val = LPFisInfinity(pos) ? LPFreadInfinity(pos) : LPFreadValue(pos, spxout, lineno);
+        break;
 
-               if(!LPFisSense(pos))
-                  goto syntax_error;
+      case BOUNDS:
+        other = false;
+        sense = 0;
 
-               sense = LPFreadSense(pos);
-               other = true;
-            }
+        if (LPFisValue(pos)) {
+          val = LPFisInfinity(pos) ? LPFreadInfinity(pos)
+                                   : LPFreadValue(pos, spxout, lineno);
 
-            if(!LPFisColName(pos))
-               goto syntax_error;
+          if (!LPFisSense(pos))
+            goto syntax_error;
 
-            if((colidx = LPFreadColName(pos, cnames, cset, 0, spxout)) < 0)
-            {
-               MSG_WARNING((*this->spxout), (*this->spxout) << "WLPFRD11 in Bounds section line "
-                           << lineno << " ignored" << std::endl;)
-               *pos = '\0';
-               continue;
-            }
+          sense = LPFreadSense(pos);
+          other = true;
+        }
+
+        if (!LPFisColName(pos))
+          goto syntax_error;
+
+        if ((colidx = LPFreadColName(pos, cnames, cset, 0, spxout)) < 0) {
+          MSG_WARNING((*this->spxout),
+                      (*this->spxout) << "WLPFRD11 in Bounds section line "
+                                      << lineno << " ignored" << std::endl;)
+          *pos = '\0';
+          continue;
+        }
+
+        if (sense) {
+          if (sense == '<')
+            cset.lower_w(colidx) = val;
+          else if (sense == '>')
+            cset.upper_w(colidx) = val;
+          else {
+            assert(sense == '=');
+            cset.lower_w(colidx) = val;
+            cset.upper_w(colidx) = val;
+          }
+        }
+
+        if (LPFisFree(pos)) {
+          cset.lower_w(colidx) = -infinity;
+          cset.upper_w(colidx) = infinity;
+          other = true;
+          pos += 4; // set position after the word "free"
+        } else if (LPFisSense(pos)) {
+          sense = LPFreadSense(pos);
+          other = true;
+
+          if (!LPFisValue(pos))
+            goto syntax_error;
 
-            if(sense)
-            {
-               if(sense == '<')
-                  cset.lower_w(colidx) = val;
-               else if(sense == '>')
-                  cset.upper_w(colidx) = val;
-               else
-               {
-                  assert(sense == '=');
-                  cset.lower_w(colidx) = val;
-                  cset.upper_w(colidx) = val;
-               }
+          val = LPFisInfinity(pos) ? LPFreadInfinity(pos)
+                                   : LPFreadValue(pos, spxout, lineno);
+
+          if (sense == '<')
+            cset.upper_w(colidx) = val;
+          else if (sense == '>')
+            cset.lower_w(colidx) = val;
+          else {
+            assert(sense == '=');
+            cset.lower_w(colidx) = val;
+            cset.upper_w(colidx) = val;
+          }
+        }
+
+        /* Do we have only a single column name in the input line?  We could
+         * ignore this savely, but it is probably a sign of some other error.
+         */
+        if (!other)
+          goto syntax_error;
+
+        break;
+
+      case BINARIES:
+      case INTEGERS:
+        if ((colidx = LPFreadColName(pos, cnames, cset, 0, spxout)) < 0) {
+          MSG_WARNING((*this->spxout),
+                      (*this->spxout)
+                          << "WLPFRD12 in Binary/General section line "
+                          << lineno << " ignored" << std::endl;)
+        } else {
+          if (section == BINARIES) {
+            if (cset.lower(colidx) < 0) {
+              cset.lower_w(colidx) = 0;
             }
 
-            if(LPFisFree(pos))
-            {
-               cset.lower_w(colidx) = -infinity;
-               cset.upper_w(colidx) =  infinity;
-               other = true;
-               pos += 4;  // set position after the word "free"
-            }
-            else if(LPFisSense(pos))
-            {
-               sense = LPFreadSense(pos);
-               other = true;
-
-               if(!LPFisValue(pos))
-                  goto syntax_error;
-
-               val = LPFisInfinity(pos) ? LPFreadInfinity(pos) : LPFreadValue(pos,  spxout, lineno);
-
-               if(sense == '<')
-                  cset.upper_w(colidx) = val;
-               else if(sense == '>')
-                  cset.lower_w(colidx) = val;
-               else
-               {
-                  assert(sense == '=');
-                  cset.lower_w(colidx) = val;
-                  cset.upper_w(colidx) = val;
-               }
-            }
-
-            /* Do we have only a single column name in the input line?  We could ignore this savely, but it is probably
-             * a sign of some other error.
-             */
-            if(!other)
-               goto syntax_error;
-
-            break;
-
-         case BINARIES:
-         case INTEGERS:
-            if((colidx = LPFreadColName(pos, cnames, cset, 0, spxout)) < 0)
-            {
-               MSG_WARNING((*this->spxout), (*this->spxout) << "WLPFRD12 in Binary/General section line " << lineno
-                           << " ignored" << std::endl;)
-            }
-            else
-            {
-               if(section == BINARIES)
-               {
-                  if(cset.lower(colidx) < 0)
-                  {
-                     cset.lower_w(colidx) = 0;
-                  }
-
-                  if(cset.upper(colidx) > 1)
-                  {
-                     cset.upper_w(colidx) = 1;
-                  }
-               }
-
-               if(p_intvars != 0)
-                  p_intvars->addIdx(colidx);
+            if (cset.upper(colidx) > 1) {
+              cset.upper_w(colidx) = 1;
             }
+          }
 
-            break;
+          if (p_intvars != 0)
+            p_intvars->addIdx(colidx);
+        }
 
-         case START:
-            MSG_ERROR(std::cerr << "ELPFRD13 This seems to be no LP format file" << std::endl;)
-            goto syntax_error;
+        break;
 
-         default:
-            throw SPxInternalCodeException("XLPFRD01 This should never happen.");
-         }
+      case START:
+        MSG_ERROR(std::cerr << "ELPFRD13 This seems to be no LP format file"
+                            << std::endl;)
+        goto syntax_error;
 
-         if(pos == pos_old)
-            goto syntax_error;
+      default:
+        throw SPxInternalCodeException("XLPFRD01 This should never happen.");
       }
-   }
 
-   assert(isConsistent());
+      if (pos == pos_old)
+        goto syntax_error;
+    }
+  }
 
-   addCols(cset);
-   assert(isConsistent());
+  assert(isConsistent());
 
-   addRows(rset);
-   assert(isConsistent());
+  addCols(cset);
+  assert(isConsistent());
+
+  addRows(rset);
+  assert(isConsistent());
 
 syntax_error:
 
-   if(finished)
-   {
-      MSG_INFO2((*this->spxout), (*this->spxout) << "Finished reading " << lineno << " lines" <<
-                std::endl;)
-   }
-   else
-      MSG_ERROR(std::cerr << "ELPFRD15 Syntax error in line " << lineno << std::endl;)
+  if (finished) {
+    MSG_INFO2((*this->spxout), (*this->spxout) << "Finished reading " << lineno
+                                               << " lines" << std::endl;)
+  } else
+    MSG_ERROR(std::cerr << "ELPFRD15 Syntax error in line " << lineno
+                        << std::endl;)
 
-      if(p_cnames == 0)
-         spx_free(cnames);
+  if (p_cnames == 0)
+    spx_free(cnames);
 
-   if(p_rnames == 0)
-      spx_free(rnames);
+  if (p_rnames == 0)
+    spx_free(rnames);
 
-   return finished;
+  return finished;
 }
 
 /// Process ROWS section.
-static void MPSreadRows(MPSInput& mps, LPRowSetBase<Rational>& rset, NameSet& rnames,
-                        SPxOut* spxout)
-{
-   LPRowBase<Rational> row;
+static void MPSreadRows(MPSInput &mps, LPRowSetBase<Rational> &rset,
+                        NameSet &rnames, SPxOut *spxout) {
+  LPRowBase<Rational> row;
 
-   while(mps.readLine())
-   {
-      if(mps.field0() != 0)
-      {
-         MSG_INFO2((*spxout), (*spxout) << "IMPSRD02 Objective name : " << mps.objName() << std::endl;)
+  while (mps.readLine()) {
+    if (mps.field0() != 0) {
+      MSG_INFO2((*spxout), (*spxout) << "IMPSRD02 Objective name : "
+                                     << mps.objName() << std::endl;)
 
-         if(strcmp(mps.field0(), "COLUMNS"))
-            break;
+      if (strcmp(mps.field0(), "COLUMNS"))
+        break;
 
-         mps.setSection(MPSInput::COLUMNS);
+      mps.setSection(MPSInput::COLUMNS);
 
-         return;
+      return;
+    }
+
+    if (*mps.field1() == 'N') {
+      if (*mps.objName() == '\0')
+        mps.setObjName(mps.field2());
+    } else {
+      if (rnames.has(mps.field2()))
+        break;
+
+      rnames.add(mps.field2());
+
+      switch (*mps.field1()) {
+      case 'G':
+        row.setLhs(0);
+        row.setRhs(infinity);
+        break;
+
+      case 'E':
+        row.setLhs(0);
+        row.setRhs(0);
+        break;
+
+      case 'L':
+        row.setLhs(-infinity);
+        row.setRhs(0);
+        break;
+
+      default:
+        mps.syntaxError();
+        return;
       }
 
-      if(*mps.field1() == 'N')
-      {
-         if(*mps.objName() == '\0')
-            mps.setObjName(mps.field2());
-      }
-      else
-      {
-         if(rnames.has(mps.field2()))
-            break;
-
-         rnames.add(mps.field2());
-
-         switch(*mps.field1())
-         {
-         case 'G':
-            row.setLhs(0);
-            row.setRhs(infinity);
-            break;
-
-         case 'E':
-            row.setLhs(0);
-            row.setRhs(0);
-            break;
-
-         case 'L':
-            row.setLhs(-infinity);
-            row.setRhs(0);
-            break;
-
-         default:
-            mps.syntaxError();
-            return;
-         }
-
-         rset.add(row);
-      }
+      rset.add(row);
+    }
 
-      assert((*mps.field1() == 'N') || (rnames.number(mps.field2()) == rset.num() - 1));
-   }
+    assert((*mps.field1() == 'N') ||
+           (rnames.number(mps.field2()) == rset.num() - 1));
+  }
 
-   mps.syntaxError();
+  mps.syntaxError();
 }
 
-
-
 /// Process COLUMNS section.
-static void MPSreadCols(MPSInput& mps, const LPRowSetBase<Rational>& rset, const NameSet&  rnames,
-                        LPColSetBase<Rational>& cset, NameSet& cnames, DIdxSet* intvars, SPxOut* spxout)
-{
-   Rational val;
-   int idx;
-   char colname[MPSInput::MAX_LINE_LEN] = { '\0' };
-   LPColBase<Rational> col(rset.num());
-   DSVectorBase<Rational> vec;
-
-   col.setObj(0);
-   vec.clear();
-
-   while(mps.readLine())
-   {
-      if(mps.field0() != 0)
-      {
-         if(strcmp(mps.field0(), "RHS"))
-            break;
-
-         if(colname[0] != '\0')
-         {
-            col.setColVector(vec);
-            cset.add(col);
-         }
-
-         mps.setSection(MPSInput::RHS);
-
-         return;
+static void MPSreadCols(MPSInput &mps, const LPRowSetBase<Rational> &rset,
+                        const NameSet &rnames, LPColSetBase<Rational> &cset,
+                        NameSet &cnames, DIdxSet *intvars, SPxOut *spxout) {
+  Rational val;
+  int idx;
+  char colname[MPSInput::MAX_LINE_LEN] = {'\0'};
+  LPColBase<Rational> col(rset.num());
+  DSVectorBase<Rational> vec;
+
+  col.setObj(0);
+  vec.clear();
+
+  while (mps.readLine()) {
+    if (mps.field0() != 0) {
+      if (strcmp(mps.field0(), "RHS"))
+        break;
+
+      if (colname[0] != '\0') {
+        col.setColVector(vec);
+        cset.add(col);
       }
 
-      if((mps.field1() == 0) || (mps.field2() == 0) || (mps.field3() == 0))
-         break;
-
-      // new column?
-      if(strcmp(colname, mps.field1()))
-      {
-         // first column?
-         if(colname[0] != '\0')
-         {
-            col.setColVector(vec);
-            cset.add(col);
-         }
-
-         // save copy of string (make sure string ends with \0)
-         spxSnprintf(colname, MPSInput::MAX_LINE_LEN - 1, "%s", mps.field1());
-         colname[MPSInput::MAX_LINE_LEN - 1] = '\0';
-
-         int ncnames = cnames.size();
-         cnames.add(colname);
-
-         // check whether the new name is unique wrt previous column names
-         if(cnames.size() <= ncnames)
-         {
-            MSG_ERROR(std::cerr << "ERROR in COLUMNS: duplicate column name or not column-wise ordering" <<
-                      std::endl;)
-            break;
-         }
-
-         vec.clear();
-         col.setObj(0);
-         col.setLower(0);
-         col.setUpper(infinity);
-
-         if(mps.isInteger())
-         {
-            assert(cnames.number(colname) == cset.num());
-
-            if(intvars != 0)
-               intvars->addIdx(cnames.number(colname));
-
-            // for Integer variable the default bounds are 0/1
-            col.setUpper(1);
-         }
-      }
+      mps.setSection(MPSInput::RHS);
 
-      try
-      {
-         val = ratFromString(mps.field3());
-      }
-      catch(const std::exception& e)
-      {
-         MSG_WARNING((*spxout), (*spxout) << "WMPSRD01 Warning: malformed rational value in MPS file\n");
-         std::cerr << e.what() << '\n';
-      }
+      return;
+    }
 
-      if(!strcmp(mps.field2(), mps.objName()))
-         col.setObj(val);
-      else
-      {
-         if((idx = rnames.number(mps.field2())) < 0)
-            mps.entryIgnored("Column", mps.field1(), "row", mps.field2());
-         else if(val != 0)
-            vec.add(idx, val);
+    if ((mps.field1() == 0) || (mps.field2() == 0) || (mps.field3() == 0))
+      break;
+
+    // new column?
+    if (strcmp(colname, mps.field1())) {
+      // first column?
+      if (colname[0] != '\0') {
+        col.setColVector(vec);
+        cset.add(col);
       }
 
-      if(mps.field5() != 0)
-      {
-         assert(mps.field4() != 0);
+      // save copy of string (make sure string ends with \0)
+      spxSnprintf(colname, MPSInput::MAX_LINE_LEN - 1, "%s", mps.field1());
+      colname[MPSInput::MAX_LINE_LEN - 1] = '\0';
 
-         try
-         {
-            val = ratFromString(mps.field5());
-         }
-         catch(const std::exception& e)
-         {
-            MSG_WARNING((*spxout), (*spxout) << "WMPSRD02 Warning: malformed rational value in MPS file\n");
-            std::cerr << e.what() << '\n';
-         }
-
-         if(!strcmp(mps.field4(), mps.objName()))
-            col.setObj(val);
-         else
-         {
-            if((idx = rnames.number(mps.field4())) < 0)
-               mps.entryIgnored("Column", mps.field1(), "row", mps.field4());
-            else if(val != 0)
-               vec.add(idx, val);
-         }
+      int ncnames = cnames.size();
+      cnames.add(colname);
+
+      // check whether the new name is unique wrt previous column names
+      if (cnames.size() <= ncnames) {
+        MSG_ERROR(std::cerr << "ERROR in COLUMNS: duplicate column name or not "
+                               "column-wise ordering"
+                            << std::endl;)
+        break;
       }
-   }
 
-   mps.syntaxError();
-}
+      vec.clear();
+      col.setObj(0);
+      col.setLower(0);
+      col.setUpper(infinity);
 
+      if (mps.isInteger()) {
+        assert(cnames.number(colname) == cset.num());
 
+        if (intvars != 0)
+          intvars->addIdx(cnames.number(colname));
 
-/// Process RHS section.
-static void MPSreadRhs(MPSInput& mps, LPRowSetBase<Rational>& rset, const NameSet& rnames,
-                       SPxOut* spxout)
-{
-   char rhsname[MPSInput::MAX_LINE_LEN] = { '\0' };
-   char addname[MPSInput::MAX_LINE_LEN] = { '\0' };
-   int idx;
-   Rational val;
-
-   while(mps.readLine())
-   {
-      if(mps.field0() != 0)
-      {
-         MSG_INFO2((*spxout), (*spxout) << "IMPSRD03 RHS name       : " << rhsname  << std::endl;);
-
-         if(!strcmp(mps.field0(), "RANGES"))
-            mps.setSection(MPSInput::RANGES);
-         else if(!strcmp(mps.field0(), "BOUNDS"))
-            mps.setSection(MPSInput::BOUNDS);
-         else if(!strcmp(mps.field0(), "ENDATA"))
-            mps.setSection(MPSInput::ENDATA);
-         else
-            break;
-
-         return;
+        // for Integer variable the default bounds are 0/1
+        col.setUpper(1);
+      }
+    }
+
+    try {
+      val = ratFromString(mps.field3());
+    } catch (const std::exception &e) {
+      MSG_WARNING(
+          (*spxout),
+          (*spxout)
+              << "WMPSRD01 Warning: malformed rational value in MPS file\n");
+      std::cerr << e.what() << '\n';
+    }
+
+    if (!strcmp(mps.field2(), mps.objName()))
+      col.setObj(val);
+    else {
+      if ((idx = rnames.number(mps.field2())) < 0)
+        mps.entryIgnored("Column", mps.field1(), "row", mps.field2());
+      else if (val != 0)
+        vec.add(idx, val);
+    }
+
+    if (mps.field5() != 0) {
+      assert(mps.field4() != 0);
+
+      try {
+        val = ratFromString(mps.field5());
+      } catch (const std::exception &e) {
+        MSG_WARNING(
+            (*spxout),
+            (*spxout)
+                << "WMPSRD02 Warning: malformed rational value in MPS file\n");
+        std::cerr << e.what() << '\n';
       }
 
-      if(((mps.field2() != 0) && (mps.field3() == 0)) || ((mps.field4() != 0) && (mps.field5() == 0)))
-         mps.insertName("_RHS_");
-
-      if((mps.field1() == 0) || (mps.field2() == 0) || (mps.field3() == 0))
-         break;
+      if (!strcmp(mps.field4(), mps.objName()))
+        col.setObj(val);
+      else {
+        if ((idx = rnames.number(mps.field4())) < 0)
+          mps.entryIgnored("Column", mps.field1(), "row", mps.field4());
+        else if (val != 0)
+          vec.add(idx, val);
+      }
+    }
+  }
 
-      if(*rhsname == '\0')
-         spxSnprintf(rhsname, MPSInput::MAX_LINE_LEN, "%s", mps.field1());
+  mps.syntaxError();
+}
 
-      if(strcmp(rhsname, mps.field1()))
-      {
-         if(strcmp(addname, mps.field1()))
-         {
-            assert(strlen(mps.field1()) < MPSInput::MAX_LINE_LEN);
-            spxSnprintf(addname, MPSInput::MAX_LINE_LEN, "%s", mps.field1());
-            MSG_INFO3((*spxout), (*spxout) << "IMPSRD07 RHS ignored    : " << addname << std::endl);
-         }
-      }
+/// Process RHS section.
+static void MPSreadRhs(MPSInput &mps, LPRowSetBase<Rational> &rset,
+                       const NameSet &rnames, SPxOut *spxout) {
+  char rhsname[MPSInput::MAX_LINE_LEN] = {'\0'};
+  char addname[MPSInput::MAX_LINE_LEN] = {'\0'};
+  int idx;
+  Rational val;
+
+  while (mps.readLine()) {
+    if (mps.field0() != 0) {
+      MSG_INFO2((*spxout), (*spxout) << "IMPSRD03 RHS name       : " << rhsname
+                                     << std::endl;);
+
+      if (!strcmp(mps.field0(), "RANGES"))
+        mps.setSection(MPSInput::RANGES);
+      else if (!strcmp(mps.field0(), "BOUNDS"))
+        mps.setSection(MPSInput::BOUNDS);
+      else if (!strcmp(mps.field0(), "ENDATA"))
+        mps.setSection(MPSInput::ENDATA);
       else
-      {
-         if((idx = rnames.number(mps.field2())) < 0)
-            mps.entryIgnored("RHS", mps.field1(), "row", mps.field2());
-         else
-         {
-            try
-            {
-               val = ratFromString(mps.field3());
-            }
-            catch(const std::exception& e)
-            {
-               MSG_WARNING((*spxout), (*spxout) << "WMPSRD03 Warning: malformed rational value in MPS file\n");
-               std::cerr << e.what() << '\n';
-            }
+        break;
 
-            // LE or EQ
-            if(double(rset.rhs(idx)) < double(infinity))
-               rset.rhs_w(idx) = val;
+      return;
+    }
 
-            // GE or EQ
-            if(double(rset.lhs(idx)) > double(-infinity))
-               rset.lhs_w(idx) = val;
-         }
+    if (((mps.field2() != 0) && (mps.field3() == 0)) ||
+        ((mps.field4() != 0) && (mps.field5() == 0)))
+      mps.insertName("_RHS_");
 
-         if(mps.field5() != 0)
-         {
-            if((idx = rnames.number(mps.field4())) < 0)
-               mps.entryIgnored("RHS", mps.field1(), "row", mps.field4());
-            else
-            {
-               try
-               {
-                  val = ratFromString(mps.field5());
-               }
-               catch(const std::exception& e)
-               {
-                  MSG_WARNING((*spxout), (*spxout) << "WMPSRD04 Warning: malformed rational value in MPS file\n");
-                  std::cerr << e.what() << '\n';
-               }
-
-               // LE or EQ
-               if(double(rset.rhs(idx)) < double(infinity))
-                  rset.rhs_w(idx) = val;
-
-               // GE or EQ
-               if(double(rset.lhs(idx)) > double(-infinity))
-                  rset.lhs_w(idx) = val;
-            }
-         }
-      }
-   }
+    if ((mps.field1() == 0) || (mps.field2() == 0) || (mps.field3() == 0))
+      break;
 
-   mps.syntaxError();
-}
+    if (*rhsname == '\0')
+      spxSnprintf(rhsname, MPSInput::MAX_LINE_LEN, "%s", mps.field1());
 
+    if (strcmp(rhsname, mps.field1())) {
+      if (strcmp(addname, mps.field1())) {
+        assert(strlen(mps.field1()) < MPSInput::MAX_LINE_LEN);
+        spxSnprintf(addname, MPSInput::MAX_LINE_LEN, "%s", mps.field1());
+        MSG_INFO3((*spxout), (*spxout) << "IMPSRD07 RHS ignored    : "
+                                       << addname << std::endl);
+      }
+    } else {
+      if ((idx = rnames.number(mps.field2())) < 0)
+        mps.entryIgnored("RHS", mps.field1(), "row", mps.field2());
+      else {
+        try {
+          val = ratFromString(mps.field3());
+        } catch (const std::exception &e) {
+          MSG_WARNING((*spxout), (*spxout) << "WMPSRD03 Warning: malformed "
+                                              "rational value in MPS file\n");
+          std::cerr << e.what() << '\n';
+        }
+
+        // LE or EQ
+        if (double(rset.rhs(idx)) < double(infinity))
+          rset.rhs_w(idx) = val;
+
+        // GE or EQ
+        if (double(rset.lhs(idx)) > double(-infinity))
+          rset.lhs_w(idx) = val;
+      }
 
+      if (mps.field5() != 0) {
+        if ((idx = rnames.number(mps.field4())) < 0)
+          mps.entryIgnored("RHS", mps.field1(), "row", mps.field4());
+        else {
+          try {
+            val = ratFromString(mps.field5());
+          } catch (const std::exception &e) {
+            MSG_WARNING((*spxout), (*spxout) << "WMPSRD04 Warning: malformed "
+                                                "rational value in MPS file\n");
+            std::cerr << e.what() << '\n';
+          }
 
-/// Process RANGES section.
-static void MPSreadRanges(MPSInput& mps,  LPRowSetBase<Rational>& rset, const NameSet& rnames,
-                          SPxOut* spxout)
-{
-   char rngname[MPSInput::MAX_LINE_LEN] = { '\0' };
-   int idx;
-   Rational val;
-
-   while(mps.readLine())
-   {
-      if(mps.field0() != 0)
-      {
-         MSG_INFO2((*spxout), (*spxout) << "IMPSRD04 Range name     : " << rngname << std::endl;);
-
-         if(!strcmp(mps.field0(), "BOUNDS"))
-            mps.setSection(MPSInput::BOUNDS);
-         else if(!strcmp(mps.field0(), "ENDATA"))
-            mps.setSection(MPSInput::ENDATA);
-         else
-            break;
-
-         return;
+          // LE or EQ
+          if (double(rset.rhs(idx)) < double(infinity))
+            rset.rhs_w(idx) = val;
+
+          // GE or EQ
+          if (double(rset.lhs(idx)) > double(-infinity))
+            rset.lhs_w(idx) = val;
+        }
       }
+    }
+  }
 
-      if(((mps.field2() != 0) && (mps.field3() == 0)) || ((mps.field4() != 0) && (mps.field5() == 0)))
-         mps.insertName("_RNG_");
+  mps.syntaxError();
+}
 
-      if((mps.field1() == 0) || (mps.field2() == 0) || (mps.field3() == 0))
-         break;
+/// Process RANGES section.
+static void MPSreadRanges(MPSInput &mps, LPRowSetBase<Rational> &rset,
+                          const NameSet &rnames, SPxOut *spxout) {
+  char rngname[MPSInput::MAX_LINE_LEN] = {'\0'};
+  int idx;
+  Rational val;
+
+  while (mps.readLine()) {
+    if (mps.field0() != 0) {
+      MSG_INFO2((*spxout), (*spxout) << "IMPSRD04 Range name     : " << rngname
+                                     << std::endl;);
+
+      if (!strcmp(mps.field0(), "BOUNDS"))
+        mps.setSection(MPSInput::BOUNDS);
+      else if (!strcmp(mps.field0(), "ENDATA"))
+        mps.setSection(MPSInput::ENDATA);
+      else
+        break;
 
-      if(*rngname == '\0')
-      {
-         assert(strlen(mps.field1()) < MPSInput::MAX_LINE_LEN);
-         spxSnprintf(rngname, MPSInput::MAX_LINE_LEN, "%s", mps.field1());
+      return;
+    }
+
+    if (((mps.field2() != 0) && (mps.field3() == 0)) ||
+        ((mps.field4() != 0) && (mps.field5() == 0)))
+      mps.insertName("_RNG_");
+
+    if ((mps.field1() == 0) || (mps.field2() == 0) || (mps.field3() == 0))
+      break;
+
+    if (*rngname == '\0') {
+      assert(strlen(mps.field1()) < MPSInput::MAX_LINE_LEN);
+      spxSnprintf(rngname, MPSInput::MAX_LINE_LEN, "%s", mps.field1());
+    }
+
+    /* The rules are:
+     * Row Sign   LHS             RHS
+     * ----------------------------------------
+     *  G   +/-   rhs             rhs + |range|
+     *  L   +/-   rhs - |range|   rhs
+     *  E   +     rhs             rhs + range
+     *  E   -     rhs + range     rhs
+     * ----------------------------------------
+     */
+    if (!strcmp(rngname, mps.field1())) {
+      if ((idx = rnames.number(mps.field2())) < 0)
+        mps.entryIgnored("Range", mps.field1(), "row", mps.field2());
+      else {
+        try {
+          val = ratFromString(mps.field3());
+        } catch (const std::exception &e) {
+          MSG_WARNING((*spxout), (*spxout) << "WMPSRD05 Warning: malformed "
+                                              "rational value in MPS file\n");
+          std::cerr << e.what() << '\n';
+        }
+
+        // EQ
+        if ((double(rset.lhs(idx)) > -double(infinity)) &&
+            (double(rset.rhs_w(idx)) < double(infinity))) {
+          assert(rset.lhs(idx) == rset.rhs(idx));
+
+          if (double(val) >= 0)
+            rset.rhs_w(idx) += val;
+          else
+            rset.lhs_w(idx) += val;
+        } else {
+          // GE
+          if (double(rset.lhs(idx)) > -double(infinity)) {
+            rset.rhs_w(idx) = rset.lhs(idx);
+            rset.rhs_w(idx) += spxAbs(val);
+          }
+          // LE
+          else {
+            rset.lhs_w(idx) = rset.rhs(idx);
+            rset.lhs_w(idx) -= spxAbs(val);
+          }
+        }
       }
 
-      /* The rules are:
-       * Row Sign   LHS             RHS
-       * ----------------------------------------
-       *  G   +/-   rhs             rhs + |range|
-       *  L   +/-   rhs - |range|   rhs
-       *  E   +     rhs             rhs + range
-       *  E   -     rhs + range     rhs
-       * ----------------------------------------
-       */
-      if(!strcmp(rngname, mps.field1()))
-      {
-         if((idx = rnames.number(mps.field2())) < 0)
-            mps.entryIgnored("Range", mps.field1(), "row", mps.field2());
-         else
-         {
-            try
-            {
-               val = ratFromString(mps.field3());
-            }
-            catch(const std::exception& e)
-            {
-               MSG_WARNING((*spxout), (*spxout) << "WMPSRD05 Warning: malformed rational value in MPS file\n");
-               std::cerr << e.what() << '\n';
-            }
+      if (mps.field5() != 0) {
+        if ((idx = rnames.number(mps.field4())) < 0)
+          mps.entryIgnored("Range", mps.field1(), "row", mps.field4());
+        else {
+          try {
+            val = ratFromString(mps.field5());
+          } catch (const std::exception &e) {
+            MSG_WARNING((*spxout), (*spxout) << "WMPSRD06 Warning: malformed "
+                                                "rational value in MPS file\n");
+            std::cerr << e.what() << '\n';
+          }
 
-            // EQ
-            if((double(rset.lhs(idx)) > -double(infinity)) && (double(rset.rhs_w(idx)) < double(infinity)))
-            {
-               assert(rset.lhs(idx) == rset.rhs(idx));
+          // EQ
+          if ((double(rset.lhs(idx)) > -double(infinity)) &&
+              (double(rset.rhs(idx)) < double(infinity))) {
+            assert(rset.lhs(idx) == rset.rhs(idx));
 
-               if(double(val) >= 0)
-                  rset.rhs_w(idx) += val;
-               else
-                  rset.lhs_w(idx) += val;
-            }
+            if (double(val) >= 0)
+              rset.rhs_w(idx) += val;
             else
-            {
-               // GE
-               if(double(rset.lhs(idx)) > -double(infinity))
-               {
-                  rset.rhs_w(idx) = rset.lhs(idx);
-                  rset.rhs_w(idx) += spxAbs(val);
-               }
-               // LE
-               else
-               {
-                  rset.lhs_w(idx) = rset.rhs(idx);
-                  rset.lhs_w(idx) -= spxAbs(val);
-               }
+              rset.lhs_w(idx) += val;
+          } else {
+            // GE
+            if (double(rset.lhs(idx)) > -double(infinity)) {
+              rset.rhs_w(idx) = rset.lhs(idx);
+              rset.rhs_w(idx) += spxAbs(val);
             }
-         }
-
-         if(mps.field5() != 0)
-         {
-            if((idx = rnames.number(mps.field4())) < 0)
-               mps.entryIgnored("Range", mps.field1(), "row", mps.field4());
-            else
-            {
-               try
-               {
-                  val = ratFromString(mps.field5());
-               }
-               catch(const std::exception& e)
-               {
-                  MSG_WARNING((*spxout), (*spxout) << "WMPSRD06 Warning: malformed rational value in MPS file\n");
-                  std::cerr << e.what() << '\n';
-               }
-
-               // EQ
-               if((double(rset.lhs(idx)) > -double(infinity)) && (double(rset.rhs(idx)) <  double(infinity)))
-               {
-                  assert(rset.lhs(idx) == rset.rhs(idx));
-
-                  if(double(val) >= 0)
-                     rset.rhs_w(idx) += val;
-                  else
-                     rset.lhs_w(idx) += val;
-               }
-               else
-               {
-                  // GE
-                  if(double(rset.lhs(idx)) > -double(infinity))
-                  {
-                     rset.rhs_w(idx) = rset.lhs(idx);
-                     rset.rhs_w(idx) += spxAbs(val);
-                  }
-                  // LE
-                  else
-                  {
-                     rset.lhs_w(idx) = rset.rhs(idx);
-                     rset.lhs_w(idx) -= spxAbs(val);
-                  }
-               }
+            // LE
+            else {
+              rset.lhs_w(idx) = rset.rhs(idx);
+              rset.lhs_w(idx) -= spxAbs(val);
             }
-         }
+          }
+        }
       }
-   }
+    }
+  }
 
-   mps.syntaxError();
+  mps.syntaxError();
 }
 
-
-
 /// Process BOUNDS section.
-static void MPSreadBounds(MPSInput& mps, LPColSetBase<Rational>& cset, const NameSet& cnames,
-                          DIdxSet* intvars, SPxOut* spxout)
-{
-   DIdxSet oldbinvars;
-   char bndname[MPSInput::MAX_LINE_LEN] = { '\0' };
-   int  idx;
-   Rational val;
+static void MPSreadBounds(MPSInput &mps, LPColSetBase<Rational> &cset,
+                          const NameSet &cnames, DIdxSet *intvars,
+                          SPxOut *spxout) {
+  DIdxSet oldbinvars;
+  char bndname[MPSInput::MAX_LINE_LEN] = {'\0'};
+  int idx;
+  Rational val;
 
-   while(mps.readLine())
-   {
-      if(mps.field0() != 0)
-      {
-         MSG_INFO2((*spxout), (*spxout) << "IMPSRD05 Bound name     : " << bndname << std::endl;)
+  while (mps.readLine()) {
+    if (mps.field0() != 0) {
+      MSG_INFO2((*spxout), (*spxout) << "IMPSRD05 Bound name     : " << bndname
+                                     << std::endl;)
 
-         if(strcmp(mps.field0(), "ENDATA"))
-            break;
+      if (strcmp(mps.field0(), "ENDATA"))
+        break;
 
-         mps.setSection(MPSInput::ENDATA);
-
-         return;
-      }
-
-      // Is the value field used ?
-      if((!strcmp(mps.field1(), "LO"))
-            || (!strcmp(mps.field1(), "UP"))
-            || (!strcmp(mps.field1(), "FX"))
-            || (!strcmp(mps.field1(), "LI"))
-            || (!strcmp(mps.field1(), "UI")))
-      {
-         if((mps.field3() != 0) && (mps.field4() == 0))
-            mps.insertName("_BND_", true);
-      }
-      else
-      {
-         if((mps.field2() != 0) && (mps.field3() == 0))
-            mps.insertName("_BND_", true);
-      }
+      mps.setSection(MPSInput::ENDATA);
 
-      if((mps.field1() == 0) || (mps.field2() == 0) || (mps.field3() == 0))
-         break;
-
-      if(*bndname == '\0')
-      {
-         assert(strlen(mps.field2()) < MPSInput::MAX_LINE_LEN);
-         spxSnprintf(bndname, MPSInput::MAX_LINE_LEN, "%s", mps.field2());
-      }
-
-      // Only read the first Bound in section
-      if(!strcmp(bndname, mps.field2()))
-      {
-         if((idx = cnames.number(mps.field3())) < 0)
-            mps.entryIgnored("column", mps.field3(), "bound", bndname);
-         else
-         {
-            if(mps.field4() == 0)
-               val = 0;
-            else if(!strcmp(mps.field4(), "-Inf") || !strcmp(mps.field4(), "-inf"))
-               val = -infinity;
-            else if(!strcmp(mps.field4(), "Inf") || !strcmp(mps.field4(), "inf")
-                    || !strcmp(mps.field4(), "+Inf") || !strcmp(mps.field4(), "+inf"))
-               val = infinity;
-            else
-               try
-               {
-                  val = ratFromString(mps.field4());
-               }
-               catch(const std::exception& e)
-               {
-                  MSG_WARNING((*spxout), (*spxout) << "WMPSRD07 Warning: malformed rational value in MPS file\n");
-                  std::cerr << e.what() << '\n';
-               }
-
-            // ILOG extension (Integer Bound)
-            if(mps.field1()[1] == 'I')
-            {
-               if(intvars != 0)
-                  intvars->addIdx(idx);
-
-               // if the variable has appeared in the MARKER section of the COLUMNS section then its default bounds were
-               // set to 0,1; the first time it is declared integer we need to change to default bounds 0,infinity
-               if(oldbinvars.pos(idx) < 0)
-               {
-                  cset.upper_w(idx) = infinity;
-                  oldbinvars.addIdx(idx);
-               }
-            }
-
-            switch(*mps.field1())
-            {
-            case 'L':
-               cset.lower_w(idx) = val;
-               break;
-
-            case 'U':
-               cset.upper_w(idx) = val;
-               break;
-
-            case 'F':
-               if(mps.field1()[1] == 'X')
-               {
-                  cset.lower_w(idx) = val;
-                  cset.upper_w(idx) = val;
-               }
-               else
-               {
-                  cset.lower_w(idx) = -infinity;
-                  cset.upper_w(idx) = infinity;
-               }
-
-               break;
-
-            case 'M':
-               cset.lower_w(idx) = -infinity;
-               break;
-
-            case 'P':
-               cset.upper_w(idx) = infinity;
-               break;
-
-            // Ilog extension (Binary)
-            case 'B':
-               cset.lower_w(idx) = 0;
-               cset.upper_w(idx) = 1;
-
-               if(intvars != 0)
-                  intvars->addIdx(idx);
-
-               break;
-
-            default:
-               mps.syntaxError();
-               return;
-            }
-         }
+      return;
+    }
+
+    // Is the value field used ?
+    if ((!strcmp(mps.field1(), "LO")) || (!strcmp(mps.field1(), "UP")) ||
+        (!strcmp(mps.field1(), "FX")) || (!strcmp(mps.field1(), "LI")) ||
+        (!strcmp(mps.field1(), "UI"))) {
+      if ((mps.field3() != 0) && (mps.field4() == 0))
+        mps.insertName("_BND_", true);
+    } else {
+      if ((mps.field2() != 0) && (mps.field3() == 0))
+        mps.insertName("_BND_", true);
+    }
+
+    if ((mps.field1() == 0) || (mps.field2() == 0) || (mps.field3() == 0))
+      break;
+
+    if (*bndname == '\0') {
+      assert(strlen(mps.field2()) < MPSInput::MAX_LINE_LEN);
+      spxSnprintf(bndname, MPSInput::MAX_LINE_LEN, "%s", mps.field2());
+    }
+
+    // Only read the first Bound in section
+    if (!strcmp(bndname, mps.field2())) {
+      if ((idx = cnames.number(mps.field3())) < 0)
+        mps.entryIgnored("column", mps.field3(), "bound", bndname);
+      else {
+        if (mps.field4() == 0)
+          val = 0;
+        else if (!strcmp(mps.field4(), "-Inf") || !strcmp(mps.field4(), "-inf"))
+          val = -infinity;
+        else if (!strcmp(mps.field4(), "Inf") || !strcmp(mps.field4(), "inf") ||
+                 !strcmp(mps.field4(), "+Inf") || !strcmp(mps.field4(), "+inf"))
+          val = infinity;
+        else
+          try {
+            val = ratFromString(mps.field4());
+          } catch (const std::exception &e) {
+            MSG_WARNING((*spxout), (*spxout) << "WMPSRD07 Warning: malformed "
+                                                "rational value in MPS file\n");
+            std::cerr << e.what() << '\n';
+          }
+
+        // ILOG extension (Integer Bound)
+        if (mps.field1()[1] == 'I') {
+          if (intvars != 0)
+            intvars->addIdx(idx);
+
+          // if the variable has appeared in the MARKER section of the COLUMNS
+          // section then its default bounds were set to 0,1; the first time it
+          // is declared integer we need to change to default bounds 0,infinity
+          if (oldbinvars.pos(idx) < 0) {
+            cset.upper_w(idx) = infinity;
+            oldbinvars.addIdx(idx);
+          }
+        }
+
+        switch (*mps.field1()) {
+        case 'L':
+          cset.lower_w(idx) = val;
+          break;
+
+        case 'U':
+          cset.upper_w(idx) = val;
+          break;
+
+        case 'F':
+          if (mps.field1()[1] == 'X') {
+            cset.lower_w(idx) = val;
+            cset.upper_w(idx) = val;
+          } else {
+            cset.lower_w(idx) = -infinity;
+            cset.upper_w(idx) = infinity;
+          }
+
+          break;
+
+        case 'M':
+          cset.lower_w(idx) = -infinity;
+          break;
+
+        case 'P':
+          cset.upper_w(idx) = infinity;
+          break;
+
+        // Ilog extension (Binary)
+        case 'B':
+          cset.lower_w(idx) = 0;
+          cset.upper_w(idx) = 1;
+
+          if (intvars != 0)
+            intvars->addIdx(idx);
+
+          break;
+
+        default:
+          mps.syntaxError();
+          return;
+        }
       }
-   }
+    }
+  }
 
-   mps.syntaxError();
+  mps.syntaxError();
 }
 
 /// Read LP in MPS File Format.
 /**
- *  The specification is taken from the IBM Optimization Library Guide and Reference, online available at
- *  http://www.software.ibm.com/sos/features/libuser.htm and from the ILOG CPLEX 7.0 Reference Manual, Appendix E, Page
- *  531.
+ *  The specification is taken from the IBM Optimization Library Guide and
+ * Reference, online available at
+ *  http://www.software.ibm.com/sos/features/libuser.htm and from the ILOG
+ * CPLEX 7.0 Reference Manual, Appendix E, Page 531.
  *
- *  This routine should read all valid MPS format files.  What it will not do, is find all cases where a file is ill
- *  formed.  If this happens it may complain and read nothing or read "something".
+ *  This routine should read all valid MPS format files.  What it will not do,
+ * is find all cases where a file is ill formed.  If this happens it may
+ * complain and read nothing or read "something".
  *
  *  @return true if the file was read correctly.
  */
 #define INIT_COLS 1000 ///< initialy allocated columns.
 #define INIT_NZOS 5000 ///< initialy allocated non zeros.
-template <> inline
-bool SPxLPBase<Rational>::readMPS(
-   std::istream& p_input,           ///< input stream.
-   NameSet*      p_rnames,          ///< row names.
-   NameSet*      p_cnames,          ///< column names.
-   DIdxSet*      p_intvars)         ///< integer variables.
+template <>
+inline bool
+SPxLPBase<Rational>::readMPS(std::istream &p_input, ///< input stream.
+                             NameSet *p_rnames,     ///< row names.
+                             NameSet *p_cnames,     ///< column names.
+                             DIdxSet *p_intvars)    ///< integer variables.
 {
-   LPRowSetBase<Rational>& rset = *this;
-   LPColSetBase<Rational>& cset = *this;
-   NameSet* rnames;
-   NameSet* cnames;
-
-   if(p_cnames)
-      cnames = p_cnames;
-   else
-   {
-      cnames = 0;
-      spx_alloc(cnames);
-      cnames = new(cnames) NameSet();
-   }
-
-   cnames->clear();
-
-   if(p_rnames)
-      rnames = p_rnames;
-   else
-   {
-      try
-      {
-         rnames = 0;
-         spx_alloc(rnames);
-         rnames = new(rnames) NameSet();
+  LPRowSetBase<Rational> &rset = *this;
+  LPColSetBase<Rational> &cset = *this;
+  NameSet *rnames;
+  NameSet *cnames;
+
+  if (p_cnames)
+    cnames = p_cnames;
+  else {
+    cnames = 0;
+    spx_alloc(cnames);
+    cnames = new (cnames) NameSet();
+  }
+
+  cnames->clear();
+
+  if (p_rnames)
+    rnames = p_rnames;
+  else {
+    try {
+      rnames = 0;
+      spx_alloc(rnames);
+      rnames = new (rnames) NameSet();
+    } catch (const SPxMemoryException &x) {
+      if (!p_cnames) {
+        cnames->~NameSet();
+        spx_free(cnames);
       }
-      catch(const SPxMemoryException& x)
-      {
-         if(!p_cnames)
-         {
-            cnames->~NameSet();
-            spx_free(cnames);
-         }
-
-         throw x;
-      }
-   }
-
-   rnames->clear();
 
-   SPxLPBase<Rational>::clear(); // clear the LP.
+      throw x;
+    }
+  }
 
-   cset.memRemax(INIT_NZOS);
-   cset.reMax(INIT_COLS);
+  rnames->clear();
 
-   MPSInput mps(p_input);
+  SPxLPBase<Rational>::clear(); // clear the LP.
 
-   MPSreadName(mps, spxout);
+  cset.memRemax(INIT_NZOS);
+  cset.reMax(INIT_COLS);
 
-   if(mps.section() == MPSInput::OBJSEN)
-      MPSreadObjsen(mps);
+  MPSInput mps(p_input);
 
-   if(mps.section() == MPSInput::OBJNAME)
-      MPSreadObjname(mps);
+  MPSreadName(mps, spxout);
 
-   if(mps.section() == MPSInput::ROWS)
-      MPSreadRows(mps, rset, *rnames, spxout);
+  if (mps.section() == MPSInput::OBJSEN)
+    MPSreadObjsen(mps);
 
-   addedRows(rset.num());
+  if (mps.section() == MPSInput::OBJNAME)
+    MPSreadObjname(mps);
 
-   if(mps.section() == MPSInput::COLUMNS)
-      MPSreadCols(mps, rset, *rnames, cset, *cnames, p_intvars, spxout);
+  if (mps.section() == MPSInput::ROWS)
+    MPSreadRows(mps, rset, *rnames, spxout);
 
-   if(mps.section() == MPSInput::RHS)
-      MPSreadRhs(mps, rset, *rnames, spxout);
+  addedRows(rset.num());
 
-   if(mps.section() == MPSInput::RANGES)
-      MPSreadRanges(mps, rset, *rnames, spxout);
+  if (mps.section() == MPSInput::COLUMNS)
+    MPSreadCols(mps, rset, *rnames, cset, *cnames, p_intvars, spxout);
 
-   if(mps.section() == MPSInput::BOUNDS)
-      MPSreadBounds(mps, cset, *cnames, p_intvars, spxout);
+  if (mps.section() == MPSInput::RHS)
+    MPSreadRhs(mps, rset, *rnames, spxout);
 
-   if(mps.section() != MPSInput::ENDATA)
-      mps.syntaxError();
+  if (mps.section() == MPSInput::RANGES)
+    MPSreadRanges(mps, rset, *rnames, spxout);
 
-   if(mps.hasError())
-      clear();
-   else
-   {
-      changeSense(mps.objSense() == MPSInput::MINIMIZE ? SPxLPBase<Rational>::MINIMIZE :
-                  SPxLPBase<Rational>::MAXIMIZE);
+  if (mps.section() == MPSInput::BOUNDS)
+    MPSreadBounds(mps, cset, *cnames, p_intvars, spxout);
 
-      MSG_INFO2((*spxout), (*spxout) << "IMPSRD06 Objective sense: " << ((mps.objSense() ==
-                MPSInput::MINIMIZE) ? "Minimize\n" : "Maximize\n"));
+  if (mps.section() != MPSInput::ENDATA)
+    mps.syntaxError();
 
-      added2Set(
-         *(reinterpret_cast<SVSetBase<Rational>*>(static_cast<LPRowSetBase<Rational>*>(this))),
-         *(reinterpret_cast<SVSetBase<Rational>*>(static_cast<LPColSetBase<Rational>*>(this))),
-         cset.num());
-      addedCols(cset.num());
+  if (mps.hasError())
+    clear();
+  else {
+    changeSense(mps.objSense() == MPSInput::MINIMIZE
+                    ? SPxLPBase<Rational>::MINIMIZE
+                    : SPxLPBase<Rational>::MAXIMIZE);
 
-      assert(isConsistent());
-   }
+    MSG_INFO2((*spxout), (*spxout) << "IMPSRD06 Objective sense: "
+                                   << ((mps.objSense() == MPSInput::MINIMIZE)
+                                           ? "Minimize\n"
+                                           : "Maximize\n"));
 
-   if(p_cnames == 0)
-   {
-      cnames->~NameSet();
-      spx_free(cnames);
-   }
+    added2Set(*(reinterpret_cast<SVSetBase<Rational> *>(
+                  static_cast<LPRowSetBase<Rational> *>(this))),
+              *(reinterpret_cast<SVSetBase<Rational> *>(
+                  static_cast<LPColSetBase<Rational> *>(this))),
+              cset.num());
+    addedCols(cset.num());
 
-   if(p_rnames == 0)
-   {
-      rnames->~NameSet();
-      spx_free(rnames);
-   }
+    assert(isConsistent());
+  }
 
-   return !mps.hasError();
-}
+  if (p_cnames == 0) {
+    cnames->~NameSet();
+    spx_free(cnames);
+  }
 
+  if (p_rnames == 0) {
+    rnames->~NameSet();
+    spx_free(rnames);
+  }
 
+  return !mps.hasError();
+}
 
 // ---------------------------------------------------------------------------------------------------------------------
 // Specialization for writing LP format
 // ---------------------------------------------------------------------------------------------------------------------
 
 // get the name of a row or construct one
-static const char* LPFgetRowName(
-   const SPxLPBase<Rational>& p_lp,
-   int                    p_idx,
-   const NameSet*         p_rnames,
-   char*                  p_buf,
-   int                    p_num_written_rows
-)
-{
-   assert(p_buf != 0);
-   assert(p_idx >= 0);
-   assert(p_idx <  p_lp.nRows());
+static const char *LPFgetRowName(const SPxLPBase<Rational> &p_lp, int p_idx,
+                                 const NameSet *p_rnames, char *p_buf,
+                                 int p_num_written_rows) {
+  assert(p_buf != 0);
+  assert(p_idx >= 0);
+  assert(p_idx < p_lp.nRows());
 
-   if(p_rnames != 0)
-   {
-      DataKey key = p_lp.rId(p_idx);
+  if (p_rnames != 0) {
+    DataKey key = p_lp.rId(p_idx);
 
-      if(p_rnames->has(key))
-         return (*p_rnames)[key];
-   }
+    if (p_rnames->has(key))
+      return (*p_rnames)[key];
+  }
 
-   spxSnprintf(p_buf, 16, "C%d", p_num_written_rows);
+  spxSnprintf(p_buf, 16, "C%d", p_num_written_rows);
 
-   return p_buf;
+  return p_buf;
 }
 
-
-
 // get the name of a column or construct one
-static const char* getColName(
-   const SPxLPBase<Rational>& p_lp,
-   int                    p_idx,
-   const NameSet*         p_cnames,
-   char*                  p_buf
-)
-{
-   assert(p_buf != 0);
-   assert(p_idx >= 0);
-   assert(p_idx <  p_lp.nCols());
+static const char *getColName(const SPxLPBase<Rational> &p_lp, int p_idx,
+                              const NameSet *p_cnames, char *p_buf) {
+  assert(p_buf != 0);
+  assert(p_idx >= 0);
+  assert(p_idx < p_lp.nCols());
 
-   if(p_cnames != 0)
-   {
-      DataKey key = p_lp.cId(p_idx);
+  if (p_cnames != 0) {
+    DataKey key = p_lp.cId(p_idx);
 
-      if(p_cnames->has(key))
-         return (*p_cnames)[key];
-   }
+    if (p_cnames->has(key))
+      return (*p_cnames)[key];
+  }
 
-   spxSnprintf(p_buf, 16, "x%d", p_idx);
+  spxSnprintf(p_buf, 16, "x%d", p_idx);
 
-   return p_buf;
+  return p_buf;
 }
 
-
-
 // write an SVector
 #define NUM_ENTRIES_PER_LINE 5
-static void LPFwriteSVector(
-   const SPxLPBase<Rational>&   p_lp,       ///< the LP
-   std::ostream&            p_output,   ///< output stream
-   const NameSet*           p_cnames,   ///< column names
-   const SVectorBase<Rational>& p_svec,     ///< vector to write
-   SPxOut*                  spxout      ///< out stream
-)
-{
-
-   char name[16];
-   int num_coeffs = 0;
-   long long pos;
-
-   pos = p_output.tellp();
-
-   for(int j = 0; j < p_lp.nCols(); ++j)
-   {
-      const Rational coeff = p_svec[j];
-
-      if(coeff == 0)
-         continue;
+static void
+LPFwriteSVector(const SPxLPBase<Rational> &p_lp,     ///< the LP
+                std::ostream &p_output,              ///< output stream
+                const NameSet *p_cnames,             ///< column names
+                const SVectorBase<Rational> &p_svec, ///< vector to write
+                SPxOut *spxout                       ///< out stream
+) {
+
+  char name[16];
+  int num_coeffs = 0;
+  long long pos;
+
+  pos = p_output.tellp();
+
+  for (int j = 0; j < p_lp.nCols(); ++j) {
+    const Rational coeff = p_svec[j];
+
+    if (coeff == 0)
+      continue;
+
+    if (num_coeffs == 0)
+      p_output << coeff << " " << getColName(p_lp, j, p_cnames, name);
+    else {
+      // insert a line break every NUM_ENTRIES_PER_LINE columns or whenever max
+      // line length is nearly exceeded
+      if (num_coeffs == NUM_ENTRIES_PER_LINE ||
+          (long long)(p_output.tellp()) - pos +
+                  (long long)(coeff.str().length() + 100) >
+              MAX_LINE_WRITE_LEN) {
+        num_coeffs = 0;
+        p_output << "\n\t";
+
+        if ((long long)(p_output.tellp()) - pos > MAX_LINE_WRITE_LEN) {
+          MSG_WARNING((*spxout),
+                      (*spxout) << "XLPSWR01 Warning: MAX_LINE_WRITE_LEN "
+                                   "possibly exceeded when writing LP file\n");
+        }
+
+        pos = p_output.tellp();
+      }
 
-      if(num_coeffs == 0)
-         p_output << coeff << " " << getColName(p_lp, j, p_cnames, name);
+      if (coeff < 0)
+        p_output << " - " << -coeff;
       else
-      {
-         // insert a line break every NUM_ENTRIES_PER_LINE columns or whenever max line length is nearly exceeded
-         if(num_coeffs == NUM_ENTRIES_PER_LINE ||
-               (long long)(p_output.tellp()) - pos + (long long)(coeff.str().length() + 100) > MAX_LINE_WRITE_LEN)
-         {
-            num_coeffs = 0;
-            p_output << "\n\t";
-
-            if((long long)(p_output.tellp()) - pos  >  MAX_LINE_WRITE_LEN)
-            {
-               MSG_WARNING((*spxout), (*spxout) <<
-                           "XLPSWR01 Warning: MAX_LINE_WRITE_LEN possibly exceeded when writing LP file\n");
-            }
-
-            pos = p_output.tellp();
-         }
+        p_output << " + " << coeff;
 
-         if(coeff < 0)
-            p_output << " - " << -coeff;
-         else
-            p_output << " + " << coeff;
+      p_output << " " << getColName(p_lp, j, p_cnames, name);
+    }
 
-         p_output << " " << getColName(p_lp, j, p_cnames, name);
-      }
-
-      ++num_coeffs;
-   }
+    ++num_coeffs;
+  }
 }
 
-
-
 // write the objective
-static void LPFwriteObjective(
-   const SPxLPBase<Rational>& p_lp,       ///< the LP
-   std::ostream&          p_output,   ///< output stream
-   const NameSet*         p_cnames,   ///< column names
-   SPxOut*                spxout      ///< out stream
-)
-{
-
-   const int sense = p_lp.spxSense();
-
-   p_output << ((sense == SPxLPBase<Rational>::MINIMIZE) ? "Minimize\n" : "Maximize\n");
-   p_output << "  obj: ";
-
-   const VectorBase<Rational>& obj = p_lp.maxObj();
-   DSVectorBase<Rational> svec(obj.dim());
-   svec.operator = (obj);
-   svec *= Rational(sense);
-   LPFwriteSVector(p_lp, p_output, p_cnames, svec, spxout);
-   p_output << "\n";
+static void LPFwriteObjective(const SPxLPBase<Rational> &p_lp, ///< the LP
+                              std::ostream &p_output,  ///< output stream
+                              const NameSet *p_cnames, ///< column names
+                              SPxOut *spxout           ///< out stream
+) {
+
+  const int sense = p_lp.spxSense();
+
+  p_output << ((sense == SPxLPBase<Rational>::MINIMIZE) ? "Minimize\n"
+                                                        : "Maximize\n");
+  p_output << "  obj: ";
+
+  const VectorBase<Rational> &obj = p_lp.maxObj();
+  DSVectorBase<Rational> svec(obj.dim());
+  svec.operator=(obj);
+  svec *= Rational(sense);
+  LPFwriteSVector(p_lp, p_output, p_cnames, svec, spxout);
+  p_output << "\n";
 }
 
-
-
 // write non-ranged rows
-static void LPFwriteRow(
-   const SPxLPBase<Rational>&   p_lp,       ///< the LP
-   std::ostream&            p_output,   ///< output stream
-   const NameSet*           p_cnames,   ///< column names
-   const SVectorBase<Rational>& p_svec,     ///< vector of the row
-   const Rational&              p_lhs,      ///< lhs of the row
-   const Rational&              p_rhs,      ///< rhs of the row
-   SPxOut*                      spxout      ///< out stream
-)
-{
-
-   long long pos;
-   pos = p_output.tellp();
-
-   LPFwriteSVector(p_lp, p_output, p_cnames, p_svec, spxout);
-
-   long long sidelen;
-   sidelen = (p_lhs == p_rhs
-              || double(p_lhs) <= double(-infinity)) ? (long long)p_rhs.str().length()
-             : (long long)p_lhs.str().length();
-
-   // insert a line break if max line length is in danger of being exceeded
-   if((long long)(p_output.tellp()) - pos + sidelen + (long long)100 > MAX_LINE_WRITE_LEN)
-   {
-      p_output << "\n\t";
-
-      if((long long)(p_output.tellp()) - pos  >  MAX_LINE_WRITE_LEN)
-      {
-         MSG_WARNING((*spxout), (*spxout) <<
-                     "XLPSWR02 Warning: MAX_LINE_WRITE_LEN possibly exceeded when writing LP file\n");
-      }
-
-      pos = p_output.tellp();
-   }
-
-   // write bound value
-   if(p_lhs == p_rhs)
-      p_output << " = " << p_rhs;
-   else if(double(p_lhs) <= double(-infinity))
-      p_output << " <= " << p_rhs;
-   else
-   {
-      assert(double(p_rhs) >= double(infinity));
-      p_output << " >= " << p_lhs;
-   }
-
-   p_output << "\n";
-
-   if((long long)(p_output.tellp()) - pos  >  MAX_LINE_WRITE_LEN)
-   {
-      MSG_WARNING((*spxout), (*spxout) <<
-                  "XLPSWR03 Warning: MAX_LINE_WRITE_LEN possibly exceeded when writing LP file\n");
-   }
+static void
+LPFwriteRow(const SPxLPBase<Rational> &p_lp,     ///< the LP
+            std::ostream &p_output,              ///< output stream
+            const NameSet *p_cnames,             ///< column names
+            const SVectorBase<Rational> &p_svec, ///< vector of the row
+            const Rational &p_lhs,               ///< lhs of the row
+            const Rational &p_rhs,               ///< rhs of the row
+            SPxOut *spxout                       ///< out stream
+) {
+
+  long long pos;
+  pos = p_output.tellp();
+
+  LPFwriteSVector(p_lp, p_output, p_cnames, p_svec, spxout);
+
+  long long sidelen;
+  sidelen = (p_lhs == p_rhs || double(p_lhs) <= double(-infinity))
+                ? (long long)p_rhs.str().length()
+                : (long long)p_lhs.str().length();
+
+  // insert a line break if max line length is in danger of being exceeded
+  if ((long long)(p_output.tellp()) - pos + sidelen + (long long)100 >
+      MAX_LINE_WRITE_LEN) {
+    p_output << "\n\t";
+
+    if ((long long)(p_output.tellp()) - pos > MAX_LINE_WRITE_LEN) {
+      MSG_WARNING((*spxout), (*spxout)
+                                 << "XLPSWR02 Warning: MAX_LINE_WRITE_LEN "
+                                    "possibly exceeded when writing LP file\n");
+    }
+
+    pos = p_output.tellp();
+  }
+
+  // write bound value
+  if (p_lhs == p_rhs)
+    p_output << " = " << p_rhs;
+  else if (double(p_lhs) <= double(-infinity))
+    p_output << " <= " << p_rhs;
+  else {
+    assert(double(p_rhs) >= double(infinity));
+    p_output << " >= " << p_lhs;
+  }
+
+  p_output << "\n";
+
+  if ((long long)(p_output.tellp()) - pos > MAX_LINE_WRITE_LEN) {
+    MSG_WARNING((*spxout), (*spxout)
+                               << "XLPSWR03 Warning: MAX_LINE_WRITE_LEN "
+                                  "possibly exceeded when writing LP file\n");
+  }
 }
 
-
-
 // write all rows
-static void LPFwriteRows(
-   const SPxLPBase<Rational>& p_lp,       ///< the LP
-   std::ostream&          p_output,   ///< output stream
-   const NameSet*         p_rnames,   ///< row names
-   const NameSet*         p_cnames,   ///< column names
-   SPxOut*                spxout      ///< out stream
-)
-{
-
-   char name[16];
-
-   p_output << "Subject To\n";
-
-   for(int i = 0; i < p_lp.nRows(); ++i)
-   {
-      const Rational lhs = p_lp.lhs(i);
-      const Rational rhs = p_lp.rhs(i);
-
-      if(double(lhs) > -double(infinity) && double(rhs) < double(infinity) && lhs != rhs)
-      {
-         // ranged row -> write two non-ranged rows
-         p_output << " " << LPFgetRowName(p_lp, i, p_rnames, name, i) << "_1 : ";
-         LPFwriteRow(p_lp, p_output, p_cnames, p_lp.rowVector(i), lhs, infinity, spxout);
-
-         p_output << " " << LPFgetRowName(p_lp, i, p_rnames, name, i) << "_2 : ";
-         LPFwriteRow(p_lp, p_output, p_cnames, p_lp.rowVector(i), -infinity, rhs, spxout);
-      }
-      else
-      {
-         p_output << " " << LPFgetRowName(p_lp, i, p_rnames, name, i) << " : ";
-         LPFwriteRow(p_lp, p_output, p_cnames, p_lp.rowVector(i), lhs, rhs, spxout);
-      }
-   }
+static void LPFwriteRows(const SPxLPBase<Rational> &p_lp, ///< the LP
+                         std::ostream &p_output,          ///< output stream
+                         const NameSet *p_rnames,         ///< row names
+                         const NameSet *p_cnames,         ///< column names
+                         SPxOut *spxout                   ///< out stream
+) {
+
+  char name[16];
+
+  p_output << "Subject To\n";
+
+  for (int i = 0; i < p_lp.nRows(); ++i) {
+    const Rational lhs = p_lp.lhs(i);
+    const Rational rhs = p_lp.rhs(i);
+
+    if (double(lhs) > -double(infinity) && double(rhs) < double(infinity) &&
+        lhs != rhs) {
+      // ranged row -> write two non-ranged rows
+      p_output << " " << LPFgetRowName(p_lp, i, p_rnames, name, i) << "_1 : ";
+      LPFwriteRow(p_lp, p_output, p_cnames, p_lp.rowVector(i), lhs, infinity,
+                  spxout);
+
+      p_output << " " << LPFgetRowName(p_lp, i, p_rnames, name, i) << "_2 : ";
+      LPFwriteRow(p_lp, p_output, p_cnames, p_lp.rowVector(i), -infinity, rhs,
+                  spxout);
+    } else {
+      p_output << " " << LPFgetRowName(p_lp, i, p_rnames, name, i) << " : ";
+      LPFwriteRow(p_lp, p_output, p_cnames, p_lp.rowVector(i), lhs, rhs,
+                  spxout);
+    }
+  }
 }
 
-
-
 // write the variable bounds
 // (the default bounds 0 <= x <= infinity are not written)
-static void LPFwriteBounds(
-   const SPxLPBase<Rational>&   p_lp,       ///< the LP to write
-   std::ostream&            p_output,   ///< output stream
-   const NameSet*           p_cnames,   ///< column names
-   SPxOut*                  spxout      ///< out stream
-)
-{
-
-   char name[16];
-   long long pos;
-
-   pos = p_output.tellp();
-
-   p_output << "Bounds\n";
-
-   for(int j = 0; j < p_lp.nCols(); ++j)
-   {
-      const Rational lower = p_lp.lower(j);
-      const Rational upper = p_lp.upper(j);
-
-      if(lower == upper)
-      {
-         p_output << "  "   << getColName(p_lp, j, p_cnames, name) << " = "  << upper << '\n';
-      }
-      else if(double(lower) > -double(infinity))
-      {
-         if(double(upper) < double(infinity))
-         {
-            // range bound
-            if(lower != 0)
-               p_output << "  "   << lower << " <= "
-                        << getColName(p_lp, j, p_cnames, name)
-                        << " <= " << upper << '\n';
-            else
-               p_output << "  "   << getColName(p_lp, j, p_cnames, name)
-                        << " <= " << upper << '\n';
-         }
-         else if(lower != 0)
-            p_output << "  " << lower << " <= "
-                     << getColName(p_lp, j, p_cnames, name)
-                     << '\n';
-      }
-      else if(double(upper) < double(infinity))
-         p_output << "   -Inf <= "
-                  << getColName(p_lp, j, p_cnames, name)
-                  << " <= " << upper << '\n';
-      else
-         p_output << "  "   << getColName(p_lp, j, p_cnames, name)
-                  << " free\n";
-
-      // check if max line length exceeded
-      if((long long)(p_output.tellp()) - pos  >  MAX_LINE_WRITE_LEN)
-      {
-         MSG_WARNING((*spxout), (*spxout) <<
-                     "XLPSWR04 Warning: MAX_LINE_WRITE_LEN exceeded when writing LP file\n");
-      }
-
-      pos = p_output.tellp();
-   }
+static void LPFwriteBounds(const SPxLPBase<Rational> &p_lp, ///< the LP to write
+                           std::ostream &p_output,          ///< output stream
+                           const NameSet *p_cnames,         ///< column names
+                           SPxOut *spxout                   ///< out stream
+) {
+
+  char name[16];
+  long long pos;
+
+  pos = p_output.tellp();
+
+  p_output << "Bounds\n";
+
+  for (int j = 0; j < p_lp.nCols(); ++j) {
+    const Rational lower = p_lp.lower(j);
+    const Rational upper = p_lp.upper(j);
+
+    if (lower == upper) {
+      p_output << "  " << getColName(p_lp, j, p_cnames, name) << " = " << upper
+               << '\n';
+    } else if (double(lower) > -double(infinity)) {
+      if (double(upper) < double(infinity)) {
+        // range bound
+        if (lower != 0)
+          p_output << "  " << lower
+                   << " <= " << getColName(p_lp, j, p_cnames, name)
+                   << " <= " << upper << '\n';
+        else
+          p_output << "  " << getColName(p_lp, j, p_cnames, name)
+                   << " <= " << upper << '\n';
+      } else if (lower != 0)
+        p_output << "  " << lower
+                 << " <= " << getColName(p_lp, j, p_cnames, name) << '\n';
+    } else if (double(upper) < double(infinity))
+      p_output << "   -Inf <= " << getColName(p_lp, j, p_cnames, name)
+               << " <= " << upper << '\n';
+    else
+      p_output << "  " << getColName(p_lp, j, p_cnames, name) << " free\n";
+
+    // check if max line length exceeded
+    if ((long long)(p_output.tellp()) - pos > MAX_LINE_WRITE_LEN) {
+      MSG_WARNING((*spxout), (*spxout)
+                                 << "XLPSWR04 Warning: MAX_LINE_WRITE_LEN "
+                                    "exceeded when writing LP file\n");
+    }
+
+    pos = p_output.tellp();
+  }
 }
 
-
-
 // write the generals section
-static void LPFwriteGenerals(
-   const SPxLPBase<Rational>&   p_lp,         ///< the LP to write
-   std::ostream&            p_output,     ///< output stream
-   const NameSet*           p_cnames,     ///< column names
-   const DIdxSet*           p_intvars     ///< integer variables
-)
-{
+static void
+LPFwriteGenerals(const SPxLPBase<Rational> &p_lp, ///< the LP to write
+                 std::ostream &p_output,          ///< output stream
+                 const NameSet *p_cnames,         ///< column names
+                 const DIdxSet *p_intvars         ///< integer variables
+) {
 
-   char name[16];
+  char name[16];
 
-   if(p_intvars == NULL || p_intvars->size() <= 0)
-      return;  // no integer variables
+  if (p_intvars == NULL || p_intvars->size() <= 0)
+    return; // no integer variables
 
-   p_output << "Generals\n";
+  p_output << "Generals\n";
 
-   for(int j = 0; j < p_lp.nCols(); ++j)
-      if(p_intvars->pos(j) >= 0)
-         p_output << "  " << getColName(p_lp, j, p_cnames, name) << "\n";
+  for (int j = 0; j < p_lp.nCols(); ++j)
+    if (p_intvars->pos(j) >= 0)
+      p_output << "  " << getColName(p_lp, j, p_cnames, name) << "\n";
 }
 
-
 /// Write LP in LP Format.
-template <> inline
-void SPxLPBase<Rational>::writeLPF(
-   std::ostream&  p_output,          ///< output stream
-   const NameSet* p_rnames,          ///< row names
-   const NameSet* p_cnames,          ///< column names
-   const DIdxSet* p_intvars          ///< integer variables
-) const
-{
-   LPFwriteObjective(*this, p_output, p_cnames, spxout);
-   LPFwriteRows(*this, p_output, p_rnames, p_cnames, spxout);
-   LPFwriteBounds(*this, p_output, p_cnames, spxout);
-   LPFwriteGenerals(*this, p_output, p_cnames, p_intvars);
-
-   p_output << "End" << std::endl;
+template <>
+inline void
+SPxLPBase<Rational>::writeLPF(std::ostream &p_output,  ///< output stream
+                              const NameSet *p_rnames, ///< row names
+                              const NameSet *p_cnames, ///< column names
+                              const DIdxSet *p_intvars ///< integer variables
+) const {
+  LPFwriteObjective(*this, p_output, p_cnames, spxout);
+  LPFwriteRows(*this, p_output, p_rnames, p_cnames, spxout);
+  LPFwriteBounds(*this, p_output, p_cnames, spxout);
+  LPFwriteGenerals(*this, p_output, p_cnames, p_intvars);
+
+  p_output << "End" << std::endl;
 }
 
-
-
 // ---------------------------------------------------------------------------------------------------------------------
 // Specialization for writing MPS format
 // ---------------------------------------------------------------------------------------------------------------------
 
 // A problem here.
-static void MPSwriteRecord(
-   std::ostream&  os,
-   const char*    indicator,
-   const char*    name,
-   SPxOut* spxout,
-   const char*    name1  = nullptr,
-   const Rational value1 = 0,
-   const char*    name2  = nullptr,
-   const Rational value2 = 0
-)
-{
-   char buf[81];
-   long long pos;
-   pos = os.tellp();
-
-   spxSnprintf(buf, sizeof(buf), " %-2.2s %-8.8s", (indicator == 0) ? "" : indicator,
-               (name == 0)      ? "" : name);
-   os << buf;
-
-   if(name1 != nullptr)
-   {
-      spxSnprintf(buf, sizeof(buf), " %-8.8s ", name1);
-      os << buf << value1;
-
-      if(name2 != 0)
-      {
-         spxSnprintf(buf, sizeof(buf), " %-8.8s ", name2);
-         os << buf << value2;
-      }
-   }
-
-   os << std::endl;
-
-   // Warning if line is too long
-   if((long long)(os.tellp()) - pos > MAX_LINE_WRITE_LEN)
-   {
-      MSG_WARNING((*spxout), (*spxout) <<
-                  "XMPSWR04 Warning: MAX_LINE_WRITE_LEN exceeded when writing MPS file\n");
-   }
+static void MPSwriteRecord(std::ostream &os, const char *indicator,
+                           const char *name, SPxOut *spxout,
+                           const char *name1 = nullptr,
+                           const Rational value1 = 0,
+                           const char *name2 = nullptr,
+                           const Rational value2 = 0) {
+  char buf[81];
+  long long pos;
+  pos = os.tellp();
+
+  spxSnprintf(buf, sizeof(buf), " %-2.2s %-8.8s",
+              (indicator == 0) ? "" : indicator, (name == 0) ? "" : name);
+  os << buf;
+
+  if (name1 != nullptr) {
+    spxSnprintf(buf, sizeof(buf), " %-8.8s ", name1);
+    os << buf << value1;
+
+    if (name2 != 0) {
+      spxSnprintf(buf, sizeof(buf), " %-8.8s ", name2);
+      os << buf << value2;
+    }
+  }
+
+  os << std::endl;
+
+  // Warning if line is too long
+  if ((long long)(os.tellp()) - pos > MAX_LINE_WRITE_LEN) {
+    MSG_WARNING((*spxout), (*spxout) << "XMPSWR04 Warning: MAX_LINE_WRITE_LEN "
+                                        "exceeded when writing MPS file\n");
+  }
 }
 
+static Rational MPSgetRHS(Rational left, Rational right) {
+  Rational rhsval;
 
+  if (double(left) > -double(infinity)) /// This includes ranges
+    rhsval = left;
+  else if (double(right) < double(infinity))
+    rhsval = right;
+  else
+    throw SPxInternalCodeException("XMPSWR01 This should never happen.");
 
-static Rational MPSgetRHS(Rational left, Rational right)
-{
-   Rational rhsval;
-
-   if(double(left) > -double(infinity))   /// This includes ranges
-      rhsval = left;
-   else if(double(right) <  double(infinity))
-      rhsval = right;
-   else
-      throw SPxInternalCodeException("XMPSWR01 This should never happen.");
-
-   return rhsval;
+  return rhsval;
 }
 
+static const char *MPSgetRowName(const SPxLPBase<Rational> &lp, int idx,
+                                 const NameSet *rnames, char *buf) {
+  assert(buf != 0);
+  assert(idx >= 0);
+  assert(idx < lp.nRows());
 
+  if (rnames != 0) {
+    DataKey key = lp.rId(idx);
 
-static const char* MPSgetRowName(
-   const SPxLPBase<Rational>& lp,
-   int                   idx,
-   const NameSet*        rnames,
-   char*                 buf
-)
-{
-   assert(buf != 0);
-   assert(idx >= 0);
-   assert(idx <  lp.nRows());
-
-   if(rnames != 0)
-   {
-      DataKey key = lp.rId(idx);
+    if (rnames->has(key))
+      return (*rnames)[key];
+  }
 
-      if(rnames->has(key))
-         return (*rnames)[key];
-   }
+  spxSnprintf(buf, 16, "C%d", idx);
 
-   spxSnprintf(buf, 16, "C%d", idx);
-
-   return buf;
+  return buf;
 }
 
-
-
 /// Write LP in MPS format.
 /** @note There will always be a BOUNDS section, even if there are no bounds.
  */
-template <> inline
-void SPxLPBase<Rational>::writeMPS(
-   std::ostream&  p_output,          ///< output stream.
-   const NameSet* p_rnames,          ///< row names.
-   const NameSet* p_cnames,          ///< column names.
-   const DIdxSet* p_intvars          ///< integer variables.
-) const
-{
-
-   const char*    indicator;
-   char           name [16];
-   char           name1[16];
-   char           name2[16];
-   bool           has_ranges = false;
-   int            i;
-   int            k;
-
-   // --- NAME Section ---
-   p_output << "NAME          MPSDATA" << std::endl;
-
-   // --- ROWS Section ---
-   p_output << "ROWS" << std::endl;
-
-   for(i = 0; i < nRows(); i++)
-   {
-      if(lhs(i) == rhs(i))
-         indicator = "E";
-      else if((double(lhs(i)) > -double(infinity)) && (double(rhs(i)) < double(infinity)))
-      {
-         indicator = "E";
-         has_ranges = true;
-      }
-      else if(double(lhs(i)) > -double(infinity))
-         indicator = "G";
-      else if(double(rhs(i)) <  double(infinity))
-         indicator = "L";
-      else
-         throw SPxInternalCodeException("XMPSWR02 This should never happen.");
-
-      MPSwriteRecord(p_output, indicator, MPSgetRowName(*this, i, p_rnames, name), spxout);
-   }
-
-   MPSwriteRecord(p_output, "N", "MINIMIZE", spxout);
-
-   // --- COLUMNS Section ---
-   p_output << "COLUMNS" << std::endl;
-
-   bool has_intvars = (p_intvars != 0) && (p_intvars->size() > 0);
-
-   for(int j = 0; j < (has_intvars ? 2 : 1); j++)
-   {
-      bool is_intrun = has_intvars && (j == 1);
-
-      if(is_intrun)
-         p_output << "    MARK0001  'MARKER'                 'INTORG'" << std::endl;
-
-      for(i = 0; i < nCols(); i++)
-      {
-         bool is_intvar = has_intvars && (p_intvars->pos(i) >= 0);
-
-         if((is_intrun && !is_intvar) || (!is_intrun &&  is_intvar))
-            continue;
-
-         const SVectorBase<Rational>& col = colVector(i);
-         int colsize2 = (col.size() / 2) * 2;
-
-         assert(colsize2 % 2 == 0);
-
-         for(k = 0; k < colsize2; k += 2)
-            MPSwriteRecord(p_output, 0, getColName(*this, i, p_cnames, name), spxout,
-                           MPSgetRowName(*this, col.index(k), p_rnames, name1), col.value(k),
-                           MPSgetRowName(*this, col.index(k + 1), p_rnames, name2), col.value(k + 1));
-
-         if(colsize2 != col.size())
-            MPSwriteRecord(p_output, 0, getColName(*this, i, p_cnames, name), spxout,
-                           MPSgetRowName(*this, col.index(k), p_rnames, name1), col.value(k));
-
-         if(maxObj(i) != 0)
-            MPSwriteRecord(p_output, 0, getColName(*this, i, p_cnames, name), spxout, "MINIMIZE", -maxObj(i));
-      }
-
-      if(is_intrun)
-         p_output << "    MARK0001  'MARKER'                 'INTEND'" << std::endl;
-   }
-
-   // --- RHS Section ---
-   p_output << "RHS" << std::endl;
-
-   i = 0;
-
-   while(i < nRows())
-   {
-      Rational rhsval1 = 0;
-      Rational rhsval2 = 0;
-
-      for(; i < nRows(); i++)
-         if((rhsval1 = MPSgetRHS(lhs(i), rhs(i))) != 0)
-            break;
-
-      if(i < nRows())
-      {
-         for(k = i + 1; k < nRows(); k++)
-         {
-            if((rhsval2 = MPSgetRHS(lhs(k), rhs(k))) != 0)
-               break;
-         }
-
-         if(k < nRows())
-         {
-            MPSwriteRecord(p_output, 0, "RHS", spxout, MPSgetRowName(*this, i, p_rnames, name1), rhsval1,
-                           MPSgetRowName(*this, k, p_rnames, name2), rhsval2);
-         }
-         else
-            MPSwriteRecord(p_output, 0, "RHS", spxout, MPSgetRowName(*this, i, p_rnames, name1), rhsval1);
-
-         i = k + 1;
-      }
-   }
-
-   // --- RANGES Section ---
-   if(has_ranges)
-   {
-      p_output << "RANGES" << std::endl;
-
-      for(i = 0; i < nRows(); i++)
-      {
-         if((double(lhs(i)) > -double(infinity)) && (double(rhs(i)) < double(infinity)))
-         {
-            Rational range = rhs(i);
-            range -= lhs(i);
-            MPSwriteRecord(p_output, "", "RANGE", spxout, MPSgetRowName(*this, i, p_rnames, name1), range);
-         }
-      }
-   }
-
-   // --- BOUNDS Section ---
-   p_output << "BOUNDS" << std::endl;
-
-   for(i = 0; i < nCols(); i++)
-   {
-      // skip variables that do not appear in the objective function or any constraint
-      const SVectorBase<Rational>& col = colVector(i);
-
-      if(col.size() == 0 && maxObj(i) == 0)
-         continue;
-
-      if(lower(i) == upper(i))
-      {
-         MPSwriteRecord(p_output, "FX", "BOUND", spxout, getColName(*this, i, p_cnames, name1), lower(i));
-         continue;
-      }
-
-      if((double(lower(i)) <= double(-infinity)) && (double(upper(i)) >= double(infinity)))
-      {
-         MPSwriteRecord(p_output, "FR", "BOUND", spxout, getColName(*this, i, p_cnames, name1));
-         continue;
+template <>
+inline void
+SPxLPBase<Rational>::writeMPS(std::ostream &p_output,  ///< output stream.
+                              const NameSet *p_rnames, ///< row names.
+                              const NameSet *p_cnames, ///< column names.
+                              const DIdxSet *p_intvars ///< integer variables.
+) const {
+
+  const char *indicator;
+  char name[16];
+  char name1[16];
+  char name2[16];
+  bool has_ranges = false;
+  int i;
+  int k;
+
+  // --- NAME Section ---
+  p_output << "NAME          MPSDATA" << std::endl;
+
+  // --- ROWS Section ---
+  p_output << "ROWS" << std::endl;
+
+  for (i = 0; i < nRows(); i++) {
+    if (lhs(i) == rhs(i))
+      indicator = "E";
+    else if ((double(lhs(i)) > -double(infinity)) &&
+             (double(rhs(i)) < double(infinity))) {
+      indicator = "E";
+      has_ranges = true;
+    } else if (double(lhs(i)) > -double(infinity))
+      indicator = "G";
+    else if (double(rhs(i)) < double(infinity))
+      indicator = "L";
+    else
+      throw SPxInternalCodeException("XMPSWR02 This should never happen.");
+
+    MPSwriteRecord(p_output, indicator, MPSgetRowName(*this, i, p_rnames, name),
+                   spxout);
+  }
+
+  MPSwriteRecord(p_output, "N", "MINIMIZE", spxout);
+
+  // --- COLUMNS Section ---
+  p_output << "COLUMNS" << std::endl;
+
+  bool has_intvars = (p_intvars != 0) && (p_intvars->size() > 0);
+
+  for (int j = 0; j < (has_intvars ? 2 : 1); j++) {
+    bool is_intrun = has_intvars && (j == 1);
+
+    if (is_intrun)
+      p_output << "    MARK0001  'MARKER'                 'INTORG'"
+               << std::endl;
+
+    for (i = 0; i < nCols(); i++) {
+      bool is_intvar = has_intvars && (p_intvars->pos(i) >= 0);
+
+      if ((is_intrun && !is_intvar) || (!is_intrun && is_intvar))
+        continue;
+
+      const SVectorBase<Rational> &col = colVector(i);
+      int colsize2 = (col.size() / 2) * 2;
+
+      assert(colsize2 % 2 == 0);
+
+      for (k = 0; k < colsize2; k += 2)
+        MPSwriteRecord(
+            p_output, 0, getColName(*this, i, p_cnames, name), spxout,
+            MPSgetRowName(*this, col.index(k), p_rnames, name1), col.value(k),
+            MPSgetRowName(*this, col.index(k + 1), p_rnames, name2),
+            col.value(k + 1));
+
+      if (colsize2 != col.size())
+        MPSwriteRecord(
+            p_output, 0, getColName(*this, i, p_cnames, name), spxout,
+            MPSgetRowName(*this, col.index(k), p_rnames, name1), col.value(k));
+
+      if (maxObj(i) != 0)
+        MPSwriteRecord(p_output, 0, getColName(*this, i, p_cnames, name),
+                       spxout, "MINIMIZE", -maxObj(i));
+    }
+
+    if (is_intrun)
+      p_output << "    MARK0001  'MARKER'                 'INTEND'"
+               << std::endl;
+  }
+
+  // --- RHS Section ---
+  p_output << "RHS" << std::endl;
+
+  i = 0;
+
+  while (i < nRows()) {
+    Rational rhsval1 = 0;
+    Rational rhsval2 = 0;
+
+    for (; i < nRows(); i++)
+      if ((rhsval1 = MPSgetRHS(lhs(i), rhs(i))) != 0)
+        break;
+
+    if (i < nRows()) {
+      for (k = i + 1; k < nRows(); k++) {
+        if ((rhsval2 = MPSgetRHS(lhs(k), rhs(k))) != 0)
+          break;
       }
 
-      if(lower(i) != 0)
-      {
-         if(double(lower(i)) > -double(infinity))
-            MPSwriteRecord(p_output, "LO", "BOUND", spxout, getColName(*this, i, p_cnames, name1), lower(i));
-         else
-            MPSwriteRecord(p_output, "MI", "BOUND", spxout, getColName(*this, i, p_cnames, name1));
-      }
-
-      if(has_intvars && (p_intvars->pos(i) >= 0))
-      {
-         // Integer variables have default upper bound 1, but we should write
-         // it nevertheless since CPLEX seems to assume infinity otherwise.
-         MPSwriteRecord(p_output, "UP", "BOUND", spxout, getColName(*this, i, p_cnames, name1), upper(i));
+      if (k < nRows()) {
+        MPSwriteRecord(p_output, 0, "RHS", spxout,
+                       MPSgetRowName(*this, i, p_rnames, name1), rhsval1,
+                       MPSgetRowName(*this, k, p_rnames, name2), rhsval2);
+      } else
+        MPSwriteRecord(p_output, 0, "RHS", spxout,
+                       MPSgetRowName(*this, i, p_rnames, name1), rhsval1);
+
+      i = k + 1;
+    }
+  }
+
+  // --- RANGES Section ---
+  if (has_ranges) {
+    p_output << "RANGES" << std::endl;
+
+    for (i = 0; i < nRows(); i++) {
+      if ((double(lhs(i)) > -double(infinity)) &&
+          (double(rhs(i)) < double(infinity))) {
+        Rational range = rhs(i);
+        range -= lhs(i);
+        MPSwriteRecord(p_output, "", "RANGE", spxout,
+                       MPSgetRowName(*this, i, p_rnames, name1), range);
       }
+    }
+  }
+
+  // --- BOUNDS Section ---
+  p_output << "BOUNDS" << std::endl;
+
+  for (i = 0; i < nCols(); i++) {
+    // skip variables that do not appear in the objective function or any
+    // constraint
+    const SVectorBase<Rational> &col = colVector(i);
+
+    if (col.size() == 0 && maxObj(i) == 0)
+      continue;
+
+    if (lower(i) == upper(i)) {
+      MPSwriteRecord(p_output, "FX", "BOUND", spxout,
+                     getColName(*this, i, p_cnames, name1), lower(i));
+      continue;
+    }
+
+    if ((double(lower(i)) <= double(-infinity)) &&
+        (double(upper(i)) >= double(infinity))) {
+      MPSwriteRecord(p_output, "FR", "BOUND", spxout,
+                     getColName(*this, i, p_cnames, name1));
+      continue;
+    }
+
+    if (lower(i) != 0) {
+      if (double(lower(i)) > -double(infinity))
+        MPSwriteRecord(p_output, "LO", "BOUND", spxout,
+                       getColName(*this, i, p_cnames, name1), lower(i));
       else
-      {
-         // Continous variables have default upper bound infinity
-         if(double(upper(i)) < double(infinity))
-            MPSwriteRecord(p_output, "UP", "BOUND", spxout, getColName(*this, i, p_cnames, name1), upper(i));
-      }
-   }
-
-   // --- ENDATA Section ---
-   p_output << "ENDATA" << std::endl;
-
-   // Output warning when writing a maximisation problem
-   if(spxSense() == SPxLPBase<Rational>::MAXIMIZE)
-   {
-      MSG_WARNING((*spxout), (*spxout) <<
-                  "XMPSWR03 Warning: objective function inverted when writing maximization problem in MPS file format\n");
-   }
+        MPSwriteRecord(p_output, "MI", "BOUND", spxout,
+                       getColName(*this, i, p_cnames, name1));
+    }
+
+    if (has_intvars && (p_intvars->pos(i) >= 0)) {
+      // Integer variables have default upper bound 1, but we should write
+      // it nevertheless since CPLEX seems to assume infinity otherwise.
+      MPSwriteRecord(p_output, "UP", "BOUND", spxout,
+                     getColName(*this, i, p_cnames, name1), upper(i));
+    } else {
+      // Continous variables have default upper bound infinity
+      if (double(upper(i)) < double(infinity))
+        MPSwriteRecord(p_output, "UP", "BOUND", spxout,
+                       getColName(*this, i, p_cnames, name1), upper(i));
+    }
+  }
+
+  // --- ENDATA Section ---
+  p_output << "ENDATA" << std::endl;
+
+  // Output warning when writing a maximisation problem
+  if (spxSense() == SPxLPBase<Rational>::MAXIMIZE) {
+    MSG_WARNING(
+        (*spxout), (*spxout)
+                       << "XMPSWR03 Warning: objective function inverted when "
+                          "writing maximization problem in MPS file format\n");
+  }
 }
 
-
-
 /// Building the dual problem from a given LP
-/// @note primalRows must be as large as the number of unranged primal rows + 2 * the number of ranged primal rows.
+/// @note primalRows must be as large as the number of unranged primal rows + 2
+/// * the number of ranged primal rows.
 ///       dualCols must have the identical size to the primal rows.
-template <> inline
-void SPxLPBase<Rational>::buildDualProblem(SPxLPBase<Rational>& dualLP, SPxRowId primalRowIds[],
-      SPxColId primalColIds[],
-      SPxRowId dualRowIds[], SPxColId dualColIds[], int* nprimalrows, int* nprimalcols, int* ndualrows,
-      int* ndualcols)
-{
-   assert(false);
-   MSG_ERROR(std::cerr << "Method buildDualProblem() not implemented for Rational\n");
+template <>
+inline void SPxLPBase<Rational>::buildDualProblem(
+    SPxLPBase<Rational> &dualLP, SPxRowId primalRowIds[],
+    SPxColId primalColIds[], SPxRowId dualRowIds[], SPxColId dualColIds[],
+    int *nprimalrows, int *nprimalcols, int *ndualrows, int *ndualcols) {
+  assert(false);
+  MSG_ERROR(
+      std::cerr << "Method buildDualProblem() not implemented for Rational\n");
 }
 
-
 // ---------------------------------------------------------------------------------------------------------------------
 //  Explicit instantiation
 // ---------------------------------------------------------------------------------------------------------------------
-template class SPxLPBase < Rational >;
+template class SPxLPBase<Rational>;
 } // namespace soplex
diff --git a/src/soplex/spxlpbase_real.hpp b/src/soplex/spxlpbase_real.hpp
index d66f967..8b0293e 100644
--- a/src/soplex/spxlpbase_real.hpp
+++ b/src/soplex/spxlpbase_real.hpp
@@ -21,2096 +21,1864 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 /**@file  spxlpbase_real.hpp
  * @brief Saving LPs with R values in a form suitable for SoPlex.
  */
 
 #include <assert.h>
-#include <stdio.h>
 #include <ctype.h>
 #include <iostream>
+#include <stdio.h>
 
+#include "soplex/exceptions.h"
+#include "soplex/mpsinput.h"
 #include "soplex/spxdefines.h"
 #include "soplex/spxout.h"
-#include "soplex/mpsinput.h"
-#include "soplex/exceptions.h"
 #include "soplex/spxscaler.h"
 
-namespace soplex
-{
+namespace soplex {
 /// Is \p c a \c space, \c tab, \c nl or \c cr ?
-static inline bool LPFisSpace(int c)
-{
-   return (c == ' ') || (c == '\t') || (c == '\n') || (c == '\r');
+static inline bool LPFisSpace(int c) {
+  return (c == ' ') || (c == '\t') || (c == '\n') || (c == '\r');
 }
 
 /// Is there a number at the beginning of \p s ?
-static inline bool LPFisValue(const char* s)
-{
-   return ((*s >= '0') && (*s <= '9')) || (*s == '+') || (*s == '-') || (*s == '.');
+static inline bool LPFisValue(const char *s) {
+  return ((*s >= '0') && (*s <= '9')) || (*s == '+') || (*s == '-') ||
+         (*s == '.');
 }
 
-
 /// Is there a comparison operator at the beginning of \p s ?
-static inline bool LPFisSense(const char* s)
-{
-   return (*s == '<') || (*s == '>') || (*s == '=');
-}
-
-template <class R>
-void SPxLPBase<R>::unscaleLP()
-{
-   MSG_INFO3((*this->spxout), (*this->spxout) << "remove persistent scaling of LP" << std::endl;)
-
-   if(lp_scaler)
-   {
-      lp_scaler->unscale(*this);
-   }
-   else
-   {
-      MSG_INFO3((*this->spxout), (*this->spxout) << "no LP scaler available" << std::endl;)
-   }
+static inline bool LPFisSense(const char *s) {
+  return (*s == '<') || (*s == '>') || (*s == '=');
 }
 
-template <class R> inline
-void SPxLPBase<R>::computePrimalActivity(const VectorBase<R>& primal, VectorBase<R>& activity,
-      const bool unscaled) const
-{
-   if(primal.dim() != nCols())
-      throw SPxInternalCodeException("XSPXLP01 Primal vector for computing row activity has wrong dimension");
-
-   if(activity.dim() != nRows())
-      throw SPxInternalCodeException("XSPXLP03 Activity vector computing row activity has wrong dimension");
-
-   int c;
-
-   for(c = 0; c < nCols() && primal[c] == 0; c++)
-      ;
-
-   if(c >= nCols())
-   {
-      activity.clear();
-      return;
-   }
-
-   DSVectorBase<R> tmp(nRows());
-
-   if(unscaled && _isScaled)
-   {
-      lp_scaler->getColUnscaled(*this, c, tmp);
-      activity = tmp;
-   }
-   else
-      activity = colVector(c);
-
-   activity *= primal[c];
-   c++;
+template <class R> void SPxLPBase<R>::unscaleLP() {
+  MSG_INFO3((*this->spxout),
+            (*this->spxout) << "remove persistent scaling of LP" << std::endl;)
 
-   for(; c < nCols(); c++)
-   {
-      if(primal[c] != 0)
-      {
-         if(unscaled && _isScaled)
-         {
-            lp_scaler->getColUnscaled(*this, c, tmp);
-            activity.multAdd(primal[c], tmp);
-         }
-         else
-            activity.multAdd(primal[c], colVector(c));
-      }
-   }
+  if (lp_scaler) {
+    lp_scaler->unscale(*this);
+  } else {
+    MSG_INFO3((*this->spxout), (*this->spxout)
+                                   << "no LP scaler available" << std::endl;)
+  }
 }
 
-template <class R> inline
-void SPxLPBase<R>::computeDualActivity(const VectorBase<R>& dual, VectorBase<R>& activity,
-                                       const bool unscaled) const
-{
-   if(dual.dim() != nRows())
-      throw SPxInternalCodeException("XSPXLP02 Dual vector for computing dual activity has wrong dimension");
-
-   if(activity.dim() != nCols())
-      throw SPxInternalCodeException("XSPXLP04 Activity vector computing dual activity has wrong dimension");
-
-   int r;
-
-   for(r = 0; r < nRows() && dual[r] == 0; r++)
-      ;
-
-   if(r >= nRows())
-   {
-      activity.clear();
-      return;
-   }
-
-   DSVectorBase<R> tmp(nCols());
-
-   if(unscaled && _isScaled)
-   {
-      lp_scaler->getRowUnscaled(*this, r, tmp);
-      activity = tmp;
-   }
-   else
-      activity = rowVector(r);
-
-   activity *= dual[r];
-   r++;
+template <class R>
+inline void SPxLPBase<R>::computePrimalActivity(const VectorBase<R> &primal,
+                                                VectorBase<R> &activity,
+                                                const bool unscaled) const {
+  if (primal.dim() != nCols())
+    throw SPxInternalCodeException("XSPXLP01 Primal vector for computing row "
+                                   "activity has wrong dimension");
+
+  if (activity.dim() != nRows())
+    throw SPxInternalCodeException(
+        "XSPXLP03 Activity vector computing row activity has wrong dimension");
+
+  int c;
+
+  for (c = 0; c < nCols() && primal[c] == 0; c++)
+    ;
+
+  if (c >= nCols()) {
+    activity.clear();
+    return;
+  }
+
+  DSVectorBase<R> tmp(nRows());
+
+  if (unscaled && _isScaled) {
+    lp_scaler->getColUnscaled(*this, c, tmp);
+    activity = tmp;
+  } else
+    activity = colVector(c);
+
+  activity *= primal[c];
+  c++;
+
+  for (; c < nCols(); c++) {
+    if (primal[c] != 0) {
+      if (unscaled && _isScaled) {
+        lp_scaler->getColUnscaled(*this, c, tmp);
+        activity.multAdd(primal[c], tmp);
+      } else
+        activity.multAdd(primal[c], colVector(c));
+    }
+  }
+}
 
-   for(; r < nRows(); r++)
-   {
-      if(dual[r] != 0)
-      {
-         if(unscaled && _isScaled)
-         {
-            lp_scaler->getRowUnscaled(*this, r, tmp);
-            activity.multAdd(dual[r], tmp);
-         }
-         else
-            activity.multAdd(dual[r], rowVector(r));
-      }
-   }
+template <class R>
+inline void SPxLPBase<R>::computeDualActivity(const VectorBase<R> &dual,
+                                              VectorBase<R> &activity,
+                                              const bool unscaled) const {
+  if (dual.dim() != nRows())
+    throw SPxInternalCodeException(
+        "XSPXLP02 Dual vector for computing dual activity has wrong dimension");
+
+  if (activity.dim() != nCols())
+    throw SPxInternalCodeException(
+        "XSPXLP04 Activity vector computing dual activity has wrong dimension");
+
+  int r;
+
+  for (r = 0; r < nRows() && dual[r] == 0; r++)
+    ;
+
+  if (r >= nRows()) {
+    activity.clear();
+    return;
+  }
+
+  DSVectorBase<R> tmp(nCols());
+
+  if (unscaled && _isScaled) {
+    lp_scaler->getRowUnscaled(*this, r, tmp);
+    activity = tmp;
+  } else
+    activity = rowVector(r);
+
+  activity *= dual[r];
+  r++;
+
+  for (; r < nRows(); r++) {
+    if (dual[r] != 0) {
+      if (unscaled && _isScaled) {
+        lp_scaler->getRowUnscaled(*this, r, tmp);
+        activity.multAdd(dual[r], tmp);
+      } else
+        activity.multAdd(dual[r], rowVector(r));
+    }
+  }
 }
 
-template <class R> inline
-R SPxLPBase<R>::maxAbsNzo(bool unscaled) const
-{
-   R maxi = 0.0;
+template <class R> inline R SPxLPBase<R>::maxAbsNzo(bool unscaled) const {
+  R maxi = 0.0;
 
-   if(unscaled && _isScaled)
-   {
-      assert(lp_scaler != nullptr);
+  if (unscaled && _isScaled) {
+    assert(lp_scaler != nullptr);
 
-      for(int i = 0; i < nCols(); ++i)
-      {
-         R m = lp_scaler->getColMaxAbsUnscaled(*this, i);
+    for (int i = 0; i < nCols(); ++i) {
+      R m = lp_scaler->getColMaxAbsUnscaled(*this, i);
 
-         if(m > maxi)
-            maxi = m;
-      }
-   }
-   else
-   {
-      for(int i = 0; i < nCols(); ++i)
-      {
-         R m = colVector(i).maxAbs();
+      if (m > maxi)
+        maxi = m;
+    }
+  } else {
+    for (int i = 0; i < nCols(); ++i) {
+      R m = colVector(i).maxAbs();
 
-         if(m > maxi)
-            maxi = m;
-      }
-   }
+      if (m > maxi)
+        maxi = m;
+    }
+  }
 
-   assert(maxi >= 0.0);
+  assert(maxi >= 0.0);
 
-   return maxi;
+  return maxi;
 }
 
-template <class R> inline
-R SPxLPBase<R>::minAbsNzo(bool unscaled) const
-{
-   R mini = R(infinity);
+template <class R> inline R SPxLPBase<R>::minAbsNzo(bool unscaled) const {
+  R mini = R(infinity);
 
-   if(unscaled && _isScaled)
-   {
-      assert(lp_scaler != nullptr);
+  if (unscaled && _isScaled) {
+    assert(lp_scaler != nullptr);
 
-      for(int i = 0; i < nCols(); ++i)
-      {
-         R m = lp_scaler->getColMinAbsUnscaled(*this, i);
+    for (int i = 0; i < nCols(); ++i) {
+      R m = lp_scaler->getColMinAbsUnscaled(*this, i);
 
-         if(m < mini)
-            mini = m;
-      }
-   }
-   else
-   {
-      for(int i = 0; i < nCols(); ++i)
-      {
-         R m = colVector(i).minAbs();
+      if (m < mini)
+        mini = m;
+    }
+  } else {
+    for (int i = 0; i < nCols(); ++i) {
+      R m = colVector(i).minAbs();
 
-         if(m < mini)
-            mini = m;
-      }
-   }
+      if (m < mini)
+        mini = m;
+    }
+  }
 
-   assert(mini >= 0.0);
+  assert(mini >= 0.0);
 
-   return mini;
+  return mini;
 }
 
 /// Gets unscaled objective vector.
 template <class R>
-void SPxLPBase<R>::getObjUnscaled(VectorBase<R>& pobj) const
-{
-   if(_isScaled)
-   {
-      assert(lp_scaler);
-      lp_scaler->getMaxObjUnscaled(*this, pobj);
-   }
-   else
-   {
-      pobj = LPColSetBase<R>::maxObj();
-   }
-
-   if(spxSense() == MINIMIZE)
-      pobj *= -1.0;
+void SPxLPBase<R>::getObjUnscaled(VectorBase<R> &pobj) const {
+  if (_isScaled) {
+    assert(lp_scaler);
+    lp_scaler->getMaxObjUnscaled(*this, pobj);
+  } else {
+    pobj = LPColSetBase<R>::maxObj();
+  }
+
+  if (spxSense() == MINIMIZE)
+    pobj *= -1.0;
 }
 
 /// Gets unscaled row vector of row \p i.
 template <class R>
-void SPxLPBase<R>::getRowVectorUnscaled(int i, DSVectorBase<R>& vec) const
-{
-   assert(i >= 0 && i < nRows());
+void SPxLPBase<R>::getRowVectorUnscaled(int i, DSVectorBase<R> &vec) const {
+  assert(i >= 0 && i < nRows());
 
-   if(_isScaled)
-      lp_scaler->getRowUnscaled(*this, i, vec);
-   else
-      vec = DSVectorBase<R>(LPRowSetBase<R>::rowVector(i));
+  if (_isScaled)
+    lp_scaler->getRowUnscaled(*this, i, vec);
+  else
+    vec = DSVectorBase<R>(LPRowSetBase<R>::rowVector(i));
 }
 
 /// Gets unscaled right hand side vector.
-template <class R>
-void SPxLPBase<R>::getRhsUnscaled(VectorBase<R>& vec) const
-{
-   if(_isScaled)
-      lp_scaler->getRhsUnscaled(*this, vec);
-   else
-      vec = LPRowSetBase<R>::rhs();
+template <class R> void SPxLPBase<R>::getRhsUnscaled(VectorBase<R> &vec) const {
+  if (_isScaled)
+    lp_scaler->getRhsUnscaled(*this, vec);
+  else
+    vec = LPRowSetBase<R>::rhs();
 }
 
 /// Returns unscaled right hand side of row number \p i.
-template <class R>
-R SPxLPBase<R>::rhsUnscaled(int i) const
-{
-   assert(i >= 0 && i < nRows());
+template <class R> R SPxLPBase<R>::rhsUnscaled(int i) const {
+  assert(i >= 0 && i < nRows());
 
-   if(_isScaled)
-      return lp_scaler->rhsUnscaled(*this, i);
-   else
-      return LPRowSetBase<R>::rhs(i);
+  if (_isScaled)
+    return lp_scaler->rhsUnscaled(*this, i);
+  else
+    return LPRowSetBase<R>::rhs(i);
 }
 
 /// Returns unscaled right hand side of row with identifier \p id.
-template <class R>
-R SPxLPBase<R>::rhsUnscaled(const SPxRowId& id) const
-{
-   assert(id.isValid());
-   return rhsUnscaled(number(id));
+template <class R> R SPxLPBase<R>::rhsUnscaled(const SPxRowId &id) const {
+  assert(id.isValid());
+  return rhsUnscaled(number(id));
 }
 
 /// Returns unscaled left hand side vector.
-template <class R>
-void SPxLPBase<R>::getLhsUnscaled(VectorBase<R>& vec) const
-{
-   if(_isScaled)
-      lp_scaler->getLhsUnscaled(*this, vec);
-   else
-      vec = LPRowSetBase<R>::lhs();
+template <class R> void SPxLPBase<R>::getLhsUnscaled(VectorBase<R> &vec) const {
+  if (_isScaled)
+    lp_scaler->getLhsUnscaled(*this, vec);
+  else
+    vec = LPRowSetBase<R>::lhs();
 }
 
 /// Returns unscaled left hand side of row number \p i.
-template <class R>
-R SPxLPBase<R>::lhsUnscaled(int i) const
-{
-   assert(i >= 0 && i < nRows());
+template <class R> R SPxLPBase<R>::lhsUnscaled(int i) const {
+  assert(i >= 0 && i < nRows());
 
-   if(_isScaled)
-      return lp_scaler->lhsUnscaled(*this, i);
-   else
-      return LPRowSetBase<R>::lhs(i);
+  if (_isScaled)
+    return lp_scaler->lhsUnscaled(*this, i);
+  else
+    return LPRowSetBase<R>::lhs(i);
 }
 
 /// Returns left hand side of row with identifier \p id.
-template <class R>
-R SPxLPBase<R>::lhsUnscaled(const SPxRowId& id) const
-{
-   assert(id.isValid());
-   return lhsUnscaled(number(id));
+template <class R> R SPxLPBase<R>::lhsUnscaled(const SPxRowId &id) const {
+  assert(id.isValid());
+  return lhsUnscaled(number(id));
 }
 
 /// Gets column vector of column \p i.
 template <class R>
-void SPxLPBase<R>::getColVectorUnscaled(int i, DSVectorBase<R>& vec) const
-{
-   assert(i >= 0 && i < nCols());
+void SPxLPBase<R>::getColVectorUnscaled(int i, DSVectorBase<R> &vec) const {
+  assert(i >= 0 && i < nCols());
 
-   if(_isScaled)
-      lp_scaler->getColUnscaled(*this, i, vec);
-   else
-      vec = LPColSetBase<R>::colVector(i);
+  if (_isScaled)
+    lp_scaler->getColUnscaled(*this, i, vec);
+  else
+    vec = LPColSetBase<R>::colVector(i);
 }
 
 /// Gets column vector of column with identifier \p id.
 template <class R>
-void SPxLPBase<R>::getColVectorUnscaled(const SPxColId& id, DSVectorBase<R>& vec) const
-{
-   assert(id.isValid());
-   getColVectorUnscaled(number(id), vec);
+void SPxLPBase<R>::getColVectorUnscaled(const SPxColId &id,
+                                        DSVectorBase<R> &vec) const {
+  assert(id.isValid());
+  getColVectorUnscaled(number(id), vec);
 }
 
 /// Returns unscaled objective value of column \p i.
-template <class R>
-R SPxLPBase<R>::objUnscaled(int i) const
-{
-   assert(i >= 0 && i < nCols());
-   R res;
-
-   if(_isScaled)
-   {
-      res = lp_scaler->maxObjUnscaled(*this, i);
-   }
-   else
-   {
-      res = maxObj(i);
-   }
-
-   if(spxSense() == MINIMIZE)
-      res *= -1;
-
-   return res;
+template <class R> R SPxLPBase<R>::objUnscaled(int i) const {
+  assert(i >= 0 && i < nCols());
+  R res;
+
+  if (_isScaled) {
+    res = lp_scaler->maxObjUnscaled(*this, i);
+  } else {
+    res = maxObj(i);
+  }
+
+  if (spxSense() == MINIMIZE)
+    res *= -1;
+
+  return res;
 }
 
 /// Returns unscaled objective value of column with identifier \p id.
-template <class R>
-R SPxLPBase<R>::objUnscaled(const SPxColId& id) const
-{
-   assert(id.isValid());
-   return objUnscaled(number(id));
+template <class R> R SPxLPBase<R>::objUnscaled(const SPxColId &id) const {
+  assert(id.isValid());
+  return objUnscaled(number(id));
 }
 
 /// Returns unscaled objective vector for maximization problem.
-template <class R>
-void SPxLPBase<R>::maxObjUnscaled(VectorBase<R>& vec) const
-{
-   if(_isScaled)
-      lp_scaler->getMaxObjUnscaled(*this, vec);
-   else
-      vec = LPColSetBase<R>::maxObj();
+template <class R> void SPxLPBase<R>::maxObjUnscaled(VectorBase<R> &vec) const {
+  if (_isScaled)
+    lp_scaler->getMaxObjUnscaled(*this, vec);
+  else
+    vec = LPColSetBase<R>::maxObj();
 }
 
 /// Returns unscaled objective value of column \p i for maximization problem.
-template <class R>
-R SPxLPBase<R>::maxObjUnscaled(int i) const
-{
-   assert(i >= 0 && i < nCols());
+template <class R> R SPxLPBase<R>::maxObjUnscaled(int i) const {
+  assert(i >= 0 && i < nCols());
 
-   if(_isScaled)
-      return lp_scaler->maxObjUnscaled(*this, i);
-   else
-      return LPColSetBase<R>::maxObj(i);
+  if (_isScaled)
+    return lp_scaler->maxObjUnscaled(*this, i);
+  else
+    return LPColSetBase<R>::maxObj(i);
 }
 
-/// Returns unscaled objective value of column with identifier \p id for maximization problem.
-template <class R>
-R SPxLPBase<R>::maxObjUnscaled(const SPxColId& id) const
-{
-   assert(id.isValid());
-   return maxObjUnscaled(number(id));
+/// Returns unscaled objective value of column with identifier \p id for
+/// maximization problem.
+template <class R> R SPxLPBase<R>::maxObjUnscaled(const SPxColId &id) const {
+  assert(id.isValid());
+  return maxObjUnscaled(number(id));
 }
 
 /// Returns unscaled upper bound vector
 template <class R>
-void SPxLPBase<R>::getUpperUnscaled(VectorBase<R>& vec) const
-{
-   if(_isScaled)
-      lp_scaler->getUpperUnscaled(*this, vec);
-   else
-      vec = VectorBase<R>(LPColSetBase<R>::upper());
+void SPxLPBase<R>::getUpperUnscaled(VectorBase<R> &vec) const {
+  if (_isScaled)
+    lp_scaler->getUpperUnscaled(*this, vec);
+  else
+    vec = VectorBase<R>(LPColSetBase<R>::upper());
 }
 
 /// Returns unscaled upper bound of column \p i.
-template <class R>
-R SPxLPBase<R>::upperUnscaled(int i) const
-{
-   assert(i >= 0 && i < nCols());
+template <class R> R SPxLPBase<R>::upperUnscaled(int i) const {
+  assert(i >= 0 && i < nCols());
 
-   if(_isScaled)
-      return lp_scaler->upperUnscaled(*this, i);
-   else
-      return LPColSetBase<R>::upper(i);
+  if (_isScaled)
+    return lp_scaler->upperUnscaled(*this, i);
+  else
+    return LPColSetBase<R>::upper(i);
 }
 
 /// Returns unscaled upper bound of column with identifier \p id.
-template <class R>
-R SPxLPBase<R>::upperUnscaled(const SPxColId& id) const
-{
-   assert(id.isValid());
-   return upperUnscaled(number(id));
+template <class R> R SPxLPBase<R>::upperUnscaled(const SPxColId &id) const {
+  assert(id.isValid());
+  return upperUnscaled(number(id));
 }
 
 /// Returns unscaled lower bound vector.
 template <class R>
-void SPxLPBase<R>::getLowerUnscaled(VectorBase<R>& vec) const
-{
-   if(_isScaled)
-      lp_scaler->getLowerUnscaled(*this, vec);
-   else
-      vec = VectorBase<R>(LPColSetBase<R>::lower());
+void SPxLPBase<R>::getLowerUnscaled(VectorBase<R> &vec) const {
+  if (_isScaled)
+    lp_scaler->getLowerUnscaled(*this, vec);
+  else
+    vec = VectorBase<R>(LPColSetBase<R>::lower());
 }
 
 /// Returns unscaled lower bound of column \p i.
-template<class R>
-R SPxLPBase<R>::lowerUnscaled(int i) const
-{
-   assert(i >= 0 && i < nCols());
+template <class R> R SPxLPBase<R>::lowerUnscaled(int i) const {
+  assert(i >= 0 && i < nCols());
 
-   if(_isScaled)
-      return lp_scaler->lowerUnscaled(*this, i);
-   else
-      return LPColSetBase<R>::lower(i);
+  if (_isScaled)
+    return lp_scaler->lowerUnscaled(*this, i);
+  else
+    return LPColSetBase<R>::lower(i);
 }
 
 /// Returns unscaled lower bound of column with identifier \p id.
-template <class R>
-R SPxLPBase<R>::lowerUnscaled(const SPxColId& id) const
-{
-   assert(id.isValid());
-   return lowerUnscaled(number(id));
+template <class R> R SPxLPBase<R>::lowerUnscaled(const SPxColId &id) const {
+  assert(id.isValid());
+  return lowerUnscaled(number(id));
 }
 
-
-
-
 // ---------------------------------------------------------------------------------------------------------------------
 //  Specialization for reading LP format
 // ---------------------------------------------------------------------------------------------------------------------
 
-#define LPF_MAX_LINE_LEN  8192     ///< maximum length of a line (8190 + \\n + \\0)
-
+#define LPF_MAX_LINE_LEN 8192 ///< maximum length of a line (8190 + \\n + \\0)
 
 /// Is there a possible column name at the beginning of \p s ?
-static inline bool LPFisColName(const char* s)
-{
-   // strchr() gives a true for the null char.
-   if(*s == '\0')
-      return false;
+static inline bool LPFisColName(const char *s) {
+  // strchr() gives a true for the null char.
+  if (*s == '\0')
+    return false;
 
-   return ((*s >= 'A') && (*s <= 'Z'))
-          || ((*s >= 'a') && (*s <= 'z'))
-          || (strchr("!\"#$%&()/,;?@_'`{}|~", *s) != 0);
+  return ((*s >= 'A') && (*s <= 'Z')) || ((*s >= 'a') && (*s <= 'z')) ||
+         (strchr("!\"#$%&()/,;?@_'`{}|~", *s) != 0);
 }
 
-
-static inline bool LPFisInfinity(const char* s)
-{
-   return ((s[0] == '-') || (s[0] == '+'))
-          && (tolower(s[1]) == 'i')
-          && (tolower(s[2]) == 'n')
-          && (tolower(s[3]) == 'f');
+static inline bool LPFisInfinity(const char *s) {
+  return ((s[0] == '-') || (s[0] == '+')) && (tolower(s[1]) == 'i') &&
+         (tolower(s[2]) == 'n') && (tolower(s[3]) == 'f');
 }
 
-
-
-static inline bool LPFisFree(const char* s)
-{
-   return (tolower(s[0]) == 'f')
-          && (tolower(s[1]) == 'r')
-          && (tolower(s[2]) == 'e')
-          && (tolower(s[3]) == 'e');
+static inline bool LPFisFree(const char *s) {
+  return (tolower(s[0]) == 'f') && (tolower(s[1]) == 'r') &&
+         (tolower(s[2]) == 'e') && (tolower(s[3]) == 'e');
 }
 
-
-
 /// Read the next number and advance \p pos.
-/** If only a sign is encountered, the number is assumed to be \c sign * 1.0.  This routine will not catch malformatted
- *  numbers like .e10 !
+/** If only a sign is encountered, the number is assumed to be \c sign * 1.0.
+ * This routine will not catch malformatted numbers like .e10 !
  */
-template <class R>
-static R LPFreadValue(char*& pos, SPxOut* spxout)
-{
-   assert(LPFisValue(pos));
-
-   char        tmp[LPF_MAX_LINE_LEN];
-   const char* s = pos;
-   char*       t;
-   R        value = 1.0;
-   bool        has_digits = false;
-   bool        has_emptyexponent = false;
-
-   // 1. sign
-   if((*s == '+') || (*s == '-'))
-      s++;
-
-   // 2. Digits before the decimal dot
-   while((*s >= '0') && (*s <= '9'))
-   {
+template <class R> static R LPFreadValue(char *&pos, SPxOut *spxout) {
+  assert(LPFisValue(pos));
+
+  char tmp[LPF_MAX_LINE_LEN];
+  const char *s = pos;
+  char *t;
+  R value = 1.0;
+  bool has_digits = false;
+  bool has_emptyexponent = false;
+
+  // 1. sign
+  if ((*s == '+') || (*s == '-'))
+    s++;
+
+  // 2. Digits before the decimal dot
+  while ((*s >= '0') && (*s <= '9')) {
+    has_digits = true;
+    s++;
+  }
+
+  // 3. Decimal dot
+  if (*s == '.') {
+    s++;
+
+    // 4. If there was a dot, possible digit behind it
+    while ((*s >= '0') && (*s <= '9')) {
       has_digits = true;
       s++;
-   }
-
-   // 3. Decimal dot
-   if(*s == '.')
-   {
-      s++;
+    }
+  }
 
-      // 4. If there was a dot, possible digit behind it
-      while((*s >= '0') && (*s <= '9'))
-      {
-         has_digits = true;
-         s++;
-      }
-   }
+  // 5. Exponent
+  if (tolower(*s) == 'e') {
+    has_emptyexponent = true;
+    s++;
 
-   // 5. Exponent
-   if(tolower(*s) == 'e')
-   {
-      has_emptyexponent = true;
+    // 6. Exponent sign
+    if ((*s == '+') || (*s == '-'))
       s++;
 
-      // 6. Exponent sign
-      if((*s == '+') || (*s == '-'))
-         s++;
-
-      // 7. Exponent digits
-      while((*s >= '0') && (*s <= '9'))
-      {
-         has_emptyexponent = false;
-         s++;
-      }
-   }
+    // 7. Exponent digits
+    while ((*s >= '0') && (*s <= '9')) {
+      has_emptyexponent = false;
+      s++;
+    }
+  }
 
-   assert(s != pos);
+  assert(s != pos);
 
-   if(has_emptyexponent)
-   {
-      MSG_WARNING((*spxout), (*spxout) <<
-                  "WLPFRD01 Warning: found empty exponent in LP file - check for forbidden variable names with initial 'e' or 'E'\n";
-                 )
-   }
+  if (has_emptyexponent) {
+    MSG_WARNING(
+        (*spxout),
+        (*spxout)
+            << "WLPFRD01 Warning: found empty exponent in LP file - check for "
+               "forbidden variable names with initial 'e' or 'E'\n";)
+  }
 
-   if(!has_digits)
-      value = (*pos == '-') ? -1.0 : 1.0;
-   else
-   {
-      for(t = tmp; pos != s; pos++)
-         *t++ = *pos;
+  if (!has_digits)
+    value = (*pos == '-') ? -1.0 : 1.0;
+  else {
+    for (t = tmp; pos != s; pos++)
+      *t++ = *pos;
 
-      *t = '\0';
-      value = atof(tmp);
-   }
+    *t = '\0';
+    value = atof(tmp);
+  }
 
-   pos += s - pos;
+  pos += s - pos;
 
-   assert(pos == s);
+  assert(pos == s);
 
-   MSG_DEBUG(std::cout << "DLPFRD01 LPFreadValue = " << value << std::endl;)
+  MSG_DEBUG(std::cout << "DLPFRD01 LPFreadValue = " << value << std::endl;)
 
-   if(LPFisSpace(*pos))
-      pos++;
+  if (LPFisSpace(*pos))
+    pos++;
 
-   return value;
+  return value;
 }
 
-
-
 /// Read the next column name from the input.
 /** The name read is looked up and if not found \p emptycol
  *  is added to \p colset. \p pos is advanced behind the name.
  *  @return The Index of the named column.
  */
 template <class R>
-static int LPFreadColName(char*& pos, NameSet* colnames, LPColSetBase<R>& colset,
-                          const LPColBase<R>* emptycol, SPxOut* spxout)
-{
-   assert(LPFisColName(pos));
-   assert(colnames != 0);
-
-   char        name[LPF_MAX_LINE_LEN];
-   const char* s = pos;
-   int         i;
-   int         colidx;
-
-   // These are the characters that are not allowed in a column name.
-   while((strchr("+-.<>= ", *s) == 0) && (*s != '\0'))
-      s++;
-
-   for(i = 0; pos != s; i++, pos++)
-      name[i] = *pos;
-
-   name[i] = '\0';
-
-   if((colidx = colnames->number(name)) < 0)
-   {
-      // We only add the name if we got an empty column.
-      if(emptycol == nullptr)
-      {
-         MSG_WARNING((*spxout), (*spxout) << "WLPFRD02 Unknown variable \"" << name << "\" ";)
-      }
-      else
-      {
-         colidx = colnames->num();
-         colnames->add(name);
-         colset.add(*emptycol);
-      }
-   }
-
-   MSG_DEBUG(std::cout << "DLPFRD03 LPFreadColName [" << name << "] = " << colidx << std::endl;)
-
-   if(LPFisSpace(*pos))
-      pos++;
-
-   return colidx;
+static int LPFreadColName(char *&pos, NameSet *colnames,
+                          LPColSetBase<R> &colset, const LPColBase<R> *emptycol,
+                          SPxOut *spxout) {
+  assert(LPFisColName(pos));
+  assert(colnames != 0);
+
+  char name[LPF_MAX_LINE_LEN];
+  const char *s = pos;
+  int i;
+  int colidx;
+
+  // These are the characters that are not allowed in a column name.
+  while ((strchr("+-.<>= ", *s) == 0) && (*s != '\0'))
+    s++;
+
+  for (i = 0; pos != s; i++, pos++)
+    name[i] = *pos;
+
+  name[i] = '\0';
+
+  if ((colidx = colnames->number(name)) < 0) {
+    // We only add the name if we got an empty column.
+    if (emptycol == nullptr) {
+      MSG_WARNING((*spxout),
+                  (*spxout) << "WLPFRD02 Unknown variable \"" << name << "\" ";)
+    } else {
+      colidx = colnames->num();
+      colnames->add(name);
+      colset.add(*emptycol);
+    }
+  }
+
+  MSG_DEBUG(std::cout << "DLPFRD03 LPFreadColName [" << name << "] = " << colidx
+                      << std::endl;)
+
+  if (LPFisSpace(*pos))
+    pos++;
+
+  return colidx;
 }
 
-
-
 /// Read the next <,>,=,==,<=,=<,>=,=> and advance \p pos.
-static inline int LPFreadSense(char*& pos)
-{
-   assert(LPFisSense(pos));
+static inline int LPFreadSense(char *&pos) {
+  assert(LPFisSense(pos));
 
-   int sense = *pos++;
+  int sense = *pos++;
 
-   if((*pos == '<') || (*pos == '>'))
-      sense = *pos++;
-   else if(*pos == '=')
-      pos++;
+  if ((*pos == '<') || (*pos == '>'))
+    sense = *pos++;
+  else if (*pos == '=')
+    pos++;
 
-   MSG_DEBUG(std::cout << "DLPFRD04 LPFreadSense = " << static_cast<char>(sense) << std::endl;)
+  MSG_DEBUG(std::cout << "DLPFRD04 LPFreadSense = " << static_cast<char>(sense)
+                      << std::endl;)
 
-   if(LPFisSpace(*pos))
-      pos++;
+  if (LPFisSpace(*pos))
+    pos++;
 
-   return sense;
+  return sense;
 }
 
-
-
 /// Is the \p keyword present in \p buf ? If yes, advance \p pos.
-/** \p keyword should be lower case. It can contain optional sections which are enclosed in '[' ']' like "min[imize]".
+/** \p keyword should be lower case. It can contain optional sections which are
+ * enclosed in '[' ']' like "min[imize]".
  */
-static inline bool LPFhasKeyword(char*& pos, const char* keyword)
-{
-   int i;
-   int k;
-
-   assert(keyword != 0);
-
-   for(i = 0, k = 0; keyword[i] != '\0'; i++, k++)
-   {
-      if(keyword[i] == '[')
-      {
-         i++;
+static inline bool LPFhasKeyword(char *&pos, const char *keyword) {
+  int i;
+  int k;
 
-         // Here we assumed that we have a ']' for the '['.
-         while((tolower(pos[k]) == keyword[i]) && (pos[k] != '\0'))
-         {
-            k++;
-            i++;
-         }
+  assert(keyword != 0);
 
-         while(keyword[i] != ']')
-            i++;
+  for (i = 0, k = 0; keyword[i] != '\0'; i++, k++) {
+    if (keyword[i] == '[') {
+      i++;
 
-         --k;
-      }
-      else
-      {
-         if(keyword[i] != tolower(pos[k]))
-            break;
+      // Here we assumed that we have a ']' for the '['.
+      while ((tolower(pos[k]) == keyword[i]) && (pos[k] != '\0')) {
+        k++;
+        i++;
       }
-   }
 
-   // we have to be at the end of the keyword and the word found on the line also has to end here.  Attention: The
-   // LPFisSense is a kludge to allow LPFhasKeyword also to process Inf[inity] keywords in the bounds section.
-   if(keyword[i] == '\0' && (pos[k] == '\0' || LPFisSpace(pos[k]) || LPFisSense(&pos[k])))
-   {
-      pos += k;
+      while (keyword[i] != ']')
+        i++;
 
-      MSG_DEBUG(std::cout << "DLPFRD05 LPFhasKeyword: " << keyword << std::endl;)
+      --k;
+    } else {
+      if (keyword[i] != tolower(pos[k]))
+        break;
+    }
+  }
 
-      return true;
-   }
+  // we have to be at the end of the keyword and the word found on the line also
+  // has to end here.  Attention: The LPFisSense is a kludge to allow
+  // LPFhasKeyword also to process Inf[inity] keywords in the bounds section.
+  if (keyword[i] == '\0' &&
+      (pos[k] == '\0' || LPFisSpace(pos[k]) || LPFisSense(&pos[k]))) {
+    pos += k;
 
-   return false;
-}
+    MSG_DEBUG(std::cout << "DLPFRD05 LPFhasKeyword: " << keyword << std::endl;)
 
+    return true;
+  }
 
+  return false;
+}
 
-/// If \p buf start with "name:" store the name in \p rownames and advance \p pos.
-static inline bool LPFhasRowName(char*& pos, NameSet* rownames)
-{
-   const char* s = strchr(pos, ':');
+/// If \p buf start with "name:" store the name in \p rownames and advance \p
+/// pos.
+static inline bool LPFhasRowName(char *&pos, NameSet *rownames) {
+  const char *s = strchr(pos, ':');
 
-   if(s == 0)
-      return false;
+  if (s == 0)
+    return false;
 
-   int dcolpos = int(s - pos);
+  int dcolpos = int(s - pos);
 
-   int end;
-   int srt;
+  int end;
+  int srt;
 
-   // skip spaces between name and ":"
-   for(end = dcolpos - 1; end >= 0; end--)
-      if(pos[end] != ' ')
-         break;
+  // skip spaces between name and ":"
+  for (end = dcolpos - 1; end >= 0; end--)
+    if (pos[end] != ' ')
+      break;
 
-   // are there only spaces in front of the ":" ?
-   if(end < 0)
-   {
-      pos = &(pos[dcolpos + 1]);
-      return false;
-   }
+  // are there only spaces in front of the ":" ?
+  if (end < 0) {
+    pos = &(pos[dcolpos + 1]);
+    return false;
+  }
 
-   // skip spaces in front of name
-   for(srt = end - 1; srt >= 0; srt--)
-      if(pos[srt] == ' ')
-         break;
+  // skip spaces in front of name
+  for (srt = end - 1; srt >= 0; srt--)
+    if (pos[srt] == ' ')
+      break;
 
-   // go back to the non-space character
-   srt++;
+  // go back to the non-space character
+  srt++;
 
-   assert(srt <= end && pos[srt] != ' ');
+  assert(srt <= end && pos[srt] != ' ');
 
-   char name[LPF_MAX_LINE_LEN];
-   int i;
-   int k = 0;
+  char name[LPF_MAX_LINE_LEN];
+  int i;
+  int k = 0;
 
-   for(i = srt; i <= end; i++)
-      name[k++] = pos[i];
+  for (i = srt; i <= end; i++)
+    name[k++] = pos[i];
 
-   name[k] = '\0';
+  name[k] = '\0';
 
-   if(rownames != 0)
-      rownames->add(name);
+  if (rownames != 0)
+    rownames->add(name);
 
-   pos = &(pos[dcolpos + 1]);
+  pos = &(pos[dcolpos + 1]);
 
-   return true;
+  return true;
 }
 
+template <class R> static R LPFreadInfinity(char *&pos) {
+  assert(LPFisInfinity(pos));
 
-template <class R>
-static R LPFreadInfinity(char*& pos)
-{
-   assert(LPFisInfinity(pos));
-
-   R sense = (*pos == '-') ? -1.0 : 1.0;
+  R sense = (*pos == '-') ? -1.0 : 1.0;
 
-   (void) LPFhasKeyword(++pos, "inf[inity]");
+  (void)LPFhasKeyword(++pos, "inf[inity]");
 
-   return sense * R(infinity);
+  return sense * R(infinity);
 }
 
-
 /// Read LP in "CPLEX LP File Format".
-/** The specification is taken from the ILOG CPLEX 7.0 Reference Manual, Appendix E, Page 527.
+/** The specification is taken from the ILOG CPLEX 7.0 Reference Manual,
+ * Appendix E, Page 527.
  *
- *  This routine should read (most?) valid LP format files.  What it will not do, is find all cases where a file is ill
- *  formed.  If this happens it may complain and read nothing or read "something".
+ *  This routine should read (most?) valid LP format files.  What it will not
+ * do, is find all cases where a file is ill formed.  If this happens it may
+ * complain and read nothing or read "something".
  *
- *  Problem: A line ending in '+' or '-' followed by a line starting with a number, will be regarded as an error.
+ *  Problem: A line ending in '+' or '-' followed by a line starting with a
+ * number, will be regarded as an error.
  *
- *  The reader will accept the keyword INT[egers] as a synonym for GEN[erals] which is an undocumented feature in CPLEX.
+ *  The reader will accept the keyword INT[egers] as a synonym for GEN[erals]
+ * which is an undocumented feature in CPLEX.
  *
- *  A difference to the CPLEX reader, is that no name for the objective row is required.
+ *  A difference to the CPLEX reader, is that no name for the objective row is
+ * required.
  *
- * The manual says the maximum allowed line length is 255 characters, but CPLEX does not complain if the lines are
- * longer.
+ * The manual says the maximum allowed line length is 255 characters, but CPLEX
+ * does not complain if the lines are longer.
  *
  *  @return true if the file was read correctly
  */
-template <class R> inline
-bool SPxLPBase<R>::readLPF(
-   std::istream& p_input,                ///< input stream.
-   NameSet*      p_rnames,               ///< row names.
-   NameSet*      p_cnames,               ///< column names.
-   DIdxSet*      p_intvars)              ///< integer variables.
+template <class R>
+inline bool SPxLPBase<R>::readLPF(std::istream &p_input, ///< input stream.
+                                  NameSet *p_rnames,     ///< row names.
+                                  NameSet *p_cnames,     ///< column names.
+                                  DIdxSet *p_intvars)    ///< integer variables.
 {
-   enum
-   {
-      START, OBJECTIVE, CONSTRAINTS, BOUNDS, INTEGERS, BINARIES
-   } section = START;
-
-   NameSet* rnames;                      ///< row names.
-   NameSet* cnames;                      ///< column names.
-
-   LPColSetBase<R> cset;              ///< the set of columns read.
-   LPRowSetBase<R> rset;              ///< the set of rows read.
-   LPColBase<R> emptycol;             ///< reusable empty column.
-   LPRowBase<R> row;                  ///< last assembled row.
-   DSVectorBase<R> vec;               ///< last assembled vector (from row).
-
-   R val = 1.0;
-   int colidx;
-   int sense = 0;
-
-   char buf[LPF_MAX_LINE_LEN];
-   char tmp[LPF_MAX_LINE_LEN];
-   char line[LPF_MAX_LINE_LEN];
-   int lineno = 0;
-   bool unnamed = true;
-   bool finished = false;
-   bool other;
-   bool have_value = true;
-   int i;
-   int k;
-   char* s;
-   char* pos;
-   char* pos_old = 0;
-
-   if(p_cnames)
-      cnames = p_cnames;
-   else
-   {
-      cnames = 0;
-      spx_alloc(cnames);
-      cnames = new(cnames) NameSet();
-   }
-
-   cnames->clear();
-
-   if(p_rnames)
-      rnames = p_rnames;
-   else
-   {
-      try
-      {
-         rnames = 0;
-         spx_alloc(rnames);
-         rnames = new(rnames) NameSet();
-      }
-      catch(const SPxMemoryException& x)
-      {
-         if(!p_cnames)
-         {
-            cnames->~NameSet();
-            spx_free(cnames);
-         }
-
-         throw x;
-      }
-   }
-
-   rnames->clear();
-
-   SPxLPBase<R>::clear(); // clear the LP.
-
-   //--------------------------------------------------------------------------
-   //--- Main Loop
-   //--------------------------------------------------------------------------
-   for(;;)
-   {
-      // 0. Read a line from the file.
-      if(!p_input.getline(buf, sizeof(buf)))
-      {
-         if(strlen(buf) == LPF_MAX_LINE_LEN - 1)
-         {
-            MSG_ERROR(std::cerr << "ELPFRD06 Line exceeds " << LPF_MAX_LINE_LEN - 2
-                      << " characters" << std::endl;)
-         }
-         else
-         {
-            MSG_ERROR(std::cerr << "ELPFRD07 No 'End' marker found" << std::endl;)
-            finished = true;
-         }
-
-         break;
-      }
-
-      lineno++;
-      i   = 0;
-      pos = buf;
-
-      MSG_DEBUG(std::cout << "DLPFRD08 Reading line " << lineno
-                << " (pos=" << pos << ")" << std::endl;)
+  enum {
+    START,
+    OBJECTIVE,
+    CONSTRAINTS,
+    BOUNDS,
+    INTEGERS,
+    BINARIES
+  } section = START;
+
+  NameSet *rnames; ///< row names.
+  NameSet *cnames; ///< column names.
+
+  LPColSetBase<R> cset;  ///< the set of columns read.
+  LPRowSetBase<R> rset;  ///< the set of rows read.
+  LPColBase<R> emptycol; ///< reusable empty column.
+  LPRowBase<R> row;      ///< last assembled row.
+  DSVectorBase<R> vec;   ///< last assembled vector (from row).
+
+  R val = 1.0;
+  int colidx;
+  int sense = 0;
+
+  char buf[LPF_MAX_LINE_LEN];
+  char tmp[LPF_MAX_LINE_LEN];
+  char line[LPF_MAX_LINE_LEN];
+  int lineno = 0;
+  bool unnamed = true;
+  bool finished = false;
+  bool other;
+  bool have_value = true;
+  int i;
+  int k;
+  char *s;
+  char *pos;
+  char *pos_old = 0;
+
+  if (p_cnames)
+    cnames = p_cnames;
+  else {
+    cnames = 0;
+    spx_alloc(cnames);
+    cnames = new (cnames) NameSet();
+  }
+
+  cnames->clear();
+
+  if (p_rnames)
+    rnames = p_rnames;
+  else {
+    try {
+      rnames = 0;
+      spx_alloc(rnames);
+      rnames = new (rnames) NameSet();
+    } catch (const SPxMemoryException &x) {
+      if (!p_cnames) {
+        cnames->~NameSet();
+        spx_free(cnames);
+      }
+
+      throw x;
+    }
+  }
+
+  rnames->clear();
+
+  SPxLPBase<R>::clear(); // clear the LP.
+
+  //--------------------------------------------------------------------------
+  //--- Main Loop
+  //--------------------------------------------------------------------------
+  for (;;) {
+    // 0. Read a line from the file.
+    if (!p_input.getline(buf, sizeof(buf))) {
+      if (strlen(buf) == LPF_MAX_LINE_LEN - 1) {
+        MSG_ERROR(std::cerr << "ELPFRD06 Line exceeds " << LPF_MAX_LINE_LEN - 2
+                            << " characters" << std::endl;)
+      } else {
+        MSG_ERROR(std::cerr << "ELPFRD07 No 'End' marker found" << std::endl;)
+        finished = true;
+      }
+
+      break;
+    }
+
+    lineno++;
+    i = 0;
+    pos = buf;
+
+    MSG_DEBUG(std::cout << "DLPFRD08 Reading line " << lineno << " (pos=" << pos
+                        << ")" << std::endl;)
+
+    // 1. Remove comments.
+    if (0 != (s = strchr(buf, '\\')))
+      *s = '\0';
+
+    // 2. Look for keywords.
+    if (section == START) {
+      if (LPFhasKeyword(pos, "max[imize]")) {
+        changeSense(SPxLPBase<R>::MAXIMIZE);
+        section = OBJECTIVE;
+      } else if (LPFhasKeyword(pos, "min[imize]")) {
+        changeSense(SPxLPBase<R>::MINIMIZE);
+        section = OBJECTIVE;
+      }
+    } else if (section == OBJECTIVE) {
+      if (LPFhasKeyword(pos, "s[ubject][   ]t[o]") ||
+          LPFhasKeyword(pos, "s[uch][    ]t[hat]") ||
+          LPFhasKeyword(pos, "s[.][    ]t[.]") ||
+          LPFhasKeyword(pos, "lazy con[straints]")) {
+        // store objective vector
+        for (int j = vec.size() - 1; j >= 0; --j)
+          cset.maxObj_w(vec.index(j)) = vec.value(j);
+
+        // multiplication with -1 for minimization is done below
+        vec.clear();
+        have_value = true;
+        val = 1.0;
+        section = CONSTRAINTS;
+      }
+    } else if (section == CONSTRAINTS &&
+               (LPFhasKeyword(pos, "s[ubject][   ]t[o]") ||
+                LPFhasKeyword(pos, "s[uch][    ]t[hat]") ||
+                LPFhasKeyword(pos, "s[.][    ]t[.]"))) {
+      have_value = true;
+      val = 1.0;
+    } else {
+      if (LPFhasKeyword(pos, "lazy con[straints]"))
+        ;
+      else if (LPFhasKeyword(pos, "bound[s]"))
+        section = BOUNDS;
+      else if (LPFhasKeyword(pos, "bin[ary]"))
+        section = BINARIES;
+      else if (LPFhasKeyword(pos, "bin[aries]"))
+        section = BINARIES;
+      else if (LPFhasKeyword(pos, "gen[erals]"))
+        section = INTEGERS;
+      else if (LPFhasKeyword(pos, "int[egers]")) // this is undocumented
+        section = INTEGERS;
+      else if (LPFhasKeyword(pos, "end")) {
+        finished = true;
+        break;
+      } else if (LPFhasKeyword(pos, "s[ubject][   ]t[o]") // second time
+                 || LPFhasKeyword(pos, "s[uch][    ]t[hat]") ||
+                 LPFhasKeyword(pos, "s[.][    ]t[.]") ||
+                 LPFhasKeyword(pos, "lazy con[straints]")) {
+        // In principle this has to checked for all keywords above,
+        // otherwise we just ignore any half finished constraint
+        if (have_value)
+          goto syntax_error;
+
+        have_value = true;
+        val = 1.0;
+      }
+    }
+
+    // 3a. Look for row names in objective and drop it.
+    if (section == OBJECTIVE)
+      LPFhasRowName(pos, 0);
+
+    // 3b. Look for row name in constraint and store it.
+    if (section == CONSTRAINTS)
+      if (LPFhasRowName(pos, rnames))
+        unnamed = false;
+
+    // 4a. Remove initial spaces.
+    while (LPFisSpace(pos[i]))
+      i++;
+
+    // 4b. remove spaces if they do not appear before the name of a vaiable.
+    for (k = 0; pos[i] != '\0'; i++)
+      if (!LPFisSpace(pos[i]) || LPFisColName(&pos[i + 1]))
+        tmp[k++] = pos[i];
+
+    tmp[k] = '\0';
+
+    // 5. Is this an empty line ?
+    if (tmp[0] == '\0')
+      continue;
+
+    // 6. Collapse sequences of '+' and '-'. e.g ++---+ => -
+    for (i = 0, k = 0; tmp[i] != '\0'; i++) {
+      while (((tmp[i] == '+') || (tmp[i] == '-')) &&
+             ((tmp[i + 1] == '+') || (tmp[i + 1] == '-'))) {
+        if (tmp[i++] == '-')
+          tmp[i] = (tmp[i] == '-') ? '+' : '-';
+      }
+
+      line[k++] = tmp[i];
+    }
+
+    line[k] = '\0';
+
+    //-----------------------------------------------------------------------
+    //--- Line processing loop
+    //-----------------------------------------------------------------------
+    pos = line;
+
+    MSG_DEBUG(std::cout << "DLPFRD09 pos=" << pos << std::endl;)
+
+    // 7. We have something left to process.
+    while ((pos != 0) && (*pos != '\0')) {
+      // remember our position, so we are sure we make progress.
+      pos_old = pos;
+
+      // now process the sections
+      switch (section) {
+      case OBJECTIVE:
+        if (LPFisValue(pos)) {
+          R pre_sign = 1.0;
+
+          /* Already having here a value could only result from being the first
+           * number in a constraint, or a sign
+           * '+' or '-' as last token on the previous line.
+           */
+          if (have_value) {
+            if (NE(spxAbs(val), R(1.0)))
+              goto syntax_error;
+
+            if (EQ(val, R(-1.0)))
+              pre_sign = val;
+          }
+
+          /* non-finite coefficients are not allowed in the objective */
+          if (LPFisInfinity(pos))
+            goto syntax_error;
 
-      // 1. Remove comments.
-      if(0 != (s = strchr(buf, '\\')))
-         * s = '\0';
+          have_value = true;
+          val = LPFreadValue<R>(pos, spxout) * pre_sign;
+        }
+
+        if (*pos == '\0')
+          continue;
+
+        if (!have_value || !LPFisColName(pos))
+          goto syntax_error;
+
+        have_value = false;
+        colidx = LPFreadColName(pos, cnames, cset, &emptycol, spxout);
+        vec.add(colidx, val);
+        break;
+
+      case CONSTRAINTS:
+        if (LPFisValue(pos)) {
+          R pre_sign = 1.0;
+
+          /* Already having here a value could only result from being the first
+           * number in a constraint, or a sign
+           * '+' or '-' as last token on the previous line.
+           */
+          if (have_value) {
+            if (NE(spxAbs(val), R(1.0)))
+              goto syntax_error;
+
+            if (EQ(val, R(-1.0)))
+              pre_sign = val;
+          }
+
+          if (LPFisInfinity(pos)) {
+            /* non-finite coefficients are not allowed */
+            if (sense == 0)
+              goto syntax_error;
+
+            val = LPFreadInfinity<R>(pos) * pre_sign;
+          } else
+            val = LPFreadValue<R>(pos, spxout) * pre_sign;
+
+          have_value = true;
+
+          if (sense != 0) {
+            if (sense == '<') {
+              row.setLhs(R(-infinity));
+              row.setRhs(val);
+            } else if (sense == '>') {
+              row.setLhs(val);
+              row.setRhs(R(infinity));
+            } else {
+              assert(sense == '=');
+
+              row.setLhs(val);
+              row.setRhs(val);
+            }
 
-      // 2. Look for keywords.
-      if(section == START)
-      {
-         if(LPFhasKeyword(pos, "max[imize]"))
-         {
-            changeSense(SPxLPBase<R>::MAXIMIZE);
-            section = OBJECTIVE;
-         }
-         else if(LPFhasKeyword(pos, "min[imize]"))
-         {
-            changeSense(SPxLPBase<R>::MINIMIZE);
-            section = OBJECTIVE;
-         }
-      }
-      else if(section == OBJECTIVE)
-      {
-         if(LPFhasKeyword(pos, "s[ubject][   ]t[o]")
-               || LPFhasKeyword(pos, "s[uch][    ]t[hat]")
-               || LPFhasKeyword(pos, "s[.][    ]t[.]")
-               || LPFhasKeyword(pos, "lazy con[straints]"))
-         {
-            // store objective vector
-            for(int j = vec.size() - 1; j >= 0; --j)
-               cset.maxObj_w(vec.index(j)) = vec.value(j);
-
-            // multiplication with -1 for minimization is done below
+            row.setRowVector(vec);
+            rset.add(row);
             vec.clear();
-            have_value = true;
-            val = 1.0;
-            section = CONSTRAINTS;
-         }
-      }
-      else if(section == CONSTRAINTS &&
-              (LPFhasKeyword(pos, "s[ubject][   ]t[o]")
-               || LPFhasKeyword(pos, "s[uch][    ]t[hat]")
-               || LPFhasKeyword(pos, "s[.][    ]t[.]")))
-      {
-         have_value = true;
-         val = 1.0;
-      }
-      else
-      {
-         if(LPFhasKeyword(pos, "lazy con[straints]"))
-            ;
-         else if(LPFhasKeyword(pos, "bound[s]"))
-            section = BOUNDS;
-         else if(LPFhasKeyword(pos, "bin[ary]"))
-            section = BINARIES;
-         else if(LPFhasKeyword(pos, "bin[aries]"))
-            section = BINARIES;
-         else if(LPFhasKeyword(pos, "gen[erals]"))
-            section = INTEGERS;
-         else if(LPFhasKeyword(pos, "int[egers]"))   // this is undocumented
-            section = INTEGERS;
-         else if(LPFhasKeyword(pos, "end"))
-         {
-            finished = true;
-            break;
-         }
-         else if(LPFhasKeyword(pos, "s[ubject][   ]t[o]")  // second time
-                 || LPFhasKeyword(pos, "s[uch][    ]t[hat]")
-                 || LPFhasKeyword(pos, "s[.][    ]t[.]")
-                 || LPFhasKeyword(pos, "lazy con[straints]"))
-         {
-            // In principle this has to checked for all keywords above,
-            // otherwise we just ignore any half finished constraint
-            if(have_value)
-               goto syntax_error;
+
+            if (!unnamed)
+              unnamed = true;
+            else {
+              char name[16];
+              spxSnprintf(name, 16, "C%d", rset.num());
+              rnames->add(name);
+            }
 
             have_value = true;
             val = 1.0;
-         }
-      }
-
-      // 3a. Look for row names in objective and drop it.
-      if(section == OBJECTIVE)
-         LPFhasRowName(pos, 0);
-
-      // 3b. Look for row name in constraint and store it.
-      if(section == CONSTRAINTS)
-         if(LPFhasRowName(pos, rnames))
-            unnamed = false;
-
-      // 4a. Remove initial spaces.
-      while(LPFisSpace(pos[i]))
-         i++;
-
-      // 4b. remove spaces if they do not appear before the name of a vaiable.
-      for(k = 0; pos[i] != '\0'; i++)
-         if(!LPFisSpace(pos[i]) || LPFisColName(&pos[i + 1]))
-            tmp[k++] = pos[i];
+            sense = 0;
+            pos = 0;
+            // next line
+            continue;
+          }
+        }
 
-      tmp[k] = '\0';
+        if (*pos == '\0')
+          continue;
 
-      // 5. Is this an empty line ?
-      if(tmp[0] == '\0')
-         continue;
+        if (have_value) {
+          if (LPFisColName(pos)) {
+            colidx = LPFreadColName(pos, cnames, cset, &emptycol, spxout);
 
-      // 6. Collapse sequences of '+' and '-'. e.g ++---+ => -
-      for(i = 0, k = 0; tmp[i] != '\0'; i++)
-      {
-         while(((tmp[i] == '+') || (tmp[i] == '-')) && ((tmp[i + 1] == '+') || (tmp[i + 1] == '-')))
-         {
-            if(tmp[i++] == '-')
-               tmp[i] = (tmp[i] == '-') ? '+' : '-';
-         }
+            if (val != 0.0) {
+              // Do we have this index already in the row?
+              int n = vec.pos(colidx);
 
-         line[k++] = tmp[i];
-      }
+              // if not, add it
+              if (n < 0)
+                vec.add(colidx, val);
+              // if yes, add them up and remove the element if it amounts to
+              // zero
+              else {
+                assert(vec.index(n) == colidx);
 
-      line[k] = '\0';
+                val += vec.value(n);
 
-      //-----------------------------------------------------------------------
-      //--- Line processing loop
-      //-----------------------------------------------------------------------
-      pos = line;
+                if (val == 0.0)
+                  vec.remove(n);
+                else
+                  vec.value(n) = val;
 
-      MSG_DEBUG(std::cout << "DLPFRD09 pos=" << pos << std::endl;)
+                assert(cnames->has(colidx));
 
-      // 7. We have something left to process.
-      while((pos != 0) && (*pos != '\0'))
-      {
-         // remember our position, so we are sure we make progress.
-         pos_old = pos;
-
-         // now process the sections
-         switch(section)
-         {
-         case OBJECTIVE:
-            if(LPFisValue(pos))
-            {
-               R pre_sign = 1.0;
-
-               /* Already having here a value could only result from being the first number in a constraint, or a sign
-                * '+' or '-' as last token on the previous line.
-                */
-               if(have_value)
-               {
-                  if(NE(spxAbs(val), R(1.0)))
-                     goto syntax_error;
-
-                  if(EQ(val, R(-1.0)))
-                     pre_sign = val;
-               }
-
-               /* non-finite coefficients are not allowed in the objective */
-               if(LPFisInfinity(pos))
-                  goto syntax_error;
-
-               have_value = true;
-               val = LPFreadValue<R>(pos, spxout) * pre_sign;
+                MSG_WARNING((*this->spxout),
+                            (*this->spxout) << "WLPFRD10 Duplicate index "
+                                            << (*cnames)[colidx] << " in line "
+                                            << lineno << std::endl;)
+              }
             }
 
-            if(*pos == '\0')
-               continue;
-
-            if(!have_value || !LPFisColName(pos))
-               goto syntax_error;
-
             have_value = false;
-            colidx = LPFreadColName(pos, cnames, cset, &emptycol, spxout);
-            vec.add(colidx, val);
-            break;
-
-         case CONSTRAINTS:
-            if(LPFisValue(pos))
-            {
-               R pre_sign = 1.0;
-
-               /* Already having here a value could only result from being the first number in a constraint, or a sign
-                * '+' or '-' as last token on the previous line.
-                */
-               if(have_value)
-               {
-                  if(NE(spxAbs(val), R(1.0)))
-                     goto syntax_error;
-
-                  if(EQ(val, R(-1.0)))
-                     pre_sign = val;
-               }
-
-               if(LPFisInfinity(pos))
-               {
-                  /* non-finite coefficients are not allowed */
-                  if(sense == 0)
-                     goto syntax_error;
-
-                  val = LPFreadInfinity<R>(pos) * pre_sign;
-               }
-               else
-                  val = LPFreadValue<R>(pos, spxout) * pre_sign;
-
-               have_value = true;
-
-               if(sense != 0)
-               {
-                  if(sense == '<')
-                  {
-                     row.setLhs(R(-infinity));
-                     row.setRhs(val);
-                  }
-                  else if(sense == '>')
-                  {
-                     row.setLhs(val);
-                     row.setRhs(R(infinity));
-                  }
-                  else
-                  {
-                     assert(sense == '=');
-
-                     row.setLhs(val);
-                     row.setRhs(val);
-                  }
-
-                  row.setRowVector(vec);
-                  rset.add(row);
-                  vec.clear();
-
-                  if(!unnamed)
-                     unnamed = true;
-                  else
-                  {
-                     char name[16];
-                     spxSnprintf(name, 16, "C%d", rset.num());
-                     rnames->add(name);
-                  }
-
-                  have_value = true;
-                  val = 1.0;
-                  sense = 0;
-                  pos = 0;
-                  // next line
-                  continue;
-               }
-            }
-
-            if(*pos == '\0')
-               continue;
-
-            if(have_value)
-            {
-               if(LPFisColName(pos))
-               {
-                  colidx = LPFreadColName(pos, cnames, cset, &emptycol, spxout);
-
-                  if(val != 0.0)
-                  {
-                     // Do we have this index already in the row?
-                     int n = vec.pos(colidx);
-
-                     // if not, add it
-                     if(n < 0)
-                        vec.add(colidx, val);
-                     // if yes, add them up and remove the element if it amounts to zero
-                     else
-                     {
-                        assert(vec.index(n) == colidx);
-
-                        val += vec.value(n);
-
-                        if(val == 0.0)
-                           vec.remove(n);
-                        else
-                           vec.value(n) = val;
-
-                        assert(cnames->has(colidx));
-
-                        MSG_WARNING((*this->spxout), (*this->spxout) << "WLPFRD10 Duplicate index "
-                                    << (*cnames)[colidx]
-                                    << " in line " << lineno
-                                    << std::endl;)
-                     }
-                  }
-
-                  have_value = false;
-               }
-               else
-               {
-                  // We have a row like c1: <= 5 with no variables. We can not handle 10 <= 5; issue a syntax error.
-                  if(val != 1.0)
-                     goto syntax_error;
-
-                  // If the next thing is not the sense we give up also.
-                  if(!LPFisSense(pos))
-                     goto syntax_error;
-
-                  have_value = false;
-               }
-            }
-
-            assert(!have_value);
+          } else {
+            // We have a row like c1: <= 5 with no variables. We can not handle
+            // 10 <= 5; issue a syntax error.
+            if (val != 1.0)
+              goto syntax_error;
 
-            if(LPFisSense(pos))
-               sense = LPFreadSense(pos);
+            // If the next thing is not the sense we give up also.
+            if (!LPFisSense(pos))
+              goto syntax_error;
 
-            break;
+            have_value = false;
+          }
+        }
 
-         case BOUNDS:
-            other = false;
-            sense = 0;
+        assert(!have_value);
 
-            if(LPFisValue(pos))
-            {
-               val = LPFisInfinity(pos) ? LPFreadInfinity<R>(pos) : LPFreadValue<R>(pos, spxout);
+        if (LPFisSense(pos))
+          sense = LPFreadSense(pos);
 
-               if(!LPFisSense(pos))
-                  goto syntax_error;
+        break;
 
-               sense = LPFreadSense(pos);
-               other = true;
-            }
+      case BOUNDS:
+        other = false;
+        sense = 0;
 
-            if(!LPFisColName(pos))
-               goto syntax_error;
+        if (LPFisValue(pos)) {
+          val = LPFisInfinity(pos) ? LPFreadInfinity<R>(pos)
+                                   : LPFreadValue<R>(pos, spxout);
 
-            if((colidx = LPFreadColName<R>(pos, cnames, cset, nullptr, spxout)) < 0)
-            {
-               MSG_WARNING((*this->spxout), (*this->spxout) << "WLPFRD11 in Bounds section line "
-                           << lineno << " ignored" << std::endl;)
-               *pos = '\0';
-               continue;
-            }
+          if (!LPFisSense(pos))
+            goto syntax_error;
 
-            if(sense)
-            {
-               if(sense == '<')
-                  cset.lower_w(colidx) = val;
-               else if(sense == '>')
-                  cset.upper_w(colidx) = val;
-               else
-               {
-                  assert(sense == '=');
-                  cset.lower_w(colidx) = val;
-                  cset.upper_w(colidx) = val;
-               }
-            }
+          sense = LPFreadSense(pos);
+          other = true;
+        }
+
+        if (!LPFisColName(pos))
+          goto syntax_error;
+
+        if ((colidx = LPFreadColName<R>(pos, cnames, cset, nullptr, spxout)) <
+            0) {
+          MSG_WARNING((*this->spxout),
+                      (*this->spxout) << "WLPFRD11 in Bounds section line "
+                                      << lineno << " ignored" << std::endl;)
+          *pos = '\0';
+          continue;
+        }
+
+        if (sense) {
+          if (sense == '<')
+            cset.lower_w(colidx) = val;
+          else if (sense == '>')
+            cset.upper_w(colidx) = val;
+          else {
+            assert(sense == '=');
+            cset.lower_w(colidx) = val;
+            cset.upper_w(colidx) = val;
+          }
+        }
+
+        if (LPFisFree(pos)) {
+          cset.lower_w(colidx) = R(-infinity);
+          cset.upper_w(colidx) = R(infinity);
+          other = true;
+          pos += 4; // set position after the word "free"
+        } else if (LPFisSense(pos)) {
+          sense = LPFreadSense(pos);
+          other = true;
+
+          if (!LPFisValue(pos))
+            goto syntax_error;
 
-            if(LPFisFree(pos))
-            {
-               cset.lower_w(colidx) = R(-infinity);
-               cset.upper_w(colidx) =  R(infinity);
-               other = true;
-               pos += 4;  // set position after the word "free"
-            }
-            else if(LPFisSense(pos))
-            {
-               sense = LPFreadSense(pos);
-               other = true;
-
-               if(!LPFisValue(pos))
-                  goto syntax_error;
-
-               val = LPFisInfinity(pos) ? LPFreadInfinity<R>(pos) : LPFreadValue<R>(pos, spxout);
-
-               if(sense == '<')
-                  cset.upper_w(colidx) = val;
-               else if(sense == '>')
-                  cset.lower_w(colidx) = val;
-               else
-               {
-                  assert(sense == '=');
-                  cset.lower_w(colidx) = val;
-                  cset.upper_w(colidx) = val;
-               }
+          val = LPFisInfinity(pos) ? LPFreadInfinity<R>(pos)
+                                   : LPFreadValue<R>(pos, spxout);
+
+          if (sense == '<')
+            cset.upper_w(colidx) = val;
+          else if (sense == '>')
+            cset.lower_w(colidx) = val;
+          else {
+            assert(sense == '=');
+            cset.lower_w(colidx) = val;
+            cset.upper_w(colidx) = val;
+          }
+        }
+
+        /* Do we have only a single column name in the input line?  We could
+         * ignore this savely, but it is probably a sign of some other error.
+         */
+        if (!other)
+          goto syntax_error;
+
+        break;
+
+      case BINARIES:
+      case INTEGERS:
+        if ((colidx = LPFreadColName<R>(pos, cnames, cset, 0, spxout)) < 0) {
+          MSG_WARNING((*this->spxout),
+                      (*this->spxout)
+                          << "WLPFRD12 in Binary/General section line "
+                          << lineno << " ignored" << std::endl;)
+        } else {
+          if (section == BINARIES) {
+            if (cset.lower(colidx) < 0.0) {
+              cset.lower_w(colidx) = 0.0;
             }
 
-            /* Do we have only a single column name in the input line?  We could ignore this savely, but it is probably
-             * a sign of some other error.
-             */
-            if(!other)
-               goto syntax_error;
-
-            break;
-
-         case BINARIES:
-         case INTEGERS:
-            if((colidx = LPFreadColName<R>(pos, cnames, cset, 0, spxout)) < 0)
-            {
-               MSG_WARNING((*this->spxout), (*this->spxout) << "WLPFRD12 in Binary/General section line " << lineno
-                           << " ignored" << std::endl;)
-            }
-            else
-            {
-               if(section == BINARIES)
-               {
-                  if(cset.lower(colidx) < 0.0)
-                  {
-                     cset.lower_w(colidx) = 0.0;
-                  }
-
-                  if(cset.upper(colidx) > 1.0)
-                  {
-                     cset.upper_w(colidx) = 1.0;
-                  }
-               }
-
-               if(p_intvars != 0)
-                  p_intvars->addIdx(colidx);
+            if (cset.upper(colidx) > 1.0) {
+              cset.upper_w(colidx) = 1.0;
             }
+          }
 
-            break;
+          if (p_intvars != 0)
+            p_intvars->addIdx(colidx);
+        }
 
-         case START:
-            MSG_ERROR(std::cerr << "ELPFRD13 This seems to be no LP format file" << std::endl;)
-            goto syntax_error;
+        break;
 
-         default:
-            throw SPxInternalCodeException("XLPFRD01 This should never happen.");
-         }
+      case START:
+        MSG_ERROR(std::cerr << "ELPFRD13 This seems to be no LP format file"
+                            << std::endl;)
+        goto syntax_error;
 
-         if(pos == pos_old)
-            goto syntax_error;
+      default:
+        throw SPxInternalCodeException("XLPFRD01 This should never happen.");
       }
-   }
 
-   assert(isConsistent());
+      if (pos == pos_old)
+        goto syntax_error;
+    }
+  }
+
+  assert(isConsistent());
 
-   addCols(cset);
-   assert(isConsistent());
+  addCols(cset);
+  assert(isConsistent());
 
-   addRows(rset);
-   assert(isConsistent());
+  addRows(rset);
+  assert(isConsistent());
 
 syntax_error:
 
-   if(finished)
-   {
-      MSG_INFO2((*this->spxout), (*this->spxout) << "Finished reading " << lineno << " lines" <<
-                std::endl;)
-   }
-   else
-      MSG_ERROR(std::cerr << "ELPFRD15 Syntax error in line " << lineno << std::endl;)
+  if (finished) {
+    MSG_INFO2((*this->spxout), (*this->spxout) << "Finished reading " << lineno
+                                               << " lines" << std::endl;)
+  } else
+    MSG_ERROR(std::cerr << "ELPFRD15 Syntax error in line " << lineno
+                        << std::endl;)
 
-      if(p_cnames == 0)
-         spx_free(cnames);
+  if (p_cnames == 0)
+    spx_free(cnames);
 
-   if(p_rnames == 0)
-      spx_free(rnames);
+  if (p_rnames == 0)
+    spx_free(rnames);
 
-   return finished;
+  return finished;
 }
 
-
-
 // ---------------------------------------------------------------------------------------------------------------------
 // Specialization for reading MPS format
 // ---------------------------------------------------------------------------------------------------------------------
 
 /// Process NAME section.
-static inline void MPSreadName(MPSInput& mps, SPxOut* spxout)
-{
-   do
-   {
-      // This has to be the Line with the NAME section.
-      if(!mps.readLine() || (mps.field0() == 0) || strcmp(mps.field0(), "NAME"))
-         break;
-
-      // Sometimes the name is omitted.
-      mps.setProbName((mps.field1() == 0) ? "_MPS_" : mps.field1());
-
-      MSG_INFO2((*spxout), (*spxout) << "IMPSRD01 Problem name   : " << mps.probName() << std::endl;)
-
-      // This has to be a new section
-      if(!mps.readLine() || (mps.field0() == 0))
-         break;
-
-      if(!strcmp(mps.field0(), "ROWS"))
-         mps.setSection(MPSInput::ROWS);
-      else if(!strncmp(mps.field0(), "OBJSEN", 6))
-         mps.setSection(MPSInput::OBJSEN);
-      else if(!strcmp(mps.field0(), "OBJNAME"))
-         mps.setSection(MPSInput::OBJNAME);
-      else
-         break;
+static inline void MPSreadName(MPSInput &mps, SPxOut *spxout) {
+  do {
+    // This has to be the Line with the NAME section.
+    if (!mps.readLine() || (mps.field0() == 0) || strcmp(mps.field0(), "NAME"))
+      break;
 
-      return;
-   }
-   while(false);
+    // Sometimes the name is omitted.
+    mps.setProbName((mps.field1() == 0) ? "_MPS_" : mps.field1());
 
-   mps.syntaxError();
-}
+    MSG_INFO2((*spxout), (*spxout) << "IMPSRD01 Problem name   : "
+                                   << mps.probName() << std::endl;)
 
+    // This has to be a new section
+    if (!mps.readLine() || (mps.field0() == 0))
+      break;
 
+    if (!strcmp(mps.field0(), "ROWS"))
+      mps.setSection(MPSInput::ROWS);
+    else if (!strncmp(mps.field0(), "OBJSEN", 6))
+      mps.setSection(MPSInput::OBJSEN);
+    else if (!strcmp(mps.field0(), "OBJNAME"))
+      mps.setSection(MPSInput::OBJNAME);
+    else
+      break;
 
-/// Process OBJSEN section. This Section is an ILOG extension.
-static inline void MPSreadObjsen(MPSInput& mps)
-{
-   do
-   {
-      // This has to be the Line with MIN or MAX.
-      if(!mps.readLine() || (mps.field1() == 0))
-         break;
-
-      if(!strcmp(mps.field1(), "MIN"))
-         mps.setObjSense(MPSInput::MINIMIZE);
-      else if(!strcmp(mps.field1(), "MAX"))
-         mps.setObjSense(MPSInput::MAXIMIZE);
-      else
-         break;
+    return;
+  } while (false);
 
-      // Look for ROWS or OBJNAME Section
-      if(!mps.readLine() || (mps.field0() == 0))
-         break;
+  mps.syntaxError();
+}
 
-      if(!strcmp(mps.field0(), "ROWS"))
-         mps.setSection(MPSInput::ROWS);
-      else if(!strcmp(mps.field0(), "OBJNAME"))
-         mps.setSection(MPSInput::OBJNAME);
-      else
-         break;
+/// Process OBJSEN section. This Section is an ILOG extension.
+static inline void MPSreadObjsen(MPSInput &mps) {
+  do {
+    // This has to be the Line with MIN or MAX.
+    if (!mps.readLine() || (mps.field1() == 0))
+      break;
+
+    if (!strcmp(mps.field1(), "MIN"))
+      mps.setObjSense(MPSInput::MINIMIZE);
+    else if (!strcmp(mps.field1(), "MAX"))
+      mps.setObjSense(MPSInput::MAXIMIZE);
+    else
+      break;
+
+    // Look for ROWS or OBJNAME Section
+    if (!mps.readLine() || (mps.field0() == 0))
+      break;
+
+    if (!strcmp(mps.field0(), "ROWS"))
+      mps.setSection(MPSInput::ROWS);
+    else if (!strcmp(mps.field0(), "OBJNAME"))
+      mps.setSection(MPSInput::OBJNAME);
+    else
+      break;
 
-      return;
-   }
-   while(false);
+    return;
+  } while (false);
 
-   mps.syntaxError();
+  mps.syntaxError();
 }
 
-
-
 /// Process OBJNAME section. This Section is an ILOG extension.
-static inline void MPSreadObjname(MPSInput& mps)
-{
-   do
-   {
-      // This has to be the Line with the name.
-      if(!mps.readLine() || (mps.field1() == 0))
-         break;
+static inline void MPSreadObjname(MPSInput &mps) {
+  do {
+    // This has to be the Line with the name.
+    if (!mps.readLine() || (mps.field1() == 0))
+      break;
 
-      mps.setObjName(mps.field1());
+    mps.setObjName(mps.field1());
 
-      // Look for ROWS Section
-      if(!mps.readLine() || (mps.field0() == 0))
-         break;
+    // Look for ROWS Section
+    if (!mps.readLine() || (mps.field0() == 0))
+      break;
 
-      if(strcmp(mps.field0(), "ROWS"))
-         break;
+    if (strcmp(mps.field0(), "ROWS"))
+      break;
 
-      mps.setSection(MPSInput::ROWS);
+    mps.setSection(MPSInput::ROWS);
 
-      return;
-   }
-   while(false);
+    return;
+  } while (false);
 
-   mps.syntaxError();
+  mps.syntaxError();
 }
 
-
-
 /// Process ROWS section.
 template <class R>
-static void MPSreadRows(MPSInput& mps, LPRowSetBase<R>& rset, NameSet& rnames, SPxOut* spxout)
-{
-   LPRowBase<R> row;
+static void MPSreadRows(MPSInput &mps, LPRowSetBase<R> &rset, NameSet &rnames,
+                        SPxOut *spxout) {
+  LPRowBase<R> row;
 
-   while(mps.readLine())
-   {
-      if(mps.field0() != 0)
-      {
-         MSG_INFO2((*spxout), (*spxout) << "IMPSRD02 Objective name : " << mps.objName() << std::endl;)
+  while (mps.readLine()) {
+    if (mps.field0() != 0) {
+      MSG_INFO2((*spxout), (*spxout) << "IMPSRD02 Objective name : "
+                                     << mps.objName() << std::endl;)
 
-         if(strcmp(mps.field0(), "COLUMNS"))
-            break;
+      if (strcmp(mps.field0(), "COLUMNS"))
+        break;
 
-         mps.setSection(MPSInput::COLUMNS);
+      mps.setSection(MPSInput::COLUMNS);
 
-         return;
-      }
+      return;
+    }
 
-      if((mps.field1() == 0) || (mps.field2() == 0))
-         break;
+    if ((mps.field1() == 0) || (mps.field2() == 0))
+      break;
 
-      if(*mps.field1() == 'N')
-      {
-         if(*mps.objName() == '\0')
-            mps.setObjName(mps.field2());
-      }
-      else
-      {
-         if(rnames.has(mps.field2()))
-            break;
-
-         rnames.add(mps.field2());
-
-         switch(*mps.field1())
-         {
-         case 'G':
-            row.setLhs(0.0);
-            row.setRhs(R(infinity));
-            break;
-
-         case 'E':
-            row.setLhs(0.0);
-            row.setRhs(0.0);
-            break;
-
-         case 'L':
-            row.setLhs(R(-infinity));
-            row.setRhs(0.0);
-            break;
-
-         default:
-            mps.syntaxError();
-            return;
-         }
-
-         rset.add(row);
-      }
+    if (*mps.field1() == 'N') {
+      if (*mps.objName() == '\0')
+        mps.setObjName(mps.field2());
+    } else {
+      if (rnames.has(mps.field2()))
+        break;
 
-      assert((*mps.field1() == 'N') || (rnames.number(mps.field2()) == rset.num() - 1));
-   }
+      rnames.add(mps.field2());
 
-   mps.syntaxError();
-}
+      switch (*mps.field1()) {
+      case 'G':
+        row.setLhs(0.0);
+        row.setRhs(R(infinity));
+        break;
 
+      case 'E':
+        row.setLhs(0.0);
+        row.setRhs(0.0);
+        break;
+
+      case 'L':
+        row.setLhs(R(-infinity));
+        row.setRhs(0.0);
+        break;
+
+      default:
+        mps.syntaxError();
+        return;
+      }
 
+      rset.add(row);
+    }
+
+    assert((*mps.field1() == 'N') ||
+           (rnames.number(mps.field2()) == rset.num() - 1));
+  }
+
+  mps.syntaxError();
+}
 
 /// Process COLUMNS section.
 template <class R>
-static void MPSreadCols(MPSInput& mps, const LPRowSetBase<R>& rset, const NameSet&  rnames,
-                        LPColSetBase<R>& cset, NameSet& cnames, DIdxSet* intvars)
-{
-   R val;
-   int idx;
-   char colname[MPSInput::MAX_LINE_LEN] = { '\0' };
-   LPColBase<R> col(rset.num());
-   DSVectorBase<R> vec;
-
-   col.setObj(0.0);
-   vec.clear();
-
-   while(mps.readLine())
-   {
-      if(mps.field0() != 0)
-      {
-         if(strcmp(mps.field0(), "RHS"))
-            break;
+static void MPSreadCols(MPSInput &mps, const LPRowSetBase<R> &rset,
+                        const NameSet &rnames, LPColSetBase<R> &cset,
+                        NameSet &cnames, DIdxSet *intvars) {
+  R val;
+  int idx;
+  char colname[MPSInput::MAX_LINE_LEN] = {'\0'};
+  LPColBase<R> col(rset.num());
+  DSVectorBase<R> vec;
 
-         if(colname[0] != '\0')
-         {
-            col.setColVector(vec);
-            cset.add(col);
-         }
+  col.setObj(0.0);
+  vec.clear();
 
-         mps.setSection(MPSInput::RHS);
+  while (mps.readLine()) {
+    if (mps.field0() != 0) {
+      if (strcmp(mps.field0(), "RHS"))
+        break;
 
-         return;
+      if (colname[0] != '\0') {
+        col.setColVector(vec);
+        cset.add(col);
       }
 
-      if((mps.field1() == 0) || (mps.field2() == 0) || (mps.field3() == 0))
-         break;
+      mps.setSection(MPSInput::RHS);
 
-      // new column?
-      if(strcmp(colname, mps.field1()))
-      {
-         // first column?
-         if(colname[0] != '\0')
-         {
-            col.setColVector(vec);
-            cset.add(col);
-         }
-
-         // save copy of string (make sure string ends with \0)
-         spxSnprintf(colname, MPSInput::MAX_LINE_LEN - 1, "%s", mps.field1());
-         colname[MPSInput::MAX_LINE_LEN - 1] = '\0';
-
-         int ncnames = cnames.size();
-         cnames.add(colname);
-
-         // check whether the new name is unique wrt previous column names
-         if(cnames.size() <= ncnames)
-         {
-            MSG_ERROR(std::cerr << "ERROR in COLUMNS: duplicate column name or not column-wise ordering" <<
-                      std::endl;)
-            break;
-         }
-
-         vec.clear();
-         col.setObj(0.0);
-         col.setLower(0.0);
-         col.setUpper(R(infinity));
-
-         if(mps.isInteger())
-         {
-            assert(cnames.number(colname) == cset.num());
-
-            if(intvars != 0)
-               intvars->addIdx(cnames.number(colname));
-
-            // for Integer variable the default bounds are 0/1
-            col.setUpper(1.0);
-         }
-      }
+      return;
+    }
 
-      val = atof(mps.field3());
+    if ((mps.field1() == 0) || (mps.field2() == 0) || (mps.field3() == 0))
+      break;
 
-      if(!strcmp(mps.field2(), mps.objName()))
-         col.setObj(val);
-      else
-      {
-         if((idx = rnames.number(mps.field2())) < 0)
-            mps.entryIgnored("Column", mps.field1(), "row", mps.field2());
-         else if(val != 0.0)
-            vec.add(idx, val);
+    // new column?
+    if (strcmp(colname, mps.field1())) {
+      // first column?
+      if (colname[0] != '\0') {
+        col.setColVector(vec);
+        cset.add(col);
       }
 
-      if(mps.field5() != 0)
-      {
-         assert(mps.field4() != 0);
-
-         val = atof(mps.field5());
-
-         if(!strcmp(mps.field4(), mps.objName()))
-            col.setObj(val);
-         else
-         {
-            if((idx = rnames.number(mps.field4())) < 0)
-               mps.entryIgnored("Column", mps.field1(), "row", mps.field4());
-            else if(val != 0.0)
-               vec.add(idx, val);
-         }
+      // save copy of string (make sure string ends with \0)
+      spxSnprintf(colname, MPSInput::MAX_LINE_LEN - 1, "%s", mps.field1());
+      colname[MPSInput::MAX_LINE_LEN - 1] = '\0';
+
+      int ncnames = cnames.size();
+      cnames.add(colname);
+
+      // check whether the new name is unique wrt previous column names
+      if (cnames.size() <= ncnames) {
+        MSG_ERROR(std::cerr << "ERROR in COLUMNS: duplicate column name or not "
+                               "column-wise ordering"
+                            << std::endl;)
+        break;
       }
-   }
 
-   mps.syntaxError();
-}
+      vec.clear();
+      col.setObj(0.0);
+      col.setLower(0.0);
+      col.setUpper(R(infinity));
 
+      if (mps.isInteger()) {
+        assert(cnames.number(colname) == cset.num());
 
+        if (intvars != 0)
+          intvars->addIdx(cnames.number(colname));
 
-/// Process RHS section.
-template <class R>
-static void MPSreadRhs(MPSInput& mps, LPRowSetBase<R>& rset, const NameSet& rnames, SPxOut* spxout)
-{
-   char rhsname[MPSInput::MAX_LINE_LEN] = { '\0' };
-   char addname[MPSInput::MAX_LINE_LEN] = { '\0' };
-   int idx;
-   R val;
-
-   while(mps.readLine())
-   {
-      if(mps.field0() != 0)
-      {
-         MSG_INFO2((*spxout), (*spxout) << "IMPSRD03 RHS name       : " << rhsname  << std::endl;);
-
-         if(!strcmp(mps.field0(), "RANGES"))
-            mps.setSection(MPSInput::RANGES);
-         else if(!strcmp(mps.field0(), "BOUNDS"))
-            mps.setSection(MPSInput::BOUNDS);
-         else if(!strcmp(mps.field0(), "ENDATA"))
-            mps.setSection(MPSInput::ENDATA);
-         else
-            break;
-
-         return;
+        // for Integer variable the default bounds are 0/1
+        col.setUpper(1.0);
       }
+    }
 
-      if(((mps.field2() != 0) && (mps.field3() == 0)) || ((mps.field4() != 0) && (mps.field5() == 0)))
-         mps.insertName("_RHS_");
-
-      if((mps.field1() == 0) || (mps.field2() == 0) || (mps.field3() == 0))
-         break;
+    val = atof(mps.field3());
 
-      if(*rhsname == '\0')
-         spxSnprintf(rhsname, MPSInput::MAX_LINE_LEN, "%s", mps.field1());
+    if (!strcmp(mps.field2(), mps.objName()))
+      col.setObj(val);
+    else {
+      if ((idx = rnames.number(mps.field2())) < 0)
+        mps.entryIgnored("Column", mps.field1(), "row", mps.field2());
+      else if (val != 0.0)
+        vec.add(idx, val);
+    }
 
-      if(strcmp(rhsname, mps.field1()))
-      {
-         if(strcmp(addname, mps.field1()))
-         {
-            assert(strlen(mps.field1()) < MPSInput::MAX_LINE_LEN);
-            spxSnprintf(addname, MPSInput::MAX_LINE_LEN, "%s", mps.field1());
-            MSG_INFO3((*spxout), (*spxout) << "IMPSRD07 RHS ignored    : " << addname << std::endl);
-         }
-      }
-      else
-      {
-         if((idx = rnames.number(mps.field2())) < 0)
-            mps.entryIgnored("RHS", mps.field1(), "row", mps.field2());
-         else
-         {
-            val = atof(mps.field3());
-
-            // LE or EQ
-            if(rset.rhs(idx) < R(infinity))
-               rset.rhs_w(idx) = val;
-
-            // GE or EQ
-            if(rset.lhs(idx) > R(-infinity))
-               rset.lhs_w(idx) = val;
-         }
-
-         if(mps.field5() != 0)
-         {
-            if((idx = rnames.number(mps.field4())) < 0)
-               mps.entryIgnored("RHS", mps.field1(), "row", mps.field4());
-            else
-            {
-               val = atof(mps.field5());
+    if (mps.field5() != 0) {
+      assert(mps.field4() != 0);
 
-               // LE or EQ
-               if(rset.rhs(idx) < R(infinity))
-                  rset.rhs_w(idx) = val;
+      val = atof(mps.field5());
 
-               // GE or EQ
-               if(rset.lhs(idx) > R(-infinity))
-                  rset.lhs_w(idx) = val;
-            }
-         }
+      if (!strcmp(mps.field4(), mps.objName()))
+        col.setObj(val);
+      else {
+        if ((idx = rnames.number(mps.field4())) < 0)
+          mps.entryIgnored("Column", mps.field1(), "row", mps.field4());
+        else if (val != 0.0)
+          vec.add(idx, val);
       }
-   }
+    }
+  }
 
-   mps.syntaxError();
+  mps.syntaxError();
 }
 
+/// Process RHS section.
+template <class R>
+static void MPSreadRhs(MPSInput &mps, LPRowSetBase<R> &rset,
+                       const NameSet &rnames, SPxOut *spxout) {
+  char rhsname[MPSInput::MAX_LINE_LEN] = {'\0'};
+  char addname[MPSInput::MAX_LINE_LEN] = {'\0'};
+  int idx;
+  R val;
+
+  while (mps.readLine()) {
+    if (mps.field0() != 0) {
+      MSG_INFO2((*spxout), (*spxout) << "IMPSRD03 RHS name       : " << rhsname
+                                     << std::endl;);
+
+      if (!strcmp(mps.field0(), "RANGES"))
+        mps.setSection(MPSInput::RANGES);
+      else if (!strcmp(mps.field0(), "BOUNDS"))
+        mps.setSection(MPSInput::BOUNDS);
+      else if (!strcmp(mps.field0(), "ENDATA"))
+        mps.setSection(MPSInput::ENDATA);
+      else
+        break;
 
+      return;
+    }
 
-/// Process RANGES section.
-template <class R>
-static void MPSreadRanges(MPSInput& mps,  LPRowSetBase<R>& rset, const NameSet& rnames,
-                          SPxOut* spxout)
-{
-   char rngname[MPSInput::MAX_LINE_LEN] = { '\0' };
-   int idx;
-   R val;
+    if (((mps.field2() != 0) && (mps.field3() == 0)) ||
+        ((mps.field4() != 0) && (mps.field5() == 0)))
+      mps.insertName("_RHS_");
 
-   while(mps.readLine())
-   {
-      if(mps.field0() != 0)
-      {
-         MSG_INFO2((*spxout), (*spxout) << "IMPSRD04 Range name     : " << rngname << std::endl;);
+    if ((mps.field1() == 0) || (mps.field2() == 0) || (mps.field3() == 0))
+      break;
 
-         if(!strcmp(mps.field0(), "BOUNDS"))
-            mps.setSection(MPSInput::BOUNDS);
-         else if(!strcmp(mps.field0(), "ENDATA"))
-            mps.setSection(MPSInput::ENDATA);
-         else
-            break;
+    if (*rhsname == '\0')
+      spxSnprintf(rhsname, MPSInput::MAX_LINE_LEN, "%s", mps.field1());
 
-         return;
+    if (strcmp(rhsname, mps.field1())) {
+      if (strcmp(addname, mps.field1())) {
+        assert(strlen(mps.field1()) < MPSInput::MAX_LINE_LEN);
+        spxSnprintf(addname, MPSInput::MAX_LINE_LEN, "%s", mps.field1());
+        MSG_INFO3((*spxout), (*spxout) << "IMPSRD07 RHS ignored    : "
+                                       << addname << std::endl);
       }
+    } else {
+      if ((idx = rnames.number(mps.field2())) < 0)
+        mps.entryIgnored("RHS", mps.field1(), "row", mps.field2());
+      else {
+        val = atof(mps.field3());
 
-      if(((mps.field2() != 0) && (mps.field3() == 0)) || ((mps.field4() != 0) && (mps.field5() == 0)))
-         mps.insertName("_RNG_");
+        // LE or EQ
+        if (rset.rhs(idx) < R(infinity))
+          rset.rhs_w(idx) = val;
 
-      if((mps.field1() == 0) || (mps.field2() == 0) || (mps.field3() == 0))
-         break;
-
-      if(*rngname == '\0')
-      {
-         assert(strlen(mps.field1()) < MPSInput::MAX_LINE_LEN);
-         spxSnprintf(rngname, MPSInput::MAX_LINE_LEN, "%s", mps.field1());
+        // GE or EQ
+        if (rset.lhs(idx) > R(-infinity))
+          rset.lhs_w(idx) = val;
       }
 
-      /* The rules are:
-       * Row Sign   LHS             RHS
-       * ----------------------------------------
-       *  G   +/-   rhs             rhs + |range|
-       *  L   +/-   rhs - |range|   rhs
-       *  E   +     rhs             rhs + range
-       *  E   -     rhs + range     rhs
-       * ----------------------------------------
-       */
-      if(!strcmp(rngname, mps.field1()))
-      {
-         if((idx = rnames.number(mps.field2())) < 0)
-            mps.entryIgnored("Range", mps.field1(), "row", mps.field2());
-         else
-         {
-            val = atof(mps.field3());
-
-            // EQ
-            if((rset.lhs(idx) > R(-infinity)) && (rset.rhs_w(idx) <  R(infinity)))
-            {
-               assert(rset.lhs(idx) == rset.rhs(idx));
-
-               if(val >= 0)
-                  rset.rhs_w(idx) += val;
-               else
-                  rset.lhs_w(idx) += val;
-            }
-            else
-            {
-               // GE
-               if(rset.lhs(idx) > R(-infinity))
-                  rset.rhs_w(idx)  = rset.lhs(idx) + spxAbs(val);
-               // LE
-               else
-                  rset.lhs_w(idx)  = rset.rhs(idx) - spxAbs(val);
-            }
-         }
+      if (mps.field5() != 0) {
+        if ((idx = rnames.number(mps.field4())) < 0)
+          mps.entryIgnored("RHS", mps.field1(), "row", mps.field4());
+        else {
+          val = atof(mps.field5());
 
-         if(mps.field5() != 0)
-         {
-            if((idx = rnames.number(mps.field4())) < 0)
-               mps.entryIgnored("Range", mps.field1(), "row", mps.field4());
-            else
-            {
-               val = atof(mps.field5());
-
-               // EQ
-               if((rset.lhs(idx) > R(-infinity)) && (rset.rhs(idx) <  R(infinity)))
-               {
-                  assert(rset.lhs(idx) == rset.rhs(idx));
-
-                  if(val >= 0)
-                     rset.rhs_w(idx) += val;
-                  else
-                     rset.lhs_w(idx) += val;
-               }
-               else
-               {
-                  // GE
-                  if(rset.lhs(idx) > R(-infinity))
-                     rset.rhs_w(idx)  = rset.lhs(idx) + spxAbs(val);
-                  // LE
-                  else
-                     rset.lhs_w(idx)  = rset.rhs(idx) - spxAbs(val);
-               }
-            }
-         }
+          // LE or EQ
+          if (rset.rhs(idx) < R(infinity))
+            rset.rhs_w(idx) = val;
+
+          // GE or EQ
+          if (rset.lhs(idx) > R(-infinity))
+            rset.lhs_w(idx) = val;
+        }
       }
-   }
+    }
+  }
 
-   mps.syntaxError();
+  mps.syntaxError();
 }
 
-
-
-/// Process BOUNDS section.
+/// Process RANGES section.
 template <class R>
-static void MPSreadBounds(MPSInput& mps, LPColSetBase<R>& cset, const NameSet& cnames,
-                          DIdxSet* intvars, SPxOut* spxout)
-{
-   DIdxSet oldbinvars;
-   char bndname[MPSInput::MAX_LINE_LEN] = { '\0' };
-   int  idx;
-   R val;
-
-   while(mps.readLine())
-   {
-      if(mps.field0() != 0)
-      {
-         MSG_INFO2((*spxout), (*spxout) << "IMPSRD05 Bound name     : " << bndname << std::endl;)
-
-         if(strcmp(mps.field0(), "ENDATA"))
-            break;
-
-         mps.setSection(MPSInput::ENDATA);
+static void MPSreadRanges(MPSInput &mps, LPRowSetBase<R> &rset,
+                          const NameSet &rnames, SPxOut *spxout) {
+  char rngname[MPSInput::MAX_LINE_LEN] = {'\0'};
+  int idx;
+  R val;
+
+  while (mps.readLine()) {
+    if (mps.field0() != 0) {
+      MSG_INFO2((*spxout), (*spxout) << "IMPSRD04 Range name     : " << rngname
+                                     << std::endl;);
+
+      if (!strcmp(mps.field0(), "BOUNDS"))
+        mps.setSection(MPSInput::BOUNDS);
+      else if (!strcmp(mps.field0(), "ENDATA"))
+        mps.setSection(MPSInput::ENDATA);
+      else
+        break;
 
-         return;
+      return;
+    }
+
+    if (((mps.field2() != 0) && (mps.field3() == 0)) ||
+        ((mps.field4() != 0) && (mps.field5() == 0)))
+      mps.insertName("_RNG_");
+
+    if ((mps.field1() == 0) || (mps.field2() == 0) || (mps.field3() == 0))
+      break;
+
+    if (*rngname == '\0') {
+      assert(strlen(mps.field1()) < MPSInput::MAX_LINE_LEN);
+      spxSnprintf(rngname, MPSInput::MAX_LINE_LEN, "%s", mps.field1());
+    }
+
+    /* The rules are:
+     * Row Sign   LHS             RHS
+     * ----------------------------------------
+     *  G   +/-   rhs             rhs + |range|
+     *  L   +/-   rhs - |range|   rhs
+     *  E   +     rhs             rhs + range
+     *  E   -     rhs + range     rhs
+     * ----------------------------------------
+     */
+    if (!strcmp(rngname, mps.field1())) {
+      if ((idx = rnames.number(mps.field2())) < 0)
+        mps.entryIgnored("Range", mps.field1(), "row", mps.field2());
+      else {
+        val = atof(mps.field3());
+
+        // EQ
+        if ((rset.lhs(idx) > R(-infinity)) && (rset.rhs_w(idx) < R(infinity))) {
+          assert(rset.lhs(idx) == rset.rhs(idx));
+
+          if (val >= 0)
+            rset.rhs_w(idx) += val;
+          else
+            rset.lhs_w(idx) += val;
+        } else {
+          // GE
+          if (rset.lhs(idx) > R(-infinity))
+            rset.rhs_w(idx) = rset.lhs(idx) + spxAbs(val);
+          // LE
+          else
+            rset.lhs_w(idx) = rset.rhs(idx) - spxAbs(val);
+        }
+      }
+
+      if (mps.field5() != 0) {
+        if ((idx = rnames.number(mps.field4())) < 0)
+          mps.entryIgnored("Range", mps.field1(), "row", mps.field4());
+        else {
+          val = atof(mps.field5());
+
+          // EQ
+          if ((rset.lhs(idx) > R(-infinity)) && (rset.rhs(idx) < R(infinity))) {
+            assert(rset.lhs(idx) == rset.rhs(idx));
+
+            if (val >= 0)
+              rset.rhs_w(idx) += val;
+            else
+              rset.lhs_w(idx) += val;
+          } else {
+            // GE
+            if (rset.lhs(idx) > R(-infinity))
+              rset.rhs_w(idx) = rset.lhs(idx) + spxAbs(val);
+            // LE
+            else
+              rset.lhs_w(idx) = rset.rhs(idx) - spxAbs(val);
+          }
+        }
       }
+    }
+  }
 
-      // Is the value field used ?
-      if((!strcmp(mps.field1(), "LO"))
-            || (!strcmp(mps.field1(), "UP"))
-            || (!strcmp(mps.field1(), "FX"))
-            || (!strcmp(mps.field1(), "LI"))
-            || (!strcmp(mps.field1(), "UI")))
-      {
-         if((mps.field3() != 0) && (mps.field4() == 0))
-            mps.insertName("_BND_", true);
-      }
-      else
-      {
-         if((mps.field2() != 0) && (mps.field3() == 0))
-            mps.insertName("_BND_", true);
-      }
+  mps.syntaxError();
+}
 
-      if((mps.field1() == 0) || (mps.field2() == 0) || (mps.field3() == 0))
-         break;
+/// Process BOUNDS section.
+template <class R>
+static void MPSreadBounds(MPSInput &mps, LPColSetBase<R> &cset,
+                          const NameSet &cnames, DIdxSet *intvars,
+                          SPxOut *spxout) {
+  DIdxSet oldbinvars;
+  char bndname[MPSInput::MAX_LINE_LEN] = {'\0'};
+  int idx;
+  R val;
 
-      if(*bndname == '\0')
-      {
-         assert(strlen(mps.field2()) < MPSInput::MAX_LINE_LEN);
-         spxSnprintf(bndname, MPSInput::MAX_LINE_LEN, "%s", mps.field2());
-      }
+  while (mps.readLine()) {
+    if (mps.field0() != 0) {
+      MSG_INFO2((*spxout), (*spxout) << "IMPSRD05 Bound name     : " << bndname
+                                     << std::endl;)
 
-      // Only read the first Bound in section
-      if(!strcmp(bndname, mps.field2()))
-      {
-         if((idx = cnames.number(mps.field3())) < 0)
-            mps.entryIgnored("column", mps.field3(), "bound", bndname);
-         else
-         {
-            if(mps.field4() == 0)
-               val = 0.0;
-            else if(!strcmp(mps.field4(), "-Inf") || !strcmp(mps.field4(), "-inf"))
-               val = R(-infinity);
-            else if(!strcmp(mps.field4(), "Inf") || !strcmp(mps.field4(), "inf")
-                    || !strcmp(mps.field4(), "+Inf") || !strcmp(mps.field4(), "+inf"))
-               val = R(infinity);
-            else
-               val = atof(mps.field4());
-
-            // ILOG extension (Integer Bound)
-            if(mps.field1()[1] == 'I')
-            {
-               if(intvars != 0)
-                  intvars->addIdx(idx);
-
-               // if the variable has appeared in the MARKER section of the COLUMNS section then its default bounds were
-               // set to 0,1; the first time it is declared integer we need to change to default bounds 0,R(infinity)
-               if(oldbinvars.pos(idx) < 0)
-               {
-                  cset.upper_w(idx) = R(infinity);
-                  oldbinvars.addIdx(idx);
-               }
-            }
+      if (strcmp(mps.field0(), "ENDATA"))
+        break;
 
-            switch(*mps.field1())
-            {
-            case 'L':
-               cset.lower_w(idx) = val;
-               break;
-
-            case 'U':
-               cset.upper_w(idx) = val;
-               break;
-
-            case 'F':
-               if(mps.field1()[1] == 'X')
-               {
-                  cset.lower_w(idx) = val;
-                  cset.upper_w(idx) = val;
-               }
-               else
-               {
-                  cset.lower_w(idx) = R(-infinity);
-                  cset.upper_w(idx) = R(infinity);
-               }
-
-               break;
-
-            case 'M':
-               cset.lower_w(idx) = R(-infinity);
-               break;
-
-            case 'P':
-               cset.upper_w(idx) = R(infinity);
-               break;
-
-            // Ilog extension (Binary)
-            case 'B':
-               cset.lower_w(idx) = 0.0;
-               cset.upper_w(idx) = 1.0;
-
-               if(intvars != 0)
-                  intvars->addIdx(idx);
-
-               break;
-
-            default:
-               mps.syntaxError();
-               return;
-            }
-         }
-      }
-   }
+      mps.setSection(MPSInput::ENDATA);
 
-   mps.syntaxError();
+      return;
+    }
+
+    // Is the value field used ?
+    if ((!strcmp(mps.field1(), "LO")) || (!strcmp(mps.field1(), "UP")) ||
+        (!strcmp(mps.field1(), "FX")) || (!strcmp(mps.field1(), "LI")) ||
+        (!strcmp(mps.field1(), "UI"))) {
+      if ((mps.field3() != 0) && (mps.field4() == 0))
+        mps.insertName("_BND_", true);
+    } else {
+      if ((mps.field2() != 0) && (mps.field3() == 0))
+        mps.insertName("_BND_", true);
+    }
+
+    if ((mps.field1() == 0) || (mps.field2() == 0) || (mps.field3() == 0))
+      break;
+
+    if (*bndname == '\0') {
+      assert(strlen(mps.field2()) < MPSInput::MAX_LINE_LEN);
+      spxSnprintf(bndname, MPSInput::MAX_LINE_LEN, "%s", mps.field2());
+    }
+
+    // Only read the first Bound in section
+    if (!strcmp(bndname, mps.field2())) {
+      if ((idx = cnames.number(mps.field3())) < 0)
+        mps.entryIgnored("column", mps.field3(), "bound", bndname);
+      else {
+        if (mps.field4() == 0)
+          val = 0.0;
+        else if (!strcmp(mps.field4(), "-Inf") || !strcmp(mps.field4(), "-inf"))
+          val = R(-infinity);
+        else if (!strcmp(mps.field4(), "Inf") || !strcmp(mps.field4(), "inf") ||
+                 !strcmp(mps.field4(), "+Inf") || !strcmp(mps.field4(), "+inf"))
+          val = R(infinity);
+        else
+          val = atof(mps.field4());
+
+        // ILOG extension (Integer Bound)
+        if (mps.field1()[1] == 'I') {
+          if (intvars != 0)
+            intvars->addIdx(idx);
+
+          // if the variable has appeared in the MARKER section of the COLUMNS
+          // section then its default bounds were set to 0,1; the first time it
+          // is declared integer we need to change to default bounds
+          // 0,R(infinity)
+          if (oldbinvars.pos(idx) < 0) {
+            cset.upper_w(idx) = R(infinity);
+            oldbinvars.addIdx(idx);
+          }
+        }
+
+        switch (*mps.field1()) {
+        case 'L':
+          cset.lower_w(idx) = val;
+          break;
+
+        case 'U':
+          cset.upper_w(idx) = val;
+          break;
+
+        case 'F':
+          if (mps.field1()[1] == 'X') {
+            cset.lower_w(idx) = val;
+            cset.upper_w(idx) = val;
+          } else {
+            cset.lower_w(idx) = R(-infinity);
+            cset.upper_w(idx) = R(infinity);
+          }
+
+          break;
+
+        case 'M':
+          cset.lower_w(idx) = R(-infinity);
+          break;
+
+        case 'P':
+          cset.upper_w(idx) = R(infinity);
+          break;
+
+        // Ilog extension (Binary)
+        case 'B':
+          cset.lower_w(idx) = 0.0;
+          cset.upper_w(idx) = 1.0;
+
+          if (intvars != 0)
+            intvars->addIdx(idx);
+
+          break;
+
+        default:
+          mps.syntaxError();
+          return;
+        }
+      }
+    }
+  }
+
+  mps.syntaxError();
 }
 
-
-
 /// Read LP in MPS File Format.
 /**
- *  The specification is taken from the IBM Optimization Library Guide and Reference, online available at
- *  http://www.software.ibm.com/sos/features/libuser.htm and from the ILOG CPLEX 7.0 Reference Manual, Appendix E, Page
- *  531.
+ *  The specification is taken from the IBM Optimization Library Guide and
+ * Reference, online available at
+ *  http://www.software.ibm.com/sos/features/libuser.htm and from the ILOG
+ * CPLEX 7.0 Reference Manual, Appendix E, Page 531.
  *
- *  This routine should read all valid MPS format files.  What it will not do, is find all cases where a file is ill
- *  formed.  If this happens it may complain and read nothing or read "something".
+ *  This routine should read all valid MPS format files.  What it will not do,
+ * is find all cases where a file is ill formed.  If this happens it may
+ * complain and read nothing or read "something".
  *
  *  @return true if the file was read correctly.
  */
-const int Init_Cols = 10000; ///< initialy allocated columns.
+const int Init_Cols = 10000;  ///< initialy allocated columns.
 const int Init_NZos = 100000; ///< initialy allocated non zeros.
-template <class R> inline
-bool SPxLPBase<R>::readMPS(
-   std::istream& p_input,           ///< input stream.
-   NameSet*      p_rnames,          ///< row names.
-   NameSet*      p_cnames,          ///< column names.
-   DIdxSet*      p_intvars)         ///< integer variables.
+template <class R>
+inline bool SPxLPBase<R>::readMPS(std::istream &p_input, ///< input stream.
+                                  NameSet *p_rnames,     ///< row names.
+                                  NameSet *p_cnames,     ///< column names.
+                                  DIdxSet *p_intvars)    ///< integer variables.
 {
-   LPRowSetBase<R>& rset = *this;
-   LPColSetBase<R>& cset = *this;
-   NameSet* rnames;
-   NameSet* cnames;
-
-   if(p_cnames)
-      cnames = p_cnames;
-   else
-   {
-      cnames = 0;
-      spx_alloc(cnames);
-      cnames = new(cnames) NameSet();
-   }
-
-   cnames->clear();
-
-   if(p_rnames)
-      rnames = p_rnames;
-   else
-   {
-      try
-      {
-         rnames = 0;
-         spx_alloc(rnames);
-         rnames = new(rnames) NameSet();
-      }
-      catch(const SPxMemoryException& x)
-      {
-         if(!p_cnames)
-         {
-            cnames->~NameSet();
-            spx_free(cnames);
-         }
+  LPRowSetBase<R> &rset = *this;
+  LPColSetBase<R> &cset = *this;
+  NameSet *rnames;
+  NameSet *cnames;
 
-         throw x;
-      }
-   }
+  if (p_cnames)
+    cnames = p_cnames;
+  else {
+    cnames = 0;
+    spx_alloc(cnames);
+    cnames = new (cnames) NameSet();
+  }
 
-   rnames->clear();
+  cnames->clear();
 
-   SPxLPBase<R>::clear(); // clear the LP.
+  if (p_rnames)
+    rnames = p_rnames;
+  else {
+    try {
+      rnames = 0;
+      spx_alloc(rnames);
+      rnames = new (rnames) NameSet();
+    } catch (const SPxMemoryException &x) {
+      if (!p_cnames) {
+        cnames->~NameSet();
+        spx_free(cnames);
+      }
 
-   cset.memRemax(Init_NZos);
-   cset.reMax(Init_Cols);
+      throw x;
+    }
+  }
 
-   MPSInput mps(p_input);
+  rnames->clear();
 
-   MPSreadName(mps, spxout);
+  SPxLPBase<R>::clear(); // clear the LP.
 
-   if(mps.section() == MPSInput::OBJSEN)
-      MPSreadObjsen(mps);
+  cset.memRemax(Init_NZos);
+  cset.reMax(Init_Cols);
 
-   if(mps.section() == MPSInput::OBJNAME)
-      MPSreadObjname(mps);
+  MPSInput mps(p_input);
 
-   if(mps.section() == MPSInput::ROWS)
-      MPSreadRows(mps, rset, *rnames, spxout);
+  MPSreadName(mps, spxout);
 
-   addedRows(rset.num());
+  if (mps.section() == MPSInput::OBJSEN)
+    MPSreadObjsen(mps);
 
-   if(mps.section() == MPSInput::COLUMNS)
-      MPSreadCols(mps, rset, *rnames, cset, *cnames, p_intvars);
+  if (mps.section() == MPSInput::OBJNAME)
+    MPSreadObjname(mps);
 
-   if(mps.section() == MPSInput::RHS)
-      MPSreadRhs(mps, rset, *rnames, spxout);
+  if (mps.section() == MPSInput::ROWS)
+    MPSreadRows(mps, rset, *rnames, spxout);
 
-   if(mps.section() == MPSInput::RANGES)
-      MPSreadRanges(mps, rset, *rnames, spxout);
+  addedRows(rset.num());
 
-   if(mps.section() == MPSInput::BOUNDS)
-      MPSreadBounds(mps, cset, *cnames, p_intvars, spxout);
+  if (mps.section() == MPSInput::COLUMNS)
+    MPSreadCols(mps, rset, *rnames, cset, *cnames, p_intvars);
 
-   if(mps.section() != MPSInput::ENDATA)
-      mps.syntaxError();
+  if (mps.section() == MPSInput::RHS)
+    MPSreadRhs(mps, rset, *rnames, spxout);
 
-   if(mps.hasError())
-      clear();
-   else
-   {
-      changeSense(mps.objSense() == MPSInput::MINIMIZE ? SPxLPBase<R>::MINIMIZE : SPxLPBase<R>::MAXIMIZE);
+  if (mps.section() == MPSInput::RANGES)
+    MPSreadRanges(mps, rset, *rnames, spxout);
 
-      MSG_INFO2((*spxout), (*spxout) << "IMPSRD06 Objective sense: " << ((mps.objSense() ==
-                MPSInput::MINIMIZE) ? "Minimize\n" : "Maximize\n"));
+  if (mps.section() == MPSInput::BOUNDS)
+    MPSreadBounds(mps, cset, *cnames, p_intvars, spxout);
 
-      added2Set(
-         *(reinterpret_cast<SVSetBase<R>*>(static_cast<LPRowSetBase<R>*>(this))),
-         *(reinterpret_cast<SVSetBase<R>*>(static_cast<LPColSetBase<R>*>(this))),
-         cset.num());
-      addedCols(cset.num());
+  if (mps.section() != MPSInput::ENDATA)
+    mps.syntaxError();
 
-      assert(isConsistent());
-   }
+  if (mps.hasError())
+    clear();
+  else {
+    changeSense(mps.objSense() == MPSInput::MINIMIZE ? SPxLPBase<R>::MINIMIZE
+                                                     : SPxLPBase<R>::MAXIMIZE);
 
-   if(p_cnames == 0)
-   {
-      cnames->~NameSet();
-      spx_free(cnames);
-   }
+    MSG_INFO2((*spxout), (*spxout) << "IMPSRD06 Objective sense: "
+                                   << ((mps.objSense() == MPSInput::MINIMIZE)
+                                           ? "Minimize\n"
+                                           : "Maximize\n"));
 
-   if(p_rnames == 0)
-   {
-      rnames->~NameSet();
-      spx_free(rnames);
-   }
+    added2Set(*(reinterpret_cast<SVSetBase<R> *>(
+                  static_cast<LPRowSetBase<R> *>(this))),
+              *(reinterpret_cast<SVSetBase<R> *>(
+                  static_cast<LPColSetBase<R> *>(this))),
+              cset.num());
+    addedCols(cset.num());
 
-   return !mps.hasError();
-}
+    assert(isConsistent());
+  }
 
+  if (p_cnames == 0) {
+    cnames->~NameSet();
+    spx_free(cnames);
+  }
 
+  if (p_rnames == 0) {
+    rnames->~NameSet();
+    spx_free(rnames);
+  }
+
+  return !mps.hasError();
+}
 
 // ---------------------------------------------------------------------------------------------------------------------
 // Specialization for writing LP format
@@ -2118,874 +1886,775 @@ bool SPxLPBase<R>::readMPS(
 
 // get the name of a row or construct one
 template <class R>
-static const char* LPFgetRowName(
-   const SPxLPBase<R>& p_lp,
-   int                    p_idx,
-   const NameSet*         p_rnames,
-   char*                  p_buf,
-   int                    p_num_written_rows
-)
-{
-   assert(p_buf != 0);
-   assert(p_idx >= 0);
-   assert(p_idx <  p_lp.nRows());
+static const char *LPFgetRowName(const SPxLPBase<R> &p_lp, int p_idx,
+                                 const NameSet *p_rnames, char *p_buf,
+                                 int p_num_written_rows) {
+  assert(p_buf != 0);
+  assert(p_idx >= 0);
+  assert(p_idx < p_lp.nRows());
 
-   if(p_rnames != 0)
-   {
-      DataKey key = p_lp.rId(p_idx);
+  if (p_rnames != 0) {
+    DataKey key = p_lp.rId(p_idx);
 
-      if(p_rnames->has(key))
-         return (*p_rnames)[key];
-   }
+    if (p_rnames->has(key))
+      return (*p_rnames)[key];
+  }
 
-   spxSnprintf(p_buf, 16, "C%d", p_num_written_rows);
+  spxSnprintf(p_buf, 16, "C%d", p_num_written_rows);
 
-   return p_buf;
+  return p_buf;
 }
 
-
-
 // get the name of a column or construct one
 template <class R>
-static const char* getColName(
-   const SPxLPBase<R>& p_lp,
-   int                    p_idx,
-   const NameSet*         p_cnames,
-   char*                  p_buf
-)
-{
-   assert(p_buf != 0);
-   assert(p_idx >= 0);
-   assert(p_idx <  p_lp.nCols());
+static const char *getColName(const SPxLPBase<R> &p_lp, int p_idx,
+                              const NameSet *p_cnames, char *p_buf) {
+  assert(p_buf != 0);
+  assert(p_idx >= 0);
+  assert(p_idx < p_lp.nCols());
 
-   if(p_cnames != 0)
-   {
-      DataKey key = p_lp.cId(p_idx);
+  if (p_cnames != 0) {
+    DataKey key = p_lp.cId(p_idx);
 
-      if(p_cnames->has(key))
-         return (*p_cnames)[key];
-   }
+    if (p_cnames->has(key))
+      return (*p_cnames)[key];
+  }
 
-   spxSnprintf(p_buf, 16, "x%d", p_idx);
+  spxSnprintf(p_buf, 16, "x%d", p_idx);
 
-   return p_buf;
+  return p_buf;
 }
 
-
-
 // write an SVectorBase<R>
 #define NUM_ENTRIES_PER_LINE 5
 template <class R>
-static void LPFwriteSVector(
-   const SPxLPBase<R>&   p_lp,       ///< the LP
-   std::ostream&            p_output,   ///< output stream
-   const NameSet*           p_cnames,   ///< column names
-   const SVectorBase<R>& p_svec)     ///< vector to write
+static void LPFwriteSVector(const SPxLPBase<R> &p_lp,     ///< the LP
+                            std::ostream &p_output,       ///< output stream
+                            const NameSet *p_cnames,      ///< column names
+                            const SVectorBase<R> &p_svec) ///< vector to write
 {
 
-   char name[16];
-   int num_coeffs = 0;
+  char name[16];
+  int num_coeffs = 0;
 
-   for(int j = 0; j < p_lp.nCols(); ++j)
-   {
-      const R coeff = p_svec[j];
+  for (int j = 0; j < p_lp.nCols(); ++j) {
+    const R coeff = p_svec[j];
 
-      if(coeff == 0)
-         continue;
+    if (coeff == 0)
+      continue;
 
-      if(num_coeffs == 0)
-         p_output << coeff << " " << getColName(p_lp, j, p_cnames, name);
-      else
-      {
-         // insert a line break every NUM_ENTRIES_PER_LINE columns
-         if(num_coeffs % NUM_ENTRIES_PER_LINE == 0)
-            p_output << "\n\t";
+    if (num_coeffs == 0)
+      p_output << coeff << " " << getColName(p_lp, j, p_cnames, name);
+    else {
+      // insert a line break every NUM_ENTRIES_PER_LINE columns
+      if (num_coeffs % NUM_ENTRIES_PER_LINE == 0)
+        p_output << "\n\t";
 
-         if(coeff < 0)
-            p_output << " - " << -coeff;
-         else
-            p_output << " + " << coeff;
+      if (coeff < 0)
+        p_output << " - " << -coeff;
+      else
+        p_output << " + " << coeff;
 
-         p_output << " " << getColName(p_lp, j, p_cnames, name);
-      }
+      p_output << " " << getColName(p_lp, j, p_cnames, name);
+    }
 
-      ++num_coeffs;
-   }
+    ++num_coeffs;
+  }
 }
 
-
-
 // write the objective
 template <class R>
-static void LPFwriteObjective(
-   const SPxLPBase<R>& p_lp,       ///< the LP
-   std::ostream&          p_output,   ///< output stream
-   const NameSet*         p_cnames    ///< column names
-)
-{
-
-   const int sense = p_lp.spxSense();
-
-   p_output << ((sense == SPxLPBase<R>::MINIMIZE) ? "Minimize\n" : "Maximize\n");
-   p_output << "  obj: ";
-
-   const VectorBase<R>& obj = p_lp.maxObj();
-   DSVectorBase<R> svec(obj.dim());
-   svec.operator = (obj);
-   svec *= R(sense);
-   LPFwriteSVector(p_lp, p_output, p_cnames, svec);
-   p_output << "\n";
+static void LPFwriteObjective(const SPxLPBase<R> &p_lp, ///< the LP
+                              std::ostream &p_output,   ///< output stream
+                              const NameSet *p_cnames   ///< column names
+) {
+
+  const int sense = p_lp.spxSense();
+
+  p_output << ((sense == SPxLPBase<R>::MINIMIZE) ? "Minimize\n" : "Maximize\n");
+  p_output << "  obj: ";
+
+  const VectorBase<R> &obj = p_lp.maxObj();
+  DSVectorBase<R> svec(obj.dim());
+  svec.operator=(obj);
+  svec *= R(sense);
+  LPFwriteSVector(p_lp, p_output, p_cnames, svec);
+  p_output << "\n";
 }
 
-
-
 // write non-ranged rows
 template <class R>
-static void LPFwriteRow(
-   const SPxLPBase<R>&   p_lp,       ///< the LP
-   std::ostream&            p_output,   ///< output stream
-   const NameSet*           p_cnames,   ///< column names
-   const SVectorBase<R>& p_svec,     ///< vector of the row
-   const R&              p_lhs,      ///< lhs of the row
-   const R&              p_rhs       ///< rhs of the row
-)
-{
-
-   LPFwriteSVector(p_lp, p_output, p_cnames, p_svec);
-
-   if(p_lhs == p_rhs)
-      p_output << " = " << p_rhs;
-   else if(p_lhs <= R(-infinity))
-      p_output << " <= " << p_rhs;
-   else
-   {
-      assert(p_rhs >= R(infinity));
-      p_output << " >= " << p_lhs;
-   }
-
-   p_output << "\n";
+static void LPFwriteRow(const SPxLPBase<R> &p_lp,     ///< the LP
+                        std::ostream &p_output,       ///< output stream
+                        const NameSet *p_cnames,      ///< column names
+                        const SVectorBase<R> &p_svec, ///< vector of the row
+                        const R &p_lhs,               ///< lhs of the row
+                        const R &p_rhs                ///< rhs of the row
+) {
+
+  LPFwriteSVector(p_lp, p_output, p_cnames, p_svec);
+
+  if (p_lhs == p_rhs)
+    p_output << " = " << p_rhs;
+  else if (p_lhs <= R(-infinity))
+    p_output << " <= " << p_rhs;
+  else {
+    assert(p_rhs >= R(infinity));
+    p_output << " >= " << p_lhs;
+  }
+
+  p_output << "\n";
 }
 
-
-
 // write all rows
 template <class R>
-static void LPFwriteRows(
-   const SPxLPBase<R>& p_lp,       ///< the LP
-   std::ostream&          p_output,   ///< output stream
-   const NameSet*         p_rnames,   ///< row names
-   const NameSet*         p_cnames   ///< column names
-)
-{
-
-   char name[16];
-
-   p_output << "Subject To\n";
-
-   for(int i = 0; i < p_lp.nRows(); ++i)
-   {
-      const R lhs = p_lp.lhs(i);
-      const R rhs = p_lp.rhs(i);
-
-      if(lhs > R(-infinity) && rhs < R(infinity) && lhs != rhs)
-      {
-         // ranged row -> write two non-ranged rows
-         p_output << " " << LPFgetRowName(p_lp, i, p_rnames, name, i) << "_1 : ";
-         LPFwriteRow(p_lp, p_output, p_cnames, p_lp.rowVector(i), lhs, R(infinity));
-
-         p_output << " " << LPFgetRowName(p_lp, i, p_rnames, name, i) << "_2 : ";
-         LPFwriteRow(p_lp, p_output, p_cnames, p_lp.rowVector(i), R(-infinity), rhs);
-      }
-      else
-      {
-         p_output << " " << LPFgetRowName(p_lp, i, p_rnames, name, i) << " : ";
-         LPFwriteRow(p_lp, p_output, p_cnames, p_lp.rowVector(i), lhs, rhs);
-      }
-   }
+static void LPFwriteRows(const SPxLPBase<R> &p_lp, ///< the LP
+                         std::ostream &p_output,   ///< output stream
+                         const NameSet *p_rnames,  ///< row names
+                         const NameSet *p_cnames   ///< column names
+) {
+
+  char name[16];
+
+  p_output << "Subject To\n";
+
+  for (int i = 0; i < p_lp.nRows(); ++i) {
+    const R lhs = p_lp.lhs(i);
+    const R rhs = p_lp.rhs(i);
+
+    if (lhs > R(-infinity) && rhs < R(infinity) && lhs != rhs) {
+      // ranged row -> write two non-ranged rows
+      p_output << " " << LPFgetRowName(p_lp, i, p_rnames, name, i) << "_1 : ";
+      LPFwriteRow(p_lp, p_output, p_cnames, p_lp.rowVector(i), lhs,
+                  R(infinity));
+
+      p_output << " " << LPFgetRowName(p_lp, i, p_rnames, name, i) << "_2 : ";
+      LPFwriteRow(p_lp, p_output, p_cnames, p_lp.rowVector(i), R(-infinity),
+                  rhs);
+    } else {
+      p_output << " " << LPFgetRowName(p_lp, i, p_rnames, name, i) << " : ";
+      LPFwriteRow(p_lp, p_output, p_cnames, p_lp.rowVector(i), lhs, rhs);
+    }
+  }
 }
 
-
-
 // write the variable bounds
 // (the default bounds 0 <= x <= R(infinity) are not written)
 template <class R>
-static void LPFwriteBounds(
-   const SPxLPBase<R>&   p_lp,       ///< the LP to write
-   std::ostream&            p_output,   ///< output stream
-   const NameSet*           p_cnames    ///< column names
-)
-{
-
-   char name[16];
-
-   p_output << "Bounds\n";
-
-   for(int j = 0; j < p_lp.nCols(); ++j)
-   {
-      const R lower = p_lp.lower(j);
-      const R upper = p_lp.upper(j);
-
-      if(lower == upper)
-      {
-         p_output << "  "   << getColName(p_lp, j, p_cnames, name) << " = "  << upper << '\n';
-      }
-      else if(lower > R(-infinity))
-      {
-         if(upper < R(infinity))
-         {
-            // range bound
-            if(lower != 0)
-               p_output << "  "   << lower << " <= "
-                        << getColName(p_lp, j, p_cnames, name)
-                        << " <= " << upper << '\n';
-            else
-               p_output << "  "   << getColName(p_lp, j, p_cnames, name)
-                        << " <= " << upper << '\n';
-         }
-         else if(lower != 0)
-            p_output << "  " << lower << " <= "
-                     << getColName(p_lp, j, p_cnames, name)
-                     << '\n';
-      }
-      else if(upper < R(infinity))
-         p_output << "   -Inf <= "
-                  << getColName(p_lp, j, p_cnames, name)
-                  << " <= " << upper << '\n';
-      else
-         p_output << "  "   << getColName(p_lp, j, p_cnames, name)
-                  << " free\n";
-   }
+static void LPFwriteBounds(const SPxLPBase<R> &p_lp, ///< the LP to write
+                           std::ostream &p_output,   ///< output stream
+                           const NameSet *p_cnames   ///< column names
+) {
+
+  char name[16];
+
+  p_output << "Bounds\n";
+
+  for (int j = 0; j < p_lp.nCols(); ++j) {
+    const R lower = p_lp.lower(j);
+    const R upper = p_lp.upper(j);
+
+    if (lower == upper) {
+      p_output << "  " << getColName(p_lp, j, p_cnames, name) << " = " << upper
+               << '\n';
+    } else if (lower > R(-infinity)) {
+      if (upper < R(infinity)) {
+        // range bound
+        if (lower != 0)
+          p_output << "  " << lower
+                   << " <= " << getColName(p_lp, j, p_cnames, name)
+                   << " <= " << upper << '\n';
+        else
+          p_output << "  " << getColName(p_lp, j, p_cnames, name)
+                   << " <= " << upper << '\n';
+      } else if (lower != 0)
+        p_output << "  " << lower
+                 << " <= " << getColName(p_lp, j, p_cnames, name) << '\n';
+    } else if (upper < R(infinity))
+      p_output << "   -Inf <= " << getColName(p_lp, j, p_cnames, name)
+               << " <= " << upper << '\n';
+    else
+      p_output << "  " << getColName(p_lp, j, p_cnames, name) << " free\n";
+  }
 }
 
-
-
 // write the generals section
 template <class R>
-static void LPFwriteGenerals(
-   const SPxLPBase<R>&   p_lp,         ///< the LP to write
-   std::ostream&            p_output,     ///< output stream
-   const NameSet*           p_cnames,     ///< column names
-   const DIdxSet*           p_intvars     ///< integer variables
-)
-{
+static void LPFwriteGenerals(const SPxLPBase<R> &p_lp, ///< the LP to write
+                             std::ostream &p_output,   ///< output stream
+                             const NameSet *p_cnames,  ///< column names
+                             const DIdxSet *p_intvars  ///< integer variables
+) {
 
-   char name[16];
+  char name[16];
 
-   if(p_intvars == NULL || p_intvars->size() <= 0)
-      return;  // no integer variables
+  if (p_intvars == NULL || p_intvars->size() <= 0)
+    return; // no integer variables
 
-   p_output << "Generals\n";
+  p_output << "Generals\n";
 
-   for(int j = 0; j < p_lp.nCols(); ++j)
-      if(p_intvars->pos(j) >= 0)
-         p_output << "  " << getColName(p_lp, j, p_cnames, name) << "\n";
+  for (int j = 0; j < p_lp.nCols(); ++j)
+    if (p_intvars->pos(j) >= 0)
+      p_output << "  " << getColName(p_lp, j, p_cnames, name) << "\n";
 }
 
-
-
 /// Write LP in LP Format.
-template <class R> inline
-void SPxLPBase<R>::writeLPF(
-   std::ostream&  p_output,          ///< output stream
-   const NameSet* p_rnames,          ///< row names
-   const NameSet* p_cnames,          ///< column names
-   const DIdxSet* p_intvars          ///< integer variables
-) const
-{
-   SPxOut::setScientific(p_output, 16);
-
-   LPFwriteObjective(*this, p_output, p_cnames);
-   LPFwriteRows(*this, p_output, p_rnames, p_cnames);
-   LPFwriteBounds(*this, p_output, p_cnames);
-   LPFwriteGenerals(*this, p_output, p_cnames, p_intvars);
-
-   p_output << "End" << std::endl;
+template <class R>
+inline void
+SPxLPBase<R>::writeLPF(std::ostream &p_output,  ///< output stream
+                       const NameSet *p_rnames, ///< row names
+                       const NameSet *p_cnames, ///< column names
+                       const DIdxSet *p_intvars ///< integer variables
+) const {
+  SPxOut::setScientific(p_output, 16);
+
+  LPFwriteObjective(*this, p_output, p_cnames);
+  LPFwriteRows(*this, p_output, p_rnames, p_cnames);
+  LPFwriteBounds(*this, p_output, p_cnames);
+  LPFwriteGenerals(*this, p_output, p_cnames, p_intvars);
+
+  p_output << "End" << std::endl;
 }
 
-
-
 // ---------------------------------------------------------------------------------------------------------------------
 // Specialization for writing MPS format
 // ---------------------------------------------------------------------------------------------------------------------
 
 template <class R>
-static void MPSwriteRecord(
-   std::ostream&  os,
-   const char*    indicator,
-   const char*    name,
-   const char*    name1  = nullptr,
-   const R     value1 = 0.0,
-   const char*    name2  = nullptr,
-   const R     value2 = 0.0
-)
-{
-   char buf[81];
-
-   spxSnprintf(buf, sizeof(buf), " %-2.2s %-8.8s", (indicator == 0) ? "" : indicator,
-               (name == 0)      ? "" : name);
-   os << buf;
-
-   if(name1 != nullptr)
-   {
-      spxSnprintf(buf, sizeof(buf), "%-8.8s  %.15" REAL_FORMAT, name1, (Real) value1);
+static void MPSwriteRecord(std::ostream &os, const char *indicator,
+                           const char *name, const char *name1 = nullptr,
+                           const R value1 = 0.0, const char *name2 = nullptr,
+                           const R value2 = 0.0) {
+  char buf[81];
+
+  spxSnprintf(buf, sizeof(buf), " %-2.2s %-8.8s",
+              (indicator == 0) ? "" : indicator, (name == 0) ? "" : name);
+  os << buf;
+
+  if (name1 != nullptr) {
+    spxSnprintf(buf, sizeof(buf), "%-8.8s  %.15" REAL_FORMAT, name1,
+                (Real)value1);
+    os << buf;
+
+    if (name2 != 0) {
+      spxSnprintf(buf, sizeof(buf), "   %-8.8s  %.15" REAL_FORMAT, name2,
+                  (Real)value2);
       os << buf;
+    }
+  }
 
-      if(name2 != 0)
-      {
-         spxSnprintf(buf, sizeof(buf), "   %-8.8s  %.15" REAL_FORMAT, name2, (Real) value2);
-         os << buf;
-      }
-   }
-
-   os << std::endl;
+  os << std::endl;
 }
 
+template <class R> static R MPSgetRHS(R left, R right) {
+  R rhsval;
 
+  if (left > R(-infinity)) /// This includes ranges
+    rhsval = left;
+  else if (right < R(infinity))
+    rhsval = right;
+  else
+    throw SPxInternalCodeException("XMPSWR01 This should never happen.");
 
-template <class R>
-static R MPSgetRHS(R left, R right)
-{
-   R rhsval;
-
-   if(left > R(-infinity))   /// This includes ranges
-      rhsval = left;
-   else if(right <  R(infinity))
-      rhsval = right;
-   else
-      throw SPxInternalCodeException("XMPSWR01 This should never happen.");
-
-   return rhsval;
+  return rhsval;
 }
 
-
 template <class R>
-static const char* MPSgetRowName(
-   const SPxLPBase<R>& lp,
-   int                   idx,
-   const NameSet*        rnames,
-   char*                 buf
-)
-{
-   assert(buf != 0);
-   assert(idx >= 0);
-   assert(idx <  lp.nRows());
+static const char *MPSgetRowName(const SPxLPBase<R> &lp, int idx,
+                                 const NameSet *rnames, char *buf) {
+  assert(buf != 0);
+  assert(idx >= 0);
+  assert(idx < lp.nRows());
 
-   if(rnames != 0)
-   {
-      DataKey key = lp.rId(idx);
+  if (rnames != 0) {
+    DataKey key = lp.rId(idx);
 
-      if(rnames->has(key))
-         return (*rnames)[key];
-   }
+    if (rnames->has(key))
+      return (*rnames)[key];
+  }
 
-   spxSnprintf(buf, 16, "C%d", idx);
+  spxSnprintf(buf, 16, "C%d", idx);
 
-   return buf;
+  return buf;
 }
 
-
-
 /// Write LP in MPS format.
 /** @note There will always be a BOUNDS section, even if there are no bounds.
  */
-template <class R> inline
-void SPxLPBase<R>::writeMPS(
-   std::ostream&  p_output,          ///< output stream.
-   const NameSet* p_rnames,          ///< row names.
-   const NameSet* p_cnames,          ///< column names.
-   const DIdxSet* p_intvars          ///< integer variables.
-) const
-{
-
-   const char*    indicator;
-   char           name [16];
-   char           name1[16];
-   char           name2[16];
-   bool           has_ranges = false;
-   int            i;
-   int            k;
-
-   SPxOut::setScientific(p_output, 16);
-   // --- NAME Section ---
-   p_output << "NAME          MPSDATA" << std::endl;
-
-   // --- ROWS Section ---
-   p_output << "ROWS" << std::endl;
-
-   for(i = 0; i < nRows(); i++)
-   {
-      if(lhs(i) == rhs(i))
-         indicator = "E";
-      else if((lhs(i) > R(-infinity)) && (rhs(i) < R(infinity)))
-      {
-         indicator = "E";
-         has_ranges = true;
-      }
-      else if(lhs(i) > R(-infinity))
-         indicator = "G";
-      else if(rhs(i) <  R(infinity))
-         indicator = "L";
-      else
-         throw SPxInternalCodeException("XMPSWR02 This should never happen.");
-
-      MPSwriteRecord<R>(p_output, indicator, MPSgetRowName(*this, i, p_rnames, name));
-   }
-
-   MPSwriteRecord<R>(p_output, "N", "MINIMIZE");
-
-   // --- COLUMNS Section ---
-   p_output << "COLUMNS" << std::endl;
-
-   bool has_intvars = (p_intvars != 0) && (p_intvars->size() > 0);
-
-   for(int j = 0; j < (has_intvars ? 2 : 1); j++)
-   {
-      bool is_intrun = has_intvars && (j == 1);
-
-      if(is_intrun)
-         p_output << "    MARK0001  'MARKER'                 'INTORG'" << std::endl;
-
-      for(i = 0; i < nCols(); i++)
-      {
-         bool is_intvar = has_intvars && (p_intvars->pos(i) >= 0);
-
-         if((is_intrun && !is_intvar) || (!is_intrun &&  is_intvar))
-            continue;
-
-         const SVectorBase<R>& col = colVector(i);
-         int colsize2 = (col.size() / 2) * 2;
-
-         assert(colsize2 % 2 == 0);
-
-         for(k = 0; k < colsize2; k += 2)
-            MPSwriteRecord(p_output, 0, getColName(*this, i, p_cnames, name),
-                           MPSgetRowName(*this, col.index(k), p_rnames, name1), col.value(k),
-                           MPSgetRowName(*this, col.index(k + 1), p_rnames, name2), col.value(k + 1));
-
-         if(colsize2 != col.size())
-            MPSwriteRecord(p_output, 0, getColName(*this, i, p_cnames, name),
-                           MPSgetRowName(*this, col.index(k), p_rnames, name1), col.value(k));
-
-         if(isNotZero(maxObj(i)))
-            MPSwriteRecord(p_output, 0, getColName(*this, i, p_cnames, name), "MINIMIZE", -maxObj(i));
-      }
-
-      if(is_intrun)
-         p_output << "    MARK0001  'MARKER'                 'INTEND'" << std::endl;
-   }
-
-   // --- RHS Section ---
-   p_output << "RHS" << std::endl;
-
-   i = 0;
-
-   while(i < nRows())
-   {
-      R rhsval1 = 0.0;
-      R rhsval2 = 0.0;
-
-      for(; i < nRows(); i++)
-         if((rhsval1 = MPSgetRHS(lhs(i), rhs(i))) != 0.0)
-            break;
-
-      if(i < nRows())
-      {
-         for(k = i + 1; k < nRows(); k++)
-         {
-            if((rhsval2 = MPSgetRHS(lhs(k), rhs(k))) != 0.0)
-               break;
-         }
-
-         if(k < nRows())
-         {
-            MPSwriteRecord(p_output, 0, "RHS", MPSgetRowName(*this, i, p_rnames, name1), rhsval1,
-                           MPSgetRowName(*this, k, p_rnames, name2), rhsval2);
-         }
-         else
-            MPSwriteRecord(p_output, 0, "RHS", MPSgetRowName(*this, i, p_rnames, name1), rhsval1);
-
-         i = k + 1;
-      }
-   }
-
-   // --- RANGES Section ---
-   if(has_ranges)
-   {
-      p_output << "RANGES" << std::endl;
-
-      for(i = 0; i < nRows(); i++)
-      {
-         if((lhs(i) > R(-infinity)) && (rhs(i) < R(infinity)))
-            MPSwriteRecord(p_output, "", "RANGE", MPSgetRowName(*this, i, p_rnames, name1), rhs(i) - lhs(i));
-      }
-   }
-
-   // --- BOUNDS Section ---
-   p_output << "BOUNDS" << std::endl;
-
-   for(i = 0; i < nCols(); i++)
-   {
-      // skip variables that do not appear in the objective function or any constraint
-      const SVectorBase<R>& col = colVector(i);
-
-      if(col.size() == 0 && isZero(maxObj(i)))
-         continue;
-
-      if(lower(i) == upper(i))
-      {
-         MPSwriteRecord(p_output, "FX", "BOUND", getColName(*this, i, p_cnames, name1), lower(i));
-         continue;
-      }
-
-      if((lower(i) <= R(-infinity)) && (upper(i) >= R(infinity)))
-      {
-         MPSwriteRecord<R>(p_output, "FR", "BOUND", getColName(*this, i, p_cnames, name1));
-         continue;
-      }
-
-      if(lower(i) != 0.0)
-      {
-         if(lower(i) > R(-infinity))
-            MPSwriteRecord(p_output, "LO", "BOUND", getColName(*this, i, p_cnames, name1), lower(i));
-         else
-            MPSwriteRecord<R>(p_output, "MI", "BOUND", getColName(*this, i, p_cnames, name1));
-      }
-
-      if(has_intvars && (p_intvars->pos(i) >= 0))
-      {
-         // Integer variables have default upper bound 1.0, but we should write
-         // it nevertheless since CPLEX seems to assume R(infinity) otherwise.
-         MPSwriteRecord(p_output, "UP", "BOUND", getColName(*this, i, p_cnames, name1), upper(i));
-      }
+template <class R>
+inline void
+SPxLPBase<R>::writeMPS(std::ostream &p_output,  ///< output stream.
+                       const NameSet *p_rnames, ///< row names.
+                       const NameSet *p_cnames, ///< column names.
+                       const DIdxSet *p_intvars ///< integer variables.
+) const {
+
+  const char *indicator;
+  char name[16];
+  char name1[16];
+  char name2[16];
+  bool has_ranges = false;
+  int i;
+  int k;
+
+  SPxOut::setScientific(p_output, 16);
+  // --- NAME Section ---
+  p_output << "NAME          MPSDATA" << std::endl;
+
+  // --- ROWS Section ---
+  p_output << "ROWS" << std::endl;
+
+  for (i = 0; i < nRows(); i++) {
+    if (lhs(i) == rhs(i))
+      indicator = "E";
+    else if ((lhs(i) > R(-infinity)) && (rhs(i) < R(infinity))) {
+      indicator = "E";
+      has_ranges = true;
+    } else if (lhs(i) > R(-infinity))
+      indicator = "G";
+    else if (rhs(i) < R(infinity))
+      indicator = "L";
+    else
+      throw SPxInternalCodeException("XMPSWR02 This should never happen.");
+
+    MPSwriteRecord<R>(p_output, indicator,
+                      MPSgetRowName(*this, i, p_rnames, name));
+  }
+
+  MPSwriteRecord<R>(p_output, "N", "MINIMIZE");
+
+  // --- COLUMNS Section ---
+  p_output << "COLUMNS" << std::endl;
+
+  bool has_intvars = (p_intvars != 0) && (p_intvars->size() > 0);
+
+  for (int j = 0; j < (has_intvars ? 2 : 1); j++) {
+    bool is_intrun = has_intvars && (j == 1);
+
+    if (is_intrun)
+      p_output << "    MARK0001  'MARKER'                 'INTORG'"
+               << std::endl;
+
+    for (i = 0; i < nCols(); i++) {
+      bool is_intvar = has_intvars && (p_intvars->pos(i) >= 0);
+
+      if ((is_intrun && !is_intvar) || (!is_intrun && is_intvar))
+        continue;
+
+      const SVectorBase<R> &col = colVector(i);
+      int colsize2 = (col.size() / 2) * 2;
+
+      assert(colsize2 % 2 == 0);
+
+      for (k = 0; k < colsize2; k += 2)
+        MPSwriteRecord(p_output, 0, getColName(*this, i, p_cnames, name),
+                       MPSgetRowName(*this, col.index(k), p_rnames, name1),
+                       col.value(k),
+                       MPSgetRowName(*this, col.index(k + 1), p_rnames, name2),
+                       col.value(k + 1));
+
+      if (colsize2 != col.size())
+        MPSwriteRecord(p_output, 0, getColName(*this, i, p_cnames, name),
+                       MPSgetRowName(*this, col.index(k), p_rnames, name1),
+                       col.value(k));
+
+      if (isNotZero(maxObj(i)))
+        MPSwriteRecord(p_output, 0, getColName(*this, i, p_cnames, name),
+                       "MINIMIZE", -maxObj(i));
+    }
+
+    if (is_intrun)
+      p_output << "    MARK0001  'MARKER'                 'INTEND'"
+               << std::endl;
+  }
+
+  // --- RHS Section ---
+  p_output << "RHS" << std::endl;
+
+  i = 0;
+
+  while (i < nRows()) {
+    R rhsval1 = 0.0;
+    R rhsval2 = 0.0;
+
+    for (; i < nRows(); i++)
+      if ((rhsval1 = MPSgetRHS(lhs(i), rhs(i))) != 0.0)
+        break;
+
+    if (i < nRows()) {
+      for (k = i + 1; k < nRows(); k++) {
+        if ((rhsval2 = MPSgetRHS(lhs(k), rhs(k))) != 0.0)
+          break;
+      }
+
+      if (k < nRows()) {
+        MPSwriteRecord(p_output, 0, "RHS",
+                       MPSgetRowName(*this, i, p_rnames, name1), rhsval1,
+                       MPSgetRowName(*this, k, p_rnames, name2), rhsval2);
+      } else
+        MPSwriteRecord(p_output, 0, "RHS",
+                       MPSgetRowName(*this, i, p_rnames, name1), rhsval1);
+
+      i = k + 1;
+    }
+  }
+
+  // --- RANGES Section ---
+  if (has_ranges) {
+    p_output << "RANGES" << std::endl;
+
+    for (i = 0; i < nRows(); i++) {
+      if ((lhs(i) > R(-infinity)) && (rhs(i) < R(infinity)))
+        MPSwriteRecord(p_output, "", "RANGE",
+                       MPSgetRowName(*this, i, p_rnames, name1),
+                       rhs(i) - lhs(i));
+    }
+  }
+
+  // --- BOUNDS Section ---
+  p_output << "BOUNDS" << std::endl;
+
+  for (i = 0; i < nCols(); i++) {
+    // skip variables that do not appear in the objective function or any
+    // constraint
+    const SVectorBase<R> &col = colVector(i);
+
+    if (col.size() == 0 && isZero(maxObj(i)))
+      continue;
+
+    if (lower(i) == upper(i)) {
+      MPSwriteRecord(p_output, "FX", "BOUND",
+                     getColName(*this, i, p_cnames, name1), lower(i));
+      continue;
+    }
+
+    if ((lower(i) <= R(-infinity)) && (upper(i) >= R(infinity))) {
+      MPSwriteRecord<R>(p_output, "FR", "BOUND",
+                        getColName(*this, i, p_cnames, name1));
+      continue;
+    }
+
+    if (lower(i) != 0.0) {
+      if (lower(i) > R(-infinity))
+        MPSwriteRecord(p_output, "LO", "BOUND",
+                       getColName(*this, i, p_cnames, name1), lower(i));
       else
-      {
-         // Continous variables have default upper bound R(infinity)
-         if(upper(i) < R(infinity))
-            MPSwriteRecord(p_output, "UP", "BOUND", getColName(*this, i, p_cnames, name1), upper(i));
-      }
-   }
-
-   // --- ENDATA Section ---
-   p_output << "ENDATA" << std::endl;
-
-   // Output warning when writing a maximisation problem
-   if(spxSense() == SPxLPBase<R>::MAXIMIZE)
-   {
-      MSG_WARNING((*spxout), (*spxout) <<
-                  "XMPSWR03 Warning: objective function inverted when writing maximization problem in MPS file format\n");
-   }
+        MPSwriteRecord<R>(p_output, "MI", "BOUND",
+                          getColName(*this, i, p_cnames, name1));
+    }
+
+    if (has_intvars && (p_intvars->pos(i) >= 0)) {
+      // Integer variables have default upper bound 1.0, but we should write
+      // it nevertheless since CPLEX seems to assume R(infinity) otherwise.
+      MPSwriteRecord(p_output, "UP", "BOUND",
+                     getColName(*this, i, p_cnames, name1), upper(i));
+    } else {
+      // Continous variables have default upper bound R(infinity)
+      if (upper(i) < R(infinity))
+        MPSwriteRecord(p_output, "UP", "BOUND",
+                       getColName(*this, i, p_cnames, name1), upper(i));
+    }
+  }
+
+  // --- ENDATA Section ---
+  p_output << "ENDATA" << std::endl;
+
+  // Output warning when writing a maximisation problem
+  if (spxSense() == SPxLPBase<R>::MAXIMIZE) {
+    MSG_WARNING(
+        (*spxout), (*spxout)
+                       << "XMPSWR03 Warning: objective function inverted when "
+                          "writing maximization problem in MPS file format\n");
+  }
 }
 
-
-
 /// Building the dual problem from a given LP
-/// @note primalRows must be as large as the number of unranged primal rows + 2 * the number of ranged primal rows.
+/// @note primalRows must be as large as the number of unranged primal rows + 2
+/// * the number of ranged primal rows.
 ///       dualCols must have the identical size to the primal rows.
-template <class R> inline
-void SPxLPBase<R>::buildDualProblem(SPxLPBase<R>& dualLP, SPxRowId primalRowIds[],
-                                    SPxColId primalColIds[],
-                                    SPxRowId dualRowIds[], SPxColId dualColIds[], int* nprimalrows, int* nprimalcols, int* ndualrows,
-                                    int* ndualcols)
-{
-   // Setting up the primalrowids and dualcolids arrays if not given as parameters
-   if(primalRowIds == 0 || primalColIds == 0 || dualRowIds == 0 || dualColIds == 0)
-   {
-      DataArray < SPxRowId > primalrowids(2 * nRows());
-      DataArray < SPxColId > primalcolids(2 * nCols());
-      DataArray < SPxRowId > dualrowids(2 * nCols());
-      DataArray < SPxColId > dualcolids(2 * nRows());
-      int numprimalrows = 0;
-      int numprimalcols = 0;
-      int numdualrows = 0;
-      int numdualcols = 0;
-
-      buildDualProblem(dualLP, primalrowids.get_ptr(), primalcolids.get_ptr(), dualrowids.get_ptr(),
-                       dualcolids.get_ptr(), &numprimalrows, &numprimalcols, &numdualrows, &numdualcols);
-
-      if(primalRowIds != 0)
-      {
-         primalRowIds = primalrowids.get_ptr();
-         (*nprimalrows) = numprimalrows;
-      }
+template <class R>
+inline void SPxLPBase<R>::buildDualProblem(
+    SPxLPBase<R> &dualLP, SPxRowId primalRowIds[], SPxColId primalColIds[],
+    SPxRowId dualRowIds[], SPxColId dualColIds[], int *nprimalrows,
+    int *nprimalcols, int *ndualrows, int *ndualcols) {
+  // Setting up the primalrowids and dualcolids arrays if not given as
+  // parameters
+  if (primalRowIds == 0 || primalColIds == 0 || dualRowIds == 0 ||
+      dualColIds == 0) {
+    DataArray<SPxRowId> primalrowids(2 * nRows());
+    DataArray<SPxColId> primalcolids(2 * nCols());
+    DataArray<SPxRowId> dualrowids(2 * nCols());
+    DataArray<SPxColId> dualcolids(2 * nRows());
+    int numprimalrows = 0;
+    int numprimalcols = 0;
+    int numdualrows = 0;
+    int numdualcols = 0;
+
+    buildDualProblem(dualLP, primalrowids.get_ptr(), primalcolids.get_ptr(),
+                     dualrowids.get_ptr(), dualcolids.get_ptr(), &numprimalrows,
+                     &numprimalcols, &numdualrows, &numdualcols);
+
+    if (primalRowIds != 0) {
+      primalRowIds = primalrowids.get_ptr();
+      (*nprimalrows) = numprimalrows;
+    }
+
+    if (primalColIds != 0) {
+      primalColIds = primalcolids.get_ptr();
+      (*nprimalcols) = numprimalcols;
+    }
+
+    if (dualRowIds != 0) {
+      dualRowIds = dualrowids.get_ptr();
+      (*ndualrows) = numdualrows;
+    }
+
+    if (dualColIds != 0) {
+      dualColIds = dualcolids.get_ptr();
+      (*ndualcols) = numdualcols;
+    }
+
+    return;
+  }
+
+  // setting the sense of the dual LP
+  if (spxSense() == MINIMIZE)
+    dualLP.changeSense(MAXIMIZE);
+  else
+    dualLP.changeSense(MINIMIZE);
+
+  LPRowSetBase<R> dualrows(nCols());
+  LPColSetBase<R> dualcols(nRows());
+  DSVectorBase<R> col(1);
+
+  int numAddedRows = 0;
+  int numVarBoundCols = 0;
+  int primalrowsidx = 0;
+  int primalcolsidx = 0;
+
+  for (int i = 0; i < nCols(); ++i) {
+    primalColIds[primalcolsidx] = cId(i);
+    primalcolsidx++;
+
+    if (lower(i) <= R(-infinity) &&
+        upper(i) >= R(infinity)) // unrestricted variables
+    {
+      dualrows.create(0, obj(i), obj(i));
+      numAddedRows++;
+    } else if (lower(i) <= R(-infinity)) // no lower bound is set, indicating a
+                                         // <= 0 variable
+    {
+      if (isZero(upper(i))) // standard bound variable
+      {
+        if (spxSense() == MINIMIZE)
+          dualrows.create(0, obj(i), R(infinity));
+        else
+          dualrows.create(0, R(-infinity), obj(i));
+      } else // additional upper bound on the variable
+      {
+        col.add(numAddedRows, 1.0);
+
+        if (spxSense() == MINIMIZE) {
+          dualrows.create(0, obj(i), obj(i));
+          dualcols.add(upper(i), R(-infinity), col, 0.0);
+        } else {
+          dualrows.create(0, obj(i), obj(i));
+          dualcols.add(upper(i), 0.0, col, R(infinity));
+        }
+
+        col.clear();
+
+        numVarBoundCols++;
+      }
+
+      numAddedRows++;
+    } else if (upper(i) >=
+               R(infinity)) // no upper bound set, indicating a >= 0 variable
+    {
+      if (isZero(lower(i))) // standard bound variable
+      {
+        if (spxSense() == MINIMIZE)
+          dualrows.create(0, R(-infinity), obj(i));
+        else
+          dualrows.create(0, obj(i), R(infinity));
+      } else // additional lower bound on the variable
+      {
+        col.add(numAddedRows, 1.0);
+
+        if (spxSense() == MINIMIZE) {
+          dualrows.create(0, obj(i), obj(i));
+          dualcols.add(lower(i), 0.0, col, R(infinity));
+        } else {
+          dualrows.create(0, obj(i), obj(i));
+          dualcols.add(lower(i), R(-infinity), col, 0.0);
+        }
+
+        col.clear();
+
+        numVarBoundCols++;
+      }
+
+      numAddedRows++;
+    } else if (NE(lower(i), upper(i))) // a boxed variable
+    {
+      if (isZero(lower(i))) // variable bounded between 0 and upper(i)
+      {
+        col.add(numAddedRows, 1.0);
+
+        if (spxSense() == MINIMIZE) {
+          dualrows.create(0, R(-infinity), obj(i));
+          dualcols.add(upper(i), R(-infinity), col, 0.0);
+        } else {
+          dualrows.create(0, obj(i), R(infinity));
+          dualcols.add(upper(i), 0.0, col, R(infinity));
+        }
+
+        col.clear();
+
+        numVarBoundCols++;
+      } else if (isZero(upper(i))) // variable bounded between lower(i) and 0
+      {
+        col.add(numAddedRows, 1.0);
+
+        if (spxSense() == MINIMIZE) {
+          dualrows.create(0, obj(i), R(infinity));
+          dualcols.add(lower(i), 0.0, col, R(infinity));
+        } else {
+          dualrows.create(0, R(-infinity), obj(i));
+          dualcols.add(lower(i), R(-infinity), col, 0.0);
+        }
+
+        col.clear();
+
+        numVarBoundCols++;
+      } else // variable bounded between lower(i) and upper(i)
+      {
+        dualrows.create(0, obj(i), obj(i));
+
+        col.add(numAddedRows, 1.0);
+
+        if (spxSense() == MINIMIZE) {
+          dualcols.add(lower(i), 0.0, col, R(infinity));
+          dualcols.add(upper(i), R(-infinity), col, 0.0);
+        } else {
+          dualcols.add(lower(i), R(-infinity), col, 0.0);
+          dualcols.add(upper(i), 0.0, col, R(infinity));
+        }
 
-      if(primalColIds != 0)
-      {
-         primalColIds = primalcolids.get_ptr();
-         (*nprimalcols) = numprimalcols;
-      }
+        col.clear();
 
-      if(dualRowIds != 0)
-      {
-         dualRowIds = dualrowids.get_ptr();
-         (*ndualrows) = numdualrows;
+        numVarBoundCols += 2;
       }
 
-      if(dualColIds != 0)
-      {
-         dualColIds = dualcolids.get_ptr();
-         (*ndualcols) = numdualcols;
-      }
+      numAddedRows++;
+    } else {
+      assert(lower(i) == upper(i));
 
-      return;
-   }
+      dualrows.create(0, obj(i), obj(i));
 
-   // setting the sense of the dual LP
-   if(spxSense() == MINIMIZE)
-      dualLP.changeSense(MAXIMIZE);
-   else
-      dualLP.changeSense(MINIMIZE);
+      col.add(numAddedRows, 1.0);
+      dualcols.add(lower(i), 0, col, R(infinity));
+      dualcols.add(lower(i), R(-infinity), col, 0);
+      col.clear();
 
-   LPRowSetBase<R> dualrows(nCols());
-   LPColSetBase<R> dualcols(nRows());
-   DSVectorBase<R> col(1);
+      numVarBoundCols += 2;
+      numAddedRows++;
+    }
+  }
 
-   int numAddedRows = 0;
-   int numVarBoundCols = 0;
-   int primalrowsidx = 0;
-   int primalcolsidx = 0;
+  // adding the empty rows to the dual LP
+  dualLP.addRows(dualrows);
 
-   for(int i = 0; i < nCols(); ++i)
-   {
-      primalColIds[primalcolsidx] = cId(i);
-      primalcolsidx++;
+  // setting the dual row ids for the related primal cols.
+  // this assumes that the rows are added in sequential order.
+  for (int i = 0; i < primalcolsidx; i++)
+    dualRowIds[i] = dualLP.rId(i);
 
-      if(lower(i) <= R(-infinity) && upper(i) >= R(infinity))   // unrestricted variables
-      {
-         dualrows.create(0, obj(i), obj(i));
-         numAddedRows++;
-      }
-      else if(lower(i) <= R(-infinity))   // no lower bound is set, indicating a <= 0 variable
-      {
-         if(isZero(upper(i)))   // standard bound variable
-         {
-            if(spxSense() == MINIMIZE)
-               dualrows.create(0, obj(i), R(infinity));
-            else
-               dualrows.create(0, R(-infinity), obj(i));
-         }
-         else // additional upper bound on the variable
-         {
-            col.add(numAddedRows, 1.0);
-
-            if(spxSense() == MINIMIZE)
-            {
-               dualrows.create(0, obj(i), obj(i));
-               dualcols.add(upper(i), R(-infinity), col, 0.0);
-            }
-            else
-            {
-               dualrows.create(0, obj(i), obj(i));
-               dualcols.add(upper(i), 0.0, col, R(infinity));
-            }
+  (*nprimalcols) = primalcolsidx;
+  (*ndualrows) = primalcolsidx;
 
-            col.clear();
+  // iterating over each of the rows to create dual columns
+  for (int i = 0; i < nRows(); ++i) {
+    // checking the type of the row
+    switch (rowType(i)) {
+    case LPRowBase<R>::RANGE: // range constraint, requires the addition of two
+                              // dual variables
+      assert(lhs(i) > R(-infinity));
+      assert(rhs(i) < R(infinity));
 
-            numVarBoundCols++;
-         }
+      if (spxSense() == MINIMIZE) {
+        primalRowIds[primalrowsidx] =
+            rId(i); // setting the rowid for the primal row
+        primalrowsidx++;
+        dualcols.add(lhs(i), 0.0, rowVector(i), R(infinity));
 
-         numAddedRows++;
-      }
-      else if(upper(i) >= R(infinity))   // no upper bound set, indicating a >= 0 variable
-      {
-         if(isZero(lower(i)))   // standard bound variable
-         {
-            if(spxSense() == MINIMIZE)
-               dualrows.create(0, R(-infinity), obj(i));
-            else
-               dualrows.create(0, obj(i), R(infinity));
-         }
-         else // additional lower bound on the variable
-         {
-            col.add(numAddedRows, 1.0);
-
-            if(spxSense() == MINIMIZE)
-            {
-               dualrows.create(0, obj(i), obj(i));
-               dualcols.add(lower(i), 0.0, col, R(infinity));
-            }
-            else
-            {
-               dualrows.create(0, obj(i), obj(i));
-               dualcols.add(lower(i), R(-infinity), col, 0.0);
-            }
-
-            col.clear();
-
-            numVarBoundCols++;
-         }
-
-         numAddedRows++;
-      }
-      else if(NE(lower(i), upper(i)))   // a boxed variable
-      {
-         if(isZero(lower(i)))   // variable bounded between 0 and upper(i)
-         {
-            col.add(numAddedRows, 1.0);
-
-            if(spxSense() == MINIMIZE)
-            {
-               dualrows.create(0, R(-infinity), obj(i));
-               dualcols.add(upper(i), R(-infinity), col, 0.0);
-            }
-            else
-            {
-               dualrows.create(0, obj(i), R(infinity));
-               dualcols.add(upper(i), 0.0, col, R(infinity));
-            }
-
-            col.clear();
-
-            numVarBoundCols++;
-         }
-         else if(isZero(upper(i)))   // variable bounded between lower(i) and 0
-         {
-            col.add(numAddedRows, 1.0);
-
-            if(spxSense() == MINIMIZE)
-            {
-               dualrows.create(0, obj(i), R(infinity));
-               dualcols.add(lower(i), 0.0, col, R(infinity));
-            }
-            else
-            {
-               dualrows.create(0, R(-infinity), obj(i));
-               dualcols.add(lower(i), R(-infinity), col, 0.0);
-            }
+        primalRowIds[primalrowsidx] =
+            rId(i); // setting the rowid for the primal row
+        primalrowsidx++;
+        dualcols.add(rhs(i), R(-infinity), rowVector(i), 0.0);
+      } else {
+        primalRowIds[primalrowsidx] =
+            rId(i); // setting the rowid for the primal row
+        primalrowsidx++;
+        dualcols.add(lhs(i), R(-infinity), rowVector(i), 0.0);
 
-            col.clear();
+        primalRowIds[primalrowsidx] =
+            rId(i); // setting the rowid for the primal row
+        primalrowsidx++;
+        dualcols.add(rhs(i), 0.0, rowVector(i), R(infinity));
+      }
 
-            numVarBoundCols++;
-         }
-         else // variable bounded between lower(i) and upper(i)
-         {
-            dualrows.create(0, obj(i), obj(i));
+      break;
 
-            col.add(numAddedRows, 1.0);
+    case LPRowBase<R>::GREATER_EQUAL: // >= constraint
+      assert(lhs(i) > R(-infinity));
+      primalRowIds[primalrowsidx] =
+          rId(i); // setting the rowid for the primal row
+      primalrowsidx++;
 
-            if(spxSense() == MINIMIZE)
-            {
-               dualcols.add(lower(i), 0.0, col, R(infinity));
-               dualcols.add(upper(i), R(-infinity), col, 0.0);
-            }
-            else
-            {
-               dualcols.add(lower(i), R(-infinity), col, 0.0);
-               dualcols.add(upper(i), 0.0, col, R(infinity));
-            }
-
-            col.clear();
-
-            numVarBoundCols += 2;
-         }
-
-         numAddedRows++;
-      }
+      if (spxSense() == MINIMIZE)
+        dualcols.add(lhs(i), 0.0, rowVector(i), R(infinity));
       else
-      {
-         assert(lower(i) == upper(i));
+        dualcols.add(lhs(i), R(-infinity), rowVector(i), 0.0);
 
-         dualrows.create(0, obj(i), obj(i));
+      break;
 
-         col.add(numAddedRows, 1.0);
-         dualcols.add(lower(i), 0, col, R(infinity));
-         dualcols.add(lower(i), R(-infinity), col, 0);
-         col.clear();
+    case LPRowBase<R>::LESS_EQUAL: // <= constriant
+      assert(rhs(i) < R(infinity));
+      primalRowIds[primalrowsidx] =
+          rId(i); // setting the rowid for the primal row
+      primalrowsidx++;
 
-         numVarBoundCols += 2;
-         numAddedRows++;
-      }
-   }
-
-   // adding the empty rows to the dual LP
-   dualLP.addRows(dualrows);
+      if (spxSense() == MINIMIZE)
+        dualcols.add(rhs(i), R(-infinity), rowVector(i), 0.0);
+      else
+        dualcols.add(rhs(i), 0.0, rowVector(i), R(infinity));
 
-   // setting the dual row ids for the related primal cols.
-   // this assumes that the rows are added in sequential order.
-   for(int i = 0; i < primalcolsidx; i++)
-      dualRowIds[i] = dualLP.rId(i);
+      break;
 
-   (*nprimalcols) = primalcolsidx;
-   (*ndualrows) = primalcolsidx;
+    case LPRowBase<R>::EQUAL: // Equality constraint
+      assert(EQ(lhs(i), rhs(i)));
+      primalRowIds[primalrowsidx] =
+          rId(i); // setting the rowid for the primal row
+      primalrowsidx++;
+      dualcols.add(rhs(i), R(-infinity), rowVector(i), R(infinity));
+      break;
 
-   // iterating over each of the rows to create dual columns
-   for(int i = 0; i < nRows(); ++i)
-   {
-      // checking the type of the row
-      switch(rowType(i))
-      {
-      case LPRowBase<R>::RANGE: // range constraint, requires the addition of two dual variables
-         assert(lhs(i) > R(-infinity));
-         assert(rhs(i) < R(infinity));
-
-         if(spxSense() == MINIMIZE)
-         {
-            primalRowIds[primalrowsidx] = rId(i); // setting the rowid for the primal row
-            primalrowsidx++;
-            dualcols.add(lhs(i), 0.0, rowVector(i), R(infinity));
-
-            primalRowIds[primalrowsidx] = rId(i); // setting the rowid for the primal row
-            primalrowsidx++;
-            dualcols.add(rhs(i), R(-infinity), rowVector(i), 0.0);
-         }
-         else
-         {
-            primalRowIds[primalrowsidx] = rId(i); // setting the rowid for the primal row
-            primalrowsidx++;
-            dualcols.add(lhs(i), R(-infinity), rowVector(i), 0.0);
-
-            primalRowIds[primalrowsidx] = rId(i); // setting the rowid for the primal row
-            primalrowsidx++;
-            dualcols.add(rhs(i), 0.0, rowVector(i), R(infinity));
-         }
-
-         break;
-
-      case LPRowBase<R>::GREATER_EQUAL: // >= constraint
-         assert(lhs(i) > R(-infinity));
-         primalRowIds[primalrowsidx] = rId(i); // setting the rowid for the primal row
-         primalrowsidx++;
-
-         if(spxSense() == MINIMIZE)
-            dualcols.add(lhs(i), 0.0, rowVector(i), R(infinity));
-         else
-            dualcols.add(lhs(i), R(-infinity), rowVector(i), 0.0);
-
-         break;
-
-      case LPRowBase<R>::LESS_EQUAL: // <= constriant
-         assert(rhs(i) < R(infinity));
-         primalRowIds[primalrowsidx] = rId(i); // setting the rowid for the primal row
-         primalrowsidx++;
-
-         if(spxSense() == MINIMIZE)
-            dualcols.add(rhs(i), R(-infinity), rowVector(i), 0.0);
-         else
-            dualcols.add(rhs(i), 0.0, rowVector(i), R(infinity));
-
-         break;
-
-      case LPRowBase<R>::EQUAL: // Equality constraint
-         assert(EQ(lhs(i), rhs(i)));
-         primalRowIds[primalrowsidx] = rId(i); // setting the rowid for the primal row
-         primalrowsidx++;
-         dualcols.add(rhs(i), R(-infinity), rowVector(i), R(infinity));
-         break;
-
-      default:
-         throw SPxInternalCodeException("XLPFRD01 This should never happen.");
-      }
-   }
+    default:
+      throw SPxInternalCodeException("XLPFRD01 This should never happen.");
+    }
+  }
 
-   // adding the filled columns to the dual LP
-   dualLP.addCols(dualcols);
+  // adding the filled columns to the dual LP
+  dualLP.addCols(dualcols);
 
-   // setting the dual column ids for the related primal rows.
-   // this assumes that the columns are added in sequential order.
-   for(int i = 0; i < primalrowsidx; i++)
-      dualColIds[i] = dualLP.cId(i + numVarBoundCols);
+  // setting the dual column ids for the related primal rows.
+  // this assumes that the columns are added in sequential order.
+  for (int i = 0; i < primalrowsidx; i++)
+    dualColIds[i] = dualLP.cId(i + numVarBoundCols);
 
-   (*nprimalrows) = primalrowsidx;
-   (*ndualcols) = primalrowsidx;
+  (*nprimalrows) = primalrowsidx;
+  (*ndualcols) = primalrowsidx;
 }
 
 } // namespace soplex
diff --git a/src/soplex/spxmainsm.hpp b/src/soplex/spxmainsm.hpp
index 186b595..199a910 100644
--- a/src/soplex/spxmainsm.hpp
+++ b/src/soplex/spxmainsm.hpp
@@ -21,6 +21,7 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <iostream>
 
@@ -28,5424 +29,5006 @@
 #include "soplex/dataarray.h"
 #include "soplex/sorter.h"
 #include "soplex/spxout.h"
-#include <sstream>
-#include <iostream>
 #include <fstream>
+#include <iostream>
 #include <memory>
+#include <sstream>
 
-
-//rows
-#define FREE_LHS_RHS            1
-#define FREE_CONSTRAINT         1
-#define EMPTY_CONSTRAINT        1
-#define ROW_SINGLETON           1
-#define AGGREGATE_VARS          1
-#define FORCE_CONSTRAINT        1
-//cols
-#define FREE_BOUNDS             1
-#define EMPTY_COLUMN            1
-#define FIX_VARIABLE            1
-#define FREE_ZERO_OBJ_VARIABLE  1
-#define ZERO_OBJ_COL_SINGLETON  1
-#define DOUBLETON_EQUATION      1
-#define FREE_COL_SINGLETON      1
-//dual
-#define DOMINATED_COLUMN        1
+// rows
+#define FREE_LHS_RHS 1
+#define FREE_CONSTRAINT 1
+#define EMPTY_CONSTRAINT 1
+#define ROW_SINGLETON 1
+#define AGGREGATE_VARS 1
+#define FORCE_CONSTRAINT 1
+// cols
+#define FREE_BOUNDS 1
+#define EMPTY_COLUMN 1
+#define FIX_VARIABLE 1
+#define FREE_ZERO_OBJ_VARIABLE 1
+#define ZERO_OBJ_COL_SINGLETON 1
+#define DOUBLETON_EQUATION 1
+#define FREE_COL_SINGLETON 1
+// dual
+#define DOMINATED_COLUMN 1
 #define WEAKLY_DOMINATED_COLUMN 1
-#define MULTI_AGGREGATE         1
-//other
-#define TRIVIAL_HEURISTICS      1
-#define PSEUDOOBJ               1
-
-
-#define EXTREMES                1
-#define ROWS_SPXMAINSM                    1
-#define COLS_SPXMAINSM                    1
-#define DUAL_SPXMAINSM                    1
-///@todo check: with this simplification step, the unsimplified basis seems to be slightly suboptimal for some instances
-#define DUPLICATE_ROWS          1
-#define DUPLICATE_COLS          1
-
+#define MULTI_AGGREGATE 1
+// other
+#define TRIVIAL_HEURISTICS 1
+#define PSEUDOOBJ 1
+
+#define EXTREMES 1
+#define ROWS_SPXMAINSM 1
+#define COLS_SPXMAINSM 1
+#define DUAL_SPXMAINSM 1
+///@todo check: with this simplification step, the unsimplified basis seems to
+///be slightly suboptimal for some instances
+#define DUPLICATE_ROWS 1
+#define DUPLICATE_COLS 1
 
 #ifndef NDEBUG
 #define CHECK_BASIC_DIM
-#endif  // NDEBUG
+#endif // NDEBUG
 
-namespace soplex
-{
+namespace soplex {
 
 template <class R>
-bool SPxMainSM<R>::PostStep::checkBasisDim(DataArray<typename SPxSolverBase<R>::VarStatus> rows,
-      DataArray<typename SPxSolverBase<R>::VarStatus> cols) const
-{
-   int numBasis = 0;
-
-   for(int rs = 0; rs < nRows; ++rs)
-   {
-      if(rows[rs] == SPxSolverBase<R>::BASIC)
-         numBasis++;
-   }
-
-   for(int cs = 0; cs < nCols; ++cs)
-   {
-      if(cols[cs] == SPxSolverBase<R>::BASIC)
-         numBasis++;
-   }
-
-   assert(numBasis == nRows);
-   return numBasis == nRows;
+bool SPxMainSM<R>::PostStep::checkBasisDim(
+    DataArray<typename SPxSolverBase<R>::VarStatus> rows,
+    DataArray<typename SPxSolverBase<R>::VarStatus> cols) const {
+  int numBasis = 0;
+
+  for (int rs = 0; rs < nRows; ++rs) {
+    if (rows[rs] == SPxSolverBase<R>::BASIC)
+      numBasis++;
+  }
+
+  for (int cs = 0; cs < nCols; ++cs) {
+    if (cols[cs] == SPxSolverBase<R>::BASIC)
+      numBasis++;
+  }
+
+  assert(numBasis == nRows);
+  return numBasis == nRows;
 }
 
 template <class R>
-void SPxMainSM<R>::RowObjPS::execute(VectorBase<R>& x, VectorBase<R>& y, VectorBase<R>& s,
-                                     VectorBase<R>&,
-                                     DataArray<typename SPxSolverBase<R>::VarStatus>& cStatus,
-                                     DataArray<typename SPxSolverBase<R>::VarStatus>& rStatus, bool isOptimal) const
-{
-   s[m_i] = s[m_i] - x[m_j];
-
-   assert(rStatus[m_i] != SPxSolverBase<R>::UNDEFINED);
-   assert(cStatus[m_j] != SPxSolverBase<R>::UNDEFINED);
-   assert(rStatus[m_i] != SPxSolverBase<R>::BASIC || cStatus[m_j] != SPxSolverBase<R>::BASIC);
-
-   MSG_DEBUG(std::cout << "RowObjPS: removing slack column " << m_j << " (" << cStatus[m_j] <<
-             ") for row " << m_i << " (" << rStatus[m_i] << ").\n");
-
-   if(rStatus[m_i] != SPxSolverBase<R>::BASIC)
-   {
-      switch(cStatus[m_j])
-      {
-      case SPxSolverBase<R>::ON_UPPER:
-         rStatus[m_i] = SPxSolverBase<R>::ON_LOWER;
-         break;
-
-      case SPxSolverBase<R>::ON_LOWER:
-         rStatus[m_i] = SPxSolverBase<R>::ON_UPPER;
-         break;
-
-      default:
-         rStatus[m_i] = cStatus[m_j];
-      }
+void SPxMainSM<R>::RowObjPS::execute(
+    VectorBase<R> &x, VectorBase<R> &y, VectorBase<R> &s, VectorBase<R> &,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &cStatus,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &rStatus,
+    bool isOptimal) const {
+  s[m_i] = s[m_i] - x[m_j];
+
+  assert(rStatus[m_i] != SPxSolverBase<R>::UNDEFINED);
+  assert(cStatus[m_j] != SPxSolverBase<R>::UNDEFINED);
+  assert(rStatus[m_i] != SPxSolverBase<R>::BASIC ||
+         cStatus[m_j] != SPxSolverBase<R>::BASIC);
+
+  MSG_DEBUG(std::cout << "RowObjPS: removing slack column " << m_j << " ("
+                      << cStatus[m_j] << ") for row " << m_i << " ("
+                      << rStatus[m_i] << ").\n");
+
+  if (rStatus[m_i] != SPxSolverBase<R>::BASIC) {
+    switch (cStatus[m_j]) {
+    case SPxSolverBase<R>::ON_UPPER:
+      rStatus[m_i] = SPxSolverBase<R>::ON_LOWER;
+      break;
 
-      // otherwise checkBasisDim() may fail
-      cStatus[m_j] = SPxSolverBase<R>::ZERO;
-   }
+    case SPxSolverBase<R>::ON_LOWER:
+      rStatus[m_i] = SPxSolverBase<R>::ON_UPPER;
+      break;
+
+    default:
+      rStatus[m_i] = cStatus[m_j];
+    }
+
+    // otherwise checkBasisDim() may fail
+    cStatus[m_j] = SPxSolverBase<R>::ZERO;
+  }
 
 #ifdef CHECK_BASIC_DIM
 
-   if(!this->checkBasisDim(rStatus, cStatus))
-   {
-      assert(false);
-      throw SPxInternalCodeException("XMAISM15 Dimension doesn't match after this step.");
-   }
+  if (!this->checkBasisDim(rStatus, cStatus)) {
+    assert(false);
+    throw SPxInternalCodeException(
+        "XMAISM15 Dimension doesn't match after this step.");
+  }
 
 #endif
 }
 
 template <class R>
-void SPxMainSM<R>::FreeConstraintPS::execute(VectorBase<R>& x, VectorBase<R>& y, VectorBase<R>& s,
-      VectorBase<R>&,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& cStatus,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& rStatus, bool isOptimal) const
-{
-   // correcting the change of idx by deletion of the row:
-   if(m_i != m_old_i)
-   {
-      s[m_old_i] = s[m_i];
-      y[m_old_i] = y[m_i];
-      rStatus[m_old_i] = rStatus[m_i];
-   }
+void SPxMainSM<R>::FreeConstraintPS::execute(
+    VectorBase<R> &x, VectorBase<R> &y, VectorBase<R> &s, VectorBase<R> &,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &cStatus,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &rStatus,
+    bool isOptimal) const {
+  // correcting the change of idx by deletion of the row:
+  if (m_i != m_old_i) {
+    s[m_old_i] = s[m_i];
+    y[m_old_i] = y[m_i];
+    rStatus[m_old_i] = rStatus[m_i];
+  }
 
-   // primal:
-   R slack = 0.0;
+  // primal:
+  R slack = 0.0;
 
-   for(int k = 0; k < m_row.size(); ++k)
-      slack += m_row.value(k) * x[m_row.index(k)];
+  for (int k = 0; k < m_row.size(); ++k)
+    slack += m_row.value(k) * x[m_row.index(k)];
 
-   s[m_i] = slack;
+  s[m_i] = slack;
 
-   // dual:
-   y[m_i] = m_row_obj;
+  // dual:
+  y[m_i] = m_row_obj;
 
-   // basis:
-   rStatus[m_i] = SPxSolverBase<R>::BASIC;
+  // basis:
+  rStatus[m_i] = SPxSolverBase<R>::BASIC;
 
 #ifdef CHECK_BASIC_DIM
 
-   if(!this->checkBasisDim(rStatus, cStatus))
-   {
-      throw SPxInternalCodeException("XMAISM15 Dimension doesn't match after this step.");
-   }
+  if (!this->checkBasisDim(rStatus, cStatus)) {
+    throw SPxInternalCodeException(
+        "XMAISM15 Dimension doesn't match after this step.");
+  }
 
 #endif
 }
 
 template <class R>
-void SPxMainSM<R>::EmptyConstraintPS::execute(VectorBase<R>&, VectorBase<R>& y, VectorBase<R>& s,
-      VectorBase<R>&,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& cStatus,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& rStatus, bool isOptimal) const
-{
-   // correcting the change of idx by deletion of the row:
-   if(m_i != m_old_i)
-   {
-      s[m_old_i] = s[m_i];
-      y[m_old_i] = y[m_i];
-      rStatus[m_old_i] = rStatus[m_i];
-   }
-
-   // primal:
-   s[m_i] = 0.0;
-
-   // dual:
-   y[m_i] = m_row_obj;
-
-   // basis:
-   rStatus[m_i] = SPxSolverBase<R>::BASIC;
+void SPxMainSM<R>::EmptyConstraintPS::execute(
+    VectorBase<R> &, VectorBase<R> &y, VectorBase<R> &s, VectorBase<R> &,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &cStatus,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &rStatus,
+    bool isOptimal) const {
+  // correcting the change of idx by deletion of the row:
+  if (m_i != m_old_i) {
+    s[m_old_i] = s[m_i];
+    y[m_old_i] = y[m_i];
+    rStatus[m_old_i] = rStatus[m_i];
+  }
+
+  // primal:
+  s[m_i] = 0.0;
+
+  // dual:
+  y[m_i] = m_row_obj;
+
+  // basis:
+  rStatus[m_i] = SPxSolverBase<R>::BASIC;
 
 #ifdef CHECK_BASIC_DIM
 
-   if(!this->checkBasisDim(rStatus, cStatus))
-   {
-      throw SPxInternalCodeException("XMAISM16 Dimension doesn't match after this step.");
-   }
+  if (!this->checkBasisDim(rStatus, cStatus)) {
+    throw SPxInternalCodeException(
+        "XMAISM16 Dimension doesn't match after this step.");
+  }
 
 #endif
 }
 
 template <class R>
-void SPxMainSM<R>::RowSingletonPS::execute(VectorBase<R>& x, VectorBase<R>& y, VectorBase<R>& s,
-      VectorBase<R>& r,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& cStatus,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& rStatus, bool isOptimal) const
-{
-   // correcting the change of idx by deletion of the row:
-   if(m_i != m_old_i)
-   {
-      y[m_old_i] = y[m_i];
-      s[m_old_i] = s[m_i];
-      rStatus[m_old_i] = rStatus[m_i];
-   }
-
-   R aij = m_col[m_i];
-   assert(aij != 0.0);
-
-   // primal:
-   s[m_i] = aij * x[m_j];
-
-   // dual & basis:
-   R val = m_obj;
-
-   for(int k = 0; k < m_col.size(); ++k)
-   {
-      if(m_col.index(k) != m_i)
-         val -= m_col.value(k) * y[m_col.index(k)];
-   }
-
-   R newLo = (aij > 0) ? m_lhs / aij : m_rhs / aij; // implicit lhs
-   R newUp = (aij > 0) ? m_rhs / aij : m_lhs / aij; // implicit rhs
-
-   switch(cStatus[m_j])
-   {
-   case SPxSolverBase<R>::FIXED:
-      if(newLo <= m_oldLo && newUp >= m_oldUp)
-      {
-         // this row is totally redundant, has not changed bound of xj
-         rStatus[m_i] = SPxSolverBase<R>::BASIC;
-         y[m_i] = m_row_obj;
-      }
-      else if(EQrel(newLo, newUp, this->eps()))
-      {
-         // row is in the type  aij * xj = b
-         assert(EQrel(newLo, x[m_j], this->eps()));
-
-         if(EQrel(m_oldLo, m_oldUp, this->eps()))
-         {
-            // xj has been fixed in other row
-            rStatus[m_i] = SPxSolverBase<R>::BASIC;
-            y[m_i] = m_row_obj;
-         }
-         else if((EQrel(m_oldLo, x[m_j], this->eps()) && r[m_j] <= -this->eps())
-                 || (EQrel(m_oldUp, x[m_j], this->eps()) && r[m_j] >= this->eps())
-                 || (!EQrel(m_oldLo, x[m_j], this->eps()) && !(EQrel(m_oldUp, x[m_j], this->eps()))))
-         {
-            // if x_j on lower but reduced cost is negative, or x_j on upper but reduced cost is positive, or x_j not on bound: basic
-            rStatus[m_i] = (EQrel(m_lhs, x[m_j] * aij,
-                                  this->eps())) ? SPxSolverBase<R>::ON_LOWER : SPxSolverBase<R>::ON_UPPER;
-            cStatus[m_j] = SPxSolverBase<R>::BASIC;
-            y[m_i] = val / aij;
-            r[m_j] = 0.0;
-         }
-         else
-         {
-            // set x_j on one of the bound
-            assert(EQrel(m_oldLo, x[m_j], this->eps()) || EQrel(m_oldUp, x[m_j], this->eps()));
-
-            cStatus[m_j] = EQrel(m_oldLo, x[m_j],
-                                 this->eps()) ? SPxSolverBase<R>::ON_LOWER : SPxSolverBase<R>::ON_UPPER;
-            rStatus[m_i] = SPxSolverBase<R>::BASIC;
-            y[m_i] = m_row_obj;
-            r[m_j] = val;
-         }
-      }
-      else if(EQrel(newLo, m_oldUp, this->eps()))
-      {
-         // row is in the type  xj >= b/aij, try to set xj on upper
-         if(r[m_j] >= this->eps())
-         {
-            // the reduced cost is positive, xj should in the basic
-            assert(EQrel(m_rhs / aij, x[m_j], this->eps()) || EQrel(m_lhs / aij, x[m_j], this->eps()));
-
-            rStatus[m_i] = (EQrel(m_lhs / aij, x[m_j],
-                                  this->eps())) ? SPxSolverBase<R>::ON_LOWER : SPxSolverBase<R>::ON_UPPER;
-            cStatus[m_j] = SPxSolverBase<R>::BASIC;
-            y[m_i] = val / aij;
-            r[m_j] = 0.0;
-         }
-         else
-         {
-            assert(EQrel(m_oldUp, x[m_j], this->eps()));
-
-            cStatus[m_j] = SPxSolverBase<R>::ON_UPPER;
-            rStatus[m_i] = SPxSolverBase<R>::BASIC;
-            y[m_i] = m_row_obj;
-            r[m_j] = val;
-         }
-      }
-      else if(EQrel(newUp, m_oldLo, this->eps()))
-      {
-         // row is in the type  xj <= b/aij, try to set xj on lower
-         if(r[m_j] <= -this->eps())
-         {
-            // the reduced cost is negative, xj should in the basic
-            assert(EQrel(m_rhs / aij, x[m_j], this->eps()) || EQrel(m_lhs / aij, x[m_j], this->eps()));
-
-            rStatus[m_i] = (EQrel(m_lhs / aij, x[m_j],
-                                  this->eps())) ? SPxSolverBase<R>::ON_LOWER : SPxSolverBase<R>::ON_UPPER;
-            cStatus[m_j] = SPxSolverBase<R>::BASIC;
-            y[m_i] = val / aij;
-            r[m_j] = 0.0;
-         }
-         else
-         {
-            assert(EQrel(m_oldLo, x[m_j], this->eps()));
-
-            cStatus[m_j] = SPxSolverBase<R>::ON_LOWER;
-            rStatus[m_i] = SPxSolverBase<R>::BASIC;
-            y[m_i] = m_row_obj;
-            r[m_j] = val;
-         }
-      }
-      else
-      {
-         // the variable is set to FIXED by other constraints, i.e., this singleton row is redundant
-         rStatus[m_i] = SPxSolverBase<R>::BASIC;
-         y[m_i] = m_row_obj;
-      }
+void SPxMainSM<R>::RowSingletonPS::execute(
+    VectorBase<R> &x, VectorBase<R> &y, VectorBase<R> &s, VectorBase<R> &r,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &cStatus,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &rStatus,
+    bool isOptimal) const {
+  // correcting the change of idx by deletion of the row:
+  if (m_i != m_old_i) {
+    y[m_old_i] = y[m_i];
+    s[m_old_i] = s[m_i];
+    rStatus[m_old_i] = rStatus[m_i];
+  }
+
+  R aij = m_col[m_i];
+  assert(aij != 0.0);
+
+  // primal:
+  s[m_i] = aij * x[m_j];
+
+  // dual & basis:
+  R val = m_obj;
+
+  for (int k = 0; k < m_col.size(); ++k) {
+    if (m_col.index(k) != m_i)
+      val -= m_col.value(k) * y[m_col.index(k)];
+  }
 
-      break;
+  R newLo = (aij > 0) ? m_lhs / aij : m_rhs / aij; // implicit lhs
+  R newUp = (aij > 0) ? m_rhs / aij : m_lhs / aij; // implicit rhs
 
-   case SPxSolverBase<R>::BASIC:
+  switch (cStatus[m_j]) {
+  case SPxSolverBase<R>::FIXED:
+    if (newLo <= m_oldLo && newUp >= m_oldUp) {
+      // this row is totally redundant, has not changed bound of xj
       rStatus[m_i] = SPxSolverBase<R>::BASIC;
       y[m_i] = m_row_obj;
-      r[m_j] = 0.0;
-      break;
+    } else if (EQrel(newLo, newUp, this->eps())) {
+      // row is in the type  aij * xj = b
+      assert(EQrel(newLo, x[m_j], this->eps()));
+
+      if (EQrel(m_oldLo, m_oldUp, this->eps())) {
+        // xj has been fixed in other row
+        rStatus[m_i] = SPxSolverBase<R>::BASIC;
+        y[m_i] = m_row_obj;
+      } else if ((EQrel(m_oldLo, x[m_j], this->eps()) &&
+                  r[m_j] <= -this->eps()) ||
+                 (EQrel(m_oldUp, x[m_j], this->eps()) &&
+                  r[m_j] >= this->eps()) ||
+                 (!EQrel(m_oldLo, x[m_j], this->eps()) &&
+                  !(EQrel(m_oldUp, x[m_j], this->eps())))) {
+        // if x_j on lower but reduced cost is negative, or x_j on upper but
+        // reduced cost is positive, or x_j not on bound: basic
+        rStatus[m_i] = (EQrel(m_lhs, x[m_j] * aij, this->eps()))
+                           ? SPxSolverBase<R>::ON_LOWER
+                           : SPxSolverBase<R>::ON_UPPER;
+        cStatus[m_j] = SPxSolverBase<R>::BASIC;
+        y[m_i] = val / aij;
+        r[m_j] = 0.0;
+      } else {
+        // set x_j on one of the bound
+        assert(EQrel(m_oldLo, x[m_j], this->eps()) ||
+               EQrel(m_oldUp, x[m_j], this->eps()));
+
+        cStatus[m_j] = EQrel(m_oldLo, x[m_j], this->eps())
+                           ? SPxSolverBase<R>::ON_LOWER
+                           : SPxSolverBase<R>::ON_UPPER;
+        rStatus[m_i] = SPxSolverBase<R>::BASIC;
+        y[m_i] = m_row_obj;
+        r[m_j] = val;
+      }
+    } else if (EQrel(newLo, m_oldUp, this->eps())) {
+      // row is in the type  xj >= b/aij, try to set xj on upper
+      if (r[m_j] >= this->eps()) {
+        // the reduced cost is positive, xj should in the basic
+        assert(EQrel(m_rhs / aij, x[m_j], this->eps()) ||
+               EQrel(m_lhs / aij, x[m_j], this->eps()));
+
+        rStatus[m_i] = (EQrel(m_lhs / aij, x[m_j], this->eps()))
+                           ? SPxSolverBase<R>::ON_LOWER
+                           : SPxSolverBase<R>::ON_UPPER;
+        cStatus[m_j] = SPxSolverBase<R>::BASIC;
+        y[m_i] = val / aij;
+        r[m_j] = 0.0;
+      } else {
+        assert(EQrel(m_oldUp, x[m_j], this->eps()));
+
+        cStatus[m_j] = SPxSolverBase<R>::ON_UPPER;
+        rStatus[m_i] = SPxSolverBase<R>::BASIC;
+        y[m_i] = m_row_obj;
+        r[m_j] = val;
+      }
+    } else if (EQrel(newUp, m_oldLo, this->eps())) {
+      // row is in the type  xj <= b/aij, try to set xj on lower
+      if (r[m_j] <= -this->eps()) {
+        // the reduced cost is negative, xj should in the basic
+        assert(EQrel(m_rhs / aij, x[m_j], this->eps()) ||
+               EQrel(m_lhs / aij, x[m_j], this->eps()));
+
+        rStatus[m_i] = (EQrel(m_lhs / aij, x[m_j], this->eps()))
+                           ? SPxSolverBase<R>::ON_LOWER
+                           : SPxSolverBase<R>::ON_UPPER;
+        cStatus[m_j] = SPxSolverBase<R>::BASIC;
+        y[m_i] = val / aij;
+        r[m_j] = 0.0;
+      } else {
+        assert(EQrel(m_oldLo, x[m_j], this->eps()));
+
+        cStatus[m_j] = SPxSolverBase<R>::ON_LOWER;
+        rStatus[m_i] = SPxSolverBase<R>::BASIC;
+        y[m_i] = m_row_obj;
+        r[m_j] = val;
+      }
+    } else {
+      // the variable is set to FIXED by other constraints, i.e., this singleton
+      // row is redundant
+      rStatus[m_i] = SPxSolverBase<R>::BASIC;
+      y[m_i] = m_row_obj;
+    }
 
-   case SPxSolverBase<R>::ON_LOWER:
-      if(EQrel(m_oldLo, x[m_j], this->eps())) // xj may stay on lower
-      {
-         rStatus[m_i] = SPxSolverBase<R>::BASIC;
-         y[m_i] = m_row_obj;
-         r[m_j] = val;
-      }
-      else // if reduced costs are negative or old lower bound not equal to xj, we need to change xj into the basis
-      {
-         assert(!isOptimal || EQrel(m_rhs / aij, x[m_j], this->eps())
-                || EQrel(m_lhs / aij, x[m_j], this->eps()));
-
-         cStatus[m_j] = SPxSolverBase<R>::BASIC;
-         rStatus[m_i] = (EQrel(m_lhs / aij, x[m_j],
-                               this->eps())) ? SPxSolverBase<R>::ON_LOWER : SPxSolverBase<R>::ON_UPPER;
-         y[m_i] = val / aij;
-         r[m_j] = 0.0;
-      }
+    break;
 
-      break;
+  case SPxSolverBase<R>::BASIC:
+    rStatus[m_i] = SPxSolverBase<R>::BASIC;
+    y[m_i] = m_row_obj;
+    r[m_j] = 0.0;
+    break;
 
-   case SPxSolverBase<R>::ON_UPPER:
-      if(EQrel(m_oldUp, x[m_j], this->eps())) // xj may stay on upper
-      {
-         rStatus[m_i] = SPxSolverBase<R>::BASIC;
-         y[m_i] = m_row_obj;
-         r[m_j] = val;
-      }
-      else // if reduced costs are positive or old upper bound not equal to xj, we need to change xj into the basis
-      {
-         assert(!isOptimal || EQrel(m_rhs / aij, x[m_j], this->eps())
-                || EQrel(m_lhs / aij, x[m_j], this->eps()));
-
-         cStatus[m_j] = SPxSolverBase<R>::BASIC;
-         rStatus[m_i] = (EQrel(m_lhs / aij, x[m_j],
-                               this->eps())) ? SPxSolverBase<R>::ON_LOWER : SPxSolverBase<R>::ON_UPPER;
-         y[m_i] = val / aij;
-         r[m_j] = 0.0;
-      }
+  case SPxSolverBase<R>::ON_LOWER:
+    if (EQrel(m_oldLo, x[m_j], this->eps())) // xj may stay on lower
+    {
+      rStatus[m_i] = SPxSolverBase<R>::BASIC;
+      y[m_i] = m_row_obj;
+      r[m_j] = val;
+    } else // if reduced costs are negative or old lower bound not equal to xj,
+           // we need to change xj into the basis
+    {
+      assert(!isOptimal || EQrel(m_rhs / aij, x[m_j], this->eps()) ||
+             EQrel(m_lhs / aij, x[m_j], this->eps()));
 
-      break;
+      cStatus[m_j] = SPxSolverBase<R>::BASIC;
+      rStatus[m_i] = (EQrel(m_lhs / aij, x[m_j], this->eps()))
+                         ? SPxSolverBase<R>::ON_LOWER
+                         : SPxSolverBase<R>::ON_UPPER;
+      y[m_i] = val / aij;
+      r[m_j] = 0.0;
+    }
 
-   case SPxSolverBase<R>::ZERO:
+    break;
+
+  case SPxSolverBase<R>::ON_UPPER:
+    if (EQrel(m_oldUp, x[m_j], this->eps())) // xj may stay on upper
+    {
       rStatus[m_i] = SPxSolverBase<R>::BASIC;
       y[m_i] = m_row_obj;
       r[m_j] = val;
-      break;
+    } else // if reduced costs are positive or old upper bound not equal to xj,
+           // we need to change xj into the basis
+    {
+      assert(!isOptimal || EQrel(m_rhs / aij, x[m_j], this->eps()) ||
+             EQrel(m_lhs / aij, x[m_j], this->eps()));
 
-   default:
-      break;
-   }
+      cStatus[m_j] = SPxSolverBase<R>::BASIC;
+      rStatus[m_i] = (EQrel(m_lhs / aij, x[m_j], this->eps()))
+                         ? SPxSolverBase<R>::ON_LOWER
+                         : SPxSolverBase<R>::ON_UPPER;
+      y[m_i] = val / aij;
+      r[m_j] = 0.0;
+    }
+
+    break;
+
+  case SPxSolverBase<R>::ZERO:
+    rStatus[m_i] = SPxSolverBase<R>::BASIC;
+    y[m_i] = m_row_obj;
+    r[m_j] = val;
+    break;
+
+  default:
+    break;
+  }
 
 #ifdef CHECK_BASIC_DIM
 
-   if(!this->checkBasisDim(rStatus, cStatus))
-   {
-      throw SPxInternalCodeException("XMAISM17 Dimension doesn't match after this step.");
-   }
+  if (!this->checkBasisDim(rStatus, cStatus)) {
+    throw SPxInternalCodeException(
+        "XMAISM17 Dimension doesn't match after this step.");
+  }
 
 #endif
 }
 
 template <class R>
-void SPxMainSM<R>::ForceConstraintPS::execute(VectorBase<R>& x, VectorBase<R>& y, VectorBase<R>& s,
-      VectorBase<R>& r,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& cStatus,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& rStatus, bool isOptimal) const
-{
-   // correcting the change of idx by deletion of the row:
-   if(m_i != m_old_i)
-   {
-      s[m_old_i] = s[m_i];
-      y[m_old_i] = y[m_i];
-      rStatus[m_old_i] = rStatus[m_i];
-   }
-
-   // primal:
-   s[m_i] = m_lRhs;
-
-   // basis:
-   int cBasisCandidate = -1;
-   R maxViolation = -1.0;
-   int bas_k = -1;
-
-   for(int k = 0; k < m_row.size(); ++k)
-   {
-      int  cIdx  = m_row.index(k);
-      R aij   = m_row.value(k);
-      R oldLo = m_oldLowers[k];
-      R oldUp = m_oldUppers[k];
-
-      switch(cStatus[cIdx])
-      {
-      case SPxSolverBase<R>::FIXED:
-         if(m_fixed[k])
-         {
-            assert(EQrel(oldLo, x[cIdx], this->eps()) || EQrel(oldUp, x[cIdx], this->eps()));
-
-            R violation = spxAbs(r[cIdx] / aij);
-
-            cStatus[cIdx] = EQrel(oldLo, x[cIdx],
-                                  this->eps()) ? SPxSolverBase<R>::ON_LOWER : SPxSolverBase<R>::ON_UPPER;
-
-            if(violation > maxViolation && ((EQrel(oldLo, x[cIdx], this->eps()) && r[cIdx] < -this->eps())
-                                            || (EQrel(oldUp, x[cIdx], this->eps()) && r[cIdx] > this->eps())))
-            {
-               maxViolation = violation;
-               cBasisCandidate = cIdx;
-               bas_k = k;
-            }
-         } // do nothing, if the old bounds are equal, i.e. variable has been not fixed in this row
-
-         break;
+void SPxMainSM<R>::ForceConstraintPS::execute(
+    VectorBase<R> &x, VectorBase<R> &y, VectorBase<R> &s, VectorBase<R> &r,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &cStatus,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &rStatus,
+    bool isOptimal) const {
+  // correcting the change of idx by deletion of the row:
+  if (m_i != m_old_i) {
+    s[m_old_i] = s[m_i];
+    y[m_old_i] = y[m_i];
+    rStatus[m_old_i] = rStatus[m_i];
+  }
+
+  // primal:
+  s[m_i] = m_lRhs;
+
+  // basis:
+  int cBasisCandidate = -1;
+  R maxViolation = -1.0;
+  int bas_k = -1;
+
+  for (int k = 0; k < m_row.size(); ++k) {
+    int cIdx = m_row.index(k);
+    R aij = m_row.value(k);
+    R oldLo = m_oldLowers[k];
+    R oldUp = m_oldUppers[k];
+
+    switch (cStatus[cIdx]) {
+    case SPxSolverBase<R>::FIXED:
+      if (m_fixed[k]) {
+        assert(EQrel(oldLo, x[cIdx], this->eps()) ||
+               EQrel(oldUp, x[cIdx], this->eps()));
+
+        R violation = spxAbs(r[cIdx] / aij);
+
+        cStatus[cIdx] = EQrel(oldLo, x[cIdx], this->eps())
+                            ? SPxSolverBase<R>::ON_LOWER
+                            : SPxSolverBase<R>::ON_UPPER;
+
+        if (violation > maxViolation &&
+            ((EQrel(oldLo, x[cIdx], this->eps()) && r[cIdx] < -this->eps()) ||
+             (EQrel(oldUp, x[cIdx], this->eps()) && r[cIdx] > this->eps()))) {
+          maxViolation = violation;
+          cBasisCandidate = cIdx;
+          bas_k = k;
+        }
+      } // do nothing, if the old bounds are equal, i.e. variable has been not
+        // fixed in this row
 
-      case SPxSolverBase<R>::ON_LOWER:
-      case SPxSolverBase<R>::ON_UPPER:
-      case SPxSolverBase<R>::BASIC:
-         break;
-
-      default:
-         break;
-      }
-   }
-
-   // dual and basis :
-   if(cBasisCandidate >= 0)  // one of the variable in the row should in the basis
-   {
-      assert(EQrel(m_lRhs, m_rhs, this->eps()) || EQrel(m_lRhs, m_lhs, this->eps()));
-      assert(bas_k >= 0);
-      assert(cBasisCandidate == m_row.index(bas_k));
-
-      cStatus[cBasisCandidate] = SPxSolverBase<R>::BASIC;
-      rStatus[m_i] = (EQrel(m_lRhs, m_lhs,
-                            this->eps())) ? SPxSolverBase<R>::ON_LOWER : SPxSolverBase<R>::ON_UPPER;
-
-      R aij = m_row.value(bas_k);
-      R multiplier = r[cBasisCandidate] / aij;
-      r[cBasisCandidate] = 0.0;
-
-      for(int k = 0; k < m_row.size(); ++k)  // update the reduced cost
-      {
-         if(k == bas_k)
-         {
-            continue;
-         }
-
-         r[m_row.index(k)] -= m_row.value(k) * multiplier;
-      }
-
-      // compute the value of new dual variable (because we have a new row)
-      R val = m_objs[bas_k];
-      DSVectorBase<R> basis_col = m_cols[bas_k];
+      break;
 
-      for(int k = 0; k < basis_col.size(); ++k)
-      {
-         if(basis_col.index(k) != m_i)
-            val -= basis_col.value(k) * y[basis_col.index(k)];
-      }
+    case SPxSolverBase<R>::ON_LOWER:
+    case SPxSolverBase<R>::ON_UPPER:
+    case SPxSolverBase<R>::BASIC:
+      break;
 
-      y[m_i] = val / aij;
-   }
-   else // slack in the basis
-   {
-      rStatus[m_i] = SPxSolverBase<R>::BASIC;
-      y[m_i] = m_rowobj;
-   }
+    default:
+      break;
+    }
+  }
+
+  // dual and basis :
+  if (cBasisCandidate >=
+      0) // one of the variable in the row should in the basis
+  {
+    assert(EQrel(m_lRhs, m_rhs, this->eps()) ||
+           EQrel(m_lRhs, m_lhs, this->eps()));
+    assert(bas_k >= 0);
+    assert(cBasisCandidate == m_row.index(bas_k));
+
+    cStatus[cBasisCandidate] = SPxSolverBase<R>::BASIC;
+    rStatus[m_i] = (EQrel(m_lRhs, m_lhs, this->eps()))
+                       ? SPxSolverBase<R>::ON_LOWER
+                       : SPxSolverBase<R>::ON_UPPER;
+
+    R aij = m_row.value(bas_k);
+    R multiplier = r[cBasisCandidate] / aij;
+    r[cBasisCandidate] = 0.0;
+
+    for (int k = 0; k < m_row.size(); ++k) // update the reduced cost
+    {
+      if (k == bas_k) {
+        continue;
+      }
+
+      r[m_row.index(k)] -= m_row.value(k) * multiplier;
+    }
+
+    // compute the value of new dual variable (because we have a new row)
+    R val = m_objs[bas_k];
+    DSVectorBase<R> basis_col = m_cols[bas_k];
+
+    for (int k = 0; k < basis_col.size(); ++k) {
+      if (basis_col.index(k) != m_i)
+        val -= basis_col.value(k) * y[basis_col.index(k)];
+    }
+
+    y[m_i] = val / aij;
+  } else // slack in the basis
+  {
+    rStatus[m_i] = SPxSolverBase<R>::BASIC;
+    y[m_i] = m_rowobj;
+  }
 
 #ifdef CHECK_BASIC_DIM
 
-   if(!this->checkBasisDim(rStatus, cStatus))
-   {
-      throw SPxInternalCodeException("XMAISM18 Dimension doesn't match after this step.");
-   }
+  if (!this->checkBasisDim(rStatus, cStatus)) {
+    throw SPxInternalCodeException(
+        "XMAISM18 Dimension doesn't match after this step.");
+  }
 
 #endif
 }
 
 template <class R>
-void SPxMainSM<R>::FixVariablePS::execute(VectorBase<R>& x, VectorBase<R>& y, VectorBase<R>& s,
-      VectorBase<R>& r,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& cStatus,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& rStatus, bool isOptimal) const
-{
-   // update the index mapping; if m_correctIdx is false, we assume that this has happened already
-   if(m_correctIdx)
-   {
-      x[m_old_j] = x[m_j];
-      r[m_old_j] = r[m_j];
-      cStatus[m_old_j] = cStatus[m_j];
-   }
-
-   // primal:
-   x[m_j] = m_val;
-
-   for(int k = 0; k < m_col.size(); ++k)
-      s[m_col.index(k)] += m_col.value(k) * x[m_j];
-
-   // dual:
-   R val = m_obj;
-
-   for(int k = 0; k < m_col.size(); ++k)
-      val -= m_col.value(k) * y[m_col.index(k)];
-
-   r[m_j] = val;
-
-   // basis:
-   if(m_lower == m_upper)
-   {
-      assert(EQrel(m_lower, m_val));
-
-      cStatus[m_j] = SPxSolverBase<R>::FIXED;
-   }
-   else
-   {
-      assert(EQrel(m_val, m_lower) || EQrel(m_val, m_upper) || m_val == 0.0);
-
-      cStatus[m_j] = EQrel(m_val, m_lower) ? SPxSolverBase<R>::ON_LOWER : (EQrel(m_val,
-                     m_upper) ? SPxSolverBase<R>::ON_UPPER : SPxSolverBase<R>::ZERO);
-   }
+void SPxMainSM<R>::FixVariablePS::execute(
+    VectorBase<R> &x, VectorBase<R> &y, VectorBase<R> &s, VectorBase<R> &r,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &cStatus,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &rStatus,
+    bool isOptimal) const {
+  // update the index mapping; if m_correctIdx is false, we assume that this has
+  // happened already
+  if (m_correctIdx) {
+    x[m_old_j] = x[m_j];
+    r[m_old_j] = r[m_j];
+    cStatus[m_old_j] = cStatus[m_j];
+  }
+
+  // primal:
+  x[m_j] = m_val;
+
+  for (int k = 0; k < m_col.size(); ++k)
+    s[m_col.index(k)] += m_col.value(k) * x[m_j];
+
+  // dual:
+  R val = m_obj;
+
+  for (int k = 0; k < m_col.size(); ++k)
+    val -= m_col.value(k) * y[m_col.index(k)];
+
+  r[m_j] = val;
+
+  // basis:
+  if (m_lower == m_upper) {
+    assert(EQrel(m_lower, m_val));
+
+    cStatus[m_j] = SPxSolverBase<R>::FIXED;
+  } else {
+    assert(EQrel(m_val, m_lower) || EQrel(m_val, m_upper) || m_val == 0.0);
+
+    cStatus[m_j] = EQrel(m_val, m_lower)
+                       ? SPxSolverBase<R>::ON_LOWER
+                       : (EQrel(m_val, m_upper) ? SPxSolverBase<R>::ON_UPPER
+                                                : SPxSolverBase<R>::ZERO);
+  }
 
 #ifdef CHECK_BASIC_DIM
 
-   if(m_correctIdx)
-   {
-      if(!this->checkBasisDim(rStatus, cStatus))
-      {
-         throw SPxInternalCodeException("XMAISM19 Dimension doesn't match after this step.");
-      }
-   }
+  if (m_correctIdx) {
+    if (!this->checkBasisDim(rStatus, cStatus)) {
+      throw SPxInternalCodeException(
+          "XMAISM19 Dimension doesn't match after this step.");
+    }
+  }
 
 #endif
 }
 
 template <class R>
-void SPxMainSM<R>::FixBoundsPS::execute(VectorBase<R>&, VectorBase<R>&, VectorBase<R>&,
-                                        VectorBase<R>&,
-                                        DataArray<typename SPxSolverBase<R>::VarStatus>& cStatus,
-                                        DataArray<typename SPxSolverBase<R>::VarStatus>&, bool isOptimal) const
-{
-   // basis:
-   cStatus[m_j] = m_status;
+void SPxMainSM<R>::FixBoundsPS::execute(
+    VectorBase<R> &, VectorBase<R> &, VectorBase<R> &, VectorBase<R> &,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &cStatus,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &, bool isOptimal) const {
+  // basis:
+  cStatus[m_j] = m_status;
 }
 
 template <class R>
-void SPxMainSM<R>::FreeZeroObjVariablePS::execute(VectorBase<R>& x, VectorBase<R>& y,
-      VectorBase<R>& s, VectorBase<R>& r,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& cStatus,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& rStatus, bool isOptimal) const
-{
-   // correcting the change of idx by deletion of the column and corresponding rows:
-   if(m_j != m_old_j)
-   {
-      x[m_old_j] = x[m_j];
-      r[m_old_j] = r[m_j];
-      cStatus[m_old_j] = cStatus[m_j];
-   }
-
-   int rIdx = m_old_i - m_col.size() + 1;
-
-   for(int k = 0; k < m_col.size(); ++k)
-   {
-      int rIdx_new = m_col.index(k);
-      s[rIdx] = s[rIdx_new];
-      y[rIdx] = y[rIdx_new];
-      rStatus[rIdx] = rStatus[rIdx_new];
-      rIdx++;
-   }
-
-   // primal:
-   int      domIdx = -1;
-   DSVectorBase<R> slack(m_col.size());
-
-   if(m_loFree)
-   {
-      R minRowUp = R(infinity);
-
-      for(int k = 0; k < m_rows.size(); ++k)
-      {
-         R           val = 0.0;
-         const SVectorBase<R>& row = m_rows[k];
-
-         for(int l = 0; l < row.size(); ++l)
-         {
-            if(row.index(l) != m_j)
-               val += row.value(l) * x[row.index(l)];
-         }
-
-         R scale = maxAbs(m_lRhs[k], val);
-
-         if(scale < 1.0)
-            scale = 1.0;
-
-         R z = (m_lRhs[k] / scale) - (val / scale);
-
-         if(isZero(z))
-            z = 0.0;
-
-         R up = z * scale / row[m_j];
-         slack.add(k, val);
-
-         if(up < minRowUp)
-         {
-            minRowUp = up;
-            domIdx   = k;
-         }
-      }
-
-      if(m_bnd < minRowUp)
-      {
-         x[m_j] = m_bnd;
-         domIdx = -1;
-      }
-      else
-         x[m_j] = minRowUp;
-   }
-   else
-   {
-      R maxRowLo = R(-infinity);
+void SPxMainSM<R>::FreeZeroObjVariablePS::execute(
+    VectorBase<R> &x, VectorBase<R> &y, VectorBase<R> &s, VectorBase<R> &r,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &cStatus,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &rStatus,
+    bool isOptimal) const {
+  // correcting the change of idx by deletion of the column and corresponding
+  // rows:
+  if (m_j != m_old_j) {
+    x[m_old_j] = x[m_j];
+    r[m_old_j] = r[m_j];
+    cStatus[m_old_j] = cStatus[m_j];
+  }
 
-      for(int k = 0; k < m_rows.size(); ++k)
-      {
-         R val = 0.0;
-         const SVectorBase<R>& row = m_rows[k];
+  int rIdx = m_old_i - m_col.size() + 1;
 
-         for(int l = 0; l < row.size(); ++l)
-         {
-            if(row.index(l) != m_j)
-               val += row.value(l) * x[row.index(l)];
-         }
+  for (int k = 0; k < m_col.size(); ++k) {
+    int rIdx_new = m_col.index(k);
+    s[rIdx] = s[rIdx_new];
+    y[rIdx] = y[rIdx_new];
+    rStatus[rIdx] = rStatus[rIdx_new];
+    rIdx++;
+  }
 
-         R scale = maxAbs(m_lRhs[k], val);
+  // primal:
+  int domIdx = -1;
+  DSVectorBase<R> slack(m_col.size());
 
-         if(scale < 1.0)
-            scale = 1.0;
+  if (m_loFree) {
+    R minRowUp = R(infinity);
 
-         R z = (m_lRhs[k] / scale) - (val / scale);
+    for (int k = 0; k < m_rows.size(); ++k) {
+      R val = 0.0;
+      const SVectorBase<R> &row = m_rows[k];
 
-         if(isZero(z))
-            z = 0.0;
-
-         R lo = z * scale / row[m_j];
-         slack.add(k, val);
-
-         if(lo > maxRowLo)
-         {
-            maxRowLo = lo;
-            domIdx   = k;
-         }
+      for (int l = 0; l < row.size(); ++l) {
+        if (row.index(l) != m_j)
+          val += row.value(l) * x[row.index(l)];
       }
 
-      if(m_bnd > maxRowLo)
-      {
-         x[m_j] = m_bnd;
-         domIdx = -1;
-      }
-      else
-         x[m_j] = maxRowLo;
-   }
+      R scale = maxAbs(m_lRhs[k], val);
 
-   for(int k = 0; k < m_col.size(); ++k)
-      s[m_col.index(k)] = slack[k] + m_col.value(k) * x[m_j];
+      if (scale < 1.0)
+        scale = 1.0;
 
-   // dual:
-   r[m_j] = 0.0;
+      R z = (m_lRhs[k] / scale) - (val / scale);
 
-   for(int k = 0; k < m_col.size(); ++k)
-   {
-      int idx = m_col.index(k);
-      y[idx] = m_rowObj[idx];
-   }
+      if (isZero(z))
+        z = 0.0;
 
-   // basis:
-   for(int k = 0; k < m_col.size(); ++k)
-   {
-      if(k != domIdx)
-         rStatus[m_col.index(k)] = SPxSolverBase<R>::BASIC;
+      R up = z * scale / row[m_j];
+      slack.add(k, val);
 
-      else
-      {
-         cStatus[m_j] = SPxSolverBase<R>::BASIC;
-
-         if(m_loFree)
-            rStatus[m_col.index(k)] = (m_col.value(k) > 0) ? SPxSolverBase<R>::ON_UPPER :
-                                      SPxSolverBase<R>::ON_LOWER;
-         else
-            rStatus[m_col.index(k)] = (m_col.value(k) > 0) ? SPxSolverBase<R>::ON_LOWER :
-                                      SPxSolverBase<R>::ON_UPPER;
+      if (up < minRowUp) {
+        minRowUp = up;
+        domIdx = k;
       }
-   }
+    }
 
-   if(domIdx == -1)
-   {
-      if(m_loFree)
-         cStatus[m_j] = SPxSolverBase<R>::ON_UPPER;
-      else
-         cStatus[m_j] = SPxSolverBase<R>::ON_LOWER;
-   }
-
-#ifdef CHECK_BASIC_DIM
+    if (m_bnd < minRowUp) {
+      x[m_j] = m_bnd;
+      domIdx = -1;
+    } else
+      x[m_j] = minRowUp;
+  } else {
+    R maxRowLo = R(-infinity);
 
-   if(!this->checkBasisDim(rStatus, cStatus))
-   {
-      throw SPxInternalCodeException("XMAISM20 Dimension doesn't match after this step.");
-   }
-
-#endif
-}
+    for (int k = 0; k < m_rows.size(); ++k) {
+      R val = 0.0;
+      const SVectorBase<R> &row = m_rows[k];
 
-template <class R>
-void SPxMainSM<R>::ZeroObjColSingletonPS::execute(VectorBase<R>& x, VectorBase<R>& y,
-      VectorBase<R>& s, VectorBase<R>& r,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& cStatus,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& rStatus, bool isOptimal) const
-{
-   // correcting the change of idx by deletion of the column and corresponding rows:
-   if(m_j != m_old_j)
-   {
-      x[m_old_j] = x[m_j];
-      r[m_old_j] = r[m_j];
-      cStatus[m_old_j] = cStatus[m_j];
-   }
-
-   // primal & basis:
-   R aij = m_row[m_j];
-
-   if(isZero(s[m_i], R(1e-6)))
-      s[m_i] = 0.0;
-   else if(s[m_i] >= R(infinity))
-      // this is a fix for a highly ill conditioned instance that is "solved" in presolving (ilaser0 from MINLP, mittelmann)
-      throw SPxException("Simplifier: infinite activities - aborting unsimplification");
-
-   R scale1 = maxAbs(m_lhs, s[m_i]);
-   R scale2 = maxAbs(m_rhs, s[m_i]);
-
-   if(scale1 < 1.0)
-      scale1 = 1.0;
+      for (int l = 0; l < row.size(); ++l) {
+        if (row.index(l) != m_j)
+          val += row.value(l) * x[row.index(l)];
+      }
 
-   if(scale2 < 1.0)
-      scale2 = 1.0;
+      R scale = maxAbs(m_lRhs[k], val);
 
-   R z1 = (m_lhs / scale1) - (s[m_i] / scale1);
-   R z2 = (m_rhs / scale2) - (s[m_i] / scale2);
+      if (scale < 1.0)
+        scale = 1.0;
 
-   if(isZero(z1))
-      z1 = 0.0;
+      R z = (m_lRhs[k] / scale) - (val / scale);
 
-   if(isZero(z2))
-      z2 = 0.0;
+      if (isZero(z))
+        z = 0.0;
 
-   R lo = (aij > 0) ? z1 * scale1 / aij : z2 * scale2 / aij;
-   R up = (aij > 0) ? z2 * scale2 / aij : z1 * scale1 / aij;
+      R lo = z * scale / row[m_j];
+      slack.add(k, val);
 
-   if(isZero(lo, this->eps()))
-      lo = 0.0;
+      if (lo > maxRowLo) {
+        maxRowLo = lo;
+        domIdx = k;
+      }
+    }
 
-   if(isZero(up, this->eps()))
-      up = 0.0;
+    if (m_bnd > maxRowLo) {
+      x[m_j] = m_bnd;
+      domIdx = -1;
+    } else
+      x[m_j] = maxRowLo;
+  }
 
-   assert(LErel(lo, up));
-   ASSERT_WARN("WMAISM01", isNotZero(aij, R(1.0 / R(infinity))));
+  for (int k = 0; k < m_col.size(); ++k)
+    s[m_col.index(k)] = slack[k] + m_col.value(k) * x[m_j];
 
-   if(rStatus[m_i] == SPxSolverBase<R>::ON_LOWER)
-   {
-      if(m_lower <= R(-infinity) && m_upper >= R(infinity))
-      {
-         x[m_j] = 0.0;
-         cStatus[m_j] = SPxSolverBase<R>::ZERO;
-      }
-      else if(m_lower == m_upper)
-      {
-         x[m_j]       = m_lower;
-         cStatus[m_j] = SPxSolverBase<R>::FIXED;
-      }
-      else if(aij > 0)
-      {
-         x[m_j]       = m_upper;
-         cStatus[m_j] = SPxSolverBase<R>::ON_UPPER;
-      }
-      else if(aij < 0)
-      {
-         x[m_j]       = m_lower;
-         cStatus[m_j] = SPxSolverBase<R>::ON_LOWER;
-      }
-      else
-         throw SPxInternalCodeException("XMAISM01 This should never happen.");
-   }
-   else if(rStatus[m_i] == SPxSolverBase<R>::ON_UPPER)
-   {
-      if(m_lower <= R(-infinity) && m_upper >= R(infinity))
-      {
-         x[m_j] = 0.0;
-         cStatus[m_j] = SPxSolverBase<R>::ZERO;
-      }
-      else if(m_lower == m_upper)
-      {
-         x[m_j]       = m_lower;
-         cStatus[m_j] = SPxSolverBase<R>::FIXED;
-      }
-      else if(aij > 0)
-      {
-         x[m_j]       = m_lower;
-         cStatus[m_j] = SPxSolverBase<R>::ON_LOWER;
-      }
-      else if(aij < 0)
-      {
-         x[m_j]       = m_upper;
-         cStatus[m_j] = SPxSolverBase<R>::ON_UPPER;
-      }
-      else
-         throw SPxInternalCodeException("XMAISM02 This should never happen.");
-   }
-   else if(rStatus[m_i] == SPxSolverBase<R>::FIXED)
-   {
-      if(m_lower <= R(-infinity) && m_upper >= R(infinity))
-      {
-         x[m_j] = 0.0;
-         cStatus[m_j] = SPxSolverBase<R>::ZERO;
-      }
-      else
-      {
-         assert(EQrel(m_lower, m_upper, this->eps()));
+  // dual:
+  r[m_j] = 0.0;
 
-         x[m_j]        = (m_lower + m_upper) / 2.0;
-         cStatus[m_j]  = SPxSolverBase<R>::FIXED;
-      }
-   }
-   else if(rStatus[m_i] == SPxSolverBase<R>::BASIC)
-   {
-      if(GErel(m_lower, lo, this->eps()) && m_lower > R(-infinity))
-      {
-         x[m_j]       = m_lower;
-         cStatus[m_j] = (m_lower == m_upper) ? SPxSolverBase<R>::FIXED : SPxSolverBase<R>::ON_LOWER;
-      }
-      else if(LErel(m_upper, up, this->eps()) && m_upper < R(infinity))
-      {
-         x[m_j]       = m_upper;
-         cStatus[m_j] = (m_lower == m_upper) ? SPxSolverBase<R>::FIXED : SPxSolverBase<R>::ON_UPPER;
-      }
-      else if(lo > R(-infinity))
-      {
-         // make m_i non-basic and m_j basic
-         x[m_j]       = lo;
-         cStatus[m_j] = SPxSolverBase<R>::BASIC;
-         rStatus[m_i] = (aij > 0 ? SPxSolverBase<R>::ON_LOWER : SPxSolverBase<R>::ON_UPPER);
-      }
-      else if(up < R(infinity))
-      {
-         // make m_i non-basic and m_j basic
-         x[m_j]       = up;
-         cStatus[m_j] = SPxSolverBase<R>::BASIC;
-         rStatus[m_i] = (aij > 0 ? SPxSolverBase<R>::ON_UPPER : SPxSolverBase<R>::ON_LOWER);
-      }
-      else
-         throw SPxInternalCodeException("XMAISM03 This should never happen.");
-   }
-   else
-      throw SPxInternalCodeException("XMAISM04 This should never happen.");
+  for (int k = 0; k < m_col.size(); ++k) {
+    int idx = m_col.index(k);
+    y[idx] = m_rowObj[idx];
+  }
 
-   s[m_i] += aij * x[m_j];
+  // basis:
+  for (int k = 0; k < m_col.size(); ++k) {
+    if (k != domIdx)
+      rStatus[m_col.index(k)] = SPxSolverBase<R>::BASIC;
 
-   // dual:
-   r[m_j] = -1.0 * aij * y[m_i];
+    else {
+      cStatus[m_j] = SPxSolverBase<R>::BASIC;
 
-   assert(!isOptimal || (cStatus[m_j] != SPxSolverBase<R>::BASIC || isZero(r[m_j], this->eps())));
+      if (m_loFree)
+        rStatus[m_col.index(k)] = (m_col.value(k) > 0)
+                                      ? SPxSolverBase<R>::ON_UPPER
+                                      : SPxSolverBase<R>::ON_LOWER;
+      else
+        rStatus[m_col.index(k)] = (m_col.value(k) > 0)
+                                      ? SPxSolverBase<R>::ON_LOWER
+                                      : SPxSolverBase<R>::ON_UPPER;
+    }
+  }
+
+  if (domIdx == -1) {
+    if (m_loFree)
+      cStatus[m_j] = SPxSolverBase<R>::ON_UPPER;
+    else
+      cStatus[m_j] = SPxSolverBase<R>::ON_LOWER;
+  }
 
 #ifdef CHECK_BASIC_DIM
 
-   if(!this->checkBasisDim(rStatus, cStatus))
-   {
-      throw SPxInternalCodeException("XMAISM21 Dimension doesn't match after this step.");
-   }
+  if (!this->checkBasisDim(rStatus, cStatus)) {
+    throw SPxInternalCodeException(
+        "XMAISM20 Dimension doesn't match after this step.");
+  }
 
 #endif
 }
 
 template <class R>
-void SPxMainSM<R>::FreeColSingletonPS::execute(VectorBase<R>& x, VectorBase<R>& y, VectorBase<R>& s,
-      VectorBase<R>& r,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& cStatus,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& rStatus, bool isOptimal) const
-{
-
-   // correcting the change of idx by deletion of the row:
-   if(m_i != m_old_i)
-   {
-      s[m_old_i] = s[m_i];
-      y[m_old_i] = y[m_i];
-      rStatus[m_old_i] = rStatus[m_i];
-   }
-
-   // correcting the change of idx by deletion of the column:
-   if(m_j != m_old_j)
-   {
-      x[m_old_j] = x[m_j];
-      r[m_old_j] = r[m_j];
-      cStatus[m_old_j] = cStatus[m_j];
-   }
-
-   // primal:
-   R val = 0.0;
-   R aij = m_row[m_j];
-
-   for(int k = 0; k < m_row.size(); ++k)
-   {
-      if(m_row.index(k) != m_j)
-         val += m_row.value(k) * x[m_row.index(k)];
-   }
-
-   R scale = maxAbs(m_lRhs, val);
-
-   if(scale < 1.0)
-      scale = 1.0;
-
-   R z = (m_lRhs / scale) - (val / scale);
-
-   if(isZero(z))
-      z = 0.0;
-
-   x[m_j] = z * scale / aij;
-   s[m_i] = m_lRhs;
-
-   // dual:
-   y[m_i] = m_obj / aij;
-   r[m_j] = 0.0;
-
-   // basis:
-   cStatus[m_j] = SPxSolverBase<R>::BASIC;
-
-   if(m_eqCons)
-      rStatus[m_i] = SPxSolverBase<R>::FIXED;
-   else if(m_onLhs)
-      rStatus[m_i] = SPxSolverBase<R>::ON_LOWER;
-   else
-      rStatus[m_i] = SPxSolverBase<R>::ON_UPPER;
+void SPxMainSM<R>::ZeroObjColSingletonPS::execute(
+    VectorBase<R> &x, VectorBase<R> &y, VectorBase<R> &s, VectorBase<R> &r,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &cStatus,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &rStatus,
+    bool isOptimal) const {
+  // correcting the change of idx by deletion of the column and corresponding
+  // rows:
+  if (m_j != m_old_j) {
+    x[m_old_j] = x[m_j];
+    r[m_old_j] = r[m_j];
+    cStatus[m_old_j] = cStatus[m_j];
+  }
+
+  // primal & basis:
+  R aij = m_row[m_j];
+
+  if (isZero(s[m_i], R(1e-6)))
+    s[m_i] = 0.0;
+  else if (s[m_i] >= R(infinity))
+    // this is a fix for a highly ill conditioned instance that is "solved" in
+    // presolving (ilaser0 from MINLP, mittelmann)
+    throw SPxException(
+        "Simplifier: infinite activities - aborting unsimplification");
+
+  R scale1 = maxAbs(m_lhs, s[m_i]);
+  R scale2 = maxAbs(m_rhs, s[m_i]);
+
+  if (scale1 < 1.0)
+    scale1 = 1.0;
+
+  if (scale2 < 1.0)
+    scale2 = 1.0;
+
+  R z1 = (m_lhs / scale1) - (s[m_i] / scale1);
+  R z2 = (m_rhs / scale2) - (s[m_i] / scale2);
+
+  if (isZero(z1))
+    z1 = 0.0;
+
+  if (isZero(z2))
+    z2 = 0.0;
+
+  R lo = (aij > 0) ? z1 * scale1 / aij : z2 * scale2 / aij;
+  R up = (aij > 0) ? z2 * scale2 / aij : z1 * scale1 / aij;
+
+  if (isZero(lo, this->eps()))
+    lo = 0.0;
+
+  if (isZero(up, this->eps()))
+    up = 0.0;
+
+  assert(LErel(lo, up));
+  ASSERT_WARN("WMAISM01", isNotZero(aij, R(1.0 / R(infinity))));
+
+  if (rStatus[m_i] == SPxSolverBase<R>::ON_LOWER) {
+    if (m_lower <= R(-infinity) && m_upper >= R(infinity)) {
+      x[m_j] = 0.0;
+      cStatus[m_j] = SPxSolverBase<R>::ZERO;
+    } else if (m_lower == m_upper) {
+      x[m_j] = m_lower;
+      cStatus[m_j] = SPxSolverBase<R>::FIXED;
+    } else if (aij > 0) {
+      x[m_j] = m_upper;
+      cStatus[m_j] = SPxSolverBase<R>::ON_UPPER;
+    } else if (aij < 0) {
+      x[m_j] = m_lower;
+      cStatus[m_j] = SPxSolverBase<R>::ON_LOWER;
+    } else
+      throw SPxInternalCodeException("XMAISM01 This should never happen.");
+  } else if (rStatus[m_i] == SPxSolverBase<R>::ON_UPPER) {
+    if (m_lower <= R(-infinity) && m_upper >= R(infinity)) {
+      x[m_j] = 0.0;
+      cStatus[m_j] = SPxSolverBase<R>::ZERO;
+    } else if (m_lower == m_upper) {
+      x[m_j] = m_lower;
+      cStatus[m_j] = SPxSolverBase<R>::FIXED;
+    } else if (aij > 0) {
+      x[m_j] = m_lower;
+      cStatus[m_j] = SPxSolverBase<R>::ON_LOWER;
+    } else if (aij < 0) {
+      x[m_j] = m_upper;
+      cStatus[m_j] = SPxSolverBase<R>::ON_UPPER;
+    } else
+      throw SPxInternalCodeException("XMAISM02 This should never happen.");
+  } else if (rStatus[m_i] == SPxSolverBase<R>::FIXED) {
+    if (m_lower <= R(-infinity) && m_upper >= R(infinity)) {
+      x[m_j] = 0.0;
+      cStatus[m_j] = SPxSolverBase<R>::ZERO;
+    } else {
+      assert(EQrel(m_lower, m_upper, this->eps()));
+
+      x[m_j] = (m_lower + m_upper) / 2.0;
+      cStatus[m_j] = SPxSolverBase<R>::FIXED;
+    }
+  } else if (rStatus[m_i] == SPxSolverBase<R>::BASIC) {
+    if (GErel(m_lower, lo, this->eps()) && m_lower > R(-infinity)) {
+      x[m_j] = m_lower;
+      cStatus[m_j] = (m_lower == m_upper) ? SPxSolverBase<R>::FIXED
+                                          : SPxSolverBase<R>::ON_LOWER;
+    } else if (LErel(m_upper, up, this->eps()) && m_upper < R(infinity)) {
+      x[m_j] = m_upper;
+      cStatus[m_j] = (m_lower == m_upper) ? SPxSolverBase<R>::FIXED
+                                          : SPxSolverBase<R>::ON_UPPER;
+    } else if (lo > R(-infinity)) {
+      // make m_i non-basic and m_j basic
+      x[m_j] = lo;
+      cStatus[m_j] = SPxSolverBase<R>::BASIC;
+      rStatus[m_i] =
+          (aij > 0 ? SPxSolverBase<R>::ON_LOWER : SPxSolverBase<R>::ON_UPPER);
+    } else if (up < R(infinity)) {
+      // make m_i non-basic and m_j basic
+      x[m_j] = up;
+      cStatus[m_j] = SPxSolverBase<R>::BASIC;
+      rStatus[m_i] =
+          (aij > 0 ? SPxSolverBase<R>::ON_UPPER : SPxSolverBase<R>::ON_LOWER);
+    } else
+      throw SPxInternalCodeException("XMAISM03 This should never happen.");
+  } else
+    throw SPxInternalCodeException("XMAISM04 This should never happen.");
+
+  s[m_i] += aij * x[m_j];
+
+  // dual:
+  r[m_j] = -1.0 * aij * y[m_i];
+
+  assert(!isOptimal || (cStatus[m_j] != SPxSolverBase<R>::BASIC ||
+                        isZero(r[m_j], this->eps())));
 
 #ifdef CHECK_BASIC_DIM
 
-   if(!this->checkBasisDim(rStatus, cStatus))
-   {
-      throw SPxInternalCodeException("XMAISM22 Dimension doesn't match after this step.");
-   }
+  if (!this->checkBasisDim(rStatus, cStatus)) {
+    throw SPxInternalCodeException(
+        "XMAISM21 Dimension doesn't match after this step.");
+  }
 
 #endif
 }
 
 template <class R>
-void SPxMainSM<R>::DoubletonEquationPS::execute(VectorBase<R>& x, VectorBase<R>& y, VectorBase<R>&,
-      VectorBase<R>& r,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& cStatus,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& rStatus, bool isOptimal) const
-{
-   // dual:
-   if((cStatus[m_k]  != SPxSolverBase<R>::BASIC) &&
-         ((cStatus[m_k] == SPxSolverBase<R>::ON_LOWER && m_strictLo) ||
-          (cStatus[m_k] == SPxSolverBase<R>::ON_UPPER && m_strictUp) ||
-          (cStatus[m_k] == SPxSolverBase<R>::FIXED    &&
-           ((m_maxSense && ((r[m_j] > 0 && m_strictUp) || (r[m_j] < 0 && m_strictLo))) ||
-            (!m_maxSense && ((r[m_j] > 0 && m_strictLo) || (r[m_j] < 0 && m_strictUp)))))))
-   {
-      R val  = m_kObj;
-      R aik  = m_col[m_i];
-
-      for(int _k = 0; _k < m_col.size(); ++_k)
-      {
-         if(m_col.index(_k) != m_i)
-            val -= m_col.value(_k) * y[m_col.index(_k)];
-      }
+void SPxMainSM<R>::FreeColSingletonPS::execute(
+    VectorBase<R> &x, VectorBase<R> &y, VectorBase<R> &s, VectorBase<R> &r,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &cStatus,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &rStatus,
+    bool isOptimal) const {
+
+  // correcting the change of idx by deletion of the row:
+  if (m_i != m_old_i) {
+    s[m_old_i] = s[m_i];
+    y[m_old_i] = y[m_i];
+    rStatus[m_old_i] = rStatus[m_i];
+  }
+
+  // correcting the change of idx by deletion of the column:
+  if (m_j != m_old_j) {
+    x[m_old_j] = x[m_j];
+    r[m_old_j] = r[m_j];
+    cStatus[m_old_j] = cStatus[m_j];
+  }
+
+  // primal:
+  R val = 0.0;
+  R aij = m_row[m_j];
+
+  for (int k = 0; k < m_row.size(); ++k) {
+    if (m_row.index(k) != m_j)
+      val += m_row.value(k) * x[m_row.index(k)];
+  }
+
+  R scale = maxAbs(m_lRhs, val);
+
+  if (scale < 1.0)
+    scale = 1.0;
+
+  R z = (m_lRhs / scale) - (val / scale);
+
+  if (isZero(z))
+    z = 0.0;
+
+  x[m_j] = z * scale / aij;
+  s[m_i] = m_lRhs;
+
+  // dual:
+  y[m_i] = m_obj / aij;
+  r[m_j] = 0.0;
+
+  // basis:
+  cStatus[m_j] = SPxSolverBase<R>::BASIC;
+
+  if (m_eqCons)
+    rStatus[m_i] = SPxSolverBase<R>::FIXED;
+  else if (m_onLhs)
+    rStatus[m_i] = SPxSolverBase<R>::ON_LOWER;
+  else
+    rStatus[m_i] = SPxSolverBase<R>::ON_UPPER;
 
-      y[m_i] = val / aik;
-      r[m_k] = 0.0;
+#ifdef CHECK_BASIC_DIM
 
-      r[m_j] = m_jObj - val * m_aij / aik;
+  if (!this->checkBasisDim(rStatus, cStatus)) {
+    throw SPxInternalCodeException(
+        "XMAISM22 Dimension doesn't match after this step.");
+  }
 
-      ASSERT_WARN("WMAISM73", isNotZero(m_aij * aik));
+#endif
+}
 
-      // basis:
-      if(m_jFixed)
-         cStatus[m_j] = SPxSolverBase<R>::FIXED;
+template <class R>
+void SPxMainSM<R>::DoubletonEquationPS::execute(
+    VectorBase<R> &x, VectorBase<R> &y, VectorBase<R> &, VectorBase<R> &r,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &cStatus,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &rStatus,
+    bool isOptimal) const {
+  // dual:
+  if ((cStatus[m_k] != SPxSolverBase<R>::BASIC) &&
+      ((cStatus[m_k] == SPxSolverBase<R>::ON_LOWER && m_strictLo) ||
+       (cStatus[m_k] == SPxSolverBase<R>::ON_UPPER && m_strictUp) ||
+       (cStatus[m_k] == SPxSolverBase<R>::FIXED &&
+        ((m_maxSense &&
+          ((r[m_j] > 0 && m_strictUp) || (r[m_j] < 0 && m_strictLo))) ||
+         (!m_maxSense &&
+          ((r[m_j] > 0 && m_strictLo) || (r[m_j] < 0 && m_strictUp))))))) {
+    R val = m_kObj;
+    R aik = m_col[m_i];
+
+    for (int _k = 0; _k < m_col.size(); ++_k) {
+      if (m_col.index(_k) != m_i)
+        val -= m_col.value(_k) * y[m_col.index(_k)];
+    }
+
+    y[m_i] = val / aik;
+    r[m_k] = 0.0;
+
+    r[m_j] = m_jObj - val * m_aij / aik;
+
+    ASSERT_WARN("WMAISM73", isNotZero(m_aij * aik));
+
+    // basis:
+    if (m_jFixed)
+      cStatus[m_j] = SPxSolverBase<R>::FIXED;
+    else {
+      if (GT(r[m_j], (R)0) || (isZero(r[m_j]) && EQ(x[m_j], m_Lo_j)))
+        cStatus[m_j] = SPxSolverBase<R>::ON_LOWER;
       else
-      {
-         if(GT(r[m_j], (R) 0) || (isZero(r[m_j]) && EQ(x[m_j], m_Lo_j)))
-            cStatus[m_j] = SPxSolverBase<R>::ON_LOWER;
-         else
-            cStatus[m_j] = SPxSolverBase<R>::ON_UPPER;
-      }
+        cStatus[m_j] = SPxSolverBase<R>::ON_UPPER;
+    }
 
-      cStatus[m_k] = SPxSolverBase<R>::BASIC;
-   }
+    cStatus[m_k] = SPxSolverBase<R>::BASIC;
+  }
 
 #ifdef CHECK_BASIC_DIM
 
-   if(!this->checkBasisDim(rStatus, cStatus))
-   {
-      throw SPxInternalCodeException("XMAISM23 Dimension doesn't match after this step.");
-   }
+  if (!this->checkBasisDim(rStatus, cStatus)) {
+    throw SPxInternalCodeException(
+        "XMAISM23 Dimension doesn't match after this step.");
+  }
 
 #endif
 }
 
 template <class R>
-void SPxMainSM<R>::DuplicateRowsPS::execute(VectorBase<R>&, VectorBase<R>& y, VectorBase<R>& s,
-      VectorBase<R>&,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& cStatus,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& rStatus, bool isOptimal) const
-{
-   // correcting the change of idx by deletion of the duplicated rows:
-   if(m_isLast)
-   {
-      for(int i = m_perm.size() - 1; i >= 0; --i)
-      {
-         if(m_perm[i] >= 0)
-         {
-            int rIdx_new = m_perm[i];
-            int rIdx = i;
-            s[rIdx] = s[rIdx_new];
-            y[rIdx] = y[rIdx_new];
-            rStatus[rIdx] = rStatus[rIdx_new];
-         }
-      }
-   }
-
-   // primal:
-   for(int k = 0; k < m_scale.size(); ++k)
-   {
-      if(m_scale.index(k) != m_i)
-         s[m_scale.index(k)] = s[m_i] / m_scale.value(k);
-   }
-
-   // dual & basis:
-   bool haveSetBasis = false;
-
-   for(int k = 0; k < m_scale.size(); ++k)
-   {
-      int i = m_scale.index(k);
-
-      if(rStatus[m_i] == SPxSolverBase<R>::BASIC || (haveSetBasis && i != m_i))
-         // if the row with tightest lower and upper bound in the basic, every duplicate row should in basic
-         // or basis status of row m_i has been set, this row should be in basis
-      {
-         y[i]       = m_rowObj.value(k);
-         rStatus[i] = SPxSolverBase<R>::BASIC;
-         continue;
-      }
-
-      ASSERT_WARN("WMAISM02", isNotZero(m_scale.value(k)));
-
-      if(rStatus[m_i] == SPxSolverBase<R>::FIXED && (i == m_maxLhsIdx || i == m_minRhsIdx))
-      {
-         // this row leads to the tightest lower or upper bound, slack should not be in the basis
-         y[i]   = y[m_i] * m_scale.value(k);
-         y[m_i] = m_i_rowObj;
-
-         if(m_isLhsEqualRhs[k])
-         {
-            rStatus[i] = SPxSolverBase<R>::FIXED;
-         }
-         else if(i == m_maxLhsIdx)
-         {
-            rStatus[i] = m_scale.value(k) * m_scale.value(0) > 0 ? SPxSolverBase<R>::ON_LOWER :
-                         SPxSolverBase<R>::ON_UPPER;
-         }
-         else
-         {
-            assert(i == m_minRhsIdx);
-
-            rStatus[i] = m_scale.value(k) * m_scale.value(0) > 0 ? SPxSolverBase<R>::ON_UPPER :
-                         SPxSolverBase<R>::ON_LOWER;
-         }
-
-         if(i != m_i)
-            rStatus[m_i] = SPxSolverBase<R>::BASIC;
-
-         haveSetBasis = true;
-      }
-      else if(i == m_maxLhsIdx && rStatus[m_i] == SPxSolverBase<R>::ON_LOWER)
-      {
-         // this row leads to the tightest lower bound, slack should not be in the basis
-         y[i]   = y[m_i] * m_scale.value(k);
-         y[m_i] = m_i_rowObj;
-
-         rStatus[i] = m_scale.value(k) * m_scale.value(0) > 0 ? SPxSolverBase<R>::ON_LOWER :
-                      SPxSolverBase<R>::ON_UPPER;
-
-         if(i != m_i)
-            rStatus[m_i] = SPxSolverBase<R>::BASIC;
-
-         haveSetBasis = true;
-      }
-      else if(i == m_minRhsIdx && rStatus[m_i] == SPxSolverBase<R>::ON_UPPER)
-      {
-         // this row leads to the tightest upper bound, slack should not be in the basis
-         y[i]   = y[m_i] * m_scale.value(k);
-         y[m_i] = m_i_rowObj;
-
-         rStatus[i] = m_scale.value(k) * m_scale.value(0) > 0 ? SPxSolverBase<R>::ON_UPPER :
-                      SPxSolverBase<R>::ON_LOWER;
-
-         if(i != m_i)
-            rStatus[m_i] = SPxSolverBase<R>::BASIC;
-
-         haveSetBasis = true;
-      }
-      else if(i != m_i)
-      {
-         // this row does not lead to the tightest lower or upper bound, slack should be in the basis
-         y[i]       = m_rowObj.value(k);
-         rStatus[i] = SPxSolverBase<R>::BASIC;
-      }
-   }
+void SPxMainSM<R>::DuplicateRowsPS::execute(
+    VectorBase<R> &, VectorBase<R> &y, VectorBase<R> &s, VectorBase<R> &,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &cStatus,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &rStatus,
+    bool isOptimal) const {
+  // correcting the change of idx by deletion of the duplicated rows:
+  if (m_isLast) {
+    for (int i = m_perm.size() - 1; i >= 0; --i) {
+      if (m_perm[i] >= 0) {
+        int rIdx_new = m_perm[i];
+        int rIdx = i;
+        s[rIdx] = s[rIdx_new];
+        y[rIdx] = y[rIdx_new];
+        rStatus[rIdx] = rStatus[rIdx_new];
+      }
+    }
+  }
+
+  // primal:
+  for (int k = 0; k < m_scale.size(); ++k) {
+    if (m_scale.index(k) != m_i)
+      s[m_scale.index(k)] = s[m_i] / m_scale.value(k);
+  }
+
+  // dual & basis:
+  bool haveSetBasis = false;
+
+  for (int k = 0; k < m_scale.size(); ++k) {
+    int i = m_scale.index(k);
+
+    if (rStatus[m_i] == SPxSolverBase<R>::BASIC || (haveSetBasis && i != m_i))
+    // if the row with tightest lower and upper bound in the basic, every
+    // duplicate row should in basic or basis status of row m_i has been set,
+    // this row should be in basis
+    {
+      y[i] = m_rowObj.value(k);
+      rStatus[i] = SPxSolverBase<R>::BASIC;
+      continue;
+    }
+
+    ASSERT_WARN("WMAISM02", isNotZero(m_scale.value(k)));
+
+    if (rStatus[m_i] == SPxSolverBase<R>::FIXED &&
+        (i == m_maxLhsIdx || i == m_minRhsIdx)) {
+      // this row leads to the tightest lower or upper bound, slack should not
+      // be in the basis
+      y[i] = y[m_i] * m_scale.value(k);
+      y[m_i] = m_i_rowObj;
+
+      if (m_isLhsEqualRhs[k]) {
+        rStatus[i] = SPxSolverBase<R>::FIXED;
+      } else if (i == m_maxLhsIdx) {
+        rStatus[i] = m_scale.value(k) * m_scale.value(0) > 0
+                         ? SPxSolverBase<R>::ON_LOWER
+                         : SPxSolverBase<R>::ON_UPPER;
+      } else {
+        assert(i == m_minRhsIdx);
+
+        rStatus[i] = m_scale.value(k) * m_scale.value(0) > 0
+                         ? SPxSolverBase<R>::ON_UPPER
+                         : SPxSolverBase<R>::ON_LOWER;
+      }
+
+      if (i != m_i)
+        rStatus[m_i] = SPxSolverBase<R>::BASIC;
+
+      haveSetBasis = true;
+    } else if (i == m_maxLhsIdx && rStatus[m_i] == SPxSolverBase<R>::ON_LOWER) {
+      // this row leads to the tightest lower bound, slack should not be in the
+      // basis
+      y[i] = y[m_i] * m_scale.value(k);
+      y[m_i] = m_i_rowObj;
+
+      rStatus[i] = m_scale.value(k) * m_scale.value(0) > 0
+                       ? SPxSolverBase<R>::ON_LOWER
+                       : SPxSolverBase<R>::ON_UPPER;
+
+      if (i != m_i)
+        rStatus[m_i] = SPxSolverBase<R>::BASIC;
+
+      haveSetBasis = true;
+    } else if (i == m_minRhsIdx && rStatus[m_i] == SPxSolverBase<R>::ON_UPPER) {
+      // this row leads to the tightest upper bound, slack should not be in the
+      // basis
+      y[i] = y[m_i] * m_scale.value(k);
+      y[m_i] = m_i_rowObj;
+
+      rStatus[i] = m_scale.value(k) * m_scale.value(0) > 0
+                       ? SPxSolverBase<R>::ON_UPPER
+                       : SPxSolverBase<R>::ON_LOWER;
+
+      if (i != m_i)
+        rStatus[m_i] = SPxSolverBase<R>::BASIC;
+
+      haveSetBasis = true;
+    } else if (i != m_i) {
+      // this row does not lead to the tightest lower or upper bound, slack
+      // should be in the basis
+      y[i] = m_rowObj.value(k);
+      rStatus[i] = SPxSolverBase<R>::BASIC;
+    }
+  }
 
 #ifdef CHECK_BASIC_DIM
 
-   if(m_isFirst && !this->checkBasisDim(rStatus, cStatus))
-   {
-      throw SPxInternalCodeException("XMAISM24 Dimension doesn't match after this step.");
-   }
+  if (m_isFirst && !this->checkBasisDim(rStatus, cStatus)) {
+    throw SPxInternalCodeException(
+        "XMAISM24 Dimension doesn't match after this step.");
+  }
 
 #endif
 
-   // nothing to do for the reduced cost values
+  // nothing to do for the reduced cost values
 }
 
 template <class R>
-void SPxMainSM<R>::DuplicateColsPS::execute(VectorBase<R>& x,
-      VectorBase<R>&,
-      VectorBase<R>&,
-      VectorBase<R>& r,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& cStatus,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& rStatus, bool isOptimal) const
-{
-
-   if(m_isFirst)
-   {
+void SPxMainSM<R>::DuplicateColsPS::execute(
+    VectorBase<R> &x, VectorBase<R> &, VectorBase<R> &, VectorBase<R> &r,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &cStatus,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &rStatus,
+    bool isOptimal) const {
+
+  if (m_isFirst) {
 #ifdef CHECK_BASIC_DIM
 
-      if(!this->checkBasisDim(rStatus, cStatus))
-      {
-         throw SPxInternalCodeException("XMAISM25 Dimension doesn't match after this step.");
-      }
+    if (!this->checkBasisDim(rStatus, cStatus)) {
+      throw SPxInternalCodeException(
+          "XMAISM25 Dimension doesn't match after this step.");
+    }
 
 #endif
-      return;
-   }
-
-
-   // correcting the change of idx by deletion of the columns:
-   if(m_isLast)
-   {
-      for(int i = m_perm.size() - 1; i >= 0; --i)
-      {
-         if(m_perm[i] >= 0)
-         {
-            int cIdx_new = m_perm[i];
-            int cIdx = i;
-            x[cIdx] = x[cIdx_new];
-            r[cIdx] = r[cIdx_new];
-            cStatus[cIdx] = cStatus[cIdx_new];
-         }
-      }
-
-      return;
-   }
-
-   // primal & basis:
-   ASSERT_WARN("WMAISM03", isNotZero(m_scale));
-
-   if(cStatus[m_k] == SPxSolverBase<R>::ON_LOWER)
-   {
-      x[m_k] = m_loK;
-
-      if(m_scale > 0)
-      {
-         x[m_j]       = m_loJ;
-         cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED : SPxSolverBase<R>::ON_LOWER;
-      }
-      else
-      {
-         x[m_j]       = m_upJ;
-         cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED : SPxSolverBase<R>::ON_UPPER;
-      }
-   }
-   else if(cStatus[m_k] == SPxSolverBase<R>::ON_UPPER)
-   {
-      x[m_k] = m_upK;
-
-      if(m_scale > 0)
-      {
-         x[m_j]       = m_upJ;
-         cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED : SPxSolverBase<R>::ON_UPPER;
-      }
-      else
-      {
-         x[m_j]       = m_loJ;
-         cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED : SPxSolverBase<R>::ON_LOWER;
-      }
-   }
-   else if(cStatus[m_k] == SPxSolverBase<R>::FIXED)
-   {
-      // => x[m_k] and x[m_j] are also fixed before the corresponding preprocessing step
-      x[m_j]       = m_loJ;
+    return;
+  }
+
+  // correcting the change of idx by deletion of the columns:
+  if (m_isLast) {
+    for (int i = m_perm.size() - 1; i >= 0; --i) {
+      if (m_perm[i] >= 0) {
+        int cIdx_new = m_perm[i];
+        int cIdx = i;
+        x[cIdx] = x[cIdx_new];
+        r[cIdx] = r[cIdx_new];
+        cStatus[cIdx] = cStatus[cIdx_new];
+      }
+    }
+
+    return;
+  }
+
+  // primal & basis:
+  ASSERT_WARN("WMAISM03", isNotZero(m_scale));
+
+  if (cStatus[m_k] == SPxSolverBase<R>::ON_LOWER) {
+    x[m_k] = m_loK;
+
+    if (m_scale > 0) {
+      x[m_j] = m_loJ;
+      cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED
+                                      : SPxSolverBase<R>::ON_LOWER;
+    } else {
+      x[m_j] = m_upJ;
+      cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED
+                                      : SPxSolverBase<R>::ON_UPPER;
+    }
+  } else if (cStatus[m_k] == SPxSolverBase<R>::ON_UPPER) {
+    x[m_k] = m_upK;
+
+    if (m_scale > 0) {
+      x[m_j] = m_upJ;
+      cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED
+                                      : SPxSolverBase<R>::ON_UPPER;
+    } else {
+      x[m_j] = m_loJ;
+      cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED
+                                      : SPxSolverBase<R>::ON_LOWER;
+    }
+  } else if (cStatus[m_k] == SPxSolverBase<R>::FIXED) {
+    // => x[m_k] and x[m_j] are also fixed before the corresponding
+    // preprocessing step
+    x[m_j] = m_loJ;
+    cStatus[m_j] = SPxSolverBase<R>::FIXED;
+  } else if (cStatus[m_k] == SPxSolverBase<R>::ZERO) {
+    /* we only aggregate duplicate columns if 0 is contained in their bounds, so
+     * we can handle this case properly */
+    assert(isZero(x[m_k]));
+    assert(LErel(m_loJ, R(0.0)));
+    assert(GErel(m_upJ, R(0.0)));
+    assert(LErel(m_loK, R(0.0)));
+    assert(GErel(m_upK, R(0.0)));
+
+    if (isZero(m_loK) && isZero(m_upK) && m_loK == m_upK)
+      cStatus[m_k] = SPxSolverBase<R>::FIXED;
+    else if (isZero(m_loK))
+      cStatus[m_k] = SPxSolverBase<R>::ON_LOWER;
+    else if (isZero(m_upK))
+      cStatus[m_k] = SPxSolverBase<R>::ON_UPPER;
+    else if (LErel(m_loK, R(0.0)) && GErel(m_upK, R(0.0)))
+      cStatus[m_k] = SPxSolverBase<R>::ZERO;
+    else
+      throw SPxInternalCodeException("XMAISM05 This should never happen.");
+
+    x[m_j] = 0.0;
+
+    if (isZero(m_loJ) && isZero(m_upJ) && m_loJ == m_upJ)
       cStatus[m_j] = SPxSolverBase<R>::FIXED;
-   }
-   else if(cStatus[m_k] == SPxSolverBase<R>::ZERO)
-   {
-      /* we only aggregate duplicate columns if 0 is contained in their bounds, so we can handle this case properly */
-      assert(isZero(x[m_k]));
-      assert(LErel(m_loJ, R(0.0)));
-      assert(GErel(m_upJ, R(0.0)));
-      assert(LErel(m_loK, R(0.0)));
-      assert(GErel(m_upK, R(0.0)));
-
-      if(isZero(m_loK) && isZero(m_upK) && m_loK == m_upK)
-         cStatus[m_k] = SPxSolverBase<R>::FIXED;
-      else if(isZero(m_loK))
-         cStatus[m_k] = SPxSolverBase<R>::ON_LOWER;
-      else if(isZero(m_upK))
-         cStatus[m_k] = SPxSolverBase<R>::ON_UPPER;
-      else if(LErel(m_loK, R(0.0)) && GErel(m_upK, R(0.0)))
-         cStatus[m_k] = SPxSolverBase<R>::ZERO;
-      else
-         throw SPxInternalCodeException("XMAISM05 This should never happen.");
-
-      x[m_j] = 0.0;
-
-      if(isZero(m_loJ) && isZero(m_upJ) && m_loJ == m_upJ)
-         cStatus[m_j] = SPxSolverBase<R>::FIXED;
-      else if(isZero(m_loJ))
-         cStatus[m_j] = SPxSolverBase<R>::ON_LOWER;
-      else if(isZero(m_upJ))
-         cStatus[m_j] = SPxSolverBase<R>::ON_UPPER;
-      else if(LErel(m_loJ, R(0.0)) && GErel(m_upJ, R(0.0)))
-         cStatus[m_j] = SPxSolverBase<R>::ZERO;
-      else
-         throw SPxInternalCodeException("XMAISM06 This should never happen.");
-   }
-   else if(cStatus[m_k] == SPxSolverBase<R>::BASIC)
-   {
-      R scale1 = maxAbs(x[m_k], m_loK);
-      R scale2 = maxAbs(x[m_k], m_upK);
-
-      if(scale1 < 1.0)
-         scale1 = 1.0;
+    else if (isZero(m_loJ))
+      cStatus[m_j] = SPxSolverBase<R>::ON_LOWER;
+    else if (isZero(m_upJ))
+      cStatus[m_j] = SPxSolverBase<R>::ON_UPPER;
+    else if (LErel(m_loJ, R(0.0)) && GErel(m_upJ, R(0.0)))
+      cStatus[m_j] = SPxSolverBase<R>::ZERO;
+    else
+      throw SPxInternalCodeException("XMAISM06 This should never happen.");
+  } else if (cStatus[m_k] == SPxSolverBase<R>::BASIC) {
+    R scale1 = maxAbs(x[m_k], m_loK);
+    R scale2 = maxAbs(x[m_k], m_upK);
 
-      if(scale2 < 1.0)
-         scale2 = 1.0;
+    if (scale1 < 1.0)
+      scale1 = 1.0;
 
-      R z1 = (x[m_k] / scale1) - (m_loK / scale1);
-      R z2 = (x[m_k] / scale2) - (m_upK / scale2);
+    if (scale2 < 1.0)
+      scale2 = 1.0;
 
-      if(isZero(z1))
-         z1 = 0.0;
+    R z1 = (x[m_k] / scale1) - (m_loK / scale1);
+    R z2 = (x[m_k] / scale2) - (m_upK / scale2);
 
-      if(isZero(z2))
-         z2 = 0.0;
+    if (isZero(z1))
+      z1 = 0.0;
 
-      if(m_loJ <= R(-infinity) && m_upJ >= R(infinity) && m_loK <= R(-infinity) && m_upK >= R(infinity))
-      {
-         cStatus[m_j] = SPxSolverBase<R>::ZERO;
-         x[m_j] = 0.0;
-      }
-      else if(m_scale > 0.0)
-      {
-         if(GErel(x[m_k], m_upK + m_scale * m_upJ))
-         {
-            assert(m_upJ < R(infinity));
-            cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED : SPxSolverBase<R>::ON_UPPER;
-            x[m_j] = m_upJ;
-            x[m_k] -= m_scale * x[m_j];
-         }
-         else if(GErel(x[m_k], m_loK + m_scale * m_upJ) && m_upJ < R(infinity))
-         {
-            cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED : SPxSolverBase<R>::ON_UPPER;
-            x[m_j] = m_upJ;
-            x[m_k] -= m_scale * x[m_j];
-         }
-         else if(GErel(x[m_k], m_upK + m_scale * m_loJ) && m_upK < R(infinity))
-         {
-            cStatus[m_k] = (m_loK == m_upK) ? SPxSolverBase<R>::FIXED : SPxSolverBase<R>::ON_UPPER;
-            x[m_k] = m_upK;
-            cStatus[m_j] = SPxSolverBase<R>::BASIC;
-            x[m_j] = z2 * scale2 / m_scale;
-         }
-         else if(GErel(x[m_k], m_loK + m_scale * m_loJ) && m_loJ > R(-infinity))
-         {
-            cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED : SPxSolverBase<R>::ON_LOWER;
-            x[m_j] = m_loJ;
-            x[m_k] -= m_scale * x[m_j];
-         }
-         else if(GErel(x[m_k], m_loK + m_scale * m_loJ) && m_loK > R(-infinity))
-         {
-            cStatus[m_k] = (m_loK == m_upK) ? SPxSolverBase<R>::FIXED : SPxSolverBase<R>::ON_LOWER;
-            x[m_k] = m_loK;
-            cStatus[m_j] = SPxSolverBase<R>::BASIC;
-            x[m_j] = z1 * scale1 / m_scale;
-         }
-         else if(LTrel(x[m_k], m_loK + m_scale * m_loJ))
-         {
-            assert(m_loJ > R(-infinity));
-            cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED : SPxSolverBase<R>::ON_LOWER;
-            x[m_j] = m_loJ;
-            x[m_k] -= m_scale * x[m_j];
-         }
-         else
-         {
-            throw SPxInternalCodeException("XMAISM08 This should never happen.");
-         }
-      }
-      else
-      {
-         assert(m_scale < 0.0);
-
-         if(GErel(x[m_k], m_upK + m_scale * m_loJ))
-         {
-            assert(m_loJ > R(-infinity));
-            cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED : SPxSolverBase<R>::ON_LOWER;
-            x[m_j] = m_loJ;
-            x[m_k] -= m_scale * x[m_j];
-         }
-         else if(GErel(x[m_k], m_loK + m_scale * m_loJ) && m_loJ > R(-infinity))
-         {
-            cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED : SPxSolverBase<R>::ON_LOWER;
-            x[m_j] = m_loJ;
-            x[m_k] -= m_scale * x[m_j];
-         }
-         else if(GErel(x[m_k], m_upK + m_scale * m_upJ) && m_upK < R(infinity))
-         {
-            cStatus[m_k] = (m_loK == m_upK) ? SPxSolverBase<R>::FIXED : SPxSolverBase<R>::ON_UPPER;
-            x[m_k] = m_upK;
-            cStatus[m_j] = SPxSolverBase<R>::BASIC;
-            x[m_j] = z2 * scale2 / m_scale;
-         }
-         else if(GErel(x[m_k], m_loK + m_scale * m_upJ) && m_upJ < R(infinity))
-         {
-            cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED : SPxSolverBase<R>::ON_UPPER;
-            x[m_j] = m_upJ;
-            x[m_k] -= m_scale * x[m_j];
-         }
-         else if(GErel(x[m_k], m_loK + m_scale * m_upJ) && m_loK > R(-infinity))
-         {
-            cStatus[m_k] = (m_loK == m_upK) ? SPxSolverBase<R>::FIXED : SPxSolverBase<R>::ON_LOWER;
-            x[m_k] = m_loK;
-            cStatus[m_j] = SPxSolverBase<R>::BASIC;
-            x[m_j] = z1 * scale1 / m_scale;
-         }
-         else if(LTrel(x[m_k], m_loK + m_scale * m_upJ))
-         {
-            assert(m_upJ < R(infinity));
-            cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED : SPxSolverBase<R>::ON_UPPER;
-            x[m_j] = m_upJ;
-            x[m_k] -= m_scale * x[m_j];
-         }
-         else
-         {
-            throw SPxInternalCodeException("XMAISM09 This should never happen.");
-         }
-      }
-   }
+    if (isZero(z2))
+      z2 = 0.0;
 
-   // dual:
-   r[m_j] = m_scale * r[m_k];
+    if (m_loJ <= R(-infinity) && m_upJ >= R(infinity) &&
+        m_loK <= R(-infinity) && m_upK >= R(infinity)) {
+      cStatus[m_j] = SPxSolverBase<R>::ZERO;
+      x[m_j] = 0.0;
+    } else if (m_scale > 0.0) {
+      if (GErel(x[m_k], m_upK + m_scale * m_upJ)) {
+        assert(m_upJ < R(infinity));
+        cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED
+                                        : SPxSolverBase<R>::ON_UPPER;
+        x[m_j] = m_upJ;
+        x[m_k] -= m_scale * x[m_j];
+      } else if (GErel(x[m_k], m_loK + m_scale * m_upJ) &&
+                 m_upJ < R(infinity)) {
+        cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED
+                                        : SPxSolverBase<R>::ON_UPPER;
+        x[m_j] = m_upJ;
+        x[m_k] -= m_scale * x[m_j];
+      } else if (GErel(x[m_k], m_upK + m_scale * m_loJ) &&
+                 m_upK < R(infinity)) {
+        cStatus[m_k] = (m_loK == m_upK) ? SPxSolverBase<R>::FIXED
+                                        : SPxSolverBase<R>::ON_UPPER;
+        x[m_k] = m_upK;
+        cStatus[m_j] = SPxSolverBase<R>::BASIC;
+        x[m_j] = z2 * scale2 / m_scale;
+      } else if (GErel(x[m_k], m_loK + m_scale * m_loJ) &&
+                 m_loJ > R(-infinity)) {
+        cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED
+                                        : SPxSolverBase<R>::ON_LOWER;
+        x[m_j] = m_loJ;
+        x[m_k] -= m_scale * x[m_j];
+      } else if (GErel(x[m_k], m_loK + m_scale * m_loJ) &&
+                 m_loK > R(-infinity)) {
+        cStatus[m_k] = (m_loK == m_upK) ? SPxSolverBase<R>::FIXED
+                                        : SPxSolverBase<R>::ON_LOWER;
+        x[m_k] = m_loK;
+        cStatus[m_j] = SPxSolverBase<R>::BASIC;
+        x[m_j] = z1 * scale1 / m_scale;
+      } else if (LTrel(x[m_k], m_loK + m_scale * m_loJ)) {
+        assert(m_loJ > R(-infinity));
+        cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED
+                                        : SPxSolverBase<R>::ON_LOWER;
+        x[m_j] = m_loJ;
+        x[m_k] -= m_scale * x[m_j];
+      } else {
+        throw SPxInternalCodeException("XMAISM08 This should never happen.");
+      }
+    } else {
+      assert(m_scale < 0.0);
+
+      if (GErel(x[m_k], m_upK + m_scale * m_loJ)) {
+        assert(m_loJ > R(-infinity));
+        cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED
+                                        : SPxSolverBase<R>::ON_LOWER;
+        x[m_j] = m_loJ;
+        x[m_k] -= m_scale * x[m_j];
+      } else if (GErel(x[m_k], m_loK + m_scale * m_loJ) &&
+                 m_loJ > R(-infinity)) {
+        cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED
+                                        : SPxSolverBase<R>::ON_LOWER;
+        x[m_j] = m_loJ;
+        x[m_k] -= m_scale * x[m_j];
+      } else if (GErel(x[m_k], m_upK + m_scale * m_upJ) &&
+                 m_upK < R(infinity)) {
+        cStatus[m_k] = (m_loK == m_upK) ? SPxSolverBase<R>::FIXED
+                                        : SPxSolverBase<R>::ON_UPPER;
+        x[m_k] = m_upK;
+        cStatus[m_j] = SPxSolverBase<R>::BASIC;
+        x[m_j] = z2 * scale2 / m_scale;
+      } else if (GErel(x[m_k], m_loK + m_scale * m_upJ) &&
+                 m_upJ < R(infinity)) {
+        cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED
+                                        : SPxSolverBase<R>::ON_UPPER;
+        x[m_j] = m_upJ;
+        x[m_k] -= m_scale * x[m_j];
+      } else if (GErel(x[m_k], m_loK + m_scale * m_upJ) &&
+                 m_loK > R(-infinity)) {
+        cStatus[m_k] = (m_loK == m_upK) ? SPxSolverBase<R>::FIXED
+                                        : SPxSolverBase<R>::ON_LOWER;
+        x[m_k] = m_loK;
+        cStatus[m_j] = SPxSolverBase<R>::BASIC;
+        x[m_j] = z1 * scale1 / m_scale;
+      } else if (LTrel(x[m_k], m_loK + m_scale * m_upJ)) {
+        assert(m_upJ < R(infinity));
+        cStatus[m_j] = (m_loJ == m_upJ) ? SPxSolverBase<R>::FIXED
+                                        : SPxSolverBase<R>::ON_UPPER;
+        x[m_j] = m_upJ;
+        x[m_k] -= m_scale * x[m_j];
+      } else {
+        throw SPxInternalCodeException("XMAISM09 This should never happen.");
+      }
+    }
+  }
+
+  // dual:
+  r[m_j] = m_scale * r[m_k];
 }
 
 template <class R>
-void SPxMainSM<R>::AggregationPS::execute(VectorBase<R>& x, VectorBase<R>& y, VectorBase<R>& s,
-      VectorBase<R>& r,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& cStatus,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& rStatus, bool isOptimal) const
-{
-   // correcting the change of idx by deletion of the row:
-   if(m_i != m_old_i)
-   {
-      s[m_old_i] = s[m_i];
-      y[m_old_i] = y[m_i];
-      rStatus[m_old_i] = rStatus[m_i];
-   }
-
-   // correcting the change of idx by deletion of the column:
-   if(m_j != m_old_j)
-   {
-      x[m_old_j] = x[m_j];
-      r[m_old_j] = r[m_j];
-      cStatus[m_old_j] = cStatus[m_j];
-   }
-
-   // primal:
-   R val = 0.0;
-   R aij = m_row[m_j];
-   int active_idx = -1;
-
-   assert(m_row.size() == 2);
-
-   for(int k = 0; k < 2; ++k)
-   {
-      if(m_row.index(k) != m_j)
-      {
-         active_idx = m_row.index(k);
-         val = m_row.value(k) * x[active_idx];
-      }
-   }
-
-   assert(active_idx >= 0);
-
-   R scale = maxAbs(m_rhs, val);
-
-   if(scale < 1.0)
-      scale = 1.0;
-
-   R z = (m_rhs / scale) - (val / scale);
-
-   if(isZero(z))
-      z = 0.0;
+void SPxMainSM<R>::AggregationPS::execute(
+    VectorBase<R> &x, VectorBase<R> &y, VectorBase<R> &s, VectorBase<R> &r,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &cStatus,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &rStatus,
+    bool isOptimal) const {
+  // correcting the change of idx by deletion of the row:
+  if (m_i != m_old_i) {
+    s[m_old_i] = s[m_i];
+    y[m_old_i] = y[m_i];
+    rStatus[m_old_i] = rStatus[m_i];
+  }
+
+  // correcting the change of idx by deletion of the column:
+  if (m_j != m_old_j) {
+    x[m_old_j] = x[m_j];
+    r[m_old_j] = r[m_j];
+    cStatus[m_old_j] = cStatus[m_j];
+  }
+
+  // primal:
+  R val = 0.0;
+  R aij = m_row[m_j];
+  int active_idx = -1;
+
+  assert(m_row.size() == 2);
+
+  for (int k = 0; k < 2; ++k) {
+    if (m_row.index(k) != m_j) {
+      active_idx = m_row.index(k);
+      val = m_row.value(k) * x[active_idx];
+    }
+  }
+
+  assert(active_idx >= 0);
+
+  R scale = maxAbs(m_rhs, val);
+
+  if (scale < 1.0)
+    scale = 1.0;
+
+  R z = (m_rhs / scale) - (val / scale);
+
+  if (isZero(z))
+    z = 0.0;
+
+  x[m_j] = z * scale / aij;
+  s[m_i] = m_rhs;
+
+  if (isOptimal &&
+      (LT(x[m_j], m_lower, this->eps()) || GT(x[m_j], m_upper, this->eps()))) {
+    MSG_ERROR(
+        std::cerr << "EMAISM: numerical violation after disaggregating variable"
+                  << std::endl;)
+  }
+
+  // dual:
+  R dualVal = 0.0;
+
+  for (int k = 0; k < m_col.size(); ++k) {
+    if (m_col.index(k) != m_i)
+      dualVal += m_col.value(k) * y[m_col.index(k)];
+  }
+
+  z = m_obj - dualVal;
+
+  y[m_i] = z / aij;
+  r[m_j] = 0.0;
+
+  // basis:
+  if (((cStatus[active_idx] == SPxSolverBase<R>::ON_UPPER ||
+        cStatus[active_idx] == SPxSolverBase<R>::FIXED) &&
+       NE(x[active_idx], m_oldupper, this->eps())) ||
+      ((cStatus[active_idx] == SPxSolverBase<R>::ON_LOWER ||
+        cStatus[active_idx] == SPxSolverBase<R>::FIXED) &&
+       NE(x[active_idx], m_oldlower, this->eps()))) {
+    cStatus[active_idx] = SPxSolverBase<R>::BASIC;
+    r[active_idx] = 0.0;
+    assert(NE(m_upper, m_lower));
+
+    if (EQ(x[m_j], m_upper, this->eps()))
+      cStatus[m_j] = SPxSolverBase<R>::ON_UPPER;
+    else if (EQ(x[m_j], m_lower, this->eps()))
+      cStatus[m_j] = SPxSolverBase<R>::ON_LOWER;
+    else if (m_upper >= R(infinity) && m_lower <= R(-infinity))
+      cStatus[m_j] = SPxSolverBase<R>::ZERO;
+    else
+      throw SPxInternalCodeException(
+          "XMAISM unexpected basis status in aggregation unsimplifier.");
+  } else {
+    cStatus[m_j] = SPxSolverBase<R>::BASIC;
+  }
+
+  // sides may not be equal and we always only consider the rhs during
+  // aggregation, so set ON_UPPER (in theory and with exact arithmetic setting
+  // it to FIXED would be correct)
+  rStatus[m_i] = SPxSolverBase<R>::ON_UPPER;
 
-   x[m_j] = z * scale / aij;
-   s[m_i] = m_rhs;
+#ifdef CHECK_BASIC_DIM
 
-   if(isOptimal && (LT(x[m_j], m_lower, this->eps()) || GT(x[m_j], m_upper, this->eps())))
-   {
-      MSG_ERROR(std::cerr << "EMAISM: numerical violation after disaggregating variable" << std::endl;)
-   }
+  if (!this->checkBasisDim(rStatus, cStatus)) {
+    throw SPxInternalCodeException(
+        "XMAISM22 Dimension doesn't match after this step.");
+  }
 
-   // dual:
-   R dualVal = 0.0;
+#endif
+}
 
-   for(int k = 0; k < m_col.size(); ++k)
-   {
-      if(m_col.index(k) != m_i)
-         dualVal += m_col.value(k) * y[m_col.index(k)];
-   }
+template <class R>
+void SPxMainSM<R>::MultiAggregationPS::execute(
+    VectorBase<R> &x, VectorBase<R> &y, VectorBase<R> &s, VectorBase<R> &r,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &cStatus,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &rStatus,
+    bool isOptimal) const {
 
-   z = m_obj - dualVal;
+  // correcting the change of idx by deletion of the row:
+  if (m_i != m_old_i) {
+    s[m_old_i] = s[m_i];
+    y[m_old_i] = y[m_i];
+    rStatus[m_old_i] = rStatus[m_i];
+  }
 
-   y[m_i] = z / aij;
-   r[m_j] = 0.0;
+  // correcting the change of idx by deletion of the column:
+  if (m_j != m_old_j) {
+    x[m_old_j] = x[m_j];
+    r[m_old_j] = r[m_j];
+    cStatus[m_old_j] = cStatus[m_j];
+  }
 
-   // basis:
-   if(((cStatus[active_idx] == SPxSolverBase<R>::ON_UPPER
-         || cStatus[active_idx] == SPxSolverBase<R>::FIXED)
-         && NE(x[active_idx], m_oldupper, this->eps())) ||
-         ((cStatus[active_idx] == SPxSolverBase<R>::ON_LOWER
-           || cStatus[active_idx] == SPxSolverBase<R>::FIXED)
-          && NE(x[active_idx], m_oldlower, this->eps())))
-   {
-      cStatus[active_idx] = SPxSolverBase<R>::BASIC;
-      r[active_idx] = 0.0;
-      assert(NE(m_upper, m_lower));
+  // primal:
+  R val = 0.0;
+  R aij = m_row[m_j];
 
-      if(EQ(x[m_j], m_upper, this->eps()))
-         cStatus[m_j] = SPxSolverBase<R>::ON_UPPER;
-      else if(EQ(x[m_j], m_lower, this->eps()))
-         cStatus[m_j] = SPxSolverBase<R>::ON_LOWER;
-      else if(m_upper >= R(infinity) && m_lower <= R(-infinity))
-         cStatus[m_j] = SPxSolverBase<R>::ZERO;
-      else
-         throw SPxInternalCodeException("XMAISM unexpected basis status in aggregation unsimplifier.");
-   }
-   else
-   {
-      cStatus[m_j] = SPxSolverBase<R>::BASIC;
-   }
+  for (int k = 0; k < m_row.size(); ++k) {
+    if (m_row.index(k) != m_j)
+      val += m_row.value(k) * x[m_row.index(k)];
+  }
 
-   // sides may not be equal and we always only consider the rhs during aggregation, so set ON_UPPER
-   // (in theory and with exact arithmetic setting it to FIXED would be correct)
-   rStatus[m_i] = SPxSolverBase<R>::ON_UPPER;
+  R scale = maxAbs(m_const, val);
 
-#ifdef CHECK_BASIC_DIM
+  if (scale < 1.0)
+    scale = 1.0;
 
-   if(!this->checkBasisDim(rStatus, cStatus))
-   {
-      throw SPxInternalCodeException("XMAISM22 Dimension doesn't match after this step.");
-   }
+  R z = (m_const / scale) - (val / scale);
 
-#endif
-}
+  if (isZero(z))
+    z = 0.0;
 
-template <class R>
-void SPxMainSM<R>::MultiAggregationPS::execute(VectorBase<R>& x, VectorBase<R>& y, VectorBase<R>& s,
-      VectorBase<R>& r,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& cStatus,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& rStatus, bool isOptimal) const
-{
-
-   // correcting the change of idx by deletion of the row:
-   if(m_i != m_old_i)
-   {
-      s[m_old_i] = s[m_i];
-      y[m_old_i] = y[m_i];
-      rStatus[m_old_i] = rStatus[m_i];
-   }
-
-   // correcting the change of idx by deletion of the column:
-   if(m_j != m_old_j)
-   {
-      x[m_old_j] = x[m_j];
-      r[m_old_j] = r[m_j];
-      cStatus[m_old_j] = cStatus[m_j];
-   }
-
-   // primal:
-   R val = 0.0;
-   R aij = m_row[m_j];
-
-   for(int k = 0; k < m_row.size(); ++k)
-   {
-      if(m_row.index(k) != m_j)
-         val += m_row.value(k) * x[m_row.index(k)];
-   }
-
-   R scale = maxAbs(m_const, val);
-
-   if(scale < 1.0)
-      scale = 1.0;
-
-   R z = (m_const / scale) - (val / scale);
-
-   if(isZero(z))
-      z = 0.0;
-
-   x[m_j] = z * scale / aij;
-   s[m_i] = 0.0;
+  x[m_j] = z * scale / aij;
+  s[m_i] = 0.0;
 
 #ifndef NDEBUG
 
-   if(isOptimal && (LT(x[m_j], m_lower, this->eps()) || GT(x[m_j], m_upper, this->eps())))
-      MSG_ERROR(std::cerr << "numerical violation in original space due to MultiAggregation\n";)
+  if (isOptimal &&
+      (LT(x[m_j], m_lower, this->eps()) || GT(x[m_j], m_upper, this->eps())))
+    MSG_ERROR(std::cerr << "numerical violation in original space due to "
+                           "MultiAggregation\n";)
 #endif
 
-      // dual:
-      R dualVal = 0.0;
+  // dual:
+  R dualVal = 0.0;
 
-   for(int k = 0; k < m_col.size(); ++k)
-   {
-      if(m_col.index(k) != m_i)
-         dualVal += m_col.value(k) * y[m_col.index(k)];
-   }
+  for (int k = 0; k < m_col.size(); ++k) {
+    if (m_col.index(k) != m_i)
+      dualVal += m_col.value(k) * y[m_col.index(k)];
+  }
 
-   z = m_obj - dualVal;
+  z = m_obj - dualVal;
 
-   y[m_i] = z / aij;
-   r[m_j] = 0.0;
+  y[m_i] = z / aij;
+  r[m_j] = 0.0;
 
-   // basis:
-   cStatus[m_j] = SPxSolverBase<R>::BASIC;
+  // basis:
+  cStatus[m_j] = SPxSolverBase<R>::BASIC;
 
-   if(m_eqCons)
-      rStatus[m_i] = SPxSolverBase<R>::FIXED;
-   else if(m_onLhs)
-      rStatus[m_i] = SPxSolverBase<R>::ON_LOWER;
-   else
-      rStatus[m_i] = SPxSolverBase<R>::ON_UPPER;
+  if (m_eqCons)
+    rStatus[m_i] = SPxSolverBase<R>::FIXED;
+  else if (m_onLhs)
+    rStatus[m_i] = SPxSolverBase<R>::ON_LOWER;
+  else
+    rStatus[m_i] = SPxSolverBase<R>::ON_UPPER;
 
 #ifdef CHECK_BASIC_DIM
 
-   if(!this->checkBasisDim(rStatus, cStatus))
-   {
-      throw SPxInternalCodeException("XMAISM22 Dimension doesn't match after this step.");
-   }
+  if (!this->checkBasisDim(rStatus, cStatus)) {
+    throw SPxInternalCodeException(
+        "XMAISM22 Dimension doesn't match after this step.");
+  }
 
 #endif
 }
 
 template <class R>
-void SPxMainSM<R>::TightenBoundsPS::execute(VectorBase<R>& x, VectorBase<R>&, VectorBase<R>&,
-      VectorBase<R>&,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& cStatus,
-      DataArray<typename SPxSolverBase<R>::VarStatus>& rStatus, bool isOptimal) const
-{
-   // basis:
-   switch(cStatus[m_j])
-   {
-   case SPxSolverBase<R>::FIXED:
-      if(LT(x[m_j], m_origupper, this->eps()) && GT(x[m_j], m_origlower, this->eps()))
-         cStatus[m_j] = SPxSolverBase<R>::BASIC;
-      else if(LT(x[m_j], m_origupper, this->eps()))
-         cStatus[m_j] = SPxSolverBase<R>::ON_LOWER;
-      else if(GT(x[m_j], m_origlower, this->eps()))
-         cStatus[m_j] = SPxSolverBase<R>::ON_UPPER;
+void SPxMainSM<R>::TightenBoundsPS::execute(
+    VectorBase<R> &x, VectorBase<R> &, VectorBase<R> &, VectorBase<R> &,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &cStatus,
+    DataArray<typename SPxSolverBase<R>::VarStatus> &rStatus,
+    bool isOptimal) const {
+  // basis:
+  switch (cStatus[m_j]) {
+  case SPxSolverBase<R>::FIXED:
+    if (LT(x[m_j], m_origupper, this->eps()) &&
+        GT(x[m_j], m_origlower, this->eps()))
+      cStatus[m_j] = SPxSolverBase<R>::BASIC;
+    else if (LT(x[m_j], m_origupper, this->eps()))
+      cStatus[m_j] = SPxSolverBase<R>::ON_LOWER;
+    else if (GT(x[m_j], m_origlower, this->eps()))
+      cStatus[m_j] = SPxSolverBase<R>::ON_UPPER;
 
-      break;
+    break;
 
-   case SPxSolverBase<R>::ON_LOWER:
-      if(GT(x[m_j], m_origlower, this->eps()))
-         cStatus[m_j] = SPxSolverBase<R>::BASIC;
+  case SPxSolverBase<R>::ON_LOWER:
+    if (GT(x[m_j], m_origlower, this->eps()))
+      cStatus[m_j] = SPxSolverBase<R>::BASIC;
 
-      break;
+    break;
 
-   case SPxSolverBase<R>::ON_UPPER:
-      if(LT(x[m_j], m_origupper, this->eps()))
-         cStatus[m_j] = SPxSolverBase<R>::BASIC;
+  case SPxSolverBase<R>::ON_UPPER:
+    if (LT(x[m_j], m_origupper, this->eps()))
+      cStatus[m_j] = SPxSolverBase<R>::BASIC;
 
-      break;
+    break;
 
-   default:
-      break;
-   }
+  default:
+    break;
+  }
 
 #ifdef CHECK_BASIC_DIM
 
-   if(!this->checkBasisDim(rStatus, cStatus))
-   {
-      throw SPxInternalCodeException("XMAISM22 Dimension doesn't match after this step.");
-   }
+  if (!this->checkBasisDim(rStatus, cStatus)) {
+    throw SPxInternalCodeException(
+        "XMAISM22 Dimension doesn't match after this step.");
+  }
 
 #endif
 }
 
-template <class R>
-void SPxMainSM<R>::handleRowObjectives(SPxLPBase<R>& lp)
-{
-   for(int i = lp.nRows() - 1; i >= 0; --i)
-   {
-      if(lp.maxRowObj(i) != 0.0)
-      {
-         std::shared_ptr<PostStep> ptr(new RowObjPS(lp, i, lp.nCols()));
-         m_hist.append(ptr);
-         lp.addCol(lp.rowObj(i), -lp.rhs(i), UnitVectorBase<R>(i), -lp.lhs(i));
-         lp.changeRange(i, R(0.0), R(0.0));
-         lp.changeRowObj(i, R(0.0));
-         m_addedcols++;
-      }
-   }
+template <class R> void SPxMainSM<R>::handleRowObjectives(SPxLPBase<R> &lp) {
+  for (int i = lp.nRows() - 1; i >= 0; --i) {
+    if (lp.maxRowObj(i) != 0.0) {
+      std::shared_ptr<PostStep> ptr(new RowObjPS(lp, i, lp.nCols()));
+      m_hist.append(ptr);
+      lp.addCol(lp.rowObj(i), -lp.rhs(i), UnitVectorBase<R>(i), -lp.lhs(i));
+      lp.changeRange(i, R(0.0), R(0.0));
+      lp.changeRowObj(i, R(0.0));
+      m_addedcols++;
+    }
+  }
 }
 
-template <class R>
-void SPxMainSM<R>::handleExtremes(SPxLPBase<R>& lp)
-{
-
-   // This method handles extreme value of the given LP by
-   //
-   // 1. setting numbers of very small absolute values to zero and
-   // 2. setting numbers of very large absolute values to R(-infinity) or +R(infinity), respectively.
-
-   R maxVal  = R(infinity) / 5.0;
-   R tol = feastol() * 1e-2;
-   tol = (tol < this->epsZero()) ? this->epsZero() : tol;
-   int  remRows = 0;
-   int  remNzos = 0;
-   int  chgBnds = 0;
-   int  chgLRhs = 0;
-   int  objCnt  = 0;
-
-   for(int i = lp.nRows() - 1; i >= 0; --i)
-   {
-      // lhs
-      R lhs = lp.lhs(i);
-
-      if(lhs != 0.0 && isZero(lhs, this->epsZero()))
-      {
-         lp.changeLhs(i, R(0.0));
-         ++chgLRhs;
-      }
-      else if(lhs > R(-infinity) && lhs < -maxVal)
-      {
-         lp.changeLhs(i, R(-infinity));
-         ++chgLRhs;
-      }
-      else if(lhs <  R(infinity) && lhs >  maxVal)
-      {
-         lp.changeLhs(i,  R(infinity));
-         ++chgLRhs;
-      }
-
-      // rhs
-      R rhs = lp.rhs(i);
-
-      if(rhs != 0.0 && isZero(rhs, this->epsZero()))
-      {
-         lp.changeRhs(i, R(0.0));
-         ++chgLRhs;
-      }
-      else if(rhs > R(-infinity) && rhs < -maxVal)
-      {
-         lp.changeRhs(i, R(-infinity));
-         ++chgLRhs;
-      }
-      else if(rhs <  R(infinity) && rhs >  maxVal)
-      {
-         lp.changeRhs(i,  R(infinity));
-         ++chgLRhs;
-      }
-
-      if(lp.lhs(i) <= R(-infinity) && lp.rhs(i) >= R(infinity))
-      {
-         std::shared_ptr<PostStep> ptr(new FreeConstraintPS(lp, i));
-         m_hist.append(ptr);
-
-         removeRow(lp, i);
-         ++remRows;
-
-         ++m_stat[FREE_ROW];
-      }
-   }
-
-   for(int j = 0; j < lp.nCols(); ++j)
-   {
-      // lower bound
-      R lo = lp.lower(j);
-
-      if(lo != 0.0 && isZero(lo, this->epsZero()))
-      {
-         lp.changeLower(j, R(0.0));
-         ++chgBnds;
-      }
-      else if(lo > R(-infinity) && lo < -maxVal)
-      {
-         lp.changeLower(j, R(-infinity));
-         ++chgBnds;
-      }
-      else if(lo <  R(infinity) && lo >  maxVal)
-      {
-         lp.changeLower(j,  R(infinity));
-         ++chgBnds;
-      }
-
-      // upper bound
-      R up = lp.upper(j);
-
-      if(up != 0.0 && isZero(up, this->epsZero()))
-      {
-         lp.changeUpper(j, R(0.0));
-         ++chgBnds;
-      }
-      else if(up > R(-infinity) && up < -maxVal)
-      {
-         lp.changeUpper(j, R(-infinity));
-         ++chgBnds;
-      }
-      else if(up <  R(infinity) && up >  maxVal)
-      {
-         lp.changeUpper(j,  R(infinity));
-         ++chgBnds;
-      }
-
-      // fixed columns will be eliminated later
-      if(NE(lo, up))
-      {
-         lo = spxAbs(lo);
-         up = spxAbs(up);
-
-         R absBnd = (lo > up) ? lo : up;
-
-         if(absBnd < 1.0)
-            absBnd = 1.0;
-
-         // non-zeros
-         SVectorBase<R>& col = lp.colVector_w(j);
-         int        i = 0;
-
-         while(i < col.size())
-         {
-            R aij = spxAbs(col.value(i));
-
-            if(isZero(aij * absBnd, tol))
-            {
-               SVectorBase<R>& row = lp.rowVector_w(col.index(i));
-               int row_j = row.pos(j);
-
-               // this changes col.size()
-               if(row_j >= 0)
-                  row.remove(row_j);
-
-               col.remove(i);
-
-               MSG_DEBUG((*this->spxout) << "IMAISM04 aij=" << aij
-                         << " removed, absBnd=" << absBnd
-                         << std::endl;)
-               ++remNzos;
-            }
-            else
-            {
-               if(aij > maxVal)
-               {
-                  MSG_WARNING((*this->spxout), (*this->spxout) << "WMAISM05 Warning! Big matrix coefficient " << aij
-                              << std::endl);
-               }
-               else if(isZero(aij, tol))
-               {
-                  MSG_WARNING((*this->spxout), (*this->spxout) << "WMAISM06 Warning! Tiny matrix coefficient " << aij
-                              << std::endl);
-               }
-
-               ++i;
-            }
-         }
-      }
-
-      // objective
-      R obj = lp.obj(j);
+template <class R> void SPxMainSM<R>::handleExtremes(SPxLPBase<R> &lp) {
+
+  // This method handles extreme value of the given LP by
+  //
+  // 1. setting numbers of very small absolute values to zero and
+  // 2. setting numbers of very large absolute values to R(-infinity) or
+  // +R(infinity), respectively.
+
+  R maxVal = R(infinity) / 5.0;
+  R tol = feastol() * 1e-2;
+  tol = (tol < this->epsZero()) ? this->epsZero() : tol;
+  int remRows = 0;
+  int remNzos = 0;
+  int chgBnds = 0;
+  int chgLRhs = 0;
+  int objCnt = 0;
+
+  for (int i = lp.nRows() - 1; i >= 0; --i) {
+    // lhs
+    R lhs = lp.lhs(i);
+
+    if (lhs != 0.0 && isZero(lhs, this->epsZero())) {
+      lp.changeLhs(i, R(0.0));
+      ++chgLRhs;
+    } else if (lhs > R(-infinity) && lhs < -maxVal) {
+      lp.changeLhs(i, R(-infinity));
+      ++chgLRhs;
+    } else if (lhs < R(infinity) && lhs > maxVal) {
+      lp.changeLhs(i, R(infinity));
+      ++chgLRhs;
+    }
+
+    // rhs
+    R rhs = lp.rhs(i);
+
+    if (rhs != 0.0 && isZero(rhs, this->epsZero())) {
+      lp.changeRhs(i, R(0.0));
+      ++chgLRhs;
+    } else if (rhs > R(-infinity) && rhs < -maxVal) {
+      lp.changeRhs(i, R(-infinity));
+      ++chgLRhs;
+    } else if (rhs < R(infinity) && rhs > maxVal) {
+      lp.changeRhs(i, R(infinity));
+      ++chgLRhs;
+    }
+
+    if (lp.lhs(i) <= R(-infinity) && lp.rhs(i) >= R(infinity)) {
+      std::shared_ptr<PostStep> ptr(new FreeConstraintPS(lp, i));
+      m_hist.append(ptr);
 
-      if(obj != 0.0 && isZero(obj, this->epsZero()))
-      {
-         lp.changeObj(j, R(0.0));
-         ++objCnt;
-      }
-      else if(obj > R(-infinity) && obj < -maxVal)
-      {
-         lp.changeObj(j, R(-infinity));
-         ++objCnt;
-      }
-      else if(obj <  R(infinity) && obj >  maxVal)
-      {
-         lp.changeObj(j,  R(infinity));
-         ++objCnt;
-      }
-   }
-
-   if(remRows + remNzos + chgLRhs + chgBnds + objCnt > 0)
-   {
-      this->m_remRows += remRows;
-      this->m_remNzos += remNzos;
-      this->m_chgLRhs += chgLRhs;
-      this->m_chgBnds += chgBnds;
-
-      MSG_INFO2((*this->spxout), (*this->spxout) << "Simplifier (extremes) removed "
-                << remRows << " rows, "
-                << remNzos << " non-zeros, "
-                << chgBnds << " col bounds, "
-                << chgLRhs << " row bounds, "
-                << objCnt  << " objective coefficients" << std::endl;)
-   }
-
-   assert(lp.isConsistent());
+      removeRow(lp, i);
+      ++remRows;
+
+      ++m_stat[FREE_ROW];
+    }
+  }
+
+  for (int j = 0; j < lp.nCols(); ++j) {
+    // lower bound
+    R lo = lp.lower(j);
+
+    if (lo != 0.0 && isZero(lo, this->epsZero())) {
+      lp.changeLower(j, R(0.0));
+      ++chgBnds;
+    } else if (lo > R(-infinity) && lo < -maxVal) {
+      lp.changeLower(j, R(-infinity));
+      ++chgBnds;
+    } else if (lo < R(infinity) && lo > maxVal) {
+      lp.changeLower(j, R(infinity));
+      ++chgBnds;
+    }
+
+    // upper bound
+    R up = lp.upper(j);
+
+    if (up != 0.0 && isZero(up, this->epsZero())) {
+      lp.changeUpper(j, R(0.0));
+      ++chgBnds;
+    } else if (up > R(-infinity) && up < -maxVal) {
+      lp.changeUpper(j, R(-infinity));
+      ++chgBnds;
+    } else if (up < R(infinity) && up > maxVal) {
+      lp.changeUpper(j, R(infinity));
+      ++chgBnds;
+    }
+
+    // fixed columns will be eliminated later
+    if (NE(lo, up)) {
+      lo = spxAbs(lo);
+      up = spxAbs(up);
+
+      R absBnd = (lo > up) ? lo : up;
+
+      if (absBnd < 1.0)
+        absBnd = 1.0;
+
+      // non-zeros
+      SVectorBase<R> &col = lp.colVector_w(j);
+      int i = 0;
+
+      while (i < col.size()) {
+        R aij = spxAbs(col.value(i));
+
+        if (isZero(aij * absBnd, tol)) {
+          SVectorBase<R> &row = lp.rowVector_w(col.index(i));
+          int row_j = row.pos(j);
+
+          // this changes col.size()
+          if (row_j >= 0)
+            row.remove(row_j);
+
+          col.remove(i);
+
+          MSG_DEBUG((*this->spxout)
+                        << "IMAISM04 aij=" << aij
+                        << " removed, absBnd=" << absBnd << std::endl;)
+          ++remNzos;
+        } else {
+          if (aij > maxVal) {
+            MSG_WARNING((*this->spxout),
+                        (*this->spxout)
+                            << "WMAISM05 Warning! Big matrix coefficient "
+                            << aij << std::endl);
+          } else if (isZero(aij, tol)) {
+            MSG_WARNING((*this->spxout),
+                        (*this->spxout)
+                            << "WMAISM06 Warning! Tiny matrix coefficient "
+                            << aij << std::endl);
+          }
+
+          ++i;
+        }
+      }
+    }
+
+    // objective
+    R obj = lp.obj(j);
+
+    if (obj != 0.0 && isZero(obj, this->epsZero())) {
+      lp.changeObj(j, R(0.0));
+      ++objCnt;
+    } else if (obj > R(-infinity) && obj < -maxVal) {
+      lp.changeObj(j, R(-infinity));
+      ++objCnt;
+    } else if (obj < R(infinity) && obj > maxVal) {
+      lp.changeObj(j, R(infinity));
+      ++objCnt;
+    }
+  }
+
+  if (remRows + remNzos + chgLRhs + chgBnds + objCnt > 0) {
+    this->m_remRows += remRows;
+    this->m_remNzos += remNzos;
+    this->m_chgLRhs += chgLRhs;
+    this->m_chgBnds += chgBnds;
+
+    MSG_INFO2((*this->spxout),
+              (*this->spxout)
+                  << "Simplifier (extremes) removed " << remRows << " rows, "
+                  << remNzos << " non-zeros, " << chgBnds << " col bounds, "
+                  << chgLRhs << " row bounds, " << objCnt
+                  << " objective coefficients" << std::endl;)
+  }
+
+  assert(lp.isConsistent());
 }
 
 /// computes the minimum and maximum residual activity for a given variable
 template <class R>
-void SPxMainSM<R>::computeMinMaxResidualActivity(SPxLPBase<R>& lp, int rowNumber, int colNumber,
-      R& minAct, R& maxAct)
-{
-   const SVectorBase<R>& row = lp.rowVector(rowNumber);
-   bool minNegInfinite = false;
-   bool maxInfinite = false;
-
-   minAct = 0;   // this is the minimum value that the aggregation can attain
-   maxAct = 0;   // this is the maximum value that the aggregation can attain
-
-   for(int l = 0; l < row.size(); ++l)
-   {
-      if(colNumber < 0 || row.index(l) != colNumber)
-      {
-         // computing the minimum activity of the aggregated variables
-         if(GT(row.value(l), R(0.0)))
-         {
-            if(LE(lp.lower(row.index(l)), R(-infinity)))
-               minNegInfinite = true;
-            else
-               minAct += row.value(l) * lp.lower(row.index(l));
-         }
-         else if(LT(row.value(l), R(0.0)))
-         {
-            if(GE(lp.upper(row.index(l)), R(infinity)))
-               minNegInfinite = true;
-            else
-               minAct += row.value(l) * lp.upper(row.index(l));
-         }
-
-         // computing the maximum activity of the aggregated variables
-         if(GT(row.value(l), R(0.0)))
-         {
-            if(GE(lp.upper(row.index(l)), R(infinity)))
-               maxInfinite = true;
-            else
-               maxAct += row.value(l) * lp.upper(row.index(l));
-         }
-         else if(LT(row.value(l), R(0.0)))
-         {
-            if(LE(lp.lower(row.index(l)), R(-infinity)))
-               maxInfinite = true;
-            else
-               maxAct += row.value(l) * lp.lower(row.index(l));
-         }
-      }
-   }
-
-   // if an infinite value exists for the minimum activity, then that it taken
-   if(minNegInfinite)
-      minAct = R(-infinity);
-
-   // if an -infinite value exists for the maximum activity, then that value is taken
-   if(maxInfinite)
-      maxAct = R(infinity);
+void SPxMainSM<R>::computeMinMaxResidualActivity(SPxLPBase<R> &lp,
+                                                 int rowNumber, int colNumber,
+                                                 R &minAct, R &maxAct) {
+  const SVectorBase<R> &row = lp.rowVector(rowNumber);
+  bool minNegInfinite = false;
+  bool maxInfinite = false;
+
+  minAct = 0; // this is the minimum value that the aggregation can attain
+  maxAct = 0; // this is the maximum value that the aggregation can attain
+
+  for (int l = 0; l < row.size(); ++l) {
+    if (colNumber < 0 || row.index(l) != colNumber) {
+      // computing the minimum activity of the aggregated variables
+      if (GT(row.value(l), R(0.0))) {
+        if (LE(lp.lower(row.index(l)), R(-infinity)))
+          minNegInfinite = true;
+        else
+          minAct += row.value(l) * lp.lower(row.index(l));
+      } else if (LT(row.value(l), R(0.0))) {
+        if (GE(lp.upper(row.index(l)), R(infinity)))
+          minNegInfinite = true;
+        else
+          minAct += row.value(l) * lp.upper(row.index(l));
+      }
+
+      // computing the maximum activity of the aggregated variables
+      if (GT(row.value(l), R(0.0))) {
+        if (GE(lp.upper(row.index(l)), R(infinity)))
+          maxInfinite = true;
+        else
+          maxAct += row.value(l) * lp.upper(row.index(l));
+      } else if (LT(row.value(l), R(0.0))) {
+        if (LE(lp.lower(row.index(l)), R(-infinity)))
+          maxInfinite = true;
+        else
+          maxAct += row.value(l) * lp.lower(row.index(l));
+      }
+    }
+  }
+
+  // if an infinite value exists for the minimum activity, then that it taken
+  if (minNegInfinite)
+    minAct = R(-infinity);
+
+  // if an -infinite value exists for the maximum activity, then that value is
+  // taken
+  if (maxInfinite)
+    maxAct = R(infinity);
 }
 
-
 /// calculate min/max value for the multi aggregated variables
 template <class R>
-void SPxMainSM<R>::computeMinMaxValues(SPxLPBase<R>& lp, R side, R val, R minRes, R maxRes,
-                                       R& minVal, R& maxVal)
-{
-   minVal = 0;
-   maxVal = 0;
-
-   if(LT(val, R(0.0)))
-   {
-      if(LE(minRes, R(-infinity)))
-         minVal = R(-infinity);
-      else
-         minVal = (side - minRes) / val;
-
-      if(GE(maxRes, R(infinity)))
-         maxVal = R(infinity);
-      else
-         maxVal = (side - maxRes) / val;
-   }
-   else if(GT(val, R(0.0)))
-   {
-      if(GE(maxRes, R(infinity)))
-         minVal = R(-infinity);
-      else
-         minVal = (side - maxRes) / val;
-
-      if(LE(minRes, R(-infinity)))
-         maxVal = R(infinity);
-      else
-         maxVal = (side - minRes) / val;
-   }
+void SPxMainSM<R>::computeMinMaxValues(SPxLPBase<R> &lp, R side, R val,
+                                       R minRes, R maxRes, R &minVal,
+                                       R &maxVal) {
+  minVal = 0;
+  maxVal = 0;
+
+  if (LT(val, R(0.0))) {
+    if (LE(minRes, R(-infinity)))
+      minVal = R(-infinity);
+    else
+      minVal = (side - minRes) / val;
+
+    if (GE(maxRes, R(infinity)))
+      maxVal = R(infinity);
+    else
+      maxVal = (side - maxRes) / val;
+  } else if (GT(val, R(0.0))) {
+    if (GE(maxRes, R(infinity)))
+      minVal = R(-infinity);
+    else
+      minVal = (side - maxRes) / val;
+
+    if (LE(minRes, R(-infinity)))
+      maxVal = R(infinity);
+    else
+      maxVal = (side - minRes) / val;
+  }
 }
 
-
 /// tries to find good lower bound solutions by applying some trivial heuristics
-template <class R>
-void SPxMainSM<R>::trivialHeuristic(SPxLPBase<R>& lp)
-{
-   VectorBase<R>         zerosol(lp.nCols());  // the zero solution VectorBase<R>
-   VectorBase<R>         lowersol(lp.nCols()); // the lower bound solution VectorBase<R>
-   VectorBase<R>         uppersol(lp.nCols()); // the upper bound solution VectorBase<R>
-   VectorBase<R>         locksol(lp.nCols());  // the locks solution VectorBase<R>
-
-   VectorBase<R>         upLocks(lp.nCols());
-   VectorBase<R>         downLocks(lp.nCols());
-
-   R            zeroObj = this->m_objoffset;
-   R            lowerObj = this->m_objoffset;
-   R            upperObj = this->m_objoffset;
-   R            lockObj = this->m_objoffset;
-
-   bool            zerovalid = true;
-
-   R largeValue = R(infinity);
-
-   if(LT(R(1.0 / feastol()), R(infinity)))
-      largeValue = 1.0 / feastol();
-
-
-
-   for(int j = lp.nCols() - 1; j >= 0; --j)
-   {
-      upLocks[j] = 0;
-      downLocks[j] = 0;
-
-      // computing the locks on the variables
-      const SVectorBase<R>& col = lp.colVector(j);
-
-      for(int k = 0; k < col.size(); ++k)
-      {
-         R aij = col.value(k);
-
-         ASSERT_WARN("WMAISM45", isNotZero(aij, R(1.0 / R(infinity))));
-
-         if(GT(lp.lhs(col.index(k)), R(-infinity)) && LT(lp.rhs(col.index(k)), R(infinity)))
-         {
-            upLocks[j]++;
-            downLocks[j]++;
-         }
-         else if(GT(lp.lhs(col.index(k)), R(-infinity)))
-         {
-            if(aij > 0)
-               downLocks[j]++;
-            else if(aij < 0)
-               upLocks[j]++;
-         }
-         else if(LT(lp.rhs(col.index(k)), R(infinity)))
-         {
-            if(aij > 0)
-               upLocks[j]++;
-            else if(aij < 0)
-               downLocks[j]++;
-         }
-      }
-
-      R lower = lp.lower(j);
-      R upper = lp.upper(j);
-
-      if(LE(lower, R(-infinity)))
-         lower = MINIMUM(-largeValue, upper);
-
-      if(GE(upper, R(infinity)))
-         upper = MAXIMUM(lp.lower(j), largeValue);
-
-      if(zerovalid)
-      {
-         if(LE(lower, R(0.0), feastol()) && GE(upper, R(0.0), feastol()))
-            zerosol[j] = 0.0;
-         else
-            zerovalid = false;
-      }
+template <class R> void SPxMainSM<R>::trivialHeuristic(SPxLPBase<R> &lp) {
+  VectorBase<R> zerosol(lp.nCols());  // the zero solution VectorBase<R>
+  VectorBase<R> lowersol(lp.nCols()); // the lower bound solution VectorBase<R>
+  VectorBase<R> uppersol(lp.nCols()); // the upper bound solution VectorBase<R>
+  VectorBase<R> locksol(lp.nCols());  // the locks solution VectorBase<R>
 
-      lowersol[j] = lower;
-      uppersol[j] = upper;
+  VectorBase<R> upLocks(lp.nCols());
+  VectorBase<R> downLocks(lp.nCols());
 
-      if(downLocks[j] > upLocks[j])
-         locksol[j] = upper;
-      else if(downLocks[j] < upLocks[j])
-         locksol[j] = lower;
-      else
-         locksol[j] = (lower + upper) / 2.0;
-
-      lowerObj += lp.maxObj(j) * lowersol[j];
-      upperObj += lp.maxObj(j) * uppersol[j];
-      lockObj += lp.maxObj(j) * locksol[j];
-   }
-
-   // trying the lower bound solution
-   if(checkSolution(lp, lowersol))
-   {
-      if(lowerObj > m_cutoffbound)
-         m_cutoffbound = lowerObj;
-   }
-
-   // trying the upper bound solution
-   if(checkSolution(lp, uppersol))
-   {
-      if(upperObj > m_cutoffbound)
-         m_cutoffbound = upperObj;
-   }
-
-   // trying the zero solution
-   if(zerovalid && checkSolution(lp, zerosol))
-   {
-      if(zeroObj > m_cutoffbound)
-         m_cutoffbound = zeroObj;
-   }
-
-   // trying the lock solution
-   if(checkSolution(lp, locksol))
-   {
-      if(lockObj > m_cutoffbound)
-         m_cutoffbound = lockObj;
-   }
-}
+  R zeroObj = this->m_objoffset;
+  R lowerObj = this->m_objoffset;
+  R upperObj = this->m_objoffset;
+  R lockObj = this->m_objoffset;
 
+  bool zerovalid = true;
 
+  R largeValue = R(infinity);
 
-/// checks a solution for feasibility
-template <class R>
-bool SPxMainSM<R>::checkSolution(SPxLPBase<R>& lp, VectorBase<R> sol)
-{
-   for(int i = lp.nRows() - 1; i >= 0; --i)
-   {
-      const SVectorBase<R>& row = lp.rowVector(i);
-      R activity = 0;
+  if (LT(R(1.0 / feastol()), R(infinity)))
+    largeValue = 1.0 / feastol();
 
-      for(int k = 0; k < row.size(); k++)
-         activity += row.value(k) * sol[row.index(k)];
+  for (int j = lp.nCols() - 1; j >= 0; --j) {
+    upLocks[j] = 0;
+    downLocks[j] = 0;
 
-      if(!GE(activity, lp.lhs(i), feastol()) || !LE(activity, lp.rhs(i), feastol()))
-         return false;
-   }
+    // computing the locks on the variables
+    const SVectorBase<R> &col = lp.colVector(j);
 
-   return true;
-}
+    for (int k = 0; k < col.size(); ++k) {
+      R aij = col.value(k);
 
+      ASSERT_WARN("WMAISM45", isNotZero(aij, R(1.0 / R(infinity))));
 
-/// tightens variable bounds by propagating the pseudo objective function value.
-template <class R>
-void SPxMainSM<R>::propagatePseudoobj(SPxLPBase<R>& lp)
-{
-   R pseudoObj = this->m_objoffset;
-
-   for(int j = lp.nCols() - 1; j >= 0; --j)
-   {
-      R val = lp.maxObj(j);
-
-      if(val < 0)
-      {
-         if(lp.lower(j) <= R(-infinity))
-            return;
-
-         pseudoObj += val * lp.lower(j);
+      if (GT(lp.lhs(col.index(k)), R(-infinity)) &&
+          LT(lp.rhs(col.index(k)), R(infinity))) {
+        upLocks[j]++;
+        downLocks[j]++;
+      } else if (GT(lp.lhs(col.index(k)), R(-infinity))) {
+        if (aij > 0)
+          downLocks[j]++;
+        else if (aij < 0)
+          upLocks[j]++;
+      } else if (LT(lp.rhs(col.index(k)), R(infinity))) {
+        if (aij > 0)
+          upLocks[j]++;
+        else if (aij < 0)
+          downLocks[j]++;
       }
-      else if(val > 0)
-      {
-         if(lp.upper(j) >= R(-infinity))
-            return;
+    }
 
-         pseudoObj += val * lp.upper(j);
-      }
-   }
+    R lower = lp.lower(j);
+    R upper = lp.upper(j);
 
-   if(GT(m_cutoffbound, R(-infinity)) && LT(m_cutoffbound, R(infinity)))
-   {
-      if(pseudoObj > m_pseudoobj)
-         m_pseudoobj = pseudoObj;
+    if (LE(lower, R(-infinity)))
+      lower = MINIMUM(-largeValue, upper);
 
-      for(int j = lp.nCols() - 1; j >= 0; --j)
-      {
-         R objval = lp.maxObj(j);
+    if (GE(upper, R(infinity)))
+      upper = MAXIMUM(lp.lower(j), largeValue);
 
-         if(EQ(objval, R(0.0)))
-            continue;
-
-         if(objval < 0.0)
-         {
-            R newbound = lp.lower(j) + (m_cutoffbound - m_pseudoobj) / objval;
-
-            if(LT(newbound, lp.upper(j)))
-            {
-               std::shared_ptr<PostStep> ptr(new TightenBoundsPS(lp, j, lp.upper(j), lp.lower(j)));
-               m_hist.append(ptr);
-               lp.changeUpper(j, newbound);
-            }
-         }
-         else if(objval > 0.0)
-         {
-            R newbound = lp.upper(j) + (m_cutoffbound - m_pseudoobj) / objval;
-
-            if(GT(newbound, lp.lower(j)))
-            {
-               std::shared_ptr<PostStep> ptr(new TightenBoundsPS(lp, j, lp.upper(j), lp.lower(j)));
-               m_hist.append(ptr);
-               lp.changeLower(j, newbound);
-            }
-         }
-      }
-   }
+    if (zerovalid) {
+      if (LE(lower, R(0.0), feastol()) && GE(upper, R(0.0), feastol()))
+        zerosol[j] = 0.0;
+      else
+        zerovalid = false;
+    }
+
+    lowersol[j] = lower;
+    uppersol[j] = upper;
+
+    if (downLocks[j] > upLocks[j])
+      locksol[j] = upper;
+    else if (downLocks[j] < upLocks[j])
+      locksol[j] = lower;
+    else
+      locksol[j] = (lower + upper) / 2.0;
+
+    lowerObj += lp.maxObj(j) * lowersol[j];
+    upperObj += lp.maxObj(j) * uppersol[j];
+    lockObj += lp.maxObj(j) * locksol[j];
+  }
+
+  // trying the lower bound solution
+  if (checkSolution(lp, lowersol)) {
+    if (lowerObj > m_cutoffbound)
+      m_cutoffbound = lowerObj;
+  }
+
+  // trying the upper bound solution
+  if (checkSolution(lp, uppersol)) {
+    if (upperObj > m_cutoffbound)
+      m_cutoffbound = upperObj;
+  }
+
+  // trying the zero solution
+  if (zerovalid && checkSolution(lp, zerosol)) {
+    if (zeroObj > m_cutoffbound)
+      m_cutoffbound = zeroObj;
+  }
+
+  // trying the lock solution
+  if (checkSolution(lp, locksol)) {
+    if (lockObj > m_cutoffbound)
+      m_cutoffbound = lockObj;
+  }
 }
 
-
-
+/// checks a solution for feasibility
 template <class R>
-typename SPxSimplifier<R>::Result SPxMainSM<R>::removeEmpty(SPxLPBase<R>& lp)
-{
+bool SPxMainSM<R>::checkSolution(SPxLPBase<R> &lp, VectorBase<R> sol) {
+  for (int i = lp.nRows() - 1; i >= 0; --i) {
+    const SVectorBase<R> &row = lp.rowVector(i);
+    R activity = 0;
 
-   // This method removes empty rows and columns from the LP.
+    for (int k = 0; k < row.size(); k++)
+      activity += row.value(k) * sol[row.index(k)];
 
-   int remRows = 0;
-   int remCols = 0;
+    if (!GE(activity, lp.lhs(i), feastol()) ||
+        !LE(activity, lp.rhs(i), feastol()))
+      return false;
+  }
 
-   for(int i = lp.nRows() - 1; i >= 0; --i)
-   {
-      const SVectorBase<R>& row = lp.rowVector(i);
-
-      if(row.size() == 0)
-      {
-         MSG_DEBUG((*this->spxout) << "IMAISM07 row " << i
-                   << ": empty ->";)
-
-         if(LT(lp.rhs(i), R(0.0), feastol()) || GT(lp.lhs(i), R(0.0), feastol()))
-         {
-            MSG_DEBUG((*this->spxout) << " infeasible lhs=" << lp.lhs(i)
-                      << " rhs=" << lp.rhs(i) << std::endl;)
-            return this->INFEASIBLE;
-         }
-
-         MSG_DEBUG((*this->spxout) << " removed" << std::endl;)
-
-         std::shared_ptr<PostStep> ptr(new EmptyConstraintPS(lp, i));
-         m_hist.append(ptr);
-
-         ++remRows;
-         removeRow(lp, i);
-
-         ++m_stat[EMPTY_ROW];
-      }
-   }
-
-   for(int j = lp.nCols() - 1; j >= 0; --j)
-   {
-      const SVectorBase<R>& col = lp.colVector(j);
-
-      if(col.size() == 0)
-      {
-         MSG_DEBUG((*this->spxout) << "IMAISM08 col " << j
-                   << ": empty -> maxObj=" << lp.maxObj(j)
-                   << " lower=" << lp.lower(j)
-                   << " upper=" << lp.upper(j);)
-
-         R val;
-
-         if(GT(lp.maxObj(j), R(0.0), this->epsZero()))
-         {
-            if(lp.upper(j) >= R(infinity))
-            {
-               MSG_DEBUG((*this->spxout) << " unbounded" << std::endl;)
-               return this->UNBOUNDED;
-            }
-
-            val = lp.upper(j);
-         }
-         else if(LT(lp.maxObj(j), R(0.0), this->epsZero()))
-         {
-            if(lp.lower(j) <= R(-infinity))
-            {
-               MSG_DEBUG((*this->spxout) << " unbounded" << std::endl;)
-               return this->UNBOUNDED;
-            }
-
-            val = lp.lower(j);
-         }
-         else
-         {
-            ASSERT_WARN("WMAISM09", isZero(lp.maxObj(j), this->epsZero()));
-
-            // any value within the bounds is ok
-            if(lp.lower(j) > R(-infinity))
-               val = lp.lower(j);
-            else if(lp.upper(j) < R(infinity))
-               val = lp.upper(j);
-            else
-               val = 0.0;
-         }
-
-         MSG_DEBUG((*this->spxout) << " removed" << std::endl;)
-
-         std::shared_ptr<PostStep> ptr1(new FixBoundsPS(lp, j, val));
-         std::shared_ptr<PostStep> ptr2(new FixVariablePS(lp, *this, j, val));
-         m_hist.append(ptr1);
-         m_hist.append(ptr2);
-
-         ++remCols;
-         removeCol(lp, j);
-
-         ++m_stat[EMPTY_COL];
-      }
-   }
-
-   if(remRows + remCols > 0)
-   {
-      this->m_remRows += remRows;
-      this->m_remCols += remCols;
-
-      MSG_INFO2((*this->spxout), (*this->spxout) << "Simplifier (empty rows/colums) removed "
-                << remRows << " rows, "
-                << remCols << " cols"
-                << std::endl;)
-
-   }
+  return true;
+}
 
-   return this->OKAY;
+/// tightens variable bounds by propagating the pseudo objective function value.
+template <class R> void SPxMainSM<R>::propagatePseudoobj(SPxLPBase<R> &lp) {
+  R pseudoObj = this->m_objoffset;
+
+  for (int j = lp.nCols() - 1; j >= 0; --j) {
+    R val = lp.maxObj(j);
+
+    if (val < 0) {
+      if (lp.lower(j) <= R(-infinity))
+        return;
+
+      pseudoObj += val * lp.lower(j);
+    } else if (val > 0) {
+      if (lp.upper(j) >= R(-infinity))
+        return;
+
+      pseudoObj += val * lp.upper(j);
+    }
+  }
+
+  if (GT(m_cutoffbound, R(-infinity)) && LT(m_cutoffbound, R(infinity))) {
+    if (pseudoObj > m_pseudoobj)
+      m_pseudoobj = pseudoObj;
+
+    for (int j = lp.nCols() - 1; j >= 0; --j) {
+      R objval = lp.maxObj(j);
+
+      if (EQ(objval, R(0.0)))
+        continue;
+
+      if (objval < 0.0) {
+        R newbound = lp.lower(j) + (m_cutoffbound - m_pseudoobj) / objval;
+
+        if (LT(newbound, lp.upper(j))) {
+          std::shared_ptr<PostStep> ptr(
+              new TightenBoundsPS(lp, j, lp.upper(j), lp.lower(j)));
+          m_hist.append(ptr);
+          lp.changeUpper(j, newbound);
+        }
+      } else if (objval > 0.0) {
+        R newbound = lp.upper(j) + (m_cutoffbound - m_pseudoobj) / objval;
+
+        if (GT(newbound, lp.lower(j))) {
+          std::shared_ptr<PostStep> ptr(
+              new TightenBoundsPS(lp, j, lp.upper(j), lp.lower(j)));
+          m_hist.append(ptr);
+          lp.changeLower(j, newbound);
+        }
+      }
+    }
+  }
 }
 
 template <class R>
-typename SPxSimplifier<R>::Result SPxMainSM<R>::removeRowSingleton(SPxLPBase<R>& lp,
-      const SVectorBase<R>& row, int& i)
-{
-   assert(row.size() == 1);
-
-   R aij = row.value(0);
-   int  j   = row.index(0);
-   R lo  = R(-infinity);
-   R up  =  R(infinity);
-
-   MSG_DEBUG((*this->spxout) << "IMAISM22 row " << i
-             << ": singleton -> val=" << aij
-             << " lhs=" << lp.lhs(i)
-             << " rhs=" << lp.rhs(i);)
-
-   if(GT(aij, R(0.0), this->epsZero()))            // aij > 0
-   {
-      lo = (lp.lhs(i) <= R(-infinity)) ? R(-infinity) : lp.lhs(i) / aij;
-      up = (lp.rhs(i) >=  R(infinity)) ?  R(infinity) : lp.rhs(i) / aij;
-   }
-   else if(LT(aij, R(0.0), this->epsZero()))       // aij < 0
-   {
-      lo = (lp.rhs(i) >=  R(infinity)) ? R(-infinity) : lp.rhs(i) / aij;
-      up = (lp.lhs(i) <= R(-infinity)) ?  R(infinity) : lp.lhs(i) / aij;
-   }
-   else if(LT(lp.rhs(i), R(0.0), feastol()) || GT(lp.lhs(i), R(0.0), feastol()))
-   {
-      // aij == 0, rhs < 0 or lhs > 0
-      MSG_DEBUG((*this->spxout) << " infeasible" << std::endl;)
-      return this->INFEASIBLE;
-   }
-
-   if(isZero(lo, this->epsZero()))
-      lo = 0.0;
+typename SPxSimplifier<R>::Result SPxMainSM<R>::removeEmpty(SPxLPBase<R> &lp) {
 
-   if(isZero(up, this->epsZero()))
-      up = 0.0;
+  // This method removes empty rows and columns from the LP.
 
-   MSG_DEBUG((*this->spxout) << " removed, lower=" << lo
-             << " (" << lp.lower(j)
-             << ") upper=" << up
-             << " (" << lp.upper(j)
-             << ")" << std::endl;)
+  int remRows = 0;
+  int remCols = 0;
 
-   bool stricterUp = false;
-   bool stricterLo = false;
+  for (int i = lp.nRows() - 1; i >= 0; --i) {
+    const SVectorBase<R> &row = lp.rowVector(i);
 
-   R oldLo = lp.lower(j);
-   R oldUp = lp.upper(j);
+    if (row.size() == 0) {
+      MSG_DEBUG((*this->spxout) << "IMAISM07 row " << i << ": empty ->";)
 
-   if(LTrel(up, lp.upper(j), feastol()))
-   {
-      lp.changeUpper(j, up);
-      stricterUp = true;
-   }
-
-   if(GTrel(lo, lp.lower(j), feastol()))
-   {
-      lp.changeLower(j, lo);
-      stricterLo = true;
-   }
-
-   std::shared_ptr<PostStep> ptr(new RowSingletonPS(lp, i, j, stricterLo, stricterUp, lp.lower(j),
-                                 lp.upper(j), oldLo, oldUp));
-   m_hist.append(ptr);
-
-   removeRow(lp, i);
+      if (LT(lp.rhs(i), R(0.0), feastol()) ||
+          GT(lp.lhs(i), R(0.0), feastol())) {
+        MSG_DEBUG((*this->spxout) << " infeasible lhs=" << lp.lhs(i)
+                                  << " rhs=" << lp.rhs(i) << std::endl;)
+        return this->INFEASIBLE;
+      }
 
-   this->m_remRows++;
-   this->m_remNzos++;
-   ++m_stat[SINGLETON_ROW];
+      MSG_DEBUG((*this->spxout) << " removed" << std::endl;)
 
-   return this->OKAY;
-}
-
-/// aggregate variable x_j to x_j = (rhs - aik * x_k) / aij from row i: aij * x_j + aik * x_k = rhs
-template <class R>
-typename SPxSimplifier<R>::Result SPxMainSM<R>::aggregateVars(SPxLPBase<R>& lp,
-      const SVectorBase<R>& row, int& i)
-{
-   assert(row.size() == 2);
-   assert(EQrel(lp.lhs(i), lp.rhs(i), feastol()));
-
-   R rhs = lp.rhs(i);
-   assert(rhs < R(infinity) && rhs > R(-infinity));
-
-   int j = row.index(0);
-   int k = row.index(1);
-   R aij = row.value(0);
-   R aik = row.value(1);
-   R lower_j = lp.lower(j);
-   R upper_j = lp.upper(j);
-   R lower_k = lp.lower(k);
-   R upper_k = lp.upper(k);
-
-   // fixed variables should be removed by simplifyCols()
-   if(EQrel(lower_j, upper_j, feastol()) || EQrel(lower_k, upper_k, feastol()))
-      return this->OKAY;
-
-   assert(isNotZero(aij, this->epsZero()) && isNotZero(aik, this->epsZero()));
-
-   MSG_DEBUG((*this->spxout) << "IMAISM22 row " << i << ": doubleton equation -> "
-             << aij << " x_" << j << " + " << aik << " x_" << k << " = " << rhs;)
-
-   // determine which variable can be aggregated without requiring bound tightening of the other variable
-   R new_lo_j;
-   R new_up_j;
-   R new_lo_k;
-   R new_up_k;
-
-   if(aij * aik < 0.0)
-   {
-      // orientation persists
-      new_lo_j = (upper_k >=  R(infinity)) ? R(-infinity) : (rhs - aik * upper_k) / aij;
-      new_up_j = (lower_k <= R(-infinity)) ?  R(infinity) : (rhs - aik * lower_k) / aij;
-      new_lo_k = (upper_j >=  R(infinity)) ? R(-infinity) : (rhs - aij * upper_j) / aik;
-      new_up_k = (lower_j <= R(-infinity)) ?  R(infinity) : (rhs - aij * lower_j) / aik;
-   }
-   else if(aij * aik > 0.0)
-   {
-      // orientation is reversed
-      new_lo_j = (lower_k <= R(-infinity)) ? R(-infinity) : (rhs - aik * lower_k) / aij;
-      new_up_j = (upper_k >=  R(infinity)) ?  R(infinity) : (rhs - aik * upper_k) / aij;
-      new_lo_k = (lower_j <= R(-infinity)) ? R(-infinity) : (rhs - aij * lower_j) / aik;
-      new_up_k = (upper_j >=  R(infinity)) ?  R(infinity) : (rhs - aij * upper_j) / aik;
-   }
-   else
-      throw SPxInternalCodeException("XMAISM12 This should never happen.");
-
-   bool flip_jk = false;
-
-   if(new_lo_j <= R(-infinity) && new_up_j >= R(infinity))
-   {
-      // no bound tightening on x_j when x_k is aggregated
-      flip_jk = true;
-   }
-   else if(new_lo_k <= R(-infinity) && new_up_k >= R(infinity))
-   {
-      // no bound tightening on x_k when x_j is aggregated
-      flip_jk = false;
-   }
-   else if(LE(new_lo_j, lower_j) && GE(new_up_j, upper_j))
-   {
-      if(LE(new_lo_k, lower_k) && GE(new_up_k, upper_k))
-      {
-         // both variables' bounds are not affected by aggregation; choose the better aggregation coeff (aik/aij)
-         if(spxAbs(aij) > spxAbs(aik))
-            flip_jk = false;
-         else
-            flip_jk = true;
-      }
-      else
-         flip_jk = false;
-   }
-   else if(LE(new_lo_k, lower_k) && GE(new_up_k, upper_k))
-   {
-      flip_jk = true;
-   }
-   else
-   {
-      if(spxAbs(aij) > spxAbs(aik))
-         flip_jk = false;
-      else
-         flip_jk = true;
-   }
-
-   if(flip_jk)
-   {
-      int _j = j;
-      R _aij = aij;
-      R _lower_j = lower_j;
-      R _upper_j = upper_j;
-      j = k;
-      k = _j;
-      aij = aik;
-      aik = _aij;
-      lower_j = lower_k;
-      lower_k = _lower_j;
-      upper_j = upper_k;
-      upper_k = _upper_j;
-   }
-
-   const SVectorBase<R>& col_j = lp.colVector(j);
-   const SVectorBase<R>& col_k = lp.colVector(k);
-
-   // aggregation coefficients (x_j = aggr_coef * x_k + aggr_const)
-   R aggr_coef = - (aik / aij);
-   R aggr_const = rhs / aij;
-
-   MSG_DEBUG((*this->spxout) << " removed, replacing x_" << j << " with "
-             << aggr_const << " + " << aggr_coef << " * x_" << k << std::endl;)
-
-   // replace all occurrences of x_j
-   for(int r = 0; r < col_j.size(); ++r)
-   {
-      int row_r = col_j.index(r);
-      R arj = col_j.value(r);
-
-      // skip row i
-      if(row_r == i)
-         continue;
-
-      // adapt sides of row r
-      R lhs_r = lp.lhs(row_r);
-      R rhs_r = lp.rhs(row_r);
-
-      if(lhs_r > R(-infinity))
-      {
-         lp.changeLhs(row_r, lhs_r - aggr_const * arj);
-         this->m_chgLRhs++;
-      }
+      std::shared_ptr<PostStep> ptr(new EmptyConstraintPS(lp, i));
+      m_hist.append(ptr);
 
-      if(rhs_r < R(infinity))
-      {
-         lp.changeRhs(row_r, rhs_r - aggr_const * arj);
-         this->m_chgLRhs++;
-      }
+      ++remRows;
+      removeRow(lp, i);
 
-      R newcoef = aggr_coef * arj;
-      int pos_rk = col_k.pos(row_r);
+      ++m_stat[EMPTY_ROW];
+    }
+  }
 
-      // check whether x_k is also present in row r and get its coefficient
-      if(pos_rk >= 0)
-      {
-         R ark = col_k.value(pos_rk);
-         newcoef += ark;
-         this->m_remNzos++;
-      }
+  for (int j = lp.nCols() - 1; j >= 0; --j) {
+    const SVectorBase<R> &col = lp.colVector(j);
 
-      // add new column k to row r or adapt the coefficient a_rk
-      lp.changeElement(row_r, k, newcoef);
-   }
+    if (col.size() == 0) {
+      MSG_DEBUG((*this->spxout) << "IMAISM08 col " << j << ": empty -> maxObj="
+                                << lp.maxObj(j) << " lower=" << lp.lower(j)
+                                << " upper=" << lp.upper(j);)
 
-   // adapt objective function
-   R obj_j = lp.obj(j);
+      R val;
 
-   if(isNotZero(obj_j, this->epsZero()))
-   {
-      this->addObjoffset(aggr_const * obj_j);
-      R obj_k = lp.obj(k);
-      lp.changeObj(k, obj_k + aggr_coef * obj_j);
-   }
+      if (GT(lp.maxObj(j), R(0.0), this->epsZero())) {
+        if (lp.upper(j) >= R(infinity)) {
+          MSG_DEBUG((*this->spxout) << " unbounded" << std::endl;)
+          return this->UNBOUNDED;
+        }
 
-   // adapt bounds of x_k
-   R scale1 = maxAbs(rhs, aij * upper_j);
-   R scale2 = maxAbs(rhs, aij * lower_j);
+        val = lp.upper(j);
+      } else if (LT(lp.maxObj(j), R(0.0), this->epsZero())) {
+        if (lp.lower(j) <= R(-infinity)) {
+          MSG_DEBUG((*this->spxout) << " unbounded" << std::endl;)
+          return this->UNBOUNDED;
+        }
 
-   if(scale1 < 1.0)
-      scale1 = 1.0;
+        val = lp.lower(j);
+      } else {
+        ASSERT_WARN("WMAISM09", isZero(lp.maxObj(j), this->epsZero()));
 
-   if(scale2 < 1.0)
-      scale2 = 1.0;
+        // any value within the bounds is ok
+        if (lp.lower(j) > R(-infinity))
+          val = lp.lower(j);
+        else if (lp.upper(j) < R(infinity))
+          val = lp.upper(j);
+        else
+          val = 0.0;
+      }
 
-   R z1 = (rhs / scale1) - (aij * upper_j / scale1);
-   R z2 = (rhs / scale2) - (aij * lower_j / scale2);
+      MSG_DEBUG((*this->spxout) << " removed" << std::endl;)
 
-   // just some rounding
-   if(isZero(z1, this->epsZero()))
-      z1 = 0.0;
+      std::shared_ptr<PostStep> ptr1(new FixBoundsPS(lp, j, val));
+      std::shared_ptr<PostStep> ptr2(new FixVariablePS(lp, *this, j, val));
+      m_hist.append(ptr1);
+      m_hist.append(ptr2);
 
-   if(isZero(z2, this->epsZero()))
-      z2 = 0.0;
+      ++remCols;
+      removeCol(lp, j);
+
+      ++m_stat[EMPTY_COL];
+    }
+  }
 
-   // determine which side has to be used for the bounds comparison below
-   if(aik * aij > 0.0)
-   {
-      new_lo_k = (upper_j >=  R(infinity)) ? R(-infinity) : z1 * scale1 / aik;
-      new_up_k = (lower_j <= R(-infinity)) ?  R(infinity) : z2 * scale2 / aik;
-   }
-   else if(aik * aij < 0.0)
-   {
-      new_lo_k = (lower_j <= R(-infinity)) ? R(-infinity) : z2 * scale2 / aik;
-      new_up_k = (upper_j >=  R(infinity)) ?  R(infinity) : z1 * scale1 / aik;
-   }
-   else
-      throw SPxInternalCodeException("XMAISM12 This should never happen.");
-
-   // change bounds of x_k if the new ones are tighter
-   R oldlower_k = lower_k;
-   R oldupper_k = upper_k;
-
-   if(GT(new_lo_k, lower_k, this->epsZero()))
-   {
-      lp.changeLower(k, new_lo_k);
-      this->m_chgBnds++;
-   }
-
-   if(LT(new_up_k, upper_k, this->epsZero()))
-   {
-      lp.changeUpper(k, new_up_k);
-      this->m_chgBnds++;
-   }
-
-   std::shared_ptr<PostStep> ptr(new AggregationPS(lp, i, j, rhs, oldupper_k, oldlower_k));
-   m_hist.append(ptr);
-
-   removeRow(lp, i);
-   removeCol(lp, j);
-
-   this->m_remRows++;
-   this->m_remCols++;
-   this->m_remNzos += 2;
-
-   ++m_stat[AGGREGATION];
-
-   return this->OKAY;
+  if (remRows + remCols > 0) {
+    this->m_remRows += remRows;
+    this->m_remCols += remCols;
+
+    MSG_INFO2((*this->spxout), (*this->spxout)
+                                   << "Simplifier (empty rows/colums) removed "
+                                   << remRows << " rows, " << remCols << " cols"
+                                   << std::endl;)
+  }
+
+  return this->OKAY;
 }
 
 template <class R>
-typename SPxSimplifier<R>::Result SPxMainSM<R>::simplifyRows(SPxLPBase<R>& lp, bool& again)
-{
-
-   // This method simplifies the rows of the LP.
-   //
-   // The following operations are done:
-   // 1. detect implied free variables
-   // 2. detect implied free constraints
-   // 3. detect infeasible constraints
-   // 4. remove unconstrained constraints
-   // 5. remove empty constraints
-   // 6. remove row singletons and tighten the corresponding variable bounds if necessary
-   // 7. remove doubleton equation, aka aggregation
-   // 8. detect forcing rows and fix the corresponding variables
-
-   int remRows = 0;
-   int remNzos = 0;
-   int chgLRhs = 0;
-   int chgBnds = 0;
-   int keptBnds = 0;
-   int keptLRhs = 0;
-
-   int oldRows = lp.nRows();
-
-   bool redundantLower;
-   bool redundantUpper;
-   bool redundantLhs;
-   bool redundantRhs;
-
-   for(int i = lp.nRows() - 1; i >= 0; --i)
-   {
-      const SVectorBase<R>& row = lp.rowVector(i);
-
-
-      // compute bounds on constraint value
-      R lhsBnd = 0.0; // minimal activity (finite summands)
-      R rhsBnd = 0.0; // maximal activity (finite summands)
-      int  lhsCnt = 0; // number of R(-infinity) summands in minimal activity
-      int  rhsCnt = 0; // number of +R(infinity) summands in maximal activity
-
-      for(int k = 0; k < row.size(); ++k)
-      {
-         R aij = row.value(k);
-         int  j   = row.index(k);
-
-         if(!isNotZero(aij, R(1.0 / R(infinity))))
-         {
-            MSG_WARNING((*this->spxout), (*this->spxout) << "Warning: tiny nonzero coefficient " << aij <<
-                        " in row " << i << "\n");
-         }
-
-         if(aij > 0.0)
-         {
-            if(lp.lower(j) <= R(-infinity))
-               ++lhsCnt;
-            else
-               lhsBnd += aij * lp.lower(j);
+typename SPxSimplifier<R>::Result
+SPxMainSM<R>::removeRowSingleton(SPxLPBase<R> &lp, const SVectorBase<R> &row,
+                                 int &i) {
+  assert(row.size() == 1);
+
+  R aij = row.value(0);
+  int j = row.index(0);
+  R lo = R(-infinity);
+  R up = R(infinity);
+
+  MSG_DEBUG((*this->spxout)
+                << "IMAISM22 row " << i << ": singleton -> val=" << aij
+                << " lhs=" << lp.lhs(i) << " rhs=" << lp.rhs(i);)
+
+  if (GT(aij, R(0.0), this->epsZero())) // aij > 0
+  {
+    lo = (lp.lhs(i) <= R(-infinity)) ? R(-infinity) : lp.lhs(i) / aij;
+    up = (lp.rhs(i) >= R(infinity)) ? R(infinity) : lp.rhs(i) / aij;
+  } else if (LT(aij, R(0.0), this->epsZero())) // aij < 0
+  {
+    lo = (lp.rhs(i) >= R(infinity)) ? R(-infinity) : lp.rhs(i) / aij;
+    up = (lp.lhs(i) <= R(-infinity)) ? R(infinity) : lp.lhs(i) / aij;
+  } else if (LT(lp.rhs(i), R(0.0), feastol()) ||
+             GT(lp.lhs(i), R(0.0), feastol())) {
+    // aij == 0, rhs < 0 or lhs > 0
+    MSG_DEBUG((*this->spxout) << " infeasible" << std::endl;)
+    return this->INFEASIBLE;
+  }
+
+  if (isZero(lo, this->epsZero()))
+    lo = 0.0;
+
+  if (isZero(up, this->epsZero()))
+    up = 0.0;
+
+  MSG_DEBUG((*this->spxout)
+                << " removed, lower=" << lo << " (" << lp.lower(j)
+                << ") upper=" << up << " (" << lp.upper(j) << ")" << std::endl;)
+
+  bool stricterUp = false;
+  bool stricterLo = false;
+
+  R oldLo = lp.lower(j);
+  R oldUp = lp.upper(j);
+
+  if (LTrel(up, lp.upper(j), feastol())) {
+    lp.changeUpper(j, up);
+    stricterUp = true;
+  }
+
+  if (GTrel(lo, lp.lower(j), feastol())) {
+    lp.changeLower(j, lo);
+    stricterLo = true;
+  }
+
+  std::shared_ptr<PostStep> ptr(new RowSingletonPS(lp, i, j, stricterLo,
+                                                   stricterUp, lp.lower(j),
+                                                   lp.upper(j), oldLo, oldUp));
+  m_hist.append(ptr);
+
+  removeRow(lp, i);
+
+  this->m_remRows++;
+  this->m_remNzos++;
+  ++m_stat[SINGLETON_ROW];
+
+  return this->OKAY;
+}
 
-            if(lp.upper(j) >= R(infinity))
-               ++rhsCnt;
-            else
-               rhsBnd += aij * lp.upper(j);
-         }
-         else if(aij < 0.0)
-         {
-            if(lp.lower(j) <= R(-infinity))
-               ++rhsCnt;
-            else
-               rhsBnd += aij * lp.lower(j);
+/// aggregate variable x_j to x_j = (rhs - aik * x_k) / aij from row i: aij *
+/// x_j + aik * x_k = rhs
+template <class R>
+typename SPxSimplifier<R>::Result
+SPxMainSM<R>::aggregateVars(SPxLPBase<R> &lp, const SVectorBase<R> &row,
+                            int &i) {
+  assert(row.size() == 2);
+  assert(EQrel(lp.lhs(i), lp.rhs(i), feastol()));
+
+  R rhs = lp.rhs(i);
+  assert(rhs < R(infinity) && rhs > R(-infinity));
+
+  int j = row.index(0);
+  int k = row.index(1);
+  R aij = row.value(0);
+  R aik = row.value(1);
+  R lower_j = lp.lower(j);
+  R upper_j = lp.upper(j);
+  R lower_k = lp.lower(k);
+  R upper_k = lp.upper(k);
+
+  // fixed variables should be removed by simplifyCols()
+  if (EQrel(lower_j, upper_j, feastol()) || EQrel(lower_k, upper_k, feastol()))
+    return this->OKAY;
+
+  assert(isNotZero(aij, this->epsZero()) && isNotZero(aik, this->epsZero()));
+
+  MSG_DEBUG((*this->spxout)
+                << "IMAISM22 row " << i << ": doubleton equation -> " << aij
+                << " x_" << j << " + " << aik << " x_" << k << " = " << rhs;)
+
+  // determine which variable can be aggregated without requiring bound
+  // tightening of the other variable
+  R new_lo_j;
+  R new_up_j;
+  R new_lo_k;
+  R new_up_k;
+
+  if (aij * aik < 0.0) {
+    // orientation persists
+    new_lo_j =
+        (upper_k >= R(infinity)) ? R(-infinity) : (rhs - aik * upper_k) / aij;
+    new_up_j =
+        (lower_k <= R(-infinity)) ? R(infinity) : (rhs - aik * lower_k) / aij;
+    new_lo_k =
+        (upper_j >= R(infinity)) ? R(-infinity) : (rhs - aij * upper_j) / aik;
+    new_up_k =
+        (lower_j <= R(-infinity)) ? R(infinity) : (rhs - aij * lower_j) / aik;
+  } else if (aij * aik > 0.0) {
+    // orientation is reversed
+    new_lo_j =
+        (lower_k <= R(-infinity)) ? R(-infinity) : (rhs - aik * lower_k) / aij;
+    new_up_j =
+        (upper_k >= R(infinity)) ? R(infinity) : (rhs - aik * upper_k) / aij;
+    new_lo_k =
+        (lower_j <= R(-infinity)) ? R(-infinity) : (rhs - aij * lower_j) / aik;
+    new_up_k =
+        (upper_j >= R(infinity)) ? R(infinity) : (rhs - aij * upper_j) / aik;
+  } else
+    throw SPxInternalCodeException("XMAISM12 This should never happen.");
+
+  bool flip_jk = false;
+
+  if (new_lo_j <= R(-infinity) && new_up_j >= R(infinity)) {
+    // no bound tightening on x_j when x_k is aggregated
+    flip_jk = true;
+  } else if (new_lo_k <= R(-infinity) && new_up_k >= R(infinity)) {
+    // no bound tightening on x_k when x_j is aggregated
+    flip_jk = false;
+  } else if (LE(new_lo_j, lower_j) && GE(new_up_j, upper_j)) {
+    if (LE(new_lo_k, lower_k) && GE(new_up_k, upper_k)) {
+      // both variables' bounds are not affected by aggregation; choose the
+      // better aggregation coeff (aik/aij)
+      if (spxAbs(aij) > spxAbs(aik))
+        flip_jk = false;
+      else
+        flip_jk = true;
+    } else
+      flip_jk = false;
+  } else if (LE(new_lo_k, lower_k) && GE(new_up_k, upper_k)) {
+    flip_jk = true;
+  } else {
+    if (spxAbs(aij) > spxAbs(aik))
+      flip_jk = false;
+    else
+      flip_jk = true;
+  }
+
+  if (flip_jk) {
+    int _j = j;
+    R _aij = aij;
+    R _lower_j = lower_j;
+    R _upper_j = upper_j;
+    j = k;
+    k = _j;
+    aij = aik;
+    aik = _aij;
+    lower_j = lower_k;
+    lower_k = _lower_j;
+    upper_j = upper_k;
+    upper_k = _upper_j;
+  }
+
+  const SVectorBase<R> &col_j = lp.colVector(j);
+  const SVectorBase<R> &col_k = lp.colVector(k);
+
+  // aggregation coefficients (x_j = aggr_coef * x_k + aggr_const)
+  R aggr_coef = -(aik / aij);
+  R aggr_const = rhs / aij;
+
+  MSG_DEBUG((*this->spxout)
+                << " removed, replacing x_" << j << " with " << aggr_const
+                << " + " << aggr_coef << " * x_" << k << std::endl;)
+
+  // replace all occurrences of x_j
+  for (int r = 0; r < col_j.size(); ++r) {
+    int row_r = col_j.index(r);
+    R arj = col_j.value(r);
+
+    // skip row i
+    if (row_r == i)
+      continue;
+
+    // adapt sides of row r
+    R lhs_r = lp.lhs(row_r);
+    R rhs_r = lp.rhs(row_r);
+
+    if (lhs_r > R(-infinity)) {
+      lp.changeLhs(row_r, lhs_r - aggr_const * arj);
+      this->m_chgLRhs++;
+    }
+
+    if (rhs_r < R(infinity)) {
+      lp.changeRhs(row_r, rhs_r - aggr_const * arj);
+      this->m_chgLRhs++;
+    }
+
+    R newcoef = aggr_coef * arj;
+    int pos_rk = col_k.pos(row_r);
+
+    // check whether x_k is also present in row r and get its coefficient
+    if (pos_rk >= 0) {
+      R ark = col_k.value(pos_rk);
+      newcoef += ark;
+      this->m_remNzos++;
+    }
+
+    // add new column k to row r or adapt the coefficient a_rk
+    lp.changeElement(row_r, k, newcoef);
+  }
+
+  // adapt objective function
+  R obj_j = lp.obj(j);
+
+  if (isNotZero(obj_j, this->epsZero())) {
+    this->addObjoffset(aggr_const * obj_j);
+    R obj_k = lp.obj(k);
+    lp.changeObj(k, obj_k + aggr_coef * obj_j);
+  }
+
+  // adapt bounds of x_k
+  R scale1 = maxAbs(rhs, aij * upper_j);
+  R scale2 = maxAbs(rhs, aij * lower_j);
+
+  if (scale1 < 1.0)
+    scale1 = 1.0;
+
+  if (scale2 < 1.0)
+    scale2 = 1.0;
+
+  R z1 = (rhs / scale1) - (aij * upper_j / scale1);
+  R z2 = (rhs / scale2) - (aij * lower_j / scale2);
+
+  // just some rounding
+  if (isZero(z1, this->epsZero()))
+    z1 = 0.0;
+
+  if (isZero(z2, this->epsZero()))
+    z2 = 0.0;
+
+  // determine which side has to be used for the bounds comparison below
+  if (aik * aij > 0.0) {
+    new_lo_k = (upper_j >= R(infinity)) ? R(-infinity) : z1 * scale1 / aik;
+    new_up_k = (lower_j <= R(-infinity)) ? R(infinity) : z2 * scale2 / aik;
+  } else if (aik * aij < 0.0) {
+    new_lo_k = (lower_j <= R(-infinity)) ? R(-infinity) : z2 * scale2 / aik;
+    new_up_k = (upper_j >= R(infinity)) ? R(infinity) : z1 * scale1 / aik;
+  } else
+    throw SPxInternalCodeException("XMAISM12 This should never happen.");
+
+  // change bounds of x_k if the new ones are tighter
+  R oldlower_k = lower_k;
+  R oldupper_k = upper_k;
+
+  if (GT(new_lo_k, lower_k, this->epsZero())) {
+    lp.changeLower(k, new_lo_k);
+    this->m_chgBnds++;
+  }
+
+  if (LT(new_up_k, upper_k, this->epsZero())) {
+    lp.changeUpper(k, new_up_k);
+    this->m_chgBnds++;
+  }
+
+  std::shared_ptr<PostStep> ptr(
+      new AggregationPS(lp, i, j, rhs, oldupper_k, oldlower_k));
+  m_hist.append(ptr);
+
+  removeRow(lp, i);
+  removeCol(lp, j);
+
+  this->m_remRows++;
+  this->m_remCols++;
+  this->m_remNzos += 2;
+
+  ++m_stat[AGGREGATION];
+
+  return this->OKAY;
+}
 
-            if(lp.upper(j) >= R(infinity))
-               ++lhsCnt;
-            else
-               lhsBnd += aij * lp.upper(j);
-         }
-      }
+template <class R>
+typename SPxSimplifier<R>::Result SPxMainSM<R>::simplifyRows(SPxLPBase<R> &lp,
+                                                             bool &again) {
+
+  // This method simplifies the rows of the LP.
+  //
+  // The following operations are done:
+  // 1. detect implied free variables
+  // 2. detect implied free constraints
+  // 3. detect infeasible constraints
+  // 4. remove unconstrained constraints
+  // 5. remove empty constraints
+  // 6. remove row singletons and tighten the corresponding variable bounds if
+  // necessary
+  // 7. remove doubleton equation, aka aggregation
+  // 8. detect forcing rows and fix the corresponding variables
+
+  int remRows = 0;
+  int remNzos = 0;
+  int chgLRhs = 0;
+  int chgBnds = 0;
+  int keptBnds = 0;
+  int keptLRhs = 0;
+
+  int oldRows = lp.nRows();
+
+  bool redundantLower;
+  bool redundantUpper;
+  bool redundantLhs;
+  bool redundantRhs;
+
+  for (int i = lp.nRows() - 1; i >= 0; --i) {
+    const SVectorBase<R> &row = lp.rowVector(i);
+
+    // compute bounds on constraint value
+    R lhsBnd = 0.0; // minimal activity (finite summands)
+    R rhsBnd = 0.0; // maximal activity (finite summands)
+    int lhsCnt = 0; // number of R(-infinity) summands in minimal activity
+    int rhsCnt = 0; // number of +R(infinity) summands in maximal activity
+
+    for (int k = 0; k < row.size(); ++k) {
+      R aij = row.value(k);
+      int j = row.index(k);
+
+      if (!isNotZero(aij, R(1.0 / R(infinity)))) {
+        MSG_WARNING((*this->spxout), (*this->spxout)
+                                         << "Warning: tiny nonzero coefficient "
+                                         << aij << " in row " << i << "\n");
+      }
+
+      if (aij > 0.0) {
+        if (lp.lower(j) <= R(-infinity))
+          ++lhsCnt;
+        else
+          lhsBnd += aij * lp.lower(j);
+
+        if (lp.upper(j) >= R(infinity))
+          ++rhsCnt;
+        else
+          rhsBnd += aij * lp.upper(j);
+      } else if (aij < 0.0) {
+        if (lp.lower(j) <= R(-infinity))
+          ++rhsCnt;
+        else
+          rhsBnd += aij * lp.lower(j);
+
+        if (lp.upper(j) >= R(infinity))
+          ++lhsCnt;
+        else
+          lhsBnd += aij * lp.upper(j);
+      }
+    }
 
 #if FREE_BOUNDS
 
-      // 1. detect implied free variables
-      if(rhsCnt <= 1 || lhsCnt <= 1)
-      {
-         for(int k = 0; k < row.size(); ++k)
-         {
-            R aij = row.value(k);
-            int  j   = row.index(k);
-
-            redundantLower = false;
-            redundantUpper = false;
+    // 1. detect implied free variables
+    if (rhsCnt <= 1 || lhsCnt <= 1) {
+      for (int k = 0; k < row.size(); ++k) {
+        R aij = row.value(k);
+        int j = row.index(k);
 
-            ASSERT_WARN("WMAISM12", isNotZero(aij, R(1.0 / R(infinity))));
+        redundantLower = false;
+        redundantUpper = false;
 
-            if(aij > 0.0)
-            {
-               if(lp.lhs(i) > R(-infinity) && lp.lower(j) > R(-infinity) && rhsCnt <= 1
-                     && NErel(lp.lhs(i), rhsBnd, feastol())
-                     // do not perform if strongly different orders of magnitude occur
-                     && spxAbs(lp.lhs(i) / maxAbs(rhsBnd, R(1.0))) > Param::epsilon())
-               {
-                  R lo    = R(-infinity);
-                  R scale = maxAbs(lp.lhs(i), rhsBnd);
+        ASSERT_WARN("WMAISM12", isNotZero(aij, R(1.0 / R(infinity))));
 
-                  if(scale < 1.0)
-                     scale = 1.0;
+        if (aij > 0.0) {
+          if (lp.lhs(i) > R(-infinity) && lp.lower(j) > R(-infinity) &&
+              rhsCnt <= 1 &&
+              NErel(lp.lhs(i), rhsBnd, feastol())
+              // do not perform if strongly different orders of magnitude occur
+              &&
+              spxAbs(lp.lhs(i) / maxAbs(rhsBnd, R(1.0))) > Param::epsilon()) {
+            R lo = R(-infinity);
+            R scale = maxAbs(lp.lhs(i), rhsBnd);
 
-                  R z = (lp.lhs(i) / scale) - (rhsBnd / scale);
+            if (scale < 1.0)
+              scale = 1.0;
 
-                  if(isZero(z, this->epsZero()))
-                     z = 0.0;
+            R z = (lp.lhs(i) / scale) - (rhsBnd / scale);
 
-                  assert(rhsCnt > 0 || lp.upper(j) < R(infinity));
+            if (isZero(z, this->epsZero()))
+              z = 0.0;
 
-                  if(rhsCnt == 0)
-                     lo = lp.upper(j) + z * scale / aij;
-                  else if(lp.upper(j) >= R(infinity))
-                     lo = z * scale / aij;
+            assert(rhsCnt > 0 || lp.upper(j) < R(infinity));
 
-                  if(isZero(lo, this->epsZero()))
-                     lo = 0.0;
+            if (rhsCnt == 0)
+              lo = lp.upper(j) + z * scale / aij;
+            else if (lp.upper(j) >= R(infinity))
+              lo = z * scale / aij;
 
-                  if(GErel(lo, lp.lower(j), feastol()))
-                  {
-                     MSG_DEBUG((*this->spxout) << "IMAISM13 row " << i
-                               << ": redundant lower bound on x" << j
-                               << " -> lower=" << lo
-                               << " (" << lp.lower(j)
-                               << ")" << std::endl;)
+            if (isZero(lo, this->epsZero()))
+              lo = 0.0;
 
-                     redundantLower = true;
-                  }
+            if (GErel(lo, lp.lower(j), feastol())) {
+              MSG_DEBUG((*this->spxout) << "IMAISM13 row " << i
+                                        << ": redundant lower bound on x" << j
+                                        << " -> lower=" << lo << " ("
+                                        << lp.lower(j) << ")" << std::endl;)
 
-               }
+              redundantLower = true;
+            }
+          }
 
-               if(lp.rhs(i) < R(infinity) && lp.upper(j) < R(infinity) && lhsCnt <= 1
-                     && NErel(lp.rhs(i), lhsBnd, feastol())
-                     // do not perform if strongly different orders of magnitude occur
-                     && spxAbs(lp.rhs(i) / maxAbs(lhsBnd, R(1.0))) > Param::epsilon())
-               {
-                  R up    = R(infinity);
-                  R scale = maxAbs(lp.rhs(i), lhsBnd);
+          if (lp.rhs(i) < R(infinity) && lp.upper(j) < R(infinity) &&
+              lhsCnt <= 1 &&
+              NErel(lp.rhs(i), lhsBnd, feastol())
+              // do not perform if strongly different orders of magnitude occur
+              &&
+              spxAbs(lp.rhs(i) / maxAbs(lhsBnd, R(1.0))) > Param::epsilon()) {
+            R up = R(infinity);
+            R scale = maxAbs(lp.rhs(i), lhsBnd);
 
-                  if(scale < 1.0)
-                     scale = 1.0;
+            if (scale < 1.0)
+              scale = 1.0;
 
-                  R z = (lp.rhs(i) / scale) - (lhsBnd / scale);
+            R z = (lp.rhs(i) / scale) - (lhsBnd / scale);
 
-                  if(isZero(z, this->epsZero()))
-                     z = 0.0;
+            if (isZero(z, this->epsZero()))
+              z = 0.0;
 
-                  assert(lhsCnt > 0 || lp.lower(j) > R(-infinity));
+            assert(lhsCnt > 0 || lp.lower(j) > R(-infinity));
 
-                  if(lhsCnt == 0)
-                     up = lp.lower(j) + z * scale / aij;
-                  else if(lp.lower(j) <= R(-infinity))
-                     up = z * scale / aij;
+            if (lhsCnt == 0)
+              up = lp.lower(j) + z * scale / aij;
+            else if (lp.lower(j) <= R(-infinity))
+              up = z * scale / aij;
 
-                  if(isZero(up, this->epsZero()))
-                     up = 0.0;
+            if (isZero(up, this->epsZero()))
+              up = 0.0;
 
-                  if(LErel(up, lp.upper(j), feastol()))
-                  {
-                     MSG_DEBUG((*this->spxout) << "IMAISM14 row " << i
-                               << ": redundant upper bound on x" << j
-                               << " -> upper=" << up
-                               << " (" << lp.upper(j)
-                               << ")" << std::endl;)
+            if (LErel(up, lp.upper(j), feastol())) {
+              MSG_DEBUG((*this->spxout) << "IMAISM14 row " << i
+                                        << ": redundant upper bound on x" << j
+                                        << " -> upper=" << up << " ("
+                                        << lp.upper(j) << ")" << std::endl;)
 
-                     redundantUpper = true;
-                  }
-               }
-
-               if(redundantLower)
-               {
-                  // no upper bound on x_j OR redundant upper bound
-                  if((lp.upper(j) >= R(infinity)) || redundantUpper || (!m_keepbounds))
-                  {
-                     ++lhsCnt;
-                     lhsBnd -= aij * lp.lower(j);
-
-                     lp.changeLower(j, R(-infinity));
-                     ++chgBnds;
-                  }
-                  else
-                     ++keptBnds;
-               }
-
-               if(redundantUpper)
-               {
-                  // no lower bound on x_j OR redundant lower bound
-                  if((lp.lower(j) <= R(-infinity)) || redundantLower || (!m_keepbounds))
-                  {
-                     ++rhsCnt;
-                     rhsBnd -= aij * lp.upper(j);
-
-                     lp.changeUpper(j, R(infinity));
-                     ++chgBnds;
-                  }
-                  else
-                     ++keptBnds;
-               }
+              redundantUpper = true;
             }
-            else if(aij < 0.0)
-            {
-               if(lp.lhs(i) > R(-infinity) && lp.upper(j) < R(infinity) && rhsCnt <= 1
-                     && NErel(lp.lhs(i), rhsBnd, feastol())
-                     // do not perform if strongly different orders of magnitude occur
-                     && spxAbs(lp.lhs(i) / maxAbs(rhsBnd, R(1.0))) > Param::epsilon())
-               {
-                  R up    = R(infinity);
-                  R scale = maxAbs(lp.lhs(i), rhsBnd);
-
-                  if(scale < 1.0)
-                     scale = 1.0;
-
-                  R z = (lp.lhs(i) / scale) - (rhsBnd / scale);
-
-                  if(isZero(z, this->epsZero()))
-                     z = 0.0;
-
-                  assert(rhsCnt > 0 || lp.lower(j) > R(-infinity));
-
-                  if(rhsCnt == 0)
-                     up = lp.lower(j) + z * scale / aij;
-                  else if(lp.lower(j) <= R(-infinity))
-                     up = z * scale / aij;
-
-                  if(isZero(up, this->epsZero()))
-                     up = 0.0;
-
-                  if(LErel(up, lp.upper(j), feastol()))
-                  {
-                     MSG_DEBUG((*this->spxout) << "IMAISM15 row " << i
-                               << ": redundant upper bound on x" << j
-                               << " -> upper=" << up
-                               << " (" << lp.upper(j)
-                               << ")" << std::endl;)
-
-                     redundantUpper = true;
-                  }
-               }
+          }
+
+          if (redundantLower) {
+            // no upper bound on x_j OR redundant upper bound
+            if ((lp.upper(j) >= R(infinity)) || redundantUpper ||
+                (!m_keepbounds)) {
+              ++lhsCnt;
+              lhsBnd -= aij * lp.lower(j);
+
+              lp.changeLower(j, R(-infinity));
+              ++chgBnds;
+            } else
+              ++keptBnds;
+          }
+
+          if (redundantUpper) {
+            // no lower bound on x_j OR redundant lower bound
+            if ((lp.lower(j) <= R(-infinity)) || redundantLower ||
+                (!m_keepbounds)) {
+              ++rhsCnt;
+              rhsBnd -= aij * lp.upper(j);
+
+              lp.changeUpper(j, R(infinity));
+              ++chgBnds;
+            } else
+              ++keptBnds;
+          }
+        } else if (aij < 0.0) {
+          if (lp.lhs(i) > R(-infinity) && lp.upper(j) < R(infinity) &&
+              rhsCnt <= 1 &&
+              NErel(lp.lhs(i), rhsBnd, feastol())
+              // do not perform if strongly different orders of magnitude occur
+              &&
+              spxAbs(lp.lhs(i) / maxAbs(rhsBnd, R(1.0))) > Param::epsilon()) {
+            R up = R(infinity);
+            R scale = maxAbs(lp.lhs(i), rhsBnd);
+
+            if (scale < 1.0)
+              scale = 1.0;
+
+            R z = (lp.lhs(i) / scale) - (rhsBnd / scale);
+
+            if (isZero(z, this->epsZero()))
+              z = 0.0;
+
+            assert(rhsCnt > 0 || lp.lower(j) > R(-infinity));
+
+            if (rhsCnt == 0)
+              up = lp.lower(j) + z * scale / aij;
+            else if (lp.lower(j) <= R(-infinity))
+              up = z * scale / aij;
+
+            if (isZero(up, this->epsZero()))
+              up = 0.0;
+
+            if (LErel(up, lp.upper(j), feastol())) {
+              MSG_DEBUG((*this->spxout) << "IMAISM15 row " << i
+                                        << ": redundant upper bound on x" << j
+                                        << " -> upper=" << up << " ("
+                                        << lp.upper(j) << ")" << std::endl;)
+
+              redundantUpper = true;
+            }
+          }
 
-               if(lp.rhs(i) < R(infinity) && lp.lower(j) > R(-infinity) && lhsCnt <= 1
-                     && NErel(lp.rhs(i), lhsBnd, feastol())
-                     // do not perform if strongly different orders of magnitude occur
-                     && spxAbs(lp.rhs(i) / maxAbs(lhsBnd, R(1.0))) > Param::epsilon())
-               {
-                  R lo    = R(-infinity);
-                  R scale = maxAbs(lp.rhs(i), lhsBnd);
+          if (lp.rhs(i) < R(infinity) && lp.lower(j) > R(-infinity) &&
+              lhsCnt <= 1 &&
+              NErel(lp.rhs(i), lhsBnd, feastol())
+              // do not perform if strongly different orders of magnitude occur
+              &&
+              spxAbs(lp.rhs(i) / maxAbs(lhsBnd, R(1.0))) > Param::epsilon()) {
+            R lo = R(-infinity);
+            R scale = maxAbs(lp.rhs(i), lhsBnd);
 
-                  if(scale < 1.0)
-                     scale = 1.0;
+            if (scale < 1.0)
+              scale = 1.0;
 
-                  R z = (lp.rhs(i) / scale) - (lhsBnd / scale);
+            R z = (lp.rhs(i) / scale) - (lhsBnd / scale);
 
-                  if(isZero(z, this->epsZero()))
-                     z = 0.0;
+            if (isZero(z, this->epsZero()))
+              z = 0.0;
 
-                  assert(lhsCnt > 0 || lp.upper(j) < R(infinity));
+            assert(lhsCnt > 0 || lp.upper(j) < R(infinity));
 
-                  if(lhsCnt == 0)
-                     lo = lp.upper(j) + z * scale / aij;
-                  else if(lp.upper(j) >= R(infinity))
-                     lo = z * scale / aij;
+            if (lhsCnt == 0)
+              lo = lp.upper(j) + z * scale / aij;
+            else if (lp.upper(j) >= R(infinity))
+              lo = z * scale / aij;
 
-                  if(isZero(lo, this->epsZero()))
-                     lo = 0.0;
+            if (isZero(lo, this->epsZero()))
+              lo = 0.0;
 
-                  if(GErel(lo, lp.lower(j)))
-                  {
-                     MSG_DEBUG((*this->spxout) << "IMAISM16 row " << i
-                               << ": redundant lower bound on x" << j
-                               << " -> lower=" << lo
-                               << " (" << lp.lower(j)
-                               << ")" << std::endl;)
+            if (GErel(lo, lp.lower(j))) {
+              MSG_DEBUG((*this->spxout) << "IMAISM16 row " << i
+                                        << ": redundant lower bound on x" << j
+                                        << " -> lower=" << lo << " ("
+                                        << lp.lower(j) << ")" << std::endl;)
 
-                     redundantLower = true;
-                  }
-               }
-
-               if(redundantUpper)
-               {
-                  // no lower bound on x_j OR redundant lower bound
-                  if((lp.lower(j) <= R(-infinity)) || redundantLower || (!m_keepbounds))
-                  {
-                     ++lhsCnt;
-                     lhsBnd -= aij * lp.upper(j);
-
-                     lp.changeUpper(j, R(infinity));
-                     ++chgBnds;
-                  }
-                  else
-                     ++keptBnds;
-               }
-
-               if(redundantLower)
-               {
-                  // no upper bound on x_j OR redundant upper bound
-                  if((lp.upper(j) >= R(infinity)) || redundantUpper || (!m_keepbounds))
-                  {
-                     ++rhsCnt;
-                     rhsBnd -= aij * lp.lower(j);
-
-                     lp.changeLower(j, R(-infinity));
-                     ++chgBnds;
-                  }
-                  else
-                     ++keptBnds;
-               }
+              redundantLower = true;
             }
-         }
-      }
+          }
+
+          if (redundantUpper) {
+            // no lower bound on x_j OR redundant lower bound
+            if ((lp.lower(j) <= R(-infinity)) || redundantLower ||
+                (!m_keepbounds)) {
+              ++lhsCnt;
+              lhsBnd -= aij * lp.upper(j);
+
+              lp.changeUpper(j, R(infinity));
+              ++chgBnds;
+            } else
+              ++keptBnds;
+          }
+
+          if (redundantLower) {
+            // no upper bound on x_j OR redundant upper bound
+            if ((lp.upper(j) >= R(infinity)) || redundantUpper ||
+                (!m_keepbounds)) {
+              ++rhsCnt;
+              rhsBnd -= aij * lp.lower(j);
+
+              lp.changeLower(j, R(-infinity));
+              ++chgBnds;
+            } else
+              ++keptBnds;
+          }
+        }
+      }
+    }
 
 #endif
 
 #if FREE_LHS_RHS
 
-      redundantLhs = false;
-      redundantRhs = false;
-
-      // 2. detect implied free constraints
-      if(lp.lhs(i) > R(-infinity) && lhsCnt == 0 && GErel(lhsBnd, lp.lhs(i), feastol()))
-      {
-         MSG_DEBUG((*this->spxout) << "IMAISM17 row " << i
-                   << ": redundant lhs -> lhsBnd=" << lhsBnd
-                   << " lhs=" << lp.lhs(i)
-                   << std::endl;)
-
-         redundantLhs = true;
-      }
-
-      if(lp.rhs(i) <  R(infinity) && rhsCnt == 0 && LErel(rhsBnd, lp.rhs(i), feastol()))
-      {
-         MSG_DEBUG((*this->spxout) << "IMAISM18 row " << i
-                   << ": redundant rhs -> rhsBnd=" << rhsBnd
-                   << " rhs=" << lp.rhs(i)
-                   << std::endl;)
-
-         redundantRhs = true;
-      }
-
-      if(redundantLhs)
-      {
-         // no rhs for constraint i OR redundant rhs
-         if((lp.rhs(i) >= R(infinity)) || redundantRhs || (!m_keepbounds))
-         {
-            lp.changeLhs(i, R(-infinity));
-            ++chgLRhs;
-         }
-         else
-            ++keptLRhs;
-      }
-
-      if(redundantRhs)
-      {
-         // no lhs for constraint i OR redundant lhs
-         if((lp.lhs(i) <= R(-infinity)) || redundantLhs || (!m_keepbounds))
-         {
-            lp.changeRhs(i, R(infinity));
-            ++chgLRhs;
-         }
-         else
-            ++keptLRhs;
-      }
+    redundantLhs = false;
+    redundantRhs = false;
+
+    // 2. detect implied free constraints
+    if (lp.lhs(i) > R(-infinity) && lhsCnt == 0 &&
+        GErel(lhsBnd, lp.lhs(i), feastol())) {
+      MSG_DEBUG((*this->spxout) << "IMAISM17 row " << i
+                                << ": redundant lhs -> lhsBnd=" << lhsBnd
+                                << " lhs=" << lp.lhs(i) << std::endl;)
+
+      redundantLhs = true;
+    }
+
+    if (lp.rhs(i) < R(infinity) && rhsCnt == 0 &&
+        LErel(rhsBnd, lp.rhs(i), feastol())) {
+      MSG_DEBUG((*this->spxout) << "IMAISM18 row " << i
+                                << ": redundant rhs -> rhsBnd=" << rhsBnd
+                                << " rhs=" << lp.rhs(i) << std::endl;)
+
+      redundantRhs = true;
+    }
+
+    if (redundantLhs) {
+      // no rhs for constraint i OR redundant rhs
+      if ((lp.rhs(i) >= R(infinity)) || redundantRhs || (!m_keepbounds)) {
+        lp.changeLhs(i, R(-infinity));
+        ++chgLRhs;
+      } else
+        ++keptLRhs;
+    }
+
+    if (redundantRhs) {
+      // no lhs for constraint i OR redundant lhs
+      if ((lp.lhs(i) <= R(-infinity)) || redundantLhs || (!m_keepbounds)) {
+        lp.changeRhs(i, R(infinity));
+        ++chgLRhs;
+      } else
+        ++keptLRhs;
+    }
 
 #endif
 
-      // 3. infeasible constraint
-      if(LTrel(lp.rhs(i), lp.lhs(i), feastol())                 ||
-            (LTrel(rhsBnd,   lp.lhs(i), feastol()) && rhsCnt == 0) ||
-            (GTrel(lhsBnd,   lp.rhs(i), feastol()) && lhsCnt == 0))
-      {
-         MSG_DEBUG((*this->spxout) << "IMAISM19 row " << std::setprecision(20) << i
-                   << ": infeasible -> lhs=" << lp.lhs(i)
-                   << " rhs=" << lp.rhs(i)
-                   << " lhsBnd=" << lhsBnd
-                   << " rhsBnd=" << rhsBnd
-                   << std::endl;)
-         return this->INFEASIBLE;
-      }
+    // 3. infeasible constraint
+    if (LTrel(lp.rhs(i), lp.lhs(i), feastol()) ||
+        (LTrel(rhsBnd, lp.lhs(i), feastol()) && rhsCnt == 0) ||
+        (GTrel(lhsBnd, lp.rhs(i), feastol()) && lhsCnt == 0)) {
+      MSG_DEBUG((*this->spxout) << "IMAISM19 row " << std::setprecision(20) << i
+                                << ": infeasible -> lhs=" << lp.lhs(i)
+                                << " rhs=" << lp.rhs(i) << " lhsBnd=" << lhsBnd
+                                << " rhsBnd=" << rhsBnd << std::endl;)
+      return this->INFEASIBLE;
+    }
 
 #if FREE_CONSTRAINT
 
-      // 4. unconstrained constraint
-      if(lp.lhs(i) <= R(-infinity) && lp.rhs(i) >= R(infinity))
-      {
-         MSG_DEBUG((*this->spxout) << "IMAISM20 row " << i
-                   << ": unconstrained -> removed" << std::endl;)
+    // 4. unconstrained constraint
+    if (lp.lhs(i) <= R(-infinity) && lp.rhs(i) >= R(infinity)) {
+      MSG_DEBUG((*this->spxout) << "IMAISM20 row " << i
+                                << ": unconstrained -> removed" << std::endl;)
 
-         std::shared_ptr<PostStep> ptr(new FreeConstraintPS(lp, i));
-         m_hist.append(ptr);
+      std::shared_ptr<PostStep> ptr(new FreeConstraintPS(lp, i));
+      m_hist.append(ptr);
 
-         ++remRows;
-         remNzos += row.size();
-         removeRow(lp, i);
+      ++remRows;
+      remNzos += row.size();
+      removeRow(lp, i);
 
-         ++m_stat[FREE_ROW];
+      ++m_stat[FREE_ROW];
 
-         continue;
-      }
+      continue;
+    }
 
 #endif
 
 #if EMPTY_CONSTRAINT
 
-      // 5. empty constraint
-      if(row.size() == 0)
-      {
-         MSG_DEBUG((*this->spxout) << "IMAISM21 row " << i
-                   << ": empty ->";)
+    // 5. empty constraint
+    if (row.size() == 0) {
+      MSG_DEBUG((*this->spxout) << "IMAISM21 row " << i << ": empty ->";)
 
-         if(LT(lp.rhs(i), R(0.0), feastol()) || GT(lp.lhs(i), R(0.0), feastol()))
-         {
-            MSG_DEBUG((*this->spxout) << " infeasible lhs=" << lp.lhs(i)
-                      << " rhs=" << lp.rhs(i) << std::endl;)
-            return this->INFEASIBLE;
-         }
+      if (LT(lp.rhs(i), R(0.0), feastol()) ||
+          GT(lp.lhs(i), R(0.0), feastol())) {
+        MSG_DEBUG((*this->spxout) << " infeasible lhs=" << lp.lhs(i)
+                                  << " rhs=" << lp.rhs(i) << std::endl;)
+        return this->INFEASIBLE;
+      }
 
-         MSG_DEBUG((*this->spxout) << " removed" << std::endl;)
+      MSG_DEBUG((*this->spxout) << " removed" << std::endl;)
 
-         std::shared_ptr<PostStep> ptr(new EmptyConstraintPS(lp, i));
-         m_hist.append(ptr);
+      std::shared_ptr<PostStep> ptr(new EmptyConstraintPS(lp, i));
+      m_hist.append(ptr);
 
-         ++remRows;
-         removeRow(lp, i);
+      ++remRows;
+      removeRow(lp, i);
 
-         ++m_stat[EMPTY_ROW];
+      ++m_stat[EMPTY_ROW];
 
-         continue;
-      }
+      continue;
+    }
 
 #endif
 
 #if ROW_SINGLETON
 
-      // 6. row singleton
-      if(row.size() == 1)
-      {
-         removeRowSingleton(lp, row, i);
-         continue;
-      }
+    // 6. row singleton
+    if (row.size() == 1) {
+      removeRowSingleton(lp, row, i);
+      continue;
+    }
 
 #endif
 
 #if AGGREGATE_VARS
 
-      // 7. row doubleton, aka. simple aggregation of two variables in an equation
-      if(row.size() == 2 && EQrel(lp.lhs(i), lp.rhs(i), feastol()))
-      {
-         aggregateVars(lp, row, i);
-         continue;
-      }
+    // 7. row doubleton, aka. simple aggregation of two variables in an equation
+    if (row.size() == 2 && EQrel(lp.lhs(i), lp.rhs(i), feastol())) {
+      aggregateVars(lp, row, i);
+      continue;
+    }
 
 #endif
 
 #if FORCE_CONSTRAINT
 
-      // 8. forcing constraint (postsolving)
-      // fix variables to obtain the upper bound on constraint value
-      if(rhsCnt == 0 && EQrel(rhsBnd, lp.lhs(i), feastol()))
-      {
-         MSG_DEBUG((*this->spxout) << "IMAISM24 row " << i
-                   << ": forcing constraint fix on lhs ->"
-                   << " lhs=" << lp.lhs(i)
-                   << " rhsBnd=" << rhsBnd
-                   << std::endl;)
+    // 8. forcing constraint (postsolving)
+    // fix variables to obtain the upper bound on constraint value
+    if (rhsCnt == 0 && EQrel(rhsBnd, lp.lhs(i), feastol())) {
+      MSG_DEBUG((*this->spxout) << "IMAISM24 row " << i
+                                << ": forcing constraint fix on lhs ->"
+                                << " lhs=" << lp.lhs(i) << " rhsBnd=" << rhsBnd
+                                << std::endl;)
 
-         DataArray<bool> fixedCol(row.size());
-         Array<R> lowers(row.size());
-         Array<R> uppers(row.size());
+      DataArray<bool> fixedCol(row.size());
+      Array<R> lowers(row.size());
+      Array<R> uppers(row.size());
 
-         for(int k = 0; k < row.size(); ++k)
-         {
-            R aij = row.value(k);
-            int  j   = row.index(k);
+      for (int k = 0; k < row.size(); ++k) {
+        R aij = row.value(k);
+        int j = row.index(k);
 
-            fixedCol[k] = !(EQrel(lp.upper(j), lp.lower(j), m_epsilon));
+        fixedCol[k] = !(EQrel(lp.upper(j), lp.lower(j), m_epsilon));
 
-            lowers[k] = lp.lower(j);
-            uppers[k] = lp.upper(j);
+        lowers[k] = lp.lower(j);
+        uppers[k] = lp.upper(j);
 
-            ASSERT_WARN("WMAISM25", isNotZero(aij, R(1.0 / R(infinity))));
+        ASSERT_WARN("WMAISM25", isNotZero(aij, R(1.0 / R(infinity))));
 
-            if(aij > 0.0)
-               lp.changeLower(j, lp.upper(j));
-            else
-               lp.changeUpper(j, lp.lower(j));
-         }
+        if (aij > 0.0)
+          lp.changeLower(j, lp.upper(j));
+        else
+          lp.changeUpper(j, lp.lower(j));
+      }
 
-         std::shared_ptr<PostStep> ptr(new ForceConstraintPS(lp, i, true, fixedCol, lowers, uppers));
-         m_hist.append(ptr);
+      std::shared_ptr<PostStep> ptr(
+          new ForceConstraintPS(lp, i, true, fixedCol, lowers, uppers));
+      m_hist.append(ptr);
 
-         ++remRows;
-         remNzos += row.size();
-         removeRow(lp, i);
+      ++remRows;
+      remNzos += row.size();
+      removeRow(lp, i);
 
-         ++m_stat[FORCE_ROW];
+      ++m_stat[FORCE_ROW];
 
-         continue;
-      }
+      continue;
+    }
 
-      // fix variables to obtain the lower bound on constraint value
-      if(lhsCnt == 0 && EQrel(lhsBnd, lp.rhs(i), feastol()))
-      {
-         MSG_DEBUG((*this->spxout) << "IMAISM26 row " << i
-                   << ": forcing constraint fix on rhs ->"
-                   << " rhs=" << lp.rhs(i)
-                   << " lhsBnd=" << lhsBnd
-                   << std::endl;)
+    // fix variables to obtain the lower bound on constraint value
+    if (lhsCnt == 0 && EQrel(lhsBnd, lp.rhs(i), feastol())) {
+      MSG_DEBUG((*this->spxout) << "IMAISM26 row " << i
+                                << ": forcing constraint fix on rhs ->"
+                                << " rhs=" << lp.rhs(i) << " lhsBnd=" << lhsBnd
+                                << std::endl;)
 
-         DataArray<bool> fixedCol(row.size());
-         Array<R> lowers(row.size());
-         Array<R> uppers(row.size());
+      DataArray<bool> fixedCol(row.size());
+      Array<R> lowers(row.size());
+      Array<R> uppers(row.size());
 
-         for(int k = 0; k < row.size(); ++k)
-         {
-            R aij   = row.value(k);
-            int  j     = row.index(k);
+      for (int k = 0; k < row.size(); ++k) {
+        R aij = row.value(k);
+        int j = row.index(k);
 
-            fixedCol[k] = !(EQrel(lp.upper(j), lp.lower(j), m_epsilon));
+        fixedCol[k] = !(EQrel(lp.upper(j), lp.lower(j), m_epsilon));
 
-            lowers[k] = lp.lower(j);
-            uppers[k] = lp.upper(j);
+        lowers[k] = lp.lower(j);
+        uppers[k] = lp.upper(j);
 
-            ASSERT_WARN("WMAISM27", isNotZero(aij, R(1.0 / R(infinity))));
+        ASSERT_WARN("WMAISM27", isNotZero(aij, R(1.0 / R(infinity))));
 
-            if(aij > 0.0)
-               lp.changeUpper(j, lp.lower(j));
-            else
-               lp.changeLower(j, lp.upper(j));
-         }
+        if (aij > 0.0)
+          lp.changeUpper(j, lp.lower(j));
+        else
+          lp.changeLower(j, lp.upper(j));
+      }
 
-         std::shared_ptr<PostStep> ptr(new ForceConstraintPS(lp, i, false, fixedCol, lowers, uppers));
-         m_hist.append(ptr);
+      std::shared_ptr<PostStep> ptr(
+          new ForceConstraintPS(lp, i, false, fixedCol, lowers, uppers));
+      m_hist.append(ptr);
 
-         ++remRows;
-         remNzos += row.size();
-         removeRow(lp, i);
+      ++remRows;
+      remNzos += row.size();
+      removeRow(lp, i);
 
-         ++m_stat[FORCE_ROW];
+      ++m_stat[FORCE_ROW];
 
-         continue;
-      }
+      continue;
+    }
 
 #endif
-   }
-
-   assert(remRows > 0 || remNzos == 0);
-
-   if(remRows + chgLRhs + chgBnds > 0)
-   {
-      this->m_remRows += remRows;
-      this->m_remNzos += remNzos;
-      this->m_chgLRhs += chgLRhs;
-      this->m_chgBnds += chgBnds;
-      this->m_keptBnds += keptBnds;
-      this->m_keptLRhs += keptLRhs;
-
-      MSG_INFO2((*this->spxout), (*this->spxout) << "Simplifier (rows) removed "
-                << remRows << " rows, "
-                << remNzos << " non-zeros, "
-                << chgBnds << " col bounds, "
-                << chgLRhs << " row bounds; kept "
-                << keptBnds << " column bounds, "
-                << keptLRhs << " row bounds"
-                << std::endl;)
-
-      if(remRows > this->m_minReduction * oldRows)
-         again = true;
-   }
-
-   return this->OKAY;
+  }
+
+  assert(remRows > 0 || remNzos == 0);
+
+  if (remRows + chgLRhs + chgBnds > 0) {
+    this->m_remRows += remRows;
+    this->m_remNzos += remNzos;
+    this->m_chgLRhs += chgLRhs;
+    this->m_chgBnds += chgBnds;
+    this->m_keptBnds += keptBnds;
+    this->m_keptLRhs += keptLRhs;
+
+    MSG_INFO2((*this->spxout), (*this->spxout)
+                                   << "Simplifier (rows) removed " << remRows
+                                   << " rows, " << remNzos << " non-zeros, "
+                                   << chgBnds << " col bounds, " << chgLRhs
+                                   << " row bounds; kept " << keptBnds
+                                   << " column bounds, " << keptLRhs
+                                   << " row bounds" << std::endl;)
+
+    if (remRows > this->m_minReduction * oldRows)
+      again = true;
+  }
+
+  return this->OKAY;
 }
 
 template <class R>
-typename SPxSimplifier<R>::Result SPxMainSM<R>::simplifyCols(SPxLPBase<R>& lp, bool& again)
-{
-
-   // This method simplifies the columns of the LP.
-   //
-   // The following operations are done:
-   // 1. detect empty columns and fix corresponding variables
-   // 2. detect variables that are unconstrained from below or above
-   //    and fix corresponding variables or remove involved constraints
-   // 3. fix variables
-   // 4. use column singleton variables with zero objective to adjust constraint bounds
-   // 5. (not free) column singleton combined with doubleton equation are
-   //    used to make the column singleton variable free
-   // 6. substitute (implied) free column singletons
-
-   int remRows = 0;
-   int remCols = 0;
-   int remNzos = 0;
-   int chgBnds = 0;
-
-   int oldCols = lp.nCols();
-   int oldRows = lp.nRows();
-
-   for(int j = lp.nCols() - 1; j >= 0; --j)
-   {
-      const SVectorBase<R>& col = lp.colVector(j);
-
-      // infeasible bounds
-      if(GTrel(lp.lower(j), lp.upper(j), feastol()))
-      {
-         MSG_DEBUG((*this->spxout) << "IMAISM29 col " << j
-                   << ": infeasible bounds on x" << j
-                   << " -> lower=" << lp.lower(j)
-                   << " upper=" << lp.upper(j)
-                   << std::endl;)
-         return this->INFEASIBLE;
-      }
+typename SPxSimplifier<R>::Result SPxMainSM<R>::simplifyCols(SPxLPBase<R> &lp,
+                                                             bool &again) {
+
+  // This method simplifies the columns of the LP.
+  //
+  // The following operations are done:
+  // 1. detect empty columns and fix corresponding variables
+  // 2. detect variables that are unconstrained from below or above
+  //    and fix corresponding variables or remove involved constraints
+  // 3. fix variables
+  // 4. use column singleton variables with zero objective to adjust constraint
+  // bounds
+  // 5. (not free) column singleton combined with doubleton equation are
+  //    used to make the column singleton variable free
+  // 6. substitute (implied) free column singletons
+
+  int remRows = 0;
+  int remCols = 0;
+  int remNzos = 0;
+  int chgBnds = 0;
+
+  int oldCols = lp.nCols();
+  int oldRows = lp.nRows();
+
+  for (int j = lp.nCols() - 1; j >= 0; --j) {
+    const SVectorBase<R> &col = lp.colVector(j);
+
+    // infeasible bounds
+    if (GTrel(lp.lower(j), lp.upper(j), feastol())) {
+      MSG_DEBUG((*this->spxout)
+                    << "IMAISM29 col " << j << ": infeasible bounds on x" << j
+                    << " -> lower=" << lp.lower(j) << " upper=" << lp.upper(j)
+                    << std::endl;)
+      return this->INFEASIBLE;
+    }
 
-      // 1. empty column
-      if(col.size() == 0)
-      {
+    // 1. empty column
+    if (col.size() == 0) {
 #if EMPTY_COLUMN
-         MSG_DEBUG((*this->spxout) << "IMAISM30 col " << j
-                   << ": empty -> maxObj=" << lp.maxObj(j)
-                   << " lower=" << lp.lower(j)
-                   << " upper=" << lp.upper(j);)
-
-         R val;
-
-         if(GT(lp.maxObj(j), R(0.0), this->epsZero()))
-         {
-            if(lp.upper(j) >= R(infinity))
-            {
-               MSG_DEBUG((*this->spxout) << " unbounded" << std::endl;)
-               return this->UNBOUNDED;
-            }
+      MSG_DEBUG((*this->spxout) << "IMAISM30 col " << j << ": empty -> maxObj="
+                                << lp.maxObj(j) << " lower=" << lp.lower(j)
+                                << " upper=" << lp.upper(j);)
 
-            val = lp.upper(j);
-         }
-         else if(LT(lp.maxObj(j), R(0.0), this->epsZero()))
-         {
-            if(lp.lower(j) <= R(-infinity))
-            {
-               MSG_DEBUG((*this->spxout) << " unbounded" << std::endl;)
-               return this->UNBOUNDED;
-            }
+      R val;
 
-            val = lp.lower(j);
-         }
-         else
-         {
-            assert(isZero(lp.maxObj(j), this->epsZero()));
+      if (GT(lp.maxObj(j), R(0.0), this->epsZero())) {
+        if (lp.upper(j) >= R(infinity)) {
+          MSG_DEBUG((*this->spxout) << " unbounded" << std::endl;)
+          return this->UNBOUNDED;
+        }
 
-            // any value within the bounds is ok
-            if(lp.lower(j) > R(-infinity))
-               val = lp.lower(j);
-            else if(lp.upper(j) < R(infinity))
-               val = lp.upper(j);
-            else
-               val = 0.0;
-         }
+        val = lp.upper(j);
+      } else if (LT(lp.maxObj(j), R(0.0), this->epsZero())) {
+        if (lp.lower(j) <= R(-infinity)) {
+          MSG_DEBUG((*this->spxout) << " unbounded" << std::endl;)
+          return this->UNBOUNDED;
+        }
+
+        val = lp.lower(j);
+      } else {
+        assert(isZero(lp.maxObj(j), this->epsZero()));
+
+        // any value within the bounds is ok
+        if (lp.lower(j) > R(-infinity))
+          val = lp.lower(j);
+        else if (lp.upper(j) < R(infinity))
+          val = lp.upper(j);
+        else
+          val = 0.0;
+      }
 
-         MSG_DEBUG((*this->spxout) << " removed" << std::endl;)
+      MSG_DEBUG((*this->spxout) << " removed" << std::endl;)
 
-         std::shared_ptr<PostStep> ptr1(new FixBoundsPS(lp, j, val));
-         std::shared_ptr<PostStep> ptr2(new FixVariablePS(lp, *this, j, val));
-         m_hist.append(ptr1);
-         m_hist.append(ptr2);
+      std::shared_ptr<PostStep> ptr1(new FixBoundsPS(lp, j, val));
+      std::shared_ptr<PostStep> ptr2(new FixVariablePS(lp, *this, j, val));
+      m_hist.append(ptr1);
+      m_hist.append(ptr2);
 
-         ++remCols;
-         removeCol(lp, j);
+      ++remCols;
+      removeCol(lp, j);
 
-         ++m_stat[EMPTY_COL];
+      ++m_stat[EMPTY_COL];
 
-         continue;
+      continue;
 #endif
-      }
+    }
 
-      if(NErel(lp.lower(j), lp.upper(j), feastol()))
-      {
-         // will be set to false if any constraint implies a bound on the variable
-         bool loFree = true;
-         bool upFree = true;
+    if (NErel(lp.lower(j), lp.upper(j), feastol())) {
+      // will be set to false if any constraint implies a bound on the variable
+      bool loFree = true;
+      bool upFree = true;
 
-         // 1. fix and remove variables
-         for(int k = 0; k < col.size(); ++k)
-         {
-            if(!loFree && !upFree)
-               break;
+      // 1. fix and remove variables
+      for (int k = 0; k < col.size(); ++k) {
+        if (!loFree && !upFree)
+          break;
 
-            int i = col.index(k);
+        int i = col.index(k);
 
-            // warn since this unhandled case may slip through unnoticed otherwise
-            ASSERT_WARN("WMAISM31", isNotZero(col.value(k), R(1.0 / R(infinity))));
+        // warn since this unhandled case may slip through unnoticed otherwise
+        ASSERT_WARN("WMAISM31", isNotZero(col.value(k), R(1.0 / R(infinity))));
 
-            if(col.value(k) > 0.0)
-            {
-               if(lp.rhs(i) <  R(infinity))
-                  upFree = false;
+        if (col.value(k) > 0.0) {
+          if (lp.rhs(i) < R(infinity))
+            upFree = false;
 
-               if(lp.lhs(i) > R(-infinity))
-                  loFree = false;
-            }
-            else if(col.value(k) < 0.0)
-            {
-               if(lp.rhs(i) <  R(infinity))
-                  loFree = false;
+          if (lp.lhs(i) > R(-infinity))
+            loFree = false;
+        } else if (col.value(k) < 0.0) {
+          if (lp.rhs(i) < R(infinity))
+            loFree = false;
 
-               if(lp.lhs(i) > R(-infinity))
-                  upFree = false;
-            }
-         }
+          if (lp.lhs(i) > R(-infinity))
+            upFree = false;
+        }
+      }
 
-         // 2. detect variables that are unconstrained from below or above
-         // max  3 x
-         // s.t. 5 x >= 8
-         if(GT(lp.maxObj(j), R(0.0), this->epsZero()) && upFree)
-         {
+      // 2. detect variables that are unconstrained from below or above
+      // max  3 x
+      // s.t. 5 x >= 8
+      if (GT(lp.maxObj(j), R(0.0), this->epsZero()) && upFree) {
 #if FIX_VARIABLE
-            MSG_DEBUG((*this->spxout) << "IMAISM32 col " << j
-                      << ": x" << j
-                      << " unconstrained above ->";)
+        MSG_DEBUG((*this->spxout) << "IMAISM32 col " << j << ": x" << j
+                                  << " unconstrained above ->";)
 
-            if(lp.upper(j) >= R(infinity))
-            {
-               MSG_DEBUG((*this->spxout) << " unbounded" << std::endl;)
+        if (lp.upper(j) >= R(infinity)) {
+          MSG_DEBUG((*this->spxout) << " unbounded" << std::endl;)
 
-               return this->UNBOUNDED;
-            }
+          return this->UNBOUNDED;
+        }
 
-            MSG_DEBUG((*this->spxout) << " fixed at upper=" << lp.upper(j) << std::endl;)
-
-            std::shared_ptr<PostStep> ptr(new FixBoundsPS(lp, j, lp.upper(j)));
-            m_hist.append(ptr);
-            lp.changeLower(j, lp.upper(j));
-         }
-         // max -3 x
-         // s.t. 5 x <= 8
-         else if(LT(lp.maxObj(j), R(0.0), this->epsZero()) && loFree)
-         {
-            MSG_DEBUG((*this->spxout) << "IMAISM33 col " << j
-                      << ": x" << j
-                      << " unconstrained below ->";)
-
-            if(lp.lower(j) <= R(-infinity))
-            {
-               MSG_DEBUG((*this->spxout) << " unbounded" << std::endl;)
-
-               return this->UNBOUNDED;
-            }
+        MSG_DEBUG((*this->spxout)
+                      << " fixed at upper=" << lp.upper(j) << std::endl;)
+
+        std::shared_ptr<PostStep> ptr(new FixBoundsPS(lp, j, lp.upper(j)));
+        m_hist.append(ptr);
+        lp.changeLower(j, lp.upper(j));
+      }
+      // max -3 x
+      // s.t. 5 x <= 8
+      else if (LT(lp.maxObj(j), R(0.0), this->epsZero()) && loFree) {
+        MSG_DEBUG((*this->spxout) << "IMAISM33 col " << j << ": x" << j
+                                  << " unconstrained below ->";)
 
-            MSG_DEBUG((*this->spxout) << " fixed at lower=" << lp.lower(j) << std::endl;)
+        if (lp.lower(j) <= R(-infinity)) {
+          MSG_DEBUG((*this->spxout) << " unbounded" << std::endl;)
 
-            std::shared_ptr<PostStep> ptr(new FixBoundsPS(lp, j, lp.lower(j)));
-            m_hist.append(ptr);
-            lp.changeUpper(j, lp.lower(j));
+          return this->UNBOUNDED;
+        }
+
+        MSG_DEBUG((*this->spxout)
+                      << " fixed at lower=" << lp.lower(j) << std::endl;)
+
+        std::shared_ptr<PostStep> ptr(new FixBoundsPS(lp, j, lp.lower(j)));
+        m_hist.append(ptr);
+        lp.changeUpper(j, lp.lower(j));
 #endif
-         }
-         else if(isZero(lp.maxObj(j), this->epsZero()))
-         {
+      } else if (isZero(lp.maxObj(j), this->epsZero())) {
 #if FREE_ZERO_OBJ_VARIABLE
-            bool unconstrained_below = loFree && lp.lower(j) <= R(-infinity);
-            bool unconstrained_above = upFree && lp.upper(j) >= R(infinity);
+        bool unconstrained_below = loFree && lp.lower(j) <= R(-infinity);
+        bool unconstrained_above = upFree && lp.upper(j) >= R(infinity);
 
-            if(unconstrained_below || unconstrained_above)
-            {
-               MSG_DEBUG((*this->spxout) << "IMAISM34 col " << j
-                         << ": x" << j
-                         << " unconstrained "
-                         << (unconstrained_below ? "below" : "above")
-                         << " with zero objective (" << lp.maxObj(j)
-                         << ")" << std::endl;)
+        if (unconstrained_below || unconstrained_above) {
+          MSG_DEBUG((*this->spxout) << "IMAISM34 col " << j << ": x" << j
+                                    << " unconstrained "
+                                    << (unconstrained_below ? "below" : "above")
+                                    << " with zero objective (" << lp.maxObj(j)
+                                    << ")" << std::endl;)
 
-               DSVectorBase<R> col_idx_sorted(col);
+          DSVectorBase<R> col_idx_sorted(col);
 
-               // sort col elements by increasing idx
-               IdxCompare compare;
-               SPxQuicksort(col_idx_sorted.mem(), col_idx_sorted.size(), compare);
+          // sort col elements by increasing idx
+          IdxCompare compare;
+          SPxQuicksort(col_idx_sorted.mem(), col_idx_sorted.size(), compare);
 
-               std::shared_ptr<PostStep> ptr(new FreeZeroObjVariablePS(lp, j, unconstrained_below,
-                                             col_idx_sorted));
-               m_hist.append(ptr);
+          std::shared_ptr<PostStep> ptr(new FreeZeroObjVariablePS(
+              lp, j, unconstrained_below, col_idx_sorted));
+          m_hist.append(ptr);
 
-               // we have to remove the rows with larger idx first, because otherwise the rows are reorder and indices
-               // are out-of-date
-               remRows += col.size();
+          // we have to remove the rows with larger idx first, because otherwise
+          // the rows are reorder and indices are out-of-date
+          remRows += col.size();
 
-               for(int k = col_idx_sorted.size() - 1; k >= 0; --k)
-                  removeRow(lp, col_idx_sorted.index(k));
+          for (int k = col_idx_sorted.size() - 1; k >= 0; --k)
+            removeRow(lp, col_idx_sorted.index(k));
 
-               // remove column
-               removeCol(lp, j);
+          // remove column
+          removeCol(lp, j);
 
-               // statistics
-               for(int k = 0; k < col.size(); ++k)
-               {
-                  int l   =  col.index(k);
-                  remNzos += lp.rowVector(l).size();
-               }
+          // statistics
+          for (int k = 0; k < col.size(); ++k) {
+            int l = col.index(k);
+            remNzos += lp.rowVector(l).size();
+          }
 
-               ++m_stat[FREE_ZOBJ_COL];
-               ++remCols;
+          ++m_stat[FREE_ZOBJ_COL];
+          ++remCols;
 
-               continue;
-            }
+          continue;
+        }
 
 #endif
-         }
       }
+    }
 
 #if FIX_VARIABLE
 
-      // 3. fix variable
-      if(EQrel(lp.lower(j), lp.upper(j), feastol()))
-      {
-         MSG_DEBUG((*this->spxout) << "IMAISM36 col " << j
-                   << ": x" << j
-                   << " fixed -> lower=" << lp.lower(j)
-                   << " upper=" << lp.upper(j) << std::endl;)
+    // 3. fix variable
+    if (EQrel(lp.lower(j), lp.upper(j), feastol())) {
+      MSG_DEBUG((*this->spxout) << "IMAISM36 col " << j << ": x" << j
+                                << " fixed -> lower=" << lp.lower(j)
+                                << " upper=" << lp.upper(j) << std::endl;)
 
-         fixColumn(lp, j);
+      fixColumn(lp, j);
 
-         ++remCols;
-         remNzos += col.size();
-         removeCol(lp, j);
+      ++remCols;
+      remNzos += col.size();
+      removeCol(lp, j);
 
-         ++m_stat[FIX_COL];
+      ++m_stat[FIX_COL];
 
-         continue;
-      }
+      continue;
+    }
 
 #endif
 
-      // handle column singletons
-      if(col.size() == 1)
-      {
-         R aij = col.value(0);
-         int  i   = col.index(0);
+    // handle column singletons
+    if (col.size() == 1) {
+      R aij = col.value(0);
+      int i = col.index(0);
 
-         // 4. column singleton with zero objective
-         if(isZero(lp.maxObj(j), this->epsZero()))
-         {
+      // 4. column singleton with zero objective
+      if (isZero(lp.maxObj(j), this->epsZero())) {
 #if ZERO_OBJ_COL_SINGLETON
-            MSG_DEBUG((*this->spxout) << "IMAISM37 col " << j
-                      << ": singleton in row " << i
+        MSG_DEBUG((*this->spxout)
+                      << "IMAISM37 col " << j << ": singleton in row " << i
                       << " with zero objective";)
 
-            R lhs = R(-infinity);
-            R rhs = +R(infinity);
+        R lhs = R(-infinity);
+        R rhs = +R(infinity);
 
-            if(GT(aij, R(0.0), this->epsZero()))
-            {
-               if(lp.lhs(i) > R(-infinity) && lp.upper(j) <  R(infinity))
-                  lhs = lp.lhs(i) - aij * lp.upper(j);
+        if (GT(aij, R(0.0), this->epsZero())) {
+          if (lp.lhs(i) > R(-infinity) && lp.upper(j) < R(infinity))
+            lhs = lp.lhs(i) - aij * lp.upper(j);
 
-               if(lp.rhs(i) <  R(infinity) && lp.lower(j) > R(-infinity))
-                  rhs = lp.rhs(i) - aij * lp.lower(j);
-            }
-            else if(LT(aij, R(0.0), this->epsZero()))
-            {
-               if(lp.lhs(i) > R(-infinity) && lp.lower(j) > R(-infinity))
-                  lhs = lp.lhs(i) - aij * lp.lower(j);
+          if (lp.rhs(i) < R(infinity) && lp.lower(j) > R(-infinity))
+            rhs = lp.rhs(i) - aij * lp.lower(j);
+        } else if (LT(aij, R(0.0), this->epsZero())) {
+          if (lp.lhs(i) > R(-infinity) && lp.lower(j) > R(-infinity))
+            lhs = lp.lhs(i) - aij * lp.lower(j);
 
-               if(lp.rhs(i) <  R(infinity) && lp.upper(j) <  R(infinity))
-                  rhs = lp.rhs(i) - aij * lp.upper(j);
-            }
-            else
-            {
-               lhs = lp.lhs(i);
-               rhs = lp.rhs(i);
-            }
+          if (lp.rhs(i) < R(infinity) && lp.upper(j) < R(infinity))
+            rhs = lp.rhs(i) - aij * lp.upper(j);
+        } else {
+          lhs = lp.lhs(i);
+          rhs = lp.rhs(i);
+        }
 
-            if(isZero(lhs, this->epsZero()))
-               lhs = 0.0;
+        if (isZero(lhs, this->epsZero()))
+          lhs = 0.0;
 
-            if(isZero(rhs, this->epsZero()))
-               rhs = 0.0;
+        if (isZero(rhs, this->epsZero()))
+          rhs = 0.0;
 
-            MSG_DEBUG((*this->spxout) << " removed -> lhs=" << lhs
-                      << " (" << lp.lhs(i)
-                      << ") rhs=" << rhs
-                      << " (" << lp.rhs(i)
-                      << ")" << std::endl;)
+        MSG_DEBUG((*this->spxout) << " removed -> lhs=" << lhs << " ("
+                                  << lp.lhs(i) << ") rhs=" << rhs << " ("
+                                  << lp.rhs(i) << ")" << std::endl;)
 
-            std::shared_ptr<PostStep> ptr(new ZeroObjColSingletonPS(lp, *this, j, i));
-            m_hist.append(ptr);
+        std::shared_ptr<PostStep> ptr(
+            new ZeroObjColSingletonPS(lp, *this, j, i));
+        m_hist.append(ptr);
 
-            lp.changeRange(i, lhs, rhs);
+        lp.changeRange(i, lhs, rhs);
 
-            ++remCols;
-            ++remNzos;
-            removeCol(lp, j);
+        ++remCols;
+        ++remNzos;
+        removeCol(lp, j);
 
-            ++m_stat[ZOBJ_SINGLETON_COL];
+        ++m_stat[ZOBJ_SINGLETON_COL];
 
-            if(lp.lhs(i) <= R(-infinity) && lp.rhs(i) >= R(infinity))
-            {
-               std::shared_ptr<PostStep> ptr2(new FreeConstraintPS(lp, i));
-               m_hist.append(ptr2);
+        if (lp.lhs(i) <= R(-infinity) && lp.rhs(i) >= R(infinity)) {
+          std::shared_ptr<PostStep> ptr2(new FreeConstraintPS(lp, i));
+          m_hist.append(ptr2);
 
-               ++remRows;
-               removeRow(lp, i);
+          ++remRows;
+          removeRow(lp, i);
 
-               ++m_stat[FREE_ROW];
-            }
+          ++m_stat[FREE_ROW];
+        }
 
-            continue;
+        continue;
 #endif
-         }
+      }
 
-         // 5. not free column singleton combined with doubleton equation
-         else if(EQrel(lp.lhs(i), lp.rhs(i), feastol())             &&
-                 lp.rowVector(i).size() == 2                         &&
-                 (lp.lower(j) > R(-infinity) || lp.upper(j) < R(infinity)))
-         {
+      // 5. not free column singleton combined with doubleton equation
+      else if (EQrel(lp.lhs(i), lp.rhs(i), feastol()) &&
+               lp.rowVector(i).size() == 2 &&
+               (lp.lower(j) > R(-infinity) || lp.upper(j) < R(infinity))) {
 #if DOUBLETON_EQUATION
-            MSG_DEBUG((*this->spxout) << "IMAISM38 col " << j
-                      << ": singleton in row " << i
+        MSG_DEBUG((*this->spxout)
+                      << "IMAISM38 col " << j << ": singleton in row " << i
                       << " with doubleton equation ->";)
 
-            R lhs = lp.lhs(i);
+        R lhs = lp.lhs(i);
 
-            const SVectorBase<R>& row = lp.rowVector(i);
+        const SVectorBase<R> &row = lp.rowVector(i);
 
-            R aik;
-            int  k;
+        R aik;
+        int k;
 
-            if(row.index(0) == j)
-            {
-               aik = row.value(1);
-               k   = row.index(1);
-            }
-            else if(row.index(1) == j)
-            {
-               aik = row.value(0);
-               k   = row.index(0);
-            }
-            else
-               throw SPxInternalCodeException("XMAISM11 This should never happen.");
+        if (row.index(0) == j) {
+          aik = row.value(1);
+          k = row.index(1);
+        } else if (row.index(1) == j) {
+          aik = row.value(0);
+          k = row.index(0);
+        } else
+          throw SPxInternalCodeException("XMAISM11 This should never happen.");
 
-            ASSERT_WARN("WMAISM39", isNotZero(aik, R(1.0 / R(infinity))));
+        ASSERT_WARN("WMAISM39", isNotZero(aik, R(1.0 / R(infinity))));
 
-            R lo, up;
-            R oldLower = lp.lower(k);
-            R oldUpper = lp.upper(k);
+        R lo, up;
+        R oldLower = lp.lower(k);
+        R oldUpper = lp.upper(k);
 
-            R scale1 = maxAbs(lhs, aij * lp.upper(j));
-            R scale2 = maxAbs(lhs, aij * lp.lower(j));
+        R scale1 = maxAbs(lhs, aij * lp.upper(j));
+        R scale2 = maxAbs(lhs, aij * lp.lower(j));
 
-            if(scale1 < 1.0)
-               scale1 = 1.0;
+        if (scale1 < 1.0)
+          scale1 = 1.0;
 
-            if(scale2 < 1.0)
-               scale2 = 1.0;
+        if (scale2 < 1.0)
+          scale2 = 1.0;
 
-            R z1 = (lhs / scale1) - (aij * lp.upper(j) / scale1);
-            R z2 = (lhs / scale2) - (aij * lp.lower(j) / scale2);
+        R z1 = (lhs / scale1) - (aij * lp.upper(j) / scale1);
+        R z2 = (lhs / scale2) - (aij * lp.lower(j) / scale2);
 
-            if(isZero(z1, this->epsZero()))
-               z1 = 0.0;
+        if (isZero(z1, this->epsZero()))
+          z1 = 0.0;
 
-            if(isZero(z2, this->epsZero()))
-               z2 = 0.0;
+        if (isZero(z2, this->epsZero()))
+          z2 = 0.0;
 
-            if(aij * aik > 0.0)
-            {
-               lo = (lp.upper(j) >=  R(infinity)) ? R(-infinity) : z1 * scale1 / aik;
-               up = (lp.lower(j) <= R(-infinity)) ?  R(infinity) : z2 * scale2 / aik;
-            }
-            else if(aij * aik < 0.0)
-            {
-               lo = (lp.lower(j) <= R(-infinity)) ? R(-infinity) : z2 * scale2 / aik;
-               up = (lp.upper(j) >=  R(infinity)) ?  R(infinity) : z1 * scale1 / aik;
-            }
-            else
-               throw SPxInternalCodeException("XMAISM12 This should never happen.");
-
-            if(GTrel(lo, lp.lower(k), this->epsZero()))
-               lp.changeLower(k, lo);
-
-            if(LTrel(up, lp.upper(k), this->epsZero()))
-               lp.changeUpper(k, up);
-
-            MSG_DEBUG((*this->spxout) << " made free, bounds on x" << k
-                      << ": lower=" << lp.lower(k)
-                      << " (" << oldLower
-                      << ") upper=" << lp.upper(k)
-                      << " (" << oldUpper
-                      << ")" << std::endl;)
-
-            // infeasible bounds
-            if(GTrel(lp.lower(k), lp.upper(k), feastol()))
-            {
-               MSG_DEBUG((*this->spxout) << "new bounds are infeasible"
-                         << std::endl;)
-               return this->INFEASIBLE;
-            }
+        if (aij * aik > 0.0) {
+          lo = (lp.upper(j) >= R(infinity)) ? R(-infinity) : z1 * scale1 / aik;
+          up = (lp.lower(j) <= R(-infinity)) ? R(infinity) : z2 * scale2 / aik;
+        } else if (aij * aik < 0.0) {
+          lo = (lp.lower(j) <= R(-infinity)) ? R(-infinity) : z2 * scale2 / aik;
+          up = (lp.upper(j) >= R(infinity)) ? R(infinity) : z1 * scale1 / aik;
+        } else
+          throw SPxInternalCodeException("XMAISM12 This should never happen.");
 
-            std::shared_ptr<PostStep> ptr(new DoubletonEquationPS(lp, j, k, i, oldLower, oldUpper));
-            m_hist.append(ptr);
+        if (GTrel(lo, lp.lower(k), this->epsZero()))
+          lp.changeLower(k, lo);
 
-            if(lp.lower(j) > R(-infinity) && lp.upper(j) < R(infinity))
-               chgBnds += 2;
-            else
-               ++chgBnds;
+        if (LTrel(up, lp.upper(k), this->epsZero()))
+          lp.changeUpper(k, up);
+
+        MSG_DEBUG((*this->spxout) << " made free, bounds on x" << k
+                                  << ": lower=" << lp.lower(k) << " ("
+                                  << oldLower << ") upper=" << lp.upper(k)
+                                  << " (" << oldUpper << ")" << std::endl;)
 
-            lp.changeBounds(j, R(-infinity), R(infinity));
+        // infeasible bounds
+        if (GTrel(lp.lower(k), lp.upper(k), feastol())) {
+          MSG_DEBUG((*this->spxout)
+                        << "new bounds are infeasible" << std::endl;)
+          return this->INFEASIBLE;
+        }
 
-            ++m_stat[DOUBLETON_ROW];
+        std::shared_ptr<PostStep> ptr(
+            new DoubletonEquationPS(lp, j, k, i, oldLower, oldUpper));
+        m_hist.append(ptr);
+
+        if (lp.lower(j) > R(-infinity) && lp.upper(j) < R(infinity))
+          chgBnds += 2;
+        else
+          ++chgBnds;
+
+        lp.changeBounds(j, R(-infinity), R(infinity));
+
+        ++m_stat[DOUBLETON_ROW];
 #endif
-         }
+      }
 
-         // 6. (implied) free column singleton
-         if(lp.lower(j) <= R(-infinity) && lp.upper(j) >= R(infinity))
-         {
+      // 6. (implied) free column singleton
+      if (lp.lower(j) <= R(-infinity) && lp.upper(j) >= R(infinity)) {
 #if FREE_COL_SINGLETON
-            R slackVal = lp.lhs(i);
-
-            // constraint i is an inequality constraint -> transform into equation type
-            if(NErel(lp.lhs(i), lp.rhs(i), feastol()))
-            {
-               MSG_DEBUG((*this->spxout) << "IMAISM40 col " << j
-                         << ": free singleton in inequality constraint" << std::endl;)
-
-               // do nothing if constraint i is unconstrained
-               if(lp.lhs(i) <= R(-infinity) && lp.rhs(i) >= R(infinity))
-                  continue;
-
-               // introduce slack variable to obtain equality constraint
-               R sMaxObj = lp.maxObj(j) / aij; // after substituting variable j in objective
-               R sLo     = lp.lhs(i);
-               R sUp     = lp.rhs(i);
-
-               if(GT(sMaxObj, R(0.0), this->epsZero()))
-               {
-                  if(sUp >= R(infinity))
-                  {
-                     MSG_DEBUG((*this->spxout) << " -> problem unbounded" << std::endl;)
-                     return this->UNBOUNDED;
-                  }
+        R slackVal = lp.lhs(i);
+
+        // constraint i is an inequality constraint -> transform into equation
+        // type
+        if (NErel(lp.lhs(i), lp.rhs(i), feastol())) {
+          MSG_DEBUG((*this->spxout)
+                        << "IMAISM40 col " << j
+                        << ": free singleton in inequality constraint"
+                        << std::endl;)
+
+          // do nothing if constraint i is unconstrained
+          if (lp.lhs(i) <= R(-infinity) && lp.rhs(i) >= R(infinity))
+            continue;
 
-                  slackVal = sUp;
-               }
-               else if(LT(sMaxObj, R(0.0), this->epsZero()))
-               {
-                  if(sLo <= R(-infinity))
-                  {
-                     MSG_DEBUG((*this->spxout) << " -> problem unbounded" << std::endl;)
-                     return this->UNBOUNDED;
-                  }
+          // introduce slack variable to obtain equality constraint
+          R sMaxObj =
+              lp.maxObj(j) / aij; // after substituting variable j in objective
+          R sLo = lp.lhs(i);
+          R sUp = lp.rhs(i);
+
+          if (GT(sMaxObj, R(0.0), this->epsZero())) {
+            if (sUp >= R(infinity)) {
+              MSG_DEBUG((*this->spxout)
+                            << " -> problem unbounded" << std::endl;)
+              return this->UNBOUNDED;
+            }
 
-                  slackVal = sLo;
-               }
-               else
-               {
-                  assert(isZero(sMaxObj, this->epsZero()));
-
-                  // any value within the bounds is ok
-                  if(sLo > R(-infinity))
-                     slackVal = sLo;
-                  else if(sUp < R(infinity))
-                     slackVal = sUp;
-                  else
-                     throw SPxInternalCodeException("XMAISM13 This should never happen.");
-               }
+            slackVal = sUp;
+          } else if (LT(sMaxObj, R(0.0), this->epsZero())) {
+            if (sLo <= R(-infinity)) {
+              MSG_DEBUG((*this->spxout)
+                            << " -> problem unbounded" << std::endl;)
+              return this->UNBOUNDED;
             }
 
-            std::shared_ptr<PostStep> ptr(new FreeColSingletonPS(lp, *this, j, i, slackVal));
-            m_hist.append(ptr);
+            slackVal = sLo;
+          } else {
+            assert(isZero(sMaxObj, this->epsZero()));
 
-            MSG_DEBUG((*this->spxout) << "IMAISM41 col " << j
-                      << ": free singleton removed" << std::endl;)
+            // any value within the bounds is ok
+            if (sLo > R(-infinity))
+              slackVal = sLo;
+            else if (sUp < R(infinity))
+              slackVal = sUp;
+            else
+              throw SPxInternalCodeException(
+                  "XMAISM13 This should never happen.");
+          }
+        }
 
-            const SVectorBase<R>& row = lp.rowVector(i);
+        std::shared_ptr<PostStep> ptr(
+            new FreeColSingletonPS(lp, *this, j, i, slackVal));
+        m_hist.append(ptr);
 
-            for(int h = 0; h < row.size(); ++h)
-            {
-               int k = row.index(h);
+        MSG_DEBUG((*this->spxout) << "IMAISM41 col " << j
+                                  << ": free singleton removed" << std::endl;)
 
-               if(k != j)
-               {
-                  R new_obj = lp.obj(k) - (lp.obj(j) * row.value(h) / aij);
-                  lp.changeObj(k, new_obj);
-               }
-            }
+        const SVectorBase<R> &row = lp.rowVector(i);
 
-            ++remRows;
-            ++remCols;
-            remNzos += row.size();
-            removeRow(lp, i);
-            removeCol(lp, j);
+        for (int h = 0; h < row.size(); ++h) {
+          int k = row.index(h);
 
-            ++m_stat[FREE_SINGLETON_COL];
+          if (k != j) {
+            R new_obj = lp.obj(k) - (lp.obj(j) * row.value(h) / aij);
+            lp.changeObj(k, new_obj);
+          }
+        }
 
-            continue;
+        ++remRows;
+        ++remCols;
+        remNzos += row.size();
+        removeRow(lp, i);
+        removeCol(lp, j);
+
+        ++m_stat[FREE_SINGLETON_COL];
+
+        continue;
 #endif
-         }
       }
-   }
-
-   if(remCols + remRows > 0)
-   {
-      this->m_remRows += remRows;
-      this->m_remCols += remCols;
-      this->m_remNzos += remNzos;
-      this->m_chgBnds += chgBnds;
-
-      MSG_INFO2((*this->spxout), (*this->spxout) << "Simplifier (columns) removed "
-                << remRows << " rows, "
-                << remCols << " cols, "
-                << remNzos << " non-zeros, "
-                << chgBnds << " col bounds"
-                << std::endl;)
-
-      if(remCols + remRows > this->m_minReduction * (oldCols + oldRows))
-         again = true;
-   }
-
-   return this->OKAY;
+    }
+  }
+
+  if (remCols + remRows > 0) {
+    this->m_remRows += remRows;
+    this->m_remCols += remCols;
+    this->m_remNzos += remNzos;
+    this->m_chgBnds += chgBnds;
+
+    MSG_INFO2((*this->spxout), (*this->spxout)
+                                   << "Simplifier (columns) removed " << remRows
+                                   << " rows, " << remCols << " cols, "
+                                   << remNzos << " non-zeros, " << chgBnds
+                                   << " col bounds" << std::endl;)
+
+    if (remCols + remRows > this->m_minReduction * (oldCols + oldRows))
+      again = true;
+  }
+
+  return this->OKAY;
 }
 
 template <class R>
-typename SPxSimplifier<R>::Result SPxMainSM<R>::simplifyDual(SPxLPBase<R>& lp, bool& again)
-{
-
-   // This method simplifies LP using the following dual structures:
-   //
-   // 1. dominated columns
-   // 2. weakly dominated columns
-   //
-   // For constructing the dual variables, it is assumed that the objective sense is max
-
-   int remRows = 0;
-   int remCols = 0;
-   int remNzos = 0;
-
-   int oldRows = lp.nRows();
-   int oldCols = lp.nCols();
-
-   DataArray<bool> colSingleton(lp.nCols());
-   VectorBase<R>         dualVarLo(lp.nRows());
-   VectorBase<R>         dualVarUp(lp.nRows());
-   VectorBase<R>         dualConsLo(lp.nCols());
-   VectorBase<R>         dualConsUp(lp.nCols());
-
-   // init
-   for(int i = lp.nRows() - 1; i >= 0; --i)
-   {
-      // check for unconstrained constraints
-      if(lp.lhs(i) <= R(-infinity) && lp.rhs(i) >= R(infinity))
-      {
-         MSG_DEBUG((*this->spxout) << "IMAISM43 row " << i
-                   << ": unconstrained" << std::endl;)
-
-         std::shared_ptr<PostStep> ptr(new FreeConstraintPS(lp, i));
-         m_hist.append(ptr);
-
-         ++remRows;
-         remNzos += lp.rowVector(i).size();
-         removeRow(lp, i);
-
-         ++m_stat[FREE_ROW];
-
-         continue;
-      }
+typename SPxSimplifier<R>::Result SPxMainSM<R>::simplifyDual(SPxLPBase<R> &lp,
+                                                             bool &again) {
+
+  // This method simplifies LP using the following dual structures:
+  //
+  // 1. dominated columns
+  // 2. weakly dominated columns
+  //
+  // For constructing the dual variables, it is assumed that the objective sense
+  // is max
+
+  int remRows = 0;
+  int remCols = 0;
+  int remNzos = 0;
+
+  int oldRows = lp.nRows();
+  int oldCols = lp.nCols();
+
+  DataArray<bool> colSingleton(lp.nCols());
+  VectorBase<R> dualVarLo(lp.nRows());
+  VectorBase<R> dualVarUp(lp.nRows());
+  VectorBase<R> dualConsLo(lp.nCols());
+  VectorBase<R> dualConsUp(lp.nCols());
+
+  // init
+  for (int i = lp.nRows() - 1; i >= 0; --i) {
+    // check for unconstrained constraints
+    if (lp.lhs(i) <= R(-infinity) && lp.rhs(i) >= R(infinity)) {
+      MSG_DEBUG((*this->spxout)
+                    << "IMAISM43 row " << i << ": unconstrained" << std::endl;)
+
+      std::shared_ptr<PostStep> ptr(new FreeConstraintPS(lp, i));
+      m_hist.append(ptr);
 
-      // corresponds to maximization sense
-      dualVarLo[i] = (lp.lhs(i) <= R(-infinity)) ? 0.0 : R(-infinity);
-      dualVarUp[i] = (lp.rhs(i) >=  R(infinity)) ? 0.0 :  R(infinity);
-   }
-
-   // compute bounds on the dual variables using column singletons
-   for(int j = 0; j < lp.nCols(); ++j)
-   {
-      if(lp.colVector(j).size() == 1)
-      {
-         int  i   = lp.colVector(j).index(0);
-         R aij = lp.colVector(j).value(0);
-
-         ASSERT_WARN("WMAISM44", isNotZero(aij, R(1.0 / R(infinity))));
-
-         R bound = lp.maxObj(j) / aij;
-
-         if(aij > 0)
-         {
-            if(lp.lower(j) <= R(-infinity) && bound < dualVarUp[i])
-               dualVarUp[i] = bound;
-
-            if(lp.upper(j) >=  R(infinity) && bound > dualVarLo[i])
-               dualVarLo[i] = bound;
-         }
-         else if(aij < 0)
-         {
-            if(lp.lower(j) <= R(-infinity) && bound > dualVarLo[i])
-               dualVarLo[i] = bound;
-
-            if(lp.upper(j) >=  R(infinity) && bound < dualVarUp[i])
-               dualVarUp[i] = bound;
-         }
-      }
+      ++remRows;
+      remNzos += lp.rowVector(i).size();
+      removeRow(lp, i);
 
-   }
+      ++m_stat[FREE_ROW];
 
-   // compute bounds on the dual constraints
-   for(int j = 0; j < lp.nCols(); ++j)
-   {
-      dualConsLo[j] = dualConsUp[j] = 0.0;
+      continue;
+    }
 
-      const SVectorBase<R>& col = lp.colVector(j);
+    // corresponds to maximization sense
+    dualVarLo[i] = (lp.lhs(i) <= R(-infinity)) ? 0.0 : R(-infinity);
+    dualVarUp[i] = (lp.rhs(i) >= R(infinity)) ? 0.0 : R(infinity);
+  }
 
-      for(int k = 0; k < col.size(); ++k)
-      {
-         if(dualConsLo[j] <= R(-infinity) && dualConsUp[j] >= R(infinity))
-            break;
+  // compute bounds on the dual variables using column singletons
+  for (int j = 0; j < lp.nCols(); ++j) {
+    if (lp.colVector(j).size() == 1) {
+      int i = lp.colVector(j).index(0);
+      R aij = lp.colVector(j).value(0);
 
-         R aij = col.value(k);
-         int  i   = col.index(k);
+      ASSERT_WARN("WMAISM44", isNotZero(aij, R(1.0 / R(infinity))));
 
-         ASSERT_WARN("WMAISM45", isNotZero(aij, R(1.0 / R(infinity))));
+      R bound = lp.maxObj(j) / aij;
 
-         if(aij > 0)
-         {
-            if(dualVarLo[i] <= R(-infinity))
-               dualConsLo[j] = R(-infinity);
-            else
-               dualConsLo[j] += aij * dualVarLo[i];
+      if (aij > 0) {
+        if (lp.lower(j) <= R(-infinity) && bound < dualVarUp[i])
+          dualVarUp[i] = bound;
 
-            if(dualVarUp[i] >= R(infinity))
-               dualConsUp[j] = R(infinity);
-            else
-               dualConsUp[j] += aij * dualVarUp[i];
-         }
-         else if(aij < 0)
-         {
-            if(dualVarLo[i] <= R(-infinity))
-               dualConsUp[j] = R(infinity);
-            else
-               dualConsUp[j] += aij * dualVarLo[i];
+        if (lp.upper(j) >= R(infinity) && bound > dualVarLo[i])
+          dualVarLo[i] = bound;
+      } else if (aij < 0) {
+        if (lp.lower(j) <= R(-infinity) && bound > dualVarLo[i])
+          dualVarLo[i] = bound;
 
-            if(dualVarUp[i] >= R(infinity))
-               dualConsLo[j] = R(-infinity);
-            else
-               dualConsLo[j] += aij * dualVarUp[i];
-         }
+        if (lp.upper(j) >= R(infinity) && bound < dualVarUp[i])
+          dualVarUp[i] = bound;
       }
-   }
-
-   for(int j = lp.nCols() - 1; j >= 0; --j)
-   {
-      if(lp.colVector(j).size() <= 1)
-         continue;
-
-      // dual infeasibility checks
-      if(LTrel(dualConsUp[j], dualConsLo[j], opttol()))
-      {
-         MSG_DEBUG((*this->spxout) << "IMAISM46 col " << j
-                   << ": dual infeasible -> dual lhs bound=" << dualConsLo[j]
-                   << " dual rhs bound=" << dualConsUp[j] << std::endl;)
-         return this->DUAL_INFEASIBLE;
+    }
+  }
+
+  // compute bounds on the dual constraints
+  for (int j = 0; j < lp.nCols(); ++j) {
+    dualConsLo[j] = dualConsUp[j] = 0.0;
+
+    const SVectorBase<R> &col = lp.colVector(j);
+
+    for (int k = 0; k < col.size(); ++k) {
+      if (dualConsLo[j] <= R(-infinity) && dualConsUp[j] >= R(infinity))
+        break;
+
+      R aij = col.value(k);
+      int i = col.index(k);
+
+      ASSERT_WARN("WMAISM45", isNotZero(aij, R(1.0 / R(infinity))));
+
+      if (aij > 0) {
+        if (dualVarLo[i] <= R(-infinity))
+          dualConsLo[j] = R(-infinity);
+        else
+          dualConsLo[j] += aij * dualVarLo[i];
+
+        if (dualVarUp[i] >= R(infinity))
+          dualConsUp[j] = R(infinity);
+        else
+          dualConsUp[j] += aij * dualVarUp[i];
+      } else if (aij < 0) {
+        if (dualVarLo[i] <= R(-infinity))
+          dualConsUp[j] = R(infinity);
+        else
+          dualConsUp[j] += aij * dualVarLo[i];
+
+        if (dualVarUp[i] >= R(infinity))
+          dualConsLo[j] = R(-infinity);
+        else
+          dualConsLo[j] += aij * dualVarUp[i];
       }
+    }
+  }
+
+  for (int j = lp.nCols() - 1; j >= 0; --j) {
+    if (lp.colVector(j).size() <= 1)
+      continue;
+
+    // dual infeasibility checks
+    if (LTrel(dualConsUp[j], dualConsLo[j], opttol())) {
+      MSG_DEBUG((*this->spxout)
+                    << "IMAISM46 col " << j
+                    << ": dual infeasible -> dual lhs bound=" << dualConsLo[j]
+                    << " dual rhs bound=" << dualConsUp[j] << std::endl;)
+      return this->DUAL_INFEASIBLE;
+    }
 
-      R obj = lp.maxObj(j);
+    R obj = lp.maxObj(j);
 
-      // 1. dominated column
-      // Is the problem really unbounded in the cases below ??? Or is only dual infeasibility be shown
-      if(GTrel(obj, dualConsUp[j], opttol()))
-      {
+    // 1. dominated column
+    // Is the problem really unbounded in the cases below ??? Or is only dual
+    // infeasibility be shown
+    if (GTrel(obj, dualConsUp[j], opttol())) {
 #if DOMINATED_COLUMN
-         MSG_DEBUG((*this->spxout) << "IMAISM47 col " << j
-                   << ": dominated -> maxObj=" << obj
-                   << " dual rhs bound=" << dualConsUp[j] << std::endl;)
+      MSG_DEBUG((*this->spxout)
+                    << "IMAISM47 col " << j << ": dominated -> maxObj=" << obj
+                    << " dual rhs bound=" << dualConsUp[j] << std::endl;)
 
-         if(lp.upper(j) >= R(infinity))
-         {
-            MSG_INFO2((*this->spxout), (*this->spxout) << " unbounded" << std::endl;)
-            return this->UNBOUNDED;
-         }
+      if (lp.upper(j) >= R(infinity)) {
+        MSG_INFO2((*this->spxout), (*this->spxout)
+                                       << " unbounded" << std::endl;)
+        return this->UNBOUNDED;
+      }
 
-         MSG_DEBUG((*this->spxout) << " fixed at upper=" << lp.upper(j) << std::endl;)
+      MSG_DEBUG((*this->spxout)
+                    << " fixed at upper=" << lp.upper(j) << std::endl;)
 
-         std::shared_ptr<PostStep> ptr(new FixBoundsPS(lp, j, lp.upper(j)));
-         m_hist.append(ptr);
-         lp.changeLower(j, lp.upper(j));
+      std::shared_ptr<PostStep> ptr(new FixBoundsPS(lp, j, lp.upper(j)));
+      m_hist.append(ptr);
+      lp.changeLower(j, lp.upper(j));
 
-         ++m_stat[DOMINATED_COL];
+      ++m_stat[DOMINATED_COL];
 #endif
-      }
-      else if(LTrel(obj, dualConsLo[j], opttol()))
-      {
+    } else if (LTrel(obj, dualConsLo[j], opttol())) {
 #if DOMINATED_COLUMN
-         MSG_DEBUG((*this->spxout) << "IMAISM48 col " << j
-                   << ": dominated -> maxObj=" << obj
-                   << " dual lhs bound=" << dualConsLo[j] << std::endl;)
+      MSG_DEBUG((*this->spxout)
+                    << "IMAISM48 col " << j << ": dominated -> maxObj=" << obj
+                    << " dual lhs bound=" << dualConsLo[j] << std::endl;)
 
-         if(lp.lower(j) <= R(-infinity))
-         {
-            MSG_INFO2((*this->spxout), (*this->spxout) << " unbounded" << std::endl;)
-            return this->UNBOUNDED;
-         }
+      if (lp.lower(j) <= R(-infinity)) {
+        MSG_INFO2((*this->spxout), (*this->spxout)
+                                       << " unbounded" << std::endl;)
+        return this->UNBOUNDED;
+      }
 
-         MSG_DEBUG((*this->spxout) << " fixed at lower=" << lp.lower(j) << std::endl;)
+      MSG_DEBUG((*this->spxout)
+                    << " fixed at lower=" << lp.lower(j) << std::endl;)
 
-         std::shared_ptr<PostStep> ptr(new FixBoundsPS(lp, j, lp.lower(j)));
-         m_hist.append(ptr);
-         lp.changeUpper(j, lp.lower(j));
+      std::shared_ptr<PostStep> ptr(new FixBoundsPS(lp, j, lp.lower(j)));
+      m_hist.append(ptr);
+      lp.changeUpper(j, lp.lower(j));
 
-         ++m_stat[DOMINATED_COL];
+      ++m_stat[DOMINATED_COL];
 #endif
-      }
+    }
 
-      // 2. weakly dominated column (no postsolving)
-      else if(lp.upper(j) < R(infinity) && EQrel(obj, dualConsUp[j], opttol()))
-      {
+    // 2. weakly dominated column (no postsolving)
+    else if (lp.upper(j) < R(infinity) && EQrel(obj, dualConsUp[j], opttol())) {
 #if WEAKLY_DOMINATED_COLUMN
-         MSG_DEBUG((*this->spxout) << "IMAISM49 col " << j
-                   << ": weakly dominated -> maxObj=" << obj
-                   << " dual rhs bound=" << dualConsUp[j] << std::endl;)
+      MSG_DEBUG((*this->spxout)
+                    << "IMAISM49 col " << j << ": weakly dominated -> maxObj="
+                    << obj << " dual rhs bound=" << dualConsUp[j] << std::endl;)
 
-         std::shared_ptr<PostStep> ptr(new FixBoundsPS(lp, j, lp.upper(j)));
-         m_hist.append(ptr);
-         lp.changeLower(j, lp.upper(j));
+      std::shared_ptr<PostStep> ptr(new FixBoundsPS(lp, j, lp.upper(j)));
+      m_hist.append(ptr);
+      lp.changeLower(j, lp.upper(j));
 
-         ++m_stat[WEAKLY_DOMINATED_COL];
+      ++m_stat[WEAKLY_DOMINATED_COL];
 #endif
-      }
-      else if(lp.lower(j) > R(-infinity) && EQrel(obj, dualConsLo[j], opttol()))
-      {
+    } else if (lp.lower(j) > R(-infinity) &&
+               EQrel(obj, dualConsLo[j], opttol())) {
 #if WEAKLY_DOMINATED_COLUMN
-         MSG_DEBUG((*this->spxout) << "IMAISM50 col " << j
-                   << ": weakly dominated -> maxObj=" << obj
-                   << " dual lhs bound=" << dualConsLo[j] << std::endl;)
+      MSG_DEBUG((*this->spxout)
+                    << "IMAISM50 col " << j << ": weakly dominated -> maxObj="
+                    << obj << " dual lhs bound=" << dualConsLo[j] << std::endl;)
 
-         std::shared_ptr<PostStep> ptr(new FixBoundsPS(lp, j, lp.lower(j)));
-         m_hist.append(ptr);
-         lp.changeUpper(j, lp.lower(j));
+      std::shared_ptr<PostStep> ptr(new FixBoundsPS(lp, j, lp.lower(j)));
+      m_hist.append(ptr);
+      lp.changeUpper(j, lp.lower(j));
 
-         ++m_stat[WEAKLY_DOMINATED_COL];
+      ++m_stat[WEAKLY_DOMINATED_COL];
 #endif
-      }
+    }
 
-      // fix column
-      if(EQrel(lp.lower(j), lp.upper(j), feastol()))
-      {
+    // fix column
+    if (EQrel(lp.lower(j), lp.upper(j), feastol())) {
 #if FIX_VARIABLE
-         fixColumn(lp, j);
+      fixColumn(lp, j);
 
-         ++remCols;
-         remNzos += lp.colVector(j).size();
-         removeCol(lp, j);
+      ++remCols;
+      remNzos += lp.colVector(j).size();
+      removeCol(lp, j);
 
-         ++m_stat[FIX_COL];
+      ++m_stat[FIX_COL];
 #endif
-      }
-   }
-
+    }
+  }
 
-   assert(remRows > 0 || remCols > 0 || remNzos == 0);
+  assert(remRows > 0 || remCols > 0 || remNzos == 0);
 
-   if(remCols + remRows > 0)
-   {
-      this->m_remRows += remRows;
-      this->m_remCols += remCols;
-      this->m_remNzos += remNzos;
+  if (remCols + remRows > 0) {
+    this->m_remRows += remRows;
+    this->m_remCols += remCols;
+    this->m_remNzos += remNzos;
 
-      MSG_INFO2((*this->spxout), (*this->spxout) << "Simplifier (dual) removed "
-                << remRows << " rows, "
-                << remCols << " cols, "
-                << remNzos << " non-zeros"
-                << std::endl;)
+    MSG_INFO2((*this->spxout), (*this->spxout)
+                                   << "Simplifier (dual) removed " << remRows
+                                   << " rows, " << remCols << " cols, "
+                                   << remNzos << " non-zeros" << std::endl;)
 
-      if(remCols + remRows > this->m_minReduction * (oldCols + oldRows))
-         again = true;
-   }
+    if (remCols + remRows > this->m_minReduction * (oldCols + oldRows))
+      again = true;
+  }
 
-   return this->OKAY;
+  return this->OKAY;
 }
 
-
-
 template <class R>
-typename SPxSimplifier<R>::Result SPxMainSM<R>::multiaggregation(SPxLPBase<R>& lp, bool& again)
-{
-   // this simplifier eliminates rows and columns by performing multi aggregations as identified by the constraint
-   // activities.
-   int remRows = 0;
-   int remCols = 0;
-   int remNzos = 0;
-
-   int oldRows = lp.nRows();
-   int oldCols = lp.nCols();
-
-   VectorBase<R> upLocks(lp.nCols());
-   VectorBase<R> downLocks(lp.nCols());
-
-   for(int j = lp.nCols() - 1; j >= 0; --j)
-   {
-      // setting the locks on the variables
-      upLocks[j] = 0;
-      downLocks[j] = 0;
-
-      if(lp.colVector(j).size() <= 1)
-         continue;
-
-      const SVectorBase<R>& col = lp.colVector(j);
-
-      for(int k = 0; k < col.size(); ++k)
-      {
-         R aij = col.value(k);
-
-         ASSERT_WARN("WMAISM45", isNotZero(aij, R(1.0 / R(infinity))));
-
-         if(GT(lp.lhs(col.index(k)), R(-infinity)) && LT(lp.rhs(col.index(k)), R(infinity)))
-         {
-            upLocks[j]++;
-            downLocks[j]++;
-         }
-         else if(GT(lp.lhs(col.index(k)), R(-infinity)))
-         {
-            if(aij > 0)
-               downLocks[j]++;
-            else if(aij < 0)
-               upLocks[j]++;
-         }
-         else if(LT(lp.rhs(col.index(k)), R(infinity)))
-         {
-            if(aij > 0)
-               upLocks[j]++;
-            else if(aij < 0)
-               downLocks[j]++;
-         }
-      }
-
-      // multi-aggregate column
-      if(upLocks[j] == 1 || downLocks[j] == 1)
-      {
-         R lower = lp.lower(j);
-         R upper = lp.upper(j);
-         int maxOtherLocks;
-         int bestpos = -1;
-         bool bestislhs = true;
-
-         for(int k = 0; k < col.size(); ++k)
-         {
-            int rowNumber;
-            R lhs;
-            R rhs;
-            bool lhsExists;
-            bool rhsExists;
-            bool aggLhs;
-            bool aggRhs;
-
-            R val = col.value(k);
-
-            rowNumber = col.index(k);
-            lhs = lp.lhs(rowNumber);
-            rhs = lp.rhs(rowNumber);
-
-            if(EQ(lhs, rhs, feastol()))
-               continue;
-
-            lhsExists = GT(lhs, R(-infinity));
-            rhsExists = LT(rhs, R(infinity));
-
-            if(lp.rowVector(rowNumber).size() <= 2)
-               maxOtherLocks = INT_MAX;
-            else if(lp.rowVector(rowNumber).size() == 3)
-               maxOtherLocks = 3;
-            else if(lp.rowVector(rowNumber).size() == 4)
-               maxOtherLocks = 2;
-            else
-               maxOtherLocks = 1;
-
-            aggLhs = lhsExists
-                     && ((col.value(k) > 0.0 && lp.maxObj(j) <= 0.0 && downLocks[j] == 1 && upLocks[j] <= maxOtherLocks)
-                         || (col.value(k) < 0.0 && lp.maxObj(j) >= 0.0 && upLocks[j] == 1 && downLocks[j] <= maxOtherLocks));
-            aggRhs = rhsExists
-                     && ((col.value(k) > 0.0 && lp.maxObj(j) >= 0.0 && upLocks[j] == 1 && downLocks[j] <= maxOtherLocks)
-                         || (col.value(k) < 0.0 && lp.maxObj(j) <= 0.0 && downLocks[j] == 1 && upLocks[j] <= maxOtherLocks));
-
-            if(aggLhs || aggRhs)
-            {
-               R minRes = 0;   // this is the minimum value that the aggregation can attain
-               R maxRes = 0;   // this is the maximum value that the aggregation can attain
-
-               // computing the minimum and maximum residuals if variable j is set to zero.
-               computeMinMaxResidualActivity(lp, rowNumber, j, minRes, maxRes);
-
-               // we will try to aggregate to the lhs
-               if(aggLhs)
-               {
-                  R minVal;
-                  R maxVal;
-
-                  // computing the values of the upper and lower bounds for the aggregated variables
-                  computeMinMaxValues(lp, lhs, val, minRes, maxRes, minVal, maxVal);
-
-                  assert(LE(minVal, maxVal));
-
-                  // if the bounds of the aggregation and the original variable are equivalent, then we can reduce
-                  if((minVal > R(-infinity) && GT(minVal, lower, feastol()))
-                        && (maxVal < R(infinity) && LT(maxVal, upper, feastol())))
-                  {
-                     bestpos = col.index(k);
-                     bestislhs = true;
-                     break;
-                  }
-               }
+typename SPxSimplifier<R>::Result
+SPxMainSM<R>::multiaggregation(SPxLPBase<R> &lp, bool &again) {
+  // this simplifier eliminates rows and columns by performing multi
+  // aggregations as identified by the constraint activities.
+  int remRows = 0;
+  int remCols = 0;
+  int remNzos = 0;
+
+  int oldRows = lp.nRows();
+  int oldCols = lp.nCols();
+
+  VectorBase<R> upLocks(lp.nCols());
+  VectorBase<R> downLocks(lp.nCols());
+
+  for (int j = lp.nCols() - 1; j >= 0; --j) {
+    // setting the locks on the variables
+    upLocks[j] = 0;
+    downLocks[j] = 0;
+
+    if (lp.colVector(j).size() <= 1)
+      continue;
+
+    const SVectorBase<R> &col = lp.colVector(j);
+
+    for (int k = 0; k < col.size(); ++k) {
+      R aij = col.value(k);
+
+      ASSERT_WARN("WMAISM45", isNotZero(aij, R(1.0 / R(infinity))));
+
+      if (GT(lp.lhs(col.index(k)), R(-infinity)) &&
+          LT(lp.rhs(col.index(k)), R(infinity))) {
+        upLocks[j]++;
+        downLocks[j]++;
+      } else if (GT(lp.lhs(col.index(k)), R(-infinity))) {
+        if (aij > 0)
+          downLocks[j]++;
+        else if (aij < 0)
+          upLocks[j]++;
+      } else if (LT(lp.rhs(col.index(k)), R(infinity))) {
+        if (aij > 0)
+          upLocks[j]++;
+        else if (aij < 0)
+          downLocks[j]++;
+      }
+    }
+
+    // multi-aggregate column
+    if (upLocks[j] == 1 || downLocks[j] == 1) {
+      R lower = lp.lower(j);
+      R upper = lp.upper(j);
+      int maxOtherLocks;
+      int bestpos = -1;
+      bool bestislhs = true;
+
+      for (int k = 0; k < col.size(); ++k) {
+        int rowNumber;
+        R lhs;
+        R rhs;
+        bool lhsExists;
+        bool rhsExists;
+        bool aggLhs;
+        bool aggRhs;
+
+        R val = col.value(k);
+
+        rowNumber = col.index(k);
+        lhs = lp.lhs(rowNumber);
+        rhs = lp.rhs(rowNumber);
+
+        if (EQ(lhs, rhs, feastol()))
+          continue;
+
+        lhsExists = GT(lhs, R(-infinity));
+        rhsExists = LT(rhs, R(infinity));
+
+        if (lp.rowVector(rowNumber).size() <= 2)
+          maxOtherLocks = INT_MAX;
+        else if (lp.rowVector(rowNumber).size() == 3)
+          maxOtherLocks = 3;
+        else if (lp.rowVector(rowNumber).size() == 4)
+          maxOtherLocks = 2;
+        else
+          maxOtherLocks = 1;
+
+        aggLhs =
+            lhsExists && ((col.value(k) > 0.0 && lp.maxObj(j) <= 0.0 &&
+                           downLocks[j] == 1 && upLocks[j] <= maxOtherLocks) ||
+                          (col.value(k) < 0.0 && lp.maxObj(j) >= 0.0 &&
+                           upLocks[j] == 1 && downLocks[j] <= maxOtherLocks));
+        aggRhs =
+            rhsExists && ((col.value(k) > 0.0 && lp.maxObj(j) >= 0.0 &&
+                           upLocks[j] == 1 && downLocks[j] <= maxOtherLocks) ||
+                          (col.value(k) < 0.0 && lp.maxObj(j) <= 0.0 &&
+                           downLocks[j] == 1 && upLocks[j] <= maxOtherLocks));
+
+        if (aggLhs || aggRhs) {
+          R minRes =
+              0; // this is the minimum value that the aggregation can attain
+          R maxRes =
+              0; // this is the maximum value that the aggregation can attain
+
+          // computing the minimum and maximum residuals if variable j is set to
+          // zero.
+          computeMinMaxResidualActivity(lp, rowNumber, j, minRes, maxRes);
+
+          // we will try to aggregate to the lhs
+          if (aggLhs) {
+            R minVal;
+            R maxVal;
+
+            // computing the values of the upper and lower bounds for the
+            // aggregated variables
+            computeMinMaxValues(lp, lhs, val, minRes, maxRes, minVal, maxVal);
+
+            assert(LE(minVal, maxVal));
+
+            // if the bounds of the aggregation and the original variable are
+            // equivalent, then we can reduce
+            if ((minVal > R(-infinity) && GT(minVal, lower, feastol())) &&
+                (maxVal < R(infinity) && LT(maxVal, upper, feastol()))) {
+              bestpos = col.index(k);
+              bestislhs = true;
+              break;
+            }
+          }
 
-               // we will try to aggregate to the rhs
-               if(aggRhs)
-               {
-                  R minVal;
-                  R maxVal;
+          // we will try to aggregate to the rhs
+          if (aggRhs) {
+            R minVal;
+            R maxVal;
 
-                  // computing the values of the upper and lower bounds for the aggregated variables
-                  computeMinMaxValues(lp, rhs, val, minRes, maxRes, minVal, maxVal);
+            // computing the values of the upper and lower bounds for the
+            // aggregated variables
+            computeMinMaxValues(lp, rhs, val, minRes, maxRes, minVal, maxVal);
 
-                  assert(LE(minVal, maxVal));
+            assert(LE(minVal, maxVal));
 
-                  if((minVal > R(-infinity) && GT(minVal, lower, feastol()))
-                        && (maxVal < R(infinity) && LT(maxVal, upper, feastol())))
-                  {
-                     bestpos = col.index(k);
-                     bestislhs = false;
-                     break;
-                  }
-               }
+            if ((minVal > R(-infinity) && GT(minVal, lower, feastol())) &&
+                (maxVal < R(infinity) && LT(maxVal, upper, feastol()))) {
+              bestpos = col.index(k);
+              bestislhs = false;
+              break;
+            }
+          }
+        }
+      }
+
+      // it is only possible to aggregate if a best position has been found
+      if (bestpos >= 0) {
+        const SVectorBase<R> &bestRow = lp.rowVector(bestpos);
+        // aggregating the variable and applying the fixings to the all other
+        // constraints
+        R aggConstant = (bestislhs ? lp.lhs(bestpos)
+                                   : lp.rhs(bestpos)); // this is the lhs or rhs
+                                                       // of the aggregated row
+        R aggAij = bestRow[j]; // this is the coefficient of the deleted col
+
+        MSG_DEBUG((*this->spxout) << "IMAISM51 col " << j
+                                  << ": Aggregating row: " << bestpos
+                                  << " Aggregation Constant=" << aggConstant
+                                  << " Coefficient of aggregated col=" << aggAij
+                                  << std::endl;)
+
+        std::shared_ptr<PostStep> ptr(
+            new MultiAggregationPS(lp, *this, bestpos, j, aggConstant));
+        m_hist.append(ptr);
+
+        for (int k = 0; k < col.size(); ++k) {
+          if (col.index(k) != bestpos) {
+            int rowNumber = col.index(k);
+            VectorBase<R> updateRow(lp.nCols());
+            R updateRhs = lp.rhs(col.index(k));
+            R updateLhs = lp.lhs(col.index(k));
+
+            updateRow = lp.rowVector(col.index(k));
+
+            // updating the row with the best row
+            for (int l = 0; l < bestRow.size(); l++) {
+              if (bestRow.index(l) != j) {
+                if (lp.rowVector(rowNumber).pos(bestRow.index(l)) >= 0)
+                  lp.changeElement(rowNumber, bestRow.index(l),
+                                   updateRow[bestRow.index(l)] -
+                                       updateRow[j] * bestRow.value(l) /
+                                           aggAij);
+                else
+                  lp.changeElement(rowNumber, bestRow.index(l),
+                                   -1.0 * updateRow[j] * bestRow.value(l) /
+                                       aggAij);
+              }
             }
-         }
-
-         // it is only possible to aggregate if a best position has been found
-         if(bestpos >= 0)
-         {
-            const SVectorBase<R>& bestRow = lp.rowVector(bestpos);
-            // aggregating the variable and applying the fixings to the all other constraints
-            R aggConstant = (bestislhs ? lp.lhs(bestpos) : lp.rhs(
-                                bestpos));   // this is the lhs or rhs of the aggregated row
-            R aggAij =
-               bestRow[j];                                   // this is the coefficient of the deleted col
-
-            MSG_DEBUG(
-               (*this->spxout) << "IMAISM51 col " << j
-               << ": Aggregating row: " << bestpos
-               << " Aggregation Constant=" << aggConstant
-               << " Coefficient of aggregated col=" << aggAij << std::endl;
-            )
-
-            std::shared_ptr<PostStep> ptr(new MultiAggregationPS(lp, *this, bestpos, j, aggConstant));
-            m_hist.append(ptr);
-
-            for(int k = 0; k < col.size(); ++k)
-            {
-               if(col.index(k) != bestpos)
-               {
-                  int rowNumber = col.index(k);
-                  VectorBase<R> updateRow(lp.nCols());
-                  R updateRhs = lp.rhs(col.index(k));
-                  R updateLhs = lp.lhs(col.index(k));
-
-                  updateRow = lp.rowVector(col.index(k));
-
-                  // updating the row with the best row
-                  for(int l = 0; l < bestRow.size(); l++)
-                  {
-                     if(bestRow.index(l) != j)
-                     {
-                        if(lp.rowVector(rowNumber).pos(bestRow.index(l)) >= 0)
-                           lp.changeElement(rowNumber, bestRow.index(l), updateRow[bestRow.index(l)]
-                                            - updateRow[j]*bestRow.value(l) / aggAij);
-                        else
-                           lp.changeElement(rowNumber, bestRow.index(l), -1.0 * updateRow[j]*bestRow.value(l) / aggAij);
-                     }
-                  }
 
-                  // NOTE: I don't know whether we should change the LHS and RHS if they are currently at R(infinity)
-                  if(LT(lp.rhs(rowNumber), R(infinity)))
-                     lp.changeRhs(rowNumber, updateRhs - updateRow[j]*aggConstant / aggAij);
+            // NOTE: I don't know whether we should change the LHS and RHS if
+            // they are currently at R(infinity)
+            if (LT(lp.rhs(rowNumber), R(infinity)))
+              lp.changeRhs(rowNumber,
+                           updateRhs - updateRow[j] * aggConstant / aggAij);
 
-                  if(GT(lp.lhs(rowNumber), R(-infinity)))
-                     lp.changeLhs(rowNumber, updateLhs - updateRow[j]*aggConstant / aggAij);
+            if (GT(lp.lhs(rowNumber), R(-infinity)))
+              lp.changeLhs(rowNumber,
+                           updateLhs - updateRow[j] * aggConstant / aggAij);
 
-                  assert(LE(lp.lhs(rowNumber), lp.rhs(rowNumber)));
-               }
-            }
+            assert(LE(lp.lhs(rowNumber), lp.rhs(rowNumber)));
+          }
+        }
 
-            for(int l = 0; l < bestRow.size(); l++)
-            {
-               if(bestRow.index(l) != j)
-                  lp.changeMaxObj(bestRow.index(l),
-                                  lp.maxObj(bestRow.index(l)) - lp.maxObj(j)*bestRow.value(l) / aggAij);
-            }
+        for (int l = 0; l < bestRow.size(); l++) {
+          if (bestRow.index(l) != j)
+            lp.changeMaxObj(bestRow.index(l),
+                            lp.maxObj(bestRow.index(l)) -
+                                lp.maxObj(j) * bestRow.value(l) / aggAij);
+        }
 
-            ++remCols;
-            remNzos += lp.colVector(j).size();
-            removeCol(lp, j);
-            ++remRows;
-            remNzos += lp.rowVector(bestpos).size();
-            removeRow(lp, bestpos);
+        ++remCols;
+        remNzos += lp.colVector(j).size();
+        removeCol(lp, j);
+        ++remRows;
+        remNzos += lp.rowVector(bestpos).size();
+        removeRow(lp, bestpos);
 
-            ++m_stat[MULTI_AGG];
-         }
+        ++m_stat[MULTI_AGG];
       }
-   }
+    }
+  }
 
+  assert(remRows > 0 || remCols > 0 || remNzos == 0);
 
-   assert(remRows > 0 || remCols > 0 || remNzos == 0);
+  if (remCols + remRows > 0) {
+    this->m_remRows += remRows;
+    this->m_remCols += remCols;
+    this->m_remNzos += remNzos;
 
-   if(remCols + remRows > 0)
-   {
-      this->m_remRows += remRows;
-      this->m_remCols += remCols;
-      this->m_remNzos += remNzos;
+    MSG_INFO2((*this->spxout),
+              (*this->spxout) << "Simplifier (multi-aggregation) removed "
+                              << remRows << " rows, " << remCols << " cols, "
+                              << remNzos << " non-zeros" << std::endl;)
 
-      MSG_INFO2((*this->spxout), (*this->spxout) << "Simplifier (multi-aggregation) removed "
-                << remRows << " rows, "
-                << remCols << " cols, "
-                << remNzos << " non-zeros"
-                << std::endl;)
+    if (remCols + remRows > this->m_minReduction * (oldCols + oldRows))
+      again = true;
+  }
 
-      if(remCols + remRows > this->m_minReduction * (oldCols + oldRows))
-         again = true;
-   }
-
-   return this->OKAY;
+  return this->OKAY;
 }
 
-
-
 template <class R>
-typename SPxSimplifier<R>::Result SPxMainSM<R>::duplicateRows(SPxLPBase<R>& lp, bool& again)
-{
+typename SPxSimplifier<R>::Result SPxMainSM<R>::duplicateRows(SPxLPBase<R> &lp,
+                                                              bool &again) {
 
-   // This method simplifies the LP by removing duplicate rows
-   // Duplicates are detected using the algorithm of Bixby and Wagner [1987]
+  // This method simplifies the LP by removing duplicate rows
+  // Duplicates are detected using the algorithm of Bixby and Wagner [1987]
 
-   // Possible extension: use generalized definition of duplicate rows according to Andersen and Andersen
-   // However: the resulting sparsification is often very small since the involved rows are usually very sparse
+  // Possible extension: use generalized definition of duplicate rows according
+  // to Andersen and Andersen However: the resulting sparsification is often
+  // very small since the involved rows are usually very sparse
 
-   int remRows = 0;
-   int remNzos = 0;
+  int remRows = 0;
+  int remNzos = 0;
 
-   int oldRows = lp.nRows();
+  int oldRows = lp.nRows();
 
-   // remove empty rows and columns
-   typename SPxSimplifier<R>::Result ret = removeEmpty(lp);
+  // remove empty rows and columns
+  typename SPxSimplifier<R>::Result ret = removeEmpty(lp);
 
-   if(ret != this->OKAY)
-      return ret;
+  if (ret != this->OKAY)
+    return ret;
 
 #if ROW_SINGLETON
-   int rs_remRows = 0;
+  int rs_remRows = 0;
 
-   for(int i = 0; i < lp.nRows(); ++i)
-   {
-      const SVectorBase<R>& row = lp.rowVector(i);
+  for (int i = 0; i < lp.nRows(); ++i) {
+    const SVectorBase<R> &row = lp.rowVector(i);
 
-      if(row.size() == 1)
-      {
-         removeRowSingleton(lp, row, i);
-         rs_remRows++;
-      }
-   }
+    if (row.size() == 1) {
+      removeRowSingleton(lp, row, i);
+      rs_remRows++;
+    }
+  }
 
-   if(rs_remRows > 0)
-   {
-      MSG_INFO2((*this->spxout), (*this->spxout) <<
-                "Simplifier duplicate rows (row singleton stage) removed "
-                << rs_remRows << " rows, "
-                << rs_remRows << " non-zeros"
-                << std::endl;)
-   }
+  if (rs_remRows > 0) {
+    MSG_INFO2((*this->spxout),
+              (*this->spxout)
+                  << "Simplifier duplicate rows (row singleton stage) removed "
+                  << rs_remRows << " rows, " << rs_remRows << " non-zeros"
+                  << std::endl;)
+  }
 
 #endif
 
-   if(lp.nRows() < 2)
-      return this->OKAY;
-
-   DataArray<int>    pClass(lp.nRows());           // class of parallel rows
-   DataArray<int>    classSize(lp.nRows());        // size of each class
-   Array<R>   scale(lp.nRows());            // scaling factor for each row
-   int*              idxMem = 0;
-
-   try
-   {
-      spx_alloc(idxMem, lp.nRows());
-   }
-   catch(const SPxMemoryException& x)
-   {
-      spx_free(idxMem);
-      throw x;
-   }
-
-   IdxSet idxSet(lp.nRows(), idxMem);           // set of feasible indices for new pClass
-
-   // init
-   pClass[0]    = 0;
-   scale[0]     = 0.0;
-   classSize[0] = lp.nRows();
-
-   for(int i = 1; i < lp.nRows(); ++i)
-   {
-      pClass[i] = 0;
-      scale[i]  = 0.0;
-      classSize[i] = 0;
-      idxSet.addIdx(i);
-   }
-
-   R oldVal = 0.0;
-
-   // main loop
-   for(int j = 0; j < lp.nCols(); ++j)
-   {
-      const SVectorBase<R>& col = lp.colVector(j);
-
-      for(int k = 0; k < col.size(); ++k)
-      {
-         R aij = col.value(k);
-         int  i   = col.index(k);
-
-         if(scale[i] == 0.0)
-            scale[i] = aij;
-
-         m_classSetRows[pClass[i]].add(i, aij / scale[i]);
-
-         if(--classSize[pClass[i]] == 0)
-            idxSet.addIdx(pClass[i]);
-      }
-
-      // update each parallel class with non-zero column entry
-      for(int m = 0; m < col.size(); ++m)
-      {
-         int k = pClass[col.index(m)];
+  if (lp.nRows() < 2)
+    return this->OKAY;
 
-         if(m_classSetRows[k].size() > 0)
-         {
-            // sort classSet[k] w.r.t. scaled column values
-            ElementCompare compare;
+  DataArray<int> pClass(lp.nRows());    // class of parallel rows
+  DataArray<int> classSize(lp.nRows()); // size of each class
+  Array<R> scale(lp.nRows());           // scaling factor for each row
+  int *idxMem = 0;
 
-            if(m_classSetRows[k].size() > 1)
-               SPxQuicksort(m_classSetRows[k].mem(), m_classSetRows[k].size(), compare);
+  try {
+    spx_alloc(idxMem, lp.nRows());
+  } catch (const SPxMemoryException &x) {
+    spx_free(idxMem);
+    throw x;
+  }
 
-            // use new index first
-            int classIdx = idxSet.index(0);
-            idxSet.remove(0);
-
-            for(int l = 0; l < m_classSetRows[k].size(); ++l)
-            {
-               if(l != 0 && NErel(m_classSetRows[k].value(l), oldVal, this->epsZero()))
-               {
-                  classIdx = idxSet.index(0);
-                  idxSet.remove(0);
-               }
+  IdxSet idxSet(lp.nRows(), idxMem); // set of feasible indices for new pClass
 
-               pClass[m_classSetRows[k].index(l)] = classIdx;
-               ++classSize[classIdx];
+  // init
+  pClass[0] = 0;
+  scale[0] = 0.0;
+  classSize[0] = lp.nRows();
 
-               oldVal = m_classSetRows[k].value(l);
-            }
+  for (int i = 1; i < lp.nRows(); ++i) {
+    pClass[i] = 0;
+    scale[i] = 0.0;
+    classSize[i] = 0;
+    idxSet.addIdx(i);
+  }
 
-            m_classSetRows[k].clear();
-         }
-      }
-   }
+  R oldVal = 0.0;
 
-   spx_free(idxMem);
+  // main loop
+  for (int j = 0; j < lp.nCols(); ++j) {
+    const SVectorBase<R> &col = lp.colVector(j);
 
-   DataArray<bool> remRow(lp.nRows());
+    for (int k = 0; k < col.size(); ++k) {
+      R aij = col.value(k);
+      int i = col.index(k);
 
-   for(int k = 0; k < lp.nRows(); ++k)
-      m_dupRows[k].clear();
+      if (scale[i] == 0.0)
+        scale[i] = aij;
 
-   for(int k = 0; k < lp.nRows(); ++k)
-   {
-      remRow[k] = false;
-      m_dupRows[pClass[k]].add(k, 0.0);
-   }
+      m_classSetRows[pClass[i]].add(i, aij / scale[i]);
 
-   const int nRowsOld_tmp = lp.nRows();
-   int* perm_tmp = 0;
-   spx_alloc(perm_tmp, nRowsOld_tmp);
+      if (--classSize[pClass[i]] == 0)
+        idxSet.addIdx(pClass[i]);
+    }
 
-   for(int j = 0; j < nRowsOld_tmp; ++j)
-   {
-      perm_tmp[j] = 0;
-   }
+    // update each parallel class with non-zero column entry
+    for (int m = 0; m < col.size(); ++m) {
+      int k = pClass[col.index(m)];
 
-   int idxFirstDupRows = -1;
-   int idxLastDupRows = -1;
-   int numDelRows = 0;
+      if (m_classSetRows[k].size() > 0) {
+        // sort classSet[k] w.r.t. scaled column values
+        ElementCompare compare;
 
-   for(int k = 0; k < lp.nRows(); ++k)
-   {
-      if(m_dupRows[k].size() > 1 && !(lp.rowVector(m_dupRows[k].index(0)).size() == 1))
-      {
-         idxLastDupRows = k;
+        if (m_classSetRows[k].size() > 1)
+          SPxQuicksort(m_classSetRows[k].mem(), m_classSetRows[k].size(),
+                       compare);
 
-         if(idxFirstDupRows < 0)
-         {
-            idxFirstDupRows = k;
-         }
+        // use new index first
+        int classIdx = idxSet.index(0);
+        idxSet.remove(0);
 
-         for(int l = 1; l < m_dupRows[k].size(); ++l)
-         {
-            int i = m_dupRows[k].index(l);
-            perm_tmp[i] = -1;
-         }
+        for (int l = 0; l < m_classSetRows[k].size(); ++l) {
+          if (l != 0 &&
+              NErel(m_classSetRows[k].value(l), oldVal, this->epsZero())) {
+            classIdx = idxSet.index(0);
+            idxSet.remove(0);
+          }
 
-         numDelRows += (m_dupRows[k].size() - 1);
-      }
-   }
+          pClass[m_classSetRows[k].index(l)] = classIdx;
+          ++classSize[classIdx];
 
-   {
-      int k_tmp, j_tmp = -1;
+          oldVal = m_classSetRows[k].value(l);
+        }
 
-      for(k_tmp = j_tmp = 0; k_tmp < nRowsOld_tmp; ++k_tmp)
-      {
-         if(perm_tmp[k_tmp] >= 0)
-            perm_tmp[k_tmp] = j_tmp++;
+        m_classSetRows[k].clear();
       }
-   }
-
-   // store rhs and lhs changes for combined update
-   bool doChangeRanges = false;
-   VectorBase<R> newLhsVec(lp.lhs());
-   VectorBase<R> newRhsVec(lp.rhs());
-
-   for(int k = 0; k < lp.nRows(); ++k)
-   {
-      if(m_dupRows[k].size() > 1 && !(lp.rowVector(m_dupRows[k].index(0)).size() == 1))
-      {
-         MSG_DEBUG((*this->spxout) << "IMAISM53 " << m_dupRows[k].size()
-                   << " duplicate rows found" << std::endl;)
-
-         m_stat[DUPLICATE_ROW] += m_dupRows[k].size() - 1;
-
-         // index of one non-column singleton row in dupRows[k]
-         int  rowIdx    = -1;
-         int  maxLhsIdx = -1;
-         int  minRhsIdx = -1;
-         R maxLhs    = R(-infinity);
-         R minRhs    = +R(infinity);
-
-         DataArray<bool> isLhsEqualRhs(m_dupRows[k].size());
-
-         // determine strictest bounds on constraint
-         for(int l = 0; l < m_dupRows[k].size(); ++l)
-         {
-            int i = m_dupRows[k].index(l);
-            isLhsEqualRhs[l] = (lp.lhs(i) == lp.rhs(i));
-
-            ASSERT_WARN("WMAISM54", isNotZero(scale[i], R(1.0 / R(infinity))));
-
-            if(rowIdx == -1)
-            {
-               rowIdx = i;
-               maxLhs = lp.lhs(rowIdx);
-               minRhs = lp.rhs(rowIdx);
-            }
-            else
-            {
-               R scaledLhs, scaledRhs;
-               R factor = scale[rowIdx] / scale[i];
-
-               if(factor > 0)
-               {
-                  scaledLhs = (lp.lhs(i) <= R(-infinity)) ? R(-infinity) : lp.lhs(i) * factor;
-                  scaledRhs = (lp.rhs(i) >=  R(infinity)) ?  R(infinity) : lp.rhs(i) * factor;
-               }
-               else
-               {
-                  scaledLhs = (lp.rhs(i) >=  R(infinity)) ? R(-infinity) : lp.rhs(i) * factor;
-                  scaledRhs = (lp.lhs(i) <= R(-infinity)) ?  R(infinity) : lp.lhs(i) * factor;
-               }
-
-               if(scaledLhs > maxLhs)
-               {
-                  maxLhs    = scaledLhs;
-                  maxLhsIdx = i;
-               }
-
-               if(scaledRhs < minRhs)
-               {
-                  minRhs    = scaledRhs;
-                  minRhsIdx = i;
-               }
-
-               remRow[i] = true;
-            }
-         }
-
-         if(rowIdx != -1)
-         {
-            R newLhs = (maxLhs > lp.lhs(rowIdx)) ? maxLhs : lp.lhs(rowIdx);
-            R newRhs = (minRhs < lp.rhs(rowIdx)) ? minRhs : lp.rhs(rowIdx);
-
-            if(k == idxLastDupRows)
-            {
-               DataArray<int> da_perm(nRowsOld_tmp);
-
-               for(int j = 0; j < nRowsOld_tmp; ++j)
-               {
-                  da_perm[j] = perm_tmp[j];
-               }
-
-               std::shared_ptr<PostStep> ptr(new DuplicateRowsPS(lp, rowIdx, maxLhsIdx, minRhsIdx,
-                                             m_dupRows[k], scale, da_perm, isLhsEqualRhs, true,
-                                             EQrel(newLhs, newRhs), k == idxFirstDupRows));
-               m_hist.append(ptr);
-            }
-            else
-            {
-               DataArray<int> da_perm_empty(0);
-               std::shared_ptr<PostStep> ptr(new DuplicateRowsPS(lp, rowIdx, maxLhsIdx, minRhsIdx,
-                                             m_dupRows[k], scale, da_perm_empty, isLhsEqualRhs, false, EQrel(newLhs, newRhs),
-                                             k == idxFirstDupRows));
-               m_hist.append(ptr);
-            }
+    }
+  }
 
-            if(maxLhs > lp.lhs(rowIdx) || minRhs < lp.rhs(rowIdx))
-            {
-               // modify lhs and rhs of constraint rowIdx
-               doChangeRanges = true;
-
-               if(LTrel(newRhs, newLhs, feastol()))
-               {
-                  MSG_DEBUG((*this->spxout) << "IMAISM55 duplicate rows yield infeasible bounds:"
-                            << " lhs=" << newLhs
-                            << " rhs=" << newRhs << std::endl;)
-                  spx_free(perm_tmp);
-                  return this->INFEASIBLE;
-               }
-
-               // if we accept the infeasibility we should clean up the values to avoid problems later
-               if(newRhs < newLhs)
-                  newRhs = newLhs;
-
-               newLhsVec[rowIdx] = newLhs;
-               newRhsVec[rowIdx] = newRhs;
-            }
-         }
-      }
-   }
-
-   // change ranges for all modified constraints by one single call (more efficient)
-   if(doChangeRanges)
-   {
-      lp.changeRange(newLhsVec, newRhsVec);
-   }
-
-   // remove all rows by one single method call (more efficient)
-   const int nRowsOld = lp.nRows();
-   int* perm = 0;
-   spx_alloc(perm, nRowsOld);
-
-   for(int i = 0; i < nRowsOld; ++i)
-   {
-      if(remRow[i])
-      {
-         perm[i] = -1;
-         ++remRows;
-         remNzos += lp.rowVector(i).size();
-      }
-      else
-         perm[i] = 0;
-   }
+  spx_free(idxMem);
 
-   lp.removeRows(perm);
+  DataArray<bool> remRow(lp.nRows());
 
-   for(int i = 0; i < nRowsOld; ++i)
-   {
-      // assert that the pre-computed permutation was correct
-      assert(perm[i] == perm_tmp[i]);
+  for (int k = 0; k < lp.nRows(); ++k)
+    m_dupRows[k].clear();
 
-      // update the global index mapping
-      if(perm[i] >= 0)
-         m_rIdx[perm[i]] = m_rIdx[i];
-   }
+  for (int k = 0; k < lp.nRows(); ++k) {
+    remRow[k] = false;
+    m_dupRows[pClass[k]].add(k, 0.0);
+  }
 
-   spx_free(perm);
-   spx_free(perm_tmp);
+  const int nRowsOld_tmp = lp.nRows();
+  int *perm_tmp = 0;
+  spx_alloc(perm_tmp, nRowsOld_tmp);
 
-   if(remRows + remNzos > 0)
-   {
-      this->m_remRows += remRows;
-      this->m_remNzos += remNzos;
+  for (int j = 0; j < nRowsOld_tmp; ++j) {
+    perm_tmp[j] = 0;
+  }
 
-      MSG_INFO2((*this->spxout), (*this->spxout) << "Simplifier (duplicate rows) removed "
-                << remRows << " rows, "
-                << remNzos << " non-zeros"
-                << std::endl;)
+  int idxFirstDupRows = -1;
+  int idxLastDupRows = -1;
+  int numDelRows = 0;
 
-      if(remRows > this->m_minReduction * oldRows)
-         again = true;
+  for (int k = 0; k < lp.nRows(); ++k) {
+    if (m_dupRows[k].size() > 1 &&
+        !(lp.rowVector(m_dupRows[k].index(0)).size() == 1)) {
+      idxLastDupRows = k;
 
-   }
+      if (idxFirstDupRows < 0) {
+        idxFirstDupRows = k;
+      }
 
-   return this->OKAY;
+      for (int l = 1; l < m_dupRows[k].size(); ++l) {
+        int i = m_dupRows[k].index(l);
+        perm_tmp[i] = -1;
+      }
+
+      numDelRows += (m_dupRows[k].size() - 1);
+    }
+  }
+
+  {
+    int k_tmp, j_tmp = -1;
+
+    for (k_tmp = j_tmp = 0; k_tmp < nRowsOld_tmp; ++k_tmp) {
+      if (perm_tmp[k_tmp] >= 0)
+        perm_tmp[k_tmp] = j_tmp++;
+    }
+  }
+
+  // store rhs and lhs changes for combined update
+  bool doChangeRanges = false;
+  VectorBase<R> newLhsVec(lp.lhs());
+  VectorBase<R> newRhsVec(lp.rhs());
+
+  for (int k = 0; k < lp.nRows(); ++k) {
+    if (m_dupRows[k].size() > 1 &&
+        !(lp.rowVector(m_dupRows[k].index(0)).size() == 1)) {
+      MSG_DEBUG((*this->spxout) << "IMAISM53 " << m_dupRows[k].size()
+                                << " duplicate rows found" << std::endl;)
+
+      m_stat[DUPLICATE_ROW] += m_dupRows[k].size() - 1;
+
+      // index of one non-column singleton row in dupRows[k]
+      int rowIdx = -1;
+      int maxLhsIdx = -1;
+      int minRhsIdx = -1;
+      R maxLhs = R(-infinity);
+      R minRhs = +R(infinity);
+
+      DataArray<bool> isLhsEqualRhs(m_dupRows[k].size());
+
+      // determine strictest bounds on constraint
+      for (int l = 0; l < m_dupRows[k].size(); ++l) {
+        int i = m_dupRows[k].index(l);
+        isLhsEqualRhs[l] = (lp.lhs(i) == lp.rhs(i));
+
+        ASSERT_WARN("WMAISM54", isNotZero(scale[i], R(1.0 / R(infinity))));
+
+        if (rowIdx == -1) {
+          rowIdx = i;
+          maxLhs = lp.lhs(rowIdx);
+          minRhs = lp.rhs(rowIdx);
+        } else {
+          R scaledLhs, scaledRhs;
+          R factor = scale[rowIdx] / scale[i];
+
+          if (factor > 0) {
+            scaledLhs =
+                (lp.lhs(i) <= R(-infinity)) ? R(-infinity) : lp.lhs(i) * factor;
+            scaledRhs =
+                (lp.rhs(i) >= R(infinity)) ? R(infinity) : lp.rhs(i) * factor;
+          } else {
+            scaledLhs =
+                (lp.rhs(i) >= R(infinity)) ? R(-infinity) : lp.rhs(i) * factor;
+            scaledRhs =
+                (lp.lhs(i) <= R(-infinity)) ? R(infinity) : lp.lhs(i) * factor;
+          }
+
+          if (scaledLhs > maxLhs) {
+            maxLhs = scaledLhs;
+            maxLhsIdx = i;
+          }
+
+          if (scaledRhs < minRhs) {
+            minRhs = scaledRhs;
+            minRhsIdx = i;
+          }
+
+          remRow[i] = true;
+        }
+      }
+
+      if (rowIdx != -1) {
+        R newLhs = (maxLhs > lp.lhs(rowIdx)) ? maxLhs : lp.lhs(rowIdx);
+        R newRhs = (minRhs < lp.rhs(rowIdx)) ? minRhs : lp.rhs(rowIdx);
+
+        if (k == idxLastDupRows) {
+          DataArray<int> da_perm(nRowsOld_tmp);
+
+          for (int j = 0; j < nRowsOld_tmp; ++j) {
+            da_perm[j] = perm_tmp[j];
+          }
+
+          std::shared_ptr<PostStep> ptr(new DuplicateRowsPS(
+              lp, rowIdx, maxLhsIdx, minRhsIdx, m_dupRows[k], scale, da_perm,
+              isLhsEqualRhs, true, EQrel(newLhs, newRhs),
+              k == idxFirstDupRows));
+          m_hist.append(ptr);
+        } else {
+          DataArray<int> da_perm_empty(0);
+          std::shared_ptr<PostStep> ptr(new DuplicateRowsPS(
+              lp, rowIdx, maxLhsIdx, minRhsIdx, m_dupRows[k], scale,
+              da_perm_empty, isLhsEqualRhs, false, EQrel(newLhs, newRhs),
+              k == idxFirstDupRows));
+          m_hist.append(ptr);
+        }
+
+        if (maxLhs > lp.lhs(rowIdx) || minRhs < lp.rhs(rowIdx)) {
+          // modify lhs and rhs of constraint rowIdx
+          doChangeRanges = true;
+
+          if (LTrel(newRhs, newLhs, feastol())) {
+            MSG_DEBUG((*this->spxout)
+                          << "IMAISM55 duplicate rows yield infeasible bounds:"
+                          << " lhs=" << newLhs << " rhs=" << newRhs
+                          << std::endl;)
+            spx_free(perm_tmp);
+            return this->INFEASIBLE;
+          }
+
+          // if we accept the infeasibility we should clean up the values to
+          // avoid problems later
+          if (newRhs < newLhs)
+            newRhs = newLhs;
+
+          newLhsVec[rowIdx] = newLhs;
+          newRhsVec[rowIdx] = newRhs;
+        }
+      }
+    }
+  }
+
+  // change ranges for all modified constraints by one single call (more
+  // efficient)
+  if (doChangeRanges) {
+    lp.changeRange(newLhsVec, newRhsVec);
+  }
+
+  // remove all rows by one single method call (more efficient)
+  const int nRowsOld = lp.nRows();
+  int *perm = 0;
+  spx_alloc(perm, nRowsOld);
+
+  for (int i = 0; i < nRowsOld; ++i) {
+    if (remRow[i]) {
+      perm[i] = -1;
+      ++remRows;
+      remNzos += lp.rowVector(i).size();
+    } else
+      perm[i] = 0;
+  }
+
+  lp.removeRows(perm);
+
+  for (int i = 0; i < nRowsOld; ++i) {
+    // assert that the pre-computed permutation was correct
+    assert(perm[i] == perm_tmp[i]);
+
+    // update the global index mapping
+    if (perm[i] >= 0)
+      m_rIdx[perm[i]] = m_rIdx[i];
+  }
+
+  spx_free(perm);
+  spx_free(perm_tmp);
+
+  if (remRows + remNzos > 0) {
+    this->m_remRows += remRows;
+    this->m_remNzos += remNzos;
+
+    MSG_INFO2((*this->spxout), (*this->spxout)
+                                   << "Simplifier (duplicate rows) removed "
+                                   << remRows << " rows, " << remNzos
+                                   << " non-zeros" << std::endl;)
+
+    if (remRows > this->m_minReduction * oldRows)
+      again = true;
+  }
+
+  return this->OKAY;
 }
 
 template <class R>
-typename SPxSimplifier<R>::Result SPxMainSM<R>::duplicateCols(SPxLPBase<R>& lp, bool& again)
-{
+typename SPxSimplifier<R>::Result SPxMainSM<R>::duplicateCols(SPxLPBase<R> &lp,
+                                                              bool &again) {
 
-   // This method simplifies the LP by removing duplicate columns
-   // Duplicates are detected using the algorithm of Bixby and Wagner [1987]
+  // This method simplifies the LP by removing duplicate columns
+  // Duplicates are detected using the algorithm of Bixby and Wagner [1987]
 
-   int remCols = 0;
-   int remNzos = 0;
+  int remCols = 0;
+  int remNzos = 0;
 
-   // remove empty rows and columns
-   typename SPxSimplifier<R>::Result ret = removeEmpty(lp);
+  // remove empty rows and columns
+  typename SPxSimplifier<R>::Result ret = removeEmpty(lp);
 
-   if(ret != this->OKAY)
-      return ret;
+  if (ret != this->OKAY)
+    return ret;
 
-   if(lp.nCols() < 2)
-      return this->OKAY;
+  if (lp.nCols() < 2)
+    return this->OKAY;
 
-   DataArray<int>    pClass(lp.nCols());          // class of parallel columns
-   DataArray<int>    classSize(lp.nCols());       // size of each class
-   Array<R>   scale(lp.nCols());           // scaling factor for each column
-   int*              idxMem = 0;
+  DataArray<int> pClass(lp.nCols());    // class of parallel columns
+  DataArray<int> classSize(lp.nCols()); // size of each class
+  Array<R> scale(lp.nCols());           // scaling factor for each column
+  int *idxMem = 0;
 
-   try
-   {
-      spx_alloc(idxMem, lp.nCols());
-   }
-   catch(const SPxMemoryException& x)
-   {
-      spx_free(idxMem);
-      throw x;
-   }
+  try {
+    spx_alloc(idxMem, lp.nCols());
+  } catch (const SPxMemoryException &x) {
+    spx_free(idxMem);
+    throw x;
+  }
 
-   IdxSet idxSet(lp.nCols(), idxMem);  // set of feasible indices for new pClass
+  IdxSet idxSet(lp.nCols(), idxMem); // set of feasible indices for new pClass
 
-   // init
-   pClass[0]    = 0;
-   scale[0]     = 0.0;
-   classSize[0] = lp.nCols();
+  // init
+  pClass[0] = 0;
+  scale[0] = 0.0;
+  classSize[0] = lp.nCols();
 
-   for(int j = 1; j < lp.nCols(); ++j)
-   {
-      pClass[j] = 0;
-      scale[j]  = 0.0;
-      classSize[j] = 0;
-      idxSet.addIdx(j);
-   }
+  for (int j = 1; j < lp.nCols(); ++j) {
+    pClass[j] = 0;
+    scale[j] = 0.0;
+    classSize[j] = 0;
+    idxSet.addIdx(j);
+  }
 
-   R oldVal = 0.0;
+  R oldVal = 0.0;
 
-   // main loop
-   for(int i = 0; i < lp.nRows(); ++i)
-   {
-      const SVectorBase<R>& row = lp.rowVector(i);
+  // main loop
+  for (int i = 0; i < lp.nRows(); ++i) {
+    const SVectorBase<R> &row = lp.rowVector(i);
 
-      for(int k = 0; k < row.size(); ++k)
-      {
-         R aij = row.value(k);
-         int  j   = row.index(k);
+    for (int k = 0; k < row.size(); ++k) {
+      R aij = row.value(k);
+      int j = row.index(k);
 
-         if(scale[j] == 0.0)
-            scale[j] = aij;
+      if (scale[j] == 0.0)
+        scale[j] = aij;
 
-         m_classSetCols[pClass[j]].add(j, aij / scale[j]);
+      m_classSetCols[pClass[j]].add(j, aij / scale[j]);
 
-         if(--classSize[pClass[j]] == 0)
-            idxSet.addIdx(pClass[j]);
-      }
+      if (--classSize[pClass[j]] == 0)
+        idxSet.addIdx(pClass[j]);
+    }
+
+    // update each parallel class with non-zero row entry
+    for (int m = 0; m < row.size(); ++m) {
+      int k = pClass[row.index(m)];
 
-      // update each parallel class with non-zero row entry
-      for(int m = 0; m < row.size(); ++m)
-      {
-         int k = pClass[row.index(m)];
+      if (m_classSetCols[k].size() > 0) {
+        // sort classSet[k] w.r.t. scaled row values
+        ElementCompare compare;
 
-         if(m_classSetCols[k].size() > 0)
-         {
-            // sort classSet[k] w.r.t. scaled row values
-            ElementCompare compare;
+        if (m_classSetCols[k].size() > 1)
+          SPxQuicksort(m_classSetCols[k].mem(), m_classSetCols[k].size(),
+                       compare);
 
-            if(m_classSetCols[k].size() > 1)
-               SPxQuicksort(m_classSetCols[k].mem(), m_classSetCols[k].size(), compare);
+        // use new index first
+        int classIdx = idxSet.index(0);
+        idxSet.remove(0);
 
-            // use new index first
-            int classIdx = idxSet.index(0);
+        for (int l = 0; l < m_classSetCols[k].size(); ++l) {
+          if (l != 0 &&
+              NErel(m_classSetCols[k].value(l), oldVal, this->epsZero())) {
+            // start new parallel class
+            classIdx = idxSet.index(0);
             idxSet.remove(0);
+          }
 
-            for(int l = 0; l < m_classSetCols[k].size(); ++l)
-            {
-               if(l != 0 && NErel(m_classSetCols[k].value(l), oldVal, this->epsZero()))
-               {
-                  // start new parallel class
-                  classIdx = idxSet.index(0);
-                  idxSet.remove(0);
-               }
+          pClass[m_classSetCols[k].index(l)] = classIdx;
+          ++classSize[classIdx];
 
-               pClass[m_classSetCols[k].index(l)] = classIdx;
-               ++classSize[classIdx];
+          oldVal = m_classSetCols[k].value(l);
+        }
 
-               oldVal = m_classSetCols[k].value(l);
-            }
+        m_classSetCols[k].clear();
+      }
+    }
+  }
+
+  spx_free(idxMem);
+
+  DataArray<bool> remCol(lp.nCols());
+  DataArray<bool> fixAndRemCol(lp.nCols());
+
+  for (int k = 0; k < lp.nCols(); ++k)
+    m_dupCols[k].clear();
+
+  for (int k = 0; k < lp.nCols(); ++k) {
+    remCol[k] = false;
+    fixAndRemCol[k] = false;
+    m_dupCols[pClass[k]].add(k, 0.0);
+  }
+
+  bool hasDuplicateCol = false;
+  DataArray<int> m_perm_empty(0);
+
+  for (int k = 0; k < lp.nCols(); ++k) {
+    if (m_dupCols[k].size() > 1 &&
+        !(lp.colVector(m_dupCols[k].index(0)).size() == 1)) {
+      MSG_DEBUG((*this->spxout) << "IMAISM58 " << m_dupCols[k].size()
+                                << " duplicate columns found" << std::endl;)
 
-            m_classSetCols[k].clear();
-         }
+      if (!hasDuplicateCol) {
+        std::shared_ptr<PostStep> ptr(
+            new DuplicateColsPS(lp, 0, 0, 1.0, m_perm_empty, true));
+        m_hist.append(ptr);
+        hasDuplicateCol = true;
       }
-   }
-
-   spx_free(idxMem);
-
-   DataArray<bool> remCol(lp.nCols());
-   DataArray<bool> fixAndRemCol(lp.nCols());
-
-   for(int k = 0; k < lp.nCols(); ++k)
-      m_dupCols[k].clear();
-
-   for(int k = 0; k < lp.nCols(); ++k)
-   {
-      remCol[k] = false;
-      fixAndRemCol[k] = false;
-      m_dupCols[pClass[k]].add(k, 0.0);
-   }
-
-   bool hasDuplicateCol = false;
-   DataArray<int>  m_perm_empty(0);
-
-   for(int k = 0; k < lp.nCols(); ++k)
-   {
-      if(m_dupCols[k].size() > 1 && !(lp.colVector(m_dupCols[k].index(0)).size() == 1))
-      {
-         MSG_DEBUG((*this->spxout) << "IMAISM58 " << m_dupCols[k].size()
-                   << " duplicate columns found" << std::endl;)
-
-         if(!hasDuplicateCol)
-         {
-            std::shared_ptr<PostStep> ptr(new DuplicateColsPS(lp, 0, 0, 1.0, m_perm_empty, true));
-            m_hist.append(ptr);
-            hasDuplicateCol = true;
-         }
-
-         for(int l = 0; l < m_dupCols[k].size(); ++l)
-         {
-            for(int m = 0; m < m_dupCols[k].size(); ++m)
-            {
-               int j1  = m_dupCols[k].index(l);
-               int j2  = m_dupCols[k].index(m);
-
-               if(l != m && !remCol[j1] && !remCol[j2])
-               {
-                  R cj1 = lp.maxObj(j1);
-                  R cj2 = lp.maxObj(j2);
-
-                  // A.j1 = factor * A.j2
-                  R factor = scale[j1] / scale[j2];
-                  R objDif = cj1 - cj2 * scale[j1] / scale[j2];
-
-                  ASSERT_WARN("WMAISM59", isNotZero(factor, this->epsZero()));
-
-                  if(isZero(objDif, this->epsZero()))
-                  {
-                     // case 1: objectives also duplicate
-
-                     // if 0 is not within the column bounds, we are not able to postsolve if the aggregated column has
-                     // status ZERO, hence we skip this case
-                     if(LErel(lp.lower(j1), R(0.0)) && GErel(lp.upper(j1), R(0.0))
-                           && LErel(lp.lower(j2), R(0.0)) && GErel(lp.upper(j2), R(0.0)))
-                     {
-                        std::shared_ptr<PostStep> ptr(new DuplicateColsPS(lp, j1, j2, factor, m_perm_empty));
-                        // variable substitution xj2' := xj2 + factor * xj1 <=> xj2 = -factor * xj1 + xj2'
-                        m_hist.append(ptr);
-
-                        // update bounds of remaining column j2 (new column j2')
-                        if(factor > 0)
-                        {
-                           if(lp.lower(j2) <= R(-infinity) || lp.lower(j1) <= R(-infinity))
-                              lp.changeLower(j2, R(-infinity));
-                           else
-                              lp.changeLower(j2, lp.lower(j2) + factor * lp.lower(j1));
-
-                           if(lp.upper(j2) >= R(infinity) || lp.upper(j1) >= R(infinity))
-                              lp.changeUpper(j2, R(infinity));
-                           else
-                              lp.changeUpper(j2, lp.upper(j2) + factor * lp.upper(j1));
-                        }
-                        else if(factor < 0)
-                        {
-                           if(lp.lower(j2) <= R(-infinity) || lp.upper(j1) >= R(infinity))
-                              lp.changeLower(j2, R(-infinity));
-                           else
-                              lp.changeLower(j2, lp.lower(j2) + factor * lp.upper(j1));
-
-                           if(lp.upper(j2) >= R(infinity) || lp.lower(j1) <= R(-infinity))
-                              lp.changeUpper(j2, R(infinity));
-                           else
-                              lp.changeUpper(j2, lp.upper(j2) + factor * lp.lower(j1));
-                        }
-
-                        MSG_DEBUG((*this->spxout) << "IMAISM60 two duplicate columns " << j1
-                                  << ", " << j2
-                                  << " replaced by one" << std::endl;)
-
-                        remCol[j1] = true;
-
-                        ++m_stat[SUB_DUPLICATE_COL];
-                     }
-                     else
-                     {
-                        MSG_DEBUG((*this->spxout) << "IMAISM80 not removing two duplicate columns " << j1
-                                  << ", " << j2
-                                  << " because zero not contained in their bounds" << std::endl;)
-                     }
-                  }
+
+      for (int l = 0; l < m_dupCols[k].size(); ++l) {
+        for (int m = 0; m < m_dupCols[k].size(); ++m) {
+          int j1 = m_dupCols[k].index(l);
+          int j2 = m_dupCols[k].index(m);
+
+          if (l != m && !remCol[j1] && !remCol[j2]) {
+            R cj1 = lp.maxObj(j1);
+            R cj2 = lp.maxObj(j2);
+
+            // A.j1 = factor * A.j2
+            R factor = scale[j1] / scale[j2];
+            R objDif = cj1 - cj2 * scale[j1] / scale[j2];
+
+            ASSERT_WARN("WMAISM59", isNotZero(factor, this->epsZero()));
+
+            if (isZero(objDif, this->epsZero())) {
+              // case 1: objectives also duplicate
+
+              // if 0 is not within the column bounds, we are not able to
+              // postsolve if the aggregated column has status ZERO, hence we
+              // skip this case
+              if (LErel(lp.lower(j1), R(0.0)) && GErel(lp.upper(j1), R(0.0)) &&
+                  LErel(lp.lower(j2), R(0.0)) && GErel(lp.upper(j2), R(0.0))) {
+                std::shared_ptr<PostStep> ptr(
+                    new DuplicateColsPS(lp, j1, j2, factor, m_perm_empty));
+                // variable substitution xj2' := xj2 + factor * xj1 <=> xj2 =
+                // -factor * xj1 + xj2'
+                m_hist.append(ptr);
+
+                // update bounds of remaining column j2 (new column j2')
+                if (factor > 0) {
+                  if (lp.lower(j2) <= R(-infinity) ||
+                      lp.lower(j1) <= R(-infinity))
+                    lp.changeLower(j2, R(-infinity));
                   else
-                  {
-                     // case 2: objectives not duplicate
-                     // considered for maximization sense
-                     if(lp.lower(j2) <= R(-infinity))
-                     {
-                        if(factor > 0 && objDif > 0)
-                        {
-                           if(lp.upper(j1) >= R(infinity))
-                           {
-                              MSG_DEBUG((*this->spxout) << "IMAISM75 LP unbounded" << std::endl;)
-                              return this->UNBOUNDED;
-                           }
-
-                           // fix j1 at upper bound
-                           MSG_DEBUG((*this->spxout) << "IMAISM61 two duplicate columns " << j1
-                                     << ", " << j2
-                                     << " first one fixed at upper bound=" << lp.upper(j1) << std::endl;)
-
-                           std::shared_ptr<PostStep> ptr(new FixBoundsPS(lp, j1, lp.upper(j1)));
-                           m_hist.append(ptr);
-                           lp.changeLower(j1, lp.upper(j1));
-                        }
-                        else if(factor < 0 && objDif < 0)
-                        {
-                           if(lp.lower(j1) <= R(-infinity))
-                           {
-                              MSG_DEBUG((*this->spxout) << "IMAISM76 LP unbounded" << std::endl;)
-                              return this->UNBOUNDED;
-                           }
-
-                           // fix j1 at lower bound
-                           MSG_DEBUG((*this->spxout) << "IMAISM62 two duplicate columns " << j1
-                                     << ", " << j2
-                                     << " first one fixed at lower bound=" << lp.lower(j1) << std::endl;)
-
-                           std::shared_ptr<PostStep> ptr(new FixBoundsPS(lp, j1, lp.lower(j1)));
-                           m_hist.append(ptr);
-                           lp.changeUpper(j1, lp.lower(j1));
-                        }
-                     }
-                     else if(lp.upper(j2) >= R(infinity))
-                     {
-                        // fix j1 at upper bound
-                        if(factor < 0 && objDif > 0)
-                        {
-                           if(lp.upper(j1) >= R(infinity))
-                           {
-                              MSG_DEBUG((*this->spxout) << "IMAISM77 LP unbounded" << std::endl;)
-                              return this->UNBOUNDED;
-                           }
-
-                           // fix j1 at upper bound
-                           MSG_DEBUG((*this->spxout) << "IMAISM63 two duplicate columns " << j1
-                                     << ", " << j2
-                                     << " first one fixed at upper bound=" << lp.upper(j1) << std::endl;)
-
-                           std::shared_ptr<PostStep> ptr(new FixBoundsPS(lp, j1, lp.upper(j1)));
-                           m_hist.append(ptr);
-                           lp.changeLower(j1, lp.upper(j1));
-                        }
-
-                        // fix j1 at lower bound
-                        else if(factor > 0 && objDif < 0)
-                        {
-                           if(lp.lower(j1) <= R(-infinity))
-                           {
-                              MSG_DEBUG((*this->spxout) << "IMAISM78 LP unbounded" << std::endl;)
-                              return this->UNBOUNDED;
-                           }
-
-                           // fix j1 at lower bound
-                           MSG_DEBUG((*this->spxout) << "IMAISM64 two duplicate columns " << j1
-                                     << ", " << j2
-                                     << " first one fixed at lower bound=" << lp.lower(j1) << std::endl;)
-
-                           std::shared_ptr<PostStep> ptr(new FixBoundsPS(lp, j1, lp.lower(j1)));
-                           m_hist.append(ptr);
-                           lp.changeUpper(j1, lp.lower(j1));
-                        }
-                     }
-
-                     if(EQrel(lp.lower(j1), lp.upper(j1), feastol()))
-                     {
-                        remCol[j1] = true;
-                        fixAndRemCol[j1] = true;
-
-                        ++m_stat[FIX_DUPLICATE_COL];
-                     }
+                    lp.changeLower(j2, lp.lower(j2) + factor * lp.lower(j1));
+
+                  if (lp.upper(j2) >= R(infinity) ||
+                      lp.upper(j1) >= R(infinity))
+                    lp.changeUpper(j2, R(infinity));
+                  else
+                    lp.changeUpper(j2, lp.upper(j2) + factor * lp.upper(j1));
+                } else if (factor < 0) {
+                  if (lp.lower(j2) <= R(-infinity) ||
+                      lp.upper(j1) >= R(infinity))
+                    lp.changeLower(j2, R(-infinity));
+                  else
+                    lp.changeLower(j2, lp.lower(j2) + factor * lp.upper(j1));
+
+                  if (lp.upper(j2) >= R(infinity) ||
+                      lp.lower(j1) <= R(-infinity))
+                    lp.changeUpper(j2, R(infinity));
+                  else
+                    lp.changeUpper(j2, lp.upper(j2) + factor * lp.lower(j1));
+                }
+
+                MSG_DEBUG((*this->spxout)
+                              << "IMAISM60 two duplicate columns " << j1 << ", "
+                              << j2 << " replaced by one" << std::endl;)
+
+                remCol[j1] = true;
+
+                ++m_stat[SUB_DUPLICATE_COL];
+              } else {
+                MSG_DEBUG((*this->spxout)
+                              << "IMAISM80 not removing two duplicate columns "
+                              << j1 << ", " << j2
+                              << " because zero not contained in their bounds"
+                              << std::endl;)
+              }
+            } else {
+              // case 2: objectives not duplicate
+              // considered for maximization sense
+              if (lp.lower(j2) <= R(-infinity)) {
+                if (factor > 0 && objDif > 0) {
+                  if (lp.upper(j1) >= R(infinity)) {
+                    MSG_DEBUG((*this->spxout)
+                                  << "IMAISM75 LP unbounded" << std::endl;)
+                    return this->UNBOUNDED;
+                  }
+
+                  // fix j1 at upper bound
+                  MSG_DEBUG((*this->spxout)
+                                << "IMAISM61 two duplicate columns " << j1
+                                << ", " << j2
+                                << " first one fixed at upper bound="
+                                << lp.upper(j1) << std::endl;)
+
+                  std::shared_ptr<PostStep> ptr(
+                      new FixBoundsPS(lp, j1, lp.upper(j1)));
+                  m_hist.append(ptr);
+                  lp.changeLower(j1, lp.upper(j1));
+                } else if (factor < 0 && objDif < 0) {
+                  if (lp.lower(j1) <= R(-infinity)) {
+                    MSG_DEBUG((*this->spxout)
+                                  << "IMAISM76 LP unbounded" << std::endl;)
+                    return this->UNBOUNDED;
+                  }
+
+                  // fix j1 at lower bound
+                  MSG_DEBUG((*this->spxout)
+                                << "IMAISM62 two duplicate columns " << j1
+                                << ", " << j2
+                                << " first one fixed at lower bound="
+                                << lp.lower(j1) << std::endl;)
+
+                  std::shared_ptr<PostStep> ptr(
+                      new FixBoundsPS(lp, j1, lp.lower(j1)));
+                  m_hist.append(ptr);
+                  lp.changeUpper(j1, lp.lower(j1));
+                }
+              } else if (lp.upper(j2) >= R(infinity)) {
+                // fix j1 at upper bound
+                if (factor < 0 && objDif > 0) {
+                  if (lp.upper(j1) >= R(infinity)) {
+                    MSG_DEBUG((*this->spxout)
+                                  << "IMAISM77 LP unbounded" << std::endl;)
+                    return this->UNBOUNDED;
+                  }
+
+                  // fix j1 at upper bound
+                  MSG_DEBUG((*this->spxout)
+                                << "IMAISM63 two duplicate columns " << j1
+                                << ", " << j2
+                                << " first one fixed at upper bound="
+                                << lp.upper(j1) << std::endl;)
+
+                  std::shared_ptr<PostStep> ptr(
+                      new FixBoundsPS(lp, j1, lp.upper(j1)));
+                  m_hist.append(ptr);
+                  lp.changeLower(j1, lp.upper(j1));
+                }
+
+                // fix j1 at lower bound
+                else if (factor > 0 && objDif < 0) {
+                  if (lp.lower(j1) <= R(-infinity)) {
+                    MSG_DEBUG((*this->spxout)
+                                  << "IMAISM78 LP unbounded" << std::endl;)
+                    return this->UNBOUNDED;
                   }
-               }
+
+                  // fix j1 at lower bound
+                  MSG_DEBUG((*this->spxout)
+                                << "IMAISM64 two duplicate columns " << j1
+                                << ", " << j2
+                                << " first one fixed at lower bound="
+                                << lp.lower(j1) << std::endl;)
+
+                  std::shared_ptr<PostStep> ptr(
+                      new FixBoundsPS(lp, j1, lp.lower(j1)));
+                  m_hist.append(ptr);
+                  lp.changeUpper(j1, lp.lower(j1));
+                }
+              }
+
+              if (EQrel(lp.lower(j1), lp.upper(j1), feastol())) {
+                remCol[j1] = true;
+                fixAndRemCol[j1] = true;
+
+                ++m_stat[FIX_DUPLICATE_COL];
+              }
             }
-         }
+          }
+        }
       }
-   }
+    }
+  }
 
-   for(int j = 0; j < lp.nCols(); ++j)
-   {
-      if(fixAndRemCol[j])
-      {
-         assert(remCol[j]);
+  for (int j = 0; j < lp.nCols(); ++j) {
+    if (fixAndRemCol[j]) {
+      assert(remCol[j]);
 
-         // correctIdx == false, because the index mapping will be handled by the postsolving in DuplicateColsPS
-         fixColumn(lp, j, false);
-      }
-   }
-
-   // remove all columns by one single method call (more efficient)
-   const int nColsOld = lp.nCols();
-   int* perm = 0;
-   spx_alloc(perm, nColsOld);
-
-   for(int j = 0; j < nColsOld; ++j)
-   {
-      if(remCol[j])
-      {
-         perm[j] = -1;
-         ++remCols;
-         remNzos += lp.colVector(j).size();
-      }
-      else
-         perm[j] = 0;
-   }
+      // correctIdx == false, because the index mapping will be handled by the
+      // postsolving in DuplicateColsPS
+      fixColumn(lp, j, false);
+    }
+  }
 
-   lp.removeCols(perm);
+  // remove all columns by one single method call (more efficient)
+  const int nColsOld = lp.nCols();
+  int *perm = 0;
+  spx_alloc(perm, nColsOld);
 
-   for(int j = 0; j < nColsOld; ++j)
-   {
-      if(perm[j] >= 0)
-         m_cIdx[perm[j]] = m_cIdx[j];
-   }
+  for (int j = 0; j < nColsOld; ++j) {
+    if (remCol[j]) {
+      perm[j] = -1;
+      ++remCols;
+      remNzos += lp.colVector(j).size();
+    } else
+      perm[j] = 0;
+  }
 
-   DataArray<int> da_perm(nColsOld);
+  lp.removeCols(perm);
 
-   for(int j = 0; j < nColsOld; ++j)
-   {
-      da_perm[j] = perm[j];
-   }
+  for (int j = 0; j < nColsOld; ++j) {
+    if (perm[j] >= 0)
+      m_cIdx[perm[j]] = m_cIdx[j];
+  }
 
-   if(hasDuplicateCol)
-   {
-      std::shared_ptr<PostStep> ptr(new DuplicateColsPS(lp, 0, 0, 1.0, da_perm, false, true));
-      m_hist.append(ptr);
-   }
+  DataArray<int> da_perm(nColsOld);
 
-   spx_free(perm);
+  for (int j = 0; j < nColsOld; ++j) {
+    da_perm[j] = perm[j];
+  }
 
-   assert(remCols > 0 || remNzos == 0);
+  if (hasDuplicateCol) {
+    std::shared_ptr<PostStep> ptr(
+        new DuplicateColsPS(lp, 0, 0, 1.0, da_perm, false, true));
+    m_hist.append(ptr);
+  }
 
-   if(remCols > 0)
-   {
-      this->m_remCols += remCols;
-      this->m_remNzos += remNzos;
+  spx_free(perm);
 
-      MSG_INFO2((*this->spxout), (*this->spxout) << "Simplifier (duplicate columns) removed "
-                << remCols << " cols, "
-                << remNzos << " non-zeros"
-                << std::endl;)
+  assert(remCols > 0 || remNzos == 0);
 
-      if(remCols > this->m_minReduction * nColsOld)
-         again = true;
-   }
+  if (remCols > 0) {
+    this->m_remCols += remCols;
+    this->m_remNzos += remNzos;
 
-   return this->OKAY;
+    MSG_INFO2((*this->spxout), (*this->spxout)
+                                   << "Simplifier (duplicate columns) removed "
+                                   << remCols << " cols, " << remNzos
+                                   << " non-zeros" << std::endl;)
+
+    if (remCols > this->m_minReduction * nColsOld)
+      again = true;
+  }
+
+  return this->OKAY;
 }
 
 template <class R>
-void SPxMainSM<R>::fixColumn(SPxLPBase<R>& lp, int j, bool correctIdx)
-{
+void SPxMainSM<R>::fixColumn(SPxLPBase<R> &lp, int j, bool correctIdx) {
 
-   assert(EQrel(lp.lower(j), lp.upper(j), feastol()));
+  assert(EQrel(lp.lower(j), lp.upper(j), feastol()));
 
-   R lo            = lp.lower(j);
-   R up            = lp.upper(j);
-   const SVectorBase<R>& col = lp.colVector(j);
-   R mid           = lo;
+  R lo = lp.lower(j);
+  R up = lp.upper(j);
+  const SVectorBase<R> &col = lp.colVector(j);
+  R mid = lo;
 
-   // use the center value between slightly different bounds to improve numerics
-   if(NE(lo, up))
-      mid = (up + lo) / 2.0;
+  // use the center value between slightly different bounds to improve numerics
+  if (NE(lo, up))
+    mid = (up + lo) / 2.0;
 
-   assert(LT(lo, R(infinity)) && GT(lo, R(-infinity)));
-   assert(LT(up, R(infinity)) && GT(up, R(-infinity)));
+  assert(LT(lo, R(infinity)) && GT(lo, R(-infinity)));
+  assert(LT(up, R(infinity)) && GT(up, R(-infinity)));
 
-   MSG_DEBUG((*this->spxout) << "IMAISM66 fix variable x" << j
-             << ": lower=" << lo
-             << " upper=" << up
-             << "to new value: " << mid
-             << std::endl;)
+  MSG_DEBUG((*this->spxout)
+                << "IMAISM66 fix variable x" << j << ": lower=" << lo
+                << " upper=" << up << "to new value: " << mid << std::endl;)
 
-   if(isNotZero(lo, this->epsZero()))
-   {
-      for(int k = 0; k < col.size(); ++k)
-      {
-         int i = col.index(k);
+  if (isNotZero(lo, this->epsZero())) {
+    for (int k = 0; k < col.size(); ++k) {
+      int i = col.index(k);
 
-         if(lp.rhs(i) < R(infinity))
-         {
-            R y     = mid * col.value(k);
-            R scale = maxAbs(lp.rhs(i), y);
+      if (lp.rhs(i) < R(infinity)) {
+        R y = mid * col.value(k);
+        R scale = maxAbs(lp.rhs(i), y);
 
-            if(scale < 1.0)
-               scale = 1.0;
+        if (scale < 1.0)
+          scale = 1.0;
 
-            R rhs = (lp.rhs(i) / scale) - (y / scale);
-
-            if(isZero(rhs, this->epsZero()))
-               rhs = 0.0;
-            else
-               rhs *= scale;
+        R rhs = (lp.rhs(i) / scale) - (y / scale);
 
-            MSG_DEBUG((*this->spxout) << "IMAISM67 row " << i
-                      << ": rhs=" << rhs
-                      << " (" << lp.rhs(i)
-                      << ") aij=" << col.value(k)
-                      << std::endl;)
+        if (isZero(rhs, this->epsZero()))
+          rhs = 0.0;
+        else
+          rhs *= scale;
 
-            lp.changeRhs(i, rhs);
-         }
+        MSG_DEBUG((*this->spxout)
+                      << "IMAISM67 row " << i << ": rhs=" << rhs << " ("
+                      << lp.rhs(i) << ") aij=" << col.value(k) << std::endl;)
 
-         if(lp.lhs(i) > R(-infinity))
-         {
-            R y     = mid * col.value(k);
-            R scale = maxAbs(lp.lhs(i), y);
+        lp.changeRhs(i, rhs);
+      }
 
-            if(scale < 1.0)
-               scale = 1.0;
+      if (lp.lhs(i) > R(-infinity)) {
+        R y = mid * col.value(k);
+        R scale = maxAbs(lp.lhs(i), y);
 
-            R lhs = (lp.lhs(i) / scale) - (y / scale);
+        if (scale < 1.0)
+          scale = 1.0;
 
-            if(isZero(lhs, this->epsZero()))
-               lhs = 0.0;
-            else
-               lhs *= scale;
+        R lhs = (lp.lhs(i) / scale) - (y / scale);
 
-            MSG_DEBUG((*this->spxout) << "IMAISM68 row " << i
-                      << ": lhs=" << lhs
-                      << " (" << lp.lhs(i)
-                      << ") aij=" << col.value(k)
-                      << std::endl;)
+        if (isZero(lhs, this->epsZero()))
+          lhs = 0.0;
+        else
+          lhs *= scale;
 
-            lp.changeLhs(i, lhs);
-         }
+        MSG_DEBUG((*this->spxout)
+                      << "IMAISM68 row " << i << ": lhs=" << lhs << " ("
+                      << lp.lhs(i) << ") aij=" << col.value(k) << std::endl;)
 
-         assert(lp.lhs(i) <= lp.rhs(i) + feastol());
+        lp.changeLhs(i, lhs);
       }
-   }
 
-   std::shared_ptr<PostStep> ptr(new FixVariablePS(lp, *this, j, lp.lower(j), correctIdx));
-   m_hist.append(ptr);
+      assert(lp.lhs(i) <= lp.rhs(i) + feastol());
+    }
+  }
+
+  std::shared_ptr<PostStep> ptr(
+      new FixVariablePS(lp, *this, j, lp.lower(j), correctIdx));
+  m_hist.append(ptr);
 }
 
 template <class R>
-typename SPxSimplifier<R>::Result SPxMainSM<R>::simplify(SPxLPBase<R>& lp, R eps, R ftol, R otol,
-      Real remainingTime,
-      bool keepbounds, uint32_t seed)
-{
-   // transfer message handler
-   this->spxout = lp.spxout;
-   assert(this->spxout != 0);
-
-   m_thesense = lp.spxSense();
-   this->m_timeUsed->reset();
-   this->m_timeUsed->start();
-
-   this->m_objoffset = 0.0;
-   m_cutoffbound = R(-infinity);
-   m_pseudoobj = R(-infinity);
-
-   this->m_remRows = 0;
-   this->m_remCols = 0;
-   this->m_remNzos = 0;
-   this->m_chgBnds = 0;
-   this->m_chgLRhs = 0;
-   this->m_keptBnds = 0;
-   this->m_keptLRhs = 0;
-
-   m_result     = this->OKAY;
-   bool   again = true;
-   int nrounds = 0;
-
-   if(m_hist.size() > 0)
-   {
-      m_hist.clear();
-   }
-
-   m_hist.reSize(0);
-   m_postsolved = false;
-
-   if(eps < 0.0)
-      throw SPxInterfaceException("XMAISM30 Cannot use negative this->epsilon in simplify().");
-
-   if(ftol < 0.0)
-      throw SPxInterfaceException("XMAISM31 Cannot use negative feastol in simplify().");
-
-   if(otol < 0.0)
-      throw SPxInterfaceException("XMAISM32 Cannot use negative opttol in simplify().");
-
-   m_epsilon = eps;
-   m_feastol = ftol;
-   m_opttol = otol;
-
-
-   MSG_INFO2((*this->spxout),
-             int numRangedRows = 0;
-             int numBoxedCols = 0;
-             int numEqualities = 0;
-
-             for(int i = 0; i < lp.nRows(); ++i)
-{
-   if(lp.lhs(i) > R(-infinity) && lp.rhs(i) < R(infinity))
-      {
-         if(EQ(lp.lhs(i), lp.rhs(i)))
+typename SPxSimplifier<R>::Result
+SPxMainSM<R>::simplify(SPxLPBase<R> &lp, R eps, R ftol, R otol,
+                       Real remainingTime, bool keepbounds, uint32_t seed) {
+  // transfer message handler
+  this->spxout = lp.spxout;
+  assert(this->spxout != 0);
+
+  m_thesense = lp.spxSense();
+  this->m_timeUsed->reset();
+  this->m_timeUsed->start();
+
+  this->m_objoffset = 0.0;
+  m_cutoffbound = R(-infinity);
+  m_pseudoobj = R(-infinity);
+
+  this->m_remRows = 0;
+  this->m_remCols = 0;
+  this->m_remNzos = 0;
+  this->m_chgBnds = 0;
+  this->m_chgLRhs = 0;
+  this->m_keptBnds = 0;
+  this->m_keptLRhs = 0;
+
+  m_result = this->OKAY;
+  bool again = true;
+  int nrounds = 0;
+
+  if (m_hist.size() > 0) {
+    m_hist.clear();
+  }
+
+  m_hist.reSize(0);
+  m_postsolved = false;
+
+  if (eps < 0.0)
+    throw SPxInterfaceException(
+        "XMAISM30 Cannot use negative this->epsilon in simplify().");
+
+  if (ftol < 0.0)
+    throw SPxInterfaceException(
+        "XMAISM31 Cannot use negative feastol in simplify().");
+
+  if (otol < 0.0)
+    throw SPxInterfaceException(
+        "XMAISM32 Cannot use negative opttol in simplify().");
+
+  m_epsilon = eps;
+  m_feastol = ftol;
+  m_opttol = otol;
+
+  MSG_INFO2(
+      (*this->spxout), int numRangedRows = 0; int numBoxedCols = 0;
+      int numEqualities = 0;
+
+      for (int i = 0; i < lp.nRows(); ++i) {
+        if (lp.lhs(i) > R(-infinity) && lp.rhs(i) < R(infinity)) {
+          if (EQ(lp.lhs(i), lp.rhs(i)))
             ++numEqualities;
-         else
+          else
             ++numRangedRows;
-      }
-   }
-   for(int j = 0; j < lp.nCols(); ++j)
-   if(lp.lower(j) > R(-infinity) && lp.upper(j) < R(infinity))
-      ++numBoxedCols;
+        }
+      } for (int j = 0; j < lp.nCols();
+             ++j) if (lp.lower(j) > R(-infinity) &&
+                      lp.upper(j) < R(infinity))++ numBoxedCols;
 
-      (*this->spxout) << "LP has "
-                      << numEqualities << " equations, "
-                      << numRangedRows << " ranged rows, "
-                      << numBoxedCols << " boxed columns"
-                      << std::endl;
-               )
+      (*this->spxout) << "LP has " << numEqualities << " equations, "
+                      << numRangedRows << " ranged rows, " << numBoxedCols
+                      << " boxed columns" << std::endl;)
 
-         m_stat.reSize(17);
+  m_stat.reSize(17);
 
-   for(int k = 0; k < m_stat.size(); ++k)
-      m_stat[k] = 0;
+  for (int k = 0; k < m_stat.size(); ++k)
+    m_stat[k] = 0;
 
-   m_addedcols = 0;
-   handleRowObjectives(lp);
+  m_addedcols = 0;
+  handleRowObjectives(lp);
 
-   m_prim.reDim(lp.nCols());
-   m_slack.reDim(lp.nRows());
-   m_dual.reDim(lp.nRows());
-   m_redCost.reDim(lp.nCols());
-   m_cBasisStat.reSize(lp.nCols());
-   m_rBasisStat.reSize(lp.nRows());
-   m_cIdx.reSize(lp.nCols());
-   m_rIdx.reSize(lp.nRows());
+  m_prim.reDim(lp.nCols());
+  m_slack.reDim(lp.nRows());
+  m_dual.reDim(lp.nRows());
+  m_redCost.reDim(lp.nCols());
+  m_cBasisStat.reSize(lp.nCols());
+  m_rBasisStat.reSize(lp.nRows());
+  m_cIdx.reSize(lp.nCols());
+  m_rIdx.reSize(lp.nRows());
 
-   m_classSetRows.reSize(lp.nRows());
-   m_classSetCols.reSize(lp.nCols());
-   m_dupRows.reSize(lp.nRows());
-   m_dupCols.reSize(lp.nCols());
+  m_classSetRows.reSize(lp.nRows());
+  m_classSetCols.reSize(lp.nCols());
+  m_dupRows.reSize(lp.nRows());
+  m_dupCols.reSize(lp.nCols());
 
-   m_keepbounds = keepbounds;
+  m_keepbounds = keepbounds;
 
-   for(int i = 0; i < lp.nRows(); ++i)
-      m_rIdx[i] = i;
+  for (int i = 0; i < lp.nRows(); ++i)
+    m_rIdx[i] = i;
 
-   for(int j = 0; j < lp.nCols(); ++j)
-      m_cIdx[j] = j;
+  for (int j = 0; j < lp.nCols(); ++j)
+    m_cIdx[j] = j;
 
-   // round extreme values (set all values smaller than this->eps to zero and all values bigger than R(infinity)/5 to R(infinity))
+    // round extreme values (set all values smaller than this->eps to zero and
+    // all values bigger than R(infinity)/5 to R(infinity))
 #if EXTREMES
-   handleExtremes(lp);
+  handleExtremes(lp);
 #endif
 
-   // main presolving loop
-   while(again && m_result == this->OKAY)
-   {
-      nrounds++;
-      MSG_INFO3((*this->spxout), (*this->spxout) << "Round " << nrounds << ":" << std::endl;)
-      again = false;
+  // main presolving loop
+  while (again && m_result == this->OKAY) {
+    nrounds++;
+    MSG_INFO3((*this->spxout), (*this->spxout)
+                                   << "Round " << nrounds << ":" << std::endl;)
+    again = false;
 
 #if ROWS_SPXMAINSM
 
-      if(m_result == this->OKAY)
-         m_result = simplifyRows(lp, again);
+    if (m_result == this->OKAY)
+      m_result = simplifyRows(lp, again);
 
 #endif
 
 #if COLS_SPXMAINSM
 
-      if(m_result == this->OKAY)
-         m_result = simplifyCols(lp, again);
+    if (m_result == this->OKAY)
+      m_result = simplifyCols(lp, again);
 
 #endif
 
 #if DUAL_SPXMAINSM
 
-      if(m_result == this->OKAY)
-         m_result = simplifyDual(lp, again);
+    if (m_result == this->OKAY)
+      m_result = simplifyDual(lp, again);
 
 #endif
 
 #if DUPLICATE_ROWS
 
-      if(m_result == this->OKAY)
-         m_result = duplicateRows(lp, again);
+    if (m_result == this->OKAY)
+      m_result = duplicateRows(lp, again);
 
 #endif
 
 #if DUPLICATE_COLS
 
-      if(m_result == this->OKAY)
-         m_result = duplicateCols(lp, again);
+    if (m_result == this->OKAY)
+      m_result = duplicateCols(lp, again);
 
 #endif
 
-      if(!again)
-      {
+    if (!again) {
 #if TRIVIAL_HEURISTICS
-         trivialHeuristic(lp);
+      trivialHeuristic(lp);
 #endif
 
 #if PSEUDOOBJ
-         propagatePseudoobj(lp);
+      propagatePseudoobj(lp);
 #endif
 
 #if MULTI_AGGREGATE
 
-         if(m_result == this->OKAY)
-            m_result = multiaggregation(lp, again);
+      if (m_result == this->OKAY)
+        m_result = multiaggregation(lp, again);
 
 #endif
-      }
-
-   }
-
-   // preprocessing detected infeasibility or unboundedness
-   if(m_result != this->OKAY)
-   {
-      MSG_INFO1((*this->spxout), (*this->spxout) << "Simplifier result: " << static_cast<int>
-                (m_result) << std::endl;)
-      return m_result;
-   }
-
-   this->m_remCols -= m_addedcols;
-   this->m_remNzos -= m_addedcols;
-   MSG_INFO1((*this->spxout), (*this->spxout) << "Simplifier removed "
-             << this->m_remRows << " rows, "
-             << this->m_remCols << " columns, "
-             << this->m_remNzos << " nonzeros, "
-             << this->m_chgBnds << " col bounds, "
-             << this->m_chgLRhs << " row bounds"
-             << std::endl;)
-
-   if(keepbounds)
-      MSG_INFO2((*this->spxout), (*this->spxout) << "Simplifier kept "
-                << this->m_keptBnds << " column bounds, "
-                << this->m_keptLRhs << " row bounds"
-                << std::endl;)
-
-      MSG_INFO1((*this->spxout), (*this->spxout) << "Reduced LP has "
-                << lp.nRows() << " rows "
-                << lp.nCols() << " columns "
-                << lp.nNzos() << " nonzeros"
-                << std::endl;)
-
-      MSG_INFO2((*this->spxout),
-                int numRangedRows = 0;
-                int numBoxedCols  = 0;
-                int numEqualities = 0;
-
-                for(int i = 0; i < lp.nRows(); ++i)
-   {
-      if(lp.lhs(i) > R(-infinity) && lp.rhs(i) < R(infinity))
-         {
-            if(EQ(lp.lhs(i), lp.rhs(i)))
-               ++numEqualities;
-            else
-               ++numRangedRows;
-         }
-      }
-   for(int j = 0; j < lp.nCols(); ++j)
-   if(lp.lower(j) > R(-infinity) && lp.upper(j) < R(infinity))
-      ++numBoxedCols;
-
-      (*this->spxout) << "Reduced LP has "
-                      << numEqualities << " equations, "
-                      << numRangedRows << " ranged rows, "
-                      << numBoxedCols << " boxed columns"
-                      << std::endl;
-               )
-
-         if(lp.nCols() == 0 && lp.nRows() == 0)
-         {
-            MSG_INFO1((*this->spxout), (*this->spxout) << "Simplifier removed all rows and columns" <<
-                      std::endl;)
-            m_result = this->VANISHED;
-         }
-
-   MSG_INFO2((*this->spxout), (*this->spxout) << "\nSimplifier performed:\n"
-             << m_stat[EMPTY_ROW]            << " empty rows\n"
-             << m_stat[FREE_ROW]             << " free rows\n"
-             << m_stat[SINGLETON_ROW]        << " singleton rows\n"
-             << m_stat[FORCE_ROW]            << " forcing rows\n"
-             << m_stat[EMPTY_COL]            << " empty columns\n"
-             << m_stat[FIX_COL]              << " fixed columns\n"
-             << m_stat[FREE_ZOBJ_COL]        << " free columns with zero objective\n"
-             << m_stat[ZOBJ_SINGLETON_COL]   << " singleton columns with zero objective\n"
-             << m_stat[DOUBLETON_ROW]        << " singleton columns combined with a doubleton equation\n"
-             << m_stat[FREE_SINGLETON_COL]   << " free singleton columns\n"
-             << m_stat[DOMINATED_COL]        << " dominated columns\n"
-             << m_stat[WEAKLY_DOMINATED_COL] << " weakly dominated columns\n"
-             << m_stat[DUPLICATE_ROW]        << " duplicate rows\n"
-             << m_stat[FIX_DUPLICATE_COL]    << " duplicate columns (fixed)\n"
-             << m_stat[SUB_DUPLICATE_COL]    << " duplicate columns (substituted)\n"
-             << m_stat[AGGREGATION]          << " variable aggregations\n"
-             << m_stat[MULTI_AGG]            << " multi aggregations\n"
-             << std::endl;);
-
-   this->m_timeUsed->stop();
-
-   return m_result;
+    }
+  }
+
+  // preprocessing detected infeasibility or unboundedness
+  if (m_result != this->OKAY) {
+    MSG_INFO1((*this->spxout), (*this->spxout)
+                                   << "Simplifier result: "
+                                   << static_cast<int>(m_result) << std::endl;)
+    return m_result;
+  }
+
+  this->m_remCols -= m_addedcols;
+  this->m_remNzos -= m_addedcols;
+  MSG_INFO1((*this->spxout),
+            (*this->spxout)
+                << "Simplifier removed " << this->m_remRows << " rows, "
+                << this->m_remCols << " columns, " << this->m_remNzos
+                << " nonzeros, " << this->m_chgBnds << " col bounds, "
+                << this->m_chgLRhs << " row bounds" << std::endl;)
+
+  if (keepbounds)
+    MSG_INFO2((*this->spxout), (*this->spxout)
+                                   << "Simplifier kept " << this->m_keptBnds
+                                   << " column bounds, " << this->m_keptLRhs
+                                   << " row bounds" << std::endl;)
+
+  MSG_INFO1((*this->spxout), (*this->spxout)
+                                 << "Reduced LP has " << lp.nRows() << " rows "
+                                 << lp.nCols() << " columns " << lp.nNzos()
+                                 << " nonzeros" << std::endl;)
+
+  MSG_INFO2(
+      (*this->spxout), int numRangedRows = 0; int numBoxedCols = 0;
+      int numEqualities = 0;
+
+      for (int i = 0; i < lp.nRows(); ++i) {
+        if (lp.lhs(i) > R(-infinity) && lp.rhs(i) < R(infinity)) {
+          if (EQ(lp.lhs(i), lp.rhs(i)))
+            ++numEqualities;
+          else
+            ++numRangedRows;
+        }
+      } for (int j = 0; j < lp.nCols();
+             ++j) if (lp.lower(j) > R(-infinity) &&
+                      lp.upper(j) < R(infinity))++ numBoxedCols;
+
+      (*this->spxout) << "Reduced LP has " << numEqualities << " equations, "
+                      << numRangedRows << " ranged rows, " << numBoxedCols
+                      << " boxed columns" << std::endl;)
+
+  if (lp.nCols() == 0 && lp.nRows() == 0) {
+    MSG_INFO1((*this->spxout), (*this->spxout)
+                                   << "Simplifier removed all rows and columns"
+                                   << std::endl;)
+    m_result = this->VANISHED;
+  }
+
+  MSG_INFO2((*this->spxout),
+            (*this->spxout)
+                << "\nSimplifier performed:\n"
+                << m_stat[EMPTY_ROW] << " empty rows\n"
+                << m_stat[FREE_ROW] << " free rows\n"
+                << m_stat[SINGLETON_ROW] << " singleton rows\n"
+                << m_stat[FORCE_ROW] << " forcing rows\n"
+                << m_stat[EMPTY_COL] << " empty columns\n"
+                << m_stat[FIX_COL] << " fixed columns\n"
+                << m_stat[FREE_ZOBJ_COL]
+                << " free columns with zero objective\n"
+                << m_stat[ZOBJ_SINGLETON_COL]
+                << " singleton columns with zero objective\n"
+                << m_stat[DOUBLETON_ROW]
+                << " singleton columns combined with a doubleton equation\n"
+                << m_stat[FREE_SINGLETON_COL] << " free singleton columns\n"
+                << m_stat[DOMINATED_COL] << " dominated columns\n"
+                << m_stat[WEAKLY_DOMINATED_COL] << " weakly dominated columns\n"
+                << m_stat[DUPLICATE_ROW] << " duplicate rows\n"
+                << m_stat[FIX_DUPLICATE_COL] << " duplicate columns (fixed)\n"
+                << m_stat[SUB_DUPLICATE_COL]
+                << " duplicate columns (substituted)\n"
+                << m_stat[AGGREGATION] << " variable aggregations\n"
+                << m_stat[MULTI_AGG] << " multi aggregations\n"
+                << std::endl;);
+
+  this->m_timeUsed->stop();
+
+  return m_result;
 }
 
 template <class R>
-void SPxMainSM<R>::unsimplify(const VectorBase<R>& x, const VectorBase<R>& y,
-                              const VectorBase<R>& s, const VectorBase<R>& r,
+void SPxMainSM<R>::unsimplify(const VectorBase<R> &x, const VectorBase<R> &y,
+                              const VectorBase<R> &s, const VectorBase<R> &r,
                               const typename SPxSolverBase<R>::VarStatus rows[],
-                              const typename SPxSolverBase<R>::VarStatus cols[], bool isOptimal)
-{
-   MSG_INFO1((*this->spxout), (*this->spxout) << " --- unsimplifying solution and basis" << std::endl;)
-   assert(x.dim() <= m_prim.dim());
-   assert(y.dim() <= m_dual.dim());
-   assert(x.dim() == r.dim());
-   assert(y.dim() == s.dim());
-
-   // assign values of variables in reduced LP
-   // NOTE: for maximization problems, we have to switch signs of dual and reduced cost values,
-   // since simplifier assumes minimization problem
-   for(int j = 0; j < x.dim(); ++j)
-   {
-      m_prim[j] = isZero(x[j], this->epsZero()) ? 0.0 : x[j];
-      m_redCost[j] = isZero(r[j], this->epsZero()) ? 0.0 : (m_thesense == SPxLPBase<R>::MAXIMIZE ? -r[j] :
-                     r[j]);
-      m_cBasisStat[j] = cols[j];
-   }
-
-   for(int i = 0; i < y.dim(); ++i)
-   {
-      m_dual[i] = isZero(y[i], this->epsZero()) ? 0.0 : (m_thesense == SPxLPBase<R>::MAXIMIZE ? -y[i] :
-                  y[i]);
-      m_slack[i] = isZero(s[i], this->epsZero()) ? 0.0 : s[i];
-      m_rBasisStat[i] = rows[i];
-   }
-
-   // undo preprocessing
-   for(int k = m_hist.size() - 1; k >= 0; --k)
-   {
-      MSG_DEBUG(std::cout << "unsimplifying " << m_hist[k]->getName() << "\n");
-
-      try
-      {
-         m_hist[k]->execute(m_prim, m_dual, m_slack, m_redCost, m_cBasisStat, m_rBasisStat, isOptimal);
-      }
-      catch(const SPxException& ex)
-      {
-         MSG_INFO1((*this->spxout), (*this->spxout) << "Exception thrown while unsimplifying " <<
-                   m_hist[k]->getName() << ":\n" << ex.what() << "\n");
-         throw SPxInternalCodeException("XMAISM00 Exception thrown during unsimply().");
-      }
-
-      m_hist.reSize(k);
-   }
-
-   // for maximization problems, we have to switch signs of dual and reduced cost values back
-   if(m_thesense == SPxLPBase<R>::MAXIMIZE)
-   {
-      for(int j = 0; j < m_redCost.dim(); ++j)
-         m_redCost[j] = -m_redCost[j];
-
-      for(int i = 0; i < m_dual.dim(); ++i)
-         m_dual[i] = -m_dual[i];
-   }
-
-   if(m_addedcols > 0)
-   {
-      assert(m_prim.dim() >= m_addedcols);
-      m_prim.reDim(m_prim.dim() - m_addedcols);
-      m_redCost.reDim(m_redCost.dim() - m_addedcols);
-      m_cBasisStat.reSize(m_cBasisStat.size() - m_addedcols);
-      m_cIdx.reSize(m_cIdx.size() - m_addedcols);
-   }
+                              const typename SPxSolverBase<R>::VarStatus cols[],
+                              bool isOptimal) {
+  MSG_INFO1((*this->spxout), (*this->spxout)
+                                 << " --- unsimplifying solution and basis"
+                                 << std::endl;)
+  assert(x.dim() <= m_prim.dim());
+  assert(y.dim() <= m_dual.dim());
+  assert(x.dim() == r.dim());
+  assert(y.dim() == s.dim());
+
+  // assign values of variables in reduced LP
+  // NOTE: for maximization problems, we have to switch signs of dual and
+  // reduced cost values, since simplifier assumes minimization problem
+  for (int j = 0; j < x.dim(); ++j) {
+    m_prim[j] = isZero(x[j], this->epsZero()) ? 0.0 : x[j];
+    m_redCost[j] = isZero(r[j], this->epsZero())
+                       ? 0.0
+                       : (m_thesense == SPxLPBase<R>::MAXIMIZE ? -r[j] : r[j]);
+    m_cBasisStat[j] = cols[j];
+  }
+
+  for (int i = 0; i < y.dim(); ++i) {
+    m_dual[i] = isZero(y[i], this->epsZero())
+                    ? 0.0
+                    : (m_thesense == SPxLPBase<R>::MAXIMIZE ? -y[i] : y[i]);
+    m_slack[i] = isZero(s[i], this->epsZero()) ? 0.0 : s[i];
+    m_rBasisStat[i] = rows[i];
+  }
+
+  // undo preprocessing
+  for (int k = m_hist.size() - 1; k >= 0; --k) {
+    MSG_DEBUG(std::cout << "unsimplifying " << m_hist[k]->getName() << "\n");
+
+    try {
+      m_hist[k]->execute(m_prim, m_dual, m_slack, m_redCost, m_cBasisStat,
+                         m_rBasisStat, isOptimal);
+    } catch (const SPxException &ex) {
+      MSG_INFO1((*this->spxout), (*this->spxout)
+                                     << "Exception thrown while unsimplifying "
+                                     << m_hist[k]->getName() << ":\n"
+                                     << ex.what() << "\n");
+      throw SPxInternalCodeException(
+          "XMAISM00 Exception thrown during unsimply().");
+    }
+
+    m_hist.reSize(k);
+  }
+
+  // for maximization problems, we have to switch signs of dual and reduced cost
+  // values back
+  if (m_thesense == SPxLPBase<R>::MAXIMIZE) {
+    for (int j = 0; j < m_redCost.dim(); ++j)
+      m_redCost[j] = -m_redCost[j];
+
+    for (int i = 0; i < m_dual.dim(); ++i)
+      m_dual[i] = -m_dual[i];
+  }
+
+  if (m_addedcols > 0) {
+    assert(m_prim.dim() >= m_addedcols);
+    m_prim.reDim(m_prim.dim() - m_addedcols);
+    m_redCost.reDim(m_redCost.dim() - m_addedcols);
+    m_cBasisStat.reSize(m_cBasisStat.size() - m_addedcols);
+    m_cIdx.reSize(m_cIdx.size() - m_addedcols);
+  }
 
 #ifdef CHECK_BASIC_DIM
-   int numBasis = 0;
+  int numBasis = 0;
 
-   for(int rs = 0; rs < m_rBasisStat.size(); ++rs)
-   {
-      if(m_rBasisStat[rs] == SPxSolverBase<R>::BASIC)
-         numBasis ++;
-   }
+  for (int rs = 0; rs < m_rBasisStat.size(); ++rs) {
+    if (m_rBasisStat[rs] == SPxSolverBase<R>::BASIC)
+      numBasis++;
+  }
 
-   for(int cs = 0; cs < m_cBasisStat.size(); ++cs)
-   {
-      if(m_cBasisStat[cs] == SPxSolverBase<R>::BASIC)
-         numBasis ++;
-   }
+  for (int cs = 0; cs < m_cBasisStat.size(); ++cs) {
+    if (m_cBasisStat[cs] == SPxSolverBase<R>::BASIC)
+      numBasis++;
+  }
 
-   if(numBasis != m_rBasisStat.size())
-   {
-      throw SPxInternalCodeException("XMAISM26 Dimension doesn't match after this step.");
-   }
+  if (numBasis != m_rBasisStat.size()) {
+    throw SPxInternalCodeException(
+        "XMAISM26 Dimension doesn't match after this step.");
+  }
 
 #endif
 
-   m_hist.clear();
-   m_postsolved = true;
+  m_hist.clear();
+  m_postsolved = true;
 }
 
 // Pretty-printing of solver status.
 template <class R>
-std::ostream& operator<<(std::ostream& os, const typename SPxSimplifier<R>::Result& status)
-{
-   switch(status)
-   {
-   case SPxSimplifier<R>::OKAY:
-      os << "SUCCESS";
-      break;
-
-   case SPxSimplifier<R>::INFEASIBLE:
-      os << "INFEASIBLE";
-      break;
-
-   case SPxSimplifier<R>::DUAL_INFEASIBLE:
-      os << "DUAL_INFEASIBLE";
-      break;
-
-   case SPxSimplifier<R>::UNBOUNDED:
-      os << "UNBOUNDED";
-      break;
-
-   case SPxSimplifier<R>::VANISHED:
-      os << "VANISHED";
-      break;
-
-   default:
-      os << "UNKNOWN";
-      break;
-   }
-
-   return os;
+std::ostream &operator<<(std::ostream &os,
+                         const typename SPxSimplifier<R>::Result &status) {
+  switch (status) {
+  case SPxSimplifier<R>::OKAY:
+    os << "SUCCESS";
+    break;
+
+  case SPxSimplifier<R>::INFEASIBLE:
+    os << "INFEASIBLE";
+    break;
+
+  case SPxSimplifier<R>::DUAL_INFEASIBLE:
+    os << "DUAL_INFEASIBLE";
+    break;
+
+  case SPxSimplifier<R>::UNBOUNDED:
+    os << "UNBOUNDED";
+    break;
+
+  case SPxSimplifier<R>::VANISHED:
+    os << "VANISHED";
+    break;
+
+  default:
+    os << "UNKNOWN";
+    break;
+  }
+
+  return os;
 }
 
-} //namespace soplex
+} // namespace soplex
diff --git a/src/soplex/spxparmultpr.hpp b/src/soplex/spxparmultpr.hpp
index e42f5cf..c1f87c5 100644
--- a/src/soplex/spxparmultpr.hpp
+++ b/src/soplex/spxparmultpr.hpp
@@ -21,209 +21,177 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <assert.h>
 #include <iostream>
 
 #include "soplex/spxdefines.h"
 
-namespace soplex
-{
+namespace soplex {
 
 template <class R>
-void SPxParMultPR<R>::setType(typename SPxSolverBase<R>::Type tp)
-{
-   if(tp == SPxSolverBase<R>::ENTER)
-   {
-      used = 0;
-      this->thesolver->setPricing(SPxSolverBase<R>::PARTIAL);
-   }
-   else
-   {
-      this->thesolver->setPricing(SPxSolverBase<R>::FULL);
-   }
-
-   this->thesolver->weights.reDim(0);
-   this->thesolver->coWeights.reDim(0);
-   this->thesolver->weightsAreSetup = false;
-
-   last = 0;
-   min = partialSize / 2;
+void SPxParMultPR<R>::setType(typename SPxSolverBase<R>::Type tp) {
+  if (tp == SPxSolverBase<R>::ENTER) {
+    used = 0;
+    this->thesolver->setPricing(SPxSolverBase<R>::PARTIAL);
+  } else {
+    this->thesolver->setPricing(SPxSolverBase<R>::FULL);
+  }
+
+  this->thesolver->weights.reDim(0);
+  this->thesolver->coWeights.reDim(0);
+  this->thesolver->weightsAreSetup = false;
+
+  last = 0;
+  min = partialSize / 2;
 }
 
-template <class R>
-void SPxParMultPR<R>::load(SPxSolverBase<R>* p_solver)
-{
-   this->thesolver = p_solver;
-   multiParts = (this->thesolver->dim() + this->thesolver->coDim()) / partialSize + 1;
-   pricSet.reSize(10 * partialSize);
+template <class R> void SPxParMultPR<R>::load(SPxSolverBase<R> *p_solver) {
+  this->thesolver = p_solver;
+  multiParts =
+      (this->thesolver->dim() + this->thesolver->coDim()) / partialSize + 1;
+  pricSet.reSize(10 * partialSize);
 }
 
-template <class R>
-SPxId SPxParMultPR<R>::selectEnter()
-{
-   SPxId id;
-   R x;
-   int i;
-   int best = -1;
-   //    const SPxBasisBase<R>::Desc& ds   = this->thesolver->basis().desc();
-
-   assert(this->thesolver != 0);
-   int lastlast = -1;
-
-   if(this->thesolver->pricing() == SPxSolverBase<R>::PARTIAL)
-   {
-      R val;
-      R eps = -this->theeps;
-      lastlast = last;
-
-      for(i = used - 1; i >= 0; --i)
-      {
-         int n = this->thesolver->number(pricSet[i].id);
-
-         if(this->thesolver->isId(pricSet[i].id))
-         {
-            this->thesolver->computePvec(n);
-            pricSet[i].test = val = this->thesolver->computeTest(n);
-         }
-         else
-            pricSet[i].test = val = this->thesolver->coTest()[n];
-
-         if(val >= eps)
-            pricSet[i] = pricSet[--used];
+template <class R> SPxId SPxParMultPR<R>::selectEnter() {
+  SPxId id;
+  R x;
+  int i;
+  int best = -1;
+  //    const SPxBasisBase<R>::Desc& ds   = this->thesolver->basis().desc();
+
+  assert(this->thesolver != 0);
+  int lastlast = -1;
+
+  if (this->thesolver->pricing() == SPxSolverBase<R>::PARTIAL) {
+    R val;
+    R eps = -this->theeps;
+    lastlast = last;
+
+    for (i = used - 1; i >= 0; --i) {
+      int n = this->thesolver->number(pricSet[i].id);
+
+      if (this->thesolver->isId(pricSet[i].id)) {
+        this->thesolver->computePvec(n);
+        pricSet[i].test = val = this->thesolver->computeTest(n);
+      } else
+        pricSet[i].test = val = this->thesolver->coTest()[n];
+
+      if (val >= eps)
+        pricSet[i] = pricSet[--used];
+    }
+
+    while (pricSet.size() - used < partialSize) {
+      best = 0;
+
+      for (i = 1; i < used; ++i) {
+        if (pricSet[i].test > pricSet[best].test)
+          best = i;
       }
 
-      while(pricSet.size() - used < partialSize)
-      {
-         best = 0;
+      pricSet[best] = pricSet[--used];
+    }
 
-         for(i = 1; i < used; ++i)
-         {
-            if(pricSet[i].test > pricSet[best].test)
-               best = i;
-         }
+    do {
+      last = (last + 1) % multiParts;
 
-         pricSet[best] = pricSet[--used];
+      for (i = this->thesolver->coDim() - last - 1; i >= 0; i -= multiParts) {
+        this->thesolver->computePvec(i);
+        x = this->thesolver->computeTest(i);
+
+        if (x < eps) {
+          pricSet[used].id = this->thesolver->id(i);
+          pricSet[used].test = x;
+          used++;
+        }
       }
 
-      do
-      {
-         last = (last + 1) % multiParts;
-
-         for(i = this->thesolver->coDim() - last - 1;
-               i >= 0; i -= multiParts)
-         {
-            this->thesolver->computePvec(i);
-            x = this->thesolver->computeTest(i);
-
-            if(x < eps)
-            {
-               pricSet[used].id = this->thesolver->id(i);
-               pricSet[used].test = x;
-               used++;
-            }
-         }
-
-         for(i = this->thesolver->dim() - last - 1;
-               i >= 0; i -= multiParts)
-         {
-            x = this->thesolver->coTest()[i];
-
-            if(x < eps)
-            {
-               pricSet[used].id = this->thesolver->coId(i);
-               pricSet[used].test = x;
-               used++;
-            }
-         }
-
-         assert(used < pricSet.size());
+      for (i = this->thesolver->dim() - last - 1; i >= 0; i -= multiParts) {
+        x = this->thesolver->coTest()[i];
+
+        if (x < eps) {
+          pricSet[used].id = this->thesolver->coId(i);
+          pricSet[used].test = x;
+          used++;
+        }
       }
-      while(used < min && last != lastlast);
 
-      if(used > 0)
-      {
-         min = (used + 1);
+      assert(used < pricSet.size());
+    } while (used < min && last != lastlast);
 
-         if(min < 1)
-            min = 1;
+    if (used > 0) {
+      min = (used + 1);
 
-         if(min > partialSize)
-            min = partialSize;
+      if (min < 1)
+        min = 1;
 
-         best = 0;
+      if (min > partialSize)
+        min = partialSize;
 
-         for(i = 1; i < used; ++i)
-         {
-            if(pricSet[i].test < pricSet[best].test)
-               best = i;
-         }
+      best = 0;
 
-         id = pricSet[best].id;
+      for (i = 1; i < used; ++i) {
+        if (pricSet[i].test < pricSet[best].test)
+          best = i;
       }
 
-      return id;
-   }
-
-   else
-   {
-      assert(this->thesolver->pricing() == SPxSolverBase<R>::FULL);
-      R bestx = -this->theeps;
-
-      for(i = this->thesolver->dim() - 1; i >= 0; --i)
-      {
-         x = this->thesolver->coTest()[i];
-
-         // x *= EQ_PREF * (1 + (ds.coStatus(i) == SPxBasisBase<R>::Desc::P_FREE
-         //                || ds.coStatus(i) == SPxBasisBase<R>::Desc::D_FREE));
-         if(x < bestx)
-         {
-            id = this->thesolver->coId(i);
-            bestx = this->thesolver->coTest()[i];
-         }
+      id = pricSet[best].id;
+    }
+
+    return id;
+  }
+
+  else {
+    assert(this->thesolver->pricing() == SPxSolverBase<R>::FULL);
+    R bestx = -this->theeps;
+
+    for (i = this->thesolver->dim() - 1; i >= 0; --i) {
+      x = this->thesolver->coTest()[i];
+
+      // x *= EQ_PREF * (1 + (ds.coStatus(i) == SPxBasisBase<R>::Desc::P_FREE
+      //                || ds.coStatus(i) == SPxBasisBase<R>::Desc::D_FREE));
+      if (x < bestx) {
+        id = this->thesolver->coId(i);
+        bestx = this->thesolver->coTest()[i];
       }
+    }
+
+    for (i = this->thesolver->coDim() - 1; i >= 0; --i) {
+      x = this->thesolver->test()[i];
 
-      for(i = this->thesolver->coDim() - 1; i >= 0; --i)
-      {
-         x = this->thesolver->test()[i];
-
-         // x *= EQ_PREF * (1 + (ds.status(i) == SPxBasisBase<R>::Desc::P_FREE
-         //                || ds.status(i) == SPxBasisBase<R>::Desc::D_FREE));
-         if(x < bestx)
-         {
-            id = this->thesolver->id(i);
-            bestx = this->thesolver->test()[i];
-         }
+      // x *= EQ_PREF * (1 + (ds.status(i) == SPxBasisBase<R>::Desc::P_FREE
+      //                || ds.status(i) == SPxBasisBase<R>::Desc::D_FREE));
+      if (x < bestx) {
+        id = this->thesolver->id(i);
+        bestx = this->thesolver->test()[i];
       }
+    }
 
-      return id;
-   }
+    return id;
+  }
 }
 
-template <class R>
-int SPxParMultPR<R>::selectLeave()
-{
-   int i, n;
-   R x;
-   R best = -this->theeps;
-   //    const R* up  = this->thesolver->ubBound();
-   //    const R* low = this->thesolver->lbBound();
-
-   assert(this->thesolver != 0);
-   n = -1;
-
-   for(i = this->thesolver->dim() - 1; i >= 0; --i)
-   {
-      x = this->thesolver->fTest()[i];
-
-      // x *= EQ_PREF * (1 + (up[i] == low[i]));
-      if(x < best)
-      {
-         n = i;
-         best = this->thesolver->fTest()[i];
-      }
-   }
+template <class R> int SPxParMultPR<R>::selectLeave() {
+  int i, n;
+  R x;
+  R best = -this->theeps;
+  //    const R* up  = this->thesolver->ubBound();
+  //    const R* low = this->thesolver->lbBound();
+
+  assert(this->thesolver != 0);
+  n = -1;
+
+  for (i = this->thesolver->dim() - 1; i >= 0; --i) {
+    x = this->thesolver->fTest()[i];
+
+    // x *= EQ_PREF * (1 + (up[i] == low[i]));
+    if (x < best) {
+      n = i;
+      best = this->thesolver->fTest()[i];
+    }
+  }
 
-   return n;
+  return n;
 }
 } // namespace soplex
diff --git a/src/soplex/spxquality.hpp b/src/soplex/spxquality.hpp
index aaef7e9..f007577 100644
--- a/src/soplex/spxquality.hpp
+++ b/src/soplex/spxquality.hpp
@@ -21,6 +21,7 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <assert.h>
 #include <iostream>
@@ -28,164 +29,146 @@
 #include "soplex/spxdefines.h"
 #include "soplex/spxsolver.h"
 
-namespace soplex
-{
+namespace soplex {
 
 template <class R>
-void SPxSolverBase<R>::qualConstraintViolation(R& maxviol, R& sumviol) const
-{
-   maxviol = 0.0;
-   sumviol = 0.0;
+void SPxSolverBase<R>::qualConstraintViolation(R &maxviol, R &sumviol) const {
+  maxviol = 0.0;
+  sumviol = 0.0;
 
-   VectorBase<R> solu(this->nCols());
+  VectorBase<R> solu(this->nCols());
 
-   getPrimalSol(solu);
+  getPrimalSol(solu);
 
-   for(int row = 0; row < this->nRows(); ++row)
-   {
-      const SVectorBase<R>& rowvec = this->rowVector(row);
+  for (int row = 0; row < this->nRows(); ++row) {
+    const SVectorBase<R> &rowvec = this->rowVector(row);
 
-      R val = 0.0;
+    R val = 0.0;
 
-      for(int col = 0; col < rowvec.size(); ++col)
-         val += rowvec.value(col) * solu[rowvec.index(col)];
+    for (int col = 0; col < rowvec.size(); ++col)
+      val += rowvec.value(col) * solu[rowvec.index(col)];
 
-      R viol = 0.0;
+    R viol = 0.0;
 
-      assert(this->lhs(row) <= this->rhs(row) + 1e-9);
+    assert(this->lhs(row) <= this->rhs(row) + 1e-9);
 
-      if(val < this->lhs(row))
-         viol = spxAbs(val - this->lhs(row));
-      else if(val > this->rhs(row))
-         viol = spxAbs(val - this->rhs(row));
+    if (val < this->lhs(row))
+      viol = spxAbs(val - this->lhs(row));
+    else if (val > this->rhs(row))
+      viol = spxAbs(val - this->rhs(row));
 
-      if(viol > maxviol)
-         maxviol = viol;
+    if (viol > maxviol)
+      maxviol = viol;
 
-      sumviol += viol;
-   }
+    sumviol += viol;
+  }
 }
 
 template <class R>
-void SPxSolverBase<R>::qualBoundViolation(
-   R& maxviol, R& sumviol) const
-{
-   maxviol = 0.0;
-   sumviol = 0.0;
+void SPxSolverBase<R>::qualBoundViolation(R &maxviol, R &sumviol) const {
+  maxviol = 0.0;
+  sumviol = 0.0;
 
-   VectorBase<R> solu(this->nCols());
+  VectorBase<R> solu(this->nCols());
 
-   getPrimalSol(solu);
+  getPrimalSol(solu);
 
-   for(int col = 0; col < this->nCols(); ++col)
-   {
-      assert(this->lower(col) <= this->upper(col) + 1e-9);
+  for (int col = 0; col < this->nCols(); ++col) {
+    assert(this->lower(col) <= this->upper(col) + 1e-9);
 
-      R viol = 0.0;
+    R viol = 0.0;
 
-      if(solu[col] < this->lower(col))
-         viol = spxAbs(solu[col] - this->lower(col));
-      else if(solu[col] > this->upper(col))
-         viol = spxAbs(solu[col] - this->upper(col));
+    if (solu[col] < this->lower(col))
+      viol = spxAbs(solu[col] - this->lower(col));
+    else if (solu[col] > this->upper(col))
+      viol = spxAbs(solu[col] - this->upper(col));
 
-      if(viol > maxviol)
-         maxviol = viol;
+    if (viol > maxviol)
+      maxviol = viol;
 
-      sumviol += viol;
-   }
+    sumviol += viol;
+  }
 }
 
 template <class R>
-void SPxSolverBase<R>::qualSlackViolation(R& maxviol, R& sumviol) const
-{
-   maxviol = 0.0;
-   sumviol = 0.0;
+void SPxSolverBase<R>::qualSlackViolation(R &maxviol, R &sumviol) const {
+  maxviol = 0.0;
+  sumviol = 0.0;
 
-   VectorBase<R> solu(this->nCols());
-   VectorBase<R> slacks(this->nRows());
+  VectorBase<R> solu(this->nCols());
+  VectorBase<R> slacks(this->nRows());
 
-   getPrimalSol(solu);
-   getSlacks(slacks);
+  getPrimalSol(solu);
+  getSlacks(slacks);
 
-   for(int row = 0; row < this->nRows(); ++row)
-   {
-      const SVectorBase<R>& rowvec = this->rowVector(row);
+  for (int row = 0; row < this->nRows(); ++row) {
+    const SVectorBase<R> &rowvec = this->rowVector(row);
 
-      R val = 0.0;
+    R val = 0.0;
 
-      for(int col = 0; col < rowvec.size(); ++col)
-         val += rowvec.value(col) * solu[rowvec.index(col)];
+    for (int col = 0; col < rowvec.size(); ++col)
+      val += rowvec.value(col) * solu[rowvec.index(col)];
 
-      R viol = spxAbs(val - slacks[row]);
+    R viol = spxAbs(val - slacks[row]);
 
-      if(viol > maxviol)
-         maxviol = viol;
+    if (viol > maxviol)
+      maxviol = viol;
 
-      sumviol += viol;
-   }
+    sumviol += viol;
+  }
 }
 
 template <class R>
-void SPxSolverBase<R>::qualRedCostViolation(R& maxviol, R& sumviol) const
-{
-   maxviol = 0.0;
-   sumviol = 0.0;
-
-   int i;
-
-   // TODO:   y = c_B * B^-1  => coSolve(y, c_B)
-   //         redcost = c_N - yA_N
-   // solve system "x = e_i^T * B^-1" to get i'th row of B^-1
-   // VectorBase<R> y( this->nRows() );
-   // basis().coSolve( x, spx->unitVector( i ) );
-   // VectorBase<R> rdcost( this->nCols() );
-   if(type() == ENTER)
-   {
-      for(i = 0; i < dim(); ++i)
-      {
-         R x = coTest()[i];
-
-         if(x < 0.0)
-         {
-            sumviol -= x;
-
-            if(x < maxviol)
-               maxviol = x;
-         }
+void SPxSolverBase<R>::qualRedCostViolation(R &maxviol, R &sumviol) const {
+  maxviol = 0.0;
+  sumviol = 0.0;
+
+  int i;
+
+  // TODO:   y = c_B * B^-1  => coSolve(y, c_B)
+  //         redcost = c_N - yA_N
+  // solve system "x = e_i^T * B^-1" to get i'th row of B^-1
+  // VectorBase<R> y( this->nRows() );
+  // basis().coSolve( x, spx->unitVector( i ) );
+  // VectorBase<R> rdcost( this->nCols() );
+  if (type() == ENTER) {
+    for (i = 0; i < dim(); ++i) {
+      R x = coTest()[i];
+
+      if (x < 0.0) {
+        sumviol -= x;
+
+        if (x < maxviol)
+          maxviol = x;
       }
+    }
 
-      for(i = 0; i < coDim(); ++i)
-      {
-         R x = test()[i];
+    for (i = 0; i < coDim(); ++i) {
+      R x = test()[i];
 
-         if(x < 0.0)
-         {
-            sumviol -= x;
+      if (x < 0.0) {
+        sumviol -= x;
 
-            if(x < maxviol)
-               maxviol = x;
-         }
+        if (x < maxviol)
+          maxviol = x;
       }
-   }
-   else
-   {
-      assert(type() == LEAVE);
-
-      for(i = 0; i < dim(); ++i)
-      {
-         R x = fTest()[i];
-
-         if(x < 0.0)
-         {
-            sumviol -= x;
-
-            if(x < maxviol)
-               maxviol = x;
-         }
+    }
+  } else {
+    assert(type() == LEAVE);
+
+    for (i = 0; i < dim(); ++i) {
+      R x = fTest()[i];
+
+      if (x < 0.0) {
+        sumviol -= x;
+
+        if (x < maxviol)
+          maxviol = x;
       }
-   }
+    }
+  }
 
-   maxviol *= -1;
+  maxviol *= -1;
 }
 
 } // namespace soplex
diff --git a/src/soplex/spxscaler.hpp b/src/soplex/spxscaler.hpp
index c8d22ec..a8d3006 100644
--- a/src/soplex/spxscaler.hpp
+++ b/src/soplex/spxscaler.hpp
@@ -21,6 +21,7 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 /**@file  spxscaler.hpp
  * @brief LP scaling base class.
@@ -28,955 +29,842 @@
 
 #include <cmath>
 
-#include <iostream>
-#include <assert.h>
 #include "soplex/dsvector.h"
-#include "soplex/lprowsetbase.h"
 #include "soplex/lpcolsetbase.h"
+#include "soplex/lprowsetbase.h"
+#include <assert.h>
+#include <iostream>
 #include <limits>
 
-namespace soplex
-{
+namespace soplex {
 
 template <class R>
-std::ostream& operator<<(std::ostream& s, const SPxScaler<R>& sc)
-{
-   const DataArray < int >& colscaleExp = *(sc.m_activeColscaleExp);
-   DataArray < int > rowccaleExp = *(sc.m_activeRowscaleExp);
+std::ostream &operator<<(std::ostream &s, const SPxScaler<R> &sc) {
+  const DataArray<int> &colscaleExp = *(sc.m_activeColscaleExp);
+  DataArray<int> rowccaleExp = *(sc.m_activeRowscaleExp);
 
-   s << sc.getName() << " scaler:" << std::endl;
-   s << "colscale = [ ";
+  s << sc.getName() << " scaler:" << std::endl;
+  s << "colscale = [ ";
 
-   for(int ci = 0; ci < colscaleExp.size(); ++ci)
-      s << colscaleExp[ci] << " ";
+  for (int ci = 0; ci < colscaleExp.size(); ++ci)
+    s << colscaleExp[ci] << " ";
 
-   s << "]" << std::endl;
+  s << "]" << std::endl;
 
-   s << "rowscale = [ ";
+  s << "rowscale = [ ";
 
-   for(int ri = 0; ri < rowccaleExp.size(); ++ri)
-      s << rowccaleExp[ri] << " ";
+  for (int ri = 0; ri < rowccaleExp.size(); ++ri)
+    s << rowccaleExp[ri] << " ";
 
-   s << "]" << std::endl;
+  s << "]" << std::endl;
 
-   return s;
+  return s;
 }
 
-
 template <class R>
-SPxScaler<R>::SPxScaler(
-   const char* name,
-   bool        colFirst,
-   bool        doBoth,
-   SPxOut*     outstream)
-   : m_name(name)
-   , m_activeColscaleExp(0)
-   , m_activeRowscaleExp(0)
-   , m_colFirst(colFirst)
-   , m_doBoth(doBoth)
-   , spxout(outstream)
-{
-   assert(SPxScaler<R>::isConsistent());
+SPxScaler<R>::SPxScaler(const char *name, bool colFirst, bool doBoth,
+                        SPxOut *outstream)
+    : m_name(name), m_activeColscaleExp(0), m_activeRowscaleExp(0),
+      m_colFirst(colFirst), m_doBoth(doBoth), spxout(outstream) {
+  assert(SPxScaler<R>::isConsistent());
 }
 
 template <class R>
-SPxScaler<R>::SPxScaler(const SPxScaler<R>& old)
-   : m_name(old.m_name)
-   , m_activeColscaleExp(old.m_activeColscaleExp)
-   , m_activeRowscaleExp(old.m_activeRowscaleExp)
-   , m_colFirst(old.m_colFirst)
-   , m_doBoth(old.m_doBoth)
-   , spxout(old.spxout)
-{
-   assert(SPxScaler<R>::isConsistent());
+SPxScaler<R>::SPxScaler(const SPxScaler<R> &old)
+    : m_name(old.m_name), m_activeColscaleExp(old.m_activeColscaleExp),
+      m_activeRowscaleExp(old.m_activeRowscaleExp), m_colFirst(old.m_colFirst),
+      m_doBoth(old.m_doBoth), spxout(old.spxout) {
+  assert(SPxScaler<R>::isConsistent());
 }
 
-template <class R>
-SPxScaler<R>::~SPxScaler()
-{
-   m_name = 0;
-}
+template <class R> SPxScaler<R>::~SPxScaler() { m_name = 0; }
 
 template <class R>
-SPxScaler<R>& SPxScaler<R>::operator=(const SPxScaler<R>& rhs)
-{
-   if(this != &rhs)
-   {
-      m_name     = rhs.m_name;
-      m_activeColscaleExp = rhs.m_activeColscaleExp;
-      m_activeRowscaleExp = rhs.m_activeRowscaleExp;
-      m_colFirst = rhs.m_colFirst;
-      m_doBoth   = rhs.m_doBoth;
-      spxout     = rhs.spxout;
+SPxScaler<R> &SPxScaler<R>::operator=(const SPxScaler<R> &rhs) {
+  if (this != &rhs) {
+    m_name = rhs.m_name;
+    m_activeColscaleExp = rhs.m_activeColscaleExp;
+    m_activeRowscaleExp = rhs.m_activeRowscaleExp;
+    m_colFirst = rhs.m_colFirst;
+    m_doBoth = rhs.m_doBoth;
+    spxout = rhs.spxout;
 
-      assert(SPxScaler<R>::isConsistent());
-   }
+    assert(SPxScaler<R>::isConsistent());
+  }
 
-   return *this;
+  return *this;
 }
 
-template <class R>
-const char* SPxScaler<R>::getName() const
-{
-
-   return m_name;
-}
+template <class R> const char *SPxScaler<R>::getName() const { return m_name; }
 
-template <class R>
-void SPxScaler<R>::setOrder(bool colFirst)
-{
+template <class R> void SPxScaler<R>::setOrder(bool colFirst) {
 
-   m_colFirst = colFirst;
+  m_colFirst = colFirst;
 }
 
-template <class R>
-void SPxScaler<R>::setBoth(bool both)
-{
-
-   m_doBoth = both;
-}
+template <class R> void SPxScaler<R>::setBoth(bool both) { m_doBoth = both; }
 
-template <class R>
-void SPxScaler<R>::setRealParam(R param, const char* name)
-{}
+template <class R> void SPxScaler<R>::setRealParam(R param, const char *name) {}
 
 template <class R>
-void SPxScaler<R>::setIntParam(int param, const char* name)
-{}
+void SPxScaler<R>::setIntParam(int param, const char *name) {}
 
-template <class R>
-void SPxScaler<R>::setup(SPxLPBase<R>& lp)
-{
-   assert(lp.isConsistent());
-   m_activeColscaleExp = &lp.LPColSetBase<R>::scaleExp;
-   m_activeRowscaleExp = &lp.LPRowSetBase<R>::scaleExp;
-   m_activeColscaleExp->reSize(lp.nCols());
-   m_activeRowscaleExp->reSize(lp.nRows());
+template <class R> void SPxScaler<R>::setup(SPxLPBase<R> &lp) {
+  assert(lp.isConsistent());
+  m_activeColscaleExp = &lp.LPColSetBase<R>::scaleExp;
+  m_activeRowscaleExp = &lp.LPRowSetBase<R>::scaleExp;
+  m_activeColscaleExp->reSize(lp.nCols());
+  m_activeRowscaleExp->reSize(lp.nRows());
 
-   for(int i = 0; i < lp.nCols(); ++i)
-      (*m_activeColscaleExp)[i] = 0;
+  for (int i = 0; i < lp.nCols(); ++i)
+    (*m_activeColscaleExp)[i] = 0;
 
-   for(int i = 0; i < lp.nRows(); ++i)
-      (*m_activeRowscaleExp)[i] = 0;
+  for (int i = 0; i < lp.nRows(); ++i)
+    (*m_activeRowscaleExp)[i] = 0;
 
-   lp.lp_scaler = this;
+  lp.lp_scaler = this;
 }
 
-
 template <class R>
-int SPxScaler<R>::computeScaleExp(const SVectorBase<R>& vec,
-                                  const DataArray<int>& oldScaleExp) const
-{
-   R maxi = 0.0;
+int SPxScaler<R>::computeScaleExp(const SVectorBase<R> &vec,
+                                  const DataArray<int> &oldScaleExp) const {
+  R maxi = 0.0;
 
-   // find largest absolute value after applying existing scaling factors
-   for(int i = 0; i < vec.size(); ++i)
-   {
-      R x = spxAbs(spxLdexp(vec.value(i), oldScaleExp[vec.index(i)]));
+  // find largest absolute value after applying existing scaling factors
+  for (int i = 0; i < vec.size(); ++i) {
+    R x = spxAbs(spxLdexp(vec.value(i), oldScaleExp[vec.index(i)]));
 
-      if(GT(x, maxi))
-         maxi = x;
-   }
+    if (GT(x, maxi))
+      maxi = x;
+  }
 
-   // empty rows/cols are possible
-   if(maxi == 0.0)
-      return 0;
-   // get exponent corresponding to new scaling factor
-   else
-   {
-      int scaleExp;
-      spxFrexp(R(1.0 / maxi), &(scaleExp));
-      return scaleExp - 1;
-   }
+  // empty rows/cols are possible
+  if (maxi == 0.0)
+    return 0;
+  // get exponent corresponding to new scaling factor
+  else {
+    int scaleExp;
+    spxFrexp(R(1.0 / maxi), &(scaleExp));
+    return scaleExp - 1;
+  }
 }
 
-template <class R>
-void SPxScaler<R>::applyScaling(SPxLPBase<R>& lp)
-{
-   assert(lp.nCols() == m_activeColscaleExp->size());
-   assert(lp.nRows() == m_activeRowscaleExp->size());
+template <class R> void SPxScaler<R>::applyScaling(SPxLPBase<R> &lp) {
+  assert(lp.nCols() == m_activeColscaleExp->size());
+  assert(lp.nRows() == m_activeRowscaleExp->size());
 
-   DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
-   DataArray < int >& rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
+  DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
+  DataArray<int> &rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
 
-   for(int i = 0; i < lp.nRows(); ++i)
-   {
-      SVectorBase<R>& vec = lp.rowVector_w(i);
-      int exp1;
-      int exp2 = rowscaleExp[i];
+  for (int i = 0; i < lp.nRows(); ++i) {
+    SVectorBase<R> &vec = lp.rowVector_w(i);
+    int exp1;
+    int exp2 = rowscaleExp[i];
 
-      for(int j = 0; j < vec.size(); ++j)
-      {
-         exp1 = colscaleExp[vec.index(j)];
-         vec.value(j) = spxLdexp(vec.value(j), exp1 + exp2);
-      }
+    for (int j = 0; j < vec.size(); ++j) {
+      exp1 = colscaleExp[vec.index(j)];
+      vec.value(j) = spxLdexp(vec.value(j), exp1 + exp2);
+    }
 
-      lp.maxRowObj_w(i) = spxLdexp(lp.maxRowObj(i), exp2);
+    lp.maxRowObj_w(i) = spxLdexp(lp.maxRowObj(i), exp2);
 
-      if(lp.rhs(i) < R(infinity))
-         lp.rhs_w(i) = spxLdexp(lp.rhs_w(i), exp2);
+    if (lp.rhs(i) < R(infinity))
+      lp.rhs_w(i) = spxLdexp(lp.rhs_w(i), exp2);
 
-      if(lp.lhs(i) > R(-infinity))
-         lp.lhs_w(i) = spxLdexp(lp.lhs_w(i), exp2);
+    if (lp.lhs(i) > R(-infinity))
+      lp.lhs_w(i) = spxLdexp(lp.lhs_w(i), exp2);
 
-      MSG_DEBUG(std::cout << "DEBUG: rowscaleExp(" << i << "): " << exp2 << std::endl;)
-   }
+    MSG_DEBUG(std::cout << "DEBUG: rowscaleExp(" << i << "): " << exp2
+                        << std::endl;)
+  }
 
-   for(int i = 0; i < lp.nCols(); ++i)
-   {
-      SVectorBase<R>& vec = lp.colVector_w(i);
-      int exp1;
-      int exp2 = colscaleExp[i];
+  for (int i = 0; i < lp.nCols(); ++i) {
+    SVectorBase<R> &vec = lp.colVector_w(i);
+    int exp1;
+    int exp2 = colscaleExp[i];
 
-      for(int j = 0; j < vec.size(); ++j)
-      {
-         exp1 = rowscaleExp[vec.index(j)];
-         vec.value(j) = spxLdexp(vec.value(j), exp1 + exp2);
-      }
+    for (int j = 0; j < vec.size(); ++j) {
+      exp1 = rowscaleExp[vec.index(j)];
+      vec.value(j) = spxLdexp(vec.value(j), exp1 + exp2);
+    }
 
-      lp.maxObj_w(i) = spxLdexp(lp.maxObj_w(i), exp2);
+    lp.maxObj_w(i) = spxLdexp(lp.maxObj_w(i), exp2);
 
-      if(lp.upper(i) < R(infinity))
-         lp.upper_w(i) = spxLdexp(lp.upper_w(i), -exp2);
+    if (lp.upper(i) < R(infinity))
+      lp.upper_w(i) = spxLdexp(lp.upper_w(i), -exp2);
 
-      if(lp.lower(i) > R(-infinity))
-         lp.lower_w(i) = spxLdexp(lp.lower_w(i), -exp2);
+    if (lp.lower(i) > R(-infinity))
+      lp.lower_w(i) = spxLdexp(lp.lower_w(i), -exp2);
 
-      MSG_DEBUG(std::cout << "DEBUG: colscaleExp(" << i << "): " << exp2 << std::endl;)
-   }
+    MSG_DEBUG(std::cout << "DEBUG: colscaleExp(" << i << "): " << exp2
+                        << std::endl;)
+  }
 
-   lp.setScalingInfo(true);
-   assert(lp.isConsistent());
+  lp.setScalingInfo(true);
+  assert(lp.isConsistent());
 }
 
 /// unscale SPxLP
-template <class R>
-void SPxScaler<R>::unscale(SPxLPBase<R>& lp)
-{
-   assert(lp.isScaled());
+template <class R> void SPxScaler<R>::unscale(SPxLPBase<R> &lp) {
+  assert(lp.isScaled());
 
-   const DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
-   const DataArray < int >& rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
+  const DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
+  const DataArray<int> &rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
 
-   for(int i = 0; i < lp.nRows(); ++i)
-   {
-      SVectorBase<R>& vec = lp.rowVector_w(i);
+  for (int i = 0; i < lp.nRows(); ++i) {
+    SVectorBase<R> &vec = lp.rowVector_w(i);
 
-      int exp1;
-      int exp2 = rowscaleExp[i];
+    int exp1;
+    int exp2 = rowscaleExp[i];
 
-      for(int j = 0; j < vec.size(); ++j)
-      {
-         exp1 = colscaleExp[vec.index(j)];
-         vec.value(j) = spxLdexp(vec.value(j), -exp1 - exp2);
-      }
+    for (int j = 0; j < vec.size(); ++j) {
+      exp1 = colscaleExp[vec.index(j)];
+      vec.value(j) = spxLdexp(vec.value(j), -exp1 - exp2);
+    }
 
-      lp.maxRowObj_w(i) = spxLdexp(lp.maxRowObj(i), -exp2);
+    lp.maxRowObj_w(i) = spxLdexp(lp.maxRowObj(i), -exp2);
 
-      if(lp.rhs(i) < R(infinity))
-         lp.rhs_w(i) = spxLdexp(lp.rhs_w(i), -exp2);
+    if (lp.rhs(i) < R(infinity))
+      lp.rhs_w(i) = spxLdexp(lp.rhs_w(i), -exp2);
 
-      if(lp.lhs(i) > R(-infinity))
-         lp.lhs_w(i) = spxLdexp(lp.lhs_w(i), -exp2);
-   }
+    if (lp.lhs(i) > R(-infinity))
+      lp.lhs_w(i) = spxLdexp(lp.lhs_w(i), -exp2);
+  }
 
-   for(int i = 0; i < lp.nCols(); ++i)
-   {
-      SVectorBase<R>& vec = lp.colVector_w(i);
+  for (int i = 0; i < lp.nCols(); ++i) {
+    SVectorBase<R> &vec = lp.colVector_w(i);
 
-      int exp1;
-      int exp2 = colscaleExp[i];
+    int exp1;
+    int exp2 = colscaleExp[i];
 
-      for(int j = 0; j < vec.size(); ++j)
-      {
-         exp1 = rowscaleExp[vec.index(j)];
-         vec.value(j) = spxLdexp(vec.value(j), -exp1 - exp2);
-      }
+    for (int j = 0; j < vec.size(); ++j) {
+      exp1 = rowscaleExp[vec.index(j)];
+      vec.value(j) = spxLdexp(vec.value(j), -exp1 - exp2);
+    }
 
-      lp.maxObj_w(i) = spxLdexp(lp.maxObj_w(i), -exp2);
+    lp.maxObj_w(i) = spxLdexp(lp.maxObj_w(i), -exp2);
 
-      if(lp.upper(i) < R(infinity))
-         lp.upper_w(i) = spxLdexp(lp.upper_w(i), exp2);
+    if (lp.upper(i) < R(infinity))
+      lp.upper_w(i) = spxLdexp(lp.upper_w(i), exp2);
 
-      if(lp.lower(i) > R(-infinity))
-         lp.lower_w(i) = spxLdexp(lp.lower_w(i), exp2);
-   }
+    if (lp.lower(i) > R(-infinity))
+      lp.lower_w(i) = spxLdexp(lp.lower_w(i), exp2);
+  }
 
-   lp._isScaled = false;
-   assert(lp.isConsistent());
+  lp._isScaled = false;
+  assert(lp.isConsistent());
 }
 
 /// returns scaling factor for column \p i
 /// todo pass the LP?!
-template <class R>
-int SPxScaler<R>::getColScaleExp(int i) const
-{
-   return (*m_activeColscaleExp)[i];
+template <class R> int SPxScaler<R>::getColScaleExp(int i) const {
+  return (*m_activeColscaleExp)[i];
 }
 
 /// returns scaling factor for row \p i
 /// todo pass the LP?!
-template <class R>
-int SPxScaler<R>::getRowScaleExp(int i) const
-{
-   return (*m_activeRowscaleExp)[i];
+template <class R> int SPxScaler<R>::getRowScaleExp(int i) const {
+  return (*m_activeRowscaleExp)[i];
 }
 
 /// gets unscaled column \p i
 template <class R>
-void SPxScaler<R>::getColUnscaled(const SPxLPBase<R>& lp, int i, DSVectorBase<R>& vec) const
-{
-   assert(lp.isScaled());
-   assert(i < lp.nCols());
-   assert(i >= 0);
-   const DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
-   const DataArray < int >& rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
+void SPxScaler<R>::getColUnscaled(const SPxLPBase<R> &lp, int i,
+                                  DSVectorBase<R> &vec) const {
+  assert(lp.isScaled());
+  assert(i < lp.nCols());
+  assert(i >= 0);
+  const DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
+  const DataArray<int> &rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
 
-   vec = lp.LPColSetBase<R>::colVector(i);
+  vec = lp.LPColSetBase<R>::colVector(i);
 
-   int exp1;
-   int exp2 = colscaleExp[i];
+  int exp1;
+  int exp2 = colscaleExp[i];
 
-   const SVectorBase<R>& col = lp.colVector(i);
-   vec.setMax(col.size());
-   vec.clear();
+  const SVectorBase<R> &col = lp.colVector(i);
+  vec.setMax(col.size());
+  vec.clear();
 
-   for(int j = 0; j < col.size(); j++)
-   {
-      exp1 = rowscaleExp[col.index(j)];
-      vec.add(col.index(j), spxLdexp(col.value(j), -exp1 - exp2));
-   }
+  for (int j = 0; j < col.size(); j++) {
+    exp1 = rowscaleExp[col.index(j)];
+    vec.add(col.index(j), spxLdexp(col.value(j), -exp1 - exp2));
+  }
 }
 
 /// returns maximum absolute value of unscaled column \p i
 template <class R>
-R SPxScaler<R>::getColMaxAbsUnscaled(const SPxLPBase<R>& lp, int i) const
-{
-   assert(i < lp.nCols());
-   assert(i >= 0);
+R SPxScaler<R>::getColMaxAbsUnscaled(const SPxLPBase<R> &lp, int i) const {
+  assert(i < lp.nCols());
+  assert(i >= 0);
 
-   DataArray < int >& colscaleExp = *m_activeColscaleExp;
-   DataArray < int >& rowscaleExp = *m_activeRowscaleExp;
-   const SVectorBase<R>& colVec = lp.LPColSetBase<R>::colVector(i);
+  DataArray<int> &colscaleExp = *m_activeColscaleExp;
+  DataArray<int> &rowscaleExp = *m_activeRowscaleExp;
+  const SVectorBase<R> &colVec = lp.LPColSetBase<R>::colVector(i);
 
-   R max = 0.0;
-   int exp1;
-   int exp2 = colscaleExp[i];
+  R max = 0.0;
+  int exp1;
+  int exp2 = colscaleExp[i];
 
-   for(int j = 0; j < colVec.size(); j++)
-   {
-      exp1 = rowscaleExp[colVec.index(j)];
-      R abs = spxAbs(spxLdexp(colVec.value(j), -exp1 - exp2));
+  for (int j = 0; j < colVec.size(); j++) {
+    exp1 = rowscaleExp[colVec.index(j)];
+    R abs = spxAbs(spxLdexp(colVec.value(j), -exp1 - exp2));
 
-      if(abs > max)
-         max = abs;
-   }
+    if (abs > max)
+      max = abs;
+  }
 
-   return max;
+  return max;
 }
 
 /// returns minimum absolute value of unscaled column \p i
 template <class R>
-R SPxScaler<R>::getColMinAbsUnscaled(const SPxLPBase<R>& lp, int i) const
-{
-   assert(i < lp.nCols());
-   assert(i >= 0);
+R SPxScaler<R>::getColMinAbsUnscaled(const SPxLPBase<R> &lp, int i) const {
+  assert(i < lp.nCols());
+  assert(i >= 0);
 
-   DataArray < int >& colscaleExp = *m_activeColscaleExp;
-   DataArray < int >& rowscaleExp = *m_activeRowscaleExp;
-   const SVectorBase<R>& colVec = lp.LPColSetBase<R>::colVector(i);
+  DataArray<int> &colscaleExp = *m_activeColscaleExp;
+  DataArray<int> &rowscaleExp = *m_activeRowscaleExp;
+  const SVectorBase<R> &colVec = lp.LPColSetBase<R>::colVector(i);
 
-   R min = R(infinity);
-   int exp1;
-   int exp2 = colscaleExp[i];
+  R min = R(infinity);
+  int exp1;
+  int exp2 = colscaleExp[i];
 
-   for(int j = 0; j < colVec.size(); j++)
-   {
-      exp1 = rowscaleExp[colVec.index(j)];
-      R abs = spxAbs(spxLdexp(colVec.value(j), -exp1 - exp2));
+  for (int j = 0; j < colVec.size(); j++) {
+    exp1 = rowscaleExp[colVec.index(j)];
+    R abs = spxAbs(spxLdexp(colVec.value(j), -exp1 - exp2));
 
-      if(abs < min)
-         min = abs;
-   }
+    if (abs < min)
+      min = abs;
+  }
 
-   return min;
+  return min;
 }
 
-
 /// returns unscaled upper bound \p i
 template <class R>
-R SPxScaler<R>::upperUnscaled(const SPxLPBase<R>& lp, int i) const
-{
-   assert(lp.isScaled());
-   assert(i < lp.nCols());
-   assert(i >= 0);
+R SPxScaler<R>::upperUnscaled(const SPxLPBase<R> &lp, int i) const {
+  assert(lp.isScaled());
+  assert(i < lp.nCols());
+  assert(i >= 0);
 
-   if(lp.LPColSetBase<R>::upper(i) < R(infinity))
-   {
-      const DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
-      return spxLdexp(lp.LPColSetBase<R>::upper(i), colscaleExp[i]);
-   }
-   else
-      return lp.LPColSetBase<R>::upper(i);
+  if (lp.LPColSetBase<R>::upper(i) < R(infinity)) {
+    const DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
+    return spxLdexp(lp.LPColSetBase<R>::upper(i), colscaleExp[i]);
+  } else
+    return lp.LPColSetBase<R>::upper(i);
 }
 
-
 /// gets unscaled upper bound vector
 template <class R>
-void SPxScaler<R>::getUpperUnscaled(const SPxLPBase<R>& lp, VectorBase<R>& vec) const
-{
-   assert(lp.isScaled());
-   assert(lp.LPColSetBase<R>::upper().dim() == vec.dim());
+void SPxScaler<R>::getUpperUnscaled(const SPxLPBase<R> &lp,
+                                    VectorBase<R> &vec) const {
+  assert(lp.isScaled());
+  assert(lp.LPColSetBase<R>::upper().dim() == vec.dim());
 
-   const DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
+  const DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
 
-   for(int i = 0; i < lp.LPColSetBase<R>::upper().dim(); i++)
-      vec[i] = spxLdexp(lp.LPColSetBase<R>::upper()[i], colscaleExp[i]);
+  for (int i = 0; i < lp.LPColSetBase<R>::upper().dim(); i++)
+    vec[i] = spxLdexp(lp.LPColSetBase<R>::upper()[i], colscaleExp[i]);
 }
 
-
 /// returns unscaled upper bound VectorBase<R> of \p lp
 template <class R>
-R SPxScaler<R>::lowerUnscaled(const SPxLPBase<R>& lp, int i) const
-{
-   assert(lp.isScaled());
-   assert(i < lp.nCols());
-   assert(i >= 0);
+R SPxScaler<R>::lowerUnscaled(const SPxLPBase<R> &lp, int i) const {
+  assert(lp.isScaled());
+  assert(i < lp.nCols());
+  assert(i >= 0);
 
-   if(lp.LPColSetBase<R>::lower(i) > R(-infinity))
-   {
-      const DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
-      return spxLdexp(lp.LPColSetBase<R>::lower(i), colscaleExp[i]);
-   }
-   else
-      return lp.LPColSetBase<R>::lower(i);
+  if (lp.LPColSetBase<R>::lower(i) > R(-infinity)) {
+    const DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
+    return spxLdexp(lp.LPColSetBase<R>::lower(i), colscaleExp[i]);
+  } else
+    return lp.LPColSetBase<R>::lower(i);
 }
 
-
 /// returns unscaled lower bound VectorBase<R> of \p lp
 template <class R>
-void SPxScaler<R>::getLowerUnscaled(const SPxLPBase<R>& lp, VectorBase<R>& vec) const
-{
-   assert(lp.isScaled());
-   assert(lp.LPColSetBase<R>::lower().dim() == vec.dim());
+void SPxScaler<R>::getLowerUnscaled(const SPxLPBase<R> &lp,
+                                    VectorBase<R> &vec) const {
+  assert(lp.isScaled());
+  assert(lp.LPColSetBase<R>::lower().dim() == vec.dim());
 
-   const DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
+  const DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
 
-   for(int i = 0; i < lp.LPColSetBase<R>::lower().dim(); i++)
-      vec[i] = spxLdexp(lp.LPColSetBase<R>::lower()[i], colscaleExp[i]);
+  for (int i = 0; i < lp.LPColSetBase<R>::lower().dim(); i++)
+    vec[i] = spxLdexp(lp.LPColSetBase<R>::lower()[i], colscaleExp[i]);
 }
 
 /// returns unscaled objective function coefficient of \p i
 template <class R>
-R SPxScaler<R>::maxObjUnscaled(const SPxLPBase<R>& lp, int i) const
-{
-   assert(lp.isScaled());
-   assert(i < lp.nCols());
-   assert(i >= 0);
+R SPxScaler<R>::maxObjUnscaled(const SPxLPBase<R> &lp, int i) const {
+  assert(lp.isScaled());
+  assert(i < lp.nCols());
+  assert(i >= 0);
 
-   const DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
+  const DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
 
-   return spxLdexp(lp.LPColSetBase<R>::maxObj(i), -colscaleExp[i]);
+  return spxLdexp(lp.LPColSetBase<R>::maxObj(i), -colscaleExp[i]);
 }
 
-
 /// gets unscaled objective function coefficient of \p i
 template <class R>
-void SPxScaler<R>::getMaxObjUnscaled(const SPxLPBase<R>& lp, VectorBase<R>& vec) const
-{
-   assert(lp.isScaled());
-   assert(lp.LPColSetBase<R>::maxObj().dim() == vec.dim());
+void SPxScaler<R>::getMaxObjUnscaled(const SPxLPBase<R> &lp,
+                                     VectorBase<R> &vec) const {
+  assert(lp.isScaled());
+  assert(lp.LPColSetBase<R>::maxObj().dim() == vec.dim());
 
-   const DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
+  const DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
 
-   for(int i = 0; i < lp.LPColSetBase<R>::maxObj().dim(); i++)
-      vec[i] = spxLdexp(lp.LPColSetBase<R>::maxObj()[i], -colscaleExp[i]);
+  for (int i = 0; i < lp.LPColSetBase<R>::maxObj().dim(); i++)
+    vec[i] = spxLdexp(lp.LPColSetBase<R>::maxObj()[i], -colscaleExp[i]);
 }
 
 /// gets unscaled row \p i
 template <class R>
-void SPxScaler<R>::getRowUnscaled(const SPxLPBase<R>& lp, int i, DSVectorBase<R>& vec) const
-{
-   assert(lp.isScaled());
-   assert(i < lp.nRows());
-   assert(i >= 0);
+void SPxScaler<R>::getRowUnscaled(const SPxLPBase<R> &lp, int i,
+                                  DSVectorBase<R> &vec) const {
+  assert(lp.isScaled());
+  assert(i < lp.nRows());
+  assert(i >= 0);
 
-   const DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
-   const DataArray < int >& rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
-   int exp1;
-   int exp2 = rowscaleExp[i];
+  const DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
+  const DataArray<int> &rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
+  int exp1;
+  int exp2 = rowscaleExp[i];
 
-   const SVectorBase<R>& row = lp.rowVector(i);
-   vec.setMax(row.size());
-   vec.clear();
+  const SVectorBase<R> &row = lp.rowVector(i);
+  vec.setMax(row.size());
+  vec.clear();
 
-   for(int j = 0; j < row.size(); j++)
-   {
-      exp1 = colscaleExp[row.index(j)];
-      vec.add(row.index(j), spxLdexp(row.value(j), -exp1 - exp2));
-   }
+  for (int j = 0; j < row.size(); j++) {
+    exp1 = colscaleExp[row.index(j)];
+    vec.add(row.index(j), spxLdexp(row.value(j), -exp1 - exp2));
+  }
 }
 
 /// returns maximum absolute value of unscaled row \p i
 template <class R>
-R SPxScaler<R>::getRowMaxAbsUnscaled(const SPxLPBase<R>& lp, int i) const
-{
-   assert(i < lp.nRows());
-   assert(i >= 0);
-   DataArray < int >& colscaleExp = *m_activeColscaleExp;
-   DataArray < int >& rowscaleExp = *m_activeRowscaleExp;
-   const SVectorBase<R>& rowVec = lp.LPRowSetBase<R>::rowVector(i);
+R SPxScaler<R>::getRowMaxAbsUnscaled(const SPxLPBase<R> &lp, int i) const {
+  assert(i < lp.nRows());
+  assert(i >= 0);
+  DataArray<int> &colscaleExp = *m_activeColscaleExp;
+  DataArray<int> &rowscaleExp = *m_activeRowscaleExp;
+  const SVectorBase<R> &rowVec = lp.LPRowSetBase<R>::rowVector(i);
 
-   R max = 0.0;
+  R max = 0.0;
 
-   int exp1;
-   int exp2 = rowscaleExp[i];
+  int exp1;
+  int exp2 = rowscaleExp[i];
 
-   for(int j = 0; j < rowVec.size(); j++)
-   {
-      exp1 = colscaleExp[rowVec.index(j)];
-      R abs = spxAbs(spxLdexp(rowVec.value(j), -exp1 - exp2));
+  for (int j = 0; j < rowVec.size(); j++) {
+    exp1 = colscaleExp[rowVec.index(j)];
+    R abs = spxAbs(spxLdexp(rowVec.value(j), -exp1 - exp2));
 
-      if(GT(abs, max))
-         max = abs;
-   }
+    if (GT(abs, max))
+      max = abs;
+  }
 
-   return max;
+  return max;
 }
 
 /// returns minimum absolute value of unscaled row \p i
 template <class R>
-R SPxScaler<R>::getRowMinAbsUnscaled(const SPxLPBase<R>& lp, int i) const
-{
-   assert(i < lp.nRows());
-   assert(i >= 0);
-   DataArray < int >& colscaleExp = *m_activeColscaleExp;
-   DataArray < int >& rowscaleExp = *m_activeRowscaleExp;
-   const SVectorBase<R>& rowVec = lp.LPRowSetBase<R>::rowVector(i);
+R SPxScaler<R>::getRowMinAbsUnscaled(const SPxLPBase<R> &lp, int i) const {
+  assert(i < lp.nRows());
+  assert(i >= 0);
+  DataArray<int> &colscaleExp = *m_activeColscaleExp;
+  DataArray<int> &rowscaleExp = *m_activeRowscaleExp;
+  const SVectorBase<R> &rowVec = lp.LPRowSetBase<R>::rowVector(i);
 
-   R min = R(infinity);
+  R min = R(infinity);
 
-   int exp1;
-   int exp2 = rowscaleExp[i];
+  int exp1;
+  int exp2 = rowscaleExp[i];
 
-   for(int j = 0; j < rowVec.size(); j++)
-   {
-      exp1 = colscaleExp[rowVec.index(j)];
-      R abs = spxAbs(spxLdexp(rowVec.value(j), -exp1 - exp2));
+  for (int j = 0; j < rowVec.size(); j++) {
+    exp1 = colscaleExp[rowVec.index(j)];
+    R abs = spxAbs(spxLdexp(rowVec.value(j), -exp1 - exp2));
 
-      if(LT(abs, min))
-         min = abs;
-   }
+    if (LT(abs, min))
+      min = abs;
+  }
 
-   return min;
+  return min;
 }
 
 /// returns unscaled right hand side \p i
 template <class R>
-R SPxScaler<R>::rhsUnscaled(const SPxLPBase<R>& lp, int i) const
-{
-   assert(lp.isScaled());
-   assert(i < lp.nRows());
-   assert(i >= 0);
+R SPxScaler<R>::rhsUnscaled(const SPxLPBase<R> &lp, int i) const {
+  assert(lp.isScaled());
+  assert(i < lp.nRows());
+  assert(i >= 0);
 
-   if(lp.LPRowSetBase<R>::rhs(i) < R(infinity))
-   {
-      const DataArray < int >& rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
-      return spxLdexp(lp.LPRowSetBase<R>::rhs(i), -rowscaleExp[i]);
-   }
-   else
-      return lp.LPRowSetBase<R>::rhs(i);
+  if (lp.LPRowSetBase<R>::rhs(i) < R(infinity)) {
+    const DataArray<int> &rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
+    return spxLdexp(lp.LPRowSetBase<R>::rhs(i), -rowscaleExp[i]);
+  } else
+    return lp.LPRowSetBase<R>::rhs(i);
 }
 
-
 /// gets unscaled right hand side vector
 template <class R>
-void SPxScaler<R>::getRhsUnscaled(const SPxLPBase<R>& lp, VectorBase<R>& vec) const
-{
-   assert(lp.isScaled());
-   assert(lp.LPRowSetBase<R>::rhs().dim() == vec.dim());
+void SPxScaler<R>::getRhsUnscaled(const SPxLPBase<R> &lp,
+                                  VectorBase<R> &vec) const {
+  assert(lp.isScaled());
+  assert(lp.LPRowSetBase<R>::rhs().dim() == vec.dim());
 
-   for(int i = 0; i < lp.LPRowSetBase<R>::rhs().dim(); i++)
-   {
-      const DataArray < int >& rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
-      vec[i] = spxLdexp(lp.LPRowSetBase<R>::rhs()[i], -rowscaleExp[i]);
-   }
+  for (int i = 0; i < lp.LPRowSetBase<R>::rhs().dim(); i++) {
+    const DataArray<int> &rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
+    vec[i] = spxLdexp(lp.LPRowSetBase<R>::rhs()[i], -rowscaleExp[i]);
+  }
 }
 
-
 /// returns unscaled left hand side \p i of \p lp
 template <class R>
-R SPxScaler<R>::lhsUnscaled(const SPxLPBase<R>& lp, int i) const
-{
-   assert(lp.isScaled());
-   assert(i < lp.nRows());
-   assert(i >= 0);
+R SPxScaler<R>::lhsUnscaled(const SPxLPBase<R> &lp, int i) const {
+  assert(lp.isScaled());
+  assert(i < lp.nRows());
+  assert(i >= 0);
 
-   if(lp.LPRowSetBase<R>::lhs(i) > R(-infinity))
-   {
-      const DataArray < int >& rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
-      return spxLdexp(lp.LPRowSetBase<R>::lhs(i), -rowscaleExp[i]);
-   }
-   else
-      return lp.LPRowSetBase<R>::lhs(i);
+  if (lp.LPRowSetBase<R>::lhs(i) > R(-infinity)) {
+    const DataArray<int> &rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
+    return spxLdexp(lp.LPRowSetBase<R>::lhs(i), -rowscaleExp[i]);
+  } else
+    return lp.LPRowSetBase<R>::lhs(i);
 }
 
 /// returns unscaled left hand side VectorBase<R> of \p lp
 template <class R>
-void SPxScaler<R>::getLhsUnscaled(const SPxLPBase<R>& lp, VectorBase<R>& vec) const
-{
-   assert(lp.isScaled());
-   assert(lp.LPRowSetBase<R>::lhs().dim() == vec.dim());
+void SPxScaler<R>::getLhsUnscaled(const SPxLPBase<R> &lp,
+                                  VectorBase<R> &vec) const {
+  assert(lp.isScaled());
+  assert(lp.LPRowSetBase<R>::lhs().dim() == vec.dim());
 
-   const DataArray < int >& rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
+  const DataArray<int> &rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
 
-   for(int i = 0; i < lp.LPRowSetBase<R>::lhs().dim(); i++)
-      vec[i] = spxLdexp(lp.LPRowSetBase<R>::lhs()[i], -rowscaleExp[i]);
+  for (int i = 0; i < lp.LPRowSetBase<R>::lhs().dim(); i++)
+    vec[i] = spxLdexp(lp.LPRowSetBase<R>::lhs()[i], -rowscaleExp[i]);
 }
 
 /// returns unscaled coefficient of \p lp
 template <class R>
-R SPxScaler<R>::getCoefUnscaled(const SPxLPBase<R>& lp, int row, int col) const
-{
-   assert(lp.isScaled());
-   assert(row < lp.nRows());
-   assert(col < lp.nCols());
+R SPxScaler<R>::getCoefUnscaled(const SPxLPBase<R> &lp, int row,
+                                int col) const {
+  assert(lp.isScaled());
+  assert(row < lp.nRows());
+  assert(col < lp.nCols());
 
-   const DataArray < int >& rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
-   const DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
+  const DataArray<int> &rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
+  const DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
 
-   return spxLdexp(lp.colVector(col)[row], - rowscaleExp[row] - colscaleExp[col]);
+  return spxLdexp(lp.colVector(col)[row], -rowscaleExp[row] - colscaleExp[col]);
 }
 
 template <class R>
-void SPxScaler<R>::unscalePrimal(const SPxLPBase<R>& lp, VectorBase<R>& x) const
-{
-   assert(lp.isScaled());
+void SPxScaler<R>::unscalePrimal(const SPxLPBase<R> &lp,
+                                 VectorBase<R> &x) const {
+  assert(lp.isScaled());
 
-   const DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
+  const DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
 
-   assert(x.dim() == colscaleExp.size());
+  assert(x.dim() == colscaleExp.size());
 
-   for(int j = 0; j < x.dim(); ++j)
-      x[j] = spxLdexp(x[j], colscaleExp[j]);
+  for (int j = 0; j < x.dim(); ++j)
+    x[j] = spxLdexp(x[j], colscaleExp[j]);
 }
 
 template <class R>
-void SPxScaler<R>::unscaleSlacks(const SPxLPBase<R>& lp, VectorBase<R>& s) const
-{
-   assert(lp.isScaled());
+void SPxScaler<R>::unscaleSlacks(const SPxLPBase<R> &lp,
+                                 VectorBase<R> &s) const {
+  assert(lp.isScaled());
 
-   const DataArray < int >& rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
+  const DataArray<int> &rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
 
-   assert(s.dim() == rowscaleExp.size());
+  assert(s.dim() == rowscaleExp.size());
 
-   for(int i = 0; i < s.dim(); ++i)
-      s[i] = spxLdexp(s[i], -rowscaleExp[i]);
+  for (int i = 0; i < s.dim(); ++i)
+    s[i] = spxLdexp(s[i], -rowscaleExp[i]);
 }
 
 template <class R>
-void SPxScaler<R>::unscaleDual(const SPxLPBase<R>& lp, VectorBase<R>& pi) const
-{
-   assert(lp.isScaled());
+void SPxScaler<R>::unscaleDual(const SPxLPBase<R> &lp,
+                               VectorBase<R> &pi) const {
+  assert(lp.isScaled());
 
-   const DataArray < int >& rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
+  const DataArray<int> &rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
 
-   assert(pi.dim() == rowscaleExp.size());
+  assert(pi.dim() == rowscaleExp.size());
 
-   for(int i = 0; i < pi.dim(); ++i)
-      pi[i] = spxLdexp(pi[i], rowscaleExp[i]);
+  for (int i = 0; i < pi.dim(); ++i)
+    pi[i] = spxLdexp(pi[i], rowscaleExp[i]);
 }
 
 template <class R>
-void SPxScaler<R>::unscaleRedCost(const SPxLPBase<R>& lp, VectorBase<R>& r) const
-{
-   assert(lp.isScaled());
+void SPxScaler<R>::unscaleRedCost(const SPxLPBase<R> &lp,
+                                  VectorBase<R> &r) const {
+  assert(lp.isScaled());
 
-   const DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
+  const DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
 
-   assert(r.dim() == colscaleExp.size());
+  assert(r.dim() == colscaleExp.size());
 
-   for(int j = 0; j < r.dim(); ++j)
-      r[j] = spxLdexp(r[j], -colscaleExp[j]);
+  for (int j = 0; j < r.dim(); ++j)
+    r[j] = spxLdexp(r[j], -colscaleExp[j]);
 }
 
 template <class R>
-void SPxScaler<R>::unscalePrimalray(const SPxLPBase<R>& lp, VectorBase<R>& ray) const
-{
-   assert(lp.isScaled());
+void SPxScaler<R>::unscalePrimalray(const SPxLPBase<R> &lp,
+                                    VectorBase<R> &ray) const {
+  assert(lp.isScaled());
 
-   const DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
+  const DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
 
-   assert(ray.dim() == colscaleExp.size());
+  assert(ray.dim() == colscaleExp.size());
 
-   for(int j = 0; j < ray.dim(); ++j)
-      ray[j] = spxLdexp(ray[j], colscaleExp[j]);
+  for (int j = 0; j < ray.dim(); ++j)
+    ray[j] = spxLdexp(ray[j], colscaleExp[j]);
 }
 
 template <class R>
-void SPxScaler<R>::unscaleDualray(const SPxLPBase<R>& lp, VectorBase<R>& ray) const
-{
-   assert(lp.isScaled());
+void SPxScaler<R>::unscaleDualray(const SPxLPBase<R> &lp,
+                                  VectorBase<R> &ray) const {
+  assert(lp.isScaled());
 
-   const DataArray < int >& rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
+  const DataArray<int> &rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
 
-   assert(ray.dim() == rowscaleExp.size());
+  assert(ray.dim() == rowscaleExp.size());
 
-   for(int i = 0; i < ray.dim(); ++i)
-      ray[i] = spxLdexp(ray[i], rowscaleExp[i]);
+  for (int i = 0; i < ray.dim(); ++i)
+    ray[i] = spxLdexp(ray[i], rowscaleExp[i]);
 }
 
 template <class R>
-void SPxScaler<R>::scaleObj(const SPxLPBase<R>& lp, VectorBase<R>& origObj) const
-{
-   assert(lp.isScaled());
+void SPxScaler<R>::scaleObj(const SPxLPBase<R> &lp,
+                            VectorBase<R> &origObj) const {
+  assert(lp.isScaled());
 
-   const DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
+  const DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
 
-   for(int i = 0; i < origObj.dim(); ++i)
-   {
-      origObj[i] = spxLdexp(origObj[i], colscaleExp[i]);
-   }
+  for (int i = 0; i < origObj.dim(); ++i) {
+    origObj[i] = spxLdexp(origObj[i], colscaleExp[i]);
+  }
 }
 
 template <class R>
-R SPxScaler<R>::scaleObj(const SPxLPBase<R>& lp, int i, R origObj) const
-{
-   assert(lp.isScaled());
-   assert(i < lp.nCols());
-   assert(i >= 0);
+R SPxScaler<R>::scaleObj(const SPxLPBase<R> &lp, int i, R origObj) const {
+  assert(lp.isScaled());
+  assert(i < lp.nCols());
+  assert(i >= 0);
 
-   const DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
-   int exp = colscaleExp[i];
+  const DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
+  int exp = colscaleExp[i];
 
-   return spxLdexp(origObj, exp);
+  return spxLdexp(origObj, exp);
 }
 
 template <class R>
-R SPxScaler<R>::scaleElement(const SPxLPBase<R>& lp, int row, int col, R val) const
-{
-   assert(lp.isScaled());
-   assert(col < lp.nCols());
-   assert(col >= 0);
-   assert(row < lp.nRows());
-   assert(row >= 0);
+R SPxScaler<R>::scaleElement(const SPxLPBase<R> &lp, int row, int col,
+                             R val) const {
+  assert(lp.isScaled());
+  assert(col < lp.nCols());
+  assert(col >= 0);
+  assert(row < lp.nRows());
+  assert(row >= 0);
 
-   const DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
-   const DataArray < int >& rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
+  const DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
+  const DataArray<int> &rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
 
-   return spxLdexp(val, colscaleExp[col] + rowscaleExp[row]);
+  return spxLdexp(val, colscaleExp[col] + rowscaleExp[row]);
 }
 
 template <class R>
-R SPxScaler<R>::scaleLower(const SPxLPBase<R>& lp, int col, R lower) const
-{
-   assert(lp.isScaled());
-   assert(col < lp.nCols());
-   assert(col >= 0);
+R SPxScaler<R>::scaleLower(const SPxLPBase<R> &lp, int col, R lower) const {
+  assert(lp.isScaled());
+  assert(col < lp.nCols());
+  assert(col >= 0);
 
-   const DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
+  const DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
 
-   return spxLdexp(lower, -colscaleExp[col]);
+  return spxLdexp(lower, -colscaleExp[col]);
 }
 
 template <class R>
-R SPxScaler<R>::scaleUpper(const SPxLPBase<R>& lp, int col, R upper) const
-{
-   assert(lp.isScaled());
-   assert(col < lp.nCols());
-   assert(col >= 0);
+R SPxScaler<R>::scaleUpper(const SPxLPBase<R> &lp, int col, R upper) const {
+  assert(lp.isScaled());
+  assert(col < lp.nCols());
+  assert(col >= 0);
 
-   const DataArray < int >& colscaleExp = lp.LPColSetBase<R>::scaleExp;
+  const DataArray<int> &colscaleExp = lp.LPColSetBase<R>::scaleExp;
 
-   return spxLdexp(upper, -colscaleExp[col]);
+  return spxLdexp(upper, -colscaleExp[col]);
 }
 
 template <class R>
-R SPxScaler<R>::scaleLhs(const SPxLPBase<R>& lp, int row, R lhs) const
-{
-   assert(lp.isScaled());
-   assert(row < lp.nRows());
-   assert(row >= 0);
+R SPxScaler<R>::scaleLhs(const SPxLPBase<R> &lp, int row, R lhs) const {
+  assert(lp.isScaled());
+  assert(row < lp.nRows());
+  assert(row >= 0);
 
-   const DataArray < int >& rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
+  const DataArray<int> &rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
 
-   return spxLdexp(lhs, rowscaleExp[row]);
+  return spxLdexp(lhs, rowscaleExp[row]);
 }
 
 template <class R>
-R SPxScaler<R>::scaleRhs(const SPxLPBase<R>& lp, int row, R rhs) const
-{
-   assert(lp.isScaled());
-   assert(row < lp.nRows());
-   assert(row >= 0);
+R SPxScaler<R>::scaleRhs(const SPxLPBase<R> &lp, int row, R rhs) const {
+  assert(lp.isScaled());
+  assert(row < lp.nRows());
+  assert(row >= 0);
 
-   const DataArray < int >& rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
+  const DataArray<int> &rowscaleExp = lp.LPRowSetBase<R>::scaleExp;
 
-   return spxLdexp(rhs, rowscaleExp[row]);
+  return spxLdexp(rhs, rowscaleExp[row]);
 }
 
-template <class R>
-R SPxScaler<R>::minAbsColscale() const
-{
-   const DataArray < int >& colscaleExp = *m_activeColscaleExp;
+template <class R> R SPxScaler<R>::minAbsColscale() const {
+  const DataArray<int> &colscaleExp = *m_activeColscaleExp;
 
-   R mini = R(infinity);
+  R mini = R(infinity);
 
-   for(int i = 0; i < colscaleExp.size(); ++i)
-      if(spxAbs(spxLdexp(1.0, colscaleExp[i])) < mini)
-         mini = spxAbs(spxLdexp(1.0, colscaleExp[i]));
+  for (int i = 0; i < colscaleExp.size(); ++i)
+    if (spxAbs(spxLdexp(1.0, colscaleExp[i])) < mini)
+      mini = spxAbs(spxLdexp(1.0, colscaleExp[i]));
 
-   return mini;
+  return mini;
 }
 
-template <class R>
-R SPxScaler<R>::maxAbsColscale() const
-{
-   const DataArray < int >& colscaleExp = *m_activeColscaleExp;
-
-   R maxi = 0.0;
+template <class R> R SPxScaler<R>::maxAbsColscale() const {
+  const DataArray<int> &colscaleExp = *m_activeColscaleExp;
 
-   for(int i = 0; i < colscaleExp.size(); ++i)
-      if(spxAbs(spxLdexp(1.0, colscaleExp[i])) > maxi)
-         maxi = spxAbs(spxLdexp(1.0, colscaleExp[i]));
+  R maxi = 0.0;
 
+  for (int i = 0; i < colscaleExp.size(); ++i)
+    if (spxAbs(spxLdexp(1.0, colscaleExp[i])) > maxi)
+      maxi = spxAbs(spxLdexp(1.0, colscaleExp[i]));
 
-   return maxi;
+  return maxi;
 }
 
-template <class R>
-R SPxScaler<R>::minAbsRowscale() const
-{
-   const DataArray < int >& rowscaleExp = *m_activeRowscaleExp;
+template <class R> R SPxScaler<R>::minAbsRowscale() const {
+  const DataArray<int> &rowscaleExp = *m_activeRowscaleExp;
 
-   int mini = std::numeric_limits<int>::max();
+  int mini = std::numeric_limits<int>::max();
 
-   for(int i = 0; i < rowscaleExp.size(); ++i)
-      if(rowscaleExp[i] < mini)
-         mini = rowscaleExp[i];
+  for (int i = 0; i < rowscaleExp.size(); ++i)
+    if (rowscaleExp[i] < mini)
+      mini = rowscaleExp[i];
 
-   return spxLdexp(1.0, mini);
+  return spxLdexp(1.0, mini);
 }
 
-template <class R>
-R SPxScaler<R>::maxAbsRowscale() const
-{
-   const DataArray < int >& rowscaleExp = *m_activeRowscaleExp;
+template <class R> R SPxScaler<R>::maxAbsRowscale() const {
+  const DataArray<int> &rowscaleExp = *m_activeRowscaleExp;
 
-   int maxi = std::numeric_limits<int>::min();
+  int maxi = std::numeric_limits<int>::min();
 
-   for(int i = 0; i < rowscaleExp.size(); ++i)
-      if(rowscaleExp[i] > maxi)
-         maxi = rowscaleExp[i];
+  for (int i = 0; i < rowscaleExp.size(); ++i)
+    if (rowscaleExp[i] > maxi)
+      maxi = rowscaleExp[i];
 
-   return spxLdexp(1.0, maxi);
+  return spxLdexp(1.0, maxi);
 }
 
 /** \f$\max_{j\in\mbox{ cols}}
  *   \left(\frac{\max_{i\in\mbox{ rows}}|a_ij|}
  *              {\min_{i\in\mbox{ rows}}|a_ij|}\right)\f$
  */
-template <class R>
-R SPxScaler<R>::maxColRatio(const SPxLPBase<R>& lp) const
-{
+template <class R> R SPxScaler<R>::maxColRatio(const SPxLPBase<R> &lp) const {
 
-   R pmax = 0.0;
+  R pmax = 0.0;
 
-   for(int i = 0; i < lp.nCols(); ++i)
-   {
-      const SVectorBase<R>& vec  = lp.colVector(i);
-      R           mini = R(infinity);
-      R           maxi = 0.0;
+  for (int i = 0; i < lp.nCols(); ++i) {
+    const SVectorBase<R> &vec = lp.colVector(i);
+    R mini = R(infinity);
+    R maxi = 0.0;
 
-      for(int j = 0; j < vec.size(); ++j)
-      {
-         R x = spxAbs(vec.value(j));
+    for (int j = 0; j < vec.size(); ++j) {
+      R x = spxAbs(vec.value(j));
 
-         if(isZero(x))
-            continue;
+      if (isZero(x))
+        continue;
 
-         if(x < mini)
-            mini = x;
+      if (x < mini)
+        mini = x;
 
-         if(x > maxi)
-            maxi = x;
-      }
+      if (x > maxi)
+        maxi = x;
+    }
 
-      if(mini == R(infinity))
-         continue;
+    if (mini == R(infinity))
+      continue;
 
-      R p = maxi / mini;
+    R p = maxi / mini;
 
-      if(p > pmax)
-         pmax = p;
-   }
+    if (p > pmax)
+      pmax = p;
+  }
 
-   return pmax;
+  return pmax;
 }
 
 /** \f$\max_{i\in\mbox{ rows}}
  *   \left(\frac{\max_{j\in\mbox{ cols}}|a_ij|}
  *              {\min_{j\in\mbox{ cols}}|a_ij|}\right)\f$
  */
-template <class R>
-R SPxScaler<R>::maxRowRatio(const SPxLPBase<R>& lp) const
-{
+template <class R> R SPxScaler<R>::maxRowRatio(const SPxLPBase<R> &lp) const {
 
-   R pmax = 0.0;
+  R pmax = 0.0;
 
-   for(int i = 0; i < lp.nRows(); ++i)
-   {
-      const SVectorBase<R>& vec  = lp.rowVector(i);
-      R           mini = R(infinity);
-      R           maxi = 0.0;
+  for (int i = 0; i < lp.nRows(); ++i) {
+    const SVectorBase<R> &vec = lp.rowVector(i);
+    R mini = R(infinity);
+    R maxi = 0.0;
 
-      for(int j = 0; j < vec.size(); ++j)
-      {
-         R x = spxAbs(vec.value(j));
+    for (int j = 0; j < vec.size(); ++j) {
+      R x = spxAbs(vec.value(j));
 
-         if(isZero(x))
-            continue;
+      if (isZero(x))
+        continue;
 
-         if(x < mini)
-            mini = x;
+      if (x < mini)
+        mini = x;
 
-         if(x > maxi)
-            maxi = x;
-      }
+      if (x > maxi)
+        maxi = x;
+    }
 
-      if(mini == R(infinity))
-         continue;
+    if (mini == R(infinity))
+      continue;
 
-      R p = maxi / mini;
+    R p = maxi / mini;
 
-      if(p > pmax)
-         pmax = p;
-   }
+    if (p > pmax)
+      pmax = p;
+  }
 
-   return pmax;
+  return pmax;
 }
 
 template <class R>
-void SPxScaler<R>::computeExpVec(const std::vector<R>& vec, DataArray<int>& vecExp)
-{
-   assert(vec.size() == unsigned(vecExp.size()));
+void SPxScaler<R>::computeExpVec(const std::vector<R> &vec,
+                                 DataArray<int> &vecExp) {
+  assert(vec.size() == unsigned(vecExp.size()));
 
-   for(unsigned i = 0; i < vec.size(); ++i)
-   {
-      spxFrexp(vec[i], &(vecExp[int(i)]));
-      vecExp[int(i)] -= 1;
-   }
+  for (unsigned i = 0; i < vec.size(); ++i) {
+    spxFrexp(vec[i], &(vecExp[int(i)]));
+    vecExp[int(i)] -= 1;
+  }
 }
 
-template <class R>
-bool SPxScaler<R>::isConsistent() const
-{
+template <class R> bool SPxScaler<R>::isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
-   return m_activeColscaleExp->isConsistent() && m_activeRowscaleExp->isConsistent();
+  return m_activeColscaleExp->isConsistent() &&
+         m_activeRowscaleExp->isConsistent();
 #else
-   return true;
+  return true;
 #endif
 }
 
-
 } // namespace soplex
diff --git a/src/soplex/spxshift.hpp b/src/soplex/spxshift.hpp
index 8d7faef..547bf7b 100644
--- a/src/soplex/spxshift.hpp
+++ b/src/soplex/spxshift.hpp
@@ -21,68 +21,63 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <assert.h>
 #include <iostream>
 
 #include "soplex/spxdefines.h"
-#include "soplex/spxsolver.h"
 #include "soplex/spxout.h"
+#include "soplex/spxsolver.h"
 
-namespace soplex
-{
-template <class R>
-void SPxSolverBase<R>::shiftFvec()
-{
-
-   /* the allowed tolerance is (rep() == COLUMN) ? feastol() : opttol() because theFvec is the primal VectorBase<R> in COLUMN
-    * and the dual VectorBase<R> in ROW representation; this is equivalent to entertol()
-    */
-   R minrandom = 10.0 * entertol();
-   R maxrandom = 100.0 * entertol();
-   R allow = entertol() - epsilon();
-
-   assert(type() == ENTER);
-   assert(allow > 0);
-
-   for(int i = dim() - 1; i >= 0; --i)
-   {
-      if(theUBbound[i] + allow < (*theFvec)[i])
-      {
-         MSG_DEBUG(std::cout << "DSHIFT08 theUBbound[" << i << "] violated by " <<
-                   (*theFvec)[i] - theUBbound[i] - allow << std::endl);
-
-         if(theUBbound[i] != theLBbound[i])
-         {
-            // since minrandom and maxrandom are of the order 10 different,
-            // we currently doesn't care about higher precision random
-            // numbers. Hence the cast to double.
-            shiftUBbound(i, (*theFvec)[i] + random.next((double)minrandom, (double)maxrandom));
-         }
-         else
-         {
-            shiftUBbound(i, (*theFvec)[i]);
-            theLBbound[i] = theUBbound[i];
-         }
+namespace soplex {
+template <class R> void SPxSolverBase<R>::shiftFvec() {
+
+  /* the allowed tolerance is (rep() == COLUMN) ? feastol() : opttol() because
+   * theFvec is the primal VectorBase<R> in COLUMN and the dual VectorBase<R> in
+   * ROW representation; this is equivalent to entertol()
+   */
+  R minrandom = 10.0 * entertol();
+  R maxrandom = 100.0 * entertol();
+  R allow = entertol() - epsilon();
+
+  assert(type() == ENTER);
+  assert(allow > 0);
+
+  for (int i = dim() - 1; i >= 0; --i) {
+    if (theUBbound[i] + allow < (*theFvec)[i]) {
+      MSG_DEBUG(std::cout << "DSHIFT08 theUBbound[" << i << "] violated by "
+                          << (*theFvec)[i] - theUBbound[i] - allow
+                          << std::endl);
+
+      if (theUBbound[i] != theLBbound[i]) {
+        // since minrandom and maxrandom are of the order 10 different,
+        // we currently doesn't care about higher precision random
+        // numbers. Hence the cast to double.
+        shiftUBbound(i, (*theFvec)[i] +
+                            random.next((double)minrandom, (double)maxrandom));
+      } else {
+        shiftUBbound(i, (*theFvec)[i]);
+        theLBbound[i] = theUBbound[i];
       }
-      else if((*theFvec)[i] < theLBbound[i] - allow)
-      {
-         MSG_DEBUG(std::cout << "DSHIFT08 theLBbound[" << i << "] violated by " << theLBbound[i] -
-                   (*theFvec)[i] - allow << std::endl);
-
-         if(theUBbound[i] != theLBbound[i])
-            shiftLBbound(i, (*theFvec)[i] - random.next((double)minrandom, (double)maxrandom));
-         else
-         {
-            shiftLBbound(i, (*theFvec)[i]);
-            theUBbound[i] = theLBbound[i];
-         }
+    } else if ((*theFvec)[i] < theLBbound[i] - allow) {
+      MSG_DEBUG(std::cout << "DSHIFT08 theLBbound[" << i << "] violated by "
+                          << theLBbound[i] - (*theFvec)[i] - allow
+                          << std::endl);
+
+      if (theUBbound[i] != theLBbound[i])
+        shiftLBbound(i, (*theFvec)[i] -
+                            random.next((double)minrandom, (double)maxrandom));
+      else {
+        shiftLBbound(i, (*theFvec)[i]);
+        theUBbound[i] = theLBbound[i];
       }
-   }
+    }
+  }
 
 #ifndef NDEBUG
-   testBounds();
-   MSG_DEBUG(std::cout << "DSHIFT01 shiftFvec: OK" << std::endl;)
+  testBounds();
+  MSG_DEBUG(std::cout << "DSHIFT01 shiftFvec: OK" << std::endl;)
 #endif
 }
 
@@ -93,744 +88,613 @@ void SPxSolverBase<R>::shiftFvec()
   vectors for leaving simplex. Then it checks all values of |pVec| and
   |coPvec| to obey these bounds and enlarges them if neccessary.
 */
-template <class R>
-void SPxSolverBase<R>::shiftPvec()
-{
-
-   /* the allowed tolerance is (rep() == ROW) ? feastol() : opttol() because thePvec is the primal VectorBase<R> in ROW and the
-    * dual VectorBase<R> in COLUMN representation; this is equivalent to leavetol()
-    */
-   R minrandom = 10.0 * leavetol();
-   R maxrandom = 100.0 * leavetol();
-   R allow = leavetol() - epsilon();
-   bool tmp;
-   int i;
-
-   assert(type() == LEAVE);
-   assert(allow > 0.0);
-
-   for(i = dim() - 1; i >= 0; --i)
-   {
-      tmp = !isBasic(coId(i));
-
-      if((*theCoUbound)[i] + allow <= (*theCoPvec)[i] && tmp)
-      {
-         if((*theCoUbound)[i] != (*theCoLbound)[i])
-            shiftUCbound(i, (*theCoPvec)[i] + random.next((double)minrandom, (double)maxrandom));
-         else
-         {
-            shiftUCbound(i, (*theCoPvec)[i]);
-            (*theCoLbound)[i] = (*theCoUbound)[i];
-         }
+template <class R> void SPxSolverBase<R>::shiftPvec() {
+
+  /* the allowed tolerance is (rep() == ROW) ? feastol() : opttol() because
+   * thePvec is the primal VectorBase<R> in ROW and the dual VectorBase<R> in
+   * COLUMN representation; this is equivalent to leavetol()
+   */
+  R minrandom = 10.0 * leavetol();
+  R maxrandom = 100.0 * leavetol();
+  R allow = leavetol() - epsilon();
+  bool tmp;
+  int i;
+
+  assert(type() == LEAVE);
+  assert(allow > 0.0);
+
+  for (i = dim() - 1; i >= 0; --i) {
+    tmp = !isBasic(coId(i));
+
+    if ((*theCoUbound)[i] + allow <= (*theCoPvec)[i] && tmp) {
+      if ((*theCoUbound)[i] != (*theCoLbound)[i])
+        shiftUCbound(i, (*theCoPvec)[i] +
+                            random.next((double)minrandom, (double)maxrandom));
+      else {
+        shiftUCbound(i, (*theCoPvec)[i]);
+        (*theCoLbound)[i] = (*theCoUbound)[i];
       }
-      else if((*theCoLbound)[i] - allow >= (*theCoPvec)[i] && tmp)
-      {
-         if((*theCoUbound)[i] != (*theCoLbound)[i])
-            shiftLCbound(i, (*theCoPvec)[i] - random.next((double)minrandom, (double)maxrandom));
-         else
-         {
-            shiftLCbound(i, (*theCoPvec)[i]);
-            (*theCoUbound)[i] = (*theCoLbound)[i];
-         }
+    } else if ((*theCoLbound)[i] - allow >= (*theCoPvec)[i] && tmp) {
+      if ((*theCoUbound)[i] != (*theCoLbound)[i])
+        shiftLCbound(i, (*theCoPvec)[i] -
+                            random.next((double)minrandom, (double)maxrandom));
+      else {
+        shiftLCbound(i, (*theCoPvec)[i]);
+        (*theCoUbound)[i] = (*theCoLbound)[i];
       }
-   }
-
-   for(i = coDim() - 1; i >= 0; --i)
-   {
-      tmp = !isBasic(id(i));
-
-      if((*theUbound)[i] + allow <= (*thePvec)[i] && tmp)
-      {
-         if((*theUbound)[i] != (*theLbound)[i])
-            shiftUPbound(i, (*thePvec)[i] + random.next((double)minrandom, (double)maxrandom));
-         else
-         {
-            shiftUPbound(i, (*thePvec)[i]);
-            (*theLbound)[i] = (*theUbound)[i];
-         }
+    }
+  }
+
+  for (i = coDim() - 1; i >= 0; --i) {
+    tmp = !isBasic(id(i));
+
+    if ((*theUbound)[i] + allow <= (*thePvec)[i] && tmp) {
+      if ((*theUbound)[i] != (*theLbound)[i])
+        shiftUPbound(i, (*thePvec)[i] +
+                            random.next((double)minrandom, (double)maxrandom));
+      else {
+        shiftUPbound(i, (*thePvec)[i]);
+        (*theLbound)[i] = (*theUbound)[i];
       }
-      else if((*theLbound)[i] - allow >= (*thePvec)[i] && tmp)
-      {
-         if((*theUbound)[i] != (*theLbound)[i])
-            shiftLPbound(i, (*thePvec)[i] - random.next((double)minrandom, (double)maxrandom));
-         else
-         {
-            shiftLPbound(i, (*thePvec)[i]);
-            (*theUbound)[i] = (*theLbound)[i];
-         }
+    } else if ((*theLbound)[i] - allow >= (*thePvec)[i] && tmp) {
+      if ((*theUbound)[i] != (*theLbound)[i])
+        shiftLPbound(i, (*thePvec)[i] -
+                            random.next((double)minrandom, (double)maxrandom));
+      else {
+        shiftLPbound(i, (*thePvec)[i]);
+        (*theUbound)[i] = (*theLbound)[i];
       }
-   }
+    }
+  }
 
 #ifndef NDEBUG
-   testBounds();
-   MSG_DEBUG(std::cout << "DSHIFT02 shiftPvec: OK" << std::endl;)
+  testBounds();
+  MSG_DEBUG(std::cout << "DSHIFT02 shiftPvec: OK" << std::endl;)
 #endif
 }
 // -----------------------------------------------------------------
 template <class R>
-void SPxSolverBase<R>::perturbMin(
-   const UpdateVector<R>& uvec,
-   VectorBase<R>& p_low,
-   VectorBase<R>& p_up,
-   R eps,
-   R p_delta,
-   int start,
-   int incr)
-{
-   assert(uvec.dim() == p_low.dim());
-   assert(uvec.dim() == p_up.dim());
-
-   const R* vec = uvec.get_const_ptr();
-   R minrandom = 10.0 * p_delta;
-   R maxrandom = 100.0 * p_delta;
-   R x, l, u;
-   int i;
-
-   if(fullPerturbation)
-   {
-      eps = p_delta;
-
-      for(i = uvec.dim() - start - 1; i >= 0; i -= incr)
-      {
-         u = p_up[i];
-         l = p_low[i];
-         x = vec[i];
-
-         if(LT(u, R(infinity)) && NE(l, u) && u <= x + eps)
-         {
-            p_up[i] = x + random.next((double) minrandom, (double)maxrandom);
-            theShift += p_up[i] - u;
-         }
-
-         if(GT(l, R(-infinity)) && NE(l, u) && l >= x - eps)
-         {
-            p_low[i] = x - random.next((double)minrandom, (double)maxrandom);
-            theShift -= p_low[i] - l;
-         }
+void SPxSolverBase<R>::perturbMin(const UpdateVector<R> &uvec,
+                                  VectorBase<R> &p_low, VectorBase<R> &p_up,
+                                  R eps, R p_delta, int start, int incr) {
+  assert(uvec.dim() == p_low.dim());
+  assert(uvec.dim() == p_up.dim());
+
+  const R *vec = uvec.get_const_ptr();
+  R minrandom = 10.0 * p_delta;
+  R maxrandom = 100.0 * p_delta;
+  R x, l, u;
+  int i;
+
+  if (fullPerturbation) {
+    eps = p_delta;
+
+    for (i = uvec.dim() - start - 1; i >= 0; i -= incr) {
+      u = p_up[i];
+      l = p_low[i];
+      x = vec[i];
+
+      if (LT(u, R(infinity)) && NE(l, u) && u <= x + eps) {
+        p_up[i] = x + random.next((double)minrandom, (double)maxrandom);
+        theShift += p_up[i] - u;
       }
-   }
-   else
-   {
-      const R* upd = uvec.delta().values();
-      const IdxSet& idx = uvec.delta().indices();
-
-      for(int j = uvec.delta().size() - start - 1; j >= 0; j -= incr)
-      {
-         i = idx.index(j);
-         x = upd[i];
-         u = p_up[i];
-         l = p_low[i];
-
-         // do not permute these bounds! c.f. with computeFrhs2() in spxvecs.cpp
-         if(this->dualStatus(this->baseId(i)) == SPxBasisBase<R>::Desc::D_ON_BOTH)
-         {
-            continue;
-         }
-
-         if(x < -eps)
-         {
-            if(LT(u, R(infinity)) && NE(l, u) && vec[i] >= u - eps)
-            {
-               p_up[i] = vec[i] + random.next((double)minrandom, (double)maxrandom);
-               theShift += p_up[i] - u;
-            }
-         }
-         else if(x > eps)
-         {
-            if(GT(l, R(-infinity)) && NE(l, u) && vec[i] <= l + eps)
-            {
-               p_low[i] = vec[i] - random.next((double)minrandom, (double)maxrandom);
-               theShift -= p_low[i] - l;
-            }
-         }
+
+      if (GT(l, R(-infinity)) && NE(l, u) && l >= x - eps) {
+        p_low[i] = x - random.next((double)minrandom, (double)maxrandom);
+        theShift -= p_low[i] - l;
+      }
+    }
+  } else {
+    const R *upd = uvec.delta().values();
+    const IdxSet &idx = uvec.delta().indices();
+
+    for (int j = uvec.delta().size() - start - 1; j >= 0; j -= incr) {
+      i = idx.index(j);
+      x = upd[i];
+      u = p_up[i];
+      l = p_low[i];
+
+      // do not permute these bounds! c.f. with computeFrhs2() in spxvecs.cpp
+      if (this->dualStatus(this->baseId(i)) ==
+          SPxBasisBase<R>::Desc::D_ON_BOTH) {
+        continue;
       }
-   }
+
+      if (x < -eps) {
+        if (LT(u, R(infinity)) && NE(l, u) && vec[i] >= u - eps) {
+          p_up[i] = vec[i] + random.next((double)minrandom, (double)maxrandom);
+          theShift += p_up[i] - u;
+        }
+      } else if (x > eps) {
+        if (GT(l, R(-infinity)) && NE(l, u) && vec[i] <= l + eps) {
+          p_low[i] = vec[i] - random.next((double)minrandom, (double)maxrandom);
+          theShift -= p_low[i] - l;
+        }
+      }
+    }
+  }
 }
 // -----------------------------------------------------------------
 template <class R>
-void SPxSolverBase<R>::perturbMax(
-   const UpdateVector<R>& uvec,
-   VectorBase<R>& p_low,
-   VectorBase<R>& p_up,
-   R eps,
-   R p_delta,
-   int start,
-   int incr)
-{
-   assert(uvec.dim() == p_low.dim());
-   assert(uvec.dim() == p_up.dim());
-
-   const R* vec = uvec.get_const_ptr();
-   R minrandom = 10.0 * p_delta;
-   R maxrandom = 100.0 * p_delta;
-   R x, l, u;
-   int i;
-
-   if(fullPerturbation)
-   {
-      eps = p_delta;
-
-      for(i = uvec.dim() - start - 1; i >= 0; i -= incr)
-      {
-         u = p_up[i];
-         l = p_low[i];
-         x = vec[i];
-
-         if(LT(u, R(infinity)) && NE(l, u) && u <= x + eps)
-         {
-            p_up[i] = x + random.next((double)minrandom, (double)maxrandom);
-            theShift += p_up[i] - u;
-         }
-
-         if(GT(l, R(-infinity)) && NE(l, u) && l >= x - eps)
-         {
-            p_low[i] = x - random.next((double)minrandom, (double)maxrandom);
-            theShift -= p_low[i] - l;
-         }
+void SPxSolverBase<R>::perturbMax(const UpdateVector<R> &uvec,
+                                  VectorBase<R> &p_low, VectorBase<R> &p_up,
+                                  R eps, R p_delta, int start, int incr) {
+  assert(uvec.dim() == p_low.dim());
+  assert(uvec.dim() == p_up.dim());
+
+  const R *vec = uvec.get_const_ptr();
+  R minrandom = 10.0 * p_delta;
+  R maxrandom = 100.0 * p_delta;
+  R x, l, u;
+  int i;
+
+  if (fullPerturbation) {
+    eps = p_delta;
+
+    for (i = uvec.dim() - start - 1; i >= 0; i -= incr) {
+      u = p_up[i];
+      l = p_low[i];
+      x = vec[i];
+
+      if (LT(u, R(infinity)) && NE(l, u) && u <= x + eps) {
+        p_up[i] = x + random.next((double)minrandom, (double)maxrandom);
+        theShift += p_up[i] - u;
       }
-   }
-   else
-   {
-      const R* upd = uvec.delta().values();
-      const IdxSet& idx = uvec.delta().indices();
-
-      for(int j = uvec.delta().size() - start - 1; j >= 0; j -= incr)
-      {
-         i = idx.index(j);
-         x = upd[i];
-         u = p_up[i];
-         l = p_low[i];
-
-         // do not permute these bounds! c.f. computeFrhs2() in spxvecs.cpp
-         if(this->dualStatus(this->baseId(i)) == SPxBasisBase<R>::Desc::D_ON_BOTH)
-         {
-            continue;
-         }
-
-         if(x > eps)
-         {
-            if(LT(u, R(infinity)) && NE(l, u) && vec[i] >= u - eps)
-            {
-               p_up[i] = vec[i] + random.next((double)minrandom, (double)maxrandom);
-               theShift += p_up[i] - u;
-            }
-         }
-         else if(x < -eps)
-         {
-            if(GT(l, R(-infinity)) && NE(l, u) && vec[i] <= l + eps)
-            {
-               p_low[i] = vec[i] - random.next((double)minrandom, (double)maxrandom);
-               theShift -= p_low[i] - l;
-            }
-         }
+
+      if (GT(l, R(-infinity)) && NE(l, u) && l >= x - eps) {
+        p_low[i] = x - random.next((double)minrandom, (double)maxrandom);
+        theShift -= p_low[i] - l;
+      }
+    }
+  } else {
+    const R *upd = uvec.delta().values();
+    const IdxSet &idx = uvec.delta().indices();
+
+    for (int j = uvec.delta().size() - start - 1; j >= 0; j -= incr) {
+      i = idx.index(j);
+      x = upd[i];
+      u = p_up[i];
+      l = p_low[i];
+
+      // do not permute these bounds! c.f. computeFrhs2() in spxvecs.cpp
+      if (this->dualStatus(this->baseId(i)) ==
+          SPxBasisBase<R>::Desc::D_ON_BOTH) {
+        continue;
       }
-   }
-}
 
-template <class R>
-void SPxSolverBase<R>::perturbMinEnter(void)
-{
-   MSG_DEBUG(std::cout << "DSHIFT03 iteration= " << this->iteration() << ": perturbing " << shift();)
-   fVec().delta().setup();
-   perturbMin(fVec(), lbBound(), ubBound(), epsilon(), entertol());
-   MSG_DEBUG(std::cout << "\t->" << shift() << std::endl;)
+      if (x > eps) {
+        if (LT(u, R(infinity)) && NE(l, u) && vec[i] >= u - eps) {
+          p_up[i] = vec[i] + random.next((double)minrandom, (double)maxrandom);
+          theShift += p_up[i] - u;
+        }
+      } else if (x < -eps) {
+        if (GT(l, R(-infinity)) && NE(l, u) && vec[i] <= l + eps) {
+          p_low[i] = vec[i] - random.next((double)minrandom, (double)maxrandom);
+          theShift -= p_low[i] - l;
+        }
+      }
+    }
+  }
 }
 
-
-template <class R>
-void SPxSolverBase<R>::perturbMaxEnter(void)
-{
-   MSG_DEBUG(std::cout << "DSHIFT04 iteration= " << this->iteration() << ": perturbing " << shift();)
-   fVec().delta().setup();
-   perturbMax(fVec(), lbBound(), ubBound(), epsilon(), entertol());
-   MSG_DEBUG(std::cout << "\t->" << shift() << std::endl;)
+template <class R> void SPxSolverBase<R>::perturbMinEnter(void) {
+  MSG_DEBUG(std::cout << "DSHIFT03 iteration= " << this->iteration()
+                      << ": perturbing " << shift();)
+  fVec().delta().setup();
+  perturbMin(fVec(), lbBound(), ubBound(), epsilon(), entertol());
+  MSG_DEBUG(std::cout << "\t->" << shift() << std::endl;)
 }
 
+template <class R> void SPxSolverBase<R>::perturbMaxEnter(void) {
+  MSG_DEBUG(std::cout << "DSHIFT04 iteration= " << this->iteration()
+                      << ": perturbing " << shift();)
+  fVec().delta().setup();
+  perturbMax(fVec(), lbBound(), ubBound(), epsilon(), entertol());
+  MSG_DEBUG(std::cout << "\t->" << shift() << std::endl;)
+}
 
 template <class R>
 R SPxSolverBase<R>::perturbMin(
-   const UpdateVector<R>& uvec,
-   VectorBase<R>& p_low,
-   VectorBase<R>& p_up,
-   R eps,
-   R p_delta,
-   const typename SPxBasisBase<R>::Desc::Status* stat,
-   int start,
-   int incr)
-{
-   assert(uvec.dim() == p_low.dim());
-   assert(uvec.dim() == p_up.dim());
-
-   const R* vec = uvec.get_const_ptr();
-   R minrandom = 10.0 * p_delta;
-   R maxrandom = 100.0 * p_delta;
-   R x, l, u;
-   int i;
-   R l_theShift = 0;
-
-   if(fullPerturbation)
-   {
-      eps = p_delta;
-
-      for(i = uvec.dim() - start - 1; i >= 0; i -= incr)
-      {
-         u = p_up[i];
-         l = p_low[i];
-         x = vec[i];
-
-         if(LT(u, R(infinity)) && NE(l, u) && u <= x + eps && rep() * stat[i] < 0)
-         {
-            p_up[i] = vec[i] + random.next((double)minrandom, (double)maxrandom);
-            l_theShift += p_up[i] - u;
-         }
-
-         if(GT(l, R(-infinity)) && NE(l, u) && l >= x - eps && rep() * stat[i] < 0)
-         {
-            p_low[i] = vec[i] - random.next((double)minrandom, (double)maxrandom);
-            l_theShift -= p_low[i] - l;
-         }
+    const UpdateVector<R> &uvec, VectorBase<R> &p_low, VectorBase<R> &p_up,
+    R eps, R p_delta, const typename SPxBasisBase<R>::Desc::Status *stat,
+    int start, int incr) {
+  assert(uvec.dim() == p_low.dim());
+  assert(uvec.dim() == p_up.dim());
+
+  const R *vec = uvec.get_const_ptr();
+  R minrandom = 10.0 * p_delta;
+  R maxrandom = 100.0 * p_delta;
+  R x, l, u;
+  int i;
+  R l_theShift = 0;
+
+  if (fullPerturbation) {
+    eps = p_delta;
+
+    for (i = uvec.dim() - start - 1; i >= 0; i -= incr) {
+      u = p_up[i];
+      l = p_low[i];
+      x = vec[i];
+
+      if (LT(u, R(infinity)) && NE(l, u) && u <= x + eps &&
+          static_cast<int>(rep()) * stat[i] < 0) {
+        p_up[i] = vec[i] + random.next((double)minrandom, (double)maxrandom);
+        l_theShift += p_up[i] - u;
       }
-   }
-   else
-   {
-      const R* upd = uvec.delta().values();
-      const IdxSet& idx = uvec.delta().indices();
-
-      for(int j = uvec.delta().size() - start - 1; j >= 0; j -= incr)
-      {
-         i = idx.index(j);
-         x = upd[i];
-         u = p_up[i];
-         l = p_low[i];
-
-         if(x < -eps)
-         {
-            if(LT(u, R(infinity)) && NE(l, u) && vec[i] >= u - eps && rep() * stat[i] < 0)
-            {
-               p_up[i] = vec[i] + random.next((double)minrandom, (double)maxrandom);
-               l_theShift += p_up[i] - u;
-            }
-         }
-         else if(x > eps)
-         {
-            if(GT(l, R(-infinity)) && NE(l, u) && vec[i] <= l + eps && rep() * stat[i] < 0)
-            {
-               p_low[i] = vec[i] - random.next((double)minrandom, (double)maxrandom);
-               l_theShift -= p_low[i] - l;
-            }
-         }
+
+      if (GT(l, R(-infinity)) && NE(l, u) && l >= x - eps &&
+          static_cast<int>(rep()) * stat[i] < 0) {
+        p_low[i] = vec[i] - random.next((double)minrandom, (double)maxrandom);
+        l_theShift -= p_low[i] - l;
       }
-   }
+    }
+  } else {
+    const R *upd = uvec.delta().values();
+    const IdxSet &idx = uvec.delta().indices();
+
+    for (int j = uvec.delta().size() - start - 1; j >= 0; j -= incr) {
+      i = idx.index(j);
+      x = upd[i];
+      u = p_up[i];
+      l = p_low[i];
+
+      if (x < -eps) {
+        if (LT(u, R(infinity)) && NE(l, u) && vec[i] >= u - eps &&
+            static_cast<int>(rep()) * stat[i] < 0) {
+          p_up[i] = vec[i] + random.next((double)minrandom, (double)maxrandom);
+          l_theShift += p_up[i] - u;
+        }
+      } else if (x > eps) {
+        if (GT(l, R(-infinity)) && NE(l, u) && vec[i] <= l + eps &&
+            static_cast<int>(rep()) * stat[i] < 0) {
+          p_low[i] = vec[i] - random.next((double)minrandom, (double)maxrandom);
+          l_theShift -= p_low[i] - l;
+        }
+      }
+    }
+  }
 
-   return l_theShift;
+  return l_theShift;
 }
 
 template <class R>
 R SPxSolverBase<R>::perturbMax(
-   const UpdateVector<R>& uvec,
-   VectorBase<R>& p_low,
-   VectorBase<R>& p_up,
-   R eps,
-   R p_delta,
-   const typename SPxBasisBase<R>::Desc::Status* stat,
-   int start,
-   int incr)
-{
-   assert(uvec.dim() == p_low.dim());
-   assert(uvec.dim() == p_up.dim());
-
-   const R* vec = uvec.get_const_ptr();
-   R minrandom = 10.0 * p_delta;
-   R maxrandom = 100.0 * p_delta;
-   R x, l, u;
-   int i;
-   R l_theShift = 0;
-
-   if(fullPerturbation)
-   {
-      eps = p_delta;
-
-      for(i = uvec.dim() - start - 1; i >= 0; i -= incr)
-      {
-         u = p_up[i];
-         l = p_low[i];
-         x = vec[i];
-
-         if(LT(u, R(infinity)) && NE(l, u) && u <= x + eps && rep() * stat[i] < 0)
-         {
-            p_up[i] = vec[i] + random.next((double)minrandom, (double)maxrandom);
-            l_theShift += p_up[i] - u;
-         }
-
-         if(GT(l, R(-infinity)) && NE(l, u) && l >= x - eps && rep() * stat[i] < 0)
-         {
-            p_low[i] = vec[i] - random.next((double)minrandom, (double)maxrandom);
-            l_theShift -= p_low[i] - l;
-         }
+    const UpdateVector<R> &uvec, VectorBase<R> &p_low, VectorBase<R> &p_up,
+    R eps, R p_delta, const typename SPxBasisBase<R>::Desc::Status *stat,
+    int start, int incr) {
+  assert(uvec.dim() == p_low.dim());
+  assert(uvec.dim() == p_up.dim());
+
+  const R *vec = uvec.get_const_ptr();
+  R minrandom = 10.0 * p_delta;
+  R maxrandom = 100.0 * p_delta;
+  R x, l, u;
+  int i;
+  R l_theShift = 0;
+
+  if (fullPerturbation) {
+    eps = p_delta;
+
+    for (i = uvec.dim() - start - 1; i >= 0; i -= incr) {
+      u = p_up[i];
+      l = p_low[i];
+      x = vec[i];
+
+      if (LT(u, R(infinity)) && NE(l, u) && u <= x + eps &&
+          static_cast<int>(rep()) * stat[i] < 0) {
+        p_up[i] = vec[i] + random.next((double)minrandom, (double)maxrandom);
+        l_theShift += p_up[i] - u;
+      }
+
+      if (GT(l, R(-infinity)) && NE(l, u) && l >= x - eps &&
+          static_cast<int>(rep()) * stat[i] < 0) {
+        p_low[i] = vec[i] - random.next((double)minrandom, (double)maxrandom);
+        l_theShift -= p_low[i] - l;
       }
-   }
-   else
-   {
-      const R* upd = uvec.delta().values();
-      const IdxSet& idx = uvec.delta().indices();
-
-      for(int j = uvec.delta().size() - start - 1; j >= 0; j -= incr)
-      {
-         i = idx.index(j);
-         x = upd[i];
-         u = p_up[i];
-         l = p_low[i];
-
-         if(x > eps)
-         {
-            if(LT(u, R(infinity)) && NE(l, u) && vec[i] >= u - eps && rep() * stat[i] < 0)
-            {
-               p_up[i] = vec[i] + random.next((double)minrandom, (double)maxrandom);
-               l_theShift += p_up[i] - u;
-            }
-         }
-         else if(x < -eps)
-         {
-            if(GT(l, R(-infinity)) && NE(l, u) && vec[i] <= l + eps && rep() * stat[i] < 0)
-            {
-               p_low[i] = vec[i] - random.next((double)minrandom, (double)maxrandom);
-               l_theShift -= p_low[i] - l;
-            }
-         }
+    }
+  } else {
+    const R *upd = uvec.delta().values();
+    const IdxSet &idx = uvec.delta().indices();
+
+    for (int j = uvec.delta().size() - start - 1; j >= 0; j -= incr) {
+      i = idx.index(j);
+      x = upd[i];
+      u = p_up[i];
+      l = p_low[i];
+
+      if (x > eps) {
+        if (LT(u, R(infinity)) && NE(l, u) && vec[i] >= u - eps &&
+            static_cast<int>(rep()) * stat[i] < 0) {
+          p_up[i] = vec[i] + random.next((double)minrandom, (double)maxrandom);
+          l_theShift += p_up[i] - u;
+        }
+      } else if (x < -eps) {
+        if (GT(l, R(-infinity)) && NE(l, u) && vec[i] <= l + eps &&
+            static_cast<int>(rep()) * stat[i] < 0) {
+          p_low[i] = vec[i] - random.next((double)minrandom, (double)maxrandom);
+          l_theShift -= p_low[i] - l;
+        }
       }
-   }
+    }
+  }
 
-   return l_theShift;
+  return l_theShift;
 }
 
-
-template <class R>
-void SPxSolverBase<R>::perturbMinLeave(void)
-{
-   MSG_DEBUG(std::cout << "DSHIFT05 iteration= " << this->iteration() << ": perturbing " << shift();)
-   pVec().delta().setup();
-   coPvec().delta().setup();
-   theShift += perturbMin(pVec(), lpBound(), upBound(), epsilon(), leavetol(),
-                          this->desc().status(), 0, 1);
-   theShift += perturbMin(coPvec(), lcBound(), ucBound(), epsilon(), leavetol(),
-                          this->desc().coStatus(), 0, 1);
-   MSG_DEBUG(std::cout << "\t->" << shift() << std::endl;)
+template <class R> void SPxSolverBase<R>::perturbMinLeave(void) {
+  MSG_DEBUG(std::cout << "DSHIFT05 iteration= " << this->iteration()
+                      << ": perturbing " << shift();)
+  pVec().delta().setup();
+  coPvec().delta().setup();
+  theShift += perturbMin(pVec(), lpBound(), upBound(), epsilon(), leavetol(),
+                         this->desc().status(), 0, 1);
+  theShift += perturbMin(coPvec(), lcBound(), ucBound(), epsilon(), leavetol(),
+                         this->desc().coStatus(), 0, 1);
+  MSG_DEBUG(std::cout << "\t->" << shift() << std::endl;)
 }
 
-
-template <class R>
-void SPxSolverBase<R>::perturbMaxLeave(void)
-{
-   MSG_DEBUG(std::cout << "DSHIFT06 iteration= " << this->iteration() << ": perturbing " << shift();)
-   pVec().delta().setup();
-   coPvec().delta().setup();
-   theShift += perturbMax(pVec(), lpBound(), upBound(), epsilon(), leavetol(),
-                          this->desc().status(), 0, 1);
-   theShift += perturbMax(coPvec(), lcBound(), ucBound(), epsilon(), leavetol(),
-                          this->desc().coStatus(), 0, 1);
-   MSG_DEBUG(std::cout << "\t->" << shift() << std::endl;)
+template <class R> void SPxSolverBase<R>::perturbMaxLeave(void) {
+  MSG_DEBUG(std::cout << "DSHIFT06 iteration= " << this->iteration()
+                      << ": perturbing " << shift();)
+  pVec().delta().setup();
+  coPvec().delta().setup();
+  theShift += perturbMax(pVec(), lpBound(), upBound(), epsilon(), leavetol(),
+                         this->desc().status(), 0, 1);
+  theShift += perturbMax(coPvec(), lcBound(), ucBound(), epsilon(), leavetol(),
+                         this->desc().coStatus(), 0, 1);
+  MSG_DEBUG(std::cout << "\t->" << shift() << std::endl;)
 }
 
-
-template <class R>
-void SPxSolverBase<R>::unShift(void)
-{
-   MSG_INFO3((*this->spxout), (*this->spxout) << "DSHIFT07 = " << "unshifting ..." << std::endl;);
-
-   if(isInitialized())
-   {
-      int i;
-      R t_up, t_low;
-      const typename SPxBasisBase<R>::Desc& ds = this->desc();
-
-      theShift = 0;
-
-      if(type() == ENTER)
-      {
-         R eps = entertol();
-
-         if(rep() == COLUMN)
-         {
-            for(i = dim(); i-- > 0;)
-            {
-               SPxId l_id = this->baseId(i);
-               int l_num = this->number(l_id);
-
-               if(l_id.type() == SPxId::ROW_ID)
-               {
-                  t_up = -this->lhs(l_num);
-                  t_low = -this->rhs(l_num);
-               }
-               else
-               {
-                  assert(l_id.type() == SPxId::COL_ID);
-                  t_up = this->upper(l_num);
-                  t_low = this->lower(l_num);
-               }
-
-               if(t_up != t_low)
-               {
-                  if((*theFvec)[i] < t_up + eps)  // check allowed violation
-                     theUBbound[i] = t_up; // reset shifted bound to original
-                  else if((*theFvec)[i] > t_up)  // shifted bound is required for feasibility
-                     theShift += theUBbound[i] - t_up;
-
-                  if((*theFvec)[i] > t_low - eps)  // check allowed violation
-                     theLBbound[i] = t_low; // reset shifted bound to original
-                  else if((*theFvec)[i] < t_low)  // shifted bound is required for feasibility
-                     theShift -= theLBbound[i] - t_low;
-               }
-               else
-               {
-                  if(theUBbound[i] > t_up)
-                     theShift += theUBbound[i] - t_up;
-                  else if(theLBbound[i] < t_low)
-                     theShift += t_low - theLBbound[i];
-               }
-            }
-
-            for(i = this->nRows(); i-- > 0;)
-            {
-               if(!isBasic(ds.rowStatus(i)))
-               {
-                  t_up = -this->lhs(i);
-                  t_low = -this->rhs(i);
-
-                  if(theURbound[i] > t_up)  // what about t_up == t_low ?
-                     theShift += theURbound[i] - t_up;
-
-                  if(t_low > theLRbound[i])  // what about t_up == t_low ?
-                     theShift += t_low - theLRbound[i];
-               }
-            }
-
-            for(i = this->nCols(); i-- > 0;)
-            {
-               if(!isBasic(ds.colStatus(i)))
-               {
-                  t_up = this->upper(i);
-                  t_low = this->lower(i);
-
-                  if(theUCbound[i] > t_up)  // what about t_up == t_low ?
-                     theShift += theUCbound[i] - t_up;
-
-                  if(t_low > theLCbound[i])  // what about t_up == t_low ?
-                     theShift += t_low - theLCbound[i];
-               }
-            }
-         }
-         else
-         {
-            assert(rep() == ROW);
-
-            for(i = dim(); i-- > 0;)
-            {
-               SPxId l_id = this->baseId(i);
-               int l_num = this->number(l_id);
-               t_up = t_low = 0;
-
-               if(l_id.type() == SPxId::ROW_ID)
-                  clearDualBounds(ds.rowStatus(l_num), t_up, t_low);
-               else
-                  clearDualBounds(ds.colStatus(l_num), t_up, t_low);
-
-               if(theUBbound[i] != theLBbound[i])
-               {
-                  if(theUBbound[i] > t_up)
-                     theShift += theUBbound[i] - t_up;
-                  else
-                     theShift -= theUBbound[i] - t_up;
-               }
-               else
-               {
-                  /* if the basic (primal or dual) variable is fixed (e.g., basis status P_FREE in row representation)
-                   * then shiftFvec() and shiftPvec() do not relax the bounds, but shift both, hence they may be outside
-                   * of [t_low,t_up] */
-                  assert(theLBbound[i] == theUBbound[i] || theUBbound[i] >= t_up);
-                  assert(theLBbound[i] == theUBbound[i] || theLBbound[i] <= t_low);
-
-                  if((*theFvec)[i] < t_up - eps)
-                     theUBbound[i] = t_up;
-                  else if((*theFvec)[i] > t_up)
-                     theShift += theUBbound[i] - t_up;
-
-                  if((*theFvec)[i] > t_low + eps)
-                     theLBbound[i] = t_low;
-                  else if((*theFvec)[i] < t_low)
-                     theShift -= theLBbound[i] - t_low;
-               }
-            }
-
-            for(i = this->nRows(); i-- > 0;)
-            {
-               if(!isBasic(ds.rowStatus(i)))
-               {
-                  t_up = t_low = 0;
-                  clearDualBounds(ds.rowStatus(i), t_up, t_low);
-
-                  if(theURbound[i] > t_up)  // what about t_up == t_low ?
-                     theShift += theURbound[i] - t_up;
-
-                  if(t_low > theLRbound[i])  // what about t_up == t_low ?
-                     theShift += t_low - theLRbound[i];
-               }
-            }
-
-            for(i = this->nCols(); i-- > 0;)
-            {
-               if(!isBasic(ds.colStatus(i)))
-               {
-                  t_up = t_low = 0;
-                  clearDualBounds(ds.colStatus(i), t_up, t_low);
-
-                  if(theUCbound[i] > t_up)  // what about t_up == t_low ?
-                     theShift += theUCbound[i] - t_up;
-
-                  if(t_low > theLCbound[i])  // what about t_up == t_low ?
-                     theShift += t_low - theLCbound[i];
-               }
-            }
-         }
+template <class R> void SPxSolverBase<R>::unShift(void) {
+  MSG_INFO3((*this->spxout), (*this->spxout) << "DSHIFT07 = "
+                                             << "unshifting ..." << std::endl;);
+
+  if (isInitialized()) {
+    int i;
+    R t_up, t_low;
+    const typename SPxBasisBase<R>::Desc &ds = this->desc();
+
+    theShift = 0;
+
+    if (type() == ENTER) {
+      R eps = entertol();
+
+      if (rep() == COLUMN) {
+        for (i = dim(); i-- > 0;) {
+          SPxId l_id = this->baseId(i);
+          int l_num = this->number(l_id);
+
+          if (l_id.type() == SPxId::ROW_ID) {
+            t_up = -this->lhs(l_num);
+            t_low = -this->rhs(l_num);
+          } else {
+            assert(l_id.type() == SPxId::COL_ID);
+            t_up = this->upper(l_num);
+            t_low = this->lower(l_num);
+          }
+
+          if (t_up != t_low) {
+            if ((*theFvec)[i] < t_up + eps) // check allowed violation
+              theUBbound[i] = t_up;         // reset shifted bound to original
+            else if ((*theFvec)[i] >
+                     t_up) // shifted bound is required for feasibility
+              theShift += theUBbound[i] - t_up;
+
+            if ((*theFvec)[i] > t_low - eps) // check allowed violation
+              theLBbound[i] = t_low;         // reset shifted bound to original
+            else if ((*theFvec)[i] <
+                     t_low) // shifted bound is required for feasibility
+              theShift -= theLBbound[i] - t_low;
+          } else {
+            if (theUBbound[i] > t_up)
+              theShift += theUBbound[i] - t_up;
+            else if (theLBbound[i] < t_low)
+              theShift += t_low - theLBbound[i];
+          }
+        }
+
+        for (i = this->nRows(); i-- > 0;) {
+          if (!isBasic(ds.rowStatus(i))) {
+            t_up = -this->lhs(i);
+            t_low = -this->rhs(i);
+
+            if (theURbound[i] > t_up) // what about t_up == t_low ?
+              theShift += theURbound[i] - t_up;
+
+            if (t_low > theLRbound[i]) // what about t_up == t_low ?
+              theShift += t_low - theLRbound[i];
+          }
+        }
+
+        for (i = this->nCols(); i-- > 0;) {
+          if (!isBasic(ds.colStatus(i))) {
+            t_up = this->upper(i);
+            t_low = this->lower(i);
+
+            if (theUCbound[i] > t_up) // what about t_up == t_low ?
+              theShift += theUCbound[i] - t_up;
+
+            if (t_low > theLCbound[i]) // what about t_up == t_low ?
+              theShift += t_low - theLCbound[i];
+          }
+        }
+      } else {
+        assert(rep() == ROW);
+
+        for (i = dim(); i-- > 0;) {
+          SPxId l_id = this->baseId(i);
+          int l_num = this->number(l_id);
+          t_up = t_low = 0;
+
+          if (l_id.type() == SPxId::ROW_ID)
+            clearDualBounds(ds.rowStatus(l_num), t_up, t_low);
+          else
+            clearDualBounds(ds.colStatus(l_num), t_up, t_low);
+
+          if (theUBbound[i] != theLBbound[i]) {
+            if (theUBbound[i] > t_up)
+              theShift += theUBbound[i] - t_up;
+            else
+              theShift -= theUBbound[i] - t_up;
+          } else {
+            /* if the basic (primal or dual) variable is fixed (e.g., basis
+             * status P_FREE in row representation) then shiftFvec() and
+             * shiftPvec() do not relax the bounds, but shift both, hence they
+             * may be outside of [t_low,t_up] */
+            assert(theLBbound[i] == theUBbound[i] || theUBbound[i] >= t_up);
+            assert(theLBbound[i] == theUBbound[i] || theLBbound[i] <= t_low);
+
+            if ((*theFvec)[i] < t_up - eps)
+              theUBbound[i] = t_up;
+            else if ((*theFvec)[i] > t_up)
+              theShift += theUBbound[i] - t_up;
+
+            if ((*theFvec)[i] > t_low + eps)
+              theLBbound[i] = t_low;
+            else if ((*theFvec)[i] < t_low)
+              theShift -= theLBbound[i] - t_low;
+          }
+        }
+
+        for (i = this->nRows(); i-- > 0;) {
+          if (!isBasic(ds.rowStatus(i))) {
+            t_up = t_low = 0;
+            clearDualBounds(ds.rowStatus(i), t_up, t_low);
+
+            if (theURbound[i] > t_up) // what about t_up == t_low ?
+              theShift += theURbound[i] - t_up;
+
+            if (t_low > theLRbound[i]) // what about t_up == t_low ?
+              theShift += t_low - theLRbound[i];
+          }
+        }
+
+        for (i = this->nCols(); i-- > 0;) {
+          if (!isBasic(ds.colStatus(i))) {
+            t_up = t_low = 0;
+            clearDualBounds(ds.colStatus(i), t_up, t_low);
+
+            if (theUCbound[i] > t_up) // what about t_up == t_low ?
+              theShift += theUCbound[i] - t_up;
+
+            if (t_low > theLCbound[i]) // what about t_up == t_low ?
+              theShift += t_low - theLCbound[i];
+          }
+        }
       }
-      else
-      {
-         assert(type() == LEAVE);
-
-         R eps = leavetol();
-
-         if(rep() == COLUMN)
-         {
-            for(i = this->nRows(); i-- > 0;)
-            {
-               t_up = t_low = this->maxRowObj(i);
-               clearDualBounds(ds.rowStatus(i), t_up, t_low);
-
-               if(!isBasic(ds.rowStatus(i)))
-               {
-                  if((*theCoPvec)[i] < t_up + eps)
-                  {
-                     theURbound[i] = t_up; // reset bound to original value
-
-                     if(t_up == t_low)
-                        theLRbound[i] = t_low; // for fixed rows we change both bounds
-                  }
-                  else
-                     theShift += theURbound[i] - t_up;
-
-                  if((*theCoPvec)[i] > t_low - eps)
-                  {
-                     theLRbound[i] = t_low; // reset bound to original value
-
-                     if(t_up == t_low)
-                        theURbound[i] = t_up; // for fixed rows we change both bounds
-                  }
-                  else
-                     theShift += t_low - theLRbound[i];
-               }
-               else if(theURbound[i] > t_up)
-                  theShift += theURbound[i] - t_up;
-               else if(theLRbound[i] < t_low)
-                  theShift += t_low - theLRbound[i];
-            }
-
-            for(i = this->nCols(); i-- > 0;)
-            {
-               t_up = t_low = -this->maxObj(i);
-               clearDualBounds(ds.colStatus(i), t_low, t_up);
-
-               if(!isBasic(ds.colStatus(i)))
-               {
-                  if((*thePvec)[i] < -t_up + eps)
-                  {
-                     theUCbound[i] = -t_up; // reset bound to original value
-
-                     if(t_up == t_low)
-                        theLCbound[i] = -t_low; // for fixed variables we change both bounds
-                  }
-                  else
-                     theShift += theUCbound[i] - (-t_up);
-
-                  if((*thePvec)[i] > -t_low - eps)
-                  {
-                     theLCbound[i] = -t_low; // reset bound to original value
-
-                     if(t_up == t_low)
-                        theUCbound[i] = -t_up; // for fixed variables we change both bounds
-                  }
-                  else
-                     theShift += (-t_low) - theLCbound[i];
-               }
-               else if(theUCbound[i] > -t_up)
-                  theShift += theUCbound[i] - (-t_up);
-               else if(theLCbound[i] < -t_low)
-                  theShift += (-t_low) - theLCbound[i];
-            }
-         }
-         else
-         {
-            assert(rep() == ROW);
-
-            for(i = this->nRows(); i-- > 0;)
-            {
-               t_up = this->rhs(i);
-               t_low = this->lhs(i);
-
-               if(t_up == t_low)
-               {
-                  if(theURbound[i] > t_up)
-                     theShift += theURbound[i] - t_up;
-                  else
-                     theShift += t_low - theLRbound[i];
-               }
-               else if(!isBasic(ds.rowStatus(i)))
-               {
-                  if((*thePvec)[i] < t_up + eps)
-                     theURbound[i] = t_up; // reset bound to original value
-                  else
-                     theShift += theURbound[i] - t_up;
-
-                  if((*thePvec)[i] > t_low - eps)
-                     theLRbound[i] = t_low; // reset bound to original value
-                  else
-                     theShift += t_low - theLRbound[i];
-               }
-               else if(theURbound[i] > t_up)
-                  theShift += theURbound[i] - t_up;
-               else if(theLRbound[i] < t_low)
-                  theShift += t_low - theLRbound[i];
-            }
-
-            for(i = this->nCols(); i-- > 0;)
-            {
-               t_up = this->upper(i);
-               t_low = this->lower(i);
-
-               if(t_up == t_low)
-               {
-                  if(theUCbound[i] > t_up)
-                     theShift += theUCbound[i] - t_up;
-                  else
-                     theShift += t_low - theLCbound[i];
-               }
-               else if(!isBasic(ds.colStatus(i)))
-               {
-                  if((*theCoPvec)[i] < t_up + eps)
-                     theUCbound[i] = t_up; // reset bound to original value
-                  else
-                     theShift += theUCbound[i] - t_up;
-
-                  if((*theCoPvec)[i] > t_low - eps)
-                     theLCbound[i] = t_low; // reset bound to original value
-                  else
-                     theShift += t_low - theLCbound[i];
-               }
-               else if(theUCbound[i] > t_up)
-                  theShift += theUCbound[i] - t_up;
-               else if(theLCbound[i] < t_low)
-                  theShift += t_low - theLCbound[i];
-            }
-         }
+    } else {
+      assert(type() == LEAVE);
+
+      R eps = leavetol();
+
+      if (rep() == COLUMN) {
+        for (i = this->nRows(); i-- > 0;) {
+          t_up = t_low = this->maxRowObj(i);
+          clearDualBounds(ds.rowStatus(i), t_up, t_low);
+
+          if (!isBasic(ds.rowStatus(i))) {
+            if ((*theCoPvec)[i] < t_up + eps) {
+              theURbound[i] = t_up; // reset bound to original value
+
+              if (t_up == t_low)
+                theLRbound[i] = t_low; // for fixed rows we change both bounds
+            } else
+              theShift += theURbound[i] - t_up;
+
+            if ((*theCoPvec)[i] > t_low - eps) {
+              theLRbound[i] = t_low; // reset bound to original value
+
+              if (t_up == t_low)
+                theURbound[i] = t_up; // for fixed rows we change both bounds
+            } else
+              theShift += t_low - theLRbound[i];
+          } else if (theURbound[i] > t_up)
+            theShift += theURbound[i] - t_up;
+          else if (theLRbound[i] < t_low)
+            theShift += t_low - theLRbound[i];
+        }
+
+        for (i = this->nCols(); i-- > 0;) {
+          t_up = t_low = -this->maxObj(i);
+          clearDualBounds(ds.colStatus(i), t_low, t_up);
+
+          if (!isBasic(ds.colStatus(i))) {
+            if ((*thePvec)[i] < -t_up + eps) {
+              theUCbound[i] = -t_up; // reset bound to original value
+
+              if (t_up == t_low)
+                theLCbound[i] =
+                    -t_low; // for fixed variables we change both bounds
+            } else
+              theShift += theUCbound[i] - (-t_up);
+
+            if ((*thePvec)[i] > -t_low - eps) {
+              theLCbound[i] = -t_low; // reset bound to original value
+
+              if (t_up == t_low)
+                theUCbound[i] =
+                    -t_up; // for fixed variables we change both bounds
+            } else
+              theShift += (-t_low) - theLCbound[i];
+          } else if (theUCbound[i] > -t_up)
+            theShift += theUCbound[i] - (-t_up);
+          else if (theLCbound[i] < -t_low)
+            theShift += (-t_low) - theLCbound[i];
+        }
+      } else {
+        assert(rep() == ROW);
+
+        for (i = this->nRows(); i-- > 0;) {
+          t_up = this->rhs(i);
+          t_low = this->lhs(i);
+
+          if (t_up == t_low) {
+            if (theURbound[i] > t_up)
+              theShift += theURbound[i] - t_up;
+            else
+              theShift += t_low - theLRbound[i];
+          } else if (!isBasic(ds.rowStatus(i))) {
+            if ((*thePvec)[i] < t_up + eps)
+              theURbound[i] = t_up; // reset bound to original value
+            else
+              theShift += theURbound[i] - t_up;
+
+            if ((*thePvec)[i] > t_low - eps)
+              theLRbound[i] = t_low; // reset bound to original value
+            else
+              theShift += t_low - theLRbound[i];
+          } else if (theURbound[i] > t_up)
+            theShift += theURbound[i] - t_up;
+          else if (theLRbound[i] < t_low)
+            theShift += t_low - theLRbound[i];
+        }
+
+        for (i = this->nCols(); i-- > 0;) {
+          t_up = this->upper(i);
+          t_low = this->lower(i);
+
+          if (t_up == t_low) {
+            if (theUCbound[i] > t_up)
+              theShift += theUCbound[i] - t_up;
+            else
+              theShift += t_low - theLCbound[i];
+          } else if (!isBasic(ds.colStatus(i))) {
+            if ((*theCoPvec)[i] < t_up + eps)
+              theUCbound[i] = t_up; // reset bound to original value
+            else
+              theShift += theUCbound[i] - t_up;
+
+            if ((*theCoPvec)[i] > t_low - eps)
+              theLCbound[i] = t_low; // reset bound to original value
+            else
+              theShift += t_low - theLCbound[i];
+          } else if (theUCbound[i] > t_up)
+            theShift += theUCbound[i] - t_up;
+          else if (theLCbound[i] < t_low)
+            theShift += t_low - theLCbound[i];
+        }
       }
-   }
+    }
+  }
 }
 } // namespace soplex
diff --git a/src/soplex/spxsolve.hpp b/src/soplex/spxsolve.hpp
index 4c47f1d..070ab97 100644
--- a/src/soplex/spxsolve.hpp
+++ b/src/soplex/spxsolve.hpp
@@ -21,2348 +21,2196 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <assert.h>
 #include <iostream>
 
-#include "soplex/spxdefines.h"
 #include "soplex/rational.h"
-#include "soplex/spxsolver.h"
+#include "soplex/spxdefaultrt.h"
+#include "soplex/spxdefines.h"
+#include "soplex/spxout.h"
 #include "soplex/spxpricer.h"
 #include "soplex/spxratiotester.h"
-#include "soplex/spxdefaultrt.h"
+#include "soplex/spxsolver.h"
 #include "soplex/spxstarter.h"
-#include "soplex/spxout.h"
 
 #define MAXCYCLES 400
 #define MAXSTALLS 10000
 #define MAXSTALLRECOVERS 10
 #define MAXREFACPIVOTS 10
 
-namespace soplex
-{
+namespace soplex {
 
 /**@todo check separately for ENTER and LEAVE algorithm */
 template <class R>
-bool SPxSolverBase<R>::precisionReached(R& newpricertol) const
-{
-   R maxViolRedCost;
-   R sumViolRedCost;
-   R maxViolBounds;
-   R sumViolBounds;
-   R maxViolConst;
-   R sumViolConst;
-
-   qualRedCostViolation(maxViolRedCost, sumViolRedCost);
-   qualBoundViolation(maxViolBounds, sumViolBounds);
-   qualConstraintViolation(maxViolConst, sumViolConst);
-
-   // is the solution good enough ?
-   bool reached = maxViolRedCost < opttol() && maxViolBounds < feastol() && maxViolConst < feastol();
-
-   if(!reached)
-   {
-      newpricertol = thepricer->epsilon() / 10.0;
-
-      MSG_INFO3((*this->spxout), (*this->spxout) << "Precision not reached: Pricer tolerance = "
-                << thepricer->epsilon()
-                << " new tolerance = " << newpricertol
-                << std::endl
-                << " maxViolRedCost= " << maxViolRedCost
-                << " maxViolBounds= " << maxViolBounds
-                << " maxViolConst= " << maxViolConst
-                << std::endl
-                << " sumViolRedCost= " << sumViolRedCost
-                << " sumViolBounds= " << sumViolBounds
-                << " sumViolConst= " << sumViolConst
-                << std::endl;);
-   }
-
-   return reached;
+bool SPxSolverBase<R>::precisionReached(R &newpricertol) const {
+  R maxViolRedCost;
+  R sumViolRedCost;
+  R maxViolBounds;
+  R sumViolBounds;
+  R maxViolConst;
+  R sumViolConst;
+
+  qualRedCostViolation(maxViolRedCost, sumViolRedCost);
+  qualBoundViolation(maxViolBounds, sumViolBounds);
+  qualConstraintViolation(maxViolConst, sumViolConst);
+
+  // is the solution good enough ?
+  bool reached = maxViolRedCost < opttol() && maxViolBounds < feastol() &&
+                 maxViolConst < feastol();
+
+  if (!reached) {
+    newpricertol = thepricer->epsilon() / 10.0;
+
+    MSG_INFO3((*this->spxout),
+              (*this->spxout)
+                  << "Precision not reached: Pricer tolerance = "
+                  << thepricer->epsilon() << " new tolerance = " << newpricertol
+                  << std::endl
+                  << " maxViolRedCost= " << maxViolRedCost
+                  << " maxViolBounds= " << maxViolBounds
+                  << " maxViolConst= " << maxViolConst << std::endl
+                  << " sumViolRedCost= " << sumViolRedCost
+                  << " sumViolBounds= " << sumViolBounds
+                  << " sumViolConst= " << sumViolConst << std::endl;);
+  }
+
+  return reached;
 }
 
-template <class R>
-void SPxSolverBase<R>::calculateProblemRanges()
-{
-   // only collect absolute values
-   R minobj = R(infinity);
-   R maxobj = 0.0;
-   R minbound = R(infinity);
-   R maxbound = 0.0;
-   R minside = R(infinity);
-   R maxside = 0.0;
-
-   // get min and max absolute values of bounds and objective
-   for(int j = 0; j < this->nCols(); ++j)
-   {
-      R abslow = spxAbs(this->lower(j));
-      R absupp = spxAbs(this->lower(j));
-      R absobj = spxAbs(this->obj(j));
-
-      if(abslow < R(infinity))
-      {
-         minbound = MINIMUM(minbound, abslow);
-         maxbound = MAXIMUM(maxbound, abslow);
-      }
-
-      if(absupp < R(infinity))
-      {
-         minbound = MINIMUM(minbound, absupp);
-         maxbound = MAXIMUM(maxbound, absupp);
-      }
-
-      minobj = MINIMUM(minobj, absobj);
-      maxobj = MAXIMUM(maxobj, absobj);
-   }
-
-   // get min and max absoute values of sides
-   for(int i = 0; i < this->nRows(); ++i)
-   {
-      R abslhs = spxAbs(this->lhs(i));
-      R absrhs = spxAbs(this->rhs(i));
-
-      if(abslhs > R(infinity))
-      {
-         minside = MINIMUM(minside, abslhs);
-         maxside = MAXIMUM(maxside, abslhs);
-      }
-
-      if(absrhs < R(infinity))
-      {
-         minside = MINIMUM(minside, absrhs);
-         maxside = MAXIMUM(maxside, absrhs);
-      }
-   }
-
-   boundrange = maxbound - minbound;
-   siderange = maxside - minside;
-   objrange = maxobj - minobj;
+template <class R> void SPxSolverBase<R>::calculateProblemRanges() {
+  // only collect absolute values
+  R minobj = R(infinity);
+  R maxobj = 0.0;
+  R minbound = R(infinity);
+  R maxbound = 0.0;
+  R minside = R(infinity);
+  R maxside = 0.0;
+
+  // get min and max absolute values of bounds and objective
+  for (int j = 0; j < this->nCols(); ++j) {
+    R abslow = spxAbs(this->lower(j));
+    R absupp = spxAbs(this->lower(j));
+    R absobj = spxAbs(this->obj(j));
+
+    if (abslow < R(infinity)) {
+      minbound = MINIMUM(minbound, abslow);
+      maxbound = MAXIMUM(maxbound, abslow);
+    }
+
+    if (absupp < R(infinity)) {
+      minbound = MINIMUM(minbound, absupp);
+      maxbound = MAXIMUM(maxbound, absupp);
+    }
+
+    minobj = MINIMUM(minobj, absobj);
+    maxobj = MAXIMUM(maxobj, absobj);
+  }
+
+  // get min and max absoute values of sides
+  for (int i = 0; i < this->nRows(); ++i) {
+    R abslhs = spxAbs(this->lhs(i));
+    R absrhs = spxAbs(this->rhs(i));
+
+    if (abslhs > R(infinity)) {
+      minside = MINIMUM(minside, abslhs);
+      maxside = MAXIMUM(maxside, abslhs);
+    }
+
+    if (absrhs < R(infinity)) {
+      minside = MINIMUM(minside, absrhs);
+      maxside = MAXIMUM(maxside, absrhs);
+    }
+  }
+
+  boundrange = maxbound - minbound;
+  siderange = maxside - minside;
+  objrange = maxobj - minobj;
 }
 
 template <class R>
-typename SPxSolverBase<R>::Status SPxSolverBase<R>::solve(volatile bool* interrupt)
-{
-
-   SPxId enterId;
-   int   leaveNum;
-   int   loopCount = 0;
-   R  minShift = R(infinity);
-   int   cycleCount = 0;
-   bool  priced = false;
-   R  lastDelta = 1;
-
-   /* allow clean up step only once */
-   recomputedVectors = false;
-
-   /* store the last (primal or dual) feasible objective value to recover/abort in case of stalling */
-   R  stallRefValue;
-   R  stallRefShift;
-   int   stallRefIter;
-   int   stallNumRecovers;
-
-   if(dim() <= 0 && coDim() <= 0)  // no problem loaded
-   {
-      m_status = NO_PROBLEM;
-      throw SPxStatusException("XSOLVE01 No Problem loaded");
-   }
-
-   if(slinSolver() == 0)  // linear system solver is required.
-   {
-      m_status = NO_SOLVER;
-      throw SPxStatusException("XSOLVE02 No Solver loaded");
-   }
-
-   if(thepricer == 0)  // pricer is required.
-   {
-      m_status = NO_PRICER;
-      throw SPxStatusException("XSOLVE03 No Pricer loaded");
-   }
-
-   if(theratiotester == 0)  // ratiotester is required.
-   {
-      m_status = NO_RATIOTESTER;
-      throw SPxStatusException("XSOLVE04 No RatioTester loaded");
-   }
-
-   theTime->reset();
-   theTime->start();
-
-   m_numCycle = 0;
-   this->iterCount  = 0;
-   this->lastIterCount = 0;
-   this->iterDegenCheck = 0;
-
-   if(!isInitialized())
-   {
-      /*
-        if(SPxBasisBase<R>::status() <= NO_PROBLEM)
-        SPxBasisBase<R>::load(this);
-      */
-      /**@todo != REGULAR is not enough. Also OPTIMAL/DUAL/PRIMAL should
-       * be tested and acted accordingly.
-       */
-      if(thestarter != 0 && status() != REGULAR
-            && this->theLP->status() == NO_PROBLEM)   // no basis and no starter.
-         thestarter->generate(*this);              // generate start basis.
-
-      init();
-
-      // Inna/Tobi: init might fail, if the basis is singular
-      if(!isInitialized())
-      {
-         assert(SPxBasisBase<R>::status() == SPxBasisBase<R>::SINGULAR);
-         m_status = UNKNOWN;
-         return status();
-      }
-   }
-
-   //setType(type());
-
-   if(!this->matrixIsSetup)
+typename SPxSolverBase<R>::Status
+SPxSolverBase<R>::solve(volatile bool *interrupt) {
+
+  SPxId enterId;
+  int leaveNum;
+  int loopCount = 0;
+  R minShift = R(infinity);
+  int cycleCount = 0;
+  bool priced = false;
+  R lastDelta = 1;
+
+  /* allow clean up step only once */
+  recomputedVectors = false;
+
+  /* store the last (primal or dual) feasible objective value to recover/abort
+   * in case of stalling */
+  R stallRefValue;
+  R stallRefShift;
+  int stallRefIter;
+  int stallNumRecovers;
+
+  if (dim() <= 0 && coDim() <= 0) // no problem loaded
+  {
+    m_status = NO_PROBLEM;
+    throw SPxStatusException("XSOLVE01 No Problem loaded");
+  }
+
+  if (slinSolver() == 0) // linear system solver is required.
+  {
+    m_status = NO_SOLVER;
+    throw SPxStatusException("XSOLVE02 No Solver loaded");
+  }
+
+  if (thepricer == 0) // pricer is required.
+  {
+    m_status = NO_PRICER;
+    throw SPxStatusException("XSOLVE03 No Pricer loaded");
+  }
+
+  if (theratiotester == 0) // ratiotester is required.
+  {
+    m_status = NO_RATIOTESTER;
+    throw SPxStatusException("XSOLVE04 No RatioTester loaded");
+  }
+
+  theTime->reset();
+  theTime->start();
+
+  m_numCycle = 0;
+  this->iterCount = 0;
+  this->lastIterCount = 0;
+  this->iterDegenCheck = 0;
+
+  if (!isInitialized()) {
+    /*
+      if(SPxBasisBase<R>::status() <= NO_PROBLEM)
       SPxBasisBase<R>::load(this);
-
-   //factorized = false;
-
-   assert(thepricer->solver()      == this);
-   assert(theratiotester->solver() == this);
-
-   // maybe this should be done in init() ?
-   thepricer->setType(type());
-   theratiotester->setType(type());
-
-   MSG_INFO3((*this->spxout),
-             (*this->spxout) << "starting value = " << value() << std::endl
-             << "starting shift = " << shift() << std::endl;
-            )
-
-   if(SPxBasisBase<R>::status() == SPxBasisBase<R>::OPTIMAL)
-      setBasisStatus(SPxBasisBase<R>::REGULAR);
-
-   m_status   = RUNNING;
-   bool stop  = terminate();
-   leaveCount = 0;
-   enterCount = 0;
-   primalCount = 0;
-   polishCount = 0;
-   boundflips = 0;
-   totalboundflips = 0;
-   enterCycles = 0;
-   leaveCycles = 0;
-   primalDegenSum = 0;
-   dualDegenSum = 0;
-
-   multSparseCalls = 0;
-   multFullCalls = 0;
-   multColwiseCalls = 0;
-   multUnsetupCalls = 0;
-
-   stallNumRecovers = 0;
-
-   /* if we run into a singular basis, we will retry from regulardesc with tighter tolerance in the ratio test */
-   typename SPxSolverBase<R>::Type tightenedtype = type();
-   bool tightened = false;
-
-   while(!stop)
-   {
-      const typename SPxBasisBase<R>::Desc regulardesc = this->desc();
-
-      // we need to reset these pointers to avoid unnecessary/wrong solves in leave() or enter()
-      solveVector2 = 0;
-      solveVector3 = 0;
-      coSolveVector2 = 0;
-      coSolveVector3 = 0;
-
-      updateViols.clear();
-      updateViolsCo.clear();
-
-      try
-      {
-
-         if(type() == ENTER)
-         {
-            forceRecompNonbasicValue();
-
-            int enterCycleCount = 0;
-            int enterFacPivotCount = 0;
-
-            instableEnterVal = 0;
-            instableEnterId = SPxId();
-            instableEnter = false;
-
-            stallRefIter = this->iteration() - 1;
-            stallRefShift = shift();
-            stallRefValue = value();
-
-            /* in the entering algorithm, entertol() should be maintained by the ratio test and leavetol() should be
-             * reached by the pricer
-             */
-            R maxpricertol = leavetol();
-            R minpricertol = 0.01 * maxpricertol;
-
-            thepricer->setEpsilon(maxpricertol);
-            priced = false;
-
-            // to avoid shifts we restrict tolerances in the ratio test
-            if(loopCount > 0)
-            {
-               lastDelta = (lastDelta < entertol()) ? lastDelta : entertol();
-               lastDelta *= 0.01;
-               theratiotester->setDelta(lastDelta);
-               assert(theratiotester->getDelta() > 0);
-               MSG_DEBUG(std::cout << "decreased delta for ratiotest to: " << theratiotester->getDelta() <<
-                         std::endl;)
+    */
+    /**@todo != REGULAR is not enough. Also OPTIMAL/DUAL/PRIMAL should
+     * be tested and acted accordingly.
+     */
+    if (thestarter != 0 && status() != REGULAR &&
+        this->theLP->status() == NO_PROBLEM) // no basis and no starter.
+      thestarter->generate(*this);           // generate start basis.
+
+    init();
+
+    // Inna/Tobi: init might fail, if the basis is singular
+    if (!isInitialized()) {
+      assert(SPxBasisBase<R>::status() == SPxBasisBase<R>::SINGULAR);
+      m_status = UNKNOWN;
+      return status();
+    }
+  }
+
+  // setType(type());
+
+  if (!this->matrixIsSetup)
+    SPxBasisBase<R>::load(this);
+
+  // factorized = false;
+
+  assert(thepricer->solver() == this);
+  assert(theratiotester->solver() == this);
+
+  // maybe this should be done in init() ?
+  thepricer->setType(type());
+  theratiotester->setType(type());
+
+  MSG_INFO3((*this->spxout),
+            (*this->spxout) << "starting value = " << value() << std::endl
+                            << "starting shift = " << shift() << std::endl;)
+
+  if (SPxBasisBase<R>::status() == SPxBasisBase<R>::OPTIMAL)
+    setBasisStatus(SPxBasisBase<R>::REGULAR);
+
+  m_status = RUNNING;
+  bool stop = terminate();
+  leaveCount = 0;
+  enterCount = 0;
+  primalCount = 0;
+  polishCount = 0;
+  boundflips = 0;
+  totalboundflips = 0;
+  enterCycles = 0;
+  leaveCycles = 0;
+  primalDegenSum = 0;
+  dualDegenSum = 0;
+
+  multSparseCalls = 0;
+  multFullCalls = 0;
+  multColwiseCalls = 0;
+  multUnsetupCalls = 0;
+
+  stallNumRecovers = 0;
+
+  /* if we run into a singular basis, we will retry from regulardesc with
+   * tighter tolerance in the ratio test */
+  typename SPxSolverBase<R>::Type tightenedtype = type();
+  bool tightened = false;
+
+  while (!stop) {
+    const typename SPxBasisBase<R>::Desc regulardesc = this->desc();
+
+    // we need to reset these pointers to avoid unnecessary/wrong solves in
+    // leave() or enter()
+    solveVector2 = 0;
+    solveVector3 = 0;
+    coSolveVector2 = 0;
+    coSolveVector3 = 0;
+
+    updateViols.clear();
+    updateViolsCo.clear();
+
+    try {
+
+      if (type() == ENTER) {
+        forceRecompNonbasicValue();
+
+        int enterCycleCount = 0;
+        int enterFacPivotCount = 0;
+
+        instableEnterVal = 0;
+        instableEnterId = SPxId();
+        instableEnter = false;
+
+        stallRefIter = this->iteration() - 1;
+        stallRefShift = shift();
+        stallRefValue = value();
+
+        /* in the entering algorithm, entertol() should be maintained by the
+         * ratio test and leavetol() should be reached by the pricer
+         */
+        R maxpricertol = leavetol();
+        R minpricertol = 0.01 * maxpricertol;
+
+        thepricer->setEpsilon(maxpricertol);
+        priced = false;
+
+        // to avoid shifts we restrict tolerances in the ratio test
+        if (loopCount > 0) {
+          lastDelta = (lastDelta < entertol()) ? lastDelta : entertol();
+          lastDelta *= 0.01;
+          theratiotester->setDelta(lastDelta);
+          assert(theratiotester->getDelta() > 0);
+          MSG_DEBUG(std::cout << "decreased delta for ratiotest to: "
+                              << theratiotester->getDelta() << std::endl;)
+        } else {
+          lastDelta = 1;
+          theratiotester->setDelta(entertol());
+        }
+
+        printDisplayLine(true);
+
+        do {
+          printDisplayLine();
+
+          enterId = thepricer->selectEnter();
+
+          if (!enterId.isValid() && instableEnterId.isValid() &&
+              this->lastUpdate() == 0) {
+            /* no entering variable was found, but because of valid
+               instableEnterId we know that this is due to the scaling of the
+               test values. Thus, we use instableEnterId and
+               SPxFastRT<R>::selectEnter shall accept even an instable leaving
+               variable. */
+            MSG_INFO3((*this->spxout),
+                      (*this->spxout) << " --- trying instable enter iteration"
+                                      << std::endl;)
+
+            enterId = instableEnterId;
+            instableEnter = true;
+            // we also need to reset the test() or coTest() value for
+            // getEnterVals()
+            assert(instableEnterVal < 0);
+
+            if (enterId.isSPxColId()) {
+              int idx = this->number(SPxColId(enterId));
+
+              if (rep() == COLUMN) {
+                theTest[idx] = instableEnterVal;
+
+                if (sparsePricingEnterCo &&
+                    isInfeasibleCo[idx] == SPxPricer<R>::NOT_VIOLATED) {
+                  infeasibilitiesCo.addIdx(idx);
+                  isInfeasibleCo[idx] = SPxPricer<R>::VIOLATED;
+                }
+
+                if (hyperPricingEnter)
+                  updateViolsCo.addIdx(idx);
+              } else {
+                theCoTest[idx] = instableEnterVal;
+
+                if (sparsePricingEnter &&
+                    isInfeasible[idx] == SPxPricer<R>::NOT_VIOLATED) {
+                  infeasibilities.addIdx(idx);
+                  isInfeasible[idx] = SPxPricer<R>::VIOLATED;
+                }
+
+                if (hyperPricingEnter)
+                  updateViols.addIdx(idx);
+              }
+            } else {
+              int idx = this->number(SPxRowId(enterId));
+
+              if (rep() == COLUMN) {
+                theCoTest[idx] = instableEnterVal;
+
+                if (sparsePricingEnter &&
+                    isInfeasible[idx] == SPxPricer<R>::NOT_VIOLATED) {
+                  infeasibilities.addIdx(idx);
+                  isInfeasible[idx] = SPxPricer<R>::VIOLATED;
+                }
+
+                if (hyperPricingEnter)
+                  updateViols.addIdx(idx);
+              } else {
+                theTest[idx] = instableEnterVal;
+
+                if (sparsePricingEnterCo &&
+                    isInfeasibleCo[idx] == SPxPricer<R>::NOT_VIOLATED) {
+                  infeasibilitiesCo.addIdx(idx);
+                  isInfeasibleCo[idx] = SPxPricer<R>::VIOLATED;
+                }
+
+                if (hyperPricingEnter)
+                  updateViolsCo.addIdx(idx);
+              }
             }
-            else
-            {
-               lastDelta = 1;
-               theratiotester->setDelta(entertol());
+          } else {
+            instableEnter = false;
+          }
+
+          if (!enterId.isValid()) {
+            // we are not infeasible and have no shift
+            if (shift() <= epsilon() &&
+                (SPxBasisBase<R>::status() == SPxBasisBase<R>::REGULAR ||
+                 SPxBasisBase<R>::status() == SPxBasisBase<R>::DUAL ||
+                 SPxBasisBase<R>::status() == SPxBasisBase<R>::PRIMAL)) {
+              R newpricertol = minpricertol;
+
+              // refactorize to eliminate accumulated errors from LU updates
+              if (this->lastUpdate() > 0)
+                factorize();
+
+              // recompute Fvec, Pvec and CoPvec to get a more precise solution
+              // and obj value
+              computeFrhs();
+              SPxBasisBase<R>::solve(*theFvec, *theFrhs);
+
+              computeEnterCoPrhs();
+              SPxBasisBase<R>::coSolve(*theCoPvec, *theCoPrhs);
+              computePvec();
+
+              forceRecompNonbasicValue();
+
+              MSG_INFO2((*this->spxout),
+                        (*this->spxout)
+                            << " --- checking feasibility and optimality\n")
+              computeCoTest();
+              computeTest();
+
+              // is the solution good enough ?
+              // max three times reduced
+              if ((thepricer->epsilon() > minpricertol) &&
+                  !precisionReached(newpricertol)) {
+                // no!
+                // we reduce the pricer tolerance. Note that if the pricer does
+                // not find a candiate with the reduced tolerance, we quit,
+                // regardless of the violations.
+                if (newpricertol < minpricertol)
+                  newpricertol = minpricertol;
+
+                thepricer->setEpsilon(newpricertol);
+
+                MSG_INFO2((*this->spxout),
+                          (*this->spxout) << " --- setting pricer tolerance to "
+                                          << thepricer->epsilon() << std::endl;)
+              }
             }
 
-            printDisplayLine(true);
-
-            do
-            {
-               printDisplayLine();
-
-               enterId = thepricer->selectEnter();
-
-               if(!enterId.isValid() && instableEnterId.isValid() && this->lastUpdate() == 0)
-               {
-                  /* no entering variable was found, but because of valid instableEnterId we know
-                     that this is due to the scaling of the test values. Thus, we use
-                     instableEnterId and SPxFastRT<R>::selectEnter shall accept even an instable
-                     leaving variable. */
-                  MSG_INFO3((*this->spxout), (*this->spxout) << " --- trying instable enter iteration" << std::endl;)
-
-                  enterId = instableEnterId;
-                  instableEnter = true;
-                  // we also need to reset the test() or coTest() value for getEnterVals()
-                  assert(instableEnterVal < 0);
-
-                  if(enterId.isSPxColId())
-                  {
-                     int idx = this->number(SPxColId(enterId));
-
-                     if(rep() == COLUMN)
-                     {
-                        theTest[idx] = instableEnterVal;
-
-                        if(sparsePricingEnterCo && isInfeasibleCo[idx] == SPxPricer<R>::NOT_VIOLATED)
-                        {
-                           infeasibilitiesCo.addIdx(idx);
-                           isInfeasibleCo[idx] = SPxPricer<R>::VIOLATED;
-                        }
-
-                        if(hyperPricingEnter)
-                           updateViolsCo.addIdx(idx);
-                     }
-                     else
-                     {
-                        theCoTest[idx] = instableEnterVal;
-
-                        if(sparsePricingEnter && isInfeasible[idx] == SPxPricer<R>::NOT_VIOLATED)
-                        {
-                           infeasibilities.addIdx(idx);
-                           isInfeasible[idx] = SPxPricer<R>::VIOLATED;
-                        }
-
-                        if(hyperPricingEnter)
-                           updateViols.addIdx(idx);
-                     }
-                  }
-                  else
-                  {
-                     int idx = this->number(SPxRowId(enterId));
-
-                     if(rep() == COLUMN)
-                     {
-                        theCoTest[idx] = instableEnterVal;
-
-                        if(sparsePricingEnter && isInfeasible[idx] == SPxPricer<R>::NOT_VIOLATED)
-                        {
-                           infeasibilities.addIdx(idx);
-                           isInfeasible[idx] = SPxPricer<R>::VIOLATED;
-                        }
-
-                        if(hyperPricingEnter)
-                           updateViols.addIdx(idx);
-                     }
-                     else
-                     {
-                        theTest[idx] = instableEnterVal;
-
-                        if(sparsePricingEnterCo && isInfeasibleCo[idx] == SPxPricer<R>::NOT_VIOLATED)
-                        {
-                           infeasibilitiesCo.addIdx(idx);
-                           isInfeasibleCo[idx] = SPxPricer<R>::VIOLATED;
-                        }
-
-                        if(hyperPricingEnter)
-                           updateViolsCo.addIdx(idx);
-                     }
-                  }
-               }
-               else
-               {
-                  instableEnter = false;
-               }
-
-               if(!enterId.isValid())
-               {
-                  // we are not infeasible and have no shift
-                  if(shift() <= epsilon()
-                        && (SPxBasisBase<R>::status() == SPxBasisBase<R>::REGULAR
-                            || SPxBasisBase<R>::status() == SPxBasisBase<R>::DUAL
-                            || SPxBasisBase<R>::status() == SPxBasisBase<R>::PRIMAL))
-                  {
-                     R newpricertol = minpricertol;
-
-                     // refactorize to eliminate accumulated errors from LU updates
-                     if(this->lastUpdate() > 0)
-                        factorize();
-
-                     // recompute Fvec, Pvec and CoPvec to get a more precise solution and obj value
-                     computeFrhs();
-                     SPxBasisBase<R>::solve(*theFvec, *theFrhs);
-
-                     computeEnterCoPrhs();
-                     SPxBasisBase<R>::coSolve(*theCoPvec, *theCoPrhs);
-                     computePvec();
-
-                     forceRecompNonbasicValue();
-
-                     MSG_INFO2((*this->spxout), (*this->spxout) << " --- checking feasibility and optimality\n")
-                     computeCoTest();
-                     computeTest();
-
-                     // is the solution good enough ?
-                     // max three times reduced
-                     if((thepricer->epsilon() > minpricertol) && !precisionReached(newpricertol))
-                     {
-                        // no!
-                        // we reduce the pricer tolerance. Note that if the pricer does not find a candiate
-                        // with the reduced tolerance, we quit, regardless of the violations.
-                        if(newpricertol < minpricertol)
-                           newpricertol = minpricertol;
-
-                        thepricer->setEpsilon(newpricertol);
-
-                        MSG_INFO2((*this->spxout), (*this->spxout) << " --- setting pricer tolerance to "
-                                  << thepricer->epsilon()
-                                  << std::endl;)
-                     }
-                  }
-
-                  // if the factorization is not fresh, we better refactorize and call the pricer again; however, this can
-                  // create cycling, so it is performed only a limited number of times per ENTER round
-                  if(this->lastUpdate() > 0 && enterFacPivotCount < MAXREFACPIVOTS)
-                  {
-                     MSG_INFO3((*this->spxout), (*this->spxout) << " --- solve(enter) triggers refactorization" <<
-                               std::endl;)
-
-                     factorize();
-
-                     // if the factorization was found out to be singular, we have to quit
-                     if(SPxBasisBase<R>::status() < SPxBasisBase<R>::REGULAR)
-                     {
-                        MSG_INFO1((*this->spxout), (*this->spxout) << "Something wrong with factorization, Basis status: "
-                                  << static_cast<int>(SPxBasisBase<R>::status()) << std::endl;)
-                        stop = true;
-                        break;
-                     }
-
-                     // call pricer again
-                     enterId = thepricer->selectEnter();
-
-                     // count how often the pricer has found something only after refactorizing
-                     if(enterId.isValid())
-                        enterFacPivotCount++;
-                  }
-
-                  if(!enterId.isValid())
-                  {
-                     priced = true;
-                     break;
-                  }
-               }
-
-               /* check if we have iterations left */
-               if(maxIters >= 0 && iterations() >= maxIters)
-               {
-                  MSG_INFO2((*this->spxout), (*this->spxout) << " --- maximum number of iterations (" << maxIters
-                            << ") reached" << std::endl;)
-                  m_status = ABORT_ITER;
-                  stop = true;
-                  break;
-               }
-
-               if(interrupt != NULL && *interrupt)
-               {
-                  MSG_INFO2((*this->spxout), (*this->spxout) << " --- aborted due to interrupt signal" << std::endl;)
-                  m_status = ABORT_TIME;
-                  stop = true;
-                  break;
-               }
-
-               enter(enterId);
-               assert((testBounds(), 1));
-               thepricer->entered4(this->lastEntered(), this->lastIndex());
-               stop = terminate();
-               clearUpdateVecs();
-
-               /* if a successful pivot was performed or a nonbasic variable was flipped to its other bound, we reset the
-                * cycle counter
-                */
-               if(this->lastEntered().isValid())
-                  enterCycleCount = 0;
-               else if(basis().status() != SPxBasisBase<R>::INFEASIBLE
-                       && basis().status() != SPxBasisBase<R>::UNBOUNDED)
-               {
-                  enterCycleCount++;
-
-                  if(enterCycleCount > MAXCYCLES)
-                  {
-                     MSG_INFO2((*this->spxout), (*this->spxout) << " --- abort solving due to cycling in "
-                               << "entering algorithm" << std::endl;);
-                     m_status = ABORT_CYCLING;
-                     stop = true;
-                  }
-               }
-
-               /* only if the basis has really changed, we increase the iterations counter; this is not the case when only
-                * a nonbasic variable was flipped to its other bound
-                */
-               if(this->lastIndex() >= 0)
-               {
-                  enterCount++;
-                  assert(this->lastEntered().isValid());
-               }
-
-               /* check every MAXSTALLS iterations whether shift and objective value have not changed */
-               if((this->iteration() - stallRefIter) % MAXSTALLS == 0
-                     && basis().status() != SPxBasisBase<R>::INFEASIBLE)
-               {
-                  if(spxAbs(value() - stallRefValue) <= epsilon() && spxAbs(shift() - stallRefShift) <= epsilon())
-                  {
-                     if(stallNumRecovers < MAXSTALLRECOVERS)
-                     {
-                        /* try to recover by unshifting/switching algorithm up to MAXSTALLRECOVERS times (just a number picked) */
-                        MSG_INFO3((*this->spxout), (*this->spxout) <<
-                                  " --- stalling detected - trying to recover by switching to LEAVING algorithm." << std::endl;)
-
-                        ++stallNumRecovers;
-                        break;
-                     }
-                     else
-                     {
-                        /* giving up */
-                        MSG_INFO2((*this->spxout), (*this->spxout) <<
-                                  " --- abort solving due to stalling in entering algorithm." << std::endl;);
-
-                        m_status = ABORT_CYCLING;
-                        stop = true;
-                     }
-                  }
-                  else
-                  {
-                     /* merely update reference values */
-                     stallRefIter = this->iteration() - 1;
-                     stallRefShift = shift();
-                     stallRefValue = value();
-                  }
-               }
-
-               //@ assert(isConsistent());
+            // if the factorization is not fresh, we better refactorize and call
+            // the pricer again; however, this can create cycling, so it is
+            // performed only a limited number of times per ENTER round
+            if (this->lastUpdate() > 0 && enterFacPivotCount < MAXREFACPIVOTS) {
+              MSG_INFO3((*this->spxout),
+                        (*this->spxout)
+                            << " --- solve(enter) triggers refactorization"
+                            << std::endl;)
+
+              factorize();
+
+              // if the factorization was found out to be singular, we have to
+              // quit
+              if (SPxBasisBase<R>::status() < SPxBasisBase<R>::REGULAR) {
+                MSG_INFO1(
+                    (*this->spxout),
+                    (*this->spxout)
+                        << "Something wrong with factorization, Basis status: "
+                        << static_cast<int>(SPxBasisBase<R>::status())
+                        << std::endl;)
+                stop = true;
+                break;
+              }
+
+              // call pricer again
+              enterId = thepricer->selectEnter();
+
+              // count how often the pricer has found something only after
+              // refactorizing
+              if (enterId.isValid())
+                enterFacPivotCount++;
             }
-            while(!stop);
 
-            MSG_INFO3((*this->spxout),
-                      (*this->spxout) << " --- enter finished. iteration: " << this->iteration()
-                      << ", value: " << value()
-                      << ", shift: " << shift()
-                      << ", epsilon: " << epsilon()
-                      << ", feastol: " << feastol()
-                      << ", opttol: " << opttol()
-                      << std::endl
-                      << "ISOLVE56 stop: " << stop
-                      << ", basis status: " << static_cast<int>(SPxBasisBase<R>::status()) << " (" << static_cast<int>
-                      (SPxBasisBase<R>::status()) << ")"
-                      << ", solver status: " << static_cast<int>(m_status) << " (" << static_cast<int>
-                      (m_status) << ")" << std::endl;
-                     )
-
-            if(!stop)
-            {
-               /**@todo technically it would be ok to finish already when (priced && maxinfeas + shift() <= entertol()) is
-                *  satisfied; maybe at least in the case when SoPlex keeps jumping back between ENTER and LEAVE always
-                *  shifting (looping), we may relax this condition here;
-                *  note also that unShift may increase shift() slightly due to roundoff errors
-                */
-               if(shift() <= epsilon())
-               {
-                  // factorize();
-                  unShift();
-
-                  R maxinfeas = maxInfeas();
-
-                  MSG_INFO3((*this->spxout),
-                            (*this->spxout) << " --- maxInfeas: " << maxinfeas
-                            << ", shift: " << shift()
-                            << ", entertol: " << entertol() << std::endl;
-                           )
-
-                  if(priced && maxinfeas + shift() <= entertol())
-                  {
-                     setBasisStatus(SPxBasisBase<R>::OPTIMAL);
-                     m_status = OPTIMAL;
-                     break;
-                  }
-                  else if(loopCount > 2)
-                  {
-                     // calculate problem ranges if not done already
-                     if(boundrange == 0.0 || siderange == 0.0 || objrange == 0.0)
-                        calculateProblemRanges();
-
-                     if(MAXIMUM(MAXIMUM(boundrange, siderange), objrange) >= 1e9)
-                     {
-                        SPxOut::setScientific(spxout->getCurrentStream(), 0);
-                        MSG_INFO1((*this->spxout), (*this->spxout) <<
-                                  " --- termination despite violations (numerical difficulties,"
-                                  << " bound range = " << boundrange
-                                  << ", side range = " << siderange
-                                  << ", obj range = " << objrange
-                                  << ")" << std::endl;)
-                        setBasisStatus(SPxBasisBase<R>::OPTIMAL);
-                        m_status = OPTIMAL;
-                        break;
-                     }
-                     else
-                     {
-                        m_status = ABORT_CYCLING;
-                        throw SPxStatusException("XSOLVE14 Abort solving due to looping");
-                     }
-                  }
-
-                  loopCount++;
-               }
-
-               setType(LEAVE);
-               init();
-               thepricer->setType(type());
-               theratiotester->setType(type());
+            if (!enterId.isValid()) {
+              priced = true;
+              break;
             }
-         }
-         else
-         {
-            assert(type() == LEAVE);
-
-            forceRecompNonbasicValue();
-
-            int leaveCycleCount = 0;
-            int leaveFacPivotCount = 0;
-
-            instableLeaveNum = -1;
-            instableLeave = false;
-            instableLeaveVal = 0;
-
-            stallRefIter = this->iteration() - 1;
-            stallRefShift = shift();
-            stallRefValue = value();
-
-            /* in the leaving algorithm, leavetol() should be maintained by the ratio test and entertol() should be reached
-             * by the pricer
-             */
-            R maxpricertol = entertol();
-            R minpricertol = 0.01 * maxpricertol;
-
-            thepricer->setEpsilon(maxpricertol);
-            priced = false;
-
-            // to avoid shifts we restrict tolerances in the ratio test
-            if(loopCount > 0)
-            {
-               lastDelta = (lastDelta < leavetol()) ? lastDelta : leavetol();
-               lastDelta *= 0.01;
-               theratiotester->setDelta(lastDelta);
-               assert(theratiotester->getDelta() > 0);
-               MSG_DEBUG(std::cout << "decreased delta for ratiotest to: " << theratiotester->getDelta() <<
-                         std::endl;)
+          }
+
+          /* check if we have iterations left */
+          if (maxIters >= 0 && iterations() >= maxIters) {
+            MSG_INFO2((*this->spxout),
+                      (*this->spxout) << " --- maximum number of iterations ("
+                                      << maxIters << ") reached" << std::endl;)
+            m_status = ABORT_ITER;
+            stop = true;
+            break;
+          }
+
+          if (interrupt != NULL && *interrupt) {
+            MSG_INFO2((*this->spxout),
+                      (*this->spxout) << " --- aborted due to interrupt signal"
+                                      << std::endl;)
+            m_status = ABORT_TIME;
+            stop = true;
+            break;
+          }
+
+          enter(enterId);
+          assert((testBounds(), 1));
+          thepricer->entered4(this->lastEntered(), this->lastIndex());
+          stop = terminate();
+          clearUpdateVecs();
+
+          /* if a successful pivot was performed or a nonbasic variable was
+           * flipped to its other bound, we reset the cycle counter
+           */
+          if (this->lastEntered().isValid())
+            enterCycleCount = 0;
+          else if (basis().status() != SPxBasisBase<R>::INFEASIBLE &&
+                   basis().status() != SPxBasisBase<R>::UNBOUNDED) {
+            enterCycleCount++;
+
+            if (enterCycleCount > MAXCYCLES) {
+              MSG_INFO2((*this->spxout),
+                        (*this->spxout)
+                            << " --- abort solving due to cycling in "
+                            << "entering algorithm" << std::endl;);
+              m_status = ABORT_CYCLING;
+              stop = true;
             }
-            else
-            {
-               lastDelta = 1;
-               theratiotester->setDelta(leavetol());
+          }
+
+          /* only if the basis has really changed, we increase the iterations
+           * counter; this is not the case when only a nonbasic variable was
+           * flipped to its other bound
+           */
+          if (this->lastIndex() >= 0) {
+            enterCount++;
+            assert(this->lastEntered().isValid());
+          }
+
+          /* check every MAXSTALLS iterations whether shift and objective value
+           * have not changed */
+          if ((this->iteration() - stallRefIter) % MAXSTALLS == 0 &&
+              basis().status() != SPxBasisBase<R>::INFEASIBLE) {
+            if (spxAbs(value() - stallRefValue) <= epsilon() &&
+                spxAbs(shift() - stallRefShift) <= epsilon()) {
+              if (stallNumRecovers < MAXSTALLRECOVERS) {
+                /* try to recover by unshifting/switching algorithm up to
+                 * MAXSTALLRECOVERS times (just a number picked) */
+                MSG_INFO3((*this->spxout),
+                          (*this->spxout)
+                              << " --- stalling detected - trying to recover "
+                                 "by switching to LEAVING algorithm."
+                              << std::endl;)
+
+                ++stallNumRecovers;
+                break;
+              } else {
+                /* giving up */
+                MSG_INFO2((*this->spxout),
+                          (*this->spxout) << " --- abort solving due to "
+                                             "stalling in entering algorithm."
+                                          << std::endl;);
+
+                m_status = ABORT_CYCLING;
+                stop = true;
+              }
+            } else {
+              /* merely update reference values */
+              stallRefIter = this->iteration() - 1;
+              stallRefShift = shift();
+              stallRefValue = value();
             }
-
-            printDisplayLine(true);
-
-            do
-            {
-               printDisplayLine();
-
-               leaveNum = thepricer->selectLeave();
-
-               if(leaveNum < 0 && instableLeaveNum >= 0 && this->lastUpdate() == 0)
-               {
-                  /* no leaving variable was found, but because of instableLeaveNum >= 0 we know
-                     that this is due to the scaling of theCoTest[...]. Thus, we use
-                     instableLeaveNum and SPxFastRT<R>::selectEnter shall accept even an instable
-                     entering variable. */
-                  MSG_INFO3((*this->spxout),
-                            (*this->spxout) << " --- trying instable leave iteration" << std::endl;
-                           )
-
-                  leaveNum = instableLeaveNum;
-                  instableLeave = true;
-                  // we also need to reset the fTest() value for getLeaveVals()
-                  assert(instableLeaveVal < 0);
-                  theCoTest[instableLeaveNum] = instableLeaveVal;
-
-                  if(sparsePricingLeave)
-                  {
-                     if(isInfeasible[instableLeaveNum] == SPxPricer<R>::NOT_VIOLATED)
-                     {
-                        infeasibilities.addIdx(instableLeaveNum);
-                        isInfeasible[instableLeaveNum] = SPxPricer<R>::VIOLATED;
-                     }
-
-                     if(hyperPricingLeave)
-                        updateViols.addIdx(instableLeaveNum);
-                  }
-               }
-               else
-               {
-                  instableLeave = false;
-               }
-
-               if(leaveNum < 0)
-               {
-                  // we are not infeasible and have no shift
-                  if(shift() <= epsilon()
-                        && (SPxBasisBase<R>::status() == SPxBasisBase<R>::REGULAR
-                            || SPxBasisBase<R>::status() == SPxBasisBase<R>::DUAL
-                            || SPxBasisBase<R>::status() == SPxBasisBase<R>::PRIMAL))
-                  {
-                     R newpricertol = minpricertol;
-
-                     // refactorize to eliminate accumulated errors from LU updates
-                     if(this->lastUpdate() > 0)
-                        factorize();
-
-                     // recompute Fvec, Pvec and CoPvec to get a more precise solution and obj value
-                     computeFrhs();
-                     SPxBasisBase<R>::solve(*theFvec, *theFrhs);
-
-                     computeLeaveCoPrhs();
-                     SPxBasisBase<R>::coSolve(*theCoPvec, *theCoPrhs);
-                     computePvec();
-
-                     forceRecompNonbasicValue();
-
-                     MSG_INFO2((*this->spxout), (*this->spxout) << " --- checking feasibility and optimality\n")
-                     computeFtest();
-
-                     // is the solution good enough ?
-                     // max three times reduced
-                     if((thepricer->epsilon() > minpricertol) && !precisionReached(newpricertol))
-                     {
-                        // no
-                        // we reduce the pricer tolerance. Note that if the pricer does not find a candiate
-                        // with the reduced pricer tolerance, we quit, regardless of the violations.
-                        if(newpricertol < minpricertol)
-                           newpricertol = minpricertol;
-
-                        thepricer->setEpsilon(newpricertol);
-
-                        MSG_INFO2((*this->spxout), (*this->spxout) << " --- setting pricer tolerance to "
-                                  << thepricer->epsilon()
-                                  << std::endl;);
-                     }
-                  }
-
-                  // if the factorization is not fresh, we better refactorize and call the pricer again; however, this can
-                  // create cycling, so it is performed only a limited number of times per LEAVE round
-                  if(this->lastUpdate() > 0 && leaveFacPivotCount < MAXREFACPIVOTS)
-                  {
-                     MSG_INFO3((*this->spxout), (*this->spxout) << " --- solve(leave) triggers refactorization" <<
-                               std::endl;)
-
-                     factorize();
-
-                     // Inna/Tobi: if the factorization was found out to be singular, we have to quit
-                     if(SPxBasisBase<R>::status() < SPxBasisBase<R>::REGULAR)
-                     {
-                        MSG_INFO1((*this->spxout), (*this->spxout) << "Something wrong with factorization, Basis status: "
-                                  << static_cast<int>(SPxBasisBase<R>::status()) << std::endl;)
-                        stop = true;
-                        break;
-                     }
-
-                     // call pricer again
-                     leaveNum = thepricer->selectLeave();
-
-                     // count how often the pricer has found something only after refactorizing
-                     if(leaveNum >= 0)
-                        leaveFacPivotCount++;
-                  }
-
-                  if(leaveNum < 0)
-                  {
-                     priced = true;
-                     break;
-                  }
-               }
-
-               /* check if we have iterations left */
-               if(maxIters >= 0 && iterations() >= maxIters)
-               {
-                  MSG_INFO2((*this->spxout), (*this->spxout) << " --- maximum number of iterations (" << maxIters
-                            << ") reached" << std::endl;)
-                  m_status = ABORT_ITER;
-                  stop = true;
-                  break;
-               }
-
-               if(interrupt != NULL && *interrupt)
-               {
-                  MSG_INFO2((*this->spxout), (*this->spxout) << " --- aborted due to interrupt signal" << std::endl;)
-                  m_status = ABORT_TIME;
-                  stop = true;
-                  break;
-               }
-
-               leave(leaveNum);
-               assert((testBounds(), 1));
-               thepricer->left4(this->lastIndex(), this->lastLeft());
-               stop = terminate();
-               clearUpdateVecs();
-
-               /* if a successful pivot was performed or a nonbasic variable was flipped to its other bound, we reset the
-                * cycle counter
-                */
-               if(this->lastIndex() >= 0)
-                  leaveCycleCount = 0;
-               else if(basis().status() != SPxBasisBase<R>::INFEASIBLE
-                       && basis().status() != SPxBasisBase<R>::UNBOUNDED)
-               {
-                  leaveCycleCount++;
-
-                  if(leaveCycleCount > MAXCYCLES)
-                  {
-                     MSG_INFO2((*this->spxout), (*this->spxout) <<
-                               " --- abort solving due to cycling in leaving algorithm" << std::endl;);
-                     m_status = ABORT_CYCLING;
-                     stop = true;
-                  }
-               }
-
-               /* only if the basis has really changed, we increase the iterations counter; this is not the case when only
-                * a nonbasic variable was flipped to its other bound
-                */
-               if(this->lastEntered().isValid())
-               {
-                  leaveCount++;
-                  assert(this->lastIndex() >= 0);
-               }
-
-               /* check every MAXSTALLS iterations whether shift and objective value have not changed */
-               if((this->iteration() - stallRefIter) % MAXSTALLS == 0
-                     && basis().status() != SPxBasisBase<R>::INFEASIBLE)
-               {
-                  if(spxAbs(value() - stallRefValue) <= epsilon() && spxAbs(shift() - stallRefShift) <= epsilon())
-                  {
-                     if(stallNumRecovers < MAXSTALLRECOVERS)
-                     {
-                        /* try to recover by switching algorithm up to MAXSTALLRECOVERS times */
-                        MSG_INFO3((*this->spxout), (*this->spxout) <<
-                                  " --- stalling detected - trying to recover by switching to ENTERING algorithm." << std::endl;)
-
-                        ++stallNumRecovers;
-                        break;
-                     }
-                     else
-                     {
-                        /* giving up */
-                        MSG_INFO2((*this->spxout), (*this->spxout) <<
-                                  " --- abort solving due to stalling in leaving algorithm" << std::endl;);
-
-                        m_status = ABORT_CYCLING;
-                        stop = true;
-                     }
-                  }
-                  else
-                  {
-                     /* merely update reference values */
-                     stallRefIter = this->iteration() - 1;
-                     stallRefShift = shift();
-                     stallRefValue = value();
-                  }
-               }
-
-               //@ assert(isConsistent());
+          }
+
+          //@ assert(isConsistent());
+        } while (!stop);
+
+        MSG_INFO3((*this->spxout),
+                  (*this->spxout)
+                      << " --- enter finished. iteration: " << this->iteration()
+                      << ", value: " << value() << ", shift: " << shift()
+                      << ", epsilon: " << epsilon() << ", feastol: "
+                      << feastol() << ", opttol: " << opttol() << std::endl
+                      << "ISOLVE56 stop: " << stop << ", basis status: "
+                      << static_cast<int>(SPxBasisBase<R>::status()) << " ("
+                      << static_cast<int>(SPxBasisBase<R>::status()) << ")"
+                      << ", solver status: " << static_cast<int>(m_status)
+                      << " (" << static_cast<int>(m_status) << ")"
+                      << std::endl;)
+
+        if (!stop) {
+          /**@todo technically it would be ok to finish already when (priced &&
+           * maxinfeas + shift() <= entertol()) is satisfied; maybe at least in
+           * the case when SoPlex keeps jumping back between ENTER and LEAVE
+           * always shifting (looping), we may relax this condition here; note
+           * also that unShift may increase shift() slightly due to roundoff
+           * errors
+           */
+          if (shift() <= epsilon()) {
+            // factorize();
+            unShift();
+
+            R maxinfeas = maxInfeas();
+
+            MSG_INFO3((*this->spxout), (*this->spxout)
+                                           << " --- maxInfeas: " << maxinfeas
+                                           << ", shift: " << shift()
+                                           << ", entertol: " << entertol()
+                                           << std::endl;)
+
+            if (priced && maxinfeas + shift() <= entertol()) {
+              setBasisStatus(SPxBasisBase<R>::OPTIMAL);
+              m_status = OPTIMAL;
+              break;
+            } else if (loopCount > 2) {
+              // calculate problem ranges if not done already
+              if (boundrange == 0.0 || siderange == 0.0 || objrange == 0.0)
+                calculateProblemRanges();
+
+              if (MAXIMUM(MAXIMUM(boundrange, siderange), objrange) >= 1e9) {
+                SPxOut::setScientific(spxout->getCurrentStream(), 0);
+                MSG_INFO1((*this->spxout),
+                          (*this->spxout)
+                              << " --- termination despite violations "
+                                 "(numerical difficulties,"
+                              << " bound range = " << boundrange
+                              << ", side range = " << siderange
+                              << ", obj range = " << objrange << ")"
+                              << std::endl;)
+                setBasisStatus(SPxBasisBase<R>::OPTIMAL);
+                m_status = OPTIMAL;
+                break;
+              } else {
+                m_status = ABORT_CYCLING;
+                throw SPxStatusException(
+                    "XSOLVE14 Abort solving due to looping");
+              }
             }
-            while(!stop);
 
+            loopCount++;
+          }
+
+          setType(LEAVE);
+          init();
+          thepricer->setType(type());
+          theratiotester->setType(type());
+        }
+      } else {
+        assert(type() == LEAVE);
+
+        forceRecompNonbasicValue();
+
+        int leaveCycleCount = 0;
+        int leaveFacPivotCount = 0;
+
+        instableLeaveNum = -1;
+        instableLeave = false;
+        instableLeaveVal = 0;
+
+        stallRefIter = this->iteration() - 1;
+        stallRefShift = shift();
+        stallRefValue = value();
+
+        /* in the leaving algorithm, leavetol() should be maintained by the
+         * ratio test and entertol() should be reached by the pricer
+         */
+        R maxpricertol = entertol();
+        R minpricertol = 0.01 * maxpricertol;
+
+        thepricer->setEpsilon(maxpricertol);
+        priced = false;
+
+        // to avoid shifts we restrict tolerances in the ratio test
+        if (loopCount > 0) {
+          lastDelta = (lastDelta < leavetol()) ? lastDelta : leavetol();
+          lastDelta *= 0.01;
+          theratiotester->setDelta(lastDelta);
+          assert(theratiotester->getDelta() > 0);
+          MSG_DEBUG(std::cout << "decreased delta for ratiotest to: "
+                              << theratiotester->getDelta() << std::endl;)
+        } else {
+          lastDelta = 1;
+          theratiotester->setDelta(leavetol());
+        }
+
+        printDisplayLine(true);
+
+        do {
+          printDisplayLine();
+
+          leaveNum = thepricer->selectLeave();
+
+          if (leaveNum < 0 && instableLeaveNum >= 0 &&
+              this->lastUpdate() == 0) {
+            /* no leaving variable was found, but because of instableLeaveNum >=
+               0 we know that this is due to the scaling of theCoTest[...].
+               Thus, we use instableLeaveNum and SPxFastRT<R>::selectEnter shall
+               accept even an instable entering variable. */
             MSG_INFO3((*this->spxout),
-                      (*this->spxout) << " --- leave finished. iteration: " << this->iteration()
-                      << ", value: " << value()
-                      << ", shift: " << shift()
-                      << ", epsilon: " << epsilon()
-                      << ", feastol: " << feastol()
-                      << ", opttol: " << opttol()
-                      << std::endl
-                      << "ISOLVE57 stop: " << stop
-                      << ", basis status: " << static_cast<int>(SPxBasisBase<R>::status()) << " (" << static_cast<int>
-                      (SPxBasisBase<R>::status()) << ")"
-                      << ", solver status: " << static_cast<int>(m_status) << " (" << static_cast<int>
-                      (m_status) << ")" << std::endl;
-                     )
-
-            if(!stop)
-            {
-               if(shift() < minShift)
-               {
-                  minShift = shift();
-                  cycleCount = 0;
-               }
-               else
-               {
-                  cycleCount++;
-
-                  if(cycleCount > MAXCYCLES)
-                  {
-                     m_status = ABORT_CYCLING;
-                     throw SPxStatusException("XSOLVE13 Abort solving due to cycling");
-                  }
-
-                  MSG_INFO3((*this->spxout),
-                            (*this->spxout) << " --- maxInfeas: " << maxInfeas()
-                            << ", shift: " << shift()
-                            << ", leavetol: " << leavetol()
-                            << ", cycle count: " << cycleCount << std::endl;
-                           )
-               }
-
-               /**@todo technically it would be ok to finish already when (priced && maxinfeas + shift() <= entertol()) is
-                *  satisfied; maybe at least in the case when SoPlex keeps jumping back between ENTER and LEAVE always
-                *  shifting (looping), we may relax this condition here;
-                *  note also that unShift may increase shift() slightly due to roundoff errors
-                */
-               if(shift() <= epsilon())
-               {
-                  cycleCount = 0;
-                  // factorize();
-                  unShift();
-
-                  R maxinfeas = maxInfeas();
-
-                  MSG_INFO3((*this->spxout),
-                            (*this->spxout) << " --- maxInfeas: " << maxinfeas
-                            << ", shift: " << shift()
-                            << ", leavetol: " << leavetol() << std::endl;
-                           )
-
-                  // We stop if we are indeed optimal, or if we have already been
-                  // two times at this place. In this case it seems futile to
-                  // continue.
-                  if(priced && maxinfeas + shift() <= leavetol())
-                  {
-                     setBasisStatus(SPxBasisBase<R>::OPTIMAL);
-                     m_status = OPTIMAL;
-                     break;
-                  }
-                  else if(loopCount > 2)
-                  {
-                     // calculate problem ranges if not done already
-                     if(boundrange == 0.0 || siderange == 0.0 || objrange == 0.0)
-                        calculateProblemRanges();
-
-                     if(MAXIMUM(MAXIMUM(boundrange, siderange), objrange) >= 1e9)
-                     {
-                        SPxOut::setScientific(spxout->getCurrentStream(), 0);
-                        MSG_INFO1((*this->spxout), (*this->spxout) <<
-                                  " --- termination despite violations (numerical difficulties,"
-                                  << " bound range = " << boundrange
-                                  << ", side range = " << siderange
-                                  << ", obj range = " << objrange
-                                  << ")" << std::endl;)
-                        setBasisStatus(SPxBasisBase<R>::OPTIMAL);
-                        m_status = OPTIMAL;
-                        break;
-                     }
-                     else
-                     {
-                        m_status = ABORT_CYCLING;
-                        throw SPxStatusException("XSOLVE14 Abort solving due to looping");
-                     }
-                  }
-
-                  loopCount++;
-               }
-
-               setType(ENTER);
-               init();
-               thepricer->setType(type());
-               theratiotester->setType(type());
+                      (*this->spxout) << " --- trying instable leave iteration"
+                                      << std::endl;)
+
+            leaveNum = instableLeaveNum;
+            instableLeave = true;
+            // we also need to reset the fTest() value for getLeaveVals()
+            assert(instableLeaveVal < 0);
+            theCoTest[instableLeaveNum] = instableLeaveVal;
+
+            if (sparsePricingLeave) {
+              if (isInfeasible[instableLeaveNum] ==
+                  SPxPricer<R>::NOT_VIOLATED) {
+                infeasibilities.addIdx(instableLeaveNum);
+                isInfeasible[instableLeaveNum] = SPxPricer<R>::VIOLATED;
+              }
+
+              if (hyperPricingLeave)
+                updateViols.addIdx(instableLeaveNum);
             }
-         }
-
-         assert(m_status != SINGULAR);
-
-      }
-      catch(const SPxException& E)
-      {
-         // if we stopped due to a singular basis, we reload the original basis and try again with tighter
-         // tolerance (only once)
-         if(m_status == SINGULAR && !tightened)
-         {
-            tightenedtype = type();
-
-            if(tightenedtype == ENTER)
-            {
-               m_entertol = 0.01 * m_entertol;
-
-               MSG_INFO2((*this->spxout), (*this->spxout) <<
-                         " --- basis singular: reloading basis and solving with tighter ratio test tolerance " << m_entertol
-                         << std::endl;)
+          } else {
+            instableLeave = false;
+          }
+
+          if (leaveNum < 0) {
+            // we are not infeasible and have no shift
+            if (shift() <= epsilon() &&
+                (SPxBasisBase<R>::status() == SPxBasisBase<R>::REGULAR ||
+                 SPxBasisBase<R>::status() == SPxBasisBase<R>::DUAL ||
+                 SPxBasisBase<R>::status() == SPxBasisBase<R>::PRIMAL)) {
+              R newpricertol = minpricertol;
+
+              // refactorize to eliminate accumulated errors from LU updates
+              if (this->lastUpdate() > 0)
+                factorize();
+
+              // recompute Fvec, Pvec and CoPvec to get a more precise solution
+              // and obj value
+              computeFrhs();
+              SPxBasisBase<R>::solve(*theFvec, *theFrhs);
+
+              computeLeaveCoPrhs();
+              SPxBasisBase<R>::coSolve(*theCoPvec, *theCoPrhs);
+              computePvec();
+
+              forceRecompNonbasicValue();
+
+              MSG_INFO2((*this->spxout),
+                        (*this->spxout)
+                            << " --- checking feasibility and optimality\n")
+              computeFtest();
+
+              // is the solution good enough ?
+              // max three times reduced
+              if ((thepricer->epsilon() > minpricertol) &&
+                  !precisionReached(newpricertol)) {
+                // no
+                // we reduce the pricer tolerance. Note that if the pricer does
+                // not find a candiate with the reduced pricer tolerance, we
+                // quit, regardless of the violations.
+                if (newpricertol < minpricertol)
+                  newpricertol = minpricertol;
+
+                thepricer->setEpsilon(newpricertol);
+
+                MSG_INFO2((*this->spxout),
+                          (*this->spxout)
+                              << " --- setting pricer tolerance to "
+                              << thepricer->epsilon() << std::endl;);
+              }
             }
-            else
-            {
-               m_leavetol = 0.01 * m_leavetol;
 
-               MSG_INFO2((*this->spxout), (*this->spxout) <<
-                         " --- basis singular: reloading basis and solving with tighter ratio test tolerance " << m_leavetol
-                         << std::endl;)
+            // if the factorization is not fresh, we better refactorize and call
+            // the pricer again; however, this can create cycling, so it is
+            // performed only a limited number of times per LEAVE round
+            if (this->lastUpdate() > 0 && leaveFacPivotCount < MAXREFACPIVOTS) {
+              MSG_INFO3((*this->spxout),
+                        (*this->spxout)
+                            << " --- solve(leave) triggers refactorization"
+                            << std::endl;)
+
+              factorize();
+
+              // Inna/Tobi: if the factorization was found out to be singular,
+              // we have to quit
+              if (SPxBasisBase<R>::status() < SPxBasisBase<R>::REGULAR) {
+                MSG_INFO1(
+                    (*this->spxout),
+                    (*this->spxout)
+                        << "Something wrong with factorization, Basis status: "
+                        << static_cast<int>(SPxBasisBase<R>::status())
+                        << std::endl;)
+                stop = true;
+                break;
+              }
+
+              // call pricer again
+              leaveNum = thepricer->selectLeave();
+
+              // count how often the pricer has found something only after
+              // refactorizing
+              if (leaveNum >= 0)
+                leaveFacPivotCount++;
             }
 
-            // load original basis
-            int niters = iterations();
-            loadBasis(regulardesc);
-
-            // remember iteration count
-            this->iterCount = niters;
-
-            // try initializing basis (might fail if starting basis was already singular)
-            try
-            {
-               init();
-               theratiotester->setType(type());
+            if (leaveNum < 0) {
+              priced = true;
+              break;
             }
-            catch(const SPxException& Ex)
-            {
-               MSG_INFO2((*this->spxout), (*this->spxout) <<
-                         " --- reloaded basis singular, resetting original tolerances" << std::endl;)
-
-               if(tightenedtype == ENTER)
-                  m_entertol = 100.0 * m_entertol;
-               else
-                  m_leavetol = 100.0 * m_leavetol;
-
-               theratiotester->setType(type());
-
-               throw Ex;
+          }
+
+          /* check if we have iterations left */
+          if (maxIters >= 0 && iterations() >= maxIters) {
+            MSG_INFO2((*this->spxout),
+                      (*this->spxout) << " --- maximum number of iterations ("
+                                      << maxIters << ") reached" << std::endl;)
+            m_status = ABORT_ITER;
+            stop = true;
+            break;
+          }
+
+          if (interrupt != NULL && *interrupt) {
+            MSG_INFO2((*this->spxout),
+                      (*this->spxout) << " --- aborted due to interrupt signal"
+                                      << std::endl;)
+            m_status = ABORT_TIME;
+            stop = true;
+            break;
+          }
+
+          leave(leaveNum);
+          assert((testBounds(), 1));
+          thepricer->left4(this->lastIndex(), this->lastLeft());
+          stop = terminate();
+          clearUpdateVecs();
+
+          /* if a successful pivot was performed or a nonbasic variable was
+           * flipped to its other bound, we reset the cycle counter
+           */
+          if (this->lastIndex() >= 0)
+            leaveCycleCount = 0;
+          else if (basis().status() != SPxBasisBase<R>::INFEASIBLE &&
+                   basis().status() != SPxBasisBase<R>::UNBOUNDED) {
+            leaveCycleCount++;
+
+            if (leaveCycleCount > MAXCYCLES) {
+              MSG_INFO2((*this->spxout), (*this->spxout)
+                                             << " --- abort solving due to "
+                                                "cycling in leaving algorithm"
+                                             << std::endl;);
+              m_status = ABORT_CYCLING;
+              stop = true;
+            }
+          }
+
+          /* only if the basis has really changed, we increase the iterations
+           * counter; this is not the case when only a nonbasic variable was
+           * flipped to its other bound
+           */
+          if (this->lastEntered().isValid()) {
+            leaveCount++;
+            assert(this->lastIndex() >= 0);
+          }
+
+          /* check every MAXSTALLS iterations whether shift and objective value
+           * have not changed */
+          if ((this->iteration() - stallRefIter) % MAXSTALLS == 0 &&
+              basis().status() != SPxBasisBase<R>::INFEASIBLE) {
+            if (spxAbs(value() - stallRefValue) <= epsilon() &&
+                spxAbs(shift() - stallRefShift) <= epsilon()) {
+              if (stallNumRecovers < MAXSTALLRECOVERS) {
+                /* try to recover by switching algorithm up to MAXSTALLRECOVERS
+                 * times */
+                MSG_INFO3((*this->spxout),
+                          (*this->spxout)
+                              << " --- stalling detected - trying to recover "
+                                 "by switching to ENTERING algorithm."
+                              << std::endl;)
+
+                ++stallNumRecovers;
+                break;
+              } else {
+                /* giving up */
+                MSG_INFO2((*this->spxout),
+                          (*this->spxout) << " --- abort solving due to "
+                                             "stalling in leaving algorithm"
+                                          << std::endl;);
+
+                m_status = ABORT_CYCLING;
+                stop = true;
+              }
+            } else {
+              /* merely update reference values */
+              stallRefIter = this->iteration() - 1;
+              stallRefShift = shift();
+              stallRefValue = value();
+            }
+          }
+
+          //@ assert(isConsistent());
+        } while (!stop);
+
+        MSG_INFO3((*this->spxout),
+                  (*this->spxout)
+                      << " --- leave finished. iteration: " << this->iteration()
+                      << ", value: " << value() << ", shift: " << shift()
+                      << ", epsilon: " << epsilon() << ", feastol: "
+                      << feastol() << ", opttol: " << opttol() << std::endl
+                      << "ISOLVE57 stop: " << stop << ", basis status: "
+                      << static_cast<int>(SPxBasisBase<R>::status()) << " ("
+                      << static_cast<int>(SPxBasisBase<R>::status()) << ")"
+                      << ", solver status: " << static_cast<int>(m_status)
+                      << " (" << static_cast<int>(m_status) << ")"
+                      << std::endl;)
+
+        if (!stop) {
+          if (shift() < minShift) {
+            minShift = shift();
+            cycleCount = 0;
+          } else {
+            cycleCount++;
+
+            if (cycleCount > MAXCYCLES) {
+              m_status = ABORT_CYCLING;
+              throw SPxStatusException("XSOLVE13 Abort solving due to cycling");
             }
 
-            // reset status and counters
-            m_status = RUNNING;
-            m_numCycle = 0;
-            leaveCount = 0;
-            enterCount = 0;
-            stallNumRecovers = 0;
-
-            // continue
-            stop = false;
-            tightened = true;
-         }
-         // reset tolerance to its original value and pass on the exception
-         else if(tightened)
-         {
-            if(tightenedtype == ENTER)
-               m_entertol = 100.0 * m_entertol;
-            else
-               m_leavetol = 100.0 * m_leavetol;
-
-            theratiotester->setType(type());
-
-            throw E;
-         }
-         // pass on the exception
-         else
-            throw E;
-      }
-   }
-
-   // reset tolerance to its original value
-   if(tightened)
-   {
-      if(tightenedtype == ENTER)
-         m_entertol = 100.0 * m_entertol;
-      else
-         m_leavetol = 100.0 * m_leavetol;
+            MSG_INFO3((*this->spxout),
+                      (*this->spxout)
+                          << " --- maxInfeas: " << maxInfeas() << ", shift: "
+                          << shift() << ", leavetol: " << leavetol()
+                          << ", cycle count: " << cycleCount << std::endl;)
+          }
+
+          /**@todo technically it would be ok to finish already when (priced &&
+           * maxinfeas + shift() <= entertol()) is satisfied; maybe at least in
+           * the case when SoPlex keeps jumping back between ENTER and LEAVE
+           * always shifting (looping), we may relax this condition here; note
+           * also that unShift may increase shift() slightly due to roundoff
+           * errors
+           */
+          if (shift() <= epsilon()) {
+            cycleCount = 0;
+            // factorize();
+            unShift();
+
+            R maxinfeas = maxInfeas();
+
+            MSG_INFO3((*this->spxout), (*this->spxout)
+                                           << " --- maxInfeas: " << maxinfeas
+                                           << ", shift: " << shift()
+                                           << ", leavetol: " << leavetol()
+                                           << std::endl;)
+
+            // We stop if we are indeed optimal, or if we have already been
+            // two times at this place. In this case it seems futile to
+            // continue.
+            if (priced && maxinfeas + shift() <= leavetol()) {
+              setBasisStatus(SPxBasisBase<R>::OPTIMAL);
+              m_status = OPTIMAL;
+              break;
+            } else if (loopCount > 2) {
+              // calculate problem ranges if not done already
+              if (boundrange == 0.0 || siderange == 0.0 || objrange == 0.0)
+                calculateProblemRanges();
+
+              if (MAXIMUM(MAXIMUM(boundrange, siderange), objrange) >= 1e9) {
+                SPxOut::setScientific(spxout->getCurrentStream(), 0);
+                MSG_INFO1((*this->spxout),
+                          (*this->spxout)
+                              << " --- termination despite violations "
+                                 "(numerical difficulties,"
+                              << " bound range = " << boundrange
+                              << ", side range = " << siderange
+                              << ", obj range = " << objrange << ")"
+                              << std::endl;)
+                setBasisStatus(SPxBasisBase<R>::OPTIMAL);
+                m_status = OPTIMAL;
+                break;
+              } else {
+                m_status = ABORT_CYCLING;
+                throw SPxStatusException(
+                    "XSOLVE14 Abort solving due to looping");
+              }
+            }
 
-      theratiotester->setType(type());
-   }
+            loopCount++;
+          }
 
-   theTime->stop();
-   theCumulativeTime += time();
+          setType(ENTER);
+          init();
+          thepricer->setType(type());
+          theratiotester->setType(type());
+        }
+      }
 
-   if(m_status == RUNNING)
-   {
-      m_status = ERROR;
-      throw SPxStatusException("XSOLVE05 Status is still RUNNING when it shouldn't be");
-   }
+      assert(m_status != SINGULAR);
+
+    } catch (const SPxException &E) {
+      // if we stopped due to a singular basis, we reload the original basis and
+      // try again with tighter tolerance (only once)
+      if (m_status == SINGULAR && !tightened) {
+        tightenedtype = type();
+
+        if (tightenedtype == ENTER) {
+          m_entertol = 0.01 * m_entertol;
+
+          MSG_INFO2((*this->spxout),
+                    (*this->spxout)
+                        << " --- basis singular: reloading basis and solving "
+                           "with tighter ratio test tolerance "
+                        << m_entertol << std::endl;)
+        } else {
+          m_leavetol = 0.01 * m_leavetol;
+
+          MSG_INFO2((*this->spxout),
+                    (*this->spxout)
+                        << " --- basis singular: reloading basis and solving "
+                           "with tighter ratio test tolerance "
+                        << m_leavetol << std::endl;)
+        }
+
+        // load original basis
+        int niters = iterations();
+        loadBasis(regulardesc);
+
+        // remember iteration count
+        this->iterCount = niters;
+
+        // try initializing basis (might fail if starting basis was already
+        // singular)
+        try {
+          init();
+          theratiotester->setType(type());
+        } catch (const SPxException &Ex) {
+          MSG_INFO2((*this->spxout), (*this->spxout)
+                                         << " --- reloaded basis singular, "
+                                            "resetting original tolerances"
+                                         << std::endl;)
+
+          if (tightenedtype == ENTER)
+            m_entertol = 100.0 * m_entertol;
+          else
+            m_leavetol = 100.0 * m_leavetol;
+
+          theratiotester->setType(type());
+
+          throw Ex;
+        }
+
+        // reset status and counters
+        m_status = RUNNING;
+        m_numCycle = 0;
+        leaveCount = 0;
+        enterCount = 0;
+        stallNumRecovers = 0;
+
+        // continue
+        stop = false;
+        tightened = true;
+      }
+      // reset tolerance to its original value and pass on the exception
+      else if (tightened) {
+        if (tightenedtype == ENTER)
+          m_entertol = 100.0 * m_entertol;
+        else
+          m_leavetol = 100.0 * m_leavetol;
 
-   MSG_INFO3((*this->spxout),
-             (*this->spxout) << "Finished solving (status=" << static_cast<int>(status())
-             << ", iters=" << this->iterCount
-             << ", leave=" << leaveCount
-             << ", enter=" << enterCount
-             << ", flips=" << totalboundflips;
+        theratiotester->setType(type());
 
-             if(status() == OPTIMAL)
-             (*this->spxout) << ", objValue=" << value();
-             (*this->spxout) << ")" << std::endl;
-            )
+        throw E;
+      }
+      // pass on the exception
+      else
+        throw E;
+    }
+  }
+
+  // reset tolerance to its original value
+  if (tightened) {
+    if (tightenedtype == ENTER)
+      m_entertol = 100.0 * m_entertol;
+    else
+      m_leavetol = 100.0 * m_leavetol;
+
+    theratiotester->setType(type());
+  }
+
+  theTime->stop();
+  theCumulativeTime += time();
+
+  if (m_status == RUNNING) {
+    m_status = ERROR;
+    throw SPxStatusException(
+        "XSOLVE05 Status is still RUNNING when it shouldn't be");
+  }
+
+  MSG_INFO3((*this->spxout),
+            (*this->spxout)
+                << "Finished solving (status=" << static_cast<int>(status())
+                << ", iters=" << this->iterCount << ", leave=" << leaveCount
+                << ", enter=" << enterCount << ", flips=" << totalboundflips;
+
+            if (status() == OPTIMAL)(*this->spxout) << ", objValue=" << value();
+            (*this->spxout) << ")" << std::endl;)
 
 #ifdef ENABLE_ADDITIONAL_CHECKS
 
-      /* check if solution is really feasible */
-      if(status() == OPTIMAL)
-      {
-         int     c;
-         R    val;
-         VectorBase<R> sol(this->nCols());
-
-         getPrimalSol(sol);
-
-         for(int row = 0; row < this->nRows(); ++row)
-         {
-            const SVectorBase<R>& rowvec = this->rowVector(row);
-            val = 0.0;
-
-            for(c = 0; c < rowvec.size(); ++c)
-               val += rowvec.value(c) * sol[rowvec.index(c)];
-
-            if(LT(val, this->lhs(row), feastol()) ||
-                  GT(val, this->rhs(row), feastol()))
-            {
-               // Minor rhs violations happen frequently, so print these
-               // warnings only with verbose level INFO2 and higher.
-               MSG_INFO2((*this->spxout), (*this->spxout) << "WSOLVE88 Warning! Constraint " << row
-                         << " is violated by solution" << std::endl
-                         << "   lhs:" << this->lhs(row)
-                         << " <= val:" << val
-                         << " <= rhs:" << this->rhs(row) << std::endl;)
-
-               if(type() == LEAVE && isRowBasic(row))
-               {
-                  // find basis variable
-                  for(c = 0; c < this->nRows(); ++c)
-                     if(basis().baseId(c).isSPxRowId()
-                           && (this->number(basis().baseId(c)) == row))
-                        break;
-
-                  assert(c < this->nRows());
-
-                  MSG_WARNING((*this->spxout), (*this->spxout) << "WSOLVE90 basis idx:" << c
-                              << " fVec:" << fVec()[c]
-                              << " fRhs:" << fRhs()[c]
-                              << " fTest:" << fTest()[c] << std::endl;)
-               }
-            }
-         }
-
-         for(int col = 0; col < this->nCols(); ++col)
-         {
-            if(LT(sol[col], this->lower(col), feastol()) ||
-                  GT(sol[col], this->upper(col), feastol()))
-            {
-               // Minor bound violations happen frequently, so print these
-               // warnings only with verbose level INFO2 and higher.
-               MSG_INFO2((*this->spxout), (*this->spxout) << "WSOLVE91 Warning! Bound for column " << col
-                         << " is violated by solution" << std::endl
-                         << "   lower:" << this->lower(col)
-                         << " <= val:" << sol[col]
-                         << " <= upper:" << this->upper(col) << std::endl;)
-
-               if(type() == LEAVE && isColBasic(col))
-               {
-                  for(c = 0; c < this->nRows() ; ++c)
-                     if(basis().baseId(c).isSPxColId()
-                           && (this->number(basis().baseId(c)) == col))
-                        break;
-
-                  assert(c < this->nRows());
-                  MSG_WARNING((*this->spxout), (*this->spxout) << "WSOLVE92 basis idx:" << c
-                              << " fVec:" << fVec()[c]
-                              << " fRhs:" << fRhs()[c]
-                              << " fTest:" << fTest()[c] << std::endl;)
-               }
-            }
-         }
+  /* check if solution is really feasible */
+  if (status() == OPTIMAL) {
+    int c;
+    R val;
+    VectorBase<R> sol(this->nCols());
+
+    getPrimalSol(sol);
+
+    for (int row = 0; row < this->nRows(); ++row) {
+      const SVectorBase<R> &rowvec = this->rowVector(row);
+      val = 0.0;
+
+      for (c = 0; c < rowvec.size(); ++c)
+        val += rowvec.value(c) * sol[rowvec.index(c)];
+
+      if (LT(val, this->lhs(row), feastol()) ||
+          GT(val, this->rhs(row), feastol())) {
+        // Minor rhs violations happen frequently, so print these
+        // warnings only with verbose level INFO2 and higher.
+        MSG_INFO2((*this->spxout),
+                  (*this->spxout)
+                      << "WSOLVE88 Warning! Constraint " << row
+                      << " is violated by solution" << std::endl
+                      << "   lhs:" << this->lhs(row) << " <= val:" << val
+                      << " <= rhs:" << this->rhs(row) << std::endl;)
+
+        if (type() == LEAVE && isRowBasic(row)) {
+          // find basis variable
+          for (c = 0; c < this->nRows(); ++c)
+            if (basis().baseId(c).isSPxRowId() &&
+                (this->number(basis().baseId(c)) == row))
+              break;
+
+          assert(c < this->nRows());
+
+          MSG_WARNING((*this->spxout),
+                      (*this->spxout) << "WSOLVE90 basis idx:" << c << " fVec:"
+                                      << fVec()[c] << " fRhs:" << fRhs()[c]
+                                      << " fTest:" << fTest()[c] << std::endl;)
+        }
       }
+    }
+
+    for (int col = 0; col < this->nCols(); ++col) {
+      if (LT(sol[col], this->lower(col), feastol()) ||
+          GT(sol[col], this->upper(col), feastol())) {
+        // Minor bound violations happen frequently, so print these
+        // warnings only with verbose level INFO2 and higher.
+        MSG_INFO2((*this->spxout),
+                  (*this->spxout)
+                      << "WSOLVE91 Warning! Bound for column " << col
+                      << " is violated by solution" << std::endl
+                      << "   lower:" << this->lower(col)
+                      << " <= val:" << sol[col]
+                      << " <= upper:" << this->upper(col) << std::endl;)
+
+        if (type() == LEAVE && isColBasic(col)) {
+          for (c = 0; c < this->nRows(); ++c)
+            if (basis().baseId(c).isSPxColId() &&
+                (this->number(basis().baseId(c)) == col))
+              break;
+
+          assert(c < this->nRows());
+          MSG_WARNING((*this->spxout),
+                      (*this->spxout) << "WSOLVE92 basis idx:" << c << " fVec:"
+                                      << fVec()[c] << " fRhs:" << fRhs()[c]
+                                      << " fTest:" << fTest()[c] << std::endl;)
+        }
+      }
+    }
+  }
 
-#endif  // ENABLE_ADDITIONAL_CHECKS
-
+#endif // ENABLE_ADDITIONAL_CHECKS
 
-   primalCount = (rep() == SPxSolverBase<R>::COLUMN)
-                 ? enterCount
-                 : leaveCount;
+  primalCount = (rep() == SPxSolverBase<R>::COLUMN) ? enterCount : leaveCount;
 
-   printDisplayLine(true);
-   performSolutionPolishing();
+  printDisplayLine(true);
+  performSolutionPolishing();
 
-   return status();
+  return status();
 }
 
-template <class R>
-void SPxSolverBase<R>::performSolutionPolishing()
-{
-   // catch rare case that the iteration limit is exactly reached at optimality
-   bool stop = (maxIters >= 0 && iterations() >= maxIters && !isTimeLimitReached());
-
-   // only polish an already optimal basis
-   if(stop || polishObj == POLISH_OFF || status() != OPTIMAL)
-      return;
-
-   int nSuccessfulPivots;
-   const typename SPxBasisBase<R>::Desc& ds = this->desc();
-   const typename SPxBasisBase<R>::Desc::Status* rowstatus = ds.rowStatus();
-   const typename SPxBasisBase<R>::Desc::Status* colstatus = ds.colStatus();
-   typename SPxBasisBase<R>::Desc::Status stat;
-   SPxId polishId;
-   bool success = false;
-
-   MSG_INFO2((*this->spxout), (*this->spxout) << " --- perform solution polishing" << std::endl;)
-
-   if(rep() == COLUMN)
-   {
-      setType(ENTER); // use primal simplex to preserve feasibility
-      init();
+template <class R> void SPxSolverBase<R>::performSolutionPolishing() {
+  // catch rare case that the iteration limit is exactly reached at optimality
+  bool stop =
+      (maxIters >= 0 && iterations() >= maxIters && !isTimeLimitReached());
+
+  // only polish an already optimal basis
+  if (stop || polishObj == POLISH_OFF || status() != OPTIMAL)
+    return;
+
+  int nSuccessfulPivots;
+  const typename SPxBasisBase<R>::Desc &ds = this->desc();
+  const typename SPxBasisBase<R>::Desc::Status *rowstatus = ds.rowStatus();
+  const typename SPxBasisBase<R>::Desc::Status *colstatus = ds.colStatus();
+  typename SPxBasisBase<R>::Desc::Status stat;
+  SPxId polishId;
+  bool success = false;
+
+  MSG_INFO2((*this->spxout),
+            (*this->spxout) << " --- perform solution polishing" << std::endl;)
+
+  if (rep() == COLUMN) {
+    setType(ENTER); // use primal simplex to preserve feasibility
+    init();
 #ifndef NDEBUG
-      // allow a small relative deviation from the original values
-      R alloweddeviation = entertol();
-      R origval = value();
-      R origshift = shift();
+    // allow a small relative deviation from the original values
+    R alloweddeviation = entertol();
+    R origval = value();
+    R origshift = shift();
 #endif
-      instableEnter = false;
-      theratiotester->setType(type());
+    instableEnter = false;
+    theratiotester->setType(type());
+
+    int nrows = this->nRows();
+    int ncols = this->nCols();
+
+    if (polishObj == POLISH_INTEGRALITY) {
+      DIdxSet slackcandidates(nrows);
+      DIdxSet continuousvars(ncols);
+
+      // collect nonbasic slack variables that could be made basic
+      for (int i = 0; i < nrows; ++i) {
+        // only check nonbasic rows, skip equations
+        if (rowstatus[i] == SPxBasisBase<R>::Desc::P_ON_LOWER ||
+            rowstatus[i] == SPxBasisBase<R>::Desc::P_ON_UPPER) {
+          // only consider rows with zero dual multiplier to preserve optimality
+          if (EQrel((*theCoPvec)[i], (R)0))
+            slackcandidates.addIdx(i);
+        }
+      }
 
-      int nrows = this->nRows();
-      int ncols = this->nCols();
+      // collect continuous variables that could be made basic
+      if (integerVariables.size() == ncols) {
+        for (int i = 0; i < ncols; ++i) {
+          // skip fixed variables
+          if (colstatus[i] == SPxBasisBase<R>::Desc::P_ON_LOWER ||
+              colstatus[i] == SPxBasisBase<R>::Desc::P_ON_UPPER) {
+            // only consider continuous variables with zero dual multiplier to
+            // preserve optimality
+            if (EQrel(this->maxObj(i) - (*thePvec)[i], (R)0) &&
+                integerVariables[i] == 0)
+              continuousvars.addIdx(i);
+          }
+        }
+      }
 
-      if(polishObj == POLISH_INTEGRALITY)
-      {
-         DIdxSet slackcandidates(nrows);
-         DIdxSet continuousvars(ncols);
-
-         // collect nonbasic slack variables that could be made basic
-         for(int i = 0; i < nrows; ++i)
-         {
-            // only check nonbasic rows, skip equations
-            if(rowstatus[i] ==  SPxBasisBase<R>::Desc::P_ON_LOWER
-                  || rowstatus[i] == SPxBasisBase<R>::Desc::P_ON_UPPER)
-            {
-               // only consider rows with zero dual multiplier to preserve optimality
-               if(EQrel((*theCoPvec)[i], (R) 0))
-                  slackcandidates.addIdx(i);
-            }
-         }
-
-         // collect continuous variables that could be made basic
-         if(integerVariables.size() == ncols)
-         {
-            for(int i = 0; i < ncols; ++i)
-            {
-               // skip fixed variables
-               if(colstatus[i] == SPxBasisBase<R>::Desc::P_ON_LOWER
-                     || colstatus[i] ==  SPxBasisBase<R>::Desc::P_ON_UPPER)
-               {
-                  // only consider continuous variables with zero dual multiplier to preserve optimality
-                  if(EQrel(this->maxObj(i) - (*thePvec)[i], (R) 0) && integerVariables[i] == 0)
-                     continuousvars.addIdx(i);
-               }
-            }
-         }
-
-         while(!stop)
-         {
-            nSuccessfulPivots = 0;
-
-            // identify nonbasic slack variables, i.e. rows, that may be moved into the basis
-            for(int i = slackcandidates.size() - 1; i >= 0 && !stop; --i)
-            {
-               polishId = coId(slackcandidates.index(i));
-               MSG_DEBUG(std::cout << "try pivoting: " << polishId << " stat: " << rowstatus[slackcandidates.index(
-                            i)];)
-               success = enter(polishId, true);
-               clearUpdateVecs();
+      while (!stop) {
+        nSuccessfulPivots = 0;
+
+        // identify nonbasic slack variables, i.e. rows, that may be moved into
+        // the basis
+        for (int i = slackcandidates.size() - 1; i >= 0 && !stop; --i) {
+          polishId = coId(slackcandidates.index(i));
+          MSG_DEBUG(std::cout << "try pivoting: " << polishId << " stat: "
+                              << rowstatus[slackcandidates.index(i)];)
+          success = enter(polishId, true);
+          clearUpdateVecs();
 #ifndef NDEBUG
-               assert(EQrel(value(), origval, alloweddeviation));
-               assert(LErel(shift(), origshift, alloweddeviation));
+          assert(EQrel(value(), origval, alloweddeviation));
+          assert(LErel(shift(), origshift, alloweddeviation));
 #endif
 
-               if(success)
-               {
-                  MSG_DEBUG(std::cout << " -> success!";)
-                  ++nSuccessfulPivots;
-                  slackcandidates.remove(i);
+          if (success) {
+            MSG_DEBUG(std::cout << " -> success!";)
+            ++nSuccessfulPivots;
+            slackcandidates.remove(i);
 
-                  if(maxIters >= 0 && iterations() >= maxIters)
-                     stop = true;
-               }
+            if (maxIters >= 0 && iterations() >= maxIters)
+              stop = true;
+          }
 
-               MSG_DEBUG(std::cout << std::endl;)
+          MSG_DEBUG(std::cout << std::endl;)
 
-               if(isTimeLimitReached())
-                  stop = true;
-            }
+          if (isTimeLimitReached())
+            stop = true;
+        }
 
-            // identify nonbasic variables that may be moved into the basis
-            for(int i = continuousvars.size() - 1; i >= 0 && !stop; --i)
-            {
-               polishId = id(continuousvars.index(i));
-               MSG_DEBUG(std::cout << "try pivoting: " << polishId << " stat: " << colstatus[continuousvars.index(
-                            i)];)
-               success = enter(polishId, true);
-               clearUpdateVecs();
-
-               if(success)
-               {
-                  MSG_DEBUG(std::cout << " -> success!";)
-                  ++nSuccessfulPivots;
-                  continuousvars.remove(i);
-
-                  if(maxIters >= 0 && iterations() >= maxIters)
-                     stop = true;
-               }
-
-               MSG_DEBUG(std::cout << std::endl;)
-
-               if(isTimeLimitReached())
-                  stop = true;
-            }
+        // identify nonbasic variables that may be moved into the basis
+        for (int i = continuousvars.size() - 1; i >= 0 && !stop; --i) {
+          polishId = id(continuousvars.index(i));
+          MSG_DEBUG(std::cout << "try pivoting: " << polishId << " stat: "
+                              << colstatus[continuousvars.index(i)];)
+          success = enter(polishId, true);
+          clearUpdateVecs();
+
+          if (success) {
+            MSG_DEBUG(std::cout << " -> success!";)
+            ++nSuccessfulPivots;
+            continuousvars.remove(i);
 
-            // terminate if in the last round no more polishing steps were performed
-            if(nSuccessfulPivots == 0)
-               stop = true;
+            if (maxIters >= 0 && iterations() >= maxIters)
+              stop = true;
+          }
 
-            polishCount += nSuccessfulPivots;
-         }
+          MSG_DEBUG(std::cout << std::endl;)
+
+          if (isTimeLimitReached())
+            stop = true;
+        }
+
+        // terminate if in the last round no more polishing steps were performed
+        if (nSuccessfulPivots == 0)
+          stop = true;
+
+        polishCount += nSuccessfulPivots;
       }
-      else
-      {
-         assert(polishObj == POLISH_FRACTIONALITY);
-         DIdxSet candidates(dim());
-
-         // identify nonbasic variables, i.e. columns, that may be moved into the basis
-         for(int i = 0; i < this->nCols() && !stop; ++i)
-         {
-            if(colstatus[i] == SPxBasisBase<R>::Desc::P_ON_LOWER
-                  || colstatus[i] == SPxBasisBase<R>::Desc::P_ON_UPPER)
-            {
-               // only consider variables with zero reduced costs to preserve optimality
-               if(EQrel(this->maxObj(i) - (*thePvec)[i], (R) 0))
-                  candidates.addIdx(i);
-            }
-         }
-
-         while(!stop)
-         {
-            nSuccessfulPivots = 0;
-
-            for(int i = candidates.size() - 1; i >= 0 && !stop; --i)
-            {
-               polishId = id(candidates.index(i));
-               MSG_DEBUG(std::cout << "try pivoting: " << polishId << " stat: " << colstatus[candidates.index(i)];)
-               success = enter(polishId, true);
-               clearUpdateVecs();
+    } else {
+      assert(polishObj == POLISH_FRACTIONALITY);
+      DIdxSet candidates(dim());
+
+      // identify nonbasic variables, i.e. columns, that may be moved into the
+      // basis
+      for (int i = 0; i < this->nCols() && !stop; ++i) {
+        if (colstatus[i] == SPxBasisBase<R>::Desc::P_ON_LOWER ||
+            colstatus[i] == SPxBasisBase<R>::Desc::P_ON_UPPER) {
+          // only consider variables with zero reduced costs to preserve
+          // optimality
+          if (EQrel(this->maxObj(i) - (*thePvec)[i], (R)0))
+            candidates.addIdx(i);
+        }
+      }
+
+      while (!stop) {
+        nSuccessfulPivots = 0;
+
+        for (int i = candidates.size() - 1; i >= 0 && !stop; --i) {
+          polishId = id(candidates.index(i));
+          MSG_DEBUG(std::cout << "try pivoting: " << polishId
+                              << " stat: " << colstatus[candidates.index(i)];)
+          success = enter(polishId, true);
+          clearUpdateVecs();
 #ifndef NDEBUG
-               assert(EQrel(value(), origval, alloweddeviation));
-               assert(LErel(shift(), origshift, alloweddeviation));
+          assert(EQrel(value(), origval, alloweddeviation));
+          assert(LErel(shift(), origshift, alloweddeviation));
 #endif
 
-               if(success)
-               {
-                  MSG_DEBUG(std::cout << " -> success!";)
-                  ++nSuccessfulPivots;
-                  candidates.remove(i);
+          if (success) {
+            MSG_DEBUG(std::cout << " -> success!";)
+            ++nSuccessfulPivots;
+            candidates.remove(i);
 
-                  if(maxIters >= 0 && iterations() >= maxIters)
-                     stop = true;
-               }
+            if (maxIters >= 0 && iterations() >= maxIters)
+              stop = true;
+          }
 
-               MSG_DEBUG(std::cout << std::endl;)
+          MSG_DEBUG(std::cout << std::endl;)
 
-               if(isTimeLimitReached())
-                  stop = true;
-            }
+          if (isTimeLimitReached())
+            stop = true;
+        }
 
-            // terminate if in the last round no more polishing steps were performed
-            if(nSuccessfulPivots == 0)
-               stop = true;
+        // terminate if in the last round no more polishing steps were performed
+        if (nSuccessfulPivots == 0)
+          stop = true;
 
-            polishCount += nSuccessfulPivots;
-         }
+        polishCount += nSuccessfulPivots;
       }
-   }
-   else
-   {
-      setType(LEAVE); // use primal simplex to preserve feasibility
-      init();
+    }
+  } else {
+    setType(LEAVE); // use primal simplex to preserve feasibility
+    init();
 #ifndef NDEBUG
-      // allow a small relative deviation from the original values
-      R alloweddeviation = leavetol();
-      R origval = value();
-      R origshift = shift();
+    // allow a small relative deviation from the original values
+    R alloweddeviation = leavetol();
+    R origval = value();
+    R origshift = shift();
 #endif
-      instableLeave = false;
-      theratiotester->setType(type());
-      bool useIntegrality = false;
-      int ncols = this->nCols();
-
-      if(integerVariables.size() == ncols)
-         useIntegrality = true;
-
-      // in ROW rep: pivot slack out of the basis
-      if(polishObj == POLISH_INTEGRALITY)
-      {
-         DIdxSet basiccandidates(dim());
-
-         // collect basic candidates that may be moved out of the basis
-         for(int i = 0; i < dim(); ++i)
-         {
-            polishId = this->baseId(i);
-
-            if(polishId.isSPxRowId())
-               stat = ds.rowStatus(this->number(polishId));
-            else
-            {
-               // skip (integer) variables
-               if(!useIntegrality || integerVariables[this->number(SPxColId(polishId))] == 1)
-                  continue;
-
-               stat = ds.colStatus(this->number(polishId));
-            }
-
-            if(stat == SPxBasisBase<R>::Desc::P_ON_LOWER || stat ==  SPxBasisBase<R>::Desc::P_ON_UPPER)
-            {
-               if(EQrel((*theFvec)[i], (R) 0))
-                  basiccandidates.addIdx(i);
-            }
-         }
+    instableLeave = false;
+    theratiotester->setType(type());
+    bool useIntegrality = false;
+    int ncols = this->nCols();
+
+    if (integerVariables.size() == ncols)
+      useIntegrality = true;
+
+    // in ROW rep: pivot slack out of the basis
+    if (polishObj == POLISH_INTEGRALITY) {
+      DIdxSet basiccandidates(dim());
+
+      // collect basic candidates that may be moved out of the basis
+      for (int i = 0; i < dim(); ++i) {
+        polishId = this->baseId(i);
+
+        if (polishId.isSPxRowId())
+          stat = ds.rowStatus(this->number(polishId));
+        else {
+          // skip (integer) variables
+          if (!useIntegrality ||
+              integerVariables[this->number(SPxColId(polishId))] == 1)
+            continue;
+
+          stat = ds.colStatus(this->number(polishId));
+        }
+
+        if (stat == SPxBasisBase<R>::Desc::P_ON_LOWER ||
+            stat == SPxBasisBase<R>::Desc::P_ON_UPPER) {
+          if (EQrel((*theFvec)[i], (R)0))
+            basiccandidates.addIdx(i);
+        }
+      }
 
-         while(!stop)
-         {
-            nSuccessfulPivots = 0;
+      while (!stop) {
+        nSuccessfulPivots = 0;
 
-            for(int i = basiccandidates.size() - 1; i >= 0 && !stop; --i)
-            {
+        for (int i = basiccandidates.size() - 1; i >= 0 && !stop; --i) {
 
-               MSG_DEBUG(std::cout << "try pivoting: " << this->baseId(basiccandidates.index(i));)
-               success = leave(basiccandidates.index(i), true);
-               clearUpdateVecs();
+          MSG_DEBUG(std::cout << "try pivoting: "
+                              << this->baseId(basiccandidates.index(i));)
+          success = leave(basiccandidates.index(i), true);
+          clearUpdateVecs();
 #ifndef NDEBUG
-               assert(EQrel(value(), origval, alloweddeviation));
-               assert(LErel(shift(), origshift, alloweddeviation));
+          assert(EQrel(value(), origval, alloweddeviation));
+          assert(LErel(shift(), origshift, alloweddeviation));
 #endif
 
-               if(success)
-               {
-                  MSG_DEBUG(std::cout << " -> success!";)
-                  ++nSuccessfulPivots;
-                  basiccandidates.remove(i);
+          if (success) {
+            MSG_DEBUG(std::cout << " -> success!";)
+            ++nSuccessfulPivots;
+            basiccandidates.remove(i);
 
-                  if(maxIters >= 0 && iterations() >= maxIters)
-                     stop = true;
-               }
+            if (maxIters >= 0 && iterations() >= maxIters)
+              stop = true;
+          }
 
-               MSG_DEBUG(std::cout << std::endl;)
+          MSG_DEBUG(std::cout << std::endl;)
 
-               if(isTimeLimitReached())
-                  stop = true;
-            }
+          if (isTimeLimitReached())
+            stop = true;
+        }
 
-            // terminate if in the last round no more polishing steps were performed
-            if(nSuccessfulPivots == 0)
-               stop = true;
+        // terminate if in the last round no more polishing steps were performed
+        if (nSuccessfulPivots == 0)
+          stop = true;
 
-            polishCount += nSuccessfulPivots;
-         }
+        polishCount += nSuccessfulPivots;
+      }
+    } else {
+      assert(polishObj == POLISH_FRACTIONALITY);
+      DIdxSet basiccandidates(dim());
+
+      // collect basic (integer) variables, that may be moved out of the basis
+      for (int i = 0; i < dim(); ++i) {
+        polishId = this->baseId(i);
+
+        if (polishId.isSPxRowId())
+          continue;
+        else {
+          if (useIntegrality &&
+              integerVariables[this->number(SPxColId(polishId))] == 0)
+            continue;
+
+          stat = ds.colStatus(i);
+        }
+
+        if (stat == SPxBasisBase<R>::Desc::P_ON_LOWER ||
+            stat == SPxBasisBase<R>::Desc::P_ON_UPPER) {
+          if (EQrel((*theFvec)[i], (R)0))
+            basiccandidates.addIdx(i);
+        }
       }
-      else
-      {
-         assert(polishObj == POLISH_FRACTIONALITY);
-         DIdxSet basiccandidates(dim());
-
-         // collect basic (integer) variables, that may be moved out of the basis
-         for(int i = 0; i < dim(); ++i)
-         {
-            polishId = this->baseId(i);
-
-            if(polishId.isSPxRowId())
-               continue;
-            else
-            {
-               if(useIntegrality && integerVariables[this->number(SPxColId(polishId))] == 0)
-                  continue;
-
-               stat = ds.colStatus(i);
-            }
-
-            if(stat == SPxBasisBase<R>::Desc::P_ON_LOWER || stat ==  SPxBasisBase<R>::Desc::P_ON_UPPER)
-            {
-               if(EQrel((*theFvec)[i], (R) 0))
-                  basiccandidates.addIdx(i);
-            }
-         }
 
-         while(!stop)
-         {
-            nSuccessfulPivots = 0;
+      while (!stop) {
+        nSuccessfulPivots = 0;
 
-            for(int i = basiccandidates.size() - 1; i >= 0 && !stop; --i)
-            {
-               MSG_DEBUG(std::cout << "try pivoting: " << this->baseId(basiccandidates.index(i));)
-               success = leave(basiccandidates.index(i), true);
-               clearUpdateVecs();
+        for (int i = basiccandidates.size() - 1; i >= 0 && !stop; --i) {
+          MSG_DEBUG(std::cout << "try pivoting: "
+                              << this->baseId(basiccandidates.index(i));)
+          success = leave(basiccandidates.index(i), true);
+          clearUpdateVecs();
 #ifndef NDEBUG
-               assert(EQrel(value(), origval, alloweddeviation));
-               assert(LErel(shift(), origshift, alloweddeviation));
+          assert(EQrel(value(), origval, alloweddeviation));
+          assert(LErel(shift(), origshift, alloweddeviation));
 #endif
 
-               if(success)
-               {
-                  MSG_DEBUG(std::cout << " -> success!";)
-                  ++nSuccessfulPivots;
-                  basiccandidates.remove(i);
+          if (success) {
+            MSG_DEBUG(std::cout << " -> success!";)
+            ++nSuccessfulPivots;
+            basiccandidates.remove(i);
 
-                  if(maxIters >= 0 && iterations() >= maxIters)
-                     stop = true;
-               }
+            if (maxIters >= 0 && iterations() >= maxIters)
+              stop = true;
+          }
 
-               MSG_DEBUG(std::cout << std::endl;)
+          MSG_DEBUG(std::cout << std::endl;)
 
-               if(isTimeLimitReached())
-                  stop = true;
-            }
+          if (isTimeLimitReached())
+            stop = true;
+        }
 
-            // terminate if in the last round no more polishing steps were performed
-            if(nSuccessfulPivots == 0)
-               stop = true;
+        // terminate if in the last round no more polishing steps were performed
+        if (nSuccessfulPivots == 0)
+          stop = true;
 
-            polishCount += nSuccessfulPivots;
-         }
+        polishCount += nSuccessfulPivots;
       }
-   }
+    }
+  }
 
-   MSG_INFO1((*this->spxout),
-             (*this->spxout) << " --- finished solution polishing (" << polishCount << " pivots)" << std::endl;)
+  MSG_INFO1((*this->spxout), (*this->spxout)
+                                 << " --- finished solution polishing ("
+                                 << polishCount << " pivots)" << std::endl;)
 
-   this->setStatus(SPxBasisBase<R>::OPTIMAL);
+  this->setStatus(SPxBasisBase<R>::OPTIMAL);
 }
 
-
-template <class R>
-void SPxSolverBase<R>::testVecs()
-{
-
-   assert(SPxBasisBase<R>::status() > SPxBasisBase<R>::SINGULAR);
-
-   VectorBase<R> tmp(dim());
-
-   tmp = *theCoPvec;
-   this->multWithBase(tmp);
-   tmp -= *theCoPrhs;
-
-   if(tmp.length() > leavetol())
-   {
-      MSG_INFO3((*this->spxout), (*this->spxout) << "ISOLVE93 " << this->iteration() <<
-                ":\tcoP error = \t"
-                << tmp.length() << std::endl;)
-
-      tmp.clear();
-      SPxBasisBase<R>::coSolve(tmp, *theCoPrhs);
-      this->multWithBase(tmp);
-      tmp -= *theCoPrhs;
-      MSG_INFO3((*this->spxout), (*this->spxout) << "ISOLVE94\t\t" << tmp.length() << std::endl;)
-
-      tmp.clear();
-      SPxBasisBase<R>::coSolve(tmp, *theCoPrhs);
-      tmp -= *theCoPvec;
-      MSG_INFO3((*this->spxout), (*this->spxout) << "ISOLVE95\t\t" << tmp.length() << std::endl;)
-   }
-
-   tmp = *theFvec;
-   this->multBaseWith(tmp);
-   tmp -= *theFrhs;
-
-   if(tmp.length() > entertol())
-   {
-      MSG_INFO3((*this->spxout), (*this->spxout) << "ISOLVE96 " << this->iteration() <<
-                ":\t  F error = \t"
-                << tmp.length() << std::endl;)
-
-      tmp.clear();
-      SPxBasisBase<R>::solve(tmp, *theFrhs);
-      tmp -= *theFvec;
-      MSG_INFO3((*this->spxout), (*this->spxout) << "ISOLVE97\t\t" << tmp.length() << std::endl;)
-   }
-
-   if(type() == ENTER)
-   {
-      for(int i = 0; i < dim(); ++i)
-      {
-         if(theCoTest[i] < -leavetol() && isCoBasic(i))
-         {
-            /// @todo Error message "this shalt not be": shalt this be an assert (also below)?
-            MSG_INFO1((*this->spxout), (*this->spxout) << "ESOLVE98 testVecs: theCoTest: this shalt not be!"
+template <class R> void SPxSolverBase<R>::testVecs() {
+
+  assert(SPxBasisBase<R>::status() > SPxBasisBase<R>::SINGULAR);
+
+  VectorBase<R> tmp(dim());
+
+  tmp = *theCoPvec;
+  this->multWithBase(tmp);
+  tmp -= *theCoPrhs;
+
+  if (tmp.length() > leavetol()) {
+    MSG_INFO3((*this->spxout), (*this->spxout)
+                                   << "ISOLVE93 " << this->iteration()
+                                   << ":\tcoP error = \t" << tmp.length()
+                                   << std::endl;)
+
+    tmp.clear();
+    SPxBasisBase<R>::coSolve(tmp, *theCoPrhs);
+    this->multWithBase(tmp);
+    tmp -= *theCoPrhs;
+    MSG_INFO3((*this->spxout),
+              (*this->spxout) << "ISOLVE94\t\t" << tmp.length() << std::endl;)
+
+    tmp.clear();
+    SPxBasisBase<R>::coSolve(tmp, *theCoPrhs);
+    tmp -= *theCoPvec;
+    MSG_INFO3((*this->spxout),
+              (*this->spxout) << "ISOLVE95\t\t" << tmp.length() << std::endl;)
+  }
+
+  tmp = *theFvec;
+  this->multBaseWith(tmp);
+  tmp -= *theFrhs;
+
+  if (tmp.length() > entertol()) {
+    MSG_INFO3((*this->spxout), (*this->spxout)
+                                   << "ISOLVE96 " << this->iteration()
+                                   << ":\t  F error = \t" << tmp.length()
+                                   << std::endl;)
+
+    tmp.clear();
+    SPxBasisBase<R>::solve(tmp, *theFrhs);
+    tmp -= *theFvec;
+    MSG_INFO3((*this->spxout),
+              (*this->spxout) << "ISOLVE97\t\t" << tmp.length() << std::endl;)
+  }
+
+  if (type() == ENTER) {
+    for (int i = 0; i < dim(); ++i) {
+      if (theCoTest[i] < -leavetol() && isCoBasic(i)) {
+        /// @todo Error message "this shalt not be": shalt this be an assert
+        /// (also below)?
+        MSG_INFO1((*this->spxout),
+                  (*this->spxout)
+                      << "ESOLVE98 testVecs: theCoTest: this shalt not be!"
                       << std::endl
-                      << "  i=" << i
-                      << ", theCoTest[i]=" << theCoTest[i]
+                      << "  i=" << i << ", theCoTest[i]=" << theCoTest[i]
                       << ", leavetol()=" << leavetol() << std::endl;)
-         }
       }
+    }
 
-      for(int i = 0; i < coDim(); ++i)
-      {
-         if(theTest[i] < -leavetol() && isBasic(i))
-         {
-            MSG_INFO1((*this->spxout), (*this->spxout) << "ESOLVE99 testVecs: theTest: this shalt not be!"
+    for (int i = 0; i < coDim(); ++i) {
+      if (theTest[i] < -leavetol() && isBasic(i)) {
+        MSG_INFO1((*this->spxout),
+                  (*this->spxout)
+                      << "ESOLVE99 testVecs: theTest: this shalt not be!"
                       << std::endl
-                      << "  i=" << i
-                      << ", theTest[i]=" << theTest[i]
+                      << "  i=" << i << ", theTest[i]=" << theTest[i]
                       << ", leavetol()=" << leavetol() << std::endl;)
-         }
       }
-   }
+    }
+  }
 }
 
-
 /// print display line of flying table
 template <class R>
-void SPxSolverBase<R>::printDisplayLine(const bool force, const bool forceHead)
-{
-   MSG_INFO1((*this->spxout),
-
-             if(forceHead || displayLine % (displayFreq * 30) == 0)
-{
-   (*this->spxout)
-            << "type |   time |   iters | facts |    shift | viol sum | viol num | obj value ";
-
-      if(printBasisMetric >= 0)
-         (*this->spxout) << " | basis metric";
-
-      (*this->spxout) << std::endl;
-   }
-   if((force || (displayLine % displayFreq == 0)) && !forceHead)
-{
-   (type() == LEAVE)
-      ? (*this->spxout) << "  L  |" : (*this->spxout) << "  E  |";
-      (*this->spxout) << std::fixed << std::setw(7) << std::setprecision(1) << time() << " |";
-      (*this->spxout) << std::scientific << std::setprecision(2);
-      (*this->spxout) << std::setw(8) << this->iteration() << " | "
-                      << std::setw(5) << slinSolver()->getFactorCount() << " | "
-                      << shift() << " | "
-                      << MAXIMUM(0.0, m_pricingViol + m_pricingViolCo) << " | "
-                      << std::setw(8) << MAXIMUM(0, m_numViol) << " | "
-                      << std::setprecision(8) << value();
-
-      if(getStartingDecompBasis && rep() == SPxSolverBase<R>::ROW)
-         (*this->spxout) << " (" << std::fixed << std::setprecision(2) << getDegeneracyLevel(fVec()) << ")";
-
-      if(printBasisMetric == 0)
-         (*this->spxout) << " | " << std::scientific << std::setprecision(2) << getBasisMetric(0);
-
-      if(printBasisMetric == 1)
-         (*this->spxout) << " | " << std::scientific << std::setprecision(2) << getBasisMetric(1);
-
-      if(printBasisMetric == 2)
-         (*this->spxout) << " | " << std::scientific << std::setprecision(2) << getBasisMetric(2);
-
-      if(printBasisMetric == 3)
-         (*this->spxout) << " | " << std::scientific << std::setprecision(2) <<
-                         basis().getEstimatedCondition();
-
-      (*this->spxout) << std::endl;
-   }
-   displayLine++;
-            );
+void SPxSolverBase<R>::printDisplayLine(const bool force,
+                                        const bool forceHead) {
+  MSG_INFO1((*this->spxout),
+
+            if (forceHead || displayLine % (displayFreq * 30) == 0) {
+              (*this->spxout) << "type |   time |   iters | facts |    shift | "
+                                 "viol sum | viol num | obj value ";
+
+              if (printBasisMetric >= 0)
+                (*this->spxout) << " | basis metric";
+
+              (*this->spxout) << std::endl;
+            } if ((force || (displayLine % displayFreq == 0)) && !forceHead) {
+              (type() == LEAVE) ? (*this->spxout) << "  L  |"
+                                : (*this->spxout) << "  E  |";
+              (*this->spxout) << std::fixed << std::setw(7)
+                              << std::setprecision(1) << time() << " |";
+              (*this->spxout) << std::scientific << std::setprecision(2);
+              (*this->spxout)
+                  << std::setw(8) << this->iteration() << " | " << std::setw(5)
+                  << slinSolver()->getFactorCount() << " | " << shift() << " | "
+                  << MAXIMUM(0.0, m_pricingViol + m_pricingViolCo) << " | "
+                  << std::setw(8) << MAXIMUM(0, m_numViol) << " | "
+                  << std::setprecision(8) << value();
+
+              if (getStartingDecompBasis && rep() == SPxSolverBase<R>::ROW)
+                (*this->spxout) << " (" << std::fixed << std::setprecision(2)
+                                << getDegeneracyLevel(fVec()) << ")";
+
+              if (printBasisMetric == 0)
+                (*this->spxout) << " | " << std::scientific
+                                << std::setprecision(2) << getBasisMetric(0);
+
+              if (printBasisMetric == 1)
+                (*this->spxout) << " | " << std::scientific
+                                << std::setprecision(2) << getBasisMetric(1);
+
+              if (printBasisMetric == 2)
+                (*this->spxout) << " | " << std::scientific
+                                << std::setprecision(2) << getBasisMetric(2);
+
+              if (printBasisMetric == 3)
+                (*this->spxout)
+                    << " | " << std::scientific << std::setprecision(2)
+                    << basis().getEstimatedCondition();
+
+              (*this->spxout) << std::endl;
+            } displayLine++;);
 }
 
-
-template <class R>
-bool SPxSolverBase<R>::terminate()
-{
+template <class R> bool SPxSolverBase<R>::terminate() {
 #ifdef ENABLE_ADDITIONAL_CHECKS
 
-   if(SPxBasisBase<R>::status() > SPxBasisBase<R>::SINGULAR)
-      testVecs();
+  if (SPxBasisBase<R>::status() > SPxBasisBase<R>::SINGULAR)
+    testVecs();
 
 #endif
 
-   int redo = dim();
+  int redo = dim();
 
-   if(redo < 1000)
-      redo = 1000;
+  if (redo < 1000)
+    redo = 1000;
 
-   if(this->iteration() > 10 && this->iteration() % redo == 0)
-   {
+  if (this->iteration() > 10 && this->iteration() % redo == 0) {
 #ifdef ENABLE_ADDITIONAL_CHECKS
-      VectorBase<R> cr(*theCoPrhs);
-      VectorBase<R> fr(*theFrhs);
+    VectorBase<R> cr(*theCoPrhs);
+    VectorBase<R> fr(*theFrhs);
 #endif
 
-      if(type() == ENTER)
-         computeEnterCoPrhs();
-      else
-         computeLeaveCoPrhs();
+    if (type() == ENTER)
+      computeEnterCoPrhs();
+    else
+      computeLeaveCoPrhs();
 
-      computeFrhs();
+    computeFrhs();
 
 #ifdef ENABLE_ADDITIONAL_CHECKS
-      cr -= *theCoPrhs;
-      fr -= *theFrhs;
-
-      if(cr.length() > leavetol())
-         MSG_WARNING((*this->spxout), (*this->spxout) << "WSOLVE50 unexpected change of coPrhs "
-                     << cr.length() << std::endl;)
-         if(fr.length() > entertol())
-            MSG_WARNING((*this->spxout), (*this->spxout) << "WSOLVE51 unexpected change of   Frhs "
-                        << fr.length() << std::endl;)
+    cr -= *theCoPrhs;
+    fr -= *theFrhs;
+
+    if (cr.length() > leavetol())
+      MSG_WARNING((*this->spxout),
+                  (*this->spxout) << "WSOLVE50 unexpected change of coPrhs "
+                                  << cr.length() << std::endl;)
+    if (fr.length() > entertol())
+      MSG_WARNING((*this->spxout),
+                  (*this->spxout) << "WSOLVE51 unexpected change of   Frhs "
+                                  << fr.length() << std::endl;)
 #endif
 
-            if(this->updateCount > 1)
-            {
-               MSG_INFO3((*this->spxout), (*this->spxout) << " --- terminate triggers refactorization"
-                         << std::endl;)
-               factorize();
-            }
+    if (this->updateCount > 1) {
+      MSG_INFO3((*this->spxout),
+                (*this->spxout)
+                    << " --- terminate triggers refactorization" << std::endl;)
+      factorize();
+    }
 
-      SPxBasisBase<R>::coSolve(*theCoPvec, *theCoPrhs);
-      SPxBasisBase<R>::solve(*theFvec, *theFrhs);
+    SPxBasisBase<R>::coSolve(*theCoPvec, *theCoPrhs);
+    SPxBasisBase<R>::solve(*theFvec, *theFrhs);
 
-      if(pricing() == FULL)
-      {
-         computePvec();
+    if (pricing() == FULL) {
+      computePvec();
 
-         if(type() == ENTER)
-         {
-            computeCoTest();
-            computeTest();
-         }
+      if (type() == ENTER) {
+        computeCoTest();
+        computeTest();
       }
-
-      if(shift() > 0.0)
-         unShift();
-   }
-
-   // check time limit and objective limit only for non-terminal bases
-   if(SPxBasisBase<R>::status() >= SPxBasisBase<R>::OPTIMAL  ||
-         SPxBasisBase<R>::status() <= SPxBasisBase<R>::SINGULAR)
-   {
-      m_status = UNKNOWN;
-      return true;
-   }
-
-   if(isTimeLimitReached())
-   {
-      MSG_INFO2((*this->spxout), (*this->spxout) << " --- timelimit (" << maxTime
-                << ") reached" << std::endl;)
-      m_status = ABORT_TIME;
-      return true;
-   }
-
-   // objLimit is set and we are running DUAL:
-   // - objLimit is set if objLimit < R(infinity)
-   // - DUAL is running if rep() * type() > 0 == DUAL (-1 == PRIMAL)
-   //
-   // In this case we have given a objective value limit, e.g, through a
-   // MIP solver, and we want stop solving the LP if we figure out that the
-   // optimal value of the current LP can not be better then this objective
-   // limit. More precisely:
-   // - MINIMIZATION Problem
-   //   We want stop the solving process if
-   //   objLimit <= current objective value of the DUAL LP
-   // - MAXIMIZATION Problem
-   //   We want stop the solving process if
-   //   objLimit >= current objective value of the DUAL LP
-   if(objLimit < R(infinity) && type() * rep() > 0)
-   {
-      // We have no bound shifts; therefore, we can trust the current
-      // objective value.
-      // It might be even possible to use this termination value in case of
-      // bound violations (shifting) but in this case it is quite difficult
-      // to determine if we already reached the limit.
-      if(shift() < epsilon() && noViols(opttol() - shift()))
-      {
-         // SPxSense::MINIMIZE == -1, so we have sign = 1 on minimizing
-         if(int(this->spxSense()) * value() <= int(this->spxSense()) * objLimit)
-         {
-            MSG_INFO2((*this->spxout), (*this->spxout) << " --- objective value limit (" << objLimit
-                      << ") reached" << std::endl;)
-            MSG_DEBUG(
-               (*this->spxout) << " --- objective value limit reached" << std::endl
-               << " (value: " << value()
-               << ", limit: " << objLimit << ")" << std::endl
-               << " (spxSense: " << int(this->spxSense())
-               << ", rep: " << int(rep())
-               << ", type: " << int(type()) << ")" << std::endl;
-            )
-
-            m_status = ABORT_VALUE;
-            return true;
-         }
+    }
+
+    if (shift() > 0.0)
+      unShift();
+  }
+
+  // check time limit and objective limit only for non-terminal bases
+  if (SPxBasisBase<R>::status() >= SPxBasisBase<R>::OPTIMAL ||
+      SPxBasisBase<R>::status() <= SPxBasisBase<R>::SINGULAR) {
+    m_status = UNKNOWN;
+    return true;
+  }
+
+  if (isTimeLimitReached()) {
+    MSG_INFO2((*this->spxout), (*this->spxout) << " --- timelimit (" << maxTime
+                                               << ") reached" << std::endl;)
+    m_status = ABORT_TIME;
+    return true;
+  }
+
+  // objLimit is set and we are running DUAL:
+  // - objLimit is set if objLimit < R(infinity)
+  // - DUAL is running if rep() * type() > 0 == DUAL (-1 == PRIMAL)
+  //
+  // In this case we have given a objective value limit, e.g, through a
+  // MIP solver, and we want stop solving the LP if we figure out that the
+  // optimal value of the current LP can not be better then this objective
+  // limit. More precisely:
+  // - MINIMIZATION Problem
+  //   We want stop the solving process if
+  //   objLimit <= current objective value of the DUAL LP
+  // - MAXIMIZATION Problem
+  //   We want stop the solving process if
+  //   objLimit >= current objective value of the DUAL LP
+  if (objLimit < R(infinity) && static_cast<int>(type()) * rep() > 0) {
+    // We have no bound shifts; therefore, we can trust the current
+    // objective value.
+    // It might be even possible to use this termination value in case of
+    // bound violations (shifting) but in this case it is quite difficult
+    // to determine if we already reached the limit.
+    if (shift() < epsilon() && noViols(opttol() - shift())) {
+      // SPxSense::MINIMIZE == -1, so we have sign = 1 on minimizing
+      if (int(this->spxSense()) * value() <= int(this->spxSense()) * objLimit) {
+        MSG_INFO2((*this->spxout), (*this->spxout)
+                                       << " --- objective value limit ("
+                                       << objLimit << ") reached" << std::endl;)
+        MSG_DEBUG((*this->spxout)
+                      << " --- objective value limit reached" << std::endl
+                      << " (value: " << value() << ", limit: " << objLimit
+                      << ")" << std::endl
+                      << " (spxSense: " << int(this->spxSense())
+                      << ", rep: " << int(rep()) << ", type: " << int(type())
+                      << ")" << std::endl;)
+
+        m_status = ABORT_VALUE;
+        return true;
       }
-   }
-
-
+    }
+  }
 
-   if(getComputeDegeneracy() && this->iteration() > this->prevIteration())
-   {
-      VectorBase<R> degenvec(this->nCols());
+  if (getComputeDegeneracy() && this->iteration() > this->prevIteration()) {
+    VectorBase<R> degenvec(this->nCols());
 
-      if(rep() == ROW)
+    if (rep() == ROW) {
+      if (type() == ENTER) // dual simplex
+        dualDegenSum += getDegeneracyLevel(fVec());
+      else // primal simplex
       {
-         if(type() == ENTER)     // dual simplex
-            dualDegenSum += getDegeneracyLevel(fVec());
-         else                    // primal simplex
-         {
-            getPrimalSol(degenvec);
-            primalDegenSum += getDegeneracyLevel(degenvec);
-         }
+        getPrimalSol(degenvec);
+        primalDegenSum += getDegeneracyLevel(degenvec);
       }
-      else
-      {
-         assert(rep() == COLUMN);
-
-         if(type() == LEAVE)     // dual simplex
-            dualDegenSum += getDegeneracyLevel(pVec());
-         else
-         {
-            getPrimalSol(degenvec);
-            primalDegenSum += getDegeneracyLevel(degenvec);
-         }
+    } else {
+      assert(rep() == COLUMN);
+
+      if (type() == LEAVE) // dual simplex
+        dualDegenSum += getDegeneracyLevel(pVec());
+      else {
+        getPrimalSol(degenvec);
+        primalDegenSum += getDegeneracyLevel(degenvec);
+      }
+    }
+  }
+
+  // the improved dual simplex requires a starting basis
+  // if the flag getStartingDecompBasis is set to true the simplex will
+  // terminate when a dual basis is found
+  if (getStartingDecompBasis) {
+    R iterationFrac = 0.6;
+
+    if (type() == ENTER && SPxBasisBase<R>::status() == SPxBasisBase<R>::DUAL &&
+        this->iteration() - this->lastDegenCheck() >
+            getDegenCompOffset() /*iteration() % 10 == 0*/) {
+      this->iterDegenCheck = this->iterCount;
+
+      if (SPxBasisBase<R>::status() >= SPxBasisBase<R>::OPTIMAL) {
+        m_status = RUNNING;
+        return true;
       }
-   }
-
 
-   // the improved dual simplex requires a starting basis
-   // if the flag getStartingDecompBasis is set to true the simplex will terminate when a dual basis is found
-   if(getStartingDecompBasis)
-   {
-      R iterationFrac = 0.6;
+      R degeneracyLevel = 0;
+      R degeneracyLB = 0.1;
+      R degeneracyUB = 0.9;
+      degeneracyLevel = getDegeneracyLevel(fVec());
 
-      if(type() == ENTER && SPxBasisBase<R>::status() == SPxBasisBase<R>::DUAL &&
-            this->iteration() - this->lastDegenCheck() > getDegenCompOffset()/*iteration() % 10 == 0*/)
-      {
-         this->iterDegenCheck = this->iterCount;
-
-         if(SPxBasisBase<R>::status() >= SPxBasisBase<R>::OPTIMAL)
-         {
-            m_status = RUNNING;
-            return true;
-         }
-
-         R degeneracyLevel = 0;
-         R degeneracyLB = 0.1;
-         R degeneracyUB = 0.9;
-         degeneracyLevel = getDegeneracyLevel(fVec());
-
-         if((degeneracyLevel < degeneracyUB && degeneracyLevel > degeneracyLB)
-               && this->iteration() > this->nRows() * 0.2)
-         {
-            m_status = ABORT_DECOMP;
-            return true;
-         }
-
-         if(degeneracyLevel < degeneracyLB
-               && this->iteration() > MINIMUM(getDecompIterationLimit(), int(this->nCols()*iterationFrac)))
-         {
-            setDecompIterationLimit(0);
-            setDegenCompOffset(0);
-            m_status = ABORT_EXDECOMP;
-            return true;
-         }
+      if ((degeneracyLevel < degeneracyUB && degeneracyLevel > degeneracyLB) &&
+          this->iteration() > this->nRows() * 0.2) {
+        m_status = ABORT_DECOMP;
+        return true;
       }
-      else if(type() == LEAVE
-              && this->iteration() > MINIMUM(getDecompIterationLimit(), int(this->nCols()*iterationFrac)))
-      {
-         setDecompIterationLimit(0);
-         setDegenCompOffset(0);
-         m_status = ABORT_EXDECOMP;
-         return true;
+
+      if (degeneracyLevel<degeneracyLB &&this->iteration()> MINIMUM(
+              getDecompIterationLimit(), int(this->nCols() * iterationFrac))) {
+        setDecompIterationLimit(0);
+        setDegenCompOffset(0);
+        m_status = ABORT_EXDECOMP;
+        return true;
       }
-   }
+    } else if (type() == LEAVE &&
+               this->iteration() >
+                   MINIMUM(getDecompIterationLimit(),
+                           int(this->nCols() * iterationFrac))) {
+      setDecompIterationLimit(0);
+      setDegenCompOffset(0);
+      m_status = ABORT_EXDECOMP;
+      return true;
+    }
+  }
 
-   this->lastIterCount = this->iterCount;
+  this->lastIterCount = this->iterCount;
 
-   return false;
+  return false;
 }
 
 template <class R>
-typename SPxSolverBase<R>::Status SPxSolverBase<R>::getPrimalSol(VectorBase<R>& p_vector) const
-{
-
-   if(!isInitialized())
-   {
-      /* exit if presolving/simplifier cleared the problem */
-      if(status() == NO_PROBLEM)
-         return status();
-
-      throw SPxStatusException("XSOLVE06 Not Initialized");
-   }
+typename SPxSolverBase<R>::Status
+SPxSolverBase<R>::getPrimalSol(VectorBase<R> &p_vector) const {
+
+  if (!isInitialized()) {
+    /* exit if presolving/simplifier cleared the problem */
+    if (status() == NO_PROBLEM)
+      return status();
+
+    throw SPxStatusException("XSOLVE06 Not Initialized");
+  }
+
+  if (rep() == ROW)
+    p_vector = coPvec();
+  else {
+    const typename SPxBasisBase<R>::Desc &ds = this->desc();
+
+    for (int i = 0; i < this->nCols(); ++i) {
+      switch (ds.colStatus(i)) {
+      case SPxBasisBase<R>::Desc::P_ON_LOWER:
+        p_vector[i] = SPxLPBase<R>::lower(i);
+        break;
+
+      case SPxBasisBase<R>::Desc::P_ON_UPPER:
+      case SPxBasisBase<R>::Desc::P_FIXED:
+        p_vector[i] = SPxLPBase<R>::upper(i);
+        break;
+
+      case SPxBasisBase<R>::Desc::P_FREE:
+        p_vector[i] = 0;
+        break;
+
+      case SPxBasisBase<R>::Desc::D_FREE:
+      case SPxBasisBase<R>::Desc::D_ON_UPPER:
+      case SPxBasisBase<R>::Desc::D_ON_LOWER:
+      case SPxBasisBase<R>::Desc::D_ON_BOTH:
+      case SPxBasisBase<R>::Desc::D_UNDEFINED:
+        break;
 
-   if(rep() == ROW)
-      p_vector = coPvec();
-   else
-   {
-      const typename SPxBasisBase<R>::Desc& ds = this->desc();
-
-      for(int i = 0; i < this->nCols(); ++i)
-      {
-         switch(ds.colStatus(i))
-         {
-         case SPxBasisBase<R>::Desc::P_ON_LOWER :
-            p_vector[i] = SPxLPBase<R>::lower(i);
-            break;
-
-         case SPxBasisBase<R>::Desc::P_ON_UPPER :
-         case SPxBasisBase<R>::Desc::P_FIXED :
-            p_vector[i] = SPxLPBase<R>::upper(i);
-            break;
-
-         case SPxBasisBase<R>::Desc::P_FREE :
-            p_vector[i] = 0;
-            break;
-
-         case SPxBasisBase<R>::Desc::D_FREE :
-         case SPxBasisBase<R>::Desc::D_ON_UPPER :
-         case SPxBasisBase<R>::Desc::D_ON_LOWER :
-         case SPxBasisBase<R>::Desc::D_ON_BOTH :
-         case SPxBasisBase<R>::Desc::D_UNDEFINED :
-            break;
-
-         default:
-            throw SPxInternalCodeException("XSOLVE07 This should never happen.");
-         }
+      default:
+        throw SPxInternalCodeException("XSOLVE07 This should never happen.");
       }
+    }
 
-      for(int j = 0; j < dim(); ++j)
-      {
-         if(this->baseId(j).isSPxColId())
-            p_vector[ this->number(SPxColId(this->baseId(j))) ] = fVec()[j];
-      }
-   }
+    for (int j = 0; j < dim(); ++j) {
+      if (this->baseId(j).isSPxColId())
+        p_vector[this->number(SPxColId(this->baseId(j)))] = fVec()[j];
+    }
+  }
 
-   return status();
+  return status();
 }
 
 template <class R>
-typename SPxSolverBase<R>::Status SPxSolverBase<R>::getDualSol(VectorBase<R>& p_vector) const
-{
-
-   assert(isInitialized());
-
-   if(!isInitialized())
-   {
-      /* exit if presolving/simplifier cleared the problem */
-      if(status() == NO_PROBLEM)
-         return status();
+typename SPxSolverBase<R>::Status
+SPxSolverBase<R>::getDualSol(VectorBase<R> &p_vector) const {
+
+  assert(isInitialized());
+
+  if (!isInitialized()) {
+    /* exit if presolving/simplifier cleared the problem */
+    if (status() == NO_PROBLEM)
+      return status();
+
+    throw SPxStatusException("XSOLVE08 No Problem loaded");
+  }
+
+  if (rep() == ROW) {
+    int i;
+    p_vector = this->maxRowObj();
+
+    for (i = this->nCols() - 1; i >= 0; --i) {
+      if (this->baseId(i).isSPxRowId())
+        p_vector[this->number(SPxRowId(this->baseId(i)))] = fVec()[i];
+    }
+  } else {
+    const typename SPxBasisBase<R>::Desc &ds = this->desc();
+
+    for (int i = 0; i < this->nRows(); ++i) {
+      switch (ds.rowStatus(i)) {
+      case SPxBasisBase<R>::Desc::D_FREE:
+      case SPxBasisBase<R>::Desc::D_ON_UPPER:
+      case SPxBasisBase<R>::Desc::D_ON_LOWER:
+      case SPxBasisBase<R>::Desc::D_ON_BOTH:
+      case SPxBasisBase<R>::Desc::D_UNDEFINED:
+        p_vector[i] = 0;
+        break;
 
-      throw SPxStatusException("XSOLVE08 No Problem loaded");
-   }
-
-   if(rep() == ROW)
-   {
-      int i;
-      p_vector = this->maxRowObj();
-
-      for(i = this->nCols() - 1; i >= 0; --i)
-      {
-         if(this->baseId(i).isSPxRowId())
-            p_vector[ this->number(SPxRowId(this->baseId(i))) ] = fVec()[i];
-      }
-   }
-   else
-   {
-      const typename SPxBasisBase<R>::Desc& ds = this->desc();
-
-      for(int i = 0; i < this->nRows(); ++i)
-      {
-         switch(ds.rowStatus(i))
-         {
-         case SPxBasisBase<R>::Desc::D_FREE:
-         case SPxBasisBase<R>::Desc::D_ON_UPPER:
-         case SPxBasisBase<R>::Desc::D_ON_LOWER:
-         case SPxBasisBase<R>::Desc::D_ON_BOTH:
-         case SPxBasisBase<R>::Desc::D_UNDEFINED:
-            p_vector[i] = 0;
-            break;
-
-         default:
-            p_vector[i] = (*theCoPvec)[i];
-         }
+      default:
+        p_vector[i] = (*theCoPvec)[i];
       }
-   }
+    }
+  }
 
-   p_vector *= Real(this->spxSense());
+  p_vector *= Real(this->spxSense());
 
-   return status();
+  return status();
 }
 
 template <class R>
-typename SPxSolverBase<R>::Status SPxSolverBase<R>::getRedCostSol(VectorBase<R>& p_vector) const
-{
+typename SPxSolverBase<R>::Status
+SPxSolverBase<R>::getRedCostSol(VectorBase<R> &p_vector) const {
 
-   assert(isInitialized());
+  assert(isInitialized());
 
-   if(!isInitialized())
-   {
-      throw SPxStatusException("XSOLVE09 No Problem loaded");
-      // return NOT_INIT;
-   }
+  if (!isInitialized()) {
+    throw SPxStatusException("XSOLVE09 No Problem loaded");
+    // return NOT_INIT;
+  }
 
-   if(rep() == ROW)
-   {
-      int i;
-      p_vector.clear();
+  if (rep() == ROW) {
+    int i;
+    p_vector.clear();
 
-      if(this->spxSense() == SPxLPBase<R>::MINIMIZE)
-      {
-         for(i = dim() - 1; i >= 0; --i)
-         {
-            if(this->baseId(i).isSPxColId())
-               p_vector[ this->number(SPxColId(this->baseId(i))) ] = -fVec()[i];
-         }
+    if (this->spxSense() == SPxLPBase<R>::MINIMIZE) {
+      for (i = dim() - 1; i >= 0; --i) {
+        if (this->baseId(i).isSPxColId())
+          p_vector[this->number(SPxColId(this->baseId(i)))] = -fVec()[i];
       }
-      else
-      {
-         for(i = dim() - 1; i >= 0; --i)
-         {
-            if(this->baseId(i).isSPxColId())
-               p_vector[ this->number(SPxColId(this->baseId(i))) ] = fVec()[i];
-         }
+    } else {
+      for (i = dim() - 1; i >= 0; --i) {
+        if (this->baseId(i).isSPxColId())
+          p_vector[this->number(SPxColId(this->baseId(i)))] = fVec()[i];
       }
-   }
-   else
-   {
-      const typename SPxBasisBase<R>::Desc& ds = this->desc();
+    }
+  } else {
+    const typename SPxBasisBase<R>::Desc &ds = this->desc();
+
+    for (int i = 0; i < this->nCols(); ++i) {
+      switch (ds.colStatus(i)) {
+      case SPxBasisBase<R>::Desc::D_FREE:
+      case SPxBasisBase<R>::Desc::D_ON_UPPER:
+      case SPxBasisBase<R>::Desc::D_ON_LOWER:
+      case SPxBasisBase<R>::Desc::D_ON_BOTH:
+      case SPxBasisBase<R>::Desc::D_UNDEFINED:
+        p_vector[i] = 0;
+        break;
 
-      for(int i = 0; i < this->nCols(); ++i)
-      {
-         switch(ds.colStatus(i))
-         {
-         case SPxBasisBase<R>::Desc::D_FREE:
-         case SPxBasisBase<R>::Desc::D_ON_UPPER:
-         case SPxBasisBase<R>::Desc::D_ON_LOWER:
-         case SPxBasisBase<R>::Desc::D_ON_BOTH:
-         case SPxBasisBase<R>::Desc::D_UNDEFINED:
-            p_vector[i] = 0;
-            break;
-
-         default:
-            p_vector[i] = this->maxObj()[i] - (*thePvec)[i];
-         }
+      default:
+        p_vector[i] = this->maxObj()[i] - (*thePvec)[i];
       }
+    }
 
-      if(this->spxSense() == SPxLPBase<R>::MINIMIZE)
-         p_vector *= -1.0;
-   }
+    if (this->spxSense() == SPxLPBase<R>::MINIMIZE)
+      p_vector *= -1.0;
+  }
 
-   return status();
+  return status();
 }
 
 template <class R>
-typename SPxSolverBase<R>::Status SPxSolverBase<R>::getPrimalray(VectorBase<R>& p_vector) const
-{
+typename SPxSolverBase<R>::Status
+SPxSolverBase<R>::getPrimalray(VectorBase<R> &p_vector) const {
 
-   assert(isInitialized());
+  assert(isInitialized());
 
-   if(!isInitialized())
-   {
-      throw SPxStatusException("XSOLVE10 No Problem loaded");
-      // return NOT_INIT;
-   }
+  if (!isInitialized()) {
+    throw SPxStatusException("XSOLVE10 No Problem loaded");
+    // return NOT_INIT;
+  }
 
-   assert(SPxBasisBase<R>::status() == SPxBasisBase<R>::UNBOUNDED);
-   p_vector.clear();
-   p_vector = primalRay;
+  assert(SPxBasisBase<R>::status() == SPxBasisBase<R>::UNBOUNDED);
+  p_vector.clear();
+  p_vector = primalRay;
 
-   return status();
+  return status();
 }
 
 template <class R>
-typename SPxSolverBase<R>::Status SPxSolverBase<R>::getDualfarkas(VectorBase<R>& p_vector) const
-{
+typename SPxSolverBase<R>::Status
+SPxSolverBase<R>::getDualfarkas(VectorBase<R> &p_vector) const {
 
-   assert(isInitialized());
+  assert(isInitialized());
 
-   if(!isInitialized())
-   {
-      throw SPxStatusException("XSOLVE10 No Problem loaded");
-      // return NOT_INIT;
-   }
+  if (!isInitialized()) {
+    throw SPxStatusException("XSOLVE10 No Problem loaded");
+    // return NOT_INIT;
+  }
 
-   assert(SPxBasisBase<R>::status() == SPxBasisBase<R>::INFEASIBLE);
-   p_vector.clear();
-   p_vector = dualFarkas;
+  assert(SPxBasisBase<R>::status() == SPxBasisBase<R>::INFEASIBLE);
+  p_vector.clear();
+  p_vector = dualFarkas;
 
-   return status();
+  return status();
 }
 
 template <class R>
-typename SPxSolverBase<R>::Status SPxSolverBase<R>::getSlacks(VectorBase<R>& p_vector) const
-{
-
-   assert(isInitialized());
-
-   if(!isInitialized())
-   {
-      throw SPxStatusException("XSOLVE11 No Problem loaded");
-      // return NOT_INIT;
-   }
-
-   if(rep() == COLUMN)
-   {
-      int i;
-      const typename SPxBasisBase<R>::Desc& ds = this->desc();
-
-      for(i = this->nRows() - 1; i >= 0; --i)
-      {
-         switch(ds.rowStatus(i))
-         {
-         case SPxBasisBase<R>::Desc::P_ON_LOWER :
-            p_vector[i] = this->lhs(i);
-            break;
-
-         case SPxBasisBase<R>::Desc::P_ON_UPPER :
-         case SPxBasisBase<R>::Desc::P_FIXED :
-            p_vector[i] = this->rhs(i);
-            break;
-
-         case SPxBasisBase<R>::Desc::P_FREE :
-            p_vector[i] = 0;
-            break;
-
-         case SPxBasisBase<R>::Desc::D_FREE :
-         case SPxBasisBase<R>::Desc::D_ON_UPPER :
-         case SPxBasisBase<R>::Desc::D_ON_LOWER :
-         case SPxBasisBase<R>::Desc::D_ON_BOTH :
-         case SPxBasisBase<R>::Desc::D_UNDEFINED :
-            break;
+typename SPxSolverBase<R>::Status
+SPxSolverBase<R>::getSlacks(VectorBase<R> &p_vector) const {
+
+  assert(isInitialized());
+
+  if (!isInitialized()) {
+    throw SPxStatusException("XSOLVE11 No Problem loaded");
+    // return NOT_INIT;
+  }
+
+  if (rep() == COLUMN) {
+    int i;
+    const typename SPxBasisBase<R>::Desc &ds = this->desc();
+
+    for (i = this->nRows() - 1; i >= 0; --i) {
+      switch (ds.rowStatus(i)) {
+      case SPxBasisBase<R>::Desc::P_ON_LOWER:
+        p_vector[i] = this->lhs(i);
+        break;
+
+      case SPxBasisBase<R>::Desc::P_ON_UPPER:
+      case SPxBasisBase<R>::Desc::P_FIXED:
+        p_vector[i] = this->rhs(i);
+        break;
+
+      case SPxBasisBase<R>::Desc::P_FREE:
+        p_vector[i] = 0;
+        break;
+
+      case SPxBasisBase<R>::Desc::D_FREE:
+      case SPxBasisBase<R>::Desc::D_ON_UPPER:
+      case SPxBasisBase<R>::Desc::D_ON_LOWER:
+      case SPxBasisBase<R>::Desc::D_ON_BOTH:
+      case SPxBasisBase<R>::Desc::D_UNDEFINED:
+        break;
 
-         default:
-            throw SPxInternalCodeException("XSOLVE12 This should never happen.");
-         }
+      default:
+        throw SPxInternalCodeException("XSOLVE12 This should never happen.");
       }
+    }
 
-      for(i = dim() - 1; i >= 0; --i)
-      {
-         if(this->baseId(i).isSPxRowId())
-            p_vector[ this->number(SPxRowId(this->baseId(i))) ] = -(*theFvec)[i];
-      }
-   }
-   else
-      p_vector = pVec();
+    for (i = dim() - 1; i >= 0; --i) {
+      if (this->baseId(i).isSPxRowId())
+        p_vector[this->number(SPxRowId(this->baseId(i)))] = -(*theFvec)[i];
+    }
+  } else
+    p_vector = pVec();
 
-   return status();
+  return status();
 }
 
-template <class R>
-void SPxSolverBase<R>::setPrimal(VectorBase<R>& p_vector)
-{
-
-   if(!isInitialized())
-   {
-      throw SPxStatusException("XSOLVE20 Not Initialized");
-   }
-
-   if(rep() == ROW)
-      coPvec() = p_vector;
-   else
-   {
-      for(int j = 0; j < dim(); ++j)
-      {
-         if(this->baseId(j).isSPxColId())
-            fVec()[j] = p_vector[ this->number(SPxColId(this->baseId(j))) ];
-      }
-   }
+template <class R> void SPxSolverBase<R>::setPrimal(VectorBase<R> &p_vector) {
+
+  if (!isInitialized()) {
+    throw SPxStatusException("XSOLVE20 Not Initialized");
+  }
+
+  if (rep() == ROW)
+    coPvec() = p_vector;
+  else {
+    for (int j = 0; j < dim(); ++j) {
+      if (this->baseId(j).isSPxColId())
+        fVec()[j] = p_vector[this->number(SPxColId(this->baseId(j)))];
+    }
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::setDual(VectorBase<R>& p_vector)
-{
+template <class R> void SPxSolverBase<R>::setDual(VectorBase<R> &p_vector) {
 
-   assert(isInitialized());
+  assert(isInitialized());
 
-   if(!isInitialized())
-   {
-      throw SPxStatusException("XSOLVE21 Not Initialized");
-   }
+  if (!isInitialized()) {
+    throw SPxStatusException("XSOLVE21 Not Initialized");
+  }
 
-   if(rep() == ROW)
-   {
-      for(int i = this->nCols() - 1; i >= 0; --i)
-      {
-         if(this->baseId(i).isSPxRowId())
-         {
-            if(this->spxSense() == SPxLPBase<R>::MAXIMIZE)
-               fVec()[i] = p_vector[ this->number(SPxRowId(this->baseId(i))) ];
-            else
-               fVec()[i] = -p_vector[ this->number(SPxRowId(this->baseId(i))) ];
-         }
+  if (rep() == ROW) {
+    for (int i = this->nCols() - 1; i >= 0; --i) {
+      if (this->baseId(i).isSPxRowId()) {
+        if (this->spxSense() == SPxLPBase<R>::MAXIMIZE)
+          fVec()[i] = p_vector[this->number(SPxRowId(this->baseId(i)))];
+        else
+          fVec()[i] = -p_vector[this->number(SPxRowId(this->baseId(i)))];
       }
-   }
-   else
-   {
-      coPvec() = p_vector;
-
-      if(this->spxSense() == SPxLPBase<R>::MINIMIZE)
-         coPvec() *= -1.0;
-   }
+    }
+  } else {
+    coPvec() = p_vector;
+
+    if (this->spxSense() == SPxLPBase<R>::MINIMIZE)
+      coPvec() *= -1.0;
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::setRedCost(VectorBase<R>& p_vector)
-{
+template <class R> void SPxSolverBase<R>::setRedCost(VectorBase<R> &p_vector) {
 
-   assert(isInitialized());
+  assert(isInitialized());
 
-   if(!isInitialized())
-   {
-      throw SPxStatusException("XSOLVE22 Not Initialized");
-   }
+  if (!isInitialized()) {
+    throw SPxStatusException("XSOLVE22 Not Initialized");
+  }
 
-   if(rep() == ROW)
-   {
-      for(int i = dim() - 1; i >= 0; --i)
-      {
-         if(this->baseId(i).isSPxColId())
-         {
-            if(this->spxSense() == SPxLPBase<R>::MINIMIZE)
-               fVec()[i] = -p_vector[ this->number(SPxColId(this->baseId(i))) ];
-            else
-               fVec()[i] = p_vector[ this->number(SPxColId(this->baseId(i))) ];
-         }
+  if (rep() == ROW) {
+    for (int i = dim() - 1; i >= 0; --i) {
+      if (this->baseId(i).isSPxColId()) {
+        if (this->spxSense() == SPxLPBase<R>::MINIMIZE)
+          fVec()[i] = -p_vector[this->number(SPxColId(this->baseId(i)))];
+        else
+          fVec()[i] = p_vector[this->number(SPxColId(this->baseId(i)))];
       }
-   }
-   else
-   {
-      pVec() = this->maxObj();
-
-      if(this->spxSense() == SPxLPBase<R>::MINIMIZE)
-         pVec() += p_vector;
-      else
-         pVec() -= p_vector;
-   }
+    }
+  } else {
+    pVec() = this->maxObj();
+
+    if (this->spxSense() == SPxLPBase<R>::MINIMIZE)
+      pVec() += p_vector;
+    else
+      pVec() -= p_vector;
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::setSlacks(VectorBase<R>& p_vector)
-{
+template <class R> void SPxSolverBase<R>::setSlacks(VectorBase<R> &p_vector) {
 
-   assert(isInitialized());
+  assert(isInitialized());
 
-   if(!isInitialized())
-   {
-      throw SPxStatusException("XSOLVE23 Not Initialized");
-   }
+  if (!isInitialized()) {
+    throw SPxStatusException("XSOLVE23 Not Initialized");
+  }
 
-   if(rep() == COLUMN)
-   {
-      for(int i = dim() - 1; i >= 0; --i)
-      {
-         if(this->baseId(i).isSPxRowId())
-            (*theFvec)[i] = -p_vector[ this->number(SPxRowId(this->baseId(i))) ];
-      }
-   }
-   else
-      pVec() = p_vector;
+  if (rep() == COLUMN) {
+    for (int i = dim() - 1; i >= 0; --i) {
+      if (this->baseId(i).isSPxRowId())
+        (*theFvec)[i] = -p_vector[this->number(SPxRowId(this->baseId(i)))];
+    }
+  } else
+    pVec() = p_vector;
 }
 
 template <class R>
-typename SPxSolverBase<R>::Status SPxSolverBase<R>::status() const
-{
-   switch(m_status)
-   {
-   case UNKNOWN :
-      switch(SPxBasisBase<R>::status())
-      {
-      case SPxBasisBase<R>::NO_PROBLEM :
-         return NO_PROBLEM;
+typename SPxSolverBase<R>::Status SPxSolverBase<R>::status() const {
+  switch (m_status) {
+  case UNKNOWN:
+    switch (SPxBasisBase<R>::status()) {
+    case SPxBasisBase<R>::NO_PROBLEM:
+      return NO_PROBLEM;
 
-      case SPxBasisBase<R>::SINGULAR :
-         return SINGULAR;
+    case SPxBasisBase<R>::SINGULAR:
+      return SINGULAR;
 
-      case SPxBasisBase<R>::REGULAR :
-      case SPxBasisBase<R>::DUAL :
-      case SPxBasisBase<R>::PRIMAL :
-         return UNKNOWN;
+    case SPxBasisBase<R>::REGULAR:
+    case SPxBasisBase<R>::DUAL:
+    case SPxBasisBase<R>::PRIMAL:
+      return UNKNOWN;
 
-      case SPxBasisBase<R>::OPTIMAL :
-         return OPTIMAL;
+    case SPxBasisBase<R>::OPTIMAL:
+      return OPTIMAL;
 
-      case SPxBasisBase<R>::UNBOUNDED :
-         return UNBOUNDED;
+    case SPxBasisBase<R>::UNBOUNDED:
+      return UNBOUNDED;
 
-      case SPxBasisBase<R>::INFEASIBLE :
-         return INFEASIBLE;
-
-      default:
-         return ERROR;
-      }
+    case SPxBasisBase<R>::INFEASIBLE:
+      return INFEASIBLE;
 
-   case SINGULAR :
-      return m_status;
-
-   case OPTIMAL :
-      assert(SPxBasisBase<R>::status() == SPxBasisBase<R>::OPTIMAL);
-
-   /*lint -fallthrough*/
-   case ABORT_EXDECOMP :
-   case ABORT_DECOMP :
-   case ABORT_CYCLING :
-   case ABORT_TIME :
-   case ABORT_ITER :
-   case ABORT_VALUE :
-   case RUNNING :
-   case REGULAR :
-   case NOT_INIT :
-   case NO_SOLVER :
-   case NO_PRICER :
-   case NO_RATIOTESTER :
-   case ERROR:
-      return m_status;
-
-   default:
+    default:
       return ERROR;
-   }
+    }
+
+  case SINGULAR:
+    return m_status;
+
+  case OPTIMAL:
+    assert(SPxBasisBase<R>::status() == SPxBasisBase<R>::OPTIMAL);
+
+  /*lint -fallthrough*/
+  case ABORT_EXDECOMP:
+  case ABORT_DECOMP:
+  case ABORT_CYCLING:
+  case ABORT_TIME:
+  case ABORT_ITER:
+  case ABORT_VALUE:
+  case RUNNING:
+  case REGULAR:
+  case NOT_INIT:
+  case NO_SOLVER:
+  case NO_PRICER:
+  case NO_RATIOTESTER:
+  case ERROR:
+    return m_status;
+
+  default:
+    return ERROR;
+  }
 }
 
 template <class R>
-typename SPxSolverBase<R>::Status SPxSolverBase<R>::getResult(
-   R* p_value,
-   VectorBase<R>* p_primal,
-   VectorBase<R>* p_slacks,
-   VectorBase<R>* p_dual,
-   VectorBase<R>* reduCosts)
-{
-   if(p_value)
-      *p_value = this->value();
+typename SPxSolverBase<R>::Status
+SPxSolverBase<R>::getResult(R *p_value, VectorBase<R> *p_primal,
+                            VectorBase<R> *p_slacks, VectorBase<R> *p_dual,
+                            VectorBase<R> *reduCosts) {
+  if (p_value)
+    *p_value = this->value();
 
-   if(p_primal)
-      getPrimalSol(*p_primal);
+  if (p_primal)
+    getPrimalSol(*p_primal);
 
-   if(p_slacks)
-      getSlacks(*p_slacks);
+  if (p_slacks)
+    getSlacks(*p_slacks);
 
-   if(p_dual)
-      getDualSol(*p_dual);
+  if (p_dual)
+    getDualSol(*p_dual);
 
-   if(reduCosts)
-      getRedCostSol(*reduCosts);
+  if (reduCosts)
+    getRedCostSol(*reduCosts);
 
-   return status();
+  return status();
 }
 } // namespace soplex
diff --git a/src/soplex/spxsolver.h b/src/soplex/spxsolver.h
index c9762c0..d952138 100644
--- a/src/soplex/spxsolver.h
+++ b/src/soplex/spxsolver.h
@@ -29,45 +29,51 @@
 #define _SPXSOLVER_H_
 
 #include <assert.h>
-#include <iostream>
 #include <iomanip>
+#include <iostream>
 #include <sstream>
 
+#include "soplex/array.h"
+#include "soplex/random.h"
+#include "soplex/spxbasis.h"
 #include "soplex/spxdefines.h"
+#include "soplex/spxlp.h"
+#include "soplex/stablesum.h"
 #include "soplex/timer.h"
 #include "soplex/timerfactory.h"
-#include "soplex/spxlp.h"
-#include "soplex/spxbasis.h"
-#include "soplex/array.h"
-#include "soplex/random.h"
 #include "soplex/unitvector.h"
 #include "soplex/updatevector.h"
-#include "soplex/stablesum.h"
 
 #include "soplex/spxlpbase.h"
 
-#define HYPERPRICINGTHRESHOLD    5000     /**< do (auto) hyper pricing only if problem size (cols+rows) is larger than HYPERPRICINGTHRESHOLD */
-#define HYPERPRICINGSIZE         100      /**< size of initial candidate list for hyper pricing */
-#define SPARSITYFACTOR           0.6      /**< percentage of infeasibilities that is considered sparse */
-#define DENSEROUNDS               5       /**< number of refactorizations until sparsity is tested again */
-#define SPARSITY_TRADEOFF        0.8      /**< threshold to decide whether Ids or coIds are preferred to enter the basis;
-                                           * coIds are more likely to enter if SPARSITY_TRADEOFF is close to 0
-                                           */
-#define MAXNCLCKSKIPS            32       /**< maximum number of clock skips (iterations without time measuring) */
-#define SAFETYFACTOR             1e-2     /**< the probability to skip the clock when the time limit has been reached */
-#define NINITCALLS               200      /**< the number of clock updates in isTimelimitReached() before clock skipping starts */
-namespace soplex
-{
-template <class R>
-class SPxPricer;
-template <class R>
-class SPxRatioTester;
-template <class R>
-class SPxStarter;
-template <class R>
-class SPxFastRT;
-template <class R>
-class SPxBoundFlippingRT;
+#define HYPERPRICINGTHRESHOLD                                                  \
+  5000 /**< do (auto) hyper pricing only if problem size (cols+rows) is larger \
+          than HYPERPRICINGTHRESHOLD */
+#define HYPERPRICINGSIZE                                                       \
+  100 /**< size of initial candidate list for hyper pricing */
+#define SPARSITYFACTOR                                                         \
+  0.6 /**< percentage of infeasibilities that is considered sparse */
+#define DENSEROUNDS                                                            \
+  5 /**< number of refactorizations until sparsity is tested again */
+#define SPARSITY_TRADEOFF                                                      \
+  0.8 /**< threshold to decide whether Ids or coIds are preferred to enter the \
+       * basis; coIds are more likely to enter if SPARSITY_TRADEOFF is close   \
+       * to 0                                                                  \
+       */
+#define MAXNCLCKSKIPS                                                          \
+  32 /**< maximum number of clock skips (iterations without time measuring) */
+#define SAFETYFACTOR                                                           \
+  1e-2 /**< the probability to skip the clock when the time limit has been     \
+          reached */
+#define NINITCALLS                                                             \
+  200 /**< the number of clock updates in isTimelimitReached() before clock    \
+         skipping starts */
+namespace soplex {
+template <class R> class SPxPricer;
+template <class R> class SPxRatioTester;
+template <class R> class SPxStarter;
+template <class R> class SPxFastRT;
+template <class R> class SPxBoundFlippingRT;
 
 /**@brief   Sequential object-oriented SimPlex.
    @ingroup Algo
@@ -84,8 +90,8 @@ class SPxBoundFlippingRT;
    - preprocessing of the LP using class SPxSimplifier
    - termination criteria by overriding
 
-   SPxSolverBase is derived from SPxLPBase<R> that is used to store the LP to be solved.
-   Hence, the LPs solved with SPxSolverBase have the general format
+   SPxSolverBase is derived from SPxLPBase<R> that is used to store the LP to be
+   solved. Hence, the LPs solved with SPxSolverBase have the general format
 
    \f[
    \begin{array}{rl}
@@ -100,2275 +106,2039 @@ class SPxBoundFlippingRT;
 */
 
 template <class R>
-class SPxSolverBase : public SPxLPBase<R>, protected SPxBasisBase<R>
-{
-   friend SPxFastRT<R>;
-   friend SPxBoundFlippingRT<R>;
+class SPxSolverBase : public SPxLPBase<R>, protected SPxBasisBase<R> {
+  friend SPxFastRT<R>;
+  friend SPxBoundFlippingRT<R>;
 
 public:
-
-   //-----------------------------
-   /**@name Data Types */
-   ///@{
-   /// LP basis representation.
-   /** Solving LPs with the Simplex algorithm requires the definition of a
-    *  \em basis. A basis can be defined as a set of column vectors or a
-    *  set of row vectors building a nonsingular matrix. We will refer to
-    *  the first case as the \em columnwise representation and the latter
-    *  case will be called the \em rowwise representation.
-    *
-    *  Type Representation determines the representation of SPxSolverBase, i.e.
-    *  a columnwise (#COLUMN == 1) or rowwise (#ROW == -1) one.
-    */
-   enum Representation
-   {
-      ROW    = -1,  ///< rowwise representation.
-      COLUMN =  1   ///< columnwise representation.
-   };
-
-   /// Algorithmic type.
-   /** SPxSolverBase uses the reviesed Simplex algorithm to solve LPs.
-    *  Mathematically, one distinguishes the \em primal from the
-    *  \em dual algorihm. Algorithmically, these relate to the two
-    *  types #ENTER or #LEAVE. How they relate, depends on the chosen
-    *  basis representation. This is desribed by the following table:
-    *
-    *  <TABLE>
-    *  <TR><TD>&nbsp;</TD><TD>ENTER </TD><TD>LEAVE </TD></TR>
-    *  <TR><TD>ROW   </TD><TD>DUAL  </TD><TD>PRIMAL</TD></TR>
-    *  <TR><TD>COLUMN</TD><TD>PRIMAL</TD><TD>DUAL  </TD></TR>
-    *  </TABLE>
-    */
-   enum Type
-   {
-      /// Entering Simplex.
-      /** The Simplex loop for the entering Simplex can be sketched
-       *  as follows:
-       *  - \em Pricing : Select a variable to #ENTER the basis.
-       *  - \em Ratio-Test : Select variable to #LEAVE the
-       *    basis such that the basis remains feasible.
-       *  - Perform the basis update.
-       */
-      ENTER = -1,
-      /// Leaving Simplex.
-      /** The Simplex loop for the leaving Simplex can be sketched
-       *  as follows:
-       *  - \em Pricing: Select a variable to #LEAVE the basis.
-       *  - \em Ratio-Test: Select variable to #ENTER the
-       *    basis such that the basis remains priced.
-       *  - Perform the basis update.
-       */
-      LEAVE = 1
-   };
-
-   /// Pricing type.
-   /** In case of the #ENTER%ing Simplex algorithm, for performance
-    *  reasons it may be advisable not to compute and maintain up to
-    *  date vectors #pVec() and #test() and instead compute only some
-    *  of its elements explicitely. This is controled by the #Pricing type.
-    */
-   enum Pricing
-   {
-      /// Full pricing.
-      /** If #FULL pricing in selected for the #ENTER%ing Simplex,
-       *  vectors #pVec() and #test() are kept up to date by
-       *  SPxSolverBase. An SPxPricer only needs to select an Id such
-       *  that the #test() or #coTest() value is < 0.
-       */
-      FULL,
-      /// Partial pricing.
-      /** When #PARTIAL pricing in selected for the #ENTER%ing
-       *  Simplex, vectors #pVec() and #test() are not set up and
-       *  updated by SPxSolverBase. However, vectors #coPvec() and
-       *  #coTest() are still kept up to date by SPxSolverBase.
-       *  An SPxPricer object needs to compute the values for
-       *  #pVec() and #test() itself in order to select an
-       *  appropriate pivot with #test() < 0. Methods \ref computePvec(int)
-       *  "computePvec(i)" and \ref computeTest(int) "computeTest(i)"
-       *  will assist the used to do so. Note
-       *  that it may be feasible for a pricer to return an Id with
-       *  #test() > 0; such will be rejected by SPxSolverBase.
-       */
-      PARTIAL
-   };
-
-   /// Improved dual simplex status
-   /** The improved dual simplex requires a starting basis to perform the problem partitioning. This flag sets the
-    * status of the improved dual simplex to indicate whether the starting basis must be found or not.
-    */
-   enum DecompStatus
-   {
-      /// Starting basis has not been found yet
-      FINDSTARTBASIS = 0,
-      /// Starting basis has been found and the simplex can be executed as normal
-      DONTFINDSTARTBASIS = 1
-   };
-
-   enum VarStatus
-   {
-      ON_UPPER,      ///< variable set to its upper bound.
-      ON_LOWER,      ///< variable set to its lower bound.
-      FIXED,         ///< variable fixed to identical bounds.
-      ZERO,          ///< free variable fixed to zero.
-      BASIC,         ///< variable is basic.
-      UNDEFINED      ///< nothing known about basis status (possibly due to a singular basis in transformed problem)
-   };
-
-   /**@todo In spxchange, change the status to
-      if (m_status > 0) m_status = REGULAR;
+  //-----------------------------
+  /**@name Data Types */
+  ///@{
+  /// LP basis representation.
+  /** Solving LPs with the Simplex algorithm requires the definition of a
+   *  \em basis. A basis can be defined as a set of column vectors or a
+   *  set of row vectors building a nonsingular matrix. We will refer to
+   *  the first case as the \em columnwise representation and the latter
+   *  case will be called the \em rowwise representation.
+   *
+   *  Type Representation determines the representation of SPxSolverBase, i.e.
+   *  a columnwise (#COLUMN == 1) or rowwise (#ROW == -1) one.
    */
-   enum Status
-   {
-      ERROR          = -15, ///< an error occured.
-      NO_RATIOTESTER = -14, ///< No ratiotester loaded
-      NO_PRICER      = -13, ///< No pricer loaded
-      NO_SOLVER      = -12, ///< No linear solver loaded
-      NOT_INIT       = -11, ///< not initialised error
-      ABORT_EXDECOMP = -10, ///< solve() aborted to exit decomposition simplex
-      ABORT_DECOMP   = -9,  ///< solve() aborted due to commence decomposition simplex
-      ABORT_CYCLING  = -8,  ///< solve() aborted due to detection of cycling.
-      ABORT_TIME     = -7,  ///< solve() aborted due to time limit.
-      ABORT_ITER     = -6,  ///< solve() aborted due to iteration limit.
-      ABORT_VALUE    = -5,  ///< solve() aborted due to objective limit.
-      SINGULAR       = -4,  ///< Basis is singular, numerical troubles?
-      NO_PROBLEM     = -3,  ///< No Problem has been loaded.
-      REGULAR        = -2,  ///< LP has a usable Basis (maybe LP is changed).
-      RUNNING        = -1,  ///< algorithm is running
-      UNKNOWN        =  0,  ///< nothing known on loaded problem.
-      OPTIMAL        =  1,  ///< LP has been solved to optimality.
-      UNBOUNDED      =  2,  ///< LP has been proven to be primal unbounded.
-      INFEASIBLE     =  3,  ///< LP has been proven to be primal infeasible.
-      INForUNBD      =  4,   ///< LP is primal infeasible or unbounded.
-      OPTIMAL_UNSCALED_VIOLATIONS =  5   ///< LP has beed solved to optimality but unscaled solution contains violations.
-   };
-
-   /// objective for solution polishing
-   enum SolutionPolish
-   {
-      POLISH_OFF,           ///< don't perform modifications on optimal basis
-      POLISH_INTEGRALITY,   ///< maximize number of basic slack variables, i.e. more variables on bounds
-      POLISH_FRACTIONALITY  ///< minimize number of basic slack variables, i.e. more variables in between bounds
-   };
-
-
-   ///@}
+  enum Representation {
+    ROW = -1,  ///< rowwise representation.
+    COLUMN = 1 ///< columnwise representation.
+  };
+
+  /// Algorithmic type.
+  /** SPxSolverBase uses the reviesed Simplex algorithm to solve LPs.
+   *  Mathematically, one distinguishes the \em primal from the
+   *  \em dual algorihm. Algorithmically, these relate to the two
+   *  types #ENTER or #LEAVE. How they relate, depends on the chosen
+   *  basis representation. This is desribed by the following table:
+   *
+   *  <TABLE>
+   *  <TR><TD>&nbsp;</TD><TD>ENTER </TD><TD>LEAVE </TD></TR>
+   *  <TR><TD>ROW   </TD><TD>DUAL  </TD><TD>PRIMAL</TD></TR>
+   *  <TR><TD>COLUMN</TD><TD>PRIMAL</TD><TD>DUAL  </TD></TR>
+   *  </TABLE>
+   */
+  enum Type {
+    /// Entering Simplex.
+    /** The Simplex loop for the entering Simplex can be sketched
+     *  as follows:
+     *  - \em Pricing : Select a variable to #ENTER the basis.
+     *  - \em Ratio-Test : Select variable to #LEAVE the
+     *    basis such that the basis remains feasible.
+     *  - Perform the basis update.
+     */
+    ENTER = -1,
+    /// Leaving Simplex.
+    /** The Simplex loop for the leaving Simplex can be sketched
+     *  as follows:
+     *  - \em Pricing: Select a variable to #LEAVE the basis.
+     *  - \em Ratio-Test: Select variable to #ENTER the
+     *    basis such that the basis remains priced.
+     *  - Perform the basis update.
+     */
+    LEAVE = 1
+  };
+
+  /// Pricing type.
+  /** In case of the #ENTER%ing Simplex algorithm, for performance
+   *  reasons it may be advisable not to compute and maintain up to
+   *  date vectors #pVec() and #test() and instead compute only some
+   *  of its elements explicitely. This is controled by the #Pricing type.
+   */
+  enum Pricing {
+    /// Full pricing.
+    /** If #FULL pricing in selected for the #ENTER%ing Simplex,
+     *  vectors #pVec() and #test() are kept up to date by
+     *  SPxSolverBase. An SPxPricer only needs to select an Id such
+     *  that the #test() or #coTest() value is < 0.
+     */
+    FULL,
+    /// Partial pricing.
+    /** When #PARTIAL pricing in selected for the #ENTER%ing
+     *  Simplex, vectors #pVec() and #test() are not set up and
+     *  updated by SPxSolverBase. However, vectors #coPvec() and
+     *  #coTest() are still kept up to date by SPxSolverBase.
+     *  An SPxPricer object needs to compute the values for
+     *  #pVec() and #test() itself in order to select an
+     *  appropriate pivot with #test() < 0. Methods \ref computePvec(int)
+     *  "computePvec(i)" and \ref computeTest(int) "computeTest(i)"
+     *  will assist the used to do so. Note
+     *  that it may be feasible for a pricer to return an Id with
+     *  #test() > 0; such will be rejected by SPxSolverBase.
+     */
+    PARTIAL
+  };
+
+  /// Improved dual simplex status
+  /** The improved dual simplex requires a starting basis to perform the problem
+   * partitioning. This flag sets the status of the improved dual simplex to
+   * indicate whether the starting basis must be found or not.
+   */
+  enum DecompStatus {
+    /// Starting basis has not been found yet
+    FINDSTARTBASIS = 0,
+    /// Starting basis has been found and the simplex can be executed as normal
+    DONTFINDSTARTBASIS = 1
+  };
+
+  enum VarStatus {
+    ON_UPPER, ///< variable set to its upper bound.
+    ON_LOWER, ///< variable set to its lower bound.
+    FIXED,    ///< variable fixed to identical bounds.
+    ZERO,     ///< free variable fixed to zero.
+    BASIC,    ///< variable is basic.
+    UNDEFINED ///< nothing known about basis status (possibly due to a singular
+              ///< basis in transformed problem)
+  };
+
+  /**@todo In spxchange, change the status to
+     if (m_status > 0) m_status = REGULAR;
+  */
+  enum Status {
+    ERROR = -15,          ///< an error occured.
+    NO_RATIOTESTER = -14, ///< No ratiotester loaded
+    NO_PRICER = -13,      ///< No pricer loaded
+    NO_SOLVER = -12,      ///< No linear solver loaded
+    NOT_INIT = -11,       ///< not initialised error
+    ABORT_EXDECOMP = -10, ///< solve() aborted to exit decomposition simplex
+    ABORT_DECOMP =
+        -9, ///< solve() aborted due to commence decomposition simplex
+    ABORT_CYCLING = -8, ///< solve() aborted due to detection of cycling.
+    ABORT_TIME = -7,    ///< solve() aborted due to time limit.
+    ABORT_ITER = -6,    ///< solve() aborted due to iteration limit.
+    ABORT_VALUE = -5,   ///< solve() aborted due to objective limit.
+    SINGULAR = -4,      ///< Basis is singular, numerical troubles?
+    NO_PROBLEM = -3,    ///< No Problem has been loaded.
+    REGULAR = -2,       ///< LP has a usable Basis (maybe LP is changed).
+    RUNNING = -1,       ///< algorithm is running
+    UNKNOWN = 0,        ///< nothing known on loaded problem.
+    OPTIMAL = 1,        ///< LP has been solved to optimality.
+    UNBOUNDED = 2,      ///< LP has been proven to be primal unbounded.
+    INFEASIBLE = 3,     ///< LP has been proven to be primal infeasible.
+    INForUNBD = 4,      ///< LP is primal infeasible or unbounded.
+    OPTIMAL_UNSCALED_VIOLATIONS = 5 ///< LP has beed solved to optimality but
+                                    ///< unscaled solution contains violations.
+  };
+
+  /// objective for solution polishing
+  enum SolutionPolish {
+    POLISH_OFF,         ///< don't perform modifications on optimal basis
+    POLISH_INTEGRALITY, ///< maximize number of basic slack variables, i.e. more
+                        ///< variables on bounds
+    POLISH_FRACTIONALITY ///< minimize number of basic slack variables, i.e.
+                         ///< more variables in between bounds
+  };
+
+  ///@}
 
 private:
-
-   //-----------------------------
-   /**@name Private data */
-   ///@{
-   Type           theType;     ///< entering or leaving algortihm.
-   Pricing        thePricing;  ///< full or partial pricing.
-   Representation theRep;      ///< row or column representation.
-   SolutionPolish polishObj;   ///< objective of solution polishing
-   Timer*         theTime;     ///< time spent in last call to method solve()
-   Timer::TYPE    timerType;   ///< type of timer (user or wallclock)
-   Real           theCumulativeTime; ///< cumulative time spent in all calls to method solve()
-   int            maxIters;    ///< maximum allowed iterations.
-   Real           maxTime;     ///< maximum allowed time.
-   int            nClckSkipsLeft; ///< remaining number of times the clock can be safely skipped
-   long           nCallsToTimelim; /// < the number of calls to the method isTimeLimitReached()
-   R           objLimit;    ///< objective value limit.
-   Status         m_status;    ///< status of algorithm.
-
-   R           m_nonbasicValue;         ///< nonbasic part of current objective value
-   bool           m_nonbasicValueUpToDate; ///< true, if the stored objValue is up to date
-
-   R           m_pricingViol;             ///< maximal feasibility violation of current solution
-   bool           m_pricingViolUpToDate;     ///< true, if the stored violation is up to date
-
-   R
-   m_pricingViolCo;           ///< maximal feasibility violation of current solution in coDim
-   bool           m_pricingViolCoUpToDate;   ///< true, if the stored violation in coDim is up to date
-   int            m_numViol;     ///< number of violations of current solution
-
-   R           m_entertol;    ///< feasibility tolerance maintained during entering algorithm
-   R           m_leavetol;    ///< feasibility tolerance maintained during leaving algorithm
-   R           theShift;      ///< sum of all shifts applied to any bound.
-   R           lastShift;     ///< for forcing feasibility.
-   int            m_maxCycle;    ///< maximum steps before cycling is detected.
-   int            m_numCycle;    ///< actual number of degenerate steps so far.
-   bool           initialized;   ///< true, if all vectors are setup.
-
-   SSVectorBase<R>*
-   solveVector2;      ///< when 2 systems are to be solved at a time; typically for speepest edge weights
-   SSVectorBase<R>*
-   solveVector2rhs;   ///< when 2 systems are to be solved at a time; typically for speepest edge weights
-   SSVectorBase<R>*
-   solveVector3;      ///< when 3 systems are to be solved at a time; typically reserved for bound flipping ratio test (basic solution will be modified!)
-   SSVectorBase<R>*
-   solveVector3rhs;   ///< when 3 systems are to be solved at a time; typically reserved for bound flipping ratio test (basic solution will be modified!)
-   SSVectorBase<R>*
-   coSolveVector2;    ///< when 2 systems are to be solved at a time; typically for speepest edge weights
-   SSVectorBase<R>*
-   coSolveVector2rhs; ///< when 2 systems are to be solved at a time; typically for speepest edge weights
-   SSVectorBase<R>*
-   coSolveVector3;    ///< when 3 systems are to be solved at a time; typically reserved for bound flipping ratio test (basic solution will be modified!)
-   SSVectorBase<R>*
-   coSolveVector3rhs; ///< when 3 systems are to be solved at a time; typically reserved for bound flipping ratio test (basic solution will be modified!)
-
-   bool           freePricer;        ///< true iff thepricer should be freed inside of object
-   bool           freeRatioTester;   ///< true iff theratiotester should be freed inside of object
-   bool           freeStarter;       ///< true iff thestarter should be freed inside of object
-
-   /* Store the index of a leaving variable if only an instable entering variable has been found.
-      instableLeave == true iff this instable basis change should be performed.
-      (see spxsolve.hpp and leave.hpp) */
-   int            instableLeaveNum;
-   bool           instableLeave;
-   R           instableLeaveVal;
-
-   /* Store the id of an entering row or column if only an instable pivot has been found.
-      instableEnter == true iff this instable basis change should be performed.
-      (see spxsolve.hpp and enter.hpp) */
-   SPxId          instableEnterId;
-   bool           instableEnter;
-   R           instableEnterVal;
-
-   bool
-   recomputedVectors;      ///< flag to perform clean up step to reduce numerical errors only once
-
-   int            displayLine;
-   int            displayFreq;
-   R           sparsePricingFactor;    ///< enable sparse pricing when viols < factor * dim()
-
-   bool
-   getStartingDecompBasis; ///< flag to indicate whether the simplex is solved to get the starting improved dual simplex basis
-   bool           computeDegeneracy;
-   int
-   degenCompIterOffset;    ///< the number of iterations performed before the degeneracy level is computed
-   int
-   decompIterationLimit;   ///< the maximum number of iterations before the decomposition simplex is aborted.
-
-   bool
-   fullPerturbation;       ///< whether to perturb the entire problem or just the bounds relevant for the current pivot
-   int
-   printBasisMetric;       ///< printing the current basis metric in the log (-1: off, 0: condition estimate, 1: trace, 2: determinant, 3: condition)
-
-   ///@}
+  //-----------------------------
+  /**@name Private data */
+  ///@{
+  Type theType;             ///< entering or leaving algortihm.
+  Pricing thePricing;       ///< full or partial pricing.
+  Representation theRep;    ///< row or column representation.
+  SolutionPolish polishObj; ///< objective of solution polishing
+  Timer *theTime;           ///< time spent in last call to method solve()
+  Timer::TYPE timerType;    ///< type of timer (user or wallclock)
+  Real theCumulativeTime;   ///< cumulative time spent in all calls to method
+                            ///< solve()
+  int maxIters;             ///< maximum allowed iterations.
+  Real maxTime;             ///< maximum allowed time.
+  int nClckSkipsLeft;   ///< remaining number of times the clock can be safely
+                        ///< skipped
+  long nCallsToTimelim; /// < the number of calls to the method
+                        /// isTimeLimitReached()
+  R objLimit;           ///< objective value limit.
+  Status m_status;      ///< status of algorithm.
+
+  R m_nonbasicValue;            ///< nonbasic part of current objective value
+  bool m_nonbasicValueUpToDate; ///< true, if the stored objValue is up to date
+
+  R m_pricingViol; ///< maximal feasibility violation of current solution
+  bool m_pricingViolUpToDate; ///< true, if the stored violation is up to date
+
+  R m_pricingViolCo; ///< maximal feasibility violation of current solution in
+                     ///< coDim
+  bool m_pricingViolCoUpToDate; ///< true, if the stored violation in coDim is
+                                ///< up to date
+  int m_numViol;                ///< number of violations of current solution
+
+  R m_entertol; ///< feasibility tolerance maintained during entering algorithm
+  R m_leavetol; ///< feasibility tolerance maintained during leaving algorithm
+  R theShift;   ///< sum of all shifts applied to any bound.
+  R lastShift;  ///< for forcing feasibility.
+  int m_maxCycle;   ///< maximum steps before cycling is detected.
+  int m_numCycle;   ///< actual number of degenerate steps so far.
+  bool initialized; ///< true, if all vectors are setup.
+
+  SSVectorBase<R> *solveVector2; ///< when 2 systems are to be solved at a time;
+                                 ///< typically for speepest edge weights
+  SSVectorBase<R>
+      *solveVector2rhs; ///< when 2 systems are to be solved at a time;
+                        ///< typically for speepest edge weights
+  SSVectorBase<R>
+      *solveVector3; ///< when 3 systems are to be solved at a time; typically
+                     ///< reserved for bound flipping ratio test (basic solution
+                     ///< will be modified!)
+  SSVectorBase<R>
+      *solveVector3rhs; ///< when 3 systems are to be solved at a time;
+                        ///< typically reserved for bound flipping ratio test
+                        ///< (basic solution will be modified!)
+  SSVectorBase<R>
+      *coSolveVector2; ///< when 2 systems are to be solved at a time; typically
+                       ///< for speepest edge weights
+  SSVectorBase<R>
+      *coSolveVector2rhs; ///< when 2 systems are to be solved at a time;
+                          ///< typically for speepest edge weights
+  SSVectorBase<R>
+      *coSolveVector3; ///< when 3 systems are to be solved at a time; typically
+                       ///< reserved for bound flipping ratio test (basic
+                       ///< solution will be modified!)
+  SSVectorBase<R>
+      *coSolveVector3rhs; ///< when 3 systems are to be solved at a time;
+                          ///< typically reserved for bound flipping ratio test
+                          ///< (basic solution will be modified!)
+
+  bool freePricer;      ///< true iff thepricer should be freed inside of object
+  bool freeRatioTester; ///< true iff theratiotester should be freed inside of
+                        ///< object
+  bool freeStarter; ///< true iff thestarter should be freed inside of object
+
+  /* Store the index of a leaving variable if only an instable entering variable
+     has been found. instableLeave == true iff this instable basis change should
+     be performed. (see spxsolve.hpp and leave.hpp) */
+  int instableLeaveNum;
+  bool instableLeave;
+  R instableLeaveVal;
+
+  /* Store the id of an entering row or column if only an instable pivot has
+     been found. instableEnter == true iff this instable basis change should be
+     performed. (see spxsolve.hpp and enter.hpp) */
+  SPxId instableEnterId;
+  bool instableEnter;
+  R instableEnterVal;
+
+  bool recomputedVectors; ///< flag to perform clean up step to reduce numerical
+                          ///< errors only once
+
+  int displayLine;
+  int displayFreq;
+  R sparsePricingFactor; ///< enable sparse pricing when viols < factor * dim()
+
+  bool getStartingDecompBasis; ///< flag to indicate whether the simplex is
+                               ///< solved to get the starting improved dual
+                               ///< simplex basis
+  bool computeDegeneracy;
+  int degenCompIterOffset;  ///< the number of iterations performed before the
+                            ///< degeneracy level is computed
+  int decompIterationLimit; ///< the maximum number of iterations before the
+                            ///< decomposition simplex is aborted.
+
+  bool fullPerturbation; ///< whether to perturb the entire problem or just the
+                         ///< bounds relevant for the current pivot
+  int printBasisMetric;  ///< printing the current basis metric in the log (-1:
+                         ///< off, 0: condition estimate, 1: trace, 2:
+                         ///< determinant, 3: condition)
+
+  ///@}
 
 protected:
-
-   //-----------------------------
-   /**@name Protected data */
-   ///@{
-   Array < UnitVectorBase<R> > unitVecs; ///< array of unit vectors
-   const SVSetBase<R>*   thevectors;   ///< the LP vectors according to representation
-   const SVSetBase<R>*   thecovectors; ///< the LP coVectors according to representation
-
-   VectorBase<R>        primRhs;     ///< rhs VectorBase<R> for computing the primal vector
-   UpdateVector<R>   primVec;     ///< primal vector
-   VectorBase<R>        dualRhs;     ///< rhs VectorBase<R> for computing the dual vector
-   UpdateVector<R>   dualVec;     ///< dual vector
-   UpdateVector<R>   addVec;      ///< storage for thePvec = &addVec
-
-   VectorBase<R>        theURbound;  ///< Upper Row    Feasibility bound
-   VectorBase<R>        theLRbound;  ///< Lower Row    Feasibility bound
-   VectorBase<R>        theUCbound;  ///< Upper Column Feasibility bound
-   VectorBase<R>        theLCbound;  ///< Lower Column Feasibility bound
-
-   /** In entering Simplex algorithm, the ratio test must ensure that all
-    *  \em basic variables remain within their feasibility bounds. To give fast
-    *  acces to them, the bounds of basic variables are copied into the
-    *  following two vectors.
-    */
-   VectorBase<R>        theUBbound;  ///< Upper Basic Feasibility bound
-   VectorBase<R>        theLBbound;  ///< Lower Basic Feasibility bound
-
-   /** The values of the rhs corresponding to the current basis.*/
-   VectorBase<R>*       theFrhs;
-   /** The values of all basis variables. */
-   UpdateVector<R>*  theFvec;
-
-   /* The Copricing rhs and VectorBase<R> */
-   VectorBase<R>*       theCoPrhs;
-   UpdateVector<R>*  theCoPvec;
-   /** The pricing VectorBase<R> */
-   UpdateVector<R>*  thePvec;
-
-   UpdateVector<R>*  theRPvec;    ///< row pricing vector
-   UpdateVector<R>*  theCPvec;    ///< column pricing vector
-
-   // The following vectors serve for the virtualization of shift bounds
-   //@todo In prinziple this schould be references.
-   VectorBase<R>*       theUbound;      ///< Upper bound for vars
-   VectorBase<R>*       theLbound;      ///< Lower bound for vars
-   VectorBase<R>*       theCoUbound;    ///< Upper bound for covars
-   VectorBase<R>*       theCoLbound;    ///< Lower bound for covars
-
-   // The following vectors serve for the virtualization of testing vectors
-   VectorBase<R>        theCoTest;
-   VectorBase<R>        theTest;
-
-   DSVectorBase<R>       primalRay;      ///< stores primal ray in case of unboundedness
-   DSVectorBase<R>       dualFarkas;     ///< stores dual farkas proof in case of infeasibility
-
-   int            leaveCount;    ///< number of LEAVE iterations
-   int            enterCount;    ///< number of ENTER iterations
-   int            primalCount;   ///< number of primal iterations
-   int            polishCount;   ///< number of solution polishing iterations
-
-   int            boundflips;          ///< number of performed bound flips
-   int            totalboundflips;     ///< total number of bound flips
-
-   int            enterCycles;      ///< the number of degenerate steps during the entering algorithm
-   int            leaveCycles;      ///< the number of degenerate steps during the leaving algorithm
-   int            enterDegenCand;   ///< the number of degenerate candidates in the entering algorithm
-   int            leaveDegenCand;   ///< the number of degenerate candidates in the leaving algorithm
-   R           primalDegenSum;   ///< the sum of the primal degeneracy percentage
-   R           dualDegenSum;     ///< the sum of the dual degeneracy percentage
-
-   SPxPricer<R>*      thepricer;
-   SPxRatioTester<R>* theratiotester;
-   SPxStarter<R>*     thestarter;
-
-   R           boundrange;       ///< absolute range of all bounds in the problem
-   R           siderange;        ///< absolute range of all side in the problem
-   R           objrange;         ///< absolute range of all objective coefficients in the problem
-   ///@}
-
-   //-----------------------------
-   /**@name Precision */
-   ///@{
-   /// is the solution precise enough, or should we increase delta() ?
-   virtual bool precisionReached(R& newpricertol) const;
-
-   /// determine ranges of problem values for bounds, sides and objective to assess numerical difficulties
-   void calculateProblemRanges();
-   ///@}
+  //-----------------------------
+  /**@name Protected data */
+  ///@{
+  Array<UnitVectorBase<R>> unitVecs; ///< array of unit vectors
+  const SVSetBase<R>
+      *thevectors; ///< the LP vectors according to representation
+  const SVSetBase<R>
+      *thecovectors; ///< the LP coVectors according to representation
+
+  VectorBase<R> primRhs; ///< rhs VectorBase<R> for computing the primal vector
+  UpdateVector<R> primVec; ///< primal vector
+  VectorBase<R> dualRhs;   ///< rhs VectorBase<R> for computing the dual vector
+  UpdateVector<R> dualVec; ///< dual vector
+  UpdateVector<R> addVec;  ///< storage for thePvec = &addVec
+
+  VectorBase<R> theURbound; ///< Upper Row    Feasibility bound
+  VectorBase<R> theLRbound; ///< Lower Row    Feasibility bound
+  VectorBase<R> theUCbound; ///< Upper Column Feasibility bound
+  VectorBase<R> theLCbound; ///< Lower Column Feasibility bound
+
+  /** In entering Simplex algorithm, the ratio test must ensure that all
+   *  \em basic variables remain within their feasibility bounds. To give fast
+   *  acces to them, the bounds of basic variables are copied into the
+   *  following two vectors.
+   */
+  VectorBase<R> theUBbound; ///< Upper Basic Feasibility bound
+  VectorBase<R> theLBbound; ///< Lower Basic Feasibility bound
+
+  /** The values of the rhs corresponding to the current basis.*/
+  VectorBase<R> *theFrhs;
+  /** The values of all basis variables. */
+  UpdateVector<R> *theFvec;
+
+  /* The Copricing rhs and VectorBase<R> */
+  VectorBase<R> *theCoPrhs;
+  UpdateVector<R> *theCoPvec;
+  /** The pricing VectorBase<R> */
+  UpdateVector<R> *thePvec;
+
+  UpdateVector<R> *theRPvec; ///< row pricing vector
+  UpdateVector<R> *theCPvec; ///< column pricing vector
+
+  // The following vectors serve for the virtualization of shift bounds
+  //@todo In prinziple this schould be references.
+  VectorBase<R> *theUbound;   ///< Upper bound for vars
+  VectorBase<R> *theLbound;   ///< Lower bound for vars
+  VectorBase<R> *theCoUbound; ///< Upper bound for covars
+  VectorBase<R> *theCoLbound; ///< Lower bound for covars
+
+  // The following vectors serve for the virtualization of testing vectors
+  VectorBase<R> theCoTest;
+  VectorBase<R> theTest;
+
+  DSVectorBase<R> primalRay; ///< stores primal ray in case of unboundedness
+  DSVectorBase<R>
+      dualFarkas; ///< stores dual farkas proof in case of infeasibility
+
+  int leaveCount;  ///< number of LEAVE iterations
+  int enterCount;  ///< number of ENTER iterations
+  int primalCount; ///< number of primal iterations
+  int polishCount; ///< number of solution polishing iterations
+
+  int boundflips;      ///< number of performed bound flips
+  int totalboundflips; ///< total number of bound flips
+
+  int enterCycles;    ///< the number of degenerate steps during the entering
+                      ///< algorithm
+  int leaveCycles;    ///< the number of degenerate steps during the leaving
+                      ///< algorithm
+  int enterDegenCand; ///< the number of degenerate candidates in the entering
+                      ///< algorithm
+  int leaveDegenCand; ///< the number of degenerate candidates in the leaving
+                      ///< algorithm
+  R primalDegenSum;   ///< the sum of the primal degeneracy percentage
+  R dualDegenSum;     ///< the sum of the dual degeneracy percentage
+
+  SPxPricer<R> *thepricer;
+  SPxRatioTester<R> *theratiotester;
+  SPxStarter<R> *thestarter;
+
+  R boundrange; ///< absolute range of all bounds in the problem
+  R siderange;  ///< absolute range of all side in the problem
+  R objrange;   ///< absolute range of all objective coefficients in the problem
+  ///@}
+
+  //-----------------------------
+  /**@name Precision */
+  ///@{
+  /// is the solution precise enough, or should we increase delta() ?
+  virtual bool precisionReached(R &newpricertol) const;
+
+  /// determine ranges of problem values for bounds, sides and objective to
+  /// assess numerical difficulties
+  void calculateProblemRanges();
+  ///@}
 
 public:
+  /// The random number generator used throughout the whole computation. Its
+  /// seed can be modified.
+  Random random;
 
-   /// The random number generator used throughout the whole computation. Its seed can be modified.
-   Random random;
-
-   /** For the leaving Simplex algorithm this vector contains the indices of infeasible basic variables;
-    *  for the entering Simplex algorithm this vector contains the indices of infeasible slack variables.
-    */
-   DIdxSet infeasibilities;
-   /**For the entering Simplex algorithm these vectors contains the indices of infeasible basic variables.
-    */
-   DIdxSet infeasibilitiesCo;
-
-   /// store indices that were changed in the previous iteration and must be checked in hyper pricing
-   DIdxSet updateViols;
-   DIdxSet updateViolsCo;
-
-   /** Binary vectors to store whether basic indices are infeasible
-    *  the i-th entry equals false, if the i-th basic variable is not infeasible
-    *  the i-th entry equals true, if the i-th basic variable is infeasible
-    */
-   DataArray<int>
-   isInfeasible;           ///< 0: index not violated, 1: index violated, 2: index violated and among candidate list
-   DataArray<int>
-   isInfeasibleCo;         ///< 0: index not violated, 1: index violated, 2: index violated and among candidate list
-
-   /// These values enable or disable sparse pricing
-   bool     sparsePricingLeave;        ///< true if sparsePricing is turned on in the leaving Simplex
-   bool     sparsePricingEnter;        ///< true if sparsePricing is turned on in the entering Simplex for slack variables
-   bool     sparsePricingEnterCo;      ///< true if sparsePricing is turned on in the entering Simplex
-   bool     hyperPricingLeave;         ///< true if hyper sparse pricing is turned on in the leaving Simplex
-   bool     hyperPricingEnter;         ///< true if hyper sparse pricing is turned on in the entering Simplex
-
-   int      remainingRoundsLeave;      ///< number of dense rounds/refactorizations until sparsePricing is enabled again
-   int      remainingRoundsEnter;
-   int      remainingRoundsEnterCo;
-
-   /// dual pricing norms
-   VectorBase<R>     weights;                ///< store dual norms
-   VectorBase<R>     coWeights;              ///< store dual norms
-   bool        weightsAreSetup;        ///< are the dual norms already set up?
-
-
-   Timer*   multTimeSparse;            ///< time spent in setupPupdate() exploiting sparsity
-   Timer*   multTimeFull;              ///< time spent in setupPupdate() ignoring sparsity
-   Timer*   multTimeColwise;           ///< time spent in setupPupdate(), columnwise multiplication
-   Timer*   multTimeUnsetup;           ///< time spent in setupPupdate() w/o sparsity information
-   int      multSparseCalls;           ///< number of products exploiting sparsity
-   int      multFullCalls;             ///< number of products ignoring sparsity
-   int      multColwiseCalls;          ///< number of products, columnwise multiplication
-   int      multUnsetupCalls;          ///< number of products w/o sparsity information
-
-   SPxOut* spxout;                     ///< message handler
-
-   DataArray<int>
-   integerVariables;    ///< supplementary variable information, 0: continous variable, 1: integer variable
-
-   //-----------------------------
-   void setOutstream(SPxOut& newOutstream)
-   {
-      spxout = &newOutstream;
-      SPxLPBase<R>::spxout = &newOutstream;
-   }
-
-   /// set refactor threshold for nonzeros in last factorized basis matrix compared to updated basis matrix
-   void setNonzeroFactor(R f)
-   {
-      SPxBasisBase<R>::nonzeroFactor = f;
-   }
-
-   /// set refactor threshold for fill-in in current factor update compared to fill-in in last factorization
-   void setFillFactor(R f)
-   {
-      SPxBasisBase<R>::fillFactor = f;
-   }
-
-   /// set refactor threshold for memory growth in current factor update compared to the last factorization
-   void setMemFactor(R f)
-   {
-      SPxBasisBase<R>::memFactor = f;
-   }
-
-   /**@name Access */
-   ///@{
-   /// return the version of SPxSolverBase as number like 123 for 1.2.3
-   int version() const
-   {
-      return SOPLEX_VERSION;
-   }
-   /// return the internal subversion of SPxSolverBase as number
-   int subversion() const
-   {
-      return SOPLEX_SUBVERSION;
-   }
-   /// return the current basis representation.
-   Representation rep() const
-   {
-      return theRep;
-   }
-
-   /// return current Type.
-   Type type() const
-   {
-      return theType;
-   }
-
-   /// return current Pricing.
-   Pricing pricing() const
-   {
-      return thePricing;
-   }
-
-   /// return current starter.
-   SPxStarter<R>* starter() const
-   {
-      return thestarter;
-   }
-   ///@}
-
-   //-----------------------------
-   /**@name Setup
-    *  Before solving an LP with an instance of SPxSolverBase,
-    *  the following steps must be performed:
-    *
-    *  -# Load the LP by copying an external LP or reading it from an
-    *     input stream.
-    *  -# Setup the pricer to use by loading an \ref soplex::SPxPricer
-    *     "SPxPricer" object (if not already done in a previous call).
-    *  -# Setup the ratio test method to use by loading an
-    *     \ref soplex::SPxRatioTester "SPxRatioTester" object
-    *     (if not already done in a previous call).
-    *  -# Setup the linear system solver to use by loading an
-    *     \ref soplex::SLinSolver "SLinSolver" object
-    *     (if not already done in a previous call).
-    *  -# Optionally setup an start basis generation method by loading an
-    *     \ref soplex::SPxStarter "SPxStarter" object.
-    *  -# Optionally setup a start basis by loading a
-    *     \ref soplex::SPxBasisBase<R>::Desc "SPxBasisBase<R>::Desc" object.
-    *  -# Optionally switch to another basis
-    *     \ref soplex::SPxSolverBase<R>::Representation "Representation"
-    *     by calling method \ref soplex::SPxSolverBase<R>::setRep() "setRep()".
-    *  -# Optionally switch to another algorithm
-    *     \ref soplex::SPxSolverBase<R>::Type "Type"
-    *     by calling method \ref soplex::SPxSolverBase<R>::setType() "setType()".
-    *
-    *  Now the solver is ready for execution. If the loaded LP is to be solved
-    *  again from scratch, this can be done with method
-    *  \ref soplex::SPxSolverBase<R>::reLoad() "reLoad()". Finally,
-    *  \ref soplex::SPxSolverBase<R>::clear() "clear()" removes the LP from the solver.
-    */
-   ///@{
-   /// read LP from input stream.
-   virtual bool read(std::istream& in, NameSet* rowNames = 0,
-                     NameSet* colNames = 0, DIdxSet* intVars = 0);
-
-   /// copy LP.
-   virtual void loadLP(const SPxLPBase<R>& LP, bool initSlackBasis = true);
-   /// setup linear solver to use. If \p destroy is true, \p slusolver will be freed in destructor.
-   virtual void setBasisSolver(SLinSolver<R>* slu, const bool destroy = false);
-   /// setup pricer to use. If \p destroy is true, \p pricer will be freed in destructor.
-   virtual void setPricer(SPxPricer<R>* pricer, const bool destroy = false);
-   /// setup ratio-tester to use. If \p destroy is true, \p tester will be freed in destructor.
-   virtual void setTester(SPxRatioTester<R>* tester, const bool destroy = false);
-   /// setup starting basis generator to use. If \p destroy is true, \p starter will be freed in destructor.
-   virtual void setStarter(SPxStarter<R>* starter, const bool destroy = false);
-   /// set a start basis.
-   virtual void loadBasis(const typename SPxBasisBase<R>::Desc&);
-
-   /// initialize #ROW or #COLUMN representation.
-   void initRep(Representation p_rep);
-   /// switch to #ROW or #COLUMN representation if not already used.
-   void setRep(Representation p_rep);
-   /// set \ref soplex::SPxSolverBase<R>::LEAVE "LEAVE" or \ref soplex::SPxSolverBase<R>::ENTER "ENTER" algorithm.
-   void setType(Type tp);
-   /// set \ref soplex::SPxSolverBase<R>::FULL "FULL" or \ref soplex::SPxSolverBase<R>::PARTIAL "PARTIAL" pricing.
-   void setPricing(Pricing pr);
-   /// turn on or off the improved dual simplex.
-   void setDecompStatus(DecompStatus decomp_stat);
-
-   /// reload LP.
-   virtual void reLoad();
-
-   /// clear all data in solver.
-   virtual void clear();
-
-   /// unscales the LP and reloads the basis
-   void unscaleLPandReloadBasis();
-
-   /// invalidates the basis, triggers refactorization
-   void invalidateBasis();
-
-   /** Load basis from \p filename in MPS format. If \p rowNames and \p
-    *  colNames are \c NULL, default names are used for the constraints and
-    *  variables.
-    */
-   virtual bool readBasisFile(const char* filename,
-                              const NameSet* rowNames, const NameSet* colNames);
-
-   /** Write basis to \p filename in MPS format. If \p rowNames and \p
-    *  colNames are \c NULL, default names are used for the constraints and
-    *  variables.
-    */
-   virtual bool writeBasisFile(const char* filename,
-                               const NameSet* rowNames, const NameSet* colNames, const bool cpxFormat = false) const;
-
-   /** Write current LP, basis, and parameter settings.
-    *  LP is written in MPS format to "\p filename".mps, basis is written in "\p filename".bas, and parameters
-    *  are written to "\p filename".set. If \p rowNames and \p colNames are \c NULL, default names are used for
-    *  the constraints and variables.
-    */
-   virtual bool writeState(const char* filename,
-                           const NameSet* rowNames = NULL, const NameSet* colNames = NULL, const bool cpxFormat = false) const;
-
-   ///@}
-
-   /**@name Solving LPs */
-   ///@{
-   /// solve loaded LP.
-   /** Solves the loaded LP by processing the Simplex iteration until
-    *  the termination criteria is fullfilled (see #terminate()).
-    *  The SPxStatus of the solver will indicate the reason for termination.
-    *
-    *  @throw SPxStatusException if either no problem, solver, pricer
-    *  or ratiotester loaded or if solve is still running when it shouldn't be
-    */
-   virtual Status solve(volatile bool* interrupt = NULL);
-
-   /** Identify primal basic variables that have zero reduced costs and
-    * try to pivot them out of the basis to make them tight.
-    * This is supposed to decrease the number of fractional variables
-    * when solving LP relaxations of (mixed) integer programs.
-    * The objective must not be modified during this procedure.
-    */
-   void performSolutionPolishing();
-
-   /// set objective of solution polishing (0: off, 1: max_basic_slack, 2: min_basic_slack)
-   void setSolutionPolishing(SolutionPolish _polishObj)
-   {
-      polishObj = _polishObj;
-   }
-
-   /// return objective of solution polishing
-   SolutionPolish getSolutionPolishing()
-   {
-      return polishObj;
-   }
-
-   /// Status of solution process.
-   Status status() const;
-
-   /// current objective value.
-   /**@return Objective value of the current solution vector
-    *         (see #getPrimalSol()).
-    */
-   virtual R value();
-
-   // update nonbasic part of the objective value by the given amount
-   /**@return whether nonbasic part of objective is reliable
-    */
-   bool updateNonbasicValue(R objChange);
-
-   // trigger a recomputation of the nonbasic part of the objective value
-   void forceRecompNonbasicValue()
-   {
-      m_nonbasicValue = 0.0;
-      m_nonbasicValueUpToDate = false;
-   }
-
-   /// get solution vector for primal variables.
-   /** This method returns the Status of the basis.
-    *  If it is #REGULAR or better,
-    *  the primal solution vector of the current basis will be copied
-    *  to the argument \p vector. Hence, \p vector must be of dimension
-    *  #nCols().
-    *
-    *  @throw SPxStatusException if not initialized
-    */
-   virtual Status getPrimalSol(VectorBase<R>& vector) const;
-
-   /// get VectorBase<R> of slack variables.
-   /** This method returns the Status of the basis.
-    *  If it is #REGULAR or better,
-    *  the slack variables of the current basis will be copied
-    *  to the argument \p vector. Hence, \p VectorBase<R> must be of dimension
-    *  #nRows().
-    *
-    *  @warning Because SPxSolverBase supports range constraints as its
-    *     default, slack variables are defined in a nonstandard way:
-    *     Let \em x be the current solution vector and \em A the constraint
-    *     matrix. Then the vector of slack variables is defined as
-    *     \f$s = Ax\f$.
-    *
-    *  @throw SPxStatusException if no problem loaded
-    */
-   virtual Status getSlacks(VectorBase<R>& vector) const;
-
-   /// get current solution VectorBase<R> for dual variables.
-   /** This method returns the Status of the basis.
-    *  If it is #REGULAR or better,
-    *  the VectorBase<R> of dual variables of the current basis will be copied
-    *  to the argument \p vector. Hence, \p VectorBase<R> must be of dimension
-    *  #nRows().
-    *
-    *  @warning Even though mathematically, each range constraint would
-    *     account for two dual variables (one for each inequaility), only
-    *     #nRows() dual variables are setup via the following
-    *     construction: Given a range constraint, there are three possible
-    *     situations:
-    *     - None of its inequalities is tight: The dual variables
-    *       for both are 0. However, when shifting (see below)
-    *       occurs, it may be set to a value other than 0, which
-    *       models a perturbed objective vector.
-    *     - Both of its inequalities are tight: In this case the
-    *       range constraint models an equality and we adopt the
-    *       standard definition.
-    *     - One of its inequalities is tight while the other is not:
-    *       In this case only the dual variable for the tight
-    *       constraint is given with the standard definition, while
-    *       the other constraint is implicitely set to 0.
-    *
-    *  @throw SPxStatusException if no problem loaded
-    */
-   virtual Status getDualSol(VectorBase<R>& vector) const;
-
-   /// get vector of reduced costs.
-   /** This method returns the Status of the basis.
-    *  If it is #REGULAR or better,
-    *  the vector of reduced costs of the current basis will be copied
-    *  to the argument \p vector. Hence, \p vector must be of dimension
-    *  #nCols().
-    *
-    *  Let \em d denote the vector of dual variables, as defined above,
-    *  and \em A the LPs constraint matrix. Then the reduced cost vector
-    *  \em r is defined as \f$r^T = c^T - d^TA\f$.
-    *
-    *  @throw SPxStatusException if no problem loaded
-    */
-   virtual Status getRedCostSol(VectorBase<R>& vector) const;
-
-   /// get primal ray in case of unboundedness.
-   ///  @throw SPxStatusException if no problem loaded
-   virtual Status getPrimalray(VectorBase<R>& vector) const;
-
-   /// get dual farkas proof of infeasibility.
-   ///  @throw SPxStatusException if no problem loaded
-   virtual Status getDualfarkas(VectorBase<R>& vector) const;
-
-   /// print display line of flying table
-   virtual void printDisplayLine(const bool force = false, const bool forceHead = false);
-
-   /// Termination criterion.
-   /** This method is called in each Simplex iteration to determine, if
-    *  the algorithm is to terminate. In this case a nonzero value is
-    *  returned.
-    *
-    *  This method is declared virtual to allow for implementation of
-    *  other stopping criteria or using it as callback method within the
-    *  Simplex loop, by overriding the method in a derived class.
-    *  However, all implementations must terminate with the
-    *  statement \c return SPxSolverBase<R>::#terminate(), if no own termination
-    *  criteria is encountered.
-    *
-    *  Note, that the Simplex loop stopped even when #terminate()
-    *  returns 0, if the LP has been solved to optimality (i.e. no
-    *  further pricing succeeds and no shift is present).
-    */
-   virtual bool terminate();
-   ///@}
-
-   //-----------------------------
-   /**@name Control Parameters */
-   ///@{
-   /// values \f$|x| < \epsilon\f$ are considered to be 0.
-   /** if you want another value for epsilon, use
-    * \ref soplex::Param::setEpsilon() "Param::setEpsilon()".
-    */
-   R epsilon() const
-   {
-      return primVec.delta().getEpsilon();
-   }
-   /// feasibility tolerance maintained by ratio test during ENTER algorithm.
-   R entertol() const
-   {
-      assert(m_entertol > 0.0);
-
-      return m_entertol;
-   }
-   /// feasibility tolerance maintained by ratio test during LEAVE algorithm.
-   R leavetol() const
-   {
-      assert(m_leavetol > 0.0);
-
-      return m_leavetol;
-   }
-   /// allowed primal feasibility tolerance.
-   R feastol() const
-   {
-      assert(m_entertol > 0.0);
-      assert(m_leavetol > 0.0);
-
-      return theRep == COLUMN ? m_entertol : m_leavetol;
-   }
-   /// allowed optimality, i.e., dual feasibility tolerance.
-   R opttol() const
-   {
-      assert(m_entertol > 0.0);
-      assert(m_leavetol > 0.0);
-
-      return theRep == COLUMN ? m_leavetol : m_entertol;
-   }
-   /// guaranteed primal and dual bound violation for optimal solution, returning the maximum of feastol() and opttol(), i.e., the less tight tolerance.
-   R delta() const
-   {
-      assert(m_entertol > 0.0);
-      assert(m_leavetol > 0.0);
-
-      return m_entertol > m_leavetol ? m_entertol : m_leavetol;
-   }
-   /// set parameter \p feastol.
-   void setFeastol(R d);
-   /// set parameter \p opttol.
-   void setOpttol(R d);
-   /// set parameter \p delta, i.e., set \p feastol and \p opttol to same value.
-   void setDelta(R d);
-   /// set timing type
-   void setTiming(Timer::TYPE ttype)
-   {
-      theTime = TimerFactory::switchTimer(theTime, ttype);
-      multTimeSparse = TimerFactory::switchTimer(multTimeSparse, ttype);
-      multTimeFull = TimerFactory::switchTimer(multTimeFull, ttype);
-      multTimeColwise = TimerFactory::switchTimer(multTimeColwise, ttype);
-      multTimeUnsetup = TimerFactory::switchTimer(multTimeUnsetup, ttype);
-      timerType = ttype;
-   }
-
-   /// set timing type
-   Timer::TYPE getTiming()
-   {
-      assert(timerType == theTime->type());
-      assert(timerType == multTimeSparse->type());
-      assert(timerType == multTimeFull->type());
-      assert(timerType == multTimeColwise->type());
-      assert(timerType == multTimeUnsetup->type());
-      return timerType;
-   }
-
-   /// set display frequency
-   void setDisplayFreq(int freq)
-   {
-      displayFreq = freq;
-   }
-
-   /// get display frequency
-   int getDisplayFreq()
-   {
-      return displayFreq;
-   }
-
-   /// print basis metric within the usual output
-   void setMetricInformation(int type)
-   {
-      printBasisMetric = type;
-   }
-
-   // enable sparse pricing when viols < fac * dim()
-   void setSparsePricingFactor(R fac)
-   {
-      sparsePricingFactor = fac;
-   }
-   /// enable or disable hyper sparse pricing
-   void hyperPricing(bool h);
-
-   /** SPxSolverBase considers a Simplex step as degenerate if the
-    *  steplength does not exceed #epsilon(). Cycling occurs if only
-    *  degenerate steps are taken. To prevent this situation, SPxSolverBase
-    *  perturbs the problem such that nondegenerate steps are ensured.
-    *
-    *  maxCycle() controls how agressive such perturbation is
-    *  performed, since no more than maxCycle() degenerate steps are
-    *  accepted before perturbing the LP. The current number of consecutive
-    *  degenerate steps is counted by numCycle().
-    */
-   /// maximum number of degenerate simplex steps before we detect cycling.
-   int maxCycle() const
-   {
-      return m_maxCycle;
-   }
-   /// actual number of degenerate simplex steps encountered so far.
-   int numCycle() const
-   {
-      return m_numCycle;
-   }
-
-   /// perturb entire problem or only the bounds relevant to the current pivot
-   void useFullPerturbation(bool full)
-   {
-      fullPerturbation = full;
-   }
-
-   virtual R getBasisMetric(int type)
-   {
-      return basis().getMatrixMetric(type);
-   }
-
-   ///@}
+  /** For the leaving Simplex algorithm this vector contains the indices of
+   * infeasible basic variables; for the entering Simplex algorithm this vector
+   * contains the indices of infeasible slack variables.
+   */
+  DIdxSet infeasibilities;
+  /**For the entering Simplex algorithm these vectors contains the indices of
+   * infeasible basic variables.
+   */
+  DIdxSet infeasibilitiesCo;
 
-private:
+  /// store indices that were changed in the previous iteration and must be
+  /// checked in hyper pricing
+  DIdxSet updateViols;
+  DIdxSet updateViolsCo;
 
-   //-----------------------------
-   /**@name Private helpers */
-   ///@{
-   ///
-   void localAddRows(int start);
-   ///
-   void localAddCols(int start);
-   ///
-   void setPrimal(VectorBase<R>& p_vector);
-   ///
-   void setSlacks(VectorBase<R>& p_vector);
-   ///
-   void setDual(VectorBase<R>& p_vector);
-   ///
-   void setRedCost(VectorBase<R>& p_vector);
-   ///@}
+  /** Binary vectors to store whether basic indices are infeasible
+   *  the i-th entry equals false, if the i-th basic variable is not infeasible
+   *  the i-th entry equals true, if the i-th basic variable is infeasible
+   */
+  DataArray<int> isInfeasible; ///< 0: index not violated, 1: index violated, 2:
+                               ///< index violated and among candidate list
+  DataArray<int> isInfeasibleCo; ///< 0: index not violated, 1: index violated,
+                                 ///< 2: index violated and among candidate list
+
+  /// These values enable or disable sparse pricing
+  bool sparsePricingLeave;   ///< true if sparsePricing is turned on in the
+                             ///< leaving Simplex
+  bool sparsePricingEnter;   ///< true if sparsePricing is turned on in the
+                             ///< entering Simplex for slack variables
+  bool sparsePricingEnterCo; ///< true if sparsePricing is turned on in the
+                             ///< entering Simplex
+  bool hyperPricingLeave; ///< true if hyper sparse pricing is turned on in the
+                          ///< leaving Simplex
+  bool hyperPricingEnter; ///< true if hyper sparse pricing is turned on in the
+                          ///< entering Simplex
+
+  int remainingRoundsLeave; ///< number of dense rounds/refactorizations until
+                            ///< sparsePricing is enabled again
+  int remainingRoundsEnter;
+  int remainingRoundsEnterCo;
+
+  /// dual pricing norms
+  VectorBase<R> weights;   ///< store dual norms
+  VectorBase<R> coWeights; ///< store dual norms
+  bool weightsAreSetup;    ///< are the dual norms already set up?
+
+  Timer *multTimeSparse;  ///< time spent in setupPupdate() exploiting sparsity
+  Timer *multTimeFull;    ///< time spent in setupPupdate() ignoring sparsity
+  Timer *multTimeColwise; ///< time spent in setupPupdate(), columnwise
+                          ///< multiplication
+  Timer *multTimeUnsetup; ///< time spent in setupPupdate() w/o sparsity
+                          ///< information
+  int multSparseCalls;    ///< number of products exploiting sparsity
+  int multFullCalls;      ///< number of products ignoring sparsity
+  int multColwiseCalls;   ///< number of products, columnwise multiplication
+  int multUnsetupCalls;   ///< number of products w/o sparsity information
+
+  SPxOut *spxout; ///< message handler
+
+  DataArray<int> integerVariables; ///< supplementary variable information, 0:
+                                   ///< continous variable, 1: integer variable
+
+  //-----------------------------
+  void setOutstream(SPxOut &newOutstream) {
+    spxout = &newOutstream;
+    SPxLPBase<R>::spxout = &newOutstream;
+  }
+
+  /// set refactor threshold for nonzeros in last factorized basis matrix
+  /// compared to updated basis matrix
+  void setNonzeroFactor(R f) { SPxBasisBase<R>::nonzeroFactor = f; }
+
+  /// set refactor threshold for fill-in in current factor update compared to
+  /// fill-in in last factorization
+  void setFillFactor(R f) { SPxBasisBase<R>::fillFactor = f; }
+
+  /// set refactor threshold for memory growth in current factor update compared
+  /// to the last factorization
+  void setMemFactor(R f) { SPxBasisBase<R>::memFactor = f; }
+
+  /**@name Access */
+  ///@{
+  /// return the version of SPxSolverBase as number like 123 for 1.2.3
+  int version() const { return SOPLEX_VERSION; }
+  /// return the internal subversion of SPxSolverBase as number
+  int subversion() const { return SOPLEX_SUBVERSION; }
+  /// return the current basis representation.
+  Representation rep() const { return theRep; }
+
+  /// return current Type.
+  Type type() const { return theType; }
+
+  /// return current Pricing.
+  Pricing pricing() const { return thePricing; }
+
+  /// return current starter.
+  SPxStarter<R> *starter() const { return thestarter; }
+  ///@}
+
+  //-----------------------------
+  /**@name Setup
+   *  Before solving an LP with an instance of SPxSolverBase,
+   *  the following steps must be performed:
+   *
+   *  -# Load the LP by copying an external LP or reading it from an
+   *     input stream.
+   *  -# Setup the pricer to use by loading an \ref soplex::SPxPricer
+   *     "SPxPricer" object (if not already done in a previous call).
+   *  -# Setup the ratio test method to use by loading an
+   *     \ref soplex::SPxRatioTester "SPxRatioTester" object
+   *     (if not already done in a previous call).
+   *  -# Setup the linear system solver to use by loading an
+   *     \ref soplex::SLinSolver "SLinSolver" object
+   *     (if not already done in a previous call).
+   *  -# Optionally setup an start basis generation method by loading an
+   *     \ref soplex::SPxStarter "SPxStarter" object.
+   *  -# Optionally setup a start basis by loading a
+   *     \ref soplex::SPxBasisBase<R>::Desc "SPxBasisBase<R>::Desc" object.
+   *  -# Optionally switch to another basis
+   *     \ref soplex::SPxSolverBase<R>::Representation "Representation"
+   *     by calling method \ref soplex::SPxSolverBase<R>::setRep() "setRep()".
+   *  -# Optionally switch to another algorithm
+   *     \ref soplex::SPxSolverBase<R>::Type "Type"
+   *     by calling method \ref soplex::SPxSolverBase<R>::setType() "setType()".
+   *
+   *  Now the solver is ready for execution. If the loaded LP is to be solved
+   *  again from scratch, this can be done with method
+   *  \ref soplex::SPxSolverBase<R>::reLoad() "reLoad()". Finally,
+   *  \ref soplex::SPxSolverBase<R>::clear() "clear()" removes the LP from the
+   * solver.
+   */
+  ///@{
+  /// read LP from input stream.
+  virtual bool read(std::istream &in, NameSet *rowNames = 0,
+                    NameSet *colNames = 0, DIdxSet *intVars = 0);
+
+  /// copy LP.
+  virtual void loadLP(const SPxLPBase<R> &LP, bool initSlackBasis = true);
+  /// setup linear solver to use. If \p destroy is true, \p slusolver will be
+  /// freed in destructor.
+  virtual void setBasisSolver(SLinSolver<R> *slu, const bool destroy = false);
+  /// setup pricer to use. If \p destroy is true, \p pricer will be freed in
+  /// destructor.
+  virtual void setPricer(SPxPricer<R> *pricer, const bool destroy = false);
+  /// setup ratio-tester to use. If \p destroy is true, \p tester will be freed
+  /// in destructor.
+  virtual void setTester(SPxRatioTester<R> *tester, const bool destroy = false);
+  /// setup starting basis generator to use. If \p destroy is true, \p starter
+  /// will be freed in destructor.
+  virtual void setStarter(SPxStarter<R> *starter, const bool destroy = false);
+  /// set a start basis.
+  virtual void loadBasis(const typename SPxBasisBase<R>::Desc &);
+
+  /// initialize #ROW or #COLUMN representation.
+  void initRep(Representation p_rep);
+  /// switch to #ROW or #COLUMN representation if not already used.
+  void setRep(Representation p_rep);
+  /// set \ref soplex::SPxSolverBase<R>::LEAVE "LEAVE" or \ref
+  /// soplex::SPxSolverBase<R>::ENTER "ENTER" algorithm.
+  void setType(Type tp);
+  /// set \ref soplex::SPxSolverBase<R>::FULL "FULL" or \ref
+  /// soplex::SPxSolverBase<R>::PARTIAL "PARTIAL" pricing.
+  void setPricing(Pricing pr);
+  /// turn on or off the improved dual simplex.
+  void setDecompStatus(DecompStatus decomp_stat);
+
+  /// reload LP.
+  virtual void reLoad();
+
+  /// clear all data in solver.
+  virtual void clear();
+
+  /// unscales the LP and reloads the basis
+  void unscaleLPandReloadBasis();
+
+  /// invalidates the basis, triggers refactorization
+  void invalidateBasis();
+
+  /** Load basis from \p filename in MPS format. If \p rowNames and \p
+   *  colNames are \c NULL, default names are used for the constraints and
+   *  variables.
+   */
+  virtual bool readBasisFile(const char *filename, const NameSet *rowNames,
+                             const NameSet *colNames);
 
-protected:
+  /** Write basis to \p filename in MPS format. If \p rowNames and \p
+   *  colNames are \c NULL, default names are used for the constraints and
+   *  variables.
+   */
+  virtual bool writeBasisFile(const char *filename, const NameSet *rowNames,
+                              const NameSet *colNames,
+                              const bool cpxFormat = false) const;
+
+  /** Write current LP, basis, and parameter settings.
+   *  LP is written in MPS format to "\p filename".mps, basis is written in "\p
+   * filename".bas, and parameters are written to "\p filename".set. If \p
+   * rowNames and \p colNames are \c NULL, default names are used for the
+   * constraints and variables.
+   */
+  virtual bool writeState(const char *filename, const NameSet *rowNames = NULL,
+                          const NameSet *colNames = NULL,
+                          const bool cpxFormat = false) const;
+
+  ///@}
+
+  /**@name Solving LPs */
+  ///@{
+  /// solve loaded LP.
+  /** Solves the loaded LP by processing the Simplex iteration until
+   *  the termination criteria is fullfilled (see #terminate()).
+   *  The SPxStatus of the solver will indicate the reason for termination.
+   *
+   *  @throw SPxStatusException if either no problem, solver, pricer
+   *  or ratiotester loaded or if solve is still running when it shouldn't be
+   */
+  virtual Status solve(volatile bool *interrupt = NULL);
 
-   //-----------------------------
-   /**@name Protected helpers */
-   ///@{
-   ///
-   virtual void addedRows(int n);
-   ///
-   virtual void addedCols(int n);
-   ///
-   virtual void doRemoveRow(int i);
-   ///
-   virtual void doRemoveRows(int perm[]);
-   ///
-   virtual void doRemoveCol(int i);
-   ///
-   virtual void doRemoveCols(int perm[]);
-   ///@}
+  /** Identify primal basic variables that have zero reduced costs and
+   * try to pivot them out of the basis to make them tight.
+   * This is supposed to decrease the number of fractional variables
+   * when solving LP relaxations of (mixed) integer programs.
+   * The objective must not be modified during this procedure.
+   */
+  void performSolutionPolishing();
 
-public:
+  /// set objective of solution polishing (0: off, 1: max_basic_slack, 2:
+  /// min_basic_slack)
+  void setSolutionPolishing(SolutionPolish _polishObj) {
+    polishObj = _polishObj;
+  }
 
-   //-----------------------------
-   /**@name Modification */
-   /// \p scale determines whether the new data needs to be scaled according to the existing LP (persistent scaling)
-   ///@{
-   ///
-   virtual void changeObj(const VectorBase<R>& newObj, bool scale = false);
-   ///
-   virtual void changeObj(int i, const R& newVal, bool scale = false);
-   ///
-   using SPxLPBase<R>::changeObj; /// overloading a virtual function
-   virtual void changeObj(SPxColId p_id, const R& p_newVal, bool scale = false)
-   {
-      changeObj(this->number(p_id), p_newVal, scale);
-   }
-   ///
-   virtual void changeMaxObj(const VectorBase<R>& newObj, bool scale = false);
-   ///
-   virtual void changeMaxObj(int i, const R& newVal, bool scale = false);
-   ///
-   using SPxLPBase<R>::changeMaxObj; /// overloading a virtual function
-   virtual void changeMaxObj(SPxColId p_id, const R& p_newVal, bool scale = false)
-   {
-      changeMaxObj(this->number(p_id), p_newVal, scale);
-   }
-   ///
-   virtual void changeRowObj(const VectorBase<R>& newObj, bool scale = false);
-   ///
-   virtual void changeRowObj(int i, const R& newVal, bool scale = false);
-   ///
-   using SPxLPBase<R>::changeRowObj;
-   virtual void changeRowObj(SPxRowId p_id, const R& p_newVal, bool scale = false)
-   {
-      changeRowObj(this->number(p_id), p_newVal);
-   }
-   ///
-   virtual void clearRowObjs()
-   {
-      SPxLPBase<R>::clearRowObjs();
-      unInit();
-   }
-   ///
-   virtual void changeLowerStatus(int i, R newLower, R oldLower = 0.0);
-   ///
-   virtual void changeLower(const VectorBase<R>& newLower, bool scale = false);
-   ///
-   virtual void changeLower(int i, const R& newLower, bool scale = false);
-   ///
-   using SPxLPBase<R>::changeLower;
-   virtual void changeLower(SPxColId p_id, const R& p_newLower, bool scale = false)
-   {
-      changeLower(this->number(p_id), p_newLower, scale);
-   }
-   ///
-   virtual void changeUpperStatus(int i, R newUpper, R oldLower = 0.0);
-   ///
-   virtual void changeUpper(const VectorBase<R>& newUpper, bool scale = false);
-   ///
-   virtual void changeUpper(int i, const R& newUpper, bool scale = false);
-   ///
-   using SPxLPBase<R>::changeUpper; /// overloading virtual function
-   virtual void changeUpper(SPxColId p_id, const R& p_newUpper, bool scale = false)
-   {
-      changeUpper(this->number(p_id), p_newUpper, scale);
-   }
-   ///
-   virtual void changeBounds(const VectorBase<R>& newLower, const VectorBase<R>& newUpper,
-                             bool scale = false);
-   ///
-   virtual void changeBounds(int i, const R& newLower, const R& newUpper, bool scale = false);
-   ///
-   using SPxLPBase<R>::changeBounds;
-   virtual void changeBounds(SPxColId p_id, const R& p_newLower, const R& p_newUpper,
-                             bool scale = false)
-   {
-      changeBounds(this->number(p_id), p_newLower, p_newUpper, scale);
-   }
-   ///
-   virtual void changeLhsStatus(int i, R newLhs, R oldLhs = 0.0);
-   ///
-   virtual void changeLhs(const VectorBase<R>& newLhs, bool scale = false);
-   ///
-   virtual void changeLhs(int i, const R& newLhs, bool scale = false);
-   ///
-   using SPxLPBase<R>::changeLhs;
-   virtual void changeLhs(SPxRowId p_id, const R& p_newLhs, bool scale = false)
-   {
-      changeLhs(this->number(p_id), p_newLhs, scale);
-   }
-   ///
-   virtual void changeRhsStatus(int i, R newRhs, R oldRhs = 0.0);
-   ///
-   virtual void changeRhs(const VectorBase<R>& newRhs, bool scale = false);
-   ///
-   virtual void changeRhs(int i, const R& newRhs, bool scale = false);
-   ///
-   using SPxLPBase<R>::changeRhs;
-   virtual void changeRhs(SPxRowId p_id, const R& p_newRhs, bool scale = false)
-   {
-      changeRhs(this->number(p_id), p_newRhs, scale);
-   }
-   ///
-   virtual void changeRange(const VectorBase<R>& newLhs, const VectorBase<R>& newRhs,
-                            bool scale = false);
-   ///
-   virtual void changeRange(int i, const R& newLhs, const R& newRhs, bool scale = false);
-   ///
-   using SPxLPBase<R>::changeRange;
-   virtual void changeRange(SPxRowId p_id, const R& p_newLhs, const R& p_newRhs, bool scale = false)
-   {
-      changeRange(this->number(p_id), p_newLhs, p_newRhs, scale);
-   }
-   ///
-   virtual void changeRow(int i, const LPRowBase<R>& newRow, bool scale = false);
-   ///
-   using SPxLPBase<R>::changeRow;
-   virtual void changeRow(SPxRowId p_id, const LPRowBase<R>& p_newRow, bool scale = false)
-   {
-      changeRow(this->number(p_id), p_newRow, scale);
-   }
-   ///
-   virtual void changeCol(int i, const LPColBase<R>& newCol, bool scale = false);
-   ///
-   using SPxLPBase<R>::changeCol;
-   virtual void changeCol(SPxColId p_id, const LPColBase<R>& p_newCol, bool scale = false)
-   {
-      changeCol(this->number(p_id), p_newCol, scale);
-   }
-   ///
-   virtual void changeElement(int i, int j, const R& val, bool scale = false);
-   ///
-   using SPxLPBase<R>::changeElement;
-   virtual void changeElement(SPxRowId rid, SPxColId cid, const R& val, bool scale = false)
-   {
-      changeElement(this->number(rid), this->number(cid), val, scale);
-   }
-   ///
-   virtual void changeSense(typename SPxLPBase<R>::SPxSense sns);
-   ///@}
-
-   //------------------------------------
-   /**@name Dimension and codimension */
-   ///@{
-   /// dimension of basis matrix.
-   int dim() const
-   {
-      return thecovectors->num();
-   }
-   /// codimension.
-   int coDim() const
-   {
-      return thevectors->num();
-   }
-   ///@}
-
-   //------------------------------------
-   /**@name Variables and Covariables
-    *  Class SPxLPBase<R> introduces \ref soplex::SPxId "SPxIds" to identify
-    *  row or column data of an LP. SPxSolverBase uses this concept to
-    *  access data with respect to the chosen representation.
-    */
-   ///@{
-   /// id of \p i 'th vector.
-   /** The \p i 'th Id is the \p i 'th SPxRowId for a rowwise and the
-    *  \p i 'th SPxColId for a columnwise basis represenation. Hence,
-    *  0 <= i < #coDim().
-    */
-   SPxId id(int i) const
-   {
-      if(rep() == ROW)
-      {
-         SPxRowId rid = SPxLPBase<R>::rId(i);
-         return SPxId(rid);
-      }
-      else
-      {
-         SPxColId cid = SPxLPBase<R>::cId(i);
-         return SPxId(cid);
-      }
-   }
-
-   /// id of \p i 'th covector.
-   /** The \p i 'th #coId() is the \p i 'th SPxColId for a rowwise and the
-    *  \p i 'th SPxRowId for a columnwise basis represenation. Hence,
-    *  0 <= i < #dim().
-    */
-   SPxId coId(int i) const
-   {
-      if(rep() == ROW)
-      {
-         SPxColId cid = SPxLPBase<R>::cId(i);
-         return SPxId(cid);
-      }
-      else
-      {
-         SPxRowId rid = SPxLPBase<R>::rId(i);
-         return SPxId(rid);
-      }
-   }
-
-   /// Is \p p_id an SPxId ?
-   /** This method returns wheather or not \p p_id identifies a vector
-    *  with respect to the chosen representation.
-    */
-   bool isId(const SPxId& p_id) const
-   {
-      return p_id.info * theRep > 0;
-   }
-
-   /// Is \p p_id a CoId.
-   /** This method returns wheather or not \p p_id identifies a coVector
-    *  with respect to the chosen representation.
-    */
-   bool isCoId(const SPxId& p_id) const
-   {
-      return p_id.info * theRep < 0;
-   }
-   ///@}
-
-   //------------------------------------
-   /**@name Vectors and Covectors */
-   ///@{
-   /// \p i 'th vector.
-   /**@return a reference to the \p i 'th, 0 <= i < #coDim(), vector of
-    *         the loaded LP (with respect to the chosen representation).
-    */
-   const SVectorBase<R>& vector(int i) const
-   {
-      return (*thevectors)[i];
-   }
-
-   ///
-   const SVectorBase<R>& vector(const SPxRowId& rid) const
-   {
-      assert(rid.isValid());
-      return (rep() == ROW)
-             ? (*thevectors)[this->number(rid)]
-             : static_cast<const SVectorBase<R>&>(unitVecs[this->number(rid)]);
-   }
-   ///
-   const SVectorBase<R>& vector(const SPxColId& cid) const
-   {
-      assert(cid.isValid());
-      return (rep() == COLUMN)
-             ? (*thevectors)[this->number(cid)]
-             : static_cast<const SVectorBase<R>&>(unitVecs[this->number(cid)]);
-   }
-
-   /// VectorBase<R> associated to \p p_id.
-   /**@return Returns a reference to the VectorBase<R> of the loaded LP corresponding
-    *  to \p id (with respect to the chosen representation). If \p p_id is
-    *  an id, a vector of the constraint matrix is returned, otherwise
-    *  the corresponding unit vector (of the slack variable or bound
-    *  inequality) is returned.
-    *  @todo The implementation does not exactly look like it will do
-    *        what is promised in the describtion.
-    */
-   const SVectorBase<R>& vector(const SPxId& p_id) const
-   {
-      assert(p_id.isValid());
-
-      return p_id.isSPxRowId()
-             ? vector(SPxRowId(p_id))
-             : vector(SPxColId(p_id));
-   }
-
-   /// \p i 'th covector of LP.
-   /**@return a reference to the \p i 'th, 0 <= i < #dim(), covector of
-    *  the loaded LP (with respect to the chosen representation).
-    */
-   const SVectorBase<R>& coVector(int i) const
-   {
-      return (*thecovectors)[i];
-   }
-   ///
-   const SVectorBase<R>& coVector(const SPxRowId& rid) const
-   {
-      assert(rid.isValid());
-      return (rep() == COLUMN)
-             ? (*thecovectors)[this->number(rid)]
-             : static_cast<const SVector&>(unitVecs[this->number(rid)]);
-   }
-   ///
-   const SVectorBase<R>& coVector(const SPxColId& cid) const
-   {
-      assert(cid.isValid());
-      return (rep() == ROW)
-             ? (*thecovectors)[this->number(cid)]
-             : static_cast<const SVectorBase<R>&>(unitVecs[this->number(cid)]);
-   }
-   /// coVector associated to \p p_id.
-   /**@return a reference to the covector of the loaded LP
-    *  corresponding to \p p_id (with respect to the chosen
-    *  representation). If \p p_id is a coid, a covector of the constraint
-    *  matrix is returned, otherwise the corresponding unit vector is
-    *  returned.
-    */
-   const SVectorBase<R>& coVector(const SPxId& p_id) const
-   {
-      assert(p_id.isValid());
-      return p_id.isSPxRowId()
-             ? coVector(SPxRowId(p_id))
-             : coVector(SPxColId(p_id));
-   }
-   /// return \p i 'th unit vector.
-   const SVectorBase<R>& unitVector(int i) const
-   {
-      return unitVecs[i];
-   }
-   ///@}
-
-   //------------------------------------
-   /**@name Variable status
-    *  The Simplex basis assigns a \ref soplex::SPxBasisBase<R>::Desc::Status
-    *  "Status" to each variable and covariable. Depending on the
-    *  representation, the status indicates that the corresponding
-    *  vector is in the basis matrix or not.
-    */
-   ///@{
-   /// Status of \p i 'th variable.
-   typename SPxBasisBase<R>::Desc::Status varStatus(int i) const
-   {
-      return this->desc().status(i);
-   }
-
-   /// Status of \p i 'th covariable.
-   typename SPxBasisBase<R>::Desc::Status covarStatus(int i) const
-   {
-      return this->desc().coStatus(i);
-   }
-
-   /// does \p stat describe a basic index ?
-   bool isBasic(typename SPxBasisBase<R>::Desc::Status stat) const
-   {
-      return (stat * rep() > 0);
-   }
-
-   /// is the \p p_id 'th vector basic ?
-   bool isBasic(const SPxId& p_id) const
-   {
-      assert(p_id.isValid());
-      return p_id.isSPxRowId()
-             ? isBasic(SPxRowId(p_id))
-             : isBasic(SPxColId(p_id));
-   }
-
-   /// is the \p rid 'th vector basic ?
-   bool isBasic(const SPxRowId& rid) const
-   {
-      return isBasic(this->desc().rowStatus(this->number(rid)));
-   }
-
-   /// is the \p cid 'th vector basic ?
-   bool isBasic(const SPxColId& cid) const
-   {
-      return isBasic(this->desc().colStatus(this->number(cid)));
-   }
-
-   /// is the \p i 'th row vector basic ?
-   bool isRowBasic(int i) const
-   {
-      return isBasic(this->desc().rowStatus(i));
-   }
-
-   /// is the \p i 'th column vector basic ?
-   bool isColBasic(int i) const
-   {
-      return isBasic(this->desc().colStatus(i));
-   }
-
-   /// is the \p i 'th vector basic ?
-   bool isBasic(int i) const
-   {
-      return isBasic(this->desc().status(i));
-   }
-
-   /// is the \p i 'th covector basic ?
-   bool isCoBasic(int i) const
-   {
-      return isBasic(this->desc().coStatus(i));
-   }
-   ///@}
-
-   /// feasibility vector.
-   /** This method return the \em feasibility vector. If it satisfies its
-    *  bound, the basis is called feasible (independently of the chosen
-    *  representation). The feasibility vector has dimension #dim().
-    *
-    *  For the entering Simplex, #fVec is kept within its bounds. In
-    *  contrast to this, the pricing of the leaving Simplex selects an
-    *  element of #fVec, that violates its bounds.
-    */
-   UpdateVector<R>& fVec() const
-   {
-      return *theFvec;
-   }
-   /// right-hand side vector for \ref soplex::SPxSolverBase<R>::fVec "fVec"
-   /** The feasibility vector is computed by solving a linear system with the
-    *  basis matrix. The right-hand side vector of this system is referred
-    *  to as \em feasibility, \em right-hand \em side \em vector #fRhs().
-    *
-    *  For a row basis, #fRhs() is the objective vector (ignoring shifts).
-    *  For a column basis, it is the sum of all nonbasic vectors scaled by
-    *  the factor of their bound.
-    */
-   const VectorBase<R>& fRhs() const
-   {
-      return *theFrhs;
-   }
-   /// upper bound for \ref soplex::SPxSolverBase<R>::fVec "fVec".
-   const VectorBase<R>& ubBound() const
-   {
-      return theUBbound;
-   }
-   /// upper bound for #fVec, writable.
-   /** This method returns the upper bound for the feasibility vector.
-    *  It may only be called for the #ENTER%ing Simplex.
-    *
-    *  For the #ENTER%ing Simplex algorithms, the feasibility vector is
-    *  maintained to fullfill its bounds. As #fVec itself, also its
-    *  bounds depend on the chosen representation. Further, they may
-    *  need to be shifted (see below).
-    */
-   VectorBase<R>& ubBound()
-   {
-      return theUBbound;
-   }
-   /// lower bound for \ref soplex::SPxSolverBase<R>::fVec "fVec".
-   const VectorBase<R>& lbBound() const
-   {
-      return theLBbound;
-   }
-   /// lower bound for #fVec, writable.
-   /** This method returns the lower bound for the feasibility vector.
-    *  It may only be called for the #ENTER%ing Simplex.
-    *
-    *  For the #ENTER%ing Simplex algorithms, the feasibility vector is
-    *  maintained to fullfill its bounds. As #fVec itself, also its
-    *  bound depend on the chosen representation. Further, they may
-    *  need to be shifted (see below).
-    */
-   VectorBase<R>& lbBound()
-   {
-      return theLBbound;
-   }
-
-   /// Violations of \ref soplex::SPxSolverBase<R>::fVec "fVec"
-   /** For the leaving Simplex algorithm, pricing involves selecting a
-    *  variable from #fVec that violates its bounds that is to leave
-    *  the basis. When a SPxPricer is called to select such a
-    *  leaving variable, #fTest() contains the vector of violations:
-    *  For #fTest()[i] < 0, the \c i 'th basic variable violates one of
-    *  its bounds by the given value. Otherwise no bound is violated.
-    */
-   const VectorBase<R>& fTest() const
-   {
-      assert(type() == LEAVE);
-      return theCoTest;
-   }
-
-   /// copricing vector.
-   /** The copricing vector #coPvec along with the pricing vector
-    *  #pVec are used for pricing in the #ENTER%ing Simplex algorithm,
-    *  i.e. one variable is selected, that violates its bounds. In
-    *  contrast to this, the #LEAVE%ing Simplex algorithm keeps both
-    *  vectors within their bounds.
-    */
-   UpdateVector<R>& coPvec() const
-   {
-      return *theCoPvec;
-   }
-
-   /// Right-hand side vector for \ref soplex::SPxSolverBase<R>::coPvec "coPvec".
-   /** The vector #coPvec is computed by solving a linear system with the
-    *  basis matrix and #coPrhs as the right-hand side vector. For
-    *  column basis representation, #coPrhs is build up of the
-    *  objective vector elements of all basic variables. For a row
-    *  basis, it consists of the tight bounds of all basic
-    *  constraints.
-    */
-   const VectorBase<R>& coPrhs() const
-   {
-      return *theCoPrhs;
-   }
-
-   ///
-   const VectorBase<R>& ucBound() const
-   {
-      assert(theType == LEAVE);
-      return *theCoUbound;
-   }
-   /// upper bound for #coPvec.
-   /** This method returns the upper bound for #coPvec. It may only be
-    *  called for the leaving Simplex algorithm.
-    *
-    *  For the leaving Simplex algorithms #coPvec is maintained to
-    *  fullfill its bounds. As #coPvec itself, also its bound depend
-    *  on the chosen representation. Further, they may need to be
-    *  shifted (see below).
-    */
-   VectorBase<R>& ucBound()
-   {
-      assert(theType == LEAVE);
-      return *theCoUbound;
-   }
-
-   ///
-   const VectorBase<R>& lcBound() const
-   {
-      assert(theType == LEAVE);
-      return *theCoLbound;
-   }
-   /// lower bound for #coPvec.
-   /** This method returns the lower bound for #coPvec. It may only be
-    *  called for the leaving Simplex algorithm.
-    *
-    *  For the leaving Simplex algorithms #coPvec is maintained to
-    *  fullfill its bounds. As #coPvec itself, also its bound depend
-    *  on the chosen representation. Further, they may need to be
-    *  shifted (see below).
-    */
-   VectorBase<R>& lcBound()
-   {
-      assert(theType == LEAVE);
-      return *theCoLbound;
-   }
-
-   /// violations of \ref soplex::SPxSolverBase<R>::coPvec "coPvec".
-   /** In entering Simplex pricing selects checks vectors #coPvec()
-    *  and #pVec() for violation of its bounds. #coTest() contains
-    *  the violations for #coPvec() which are indicated by a negative
-    *  value. That is, if #coTest()[i] < 0, the \p i 'th element of #coPvec()
-    *  is violated by -#coTest()[i].
-    */
-   const VectorBase<R>& coTest() const
-   {
-      assert(type() == ENTER);
-      return theCoTest;
-   }
-   /// pricing vector.
-   /** The pricing vector #pVec is the product of #coPvec with the
-    *  constraint matrix. As #coPvec, also #pVec is maintained within
-    *  its bound for the leaving Simplex algorithm, while the bounds
-    *  are tested for the entering Simplex. #pVec is of dimension
-    *  #coDim(). Vector #pVec() is only up to date for #LEAVE%ing
-    *  Simplex or #FULL pricing in #ENTER%ing Simplex.
-    */
-   UpdateVector<R>& pVec() const
-   {
-      return *thePvec;
-   }
-   ///
-   const VectorBase<R>& upBound() const
-   {
-      assert(theType == LEAVE);
-      return *theUbound;
-   }
-   /// upper bound for #pVec.
-   /** This method returns the upper bound for #pVec. It may only be
-    *  called for the leaving Simplex algorithm.
-    *
-    *  For the leaving Simplex algorithms #pVec is maintained to
-    *  fullfill its bounds. As #pVec itself, also its bound depend
-    *  on the chosen representation. Further, they may need to be
-    *  shifted (see below).
-    */
-   VectorBase<R>& upBound()
-   {
-      assert(theType == LEAVE);
-      return *theUbound;
-   }
-
-   ///
-   const VectorBase<R>& lpBound() const
-   {
-      assert(theType == LEAVE);
-      return *theLbound;
-   }
-   /// lower bound for #pVec.
-   /** This method returns the lower bound for #pVec. It may only be
-    *  called for the leaving Simplex algorithm.
-    *
-    *  For the leaving Simplex algorithms #pVec is maintained to
-    *  fullfill its bounds. As #pVec itself, also its bound depend
-    *  on the chosen representation. Further, they may need to be
-    *  shifted (see below).
-    */
-   VectorBase<R>& lpBound()
-   {
-      assert(theType == LEAVE);
-      return *theLbound;
-   }
-
-   /// Violations of \ref soplex::SPxSolverBase<R>::pVec "pVec".
-   /** In entering Simplex pricing selects checks vectors #coPvec()
-    *  and #pVec() for violation of its bounds. Vector #test()
-    *  contains the violations for #pVec(), i.e., if #test()[i] < 0,
-    *  the i'th element of #pVec() is violated by #test()[i].
-    *  Vector #test() is only up to date for #FULL pricing.
-    */
-   const VectorBase<R>& test() const
-   {
-      assert(type() == ENTER);
-      return theTest;
-   }
-
-   /// compute and return \ref soplex::SPxSolverBase<R>::pVec() "pVec()"[i].
-   R computePvec(int i);
-   /// compute entire \ref soplex::SPxSolverBase<R>::pVec() "pVec()".
-   void computePvec();
-   /// compute and return \ref soplex::SPxSolverBase<R>::test() "test()"[i] in \ref soplex::SPxSolverBase<R>::ENTER "ENTER"ing Simplex.
-   R computeTest(int i);
-   /// compute test VectorBase<R> in \ref soplex::SPxSolverBase<R>::ENTER "ENTER"ing Simplex.
-   void computeTest();
-
-   //------------------------------------
-   /**@name Shifting
-    *  The task of the ratio test (implemented in SPxRatioTester classes)
-    *  is to select a variable for the basis update, such that the basis
-    *  remains priced (i.e. both, the pricing and copricing vectors satisfy
-    *  their bounds) or feasible (i.e. the feasibility vector satisfies its
-    *  bounds). However, this can lead to numerically instable basis matrices
-    *  or -- after accumulation of various errors -- even to a singular basis
-    *  matrix.
-    *
-    *  The key to overcome this problem is to allow the basis to become "a
-    *  bit" infeasible or unpriced, in order provide a better choice for the
-    *  ratio test to select a stable variable. This is equivalent to enlarging
-    *  the bounds by a small amount. This is referred to as \em shifting.
-    *
-    *  These methods serve for shifting feasibility bounds, either in order
-    *  to maintain numerical stability or initially for computation of
-    *  phase 1. The sum of all shifts applied to any bound is stored in
-    *  \ref soplex::SPxSolverBase<R>::theShift "theShift".
-    *
-    *  The following methods are used to shift individual bounds. They are
-    *  mainly intended for stable implenentations of SPxRatioTester.
-    */
-   ///@{
-   /// Perform initial shifting to optain an feasible or pricable basis.
-   void shiftFvec();
-   /// Perform initial shifting to optain an feasible or pricable basis.
-   void shiftPvec();
-
-   /// shift \p i 'th \ref soplex::SPxSolver::ubBound "ubBound" to \p to.
-   void shiftUBbound(int i, R to)
-   {
-      assert(theType == ENTER);
-      // use maximum to not count tightened bounds in case of equality shifts
-      theShift += MAXIMUM(to - theUBbound[i], 0.0);
-      theUBbound[i] = to;
-   }
-   /// shift \p i 'th \ref soplex::SPxSolver::lbBound "lbBound" to \p to.
-   void shiftLBbound(int i, R to)
-   {
-      assert(theType == ENTER);
-      // use maximum to not count tightened bounds in case of equality shifts
-      theShift += MAXIMUM(theLBbound[i] - to, 0.0);
-      theLBbound[i] = to;
-   }
-   /// shift \p i 'th \ref soplex::SPxSolver::upBound "upBound" to \p to.
-   void shiftUPbound(int i, R to)
-   {
-      assert(theType == LEAVE);
-      // use maximum to not count tightened bounds in case of equality shifts
-      theShift += MAXIMUM(to - (*theUbound)[i], 0.0);
-      (*theUbound)[i] = to;
-   }
-   /// shift \p i 'th \ref soplex::SPxSolver::lpBound "lpBound" to \p to.
-   void shiftLPbound(int i, R to)
-   {
-      assert(theType == LEAVE);
-      // use maximum to not count tightened bounds in case of equality shifts
-      theShift += MAXIMUM((*theLbound)[i] - to, 0.0);
-      (*theLbound)[i] = to;
-   }
-   /// shift \p i 'th \ref soplex::SPxSolver::ucBound "ucBound" to \p to.
-   void shiftUCbound(int i, R to)
-   {
-      assert(theType == LEAVE);
-      // use maximum to not count tightened bounds in case of equality shifts
-      theShift += MAXIMUM(to - (*theCoUbound)[i], 0.0);
-      (*theCoUbound)[i] = to;
-   }
-   /// shift \p i 'th \ref soplex::SPxSolver::lcBound "lcBound" to \p to.
-   void shiftLCbound(int i, R to)
-   {
-      assert(theType == LEAVE);
-      // use maximum to not count tightened bounds in case of equality shifts
-      theShift += MAXIMUM((*theCoLbound)[i] - to, 0.0);
-      (*theCoLbound)[i] = to;
-   }
-   ///
-   void testBounds() const;
-
-   /// total current shift amount.
-   virtual R shift() const
-   {
-      return theShift;
-   }
-   /// remove shift as much as possible.
-   virtual void unShift(void);
-
-   /// get violation of constraints.
-   virtual void qualConstraintViolation(R& maxviol, R& sumviol) const;
-   /// get violations of bounds.
-   virtual void qualBoundViolation(R& maxviol, R& sumviol) const;
-   /// get the residuum |Ax-b|.
-   virtual void qualSlackViolation(R& maxviol, R& sumviol) const;
-   /// get violation of optimality criterion.
-   virtual void qualRedCostViolation(R& maxviol, R& sumviol) const;
-   ///@}
+  /// return objective of solution polishing
+  SolutionPolish getSolutionPolishing() { return polishObj; }
+
+  /// Status of solution process.
+  Status status() const;
+
+  /// current objective value.
+  /**@return Objective value of the current solution vector
+   *         (see #getPrimalSol()).
+   */
+  virtual R value();
+
+  // update nonbasic part of the objective value by the given amount
+  /**@return whether nonbasic part of objective is reliable
+   */
+  bool updateNonbasicValue(R objChange);
+
+  // trigger a recomputation of the nonbasic part of the objective value
+  void forceRecompNonbasicValue() {
+    m_nonbasicValue = 0.0;
+    m_nonbasicValueUpToDate = false;
+  }
+
+  /// get solution vector for primal variables.
+  /** This method returns the Status of the basis.
+   *  If it is #REGULAR or better,
+   *  the primal solution vector of the current basis will be copied
+   *  to the argument \p vector. Hence, \p vector must be of dimension
+   *  #nCols().
+   *
+   *  @throw SPxStatusException if not initialized
+   */
+  virtual Status getPrimalSol(VectorBase<R> &vector) const;
+
+  /// get VectorBase<R> of slack variables.
+  /** This method returns the Status of the basis.
+   *  If it is #REGULAR or better,
+   *  the slack variables of the current basis will be copied
+   *  to the argument \p vector. Hence, \p VectorBase<R> must be of dimension
+   *  #nRows().
+   *
+   *  @warning Because SPxSolverBase supports range constraints as its
+   *     default, slack variables are defined in a nonstandard way:
+   *     Let \em x be the current solution vector and \em A the constraint
+   *     matrix. Then the vector of slack variables is defined as
+   *     \f$s = Ax\f$.
+   *
+   *  @throw SPxStatusException if no problem loaded
+   */
+  virtual Status getSlacks(VectorBase<R> &vector) const;
+
+  /// get current solution VectorBase<R> for dual variables.
+  /** This method returns the Status of the basis.
+   *  If it is #REGULAR or better,
+   *  the VectorBase<R> of dual variables of the current basis will be copied
+   *  to the argument \p vector. Hence, \p VectorBase<R> must be of dimension
+   *  #nRows().
+   *
+   *  @warning Even though mathematically, each range constraint would
+   *     account for two dual variables (one for each inequaility), only
+   *     #nRows() dual variables are setup via the following
+   *     construction: Given a range constraint, there are three possible
+   *     situations:
+   *     - None of its inequalities is tight: The dual variables
+   *       for both are 0. However, when shifting (see below)
+   *       occurs, it may be set to a value other than 0, which
+   *       models a perturbed objective vector.
+   *     - Both of its inequalities are tight: In this case the
+   *       range constraint models an equality and we adopt the
+   *       standard definition.
+   *     - One of its inequalities is tight while the other is not:
+   *       In this case only the dual variable for the tight
+   *       constraint is given with the standard definition, while
+   *       the other constraint is implicitely set to 0.
+   *
+   *  @throw SPxStatusException if no problem loaded
+   */
+  virtual Status getDualSol(VectorBase<R> &vector) const;
+
+  /// get vector of reduced costs.
+  /** This method returns the Status of the basis.
+   *  If it is #REGULAR or better,
+   *  the vector of reduced costs of the current basis will be copied
+   *  to the argument \p vector. Hence, \p vector must be of dimension
+   *  #nCols().
+   *
+   *  Let \em d denote the vector of dual variables, as defined above,
+   *  and \em A the LPs constraint matrix. Then the reduced cost vector
+   *  \em r is defined as \f$r^T = c^T - d^TA\f$.
+   *
+   *  @throw SPxStatusException if no problem loaded
+   */
+  virtual Status getRedCostSol(VectorBase<R> &vector) const;
+
+  /// get primal ray in case of unboundedness.
+  ///  @throw SPxStatusException if no problem loaded
+  virtual Status getPrimalray(VectorBase<R> &vector) const;
+
+  /// get dual farkas proof of infeasibility.
+  ///  @throw SPxStatusException if no problem loaded
+  virtual Status getDualfarkas(VectorBase<R> &vector) const;
+
+  /// print display line of flying table
+  virtual void printDisplayLine(const bool force = false,
+                                const bool forceHead = false);
+
+  /// Termination criterion.
+  /** This method is called in each Simplex iteration to determine, if
+   *  the algorithm is to terminate. In this case a nonzero value is
+   *  returned.
+   *
+   *  This method is declared virtual to allow for implementation of
+   *  other stopping criteria or using it as callback method within the
+   *  Simplex loop, by overriding the method in a derived class.
+   *  However, all implementations must terminate with the
+   *  statement \c return SPxSolverBase<R>::#terminate(), if no own termination
+   *  criteria is encountered.
+   *
+   *  Note, that the Simplex loop stopped even when #terminate()
+   *  returns 0, if the LP has been solved to optimality (i.e. no
+   *  further pricing succeeds and no shift is present).
+   */
+  virtual bool terminate();
+  ///@}
+
+  //-----------------------------
+  /**@name Control Parameters */
+  ///@{
+  /// values \f$|x| < \epsilon\f$ are considered to be 0.
+  /** if you want another value for epsilon, use
+   * \ref soplex::Param::setEpsilon() "Param::setEpsilon()".
+   */
+  R epsilon() const { return primVec.delta().getEpsilon(); }
+  /// feasibility tolerance maintained by ratio test during ENTER algorithm.
+  R entertol() const {
+    assert(m_entertol > 0.0);
+
+    return m_entertol;
+  }
+  /// feasibility tolerance maintained by ratio test during LEAVE algorithm.
+  R leavetol() const {
+    assert(m_leavetol > 0.0);
+
+    return m_leavetol;
+  }
+  /// allowed primal feasibility tolerance.
+  R feastol() const {
+    assert(m_entertol > 0.0);
+    assert(m_leavetol > 0.0);
+
+    return theRep == COLUMN ? m_entertol : m_leavetol;
+  }
+  /// allowed optimality, i.e., dual feasibility tolerance.
+  R opttol() const {
+    assert(m_entertol > 0.0);
+    assert(m_leavetol > 0.0);
+
+    return theRep == COLUMN ? m_leavetol : m_entertol;
+  }
+  /// guaranteed primal and dual bound violation for optimal solution, returning
+  /// the maximum of feastol() and opttol(), i.e., the less tight tolerance.
+  R delta() const {
+    assert(m_entertol > 0.0);
+    assert(m_leavetol > 0.0);
+
+    return m_entertol > m_leavetol ? m_entertol : m_leavetol;
+  }
+  /// set parameter \p feastol.
+  void setFeastol(R d);
+  /// set parameter \p opttol.
+  void setOpttol(R d);
+  /// set parameter \p delta, i.e., set \p feastol and \p opttol to same value.
+  void setDelta(R d);
+  /// set timing type
+  void setTiming(Timer::TYPE ttype) {
+    theTime = TimerFactory::switchTimer(theTime, ttype);
+    multTimeSparse = TimerFactory::switchTimer(multTimeSparse, ttype);
+    multTimeFull = TimerFactory::switchTimer(multTimeFull, ttype);
+    multTimeColwise = TimerFactory::switchTimer(multTimeColwise, ttype);
+    multTimeUnsetup = TimerFactory::switchTimer(multTimeUnsetup, ttype);
+    timerType = ttype;
+  }
+
+  /// set timing type
+  Timer::TYPE getTiming() {
+    assert(timerType == theTime->type());
+    assert(timerType == multTimeSparse->type());
+    assert(timerType == multTimeFull->type());
+    assert(timerType == multTimeColwise->type());
+    assert(timerType == multTimeUnsetup->type());
+    return timerType;
+  }
+
+  /// set display frequency
+  void setDisplayFreq(int freq) { displayFreq = freq; }
+
+  /// get display frequency
+  int getDisplayFreq() { return displayFreq; }
+
+  /// print basis metric within the usual output
+  void setMetricInformation(int type) { printBasisMetric = type; }
+
+  // enable sparse pricing when viols < fac * dim()
+  void setSparsePricingFactor(R fac) { sparsePricingFactor = fac; }
+  /// enable or disable hyper sparse pricing
+  void hyperPricing(bool h);
+
+  /** SPxSolverBase considers a Simplex step as degenerate if the
+   *  steplength does not exceed #epsilon(). Cycling occurs if only
+   *  degenerate steps are taken. To prevent this situation, SPxSolverBase
+   *  perturbs the problem such that nondegenerate steps are ensured.
+   *
+   *  maxCycle() controls how agressive such perturbation is
+   *  performed, since no more than maxCycle() degenerate steps are
+   *  accepted before perturbing the LP. The current number of consecutive
+   *  degenerate steps is counted by numCycle().
+   */
+  /// maximum number of degenerate simplex steps before we detect cycling.
+  int maxCycle() const { return m_maxCycle; }
+  /// actual number of degenerate simplex steps encountered so far.
+  int numCycle() const { return m_numCycle; }
+
+  /// perturb entire problem or only the bounds relevant to the current pivot
+  void useFullPerturbation(bool full) { fullPerturbation = full; }
+
+  virtual R getBasisMetric(int type) { return basis().getMatrixMetric(type); }
+
+  ///@}
 
 private:
+  //-----------------------------
+  /**@name Private helpers */
+  ///@{
+  ///
+  void localAddRows(int start);
+  ///
+  void localAddCols(int start);
+  ///
+  void setPrimal(VectorBase<R> &p_vector);
+  ///
+  void setSlacks(VectorBase<R> &p_vector);
+  ///
+  void setDual(VectorBase<R> &p_vector);
+  ///
+  void setRedCost(VectorBase<R> &p_vector);
+  ///@}
+
+protected:
+  //-----------------------------
+  /**@name Protected helpers */
+  ///@{
+  ///
+  virtual void addedRows(int n);
+  ///
+  virtual void addedCols(int n);
+  ///
+  virtual void doRemoveRow(int i);
+  ///
+  virtual void doRemoveRows(int perm[]);
+  ///
+  virtual void doRemoveCol(int i);
+  ///
+  virtual void doRemoveCols(int perm[]);
+  ///@}
 
-   //------------------------------------
-   /**@name Perturbation */
-   ///@{
-   ///
-   void perturbMin(
-      const UpdateVector<R>& vec, VectorBase<R>& low, VectorBase<R>& up, R eps, R delta,
-      int start = 0, int incr = 1);
-   ///
-   void perturbMax(
-      const UpdateVector<R>& vec, VectorBase<R>& low, VectorBase<R>& up, R eps, R delta,
-      int start = 0, int incr = 1);
-   ///
-   R perturbMin(const UpdateVector<R>& uvec,
-                VectorBase<R>& low, VectorBase<R>& up, R eps, R delta,
-                const typename SPxBasisBase<R>::Desc::Status* stat, int start, int incr);
-   ///
-   R perturbMax(const UpdateVector<R>& uvec,
-                VectorBase<R>& low, VectorBase<R>& up, R eps, R delta,
-                const typename SPxBasisBase<R>::Desc::Status* stat, int start, int incr);
-   ///@}
-
-   //------------------------------------
-   /**@name The Simplex Loop
-    *  We now present a set of methods that may be usefull when implementing
-    *  own SPxPricer or SPxRatioTester classes. Here is, how
-    *  SPxSolverBase will call methods from its loaded SPxPricer and
-    *  SPxRatioTester.
-    *
-    *  For the entering Simplex:
-    *    -# \ref soplex::SPxPricer::selectEnter() "SPxPricer::selectEnter()"
-    *    -# \ref soplex::SPxRatioTester::selectLeave() "SPxRatioTester::selectLeave()"
-    *    -# \ref soplex::SPxPricer::entered4() "SPxPricer::entered4()"
-    *
-    *  For the leaving Simplex:
-    *    -# \ref soplex::SPxPricer::selectLeave() "SPxPricer::selectLeave()"
-    *    -# \ref soplex::SPxRatioTester::selectEnter() "SPxRatioTester::selectEnter()"
-    *    -# \ref soplex::SPxPricer::left4() "SPxPricer::left4()"
-    */
-   ///@{
 public:
-   /// Setup vectors to be solved within Simplex loop.
-   /** Load vector \p y to be #solve%d with the basis matrix during the
-    *  #LEAVE Simplex. The system will be solved after #SPxSolverBase%'s call
-    *  to SPxRatioTester.  The system will be solved along with
-    *  another system. Solving two linear system at a time has
-    *  performance advantages over solving the two linear systems
-    *  seperately.
-    */
-   void setup4solve(SSVectorBase<R>* p_y, SSVectorBase<R>* p_rhs)
-   {
-      assert(type() == LEAVE);
-      solveVector2    = p_y;
-      solveVector2rhs = p_rhs;
-   }
-   /// Setup vectors to be solved within Simplex loop.
-   /** Load a second additional vector \p y2 to be #solve%d with the
-    *  basis matrix during the #LEAVE Simplex. The system will be
-    *  solved after #SPxSolverBase%'s call to SPxRatioTester.
-    *  The system will be solved along with at least one
-    *  other system. Solving several linear system at a time has
-    *  performance advantages over solving them seperately.
-    */
-   void setup4solve2(SSVectorBase<R>* p_y2, SSVectorBase<R>* p_rhs2)
-   {
-      assert(type() == LEAVE);
-      solveVector3    = p_y2;
-      solveVector3rhs = p_rhs2;
-   }
-   /// Setup vectors to be cosolved within Simplex loop.
-   /** Load vector \p y to be #coSolve%d with the basis matrix during
-    *  the #ENTER Simplex. The system will be solved after #SPxSolverBase%'s
-    *  call to SPxRatioTester.  The system will be solved along
-    *  with another system. Solving two linear system at a time has
-    *  performance advantages over solving the two linear systems
-    *  seperately.
-    */
-   void setup4coSolve(SSVectorBase<R>* p_y, SSVectorBase<R>* p_rhs)
-   {
-      assert(type() == ENTER);
-      coSolveVector2    = p_y;
-      coSolveVector2rhs = p_rhs;
-   }
-   /// Setup vectors to be cosolved within Simplex loop.
-   /** Load a second vector \p z to be #coSolve%d with the basis matrix during
-    *  the #ENTER Simplex. The system will be solved after #SPxSolverBase%'s
-    *  call to SPxRatioTester. The system will be solved along
-    *  with two other systems.
-    */
-   void setup4coSolve2(SSVectorBase<R>* p_z, SSVectorBase<R>* p_rhs)
-   {
-      assert(type() == ENTER);
-      coSolveVector3    = p_z;
-      coSolveVector3rhs = p_rhs;
-   }
-
-   /// maximal infeasibility of basis
-   /** This method is called before concluding optimality. Since it is
-    *  possible that some stable implementation of class
-    *  SPxRatioTester yielded a slightly infeasible (or unpriced)
-    *  basis, this must be checked before terminating with an optimal
-    *  solution.
-    */
-   virtual R maxInfeas() const;
-
-   /// check for violations above tol and immediately return false w/o checking the remaining values
-   /** This method is useful for verifying whether an objective limit can be used as termination criterion
-    */
-   virtual bool noViols(R tol) const;
-
-   /// Return current basis.
-   /**@note The basis can be used to solve linear systems or use
-    *  any other of its (const) methods.  It is, however, encuraged
-    *  to use methods #setup4solve() and #setup4coSolve() for solving
-    *  systems, since this is likely to have perfomance advantages.
-    */
-   const SPxBasisBase<R>& basis() const
-   {
-      return *this;
-   }
-   ///
-   SPxBasisBase<R>& basis()
-   {
-      return *this;
-   }
-   /// return loaded SPxPricer.
-   const SPxPricer<R>* pricer() const
-   {
-      return thepricer;
-   }
-   /// return loaded SLinSolver.
-   const SLinSolver<R>* slinSolver() const
-   {
-      return SPxBasisBase<R>::factor;
-   }
-   /// return loaded SPxRatioTester.
-   const SPxRatioTester<R>* ratiotester() const
-   {
-      return theratiotester;
-   }
-
-   /// Factorize basis matrix.
-   /// @throw SPxStatusException if loaded matrix is singular
-   virtual void factorize();
+  //-----------------------------
+  /**@name Modification */
+  /// \p scale determines whether the new data needs to be scaled according to
+  /// the existing LP (persistent scaling)
+  ///@{
+  ///
+  virtual void changeObj(const VectorBase<R> &newObj, bool scale = false);
+  ///
+  virtual void changeObj(int i, const R &newVal, bool scale = false);
+  ///
+  using SPxLPBase<R>::changeObj; /// overloading a virtual function
+  virtual void changeObj(SPxColId p_id, const R &p_newVal, bool scale = false) {
+    changeObj(this->number(p_id), p_newVal, scale);
+  }
+  ///
+  virtual void changeMaxObj(const VectorBase<R> &newObj, bool scale = false);
+  ///
+  virtual void changeMaxObj(int i, const R &newVal, bool scale = false);
+  ///
+  using SPxLPBase<R>::changeMaxObj; /// overloading a virtual function
+  virtual void changeMaxObj(SPxColId p_id, const R &p_newVal,
+                            bool scale = false) {
+    changeMaxObj(this->number(p_id), p_newVal, scale);
+  }
+  ///
+  virtual void changeRowObj(const VectorBase<R> &newObj, bool scale = false);
+  ///
+  virtual void changeRowObj(int i, const R &newVal, bool scale = false);
+  ///
+  using SPxLPBase<R>::changeRowObj;
+  virtual void changeRowObj(SPxRowId p_id, const R &p_newVal,
+                            bool scale = false) {
+    changeRowObj(this->number(p_id), p_newVal);
+  }
+  ///
+  virtual void clearRowObjs() {
+    SPxLPBase<R>::clearRowObjs();
+    unInit();
+  }
+  ///
+  virtual void changeLowerStatus(int i, R newLower, R oldLower = 0.0);
+  ///
+  virtual void changeLower(const VectorBase<R> &newLower, bool scale = false);
+  ///
+  virtual void changeLower(int i, const R &newLower, bool scale = false);
+  ///
+  using SPxLPBase<R>::changeLower;
+  virtual void changeLower(SPxColId p_id, const R &p_newLower,
+                           bool scale = false) {
+    changeLower(this->number(p_id), p_newLower, scale);
+  }
+  ///
+  virtual void changeUpperStatus(int i, R newUpper, R oldLower = 0.0);
+  ///
+  virtual void changeUpper(const VectorBase<R> &newUpper, bool scale = false);
+  ///
+  virtual void changeUpper(int i, const R &newUpper, bool scale = false);
+  ///
+  using SPxLPBase<R>::changeUpper; /// overloading virtual function
+  virtual void changeUpper(SPxColId p_id, const R &p_newUpper,
+                           bool scale = false) {
+    changeUpper(this->number(p_id), p_newUpper, scale);
+  }
+  ///
+  virtual void changeBounds(const VectorBase<R> &newLower,
+                            const VectorBase<R> &newUpper, bool scale = false);
+  ///
+  virtual void changeBounds(int i, const R &newLower, const R &newUpper,
+                            bool scale = false);
+  ///
+  using SPxLPBase<R>::changeBounds;
+  virtual void changeBounds(SPxColId p_id, const R &p_newLower,
+                            const R &p_newUpper, bool scale = false) {
+    changeBounds(this->number(p_id), p_newLower, p_newUpper, scale);
+  }
+  ///
+  virtual void changeLhsStatus(int i, R newLhs, R oldLhs = 0.0);
+  ///
+  virtual void changeLhs(const VectorBase<R> &newLhs, bool scale = false);
+  ///
+  virtual void changeLhs(int i, const R &newLhs, bool scale = false);
+  ///
+  using SPxLPBase<R>::changeLhs;
+  virtual void changeLhs(SPxRowId p_id, const R &p_newLhs, bool scale = false) {
+    changeLhs(this->number(p_id), p_newLhs, scale);
+  }
+  ///
+  virtual void changeRhsStatus(int i, R newRhs, R oldRhs = 0.0);
+  ///
+  virtual void changeRhs(const VectorBase<R> &newRhs, bool scale = false);
+  ///
+  virtual void changeRhs(int i, const R &newRhs, bool scale = false);
+  ///
+  using SPxLPBase<R>::changeRhs;
+  virtual void changeRhs(SPxRowId p_id, const R &p_newRhs, bool scale = false) {
+    changeRhs(this->number(p_id), p_newRhs, scale);
+  }
+  ///
+  virtual void changeRange(const VectorBase<R> &newLhs,
+                           const VectorBase<R> &newRhs, bool scale = false);
+  ///
+  virtual void changeRange(int i, const R &newLhs, const R &newRhs,
+                           bool scale = false);
+  ///
+  using SPxLPBase<R>::changeRange;
+  virtual void changeRange(SPxRowId p_id, const R &p_newLhs, const R &p_newRhs,
+                           bool scale = false) {
+    changeRange(this->number(p_id), p_newLhs, p_newRhs, scale);
+  }
+  ///
+  virtual void changeRow(int i, const LPRowBase<R> &newRow, bool scale = false);
+  ///
+  using SPxLPBase<R>::changeRow;
+  virtual void changeRow(SPxRowId p_id, const LPRowBase<R> &p_newRow,
+                         bool scale = false) {
+    changeRow(this->number(p_id), p_newRow, scale);
+  }
+  ///
+  virtual void changeCol(int i, const LPColBase<R> &newCol, bool scale = false);
+  ///
+  using SPxLPBase<R>::changeCol;
+  virtual void changeCol(SPxColId p_id, const LPColBase<R> &p_newCol,
+                         bool scale = false) {
+    changeCol(this->number(p_id), p_newCol, scale);
+  }
+  ///
+  virtual void changeElement(int i, int j, const R &val, bool scale = false);
+  ///
+  using SPxLPBase<R>::changeElement;
+  virtual void changeElement(SPxRowId rid, SPxColId cid, const R &val,
+                             bool scale = false) {
+    changeElement(this->number(rid), this->number(cid), val, scale);
+  }
+  ///
+  virtual void changeSense(typename SPxLPBase<R>::SPxSense sns);
+  ///@}
+
+  //------------------------------------
+  /**@name Dimension and codimension */
+  ///@{
+  /// dimension of basis matrix.
+  int dim() const { return thecovectors->num(); }
+  /// codimension.
+  int coDim() const { return thevectors->num(); }
+  ///@}
+
+  //------------------------------------
+  /**@name Variables and Covariables
+   *  Class SPxLPBase<R> introduces \ref soplex::SPxId "SPxIds" to identify
+   *  row or column data of an LP. SPxSolverBase uses this concept to
+   *  access data with respect to the chosen representation.
+   */
+  ///@{
+  /// id of \p i 'th vector.
+  /** The \p i 'th Id is the \p i 'th SPxRowId for a rowwise and the
+   *  \p i 'th SPxColId for a columnwise basis represenation. Hence,
+   *  0 <= i < #coDim().
+   */
+  SPxId id(int i) const {
+    if (rep() == ROW) {
+      SPxRowId rid = SPxLPBase<R>::rId(i);
+      return SPxId(rid);
+    } else {
+      SPxColId cid = SPxLPBase<R>::cId(i);
+      return SPxId(cid);
+    }
+  }
+
+  /// id of \p i 'th covector.
+  /** The \p i 'th #coId() is the \p i 'th SPxColId for a rowwise and the
+   *  \p i 'th SPxRowId for a columnwise basis represenation. Hence,
+   *  0 <= i < #dim().
+   */
+  SPxId coId(int i) const {
+    if (rep() == ROW) {
+      SPxColId cid = SPxLPBase<R>::cId(i);
+      return SPxId(cid);
+    } else {
+      SPxRowId rid = SPxLPBase<R>::rId(i);
+      return SPxId(rid);
+    }
+  }
+
+  /// Is \p p_id an SPxId ?
+  /** This method returns wheather or not \p p_id identifies a vector
+   *  with respect to the chosen representation.
+   */
+  bool isId(const SPxId &p_id) const { return p_id.info * theRep > 0; }
+
+  /// Is \p p_id a CoId.
+  /** This method returns wheather or not \p p_id identifies a coVector
+   *  with respect to the chosen representation.
+   */
+  bool isCoId(const SPxId &p_id) const { return p_id.info * theRep < 0; }
+  ///@}
+
+  //------------------------------------
+  /**@name Vectors and Covectors */
+  ///@{
+  /// \p i 'th vector.
+  /**@return a reference to the \p i 'th, 0 <= i < #coDim(), vector of
+   *         the loaded LP (with respect to the chosen representation).
+   */
+  const SVectorBase<R> &vector(int i) const { return (*thevectors)[i]; }
+
+  ///
+  const SVectorBase<R> &vector(const SPxRowId &rid) const {
+    assert(rid.isValid());
+    return (rep() == ROW) ? (*thevectors)[this->number(rid)]
+                          : static_cast<const SVectorBase<R> &>(
+                                unitVecs[this->number(rid)]);
+  }
+  ///
+  const SVectorBase<R> &vector(const SPxColId &cid) const {
+    assert(cid.isValid());
+    return (rep() == COLUMN) ? (*thevectors)[this->number(cid)]
+                             : static_cast<const SVectorBase<R> &>(
+                                   unitVecs[this->number(cid)]);
+  }
+
+  /// VectorBase<R> associated to \p p_id.
+  /**@return Returns a reference to the VectorBase<R> of the loaded LP
+   * corresponding to \p id (with respect to the chosen representation). If \p
+   * p_id is an id, a vector of the constraint matrix is returned, otherwise the
+   * corresponding unit vector (of the slack variable or bound inequality) is
+   * returned.
+   *  @todo The implementation does not exactly look like it will do
+   *        what is promised in the describtion.
+   */
+  const SVectorBase<R> &vector(const SPxId &p_id) const {
+    assert(p_id.isValid());
+
+    return p_id.isSPxRowId() ? vector(SPxRowId(p_id)) : vector(SPxColId(p_id));
+  }
+
+  /// \p i 'th covector of LP.
+  /**@return a reference to the \p i 'th, 0 <= i < #dim(), covector of
+   *  the loaded LP (with respect to the chosen representation).
+   */
+  const SVectorBase<R> &coVector(int i) const { return (*thecovectors)[i]; }
+  ///
+  const SVectorBase<R> &coVector(const SPxRowId &rid) const {
+    assert(rid.isValid());
+    return (rep() == COLUMN)
+               ? (*thecovectors)[this->number(rid)]
+               : static_cast<const SVector &>(unitVecs[this->number(rid)]);
+  }
+  ///
+  const SVectorBase<R> &coVector(const SPxColId &cid) const {
+    assert(cid.isValid());
+    return (rep() == ROW) ? (*thecovectors)[this->number(cid)]
+                          : static_cast<const SVectorBase<R> &>(
+                                unitVecs[this->number(cid)]);
+  }
+  /// coVector associated to \p p_id.
+  /**@return a reference to the covector of the loaded LP
+   *  corresponding to \p p_id (with respect to the chosen
+   *  representation). If \p p_id is a coid, a covector of the constraint
+   *  matrix is returned, otherwise the corresponding unit vector is
+   *  returned.
+   */
+  const SVectorBase<R> &coVector(const SPxId &p_id) const {
+    assert(p_id.isValid());
+    return p_id.isSPxRowId() ? coVector(SPxRowId(p_id))
+                             : coVector(SPxColId(p_id));
+  }
+  /// return \p i 'th unit vector.
+  const SVectorBase<R> &unitVector(int i) const { return unitVecs[i]; }
+  ///@}
+
+  //------------------------------------
+  /**@name Variable status
+   *  The Simplex basis assigns a \ref soplex::SPxBasisBase<R>::Desc::Status
+   *  "Status" to each variable and covariable. Depending on the
+   *  representation, the status indicates that the corresponding
+   *  vector is in the basis matrix or not.
+   */
+  ///@{
+  /// Status of \p i 'th variable.
+  typename SPxBasisBase<R>::Desc::Status varStatus(int i) const {
+    return this->desc().status(i);
+  }
+
+  /// Status of \p i 'th covariable.
+  typename SPxBasisBase<R>::Desc::Status covarStatus(int i) const {
+    return this->desc().coStatus(i);
+  }
+
+  /// does \p stat describe a basic index ?
+  bool isBasic(typename SPxBasisBase<R>::Desc::Status stat) const {
+    return (static_cast<int>(stat) * rep() > 0);
+  }
+
+  /// is the \p p_id 'th vector basic ?
+  bool isBasic(const SPxId &p_id) const {
+    assert(p_id.isValid());
+    return p_id.isSPxRowId() ? isBasic(SPxRowId(p_id))
+                             : isBasic(SPxColId(p_id));
+  }
+
+  /// is the \p rid 'th vector basic ?
+  bool isBasic(const SPxRowId &rid) const {
+    return isBasic(this->desc().rowStatus(this->number(rid)));
+  }
+
+  /// is the \p cid 'th vector basic ?
+  bool isBasic(const SPxColId &cid) const {
+    return isBasic(this->desc().colStatus(this->number(cid)));
+  }
+
+  /// is the \p i 'th row vector basic ?
+  bool isRowBasic(int i) const { return isBasic(this->desc().rowStatus(i)); }
+
+  /// is the \p i 'th column vector basic ?
+  bool isColBasic(int i) const { return isBasic(this->desc().colStatus(i)); }
+
+  /// is the \p i 'th vector basic ?
+  bool isBasic(int i) const { return isBasic(this->desc().status(i)); }
+
+  /// is the \p i 'th covector basic ?
+  bool isCoBasic(int i) const { return isBasic(this->desc().coStatus(i)); }
+  ///@}
+
+  /// feasibility vector.
+  /** This method return the \em feasibility vector. If it satisfies its
+   *  bound, the basis is called feasible (independently of the chosen
+   *  representation). The feasibility vector has dimension #dim().
+   *
+   *  For the entering Simplex, #fVec is kept within its bounds. In
+   *  contrast to this, the pricing of the leaving Simplex selects an
+   *  element of #fVec, that violates its bounds.
+   */
+  UpdateVector<R> &fVec() const { return *theFvec; }
+  /// right-hand side vector for \ref soplex::SPxSolverBase<R>::fVec "fVec"
+  /** The feasibility vector is computed by solving a linear system with the
+   *  basis matrix. The right-hand side vector of this system is referred
+   *  to as \em feasibility, \em right-hand \em side \em vector #fRhs().
+   *
+   *  For a row basis, #fRhs() is the objective vector (ignoring shifts).
+   *  For a column basis, it is the sum of all nonbasic vectors scaled by
+   *  the factor of their bound.
+   */
+  const VectorBase<R> &fRhs() const { return *theFrhs; }
+  /// upper bound for \ref soplex::SPxSolverBase<R>::fVec "fVec".
+  const VectorBase<R> &ubBound() const { return theUBbound; }
+  /// upper bound for #fVec, writable.
+  /** This method returns the upper bound for the feasibility vector.
+   *  It may only be called for the #ENTER%ing Simplex.
+   *
+   *  For the #ENTER%ing Simplex algorithms, the feasibility vector is
+   *  maintained to fullfill its bounds. As #fVec itself, also its
+   *  bounds depend on the chosen representation. Further, they may
+   *  need to be shifted (see below).
+   */
+  VectorBase<R> &ubBound() { return theUBbound; }
+  /// lower bound for \ref soplex::SPxSolverBase<R>::fVec "fVec".
+  const VectorBase<R> &lbBound() const { return theLBbound; }
+  /// lower bound for #fVec, writable.
+  /** This method returns the lower bound for the feasibility vector.
+   *  It may only be called for the #ENTER%ing Simplex.
+   *
+   *  For the #ENTER%ing Simplex algorithms, the feasibility vector is
+   *  maintained to fullfill its bounds. As #fVec itself, also its
+   *  bound depend on the chosen representation. Further, they may
+   *  need to be shifted (see below).
+   */
+  VectorBase<R> &lbBound() { return theLBbound; }
+
+  /// Violations of \ref soplex::SPxSolverBase<R>::fVec "fVec"
+  /** For the leaving Simplex algorithm, pricing involves selecting a
+   *  variable from #fVec that violates its bounds that is to leave
+   *  the basis. When a SPxPricer is called to select such a
+   *  leaving variable, #fTest() contains the vector of violations:
+   *  For #fTest()[i] < 0, the \c i 'th basic variable violates one of
+   *  its bounds by the given value. Otherwise no bound is violated.
+   */
+  const VectorBase<R> &fTest() const {
+    assert(type() == LEAVE);
+    return theCoTest;
+  }
+
+  /// copricing vector.
+  /** The copricing vector #coPvec along with the pricing vector
+   *  #pVec are used for pricing in the #ENTER%ing Simplex algorithm,
+   *  i.e. one variable is selected, that violates its bounds. In
+   *  contrast to this, the #LEAVE%ing Simplex algorithm keeps both
+   *  vectors within their bounds.
+   */
+  UpdateVector<R> &coPvec() const { return *theCoPvec; }
+
+  /// Right-hand side vector for \ref soplex::SPxSolverBase<R>::coPvec "coPvec".
+  /** The vector #coPvec is computed by solving a linear system with the
+   *  basis matrix and #coPrhs as the right-hand side vector. For
+   *  column basis representation, #coPrhs is build up of the
+   *  objective vector elements of all basic variables. For a row
+   *  basis, it consists of the tight bounds of all basic
+   *  constraints.
+   */
+  const VectorBase<R> &coPrhs() const { return *theCoPrhs; }
+
+  ///
+  const VectorBase<R> &ucBound() const {
+    assert(theType == LEAVE);
+    return *theCoUbound;
+  }
+  /// upper bound for #coPvec.
+  /** This method returns the upper bound for #coPvec. It may only be
+   *  called for the leaving Simplex algorithm.
+   *
+   *  For the leaving Simplex algorithms #coPvec is maintained to
+   *  fullfill its bounds. As #coPvec itself, also its bound depend
+   *  on the chosen representation. Further, they may need to be
+   *  shifted (see below).
+   */
+  VectorBase<R> &ucBound() {
+    assert(theType == LEAVE);
+    return *theCoUbound;
+  }
+
+  ///
+  const VectorBase<R> &lcBound() const {
+    assert(theType == LEAVE);
+    return *theCoLbound;
+  }
+  /// lower bound for #coPvec.
+  /** This method returns the lower bound for #coPvec. It may only be
+   *  called for the leaving Simplex algorithm.
+   *
+   *  For the leaving Simplex algorithms #coPvec is maintained to
+   *  fullfill its bounds. As #coPvec itself, also its bound depend
+   *  on the chosen representation. Further, they may need to be
+   *  shifted (see below).
+   */
+  VectorBase<R> &lcBound() {
+    assert(theType == LEAVE);
+    return *theCoLbound;
+  }
+
+  /// violations of \ref soplex::SPxSolverBase<R>::coPvec "coPvec".
+  /** In entering Simplex pricing selects checks vectors #coPvec()
+   *  and #pVec() for violation of its bounds. #coTest() contains
+   *  the violations for #coPvec() which are indicated by a negative
+   *  value. That is, if #coTest()[i] < 0, the \p i 'th element of #coPvec()
+   *  is violated by -#coTest()[i].
+   */
+  const VectorBase<R> &coTest() const {
+    assert(type() == ENTER);
+    return theCoTest;
+  }
+  /// pricing vector.
+  /** The pricing vector #pVec is the product of #coPvec with the
+   *  constraint matrix. As #coPvec, also #pVec is maintained within
+   *  its bound for the leaving Simplex algorithm, while the bounds
+   *  are tested for the entering Simplex. #pVec is of dimension
+   *  #coDim(). Vector #pVec() is only up to date for #LEAVE%ing
+   *  Simplex or #FULL pricing in #ENTER%ing Simplex.
+   */
+  UpdateVector<R> &pVec() const { return *thePvec; }
+  ///
+  const VectorBase<R> &upBound() const {
+    assert(theType == LEAVE);
+    return *theUbound;
+  }
+  /// upper bound for #pVec.
+  /** This method returns the upper bound for #pVec. It may only be
+   *  called for the leaving Simplex algorithm.
+   *
+   *  For the leaving Simplex algorithms #pVec is maintained to
+   *  fullfill its bounds. As #pVec itself, also its bound depend
+   *  on the chosen representation. Further, they may need to be
+   *  shifted (see below).
+   */
+  VectorBase<R> &upBound() {
+    assert(theType == LEAVE);
+    return *theUbound;
+  }
+
+  ///
+  const VectorBase<R> &lpBound() const {
+    assert(theType == LEAVE);
+    return *theLbound;
+  }
+  /// lower bound for #pVec.
+  /** This method returns the lower bound for #pVec. It may only be
+   *  called for the leaving Simplex algorithm.
+   *
+   *  For the leaving Simplex algorithms #pVec is maintained to
+   *  fullfill its bounds. As #pVec itself, also its bound depend
+   *  on the chosen representation. Further, they may need to be
+   *  shifted (see below).
+   */
+  VectorBase<R> &lpBound() {
+    assert(theType == LEAVE);
+    return *theLbound;
+  }
+
+  /// Violations of \ref soplex::SPxSolverBase<R>::pVec "pVec".
+  /** In entering Simplex pricing selects checks vectors #coPvec()
+   *  and #pVec() for violation of its bounds. Vector #test()
+   *  contains the violations for #pVec(), i.e., if #test()[i] < 0,
+   *  the i'th element of #pVec() is violated by #test()[i].
+   *  Vector #test() is only up to date for #FULL pricing.
+   */
+  const VectorBase<R> &test() const {
+    assert(type() == ENTER);
+    return theTest;
+  }
+
+  /// compute and return \ref soplex::SPxSolverBase<R>::pVec() "pVec()"[i].
+  R computePvec(int i);
+  /// compute entire \ref soplex::SPxSolverBase<R>::pVec() "pVec()".
+  void computePvec();
+  /// compute and return \ref soplex::SPxSolverBase<R>::test() "test()"[i] in
+  /// \ref soplex::SPxSolverBase<R>::ENTER "ENTER"ing Simplex.
+  R computeTest(int i);
+  /// compute test VectorBase<R> in \ref soplex::SPxSolverBase<R>::ENTER
+  /// "ENTER"ing Simplex.
+  void computeTest();
+
+  //------------------------------------
+  /**@name Shifting
+   *  The task of the ratio test (implemented in SPxRatioTester classes)
+   *  is to select a variable for the basis update, such that the basis
+   *  remains priced (i.e. both, the pricing and copricing vectors satisfy
+   *  their bounds) or feasible (i.e. the feasibility vector satisfies its
+   *  bounds). However, this can lead to numerically instable basis matrices
+   *  or -- after accumulation of various errors -- even to a singular basis
+   *  matrix.
+   *
+   *  The key to overcome this problem is to allow the basis to become "a
+   *  bit" infeasible or unpriced, in order provide a better choice for the
+   *  ratio test to select a stable variable. This is equivalent to enlarging
+   *  the bounds by a small amount. This is referred to as \em shifting.
+   *
+   *  These methods serve for shifting feasibility bounds, either in order
+   *  to maintain numerical stability or initially for computation of
+   *  phase 1. The sum of all shifts applied to any bound is stored in
+   *  \ref soplex::SPxSolverBase<R>::theShift "theShift".
+   *
+   *  The following methods are used to shift individual bounds. They are
+   *  mainly intended for stable implenentations of SPxRatioTester.
+   */
+  ///@{
+  /// Perform initial shifting to optain an feasible or pricable basis.
+  void shiftFvec();
+  /// Perform initial shifting to optain an feasible or pricable basis.
+  void shiftPvec();
+
+  /// shift \p i 'th \ref soplex::SPxSolver::ubBound "ubBound" to \p to.
+  void shiftUBbound(int i, R to) {
+    assert(theType == ENTER);
+    // use maximum to not count tightened bounds in case of equality shifts
+    theShift += MAXIMUM(to - theUBbound[i], 0.0);
+    theUBbound[i] = to;
+  }
+  /// shift \p i 'th \ref soplex::SPxSolver::lbBound "lbBound" to \p to.
+  void shiftLBbound(int i, R to) {
+    assert(theType == ENTER);
+    // use maximum to not count tightened bounds in case of equality shifts
+    theShift += MAXIMUM(theLBbound[i] - to, 0.0);
+    theLBbound[i] = to;
+  }
+  /// shift \p i 'th \ref soplex::SPxSolver::upBound "upBound" to \p to.
+  void shiftUPbound(int i, R to) {
+    assert(theType == LEAVE);
+    // use maximum to not count tightened bounds in case of equality shifts
+    theShift += MAXIMUM(to - (*theUbound)[i], 0.0);
+    (*theUbound)[i] = to;
+  }
+  /// shift \p i 'th \ref soplex::SPxSolver::lpBound "lpBound" to \p to.
+  void shiftLPbound(int i, R to) {
+    assert(theType == LEAVE);
+    // use maximum to not count tightened bounds in case of equality shifts
+    theShift += MAXIMUM((*theLbound)[i] - to, 0.0);
+    (*theLbound)[i] = to;
+  }
+  /// shift \p i 'th \ref soplex::SPxSolver::ucBound "ucBound" to \p to.
+  void shiftUCbound(int i, R to) {
+    assert(theType == LEAVE);
+    // use maximum to not count tightened bounds in case of equality shifts
+    theShift += MAXIMUM(to - (*theCoUbound)[i], 0.0);
+    (*theCoUbound)[i] = to;
+  }
+  /// shift \p i 'th \ref soplex::SPxSolver::lcBound "lcBound" to \p to.
+  void shiftLCbound(int i, R to) {
+    assert(theType == LEAVE);
+    // use maximum to not count tightened bounds in case of equality shifts
+    theShift += MAXIMUM((*theCoLbound)[i] - to, 0.0);
+    (*theCoLbound)[i] = to;
+  }
+  ///
+  void testBounds() const;
+
+  /// total current shift amount.
+  virtual R shift() const { return theShift; }
+  /// remove shift as much as possible.
+  virtual void unShift(void);
+
+  /// get violation of constraints.
+  virtual void qualConstraintViolation(R &maxviol, R &sumviol) const;
+  /// get violations of bounds.
+  virtual void qualBoundViolation(R &maxviol, R &sumviol) const;
+  /// get the residuum |Ax-b|.
+  virtual void qualSlackViolation(R &maxviol, R &sumviol) const;
+  /// get violation of optimality criterion.
+  virtual void qualRedCostViolation(R &maxviol, R &sumviol) const;
+  ///@}
 
 private:
+  //------------------------------------
+  /**@name Perturbation */
+  ///@{
+  ///
+  void perturbMin(const UpdateVector<R> &vec, VectorBase<R> &low,
+                  VectorBase<R> &up, R eps, R delta, int start = 0,
+                  int incr = 1);
+  ///
+  void perturbMax(const UpdateVector<R> &vec, VectorBase<R> &low,
+                  VectorBase<R> &up, R eps, R delta, int start = 0,
+                  int incr = 1);
+  ///
+  R perturbMin(const UpdateVector<R> &uvec, VectorBase<R> &low,
+               VectorBase<R> &up, R eps, R delta,
+               const typename SPxBasisBase<R>::Desc::Status *stat, int start,
+               int incr);
+  ///
+  R perturbMax(const UpdateVector<R> &uvec, VectorBase<R> &low,
+               VectorBase<R> &up, R eps, R delta,
+               const typename SPxBasisBase<R>::Desc::Status *stat, int start,
+               int incr);
+  ///@}
+
+  //------------------------------------
+  /**@name The Simplex Loop
+   *  We now present a set of methods that may be usefull when implementing
+   *  own SPxPricer or SPxRatioTester classes. Here is, how
+   *  SPxSolverBase will call methods from its loaded SPxPricer and
+   *  SPxRatioTester.
+   *
+   *  For the entering Simplex:
+   *    -# \ref soplex::SPxPricer::selectEnter() "SPxPricer::selectEnter()"
+   *    -# \ref soplex::SPxRatioTester::selectLeave()
+   * "SPxRatioTester::selectLeave()"
+   *    -# \ref soplex::SPxPricer::entered4() "SPxPricer::entered4()"
+   *
+   *  For the leaving Simplex:
+   *    -# \ref soplex::SPxPricer::selectLeave() "SPxPricer::selectLeave()"
+   *    -# \ref soplex::SPxRatioTester::selectEnter()
+   * "SPxRatioTester::selectEnter()"
+   *    -# \ref soplex::SPxPricer::left4() "SPxPricer::left4()"
+   */
+  ///@{
+public:
+  /// Setup vectors to be solved within Simplex loop.
+  /** Load vector \p y to be #solve%d with the basis matrix during the
+   *  #LEAVE Simplex. The system will be solved after #SPxSolverBase%'s call
+   *  to SPxRatioTester.  The system will be solved along with
+   *  another system. Solving two linear system at a time has
+   *  performance advantages over solving the two linear systems
+   *  seperately.
+   */
+  void setup4solve(SSVectorBase<R> *p_y, SSVectorBase<R> *p_rhs) {
+    assert(type() == LEAVE);
+    solveVector2 = p_y;
+    solveVector2rhs = p_rhs;
+  }
+  /// Setup vectors to be solved within Simplex loop.
+  /** Load a second additional vector \p y2 to be #solve%d with the
+   *  basis matrix during the #LEAVE Simplex. The system will be
+   *  solved after #SPxSolverBase%'s call to SPxRatioTester.
+   *  The system will be solved along with at least one
+   *  other system. Solving several linear system at a time has
+   *  performance advantages over solving them seperately.
+   */
+  void setup4solve2(SSVectorBase<R> *p_y2, SSVectorBase<R> *p_rhs2) {
+    assert(type() == LEAVE);
+    solveVector3 = p_y2;
+    solveVector3rhs = p_rhs2;
+  }
+  /// Setup vectors to be cosolved within Simplex loop.
+  /** Load vector \p y to be #coSolve%d with the basis matrix during
+   *  the #ENTER Simplex. The system will be solved after #SPxSolverBase%'s
+   *  call to SPxRatioTester.  The system will be solved along
+   *  with another system. Solving two linear system at a time has
+   *  performance advantages over solving the two linear systems
+   *  seperately.
+   */
+  void setup4coSolve(SSVectorBase<R> *p_y, SSVectorBase<R> *p_rhs) {
+    assert(type() == ENTER);
+    coSolveVector2 = p_y;
+    coSolveVector2rhs = p_rhs;
+  }
+  /// Setup vectors to be cosolved within Simplex loop.
+  /** Load a second vector \p z to be #coSolve%d with the basis matrix during
+   *  the #ENTER Simplex. The system will be solved after #SPxSolverBase%'s
+   *  call to SPxRatioTester. The system will be solved along
+   *  with two other systems.
+   */
+  void setup4coSolve2(SSVectorBase<R> *p_z, SSVectorBase<R> *p_rhs) {
+    assert(type() == ENTER);
+    coSolveVector3 = p_z;
+    coSolveVector3rhs = p_rhs;
+  }
+
+  /// maximal infeasibility of basis
+  /** This method is called before concluding optimality. Since it is
+   *  possible that some stable implementation of class
+   *  SPxRatioTester yielded a slightly infeasible (or unpriced)
+   *  basis, this must be checked before terminating with an optimal
+   *  solution.
+   */
+  virtual R maxInfeas() const;
+
+  /// check for violations above tol and immediately return false w/o checking
+  /// the remaining values
+  /** This method is useful for verifying whether an objective limit can be used
+   * as termination criterion
+   */
+  virtual bool noViols(R tol) const;
+
+  /// Return current basis.
+  /**@note The basis can be used to solve linear systems or use
+   *  any other of its (const) methods.  It is, however, encuraged
+   *  to use methods #setup4solve() and #setup4coSolve() for solving
+   *  systems, since this is likely to have perfomance advantages.
+   */
+  const SPxBasisBase<R> &basis() const { return *this; }
+  ///
+  SPxBasisBase<R> &basis() { return *this; }
+  /// return loaded SPxPricer.
+  const SPxPricer<R> *pricer() const { return thepricer; }
+  /// return loaded SLinSolver.
+  const SLinSolver<R> *slinSolver() const { return SPxBasisBase<R>::factor; }
+  /// return loaded SPxRatioTester.
+  const SPxRatioTester<R> *ratiotester() const { return theratiotester; }
+
+  /// Factorize basis matrix.
+  /// @throw SPxStatusException if loaded matrix is singular
+  virtual void factorize();
+
+private:
+  /** let index \p i leave the basis and manage entering of another one.
+      @returns \c false if LP is unbounded/infeasible. */
+  bool leave(int i, bool polish = false);
+  /** let id enter the basis and manage leaving of another one.
+      @returns \c false if LP is unbounded/infeasible. */
+  bool enter(SPxId &id, bool polish = false);
+
+  /// test coVector \p i with status \p stat.
+  R coTest(int i, typename SPxBasisBase<R>::Desc::Status stat) const;
+  /// compute coTest vector.
+  void computeCoTest();
+  /// recompute coTest vector.
+  void updateCoTest();
+
+  /// test VectorBase<R> \p i with status \p stat.
+  R test(int i, typename SPxBasisBase<R>::Desc::Status stat) const;
+  /// recompute test vector.
+  void updateTest();
+
+  /// compute basis feasibility test vector.
+  void computeFtest();
+  /// update basis feasibility test vector.
+  void updateFtest();
+
+  ///@}
+
+  //------------------------------------
+  /**@name Parallelization
+   *  In this section we present the methods, that are provided in order to
+   *  allow a parallel version to be implemented as a derived class, thereby
+   *  inheriting most of the code of SPxSolverBase.
+   *
+   *  @par Initialization
+   *  These methods are used to setup all the vectors used in the Simplex
+   *  loop, that where described in the previous sectios.
+   */
+  ///@{
+public:
+  /// intialize data structures.
+  /** If SPxSolverBase is not \ref isInitialized() "initialized", the method
+   *  #solve() calls #init() to setup all vectors and internal data structures.
+   *  Most of the other methods within this section are called by #init().
+   *
+   *  Derived classes should add the initialization of additional
+   *  data structures by overriding this method. Don't forget,
+   *  however, to call SPxSolverBase<R>::init().
+   */
+  virtual void init();
+
+protected:
+  /// has the internal data been initialized?
+  /** As long as an instance of SPxSolverBase is not initialized, no member
+   *  contains setup data. Initialization is performed via method
+   *  #init().  Afterwards all data structures are kept up to date (even
+   *  for all manipulation methods), until #unInit() is called. However,
+   *  some manipulation methods call #unInit() themselfs.
+   */
+  bool isInitialized() const { return initialized; }
+
+  /// resets clock average statistics
+  void resetClockStats();
+
+  /// uninitialize data structures.
+  virtual void unInit() { initialized = false; }
+  /// setup all vecs fresh
+  virtual void reinitializeVecs();
+  /// reset dimensions of vectors according to loaded LP.
+  virtual void reDim();
+  /// compute feasibility vector from scratch.
+  void computeFrhs();
+  ///
+  virtual void computeFrhsXtra();
+  ///
+  virtual void computeFrhs1(const VectorBase<R> &, const VectorBase<R> &);
+  ///
+  void computeFrhs2(VectorBase<R> &, VectorBase<R> &);
+  /// compute \ref soplex::SPxSolverBase<R>::theCoPrhs "theCoPrhs" for entering
+  /// Simplex.
+  virtual void computeEnterCoPrhs();
+  ///
+  void computeEnterCoPrhs4Row(int i, int n);
+  ///
+  void computeEnterCoPrhs4Col(int i, int n);
+  /// compute \ref soplex::SPxSolverBase<R>::theCoPrhs "theCoPrhs" for leaving
+  /// Simplex.
+  virtual void computeLeaveCoPrhs();
+  ///
+  void computeLeaveCoPrhs4Row(int i, int n);
+  ///
+  void computeLeaveCoPrhs4Col(int i, int n);
+
+  /// Compute part of objective value.
+  /** This method is called from #value() in order to compute the part of
+   *  the objective value resulting form nonbasic variables for #COLUMN
+   *  Representation.
+   */
+  R nonbasicValue();
+
+  /// Get pointer to the \p id 'th vector
+  virtual const SVectorBase<R> *enterVector(const SPxId &p_id) {
+    assert(p_id.isValid());
+    return p_id.isSPxRowId() ? &vector(SPxRowId(p_id))
+                             : &vector(SPxColId(p_id));
+  }
+  ///
+  virtual void getLeaveVals(int i,
+                            typename SPxBasisBase<R>::Desc::Status &leaveStat,
+                            SPxId &leaveId, R &leaveMax, R &leavebound,
+                            int &leaveNum, StableSum<R> &objChange);
+  ///
+  virtual void getLeaveVals2(R leaveMax, SPxId enterId, R &enterBound,
+                             R &newUBbound, R &newLBbound, R &newCoPrhs,
+                             StableSum<R> &objChange);
+  ///
+  virtual void getEnterVals(SPxId id, R &enterTest, R &enterUB, R &enterLB,
+                            R &enterVal, R &enterMax, R &enterPric,
+                            typename SPxBasisBase<R>::Desc::Status &enterStat,
+                            R &enterRO, StableSum<R> &objChange);
+  ///
+  virtual void getEnterVals2(int leaveIdx, R enterMax, R &leaveBound,
+                             StableSum<R> &objChange);
+  ///
+  virtual void ungetEnterVal(SPxId enterId,
+                             typename SPxBasisBase<R>::Desc::Status enterStat,
+                             R leaveVal, const SVectorBase<R> &vec,
+                             StableSum<R> &objChange);
+  ///
+  virtual void rejectEnter(SPxId enterId, R enterTest,
+                           typename SPxBasisBase<R>::Desc::Status enterStat);
+  ///
+  virtual void rejectLeave(int leaveNum, SPxId leaveId,
+                           typename SPxBasisBase<R>::Desc::Status leaveStat,
+                           const SVectorBase<R> *newVec = 0);
+  ///
+  virtual void setupPupdate(void);
+  ///
+  virtual void doPupdate(void);
+  ///
+  virtual void clearUpdateVecs(void);
+  ///
+  virtual void perturbMinEnter(void);
+  /// perturb basis bounds.
+  virtual void perturbMaxEnter(void);
+  ///
+  virtual void perturbMinLeave(void);
+  /// perturb nonbasic bounds.
+  virtual void perturbMaxLeave(void);
+  ///@}
+
+  //------------------------------------
+  /** The following methods serve for initializing the bounds for dual or
+   *  primal Simplex algorithm of entering or leaving type.
+   */
+  ///@{
+  ///
+  void clearDualBounds(typename SPxBasisBase<R>::Desc::Status, R &, R &) const;
+  ///
+  void setDualColBounds();
+  ///
+  void setDualRowBounds();
+  /// setup feasibility bounds for entering algorithm
+  void setPrimalBounds();
+  ///
+  void setEnterBound4Col(int, int);
+  ///
+  void setEnterBound4Row(int, int);
+  ///
+  virtual void setEnterBounds();
+  ///
+  void setLeaveBound4Row(int i, int n);
+  ///
+  void setLeaveBound4Col(int i, int n);
+  ///
+  virtual void setLeaveBounds();
+  ///@}
+
+  //------------------------------------
+  /** Compute the primal ray or the farkas proof in case of unboundedness
+   *  or infeasibility.
+   */
+  ///@{
+  ///
+  void computePrimalray4Col(R direction, SPxId enterId);
+  ///
+  void computePrimalray4Row(R direction);
+  ///
+  void computeDualfarkas4Col(R direction);
+  ///
+  void computeDualfarkas4Row(R direction, SPxId enterId);
+  ///@}
 
-   /** let index \p i leave the basis and manage entering of another one.
-       @returns \c false if LP is unbounded/infeasible. */
-   bool leave(int i, bool polish = false);
-   /** let id enter the basis and manage leaving of another one.
-       @returns \c false if LP is unbounded/infeasible. */
-   bool enter(SPxId& id, bool polish = false);
-
-   /// test coVector \p i with status \p stat.
-   R coTest(int i, typename SPxBasisBase<R>::Desc::Status stat) const;
-   /// compute coTest vector.
-   void computeCoTest();
-   /// recompute coTest vector.
-   void updateCoTest();
-
-   /// test VectorBase<R> \p i with status \p stat.
-   R test(int i, typename SPxBasisBase<R>::Desc::Status stat) const;
-   /// recompute test vector.
-   void updateTest();
-
-   /// compute basis feasibility test vector.
-   void computeFtest();
-   /// update basis feasibility test vector.
-   void updateFtest();
-
-   ///@}
-
-   //------------------------------------
-   /**@name Parallelization
-    *  In this section we present the methods, that are provided in order to
-    *  allow a parallel version to be implemented as a derived class, thereby
-    *  inheriting most of the code of SPxSolverBase.
-    *
-    *  @par Initialization
-    *  These methods are used to setup all the vectors used in the Simplex
-    *  loop, that where described in the previous sectios.
-    */
-   ///@{
 public:
-   /// intialize data structures.
-   /** If SPxSolverBase is not \ref isInitialized() "initialized", the method
-    *  #solve() calls #init() to setup all vectors and internal data structures.
-    *  Most of the other methods within this section are called by #init().
-    *
-    *  Derived classes should add the initialization of additional
-    *  data structures by overriding this method. Don't forget,
-    *  however, to call SPxSolverBase<R>::init().
-    */
-   virtual void init();
+  //------------------------------------
+  /** Limits and status inquiry */
+  ///@{
+  /// set time limit.
+  virtual void setTerminationTime(Real time = infinity);
+  /// return time limit.
+  virtual Real terminationTime() const;
+  /// set iteration limit.
+  virtual void setTerminationIter(int iteration = -1);
+  /// return iteration limit.
+  virtual int terminationIter() const;
+  /// set objective limit.
+  virtual void setTerminationValue(R value = R(infinity));
+  /// return objective limit.
+  virtual R terminationValue() const;
+  /// get objective value of current solution.
+  virtual R objValue() { return value(); }
+  /// get all results of last solve.
+  Status getResult(R *value = 0, VectorBase<R> *primal = 0,
+                   VectorBase<R> *slacks = 0, VectorBase<R> *dual = 0,
+                   VectorBase<R> *reduCost = 0);
 
 protected:
+  /**@todo put the following basis methods near the variable status methods!*/
+  /// converts basis status to VarStatus
+  VarStatus
+  basisStatusToVarStatus(typename SPxBasisBase<R>::Desc::Status stat) const;
+
+  /// converts VarStatus to basis status for rows
+  typename SPxBasisBase<R>::Desc::Status
+  varStatusToBasisStatusRow(int row, VarStatus stat) const;
 
-   /// has the internal data been initialized?
-   /** As long as an instance of SPxSolverBase is not initialized, no member
-    *  contains setup data. Initialization is performed via method
-    *  #init().  Afterwards all data structures are kept up to date (even
-    *  for all manipulation methods), until #unInit() is called. However,
-    *  some manipulation methods call #unInit() themselfs.
-    */
-   bool isInitialized() const
-   {
-      return initialized;
-   }
-
-   /// resets clock average statistics
-   void resetClockStats();
-
-   /// uninitialize data structures.
-   virtual void unInit()
-   {
-      initialized = false;
-   }
-   /// setup all vecs fresh
-   virtual void reinitializeVecs();
-   /// reset dimensions of vectors according to loaded LP.
-   virtual void reDim();
-   /// compute feasibility vector from scratch.
-   void computeFrhs();
-   ///
-   virtual void computeFrhsXtra();
-   ///
-   virtual void computeFrhs1(const VectorBase<R>&, const VectorBase<R>&);
-   ///
-   void computeFrhs2(VectorBase<R>&, VectorBase<R>&);
-   /// compute \ref soplex::SPxSolverBase<R>::theCoPrhs "theCoPrhs" for entering Simplex.
-   virtual void computeEnterCoPrhs();
-   ///
-   void computeEnterCoPrhs4Row(int i, int n);
-   ///
-   void computeEnterCoPrhs4Col(int i, int n);
-   /// compute \ref soplex::SPxSolverBase<R>::theCoPrhs "theCoPrhs" for leaving Simplex.
-   virtual void computeLeaveCoPrhs();
-   ///
-   void computeLeaveCoPrhs4Row(int i, int n);
-   ///
-   void computeLeaveCoPrhs4Col(int i, int n);
-
-   /// Compute part of objective value.
-   /** This method is called from #value() in order to compute the part of
-    *  the objective value resulting form nonbasic variables for #COLUMN
-    *  Representation.
-    */
-   R nonbasicValue();
-
-   /// Get pointer to the \p id 'th vector
-   virtual const SVectorBase<R>* enterVector(const SPxId& p_id)
-   {
-      assert(p_id.isValid());
-      return p_id.isSPxRowId()
-             ? &vector(SPxRowId(p_id)) : &vector(SPxColId(p_id));
-   }
-   ///
-   virtual void getLeaveVals(int i,
-                             typename SPxBasisBase<R>::Desc::Status& leaveStat, SPxId& leaveId,
-                             R& leaveMax, R& leavebound, int& leaveNum, StableSum<R>& objChange);
-   ///
-   virtual void getLeaveVals2(R leaveMax, SPxId enterId,
-                              R& enterBound, R& newUBbound,
-                              R& newLBbound, R& newCoPrhs, StableSum<R>& objChange);
-   ///
-   virtual void getEnterVals(SPxId id, R& enterTest,
-                             R& enterUB, R& enterLB, R& enterVal, R& enterMax,
-                             R& enterPric, typename SPxBasisBase<R>::Desc::Status& enterStat, R& enterRO,
-                             StableSum<R>& objChange);
-   ///
-   virtual void getEnterVals2(int leaveIdx,
-                              R enterMax, R& leaveBound, StableSum<R>& objChange);
-   ///
-   virtual void ungetEnterVal(SPxId enterId, typename SPxBasisBase<R>::Desc::Status enterStat,
-                              R leaveVal, const SVectorBase<R>& vec, StableSum<R>& objChange);
-   ///
-   virtual void rejectEnter(SPxId enterId,
-                            R enterTest, typename SPxBasisBase<R>::Desc::Status enterStat);
-   ///
-   virtual void rejectLeave(int leaveNum, SPxId leaveId,
-                            typename SPxBasisBase<R>::Desc::Status leaveStat, const SVectorBase<R>* newVec = 0);
-   ///
-   virtual void setupPupdate(void);
-   ///
-   virtual void doPupdate(void);
-   ///
-   virtual void clearUpdateVecs(void);
-   ///
-   virtual void perturbMinEnter(void);
-   /// perturb basis bounds.
-   virtual void perturbMaxEnter(void);
-   ///
-   virtual void perturbMinLeave(void);
-   /// perturb nonbasic bounds.
-   virtual void perturbMaxLeave(void);
-   ///@}
-
-   //------------------------------------
-   /** The following methods serve for initializing the bounds for dual or
-    *  primal Simplex algorithm of entering or leaving type.
-    */
-   ///@{
-   ///
-   void clearDualBounds(typename SPxBasisBase<R>::Desc::Status, R&, R&) const;
-   ///
-   void setDualColBounds();
-   ///
-   void setDualRowBounds();
-   /// setup feasibility bounds for entering algorithm
-   void setPrimalBounds();
-   ///
-   void setEnterBound4Col(int, int);
-   ///
-   void setEnterBound4Row(int, int);
-   ///
-   virtual void setEnterBounds();
-   ///
-   void setLeaveBound4Row(int i, int n);
-   ///
-   void setLeaveBound4Col(int i, int n);
-   ///
-   virtual void setLeaveBounds();
-   ///@}
-
-   //------------------------------------
-   /** Compute the primal ray or the farkas proof in case of unboundedness
-    *  or infeasibility.
-    */
-   ///@{
-   ///
-   void computePrimalray4Col(R direction, SPxId enterId);
-   ///
-   void computePrimalray4Row(R direction);
-   ///
-   void computeDualfarkas4Col(R direction);
-   ///
-   void computeDualfarkas4Row(R direction, SPxId enterId);
-   ///@}
+  /// converts VarStatus to basis status for columns
+  typename SPxBasisBase<R>::Desc::Status
+  varStatusToBasisStatusCol(int col, VarStatus stat) const;
 
 public:
+  /// gets basis status for a single row
+  VarStatus getBasisRowStatus(int row) const;
 
-   //------------------------------------
-   /** Limits and status inquiry */
-   ///@{
-   /// set time limit.
-   virtual void setTerminationTime(Real time = infinity);
-   /// return time limit.
-   virtual Real terminationTime() const;
-   /// set iteration limit.
-   virtual void setTerminationIter(int iteration = -1);
-   /// return iteration limit.
-   virtual int terminationIter() const;
-   /// set objective limit.
-   virtual void setTerminationValue(R value = R(infinity));
-   /// return objective limit.
-   virtual R terminationValue() const;
-   /// get objective value of current solution.
-   virtual R objValue()
-   {
-      return value();
-   }
-   /// get all results of last solve.
-   Status
-   getResult(R* value = 0, VectorBase<R>* primal = 0,
-             VectorBase<R>* slacks = 0, VectorBase<R>* dual = 0,
-             VectorBase<R>* reduCost = 0);
+  /// gets basis status for a single column
+  VarStatus getBasisColStatus(int col) const;
 
-protected:
+  /// get current basis, and return solver status.
+  Status getBasis(VarStatus rows[], VarStatus cols[], const int rowsSize = -1,
+                  const int colsSize = -1) const;
 
-   /**@todo put the following basis methods near the variable status methods!*/
-   /// converts basis status to VarStatus
-   VarStatus basisStatusToVarStatus(typename SPxBasisBase<R>::Desc::Status stat) const;
+  /// gets basis status
+  typename SPxBasisBase<R>::SPxStatus getBasisStatus() const {
+    return SPxBasisBase<R>::status();
+  }
 
-   /// converts VarStatus to basis status for rows
-   typename SPxBasisBase<R>::Desc::Status varStatusToBasisStatusRow(int row, VarStatus stat)
-   const;
+  /// check a given basis for validity.
+  bool isBasisValid(DataArray<VarStatus> rows, DataArray<VarStatus> cols);
 
-   /// converts VarStatus to basis status for columns
-   typename SPxBasisBase<R>::Desc::Status varStatusToBasisStatusCol(int col, VarStatus stat)
-   const;
+  /// set the lp solver's basis.
+  void setBasis(const VarStatus rows[], const VarStatus cols[]);
 
-public:
+  /// set the lp solver's basis status.
+  void setBasisStatus(typename SPxBasisBase<R>::SPxStatus stat) {
+    if (m_status == OPTIMAL)
+      m_status = UNKNOWN;
+
+    SPxBasisBase<R>::setStatus(stat);
+  }
+
+  /// setting the solver status external from the solve loop.
+  void setSolverStatus(typename SPxSolverBase<R>::Status stat) {
+    m_status = stat;
+  }
+
+  /// get level of dual degeneracy
+  // this function is used for the improved dual simplex
+  R getDegeneracyLevel(VectorBase<R> degenvec);
+
+  /// get number of dual norms
+  void getNdualNorms(int &nnormsRow, int &nnormsCol) const;
+
+  /// get dual norms
+  bool getDualNorms(int &nnormsRow, int &nnormsCol, R *norms) const;
+
+  /// set dual norms
+  bool setDualNorms(int nnormsRow, int nnormsCol, R *norms);
+
+  /// pass integrality information about the variables to the solver
+  void setIntegralityInformation(int ncols, int *intInfo);
+
+  /// reset cumulative time counter to zero.
+  void resetCumulativeTime() { theCumulativeTime = 0.0; }
+
+  /// get number of bound flips.
+  int boundFlips() const { return totalboundflips; }
+
+  /// get number of dual degenerate pivots
+  int dualDegeneratePivots() {
+    return (rep() == ROW) ? enterCycles : leaveCycles;
+  }
+
+  /// get number of primal degenerate pivots
+  int primalDegeneratePivots() {
+    return (rep() == ROW) ? leaveCycles : enterCycles;
+  }
 
-   /// gets basis status for a single row
-   VarStatus getBasisRowStatus(int row) const;
-
-   /// gets basis status for a single column
-   VarStatus getBasisColStatus(int col) const;
-
-   /// get current basis, and return solver status.
-   Status getBasis(VarStatus rows[], VarStatus cols[], const int rowsSize = -1,
-                   const int colsSize = -1) const;
-
-   /// gets basis status
-   typename SPxBasisBase<R>::SPxStatus getBasisStatus() const
-   {
-      return SPxBasisBase<R>::status();
-   }
-
-   /// check a given basis for validity.
-   bool isBasisValid(DataArray<VarStatus> rows, DataArray<VarStatus> cols);
-
-   /// set the lp solver's basis.
-   void setBasis(const VarStatus rows[], const VarStatus cols[]);
-
-   /// set the lp solver's basis status.
-   void setBasisStatus(typename SPxBasisBase<R>::SPxStatus stat)
-   {
-      if(m_status == OPTIMAL)
-         m_status = UNKNOWN;
-
-      SPxBasisBase<R>::setStatus(stat);
-   }
-
-   /// setting the solver status external from the solve loop.
-   void setSolverStatus(typename SPxSolverBase<R>::Status stat)
-   {
-      m_status = stat;
-   }
-
-   /// get level of dual degeneracy
-   // this function is used for the improved dual simplex
-   R getDegeneracyLevel(VectorBase<R> degenvec);
-
-   /// get number of dual norms
-   void getNdualNorms(int& nnormsRow, int& nnormsCol) const;
-
-   /// get dual norms
-   bool getDualNorms(int& nnormsRow, int& nnormsCol, R* norms) const;
-
-   /// set dual norms
-   bool setDualNorms(int nnormsRow, int nnormsCol, R* norms);
-
-   /// pass integrality information about the variables to the solver
-   void setIntegralityInformation(int ncols, int* intInfo);
-
-   /// reset cumulative time counter to zero.
-   void resetCumulativeTime()
-   {
-      theCumulativeTime = 0.0;
-   }
-
-   /// get number of bound flips.
-   int boundFlips() const
-   {
-      return totalboundflips;
-   }
-
-   /// get number of dual degenerate pivots
-   int dualDegeneratePivots()
-   {
-      return (rep() == ROW) ? enterCycles : leaveCycles;
-   }
-
-   /// get number of primal degenerate pivots
-   int primalDegeneratePivots()
-   {
-      return (rep() == ROW) ? leaveCycles : enterCycles;
-   }
-
-   /// get the sum of dual degeneracy
-   R sumDualDegeneracy()
-   {
-      return dualDegenSum;
-   }
-
-   /// get the sum of primal degeneracy
-   R sumPrimalDegeneracy()
-   {
-      return primalDegenSum;
-   }
-
-   /// get number of iterations of current solution.
-   int iterations() const
-   {
-      return basis().iteration();
-   }
-
-   /// return number of iterations done with primal algorithm
-   int primalIterations()
-   {
-      assert(iterations() == 0 || primalCount <= iterations());
-      return (iterations() == 0) ? 0 : primalCount;
-   }
-
-   /// return number of iterations done with primal algorithm
-   int dualIterations()
-   {
-      return iterations() - primalIterations();
-   }
-
-   /// return number of iterations done with primal algorithm
-   int polishIterations()
-   {
-      return polishCount;
-   }
-
-   /// time spent in last call to method solve().
-   Real time() const
-   {
-      return theTime->time();
-   }
-
-   /// returns whether current time limit is reached; call to time() may be skipped unless \p forceCheck is true
-   ///
-   bool isTimeLimitReached(const bool forceCheck = false);
-
-   /// the maximum runtime
-   Real getMaxTime()
-   {
-      return maxTime;
-   }
-
-   /// cumulative time spent in all calls to method solve().
-   Real cumulativeTime() const
-   {
-      return theCumulativeTime;
-   }
-
-   /// the maximum number of iterations
-   int getMaxIters()
-   {
-      return maxIters;
-   }
-
-   /// return const lp's rows if available.
-   const LPRowSetBase<R>& rows() const
-   {
-      return *this->lprowset();
-   }
-
-   /// return const lp's cols if available.
-   const LPColSet& cols() const
-   {
-      return *this->lpcolset();
-   }
-
-   /// copy lower bound VectorBase<R> to \p p_low.
-   void getLower(VectorBase<R>& p_low) const
-   {
-      p_low = SPxLPBase<R>::lower();
-   }
-   /// copy upper bound VectorBase<R> to \p p_up.
-   void getUpper(VectorBase<R>& p_up) const
-   {
-      p_up = SPxLPBase<R>::upper();
-   }
-
-   /// copy lhs value VectorBase<R> to \p p_lhs.
-   void getLhs(VectorBase<R>& p_lhs) const
-   {
-      p_lhs = SPxLPBase<R>::lhs();
-   }
-
-   /// copy rhs value VectorBase<R> to \p p_rhs.
-   void getRhs(VectorBase<R>& p_rhs) const
-   {
-      p_rhs = SPxLPBase<R>::rhs();
-   }
-
-   /// optimization sense.
-   typename SPxLPBase<R>::SPxSense sense() const
-   {
-      return this->spxSense();
-   }
-
-   /// returns statistical information in form of a string.
-   std::string statistics() const
-   {
-      std::stringstream s;
-      s << basis().statistics()
-        << "Solution time      : " << std::setw(10) << std::fixed << std::setprecision(
-           2) << time() << std::endl
-        << "Iterations         : " << std::setw(10) << iterations() << std::endl;
-
-      return s.str();
-   }
-
-   /// returns whether a basis needs to be found for the improved dual simplex
-   DecompStatus getDecompStatus() const
-   {
-      if(getStartingDecompBasis)
-         return FINDSTARTBASIS;
-      else
-         return DONTFINDSTARTBASIS;
-   }
-
-   /// sets whether the degeneracy is computed at each iteration
-   void setComputeDegenFlag(bool computeDegen)
-   {
-      computeDegeneracy = computeDegen;
-   }
-
-
-   /// returns whether the degeneracy is computed in each iteration
-   bool getComputeDegeneracy() const
-   {
-      return computeDegeneracy;
-   }
-
-
-   /// sets the offset for the number of iterations before the degeneracy is computed
-   void setDegenCompOffset(int iterOffset)
-   {
-      degenCompIterOffset = iterOffset;
-   }
-
-
-   /// gets the offset for the number of iterations before the degeneracy is computed
-   int getDegenCompOffset() const
-   {
-      return degenCompIterOffset;
-   }
-
-   /// sets the iteration limit for the decomposition simplex initialisation
-   void setDecompIterationLimit(int iterationLimit)
-   {
-      decompIterationLimit = iterationLimit;
-   }
-
-   /// returns the iteration limit for the decomposition simplex initialisation
-   int getDecompIterationLimit() const
-   {
-      return decompIterationLimit;
-   }
-   ///@}
-
-   //------------------------------------
-   /** Mapping between numbers and Ids */
-   ///@{
-   /// RowId of \p i 'th inequality.
-   SPxRowId rowId(int i) const
-   {
-      return this->rId(i);
-   }
-   /// ColId of \p i 'th column.
-   SPxColId colId(int i) const
-   {
-      return this->cId(i);
-   }
-   ///@}
-
-   //------------------------------------
-   /** Constructors / destructors */
-   ///@{
-   /// default constructor.
-   explicit
-   SPxSolverBase(Type            type  = LEAVE,
-                 Representation  rep   = ROW,
-                 Timer::TYPE     ttype = Timer::USER_TIME);
-   // virtual destructor
-   virtual ~SPxSolverBase();
-   ///@}
-
-   //------------------------------------
-   /** Miscellaneous */
-   ///@{
-   /// check consistency.
-   bool isConsistent() const;
-   ///@}
-
-   //------------------------------------
-   /** assignment operator and copy constructor */
-   ///@{
-   /// assignment operator
-   SPxSolverBase<R>& operator=(const SPxSolverBase<R>& base);
-   /// copy constructor
-   SPxSolverBase(const SPxSolverBase<R>& base);
-   ///@}
-
-   void testVecs();
+  /// get the sum of dual degeneracy
+  R sumDualDegeneracy() { return dualDegenSum; }
+
+  /// get the sum of primal degeneracy
+  R sumPrimalDegeneracy() { return primalDegenSum; }
+
+  /// get number of iterations of current solution.
+  int iterations() const { return basis().iteration(); }
+
+  /// return number of iterations done with primal algorithm
+  int primalIterations() {
+    assert(iterations() == 0 || primalCount <= iterations());
+    return (iterations() == 0) ? 0 : primalCount;
+  }
+
+  /// return number of iterations done with primal algorithm
+  int dualIterations() { return iterations() - primalIterations(); }
+
+  /// return number of iterations done with primal algorithm
+  int polishIterations() { return polishCount; }
+
+  /// time spent in last call to method solve().
+  Real time() const { return theTime->time(); }
+
+  /// returns whether current time limit is reached; call to time() may be
+  /// skipped unless \p forceCheck is true
+  ///
+  bool isTimeLimitReached(const bool forceCheck = false);
+
+  /// the maximum runtime
+  Real getMaxTime() { return maxTime; }
+
+  /// cumulative time spent in all calls to method solve().
+  Real cumulativeTime() const { return theCumulativeTime; }
+
+  /// the maximum number of iterations
+  int getMaxIters() { return maxIters; }
+
+  /// return const lp's rows if available.
+  const LPRowSetBase<R> &rows() const { return *this->lprowset(); }
+
+  /// return const lp's cols if available.
+  const LPColSet &cols() const { return *this->lpcolset(); }
+
+  /// copy lower bound VectorBase<R> to \p p_low.
+  void getLower(VectorBase<R> &p_low) const { p_low = SPxLPBase<R>::lower(); }
+  /// copy upper bound VectorBase<R> to \p p_up.
+  void getUpper(VectorBase<R> &p_up) const { p_up = SPxLPBase<R>::upper(); }
+
+  /// copy lhs value VectorBase<R> to \p p_lhs.
+  void getLhs(VectorBase<R> &p_lhs) const { p_lhs = SPxLPBase<R>::lhs(); }
+
+  /// copy rhs value VectorBase<R> to \p p_rhs.
+  void getRhs(VectorBase<R> &p_rhs) const { p_rhs = SPxLPBase<R>::rhs(); }
+
+  /// optimization sense.
+  typename SPxLPBase<R>::SPxSense sense() const { return this->spxSense(); }
+
+  /// returns statistical information in form of a string.
+  std::string statistics() const {
+    std::stringstream s;
+    s << basis().statistics() << "Solution time      : " << std::setw(10)
+      << std::fixed << std::setprecision(2) << time() << std::endl
+      << "Iterations         : " << std::setw(10) << iterations() << std::endl;
+
+    return s.str();
+  }
+
+  /// returns whether a basis needs to be found for the improved dual simplex
+  DecompStatus getDecompStatus() const {
+    if (getStartingDecompBasis)
+      return FINDSTARTBASIS;
+    else
+      return DONTFINDSTARTBASIS;
+  }
+
+  /// sets whether the degeneracy is computed at each iteration
+  void setComputeDegenFlag(bool computeDegen) {
+    computeDegeneracy = computeDegen;
+  }
+
+  /// returns whether the degeneracy is computed in each iteration
+  bool getComputeDegeneracy() const { return computeDegeneracy; }
+
+  /// sets the offset for the number of iterations before the degeneracy is
+  /// computed
+  void setDegenCompOffset(int iterOffset) { degenCompIterOffset = iterOffset; }
+
+  /// gets the offset for the number of iterations before the degeneracy is
+  /// computed
+  int getDegenCompOffset() const { return degenCompIterOffset; }
+
+  /// sets the iteration limit for the decomposition simplex initialisation
+  void setDecompIterationLimit(int iterationLimit) {
+    decompIterationLimit = iterationLimit;
+  }
+
+  /// returns the iteration limit for the decomposition simplex initialisation
+  int getDecompIterationLimit() const { return decompIterationLimit; }
+  ///@}
+
+  //------------------------------------
+  /** Mapping between numbers and Ids */
+  ///@{
+  /// RowId of \p i 'th inequality.
+  SPxRowId rowId(int i) const { return this->rId(i); }
+  /// ColId of \p i 'th column.
+  SPxColId colId(int i) const { return this->cId(i); }
+  ///@}
+
+  //------------------------------------
+  /** Constructors / destructors */
+  ///@{
+  /// default constructor.
+  explicit SPxSolverBase(Type type = LEAVE, Representation rep = ROW,
+                         Timer::TYPE ttype = Timer::USER_TIME);
+  // virtual destructor
+  virtual ~SPxSolverBase();
+  ///@}
+
+  //------------------------------------
+  /** Miscellaneous */
+  ///@{
+  /// check consistency.
+  bool isConsistent() const;
+  ///@}
+
+  //------------------------------------
+  /** assignment operator and copy constructor */
+  ///@{
+  /// assignment operator
+  SPxSolverBase<R> &operator=(const SPxSolverBase<R> &base);
+  /// copy constructor
+  SPxSolverBase(const SPxSolverBase<R> &base);
+  ///@}
+
+  void testVecs();
 };
 
 //
@@ -2377,23 +2147,24 @@ public:
 
 /// Pretty-printing of variable status.
 template <class R>
-std::ostream& operator<<(std::ostream& os,
-                         const typename SPxSolverBase<R>::VarStatus& status);
+std::ostream &operator<<(std::ostream &os,
+                         const typename SPxSolverBase<R>::VarStatus &status);
 
 /// Pretty-printing of solver status.
 template <class R>
-std::ostream& operator<<(std::ostream& os,
-                         const typename SPxSolverBase<R>::Status& status);
+std::ostream &operator<<(std::ostream &os,
+                         const typename SPxSolverBase<R>::Status &status);
 
 /// Pretty-printing of algorithm.
 template <class R>
-std::ostream& operator<<(std::ostream& os,
-                         const typename SPxSolverBase<R>::Type& status);
+std::ostream &operator<<(std::ostream &os,
+                         const typename SPxSolverBase<R>::Type &status);
 
 /// Pretty-printing of representation.
 template <class R>
-std::ostream& operator<<(std::ostream& os,
-                         const typename SPxSolverBase<R>::Representation& status);
+std::ostream &
+operator<<(std::ostream &os,
+           const typename SPxSolverBase<R>::Representation &status);
 
 /* For Backwards compatibility */
 typedef SPxSolverBase<Real> SPxSolver;
@@ -2401,17 +2172,17 @@ typedef SPxSolverBase<Real> SPxSolver;
 } // namespace soplex
 
 // For general templated functions
-#include "spxsolver.hpp"
-#include "spxsolve.hpp"
 #include "changesoplex.hpp"
-#include "leave.hpp"
 #include "enter.hpp"
-#include "spxshift.hpp"
+#include "leave.hpp"
 #include "spxbounds.hpp"
 #include "spxchangebasis.hpp"
-#include "spxvecs.hpp"
-#include "spxwritestate.hpp"
 #include "spxfileio.hpp"
 #include "spxquality.hpp"
+#include "spxshift.hpp"
+#include "spxsolve.hpp"
+#include "spxsolver.hpp"
+#include "spxvecs.hpp"
+#include "spxwritestate.hpp"
 
 #endif // _SPXSOLVER_H_
diff --git a/src/soplex/spxsolver.hpp b/src/soplex/spxsolver.hpp
index 69e5364..694a88b 100644
--- a/src/soplex/spxsolver.hpp
+++ b/src/soplex/spxsolver.hpp
@@ -21,6 +21,7 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <assert.h>
 #include <iostream>
@@ -28,182 +29,162 @@
 
 #include "soplex/spxdefines.h"
 // #include "soplex.h"
+#include "soplex/spxout.h"
 #include "soplex/spxpricer.h"
 #include "soplex/spxratiotester.h"
 #include "soplex/spxstarter.h"
-#include "soplex/spxout.h"
 #include "soplex/timerfactory.h"
 
-namespace soplex
-{
+namespace soplex {
 template <class R>
-bool SPxSolverBase<R>::read(std::istream& in, NameSet* rowNames,
-                            NameSet* colNames, DIdxSet* intVars)
-{
-   if(initialized)
-   {
-      clear();
-      unInit();
+bool SPxSolverBase<R>::read(std::istream &in, NameSet *rowNames,
+                            NameSet *colNames, DIdxSet *intVars) {
+  if (initialized) {
+    clear();
+    unInit();
 
-      if(thepricer)
-         thepricer->clear();
+    if (thepricer)
+      thepricer->clear();
 
-      if(theratiotester)
-         theratiotester->clear();
-   }
+    if (theratiotester)
+      theratiotester->clear();
+  }
 
-   this->unLoad();
+  this->unLoad();
 
-   if(!SPxLPBase<R>::read(in, rowNames, colNames, intVars))
-      return false;
+  if (!SPxLPBase<R>::read(in, rowNames, colNames, intVars))
+    return false;
 
-   this->theLP = this;
+  this->theLP = this;
 
-   return true;
+  return true;
 }
 
-template <class R>
-void SPxSolverBase<R>::reLoad()
-{
-   forceRecompNonbasicValue();
-   unInit();
-   this->unLoad();
-   this->theLP = this;
-   m_status = SPxSolverBase<R>::UNKNOWN;
-
-   if(thepricer)
-      thepricer->clear();
+template <class R> void SPxSolverBase<R>::reLoad() {
+  forceRecompNonbasicValue();
+  unInit();
+  this->unLoad();
+  this->theLP = this;
+  m_status = SPxSolverBase<R>::UNKNOWN;
 
-   if(theratiotester)
-      theratiotester->clear();
+  if (thepricer)
+    thepricer->clear();
+
+  if (theratiotester)
+    theratiotester->clear();
 }
 
 template <class R>
-void SPxSolverBase<R>::loadLP(const SPxLPBase<R>& lp, bool initSlackBasis)
-{
-   clear();
-   unInit();
-   this->unLoad();
-   resetClockStats();
-
-   if(thepricer)
-      thepricer->clear();
+void SPxSolverBase<R>::loadLP(const SPxLPBase<R> &lp, bool initSlackBasis) {
+  clear();
+  unInit();
+  this->unLoad();
+  resetClockStats();
 
-   if(theratiotester)
-      theratiotester->clear();
+  if (thepricer)
+    thepricer->clear();
+
+  if (theratiotester)
+    theratiotester->clear();
 
-   SPxLPBase<R>::operator=(lp);
-   reDim();
-   SPxBasisBase<R>::load(this, initSlackBasis);
+  SPxLPBase<R>::operator=(lp);
+  reDim();
+  SPxBasisBase<R>::load(this, initSlackBasis);
 }
 
 template <class R>
-void SPxSolverBase<R>::setBasisSolver(SLinSolver<R>* slu, const bool destroy)
-{
-   // we need to set the outstream before we load the solver to ensure that the basis
-   // can be initialized with this pointer in loadSolver()
-   assert(spxout != 0);
-   slu->spxout = spxout;
-   SPxBasisBase<R>::loadBasisSolver(slu, destroy);
+void SPxSolverBase<R>::setBasisSolver(SLinSolver<R> *slu, const bool destroy) {
+  // we need to set the outstream before we load the solver to ensure that the
+  // basis can be initialized with this pointer in loadSolver()
+  assert(spxout != 0);
+  slu->spxout = spxout;
+  SPxBasisBase<R>::loadBasisSolver(slu, destroy);
 }
 
 template <class R>
-void SPxSolverBase<R>::loadBasis(const typename SPxBasisBase<R>::Desc& p_desc)
-{
-   unInit();
+void SPxSolverBase<R>::loadBasis(const typename SPxBasisBase<R>::Desc &p_desc) {
+  unInit();
 
-   if(SPxBasisBase<R>::status() == SPxBasisBase<R>::NO_PROBLEM)
-   {
-      SPxBasisBase<R>::load(this, false);
-   }
+  if (SPxBasisBase<R>::status() == SPxBasisBase<R>::NO_PROBLEM) {
+    SPxBasisBase<R>::load(this, false);
+  }
 
-   setBasisStatus(SPxBasisBase<R>::REGULAR);
-   SPxBasisBase<R>::loadDesc(p_desc);
+  setBasisStatus(SPxBasisBase<R>::REGULAR);
+  SPxBasisBase<R>::loadDesc(p_desc);
 }
 
 template <class R>
-void SPxSolverBase<R>::setPricer(SPxPricer<R>* x, const bool destroy)
-{
+void SPxSolverBase<R>::setPricer(SPxPricer<R> *x, const bool destroy) {
 
-   assert(!freePricer || thepricer != 0);
+  assert(!freePricer || thepricer != 0);
 
-   if(freePricer)
-   {
-      delete thepricer;
-      thepricer = 0;
-   }
+  if (freePricer) {
+    delete thepricer;
+    thepricer = 0;
+  }
 
-   if(x != 0 && x != thepricer)
-   {
-      setPricing(FULL);
+  if (x != 0 && x != thepricer) {
+    setPricing(FULL);
 
-      if(isInitialized())
-         x->load(this);
-      else
-         x->clear();
-   }
+    if (isInitialized())
+      x->load(this);
+    else
+      x->clear();
+  }
 
-   if(thepricer && thepricer != x)
-      thepricer->clear();
+  if (thepricer && thepricer != x)
+    thepricer->clear();
 
-   thepricer = x;
+  thepricer = x;
 
-   freePricer = destroy;
+  freePricer = destroy;
 }
 
 template <class R>
-void SPxSolverBase<R>::setTester(SPxRatioTester<R>* x, const bool destroy)
-{
-   assert(!freeRatioTester || theratiotester != 0);
+void SPxSolverBase<R>::setTester(SPxRatioTester<R> *x, const bool destroy) {
+  assert(!freeRatioTester || theratiotester != 0);
 
-   if(freeRatioTester)
-   {
-      delete theratiotester;
-      theratiotester = 0;
-   }
+  if (freeRatioTester) {
+    delete theratiotester;
+    theratiotester = 0;
+  }
 
-   theratiotester = x;
+  theratiotester = x;
 
-   // set the solver pointer inside the ratiotester
-   if(theratiotester != 0)
-   {
-      if(isInitialized())
-         theratiotester->load(this);
-      else
-         theratiotester->clear();
-   }
+  // set the solver pointer inside the ratiotester
+  if (theratiotester != 0) {
+    if (isInitialized())
+      theratiotester->load(this);
+    else
+      theratiotester->clear();
+  }
 
-   freeRatioTester = destroy;
+  freeRatioTester = destroy;
 }
 
 template <class R>
-void SPxSolverBase<R>::setStarter(SPxStarter<R>* x, const bool destroy)
-{
+void SPxSolverBase<R>::setStarter(SPxStarter<R> *x, const bool destroy) {
 
-   assert(!freeStarter || thestarter != 0);
+  assert(!freeStarter || thestarter != 0);
 
-   if(freeStarter)
-   {
-      delete thestarter;
-      thestarter = 0;
-   }
+  if (freeStarter) {
+    delete thestarter;
+    thestarter = 0;
+  }
 
-   thestarter = x;
+  thestarter = x;
 
-   freeStarter = destroy;
+  freeStarter = destroy;
 }
 
-template <class R>
-void SPxSolverBase<R>::setType(Type tp)
-{
+template <class R> void SPxSolverBase<R>::setType(Type tp) {
 
-   if(theType != tp)
-   {
-      theType = tp;
+  if (theType != tp) {
+    theType = tp;
 
-      forceRecompNonbasicValue();
+    forceRecompNonbasicValue();
 
-      unInit();
+    unInit();
 #if 0
       else
       {
@@ -217,2217 +198,1918 @@ void SPxSolverBase<R>::setType(Type tp)
          factorized = false;
          m_numCycle = 0;
 #endif
-         MSG_INFO3((*spxout), (*spxout) << "Switching to "
-                   << static_cast<const char*>((tp == LEAVE)
-                                               ? "leaving" : "entering")
-                   << " algorithm" << std::endl;)
-      }
-   }
-
-   template <class R>
-   void SPxSolverBase<R>::initRep(Representation p_rep)
-   {
-
-      R tmpfeastol = feastol();
-      R tmpopttol = opttol();
-
-      theRep = p_rep;
+    MSG_INFO3((*spxout),
+              (*spxout) << "Switching to "
+                        << static_cast<const char *>((tp == LEAVE) ? "leaving"
+                                                                   : "entering")
+                        << " algorithm" << std::endl;)
+  }
+}
 
-      if(theRep == COLUMN)
-      {
-         thevectors   = this->colSet();
-         thecovectors = this->rowSet();
-         theFrhs      = &primRhs;
-         theFvec      = &primVec;
-         theCoPrhs    = &dualRhs;
-         theCoPvec    = &dualVec;
-         thePvec      = &addVec;
-         theRPvec     = theCoPvec;
-         theCPvec     = thePvec;
-         theUbound    = &theUCbound;
-         theLbound    = &theLCbound;
-         theCoUbound  = &theURbound;
-         theCoLbound  = &theLRbound;
-      }
-      else
-      {
-         assert(theRep == ROW);
-
-         thevectors   = this->rowSet();
-         thecovectors = this->colSet();
-         theFrhs      = &dualRhs;
-         theFvec      = &dualVec;
-         theCoPrhs    = &primRhs;
-         theCoPvec    = &primVec;
-         thePvec      = &addVec;
-         theRPvec     = thePvec;
-         theCPvec     = theCoPvec;
-         theUbound    = &theURbound;
-         theLbound    = &theLRbound;
-         theCoUbound  = &theUCbound;
-         theCoLbound  = &theLCbound;
-      }
+template <class R> void SPxSolverBase<R>::initRep(Representation p_rep) {
+
+  R tmpfeastol = feastol();
+  R tmpopttol = opttol();
+
+  theRep = p_rep;
+
+  if (theRep == COLUMN) {
+    thevectors = this->colSet();
+    thecovectors = this->rowSet();
+    theFrhs = &primRhs;
+    theFvec = &primVec;
+    theCoPrhs = &dualRhs;
+    theCoPvec = &dualVec;
+    thePvec = &addVec;
+    theRPvec = theCoPvec;
+    theCPvec = thePvec;
+    theUbound = &theUCbound;
+    theLbound = &theLCbound;
+    theCoUbound = &theURbound;
+    theCoLbound = &theLRbound;
+  } else {
+    assert(theRep == ROW);
+
+    thevectors = this->rowSet();
+    thecovectors = this->colSet();
+    theFrhs = &dualRhs;
+    theFvec = &dualVec;
+    theCoPrhs = &primRhs;
+    theCoPvec = &primVec;
+    thePvec = &addVec;
+    theRPvec = thePvec;
+    theCPvec = theCoPvec;
+    theUbound = &theURbound;
+    theLbound = &theLRbound;
+    theCoUbound = &theUCbound;
+    theCoLbound = &theLCbound;
+  }
+
+  unInit();
+  reDim();
+
+  forceRecompNonbasicValue();
+
+  setFeastol(tmpfeastol);
+  setOpttol(tmpopttol);
+
+  SPxBasisBase<R>::setRep();
+
+  if (SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
+    SPxBasisBase<R>::loadDesc(this->desc());
+
+  if (thepricer && thepricer->solver() == this)
+    thepricer->setRep(p_rep);
+}
 
-      unInit();
-      reDim();
+template <class R> void SPxSolverBase<R>::setRep(Representation p_rep) {
 
-      forceRecompNonbasicValue();
+  if (p_rep != theRep)
+    initRep(p_rep);
+}
 
-      setFeastol(tmpfeastol);
-      setOpttol(tmpopttol);
+// needed for strongbranching. use carefully
+template <class R> void SPxSolverBase<R>::reinitializeVecs() {
+
+  initialized = true;
+
+  if (type() == ENTER) {
+    if (rep() == COLUMN)
+      setPrimalBounds();
+    else
+      setDualRowBounds();
+
+    setEnterBounds();
+    computeEnterCoPrhs();
+  } else {
+    if (rep() == ROW)
+      setPrimalBounds();
+    else
+      setDualColBounds();
+
+    setLeaveBounds();
+    computeLeaveCoPrhs();
+  }
+
+  SPxBasisBase<R>::coSolve(*theCoPvec, *theCoPrhs);
+  computePvec();
+  computeFrhs();
+  SPxBasisBase<R>::solve(*theFvec, *theFrhs);
+
+  theShift = 0.0;
+  lastShift = 0.0;
+
+  if (type() == ENTER) {
+    computeCoTest();
+    computeTest();
+  } else {
+    computeFtest();
+  }
+
+  assert((testBounds(), 1));
+}
 
-      SPxBasisBase<R>::setRep();
+template <class R> void SPxSolverBase<R>::resetClockStats() {
+  nClckSkipsLeft = 0;
+  nCallsToTimelim = 0;
+  theCumulativeTime = 0.0;
+}
 
-      if(SPxBasisBase<R>::status() > SPxBasisBase<R>::NO_PROBLEM)
-         SPxBasisBase<R>::loadDesc(this->desc());
+template <class R> void SPxSolverBase<R>::init() {
+
+  assert(thepricer != 0);
+  assert(theratiotester != 0);
+
+  if (!initialized) {
+    initialized = true;
+    clearUpdateVecs();
+    reDim();
+
+    if (SPxBasisBase<R>::status() <= SPxBasisBase<R>::NO_PROBLEM ||
+        this->solver() != this)
+      SPxBasisBase<R>::load(this);
+
+    initialized = false;
+  }
+
+  if (!this->matrixIsSetup)
+    SPxBasisBase<R>::loadDesc(this->desc());
+
+  // Inna/Tobi: don't "upgrade" a singular basis to a regular one
+  if (SPxBasisBase<R>::status() == SPxBasisBase<R>::SINGULAR)
+    return;
+
+  // catch pathological case for LPs with zero constraints
+  if (dim() == 0) {
+    this->factorized = true;
+  }
+
+  // we better factorize explicitly before solving
+  if (!this->factorized) {
+    try {
+      SPxBasisBase<R>::factorize();
+    } catch (const SPxException &) {
+      // reload inital slack basis in case the factorization failed
+      assert(SPxBasisBase<R>::status() <= SPxBasisBase<R>::SINGULAR);
+      SPxBasisBase<R>::restoreInitialBasis();
+      SPxBasisBase<R>::factorize();
+      assert(this->factorized);
+    }
+  }
+
+  m_numCycle = 0;
+
+  if (type() == ENTER) {
+    if (rep() == COLUMN) {
+      setPrimalBounds();
+      setBasisStatus(SPxBasisBase<R>::PRIMAL);
+    } else {
+      setDualRowBounds();
+      setBasisStatus(SPxBasisBase<R>::DUAL);
+    }
+
+    setEnterBounds();
+    computeEnterCoPrhs();
+    // prepare support vectors for sparse pricing
+    infeasibilities.setMax(dim());
+    infeasibilitiesCo.setMax(coDim());
+    isInfeasible.reSize(dim());
+    isInfeasibleCo.reSize(coDim());
+    theratiotester->setDelta(entertol());
+  } else {
+    if (rep() == ROW) {
+      setPrimalBounds();
+      setBasisStatus(SPxBasisBase<R>::PRIMAL);
+    } else {
+      setDualColBounds();
+      setBasisStatus(SPxBasisBase<R>::DUAL);
+    }
+
+    setLeaveBounds();
+    computeLeaveCoPrhs();
+    // prepare support vectors for sparse pricing
+    infeasibilities.setMax(dim());
+    isInfeasible.reSize(dim());
+    theratiotester->setDelta(leavetol());
+  }
+
+  SPxBasisBase<R>::coSolve(*theCoPvec, *theCoPrhs);
+  computePvec();
+  computeFrhs();
+  SPxBasisBase<R>::solve(*theFvec, *theFrhs);
+
+  theShift = 0.0;
+
+  if (type() == ENTER) {
+    shiftFvec();
+    lastShift = theShift + entertol();
+
+    computeCoTest();
+    computeTest();
+  } else {
+    shiftPvec();
+    lastShift = theShift + leavetol();
+
+    computeFtest();
+  }
+
+  if (!initialized) {
+    // if(thepricer->solver() != this)
+    thepricer->load(this);
+    // if(theratiotester->solver() != this)
+    theratiotester->load(this);
+    initialized = true;
+  }
+}
 
-      if(thepricer && thepricer->solver() == this)
-         thepricer->setRep(p_rep);
-   }
+template <class R> void SPxSolverBase<R>::setPricing(Pricing pr) {
+  thePricing = pr;
 
-   template <class R>
-   void SPxSolverBase<R>::setRep(Representation p_rep)
-   {
+  if (initialized && type() == ENTER) {
+    computePvec();
+    computeCoTest();
+    computeTest();
+  }
+}
 
-      if(p_rep != theRep)
-         initRep(p_rep);
-   }
+template <class R>
+void SPxSolverBase<R>::setDecompStatus(DecompStatus decomp_stat) {
+  if (decomp_stat == FINDSTARTBASIS)
+    getStartingDecompBasis = true;
+  else
+    getStartingDecompBasis = false;
+}
 
-   // needed for strongbranching. use carefully
-   template <class R>
-   void SPxSolverBase<R>::reinitializeVecs()
-   {
+/*
+  The following method resizes all vectors and arrays of |SoPlex|
+  (excluding inherited vectors).
+*/
+template <class R> void SPxSolverBase<R>::reDim() {
+
+  int newsize = SPxLPBase<R>::nCols() > SPxLPBase<R>::nRows()
+                    ? SPxLPBase<R>::nCols()
+                    : SPxLPBase<R>::nRows();
+
+  if (newsize > unitVecs.size()) {
+    unitVecs.reSize(newsize);
+
+    while (newsize-- > 0)
+      unitVecs[newsize] = UnitVectorBase<R>(newsize);
+  }
+
+  if (isInitialized()) {
+    theFrhs->reDim(dim());
+    theFvec->reDim(dim());
+    thePvec->reDim(coDim());
+
+    theCoPrhs->reDim(dim());
+    theCoPvec->reDim(dim());
+
+    theTest.reDim(coDim());
+    theCoTest.reDim(dim());
+
+    theURbound.reDim(SPxLPBase<R>::nRows());
+    theLRbound.reDim(SPxLPBase<R>::nRows());
+    theUCbound.reDim(SPxLPBase<R>::nCols());
+    theLCbound.reDim(SPxLPBase<R>::nCols());
+    theUBbound.reDim(dim());
+    theLBbound.reDim(dim());
+  }
+}
 
-      initialized = true;
+template <class R> void SPxSolverBase<R>::clear() {
+  unitVecs.reSize(0);
+
+  dualRhs.clear();
+  dualVec.clear();
+  primRhs.clear();
+  primVec.clear();
+  addVec.clear();
+  theURbound.clear();
+  theLRbound.clear();
+  theUCbound.clear();
+  theLCbound.clear();
+  theTest.clear();
+  theCoTest.clear();
+
+  forceRecompNonbasicValue();
+  unInit();
+  SPxLPBase<R>::clear();
+  setBasisStatus(SPxBasisBase<R>::NO_PROBLEM);
+
+  // clear the basis only when theLP is present, because LP data (nrows, ncols)
+  // is used in reDim()
+  if (this->theLP != 0)
+    SPxBasisBase<R>::reDim();
+
+  infeasibilities.clear();
+  infeasibilitiesCo.clear();
+  isInfeasible.clear();
+  isInfeasibleCo.clear();
+}
 
-      if(type() == ENTER)
-      {
-         if(rep() == COLUMN)
-            setPrimalBounds();
-         else
-            setDualRowBounds();
+template <class R> void SPxSolverBase<R>::unscaleLPandReloadBasis() {
+  SPxLPBase<R>::unscaleLP();
+  SPxBasisBase<R>::invalidate();
+  unInit();
+  init();
+}
 
-         setEnterBounds();
-         computeEnterCoPrhs();
-      }
-      else
-      {
-         if(rep() == ROW)
-            setPrimalBounds();
-         else
-            setDualColBounds();
+template <class R> void SPxSolverBase<R>::invalidateBasis() {
+  SPxBasisBase<R>::invalidate();
+  unInit();
+  init();
+}
 
-         setLeaveBounds();
-         computeLeaveCoPrhs();
-      }
+template <class R> void SPxSolverBase<R>::clearUpdateVecs(void) {
+  theFvec->clearUpdate();
+  thePvec->clearUpdate();
+  theCoPvec->clearUpdate();
+  solveVector2 = 0;
+  solveVector3 = 0;
+  coSolveVector2 = 0;
+  coSolveVector3 = 0;
+}
 
-      SPxBasisBase<R>::coSolve(*theCoPvec, *theCoPrhs);
-      computePvec();
+/*
+  When the basis matrix factorization is recomputed from scratch,
+  we also recompute the vectors.
+*/
+template <class R> void SPxSolverBase<R>::factorize() {
+
+  MSG_INFO3((*spxout), (*spxout)
+                           << " --- refactorizing basis matrix" << std::endl;)
+
+  try {
+    SPxBasisBase<R>::factorize();
+  } catch (const SPxStatusException &) {
+    assert(SPxBasisBase<R>::status() == SPxBasisBase<R>::SINGULAR);
+    m_status = SINGULAR;
+    std::stringstream s;
+    s << "Basis is singular (numerical troubles, feastol = " << feastol()
+      << ", opttol = " << opttol() << ")";
+    throw SPxStatusException(s.str());
+  }
+
+  if (!initialized) {
+    init(); // not sure if init() is neccessary here
+    // we must not go on here because not all vectors (e.g. fVec) may be set up
+    // correctly
+    return;
+  }
+
+  if (SPxBasisBase<R>::status() >= SPxBasisBase<R>::REGULAR) {
+#ifndef NDEBUG
+    VectorBase<R> ftmp(fVec());
+    VectorBase<R> ptmp(pVec());
+    VectorBase<R> ctmp(coPvec());
+#endif // NDEBUG
+
+    if (type() == LEAVE) {
+      /* we have to recompute theFrhs, because roundoff errors can occur during
+       * updating, especially when columns/rows with large bounds are present
+       */
       computeFrhs();
       SPxBasisBase<R>::solve(*theFvec, *theFrhs);
-
-      theShift  = 0.0;
-      lastShift = 0.0;
-
-      if(type() == ENTER)
-      {
-         computeCoTest();
-         computeTest();
-      }
-      else
-      {
-         computeFtest();
-      }
-
-      assert((testBounds(), 1));
-   }
-
-   template <class R>
-   void SPxSolverBase<R>::resetClockStats()
-   {
-      nClckSkipsLeft = 0;
-      nCallsToTimelim = 0;
-      theCumulativeTime = 0.0;
-   }
-
-   template <class R>
-   void SPxSolverBase<R>::init()
-   {
-
-      assert(thepricer      != 0);
-      assert(theratiotester != 0);
-
-      if(!initialized)
-      {
-         initialized = true;
-         clearUpdateVecs();
-         reDim();
-
-         if(SPxBasisBase<R>::status() <= SPxBasisBase<R>::NO_PROBLEM || this->solver() != this)
-            SPxBasisBase<R>::load(this);
-
-         initialized = false;
-      }
-
-      if(!this->matrixIsSetup)
-         SPxBasisBase<R>::loadDesc(this->desc());
-
-      // Inna/Tobi: don't "upgrade" a singular basis to a regular one
-      if(SPxBasisBase<R>::status() == SPxBasisBase<R>::SINGULAR)
-         return;
-
-      // catch pathological case for LPs with zero constraints
-      if(dim() == 0)
-      {
-         this->factorized = true;
-      }
-
-      // we better factorize explicitly before solving
-      if(!this->factorized)
-      {
-         try
-         {
-            SPxBasisBase<R>::factorize();
-         }
-         catch(const SPxException&)
-         {
-            // reload inital slack basis in case the factorization failed
-            assert(SPxBasisBase<R>::status() <= SPxBasisBase<R>::SINGULAR);
-            SPxBasisBase<R>::restoreInitialBasis();
-            SPxBasisBase<R>::factorize();
-            assert(this->factorized);
-         }
-      }
-
-      m_numCycle = 0;
-
-      if(type() == ENTER)
-      {
-         if(rep() == COLUMN)
-         {
-            setPrimalBounds();
-            setBasisStatus(SPxBasisBase<R>::PRIMAL);
-         }
-         else
-         {
-            setDualRowBounds();
-            setBasisStatus(SPxBasisBase<R>::DUAL);
-         }
-
-         setEnterBounds();
-         computeEnterCoPrhs();
-         // prepare support vectors for sparse pricing
-         infeasibilities.setMax(dim());
-         infeasibilitiesCo.setMax(coDim());
-         isInfeasible.reSize(dim());
-         isInfeasibleCo.reSize(coDim());
-         theratiotester->setDelta(entertol());
-      }
-      else
-      {
-         if(rep() == ROW)
-         {
-            setPrimalBounds();
-            setBasisStatus(SPxBasisBase<R>::PRIMAL);
-         }
-         else
-         {
-            setDualColBounds();
-            setBasisStatus(SPxBasisBase<R>::DUAL);
-         }
-
-         setLeaveBounds();
-         computeLeaveCoPrhs();
-         // prepare support vectors for sparse pricing
-         infeasibilities.setMax(dim());
-         isInfeasible.reSize(dim());
-         theratiotester->setDelta(leavetol());
-      }
-
       SPxBasisBase<R>::coSolve(*theCoPvec, *theCoPrhs);
-      computePvec();
-      computeFrhs();
-      SPxBasisBase<R>::solve(*theFvec, *theFrhs);
 
-      theShift = 0.0;
+#ifndef NDEBUG
+      ftmp -= fVec();
+      ptmp -= pVec();
+      ctmp -= coPvec();
 
-      if(type() == ENTER)
-      {
-         shiftFvec();
-         lastShift = theShift + entertol();
+      if (ftmp.length() > DEFAULT_BND_VIOL) {
+        MSG_DEBUG(std::cout << "DSOLVE21 fVec:   " << ftmp.length()
+                            << std::endl;)
+        ftmp = fVec();
+        this->multBaseWith(ftmp);
+        ftmp -= fRhs();
 
-         computeCoTest();
-         computeTest();
+        if (ftmp.length() > DEFAULT_BND_VIOL)
+          MSG_INFO1((*spxout), (*spxout) << "ESOLVE29 " << this->iteration()
+                                         << ": fVec error = " << ftmp.length()
+                                         << " exceeding DEFAULT_BND_VIOL = "
+                                         << DEFAULT_BND_VIOL << std::endl;)
       }
-      else
-      {
-         shiftPvec();
-         lastShift = theShift + leavetol();
 
-         computeFtest();
-      }
+      if (ctmp.length() > DEFAULT_BND_VIOL) {
+        MSG_DEBUG(std::cout << "DSOLVE23 coPvec: " << ctmp.length()
+                            << std::endl;)
+        ctmp = coPvec();
+        this->multWithBase(ctmp);
+        ctmp -= coPrhs();
 
-      if(!initialized)
-      {
-         // if(thepricer->solver() != this)
-         thepricer->load(this);
-         // if(theratiotester->solver() != this)
-         theratiotester->load(this);
-         initialized = true;
+        if (ctmp.length() > DEFAULT_BND_VIOL)
+          MSG_INFO1((*spxout), (*spxout) << "ESOLVE30 " << this->iteration()
+                                         << ": coPvec error = " << ctmp.length()
+                                         << " exceeding DEFAULT_BND_VIOL = "
+                                         << DEFAULT_BND_VIOL << std::endl;)
       }
-   }
-
-   template <class R>
-   void SPxSolverBase<R>::setPricing(Pricing pr)
-   {
-      thePricing = pr;
 
-      if(initialized && type() == ENTER)
-      {
-         computePvec();
-         computeCoTest();
-         computeTest();
+      if (ptmp.length() > DEFAULT_BND_VIOL) {
+        MSG_DEBUG(std::cout << "DSOLVE24 pVec:   " << ptmp.length()
+                            << std::endl;)
       }
-   }
-
-   template <class R>
-   void SPxSolverBase<R>::setDecompStatus(DecompStatus decomp_stat)
-   {
-      if(decomp_stat == FINDSTARTBASIS)
-         getStartingDecompBasis = true;
-      else
-         getStartingDecompBasis = false;
-   }
 
-   /*
-     The following method resizes all vectors and arrays of |SoPlex|
-     (excluding inherited vectors).
-   */
-   template <class R>
-   void SPxSolverBase<R>::reDim()
-   {
+#endif // NDEBUG
 
-      int newsize = SPxLPBase<R>::nCols() > SPxLPBase<R>::nRows() ? SPxLPBase<R>::nCols() :
-                    SPxLPBase<R>::nRows();
+      computeFtest();
+    } else {
+      assert(type() == ENTER);
 
-      if(newsize > unitVecs.size())
-      {
-         unitVecs.reSize(newsize);
-
-         while(newsize-- > 0)
-            unitVecs[newsize] = UnitVectorBase<R>(newsize);
-      }
-
-      if(isInitialized())
-      {
-         theFrhs->reDim(dim());
-         theFvec->reDim(dim());
-         thePvec->reDim(coDim());
-
-         theCoPrhs->reDim(dim());
-         theCoPvec->reDim(dim());
-
-         theTest.reDim(coDim());
-         theCoTest.reDim(dim());
-
-         theURbound.reDim(SPxLPBase<R>::nRows());
-         theLRbound.reDim(SPxLPBase<R>::nRows());
-         theUCbound.reDim(SPxLPBase<R>::nCols());
-         theLCbound.reDim(SPxLPBase<R>::nCols());
-         theUBbound.reDim(dim());
-         theLBbound.reDim(dim());
-      }
-   }
-
-   template <class R>
-   void SPxSolverBase<R>::clear()
-   {
-      unitVecs.reSize(0);
-
-      dualRhs.clear();
-      dualVec.clear();
-      primRhs.clear();
-      primVec.clear();
-      addVec.clear();
-      theURbound.clear();
-      theLRbound.clear();
-      theUCbound.clear();
-      theLCbound.clear();
-      theTest.clear();
-      theCoTest.clear();
-
-      forceRecompNonbasicValue();
-      unInit();
-      SPxLPBase<R>::clear();
-      setBasisStatus(SPxBasisBase<R>::NO_PROBLEM);
-
-      // clear the basis only when theLP is present, because LP data (nrows, ncols) is used in reDim()
-      if(this->theLP != 0)
-         SPxBasisBase<R>::reDim();
-
-      infeasibilities.clear();
-      infeasibilitiesCo.clear();
-      isInfeasible.clear();
-      isInfeasibleCo.clear();
-   }
-
-   template <class R>
-   void SPxSolverBase<R>::unscaleLPandReloadBasis()
-   {
-      SPxLPBase<R>::unscaleLP();
-      SPxBasisBase<R>::invalidate();
-      unInit();
-      init();
-   }
-
-   template <class R>
-   void SPxSolverBase<R>::invalidateBasis()
-   {
-      SPxBasisBase<R>::invalidate();
-      unInit();
-      init();
-   }
-
-   template <class R>
-   void SPxSolverBase<R>::clearUpdateVecs(void)
-   {
-      theFvec->clearUpdate();
-      thePvec->clearUpdate();
-      theCoPvec->clearUpdate();
-      solveVector2 = 0;
-      solveVector3 = 0;
-      coSolveVector2 = 0;
-      coSolveVector3 = 0;
-   }
-
-   /*
-     When the basis matrix factorization is recomputed from scratch,
-     we also recompute the vectors.
-   */
-   template <class R>
-   void SPxSolverBase<R>::factorize()
-   {
-
-      MSG_INFO3((*spxout), (*spxout) << " --- refactorizing basis matrix" << std::endl;)
-
-      try
-      {
-         SPxBasisBase<R>::factorize();
-      }
-      catch(const SPxStatusException&)
-      {
-         assert(SPxBasisBase<R>::status() == SPxBasisBase<R>::SINGULAR);
-         m_status = SINGULAR;
-         std::stringstream s;
-         s << "Basis is singular (numerical troubles, feastol = " << feastol() << ", opttol = " << opttol()
-           << ")";
-         throw SPxStatusException(s.str());
-      }
-
-      if(!initialized)
-      {
-         init();  // not sure if init() is neccessary here
-         // we must not go on here because not all vectors (e.g. fVec) may be set up correctly
-         return;
-      }
-
-      if(SPxBasisBase<R>::status() >= SPxBasisBase<R>::REGULAR)
-      {
-#ifndef NDEBUG
-         VectorBase<R> ftmp(fVec());
-         VectorBase<R> ptmp(pVec());
-         VectorBase<R> ctmp(coPvec());
-#endif  // NDEBUG
-
-         if(type() == LEAVE)
-         {
-            /* we have to recompute theFrhs, because roundoff errors can occur during updating, especially when
-             * columns/rows with large bounds are present
-             */
-            computeFrhs();
-            SPxBasisBase<R>::solve(*theFvec, *theFrhs);
-            SPxBasisBase<R>::coSolve(*theCoPvec, *theCoPrhs);
-
-#ifndef NDEBUG
-            ftmp -= fVec();
-            ptmp -= pVec();
-            ctmp -= coPvec();
-
-            if(ftmp.length() > DEFAULT_BND_VIOL)
-            {
-               MSG_DEBUG(std::cout << "DSOLVE21 fVec:   " << ftmp.length() << std::endl;)
-               ftmp = fVec();
-               this->multBaseWith(ftmp);
-               ftmp -= fRhs();
-
-               if(ftmp.length() > DEFAULT_BND_VIOL)
-                  MSG_INFO1((*spxout), (*spxout) << "ESOLVE29 " << this->iteration() << ": fVec error = "
-                            << ftmp.length() << " exceeding DEFAULT_BND_VIOL = " << DEFAULT_BND_VIOL << std::endl;)
-               }
-
-            if(ctmp.length() > DEFAULT_BND_VIOL)
-            {
-               MSG_DEBUG(std::cout << "DSOLVE23 coPvec: " << ctmp.length() << std::endl;)
-               ctmp = coPvec();
-               this->multWithBase(ctmp);
-               ctmp -= coPrhs();
-
-               if(ctmp.length() > DEFAULT_BND_VIOL)
-                  MSG_INFO1((*spxout), (*spxout) << "ESOLVE30 " << this->iteration() << ": coPvec error = "
-                            << ctmp.length() << " exceeding DEFAULT_BND_VIOL = " << DEFAULT_BND_VIOL << std::endl;)
-               }
-
-            if(ptmp.length() > DEFAULT_BND_VIOL)
-            {
-               MSG_DEBUG(std::cout << "DSOLVE24 pVec:   " << ptmp.length() << std::endl;)
-            }
-
-#endif  // NDEBUG
-
-            computeFtest();
-         }
-         else
-         {
-            assert(type() == ENTER);
-
-            SPxBasisBase<R>::coSolve(*theCoPvec, *theCoPrhs);
-            computeCoTest();
+      SPxBasisBase<R>::coSolve(*theCoPvec, *theCoPrhs);
+      computeCoTest();
 
-            if(pricing() == FULL)
-            {
-               /* to save time only recompute the row activities (in row rep) when we are already nearly optimal to
-                * avoid missing any violations from previous updates */
-               if(rep() == ROW && m_pricingViolCo < entertol() && m_pricingViol < entertol())
-                  computePvec();
+      if (pricing() == FULL) {
+        /* to save time only recompute the row activities (in row rep) when we
+         * are already nearly optimal to avoid missing any violations from
+         * previous updates */
+        if (rep() == ROW && m_pricingViolCo < entertol() &&
+            m_pricingViol < entertol())
+          computePvec();
 
-               /* was deactivated, but this leads to warnings in testVecs() */
-               computeTest();
-            }
-         }
+        /* was deactivated, but this leads to warnings in testVecs() */
+        computeTest();
       }
+    }
+  }
 
 #ifdef ENABLE_ADDITIONAL_CHECKS
 
-      /* moved this test after the computation of fTest and coTest below, since these vectors might not be set up at top, e.g. for an initial basis */
-      if(SPxBasisBase<R>::status() > SPxBasisBase<R>::SINGULAR)
-         testVecs();
+  /* moved this test after the computation of fTest and coTest below, since
+   * these vectors might not be set up at top, e.g. for an initial basis */
+  if (SPxBasisBase<R>::status() > SPxBasisBase<R>::SINGULAR)
+    testVecs();
 
 #endif
-   }
-
-   /* We compute how much the current solution violates (primal or dual) feasibility. In the
-      row/enter or column/leave algorithm the maximum violation of dual feasibility is
-      computed. In the row/leave or column/enter algorithm the primal feasibility is checked.
-      Additionally, the violation from pricing is taken into account. */
-   template <class R>
-   R SPxSolverBase<R>::maxInfeas() const
-   {
-      R inf = 0.0;
-
-      if(type() == ENTER)
-      {
-         if(m_pricingViolUpToDate && m_pricingViolCoUpToDate)
-            inf = m_pricingViol + m_pricingViolCo;
-
-         for(int i = 0; i < dim(); i++)
-         {
-            if((*theFvec)[i] > theUBbound[i])
-               inf = MAXIMUM(inf, (*theFvec)[i] - theUBbound[i]);
-            else if((*theFvec)[i] < theLBbound[i])
-               inf = MAXIMUM(inf, theLBbound[i] - (*theFvec)[i]);
-         }
-      }
-      else
-      {
-         assert(type() == LEAVE);
-
-         if(m_pricingViolUpToDate)
-            inf = m_pricingViol;
-
-         for(int i = 0; i < dim(); i++)
-         {
-            if((*theCoPvec)[i] > (*theCoUbound)[i])
-               inf = MAXIMUM(inf, (*theCoPvec)[i] - (*theCoUbound)[i]);
-            else if((*theCoPvec)[i] < (*theCoLbound)[i])
-               inf = MAXIMUM(inf, (*theCoLbound)[i] - (*theCoPvec)[i]);
-         }
-
-         for(int i = 0; i < coDim(); i++)
-         {
-            if((*thePvec)[i] > (*theUbound)[i])
-               inf = MAXIMUM(inf, (*thePvec)[i] - (*theUbound)[i]);
-            else if((*thePvec)[i] < (*theLbound)[i])
-               inf = MAXIMUM(inf, (*theLbound)[i] - (*thePvec)[i]);
-         }
-      }
-
-      return inf;
-   }
-
-   /* check for (dual) violations above tol and immediately return false w/o checking the remaining values
-      This method is useful for verifying whether an objective limit can be used as termination criterion */
-   template <class R>
-   bool SPxSolverBase<R>::noViols(R tol) const
-   {
-      assert(tol >= 0.0);
-
-      if(type() == ENTER)
-      {
-         for(int i = 0; i < dim(); i++)
-         {
-            if((*theFvec)[i] - theUBbound[i] > tol)
-               return false;
-
-            if(theLBbound[i] - (*theFvec)[i] > tol)
-               return false;
-         }
-      }
-      else
-      {
-         assert(type() == LEAVE);
-
-         for(int i = 0; i < dim(); i++)
-         {
-            if((*theCoPvec)[i] - (*theCoUbound)[i] > tol)
-               return false;
-
-            if((*theCoLbound)[i] - (*theCoPvec)[i] > tol)
-               return false;
-         }
-
-         for(int i = 0; i < coDim(); i++)
-         {
-            if((*thePvec)[i] - (*theUbound)[i] > tol)
-               return false;
+}
 
-            if((*theLbound)[i] - (*thePvec)[i] > tol)
-               return false;
-         }
-      }
+/* We compute how much the current solution violates (primal or dual)
+   feasibility. In the row/enter or column/leave algorithm the maximum violation
+   of dual feasibility is computed. In the row/leave or column/enter algorithm
+   the primal feasibility is checked. Additionally, the violation from pricing
+   is taken into account. */
+template <class R> R SPxSolverBase<R>::maxInfeas() const {
+  R inf = 0.0;
+
+  if (type() == ENTER) {
+    if (m_pricingViolUpToDate && m_pricingViolCoUpToDate)
+      inf = m_pricingViol + m_pricingViolCo;
+
+    for (int i = 0; i < dim(); i++) {
+      if ((*theFvec)[i] > theUBbound[i])
+        inf = MAXIMUM(inf, (*theFvec)[i] - theUBbound[i]);
+      else if ((*theFvec)[i] < theLBbound[i])
+        inf = MAXIMUM(inf, theLBbound[i] - (*theFvec)[i]);
+    }
+  } else {
+    assert(type() == LEAVE);
+
+    if (m_pricingViolUpToDate)
+      inf = m_pricingViol;
+
+    for (int i = 0; i < dim(); i++) {
+      if ((*theCoPvec)[i] > (*theCoUbound)[i])
+        inf = MAXIMUM(inf, (*theCoPvec)[i] - (*theCoUbound)[i]);
+      else if ((*theCoPvec)[i] < (*theCoLbound)[i])
+        inf = MAXIMUM(inf, (*theCoLbound)[i] - (*theCoPvec)[i]);
+    }
+
+    for (int i = 0; i < coDim(); i++) {
+      if ((*thePvec)[i] > (*theUbound)[i])
+        inf = MAXIMUM(inf, (*thePvec)[i] - (*theUbound)[i]);
+      else if ((*thePvec)[i] < (*theLbound)[i])
+        inf = MAXIMUM(inf, (*theLbound)[i] - (*thePvec)[i]);
+    }
+  }
+
+  return inf;
+}
 
-      return true;
-   }
+/* check for (dual) violations above tol and immediately return false w/o
+   checking the remaining values This method is useful for verifying whether an
+   objective limit can be used as termination criterion */
+template <class R> bool SPxSolverBase<R>::noViols(R tol) const {
+  assert(tol >= 0.0);
+
+  if (type() == ENTER) {
+    for (int i = 0; i < dim(); i++) {
+      if ((*theFvec)[i] - theUBbound[i] > tol)
+        return false;
+
+      if (theLBbound[i] - (*theFvec)[i] > tol)
+        return false;
+    }
+  } else {
+    assert(type() == LEAVE);
+
+    for (int i = 0; i < dim(); i++) {
+      if ((*theCoPvec)[i] - (*theCoUbound)[i] > tol)
+        return false;
+
+      if ((*theCoLbound)[i] - (*theCoPvec)[i] > tol)
+        return false;
+    }
+
+    for (int i = 0; i < coDim(); i++) {
+      if ((*thePvec)[i] - (*theUbound)[i] > tol)
+        return false;
+
+      if ((*theLbound)[i] - (*thePvec)[i] > tol)
+        return false;
+    }
+  }
+
+  return true;
+}
 
-   template <class R>
-   R SPxSolverBase<R>::nonbasicValue()
-   {
-      int i;
-      StableSum<R> val;
-      const typename SPxBasisBase<R>::Desc& ds = this->desc();
+template <class R> R SPxSolverBase<R>::nonbasicValue() {
+  int i;
+  StableSum<R> val;
+  const typename SPxBasisBase<R>::Desc &ds = this->desc();
 
 #ifndef ENABLE_ADDITIONAL_CHECKS
 
-      // if the value is available we don't need to recompute it
-      if(m_nonbasicValueUpToDate)
-         return m_nonbasicValue;
+  // if the value is available we don't need to recompute it
+  if (m_nonbasicValueUpToDate)
+    return m_nonbasicValue;
 
 #endif
 
-      if(rep() == COLUMN)
-      {
-         if(type() == LEAVE)
-         {
-            for(i = this->nCols() - 1; i >= 0; --i)
-            {
-               switch(ds.colStatus(i))
-               {
-               case SPxBasisBase<R>::Desc::P_ON_UPPER :
-                  val += theUCbound[i] * SPxLPBase<R>::upper(i);
-                  //@ val += maxObj(i) * SPxLPBase<R>::upper(i);
-                  break;
-
-               case SPxBasisBase<R>::Desc::P_ON_LOWER :
-                  val += theLCbound[i] * SPxLPBase<R>::lower(i);
-                  //@ val += maxObj(i) * SPxLPBase<R>::lower(i);
-                  break;
-
-               case SPxBasisBase<R>::Desc::P_FIXED :
-                  assert(EQ(SPxLPBase<R>::lower(i), SPxLPBase<R>::upper(i)));
-                  val += this->maxObj(i) * SPxLPBase<R>::lower(i);
-                  break;
-
-               default:
-                  break;
-               }
-            }
-
-            for(i = this->nRows() - 1; i >= 0; --i)
-            {
-               switch(ds.rowStatus(i))
-               {
-               case SPxBasisBase<R>::Desc::P_ON_UPPER :
-                  val += theLRbound[i] * SPxLPBase<R>::rhs(i);
-                  break;
-
-               case SPxBasisBase<R>::Desc::P_ON_LOWER :
-                  val += theURbound[i] * SPxLPBase<R>::lhs(i);
-                  break;
-
-               case SPxBasisBase<R>::Desc::P_FIXED :
-                  assert(EQ(SPxLPBase<R>::lhs(i), SPxLPBase<R>::rhs(i)));
-                  val += this->maxRowObj(i) * SPxLPBase<R>::lhs(i);
-                  break;
-
-               default:
-                  break;
-               }
-            }
-         }
-         else
-         {
-            assert(type() == ENTER);
-
-            for(i = this->nCols() - 1; i >= 0; --i)
-            {
-               switch(ds.colStatus(i))
-               {
-               case SPxBasisBase<R>::Desc::P_ON_UPPER :
-                  val += this->maxObj(i) * theUCbound[i];
-                  break;
-
-               case SPxBasisBase<R>::Desc::P_ON_LOWER :
-                  val += this->maxObj(i) * theLCbound[i];
-                  break;
-
-               case SPxBasisBase<R>::Desc::P_FIXED :
-                  assert(EQ(theLCbound[i], theUCbound[i]));
-                  val += this->maxObj(i) * theLCbound[i];
-                  break;
-
-               default:
-                  break;
-               }
-            }
-
-            for(i = this->nRows() - 1; i >= 0; --i)
-            {
-               switch(ds.rowStatus(i))
-               {
-               case SPxBasisBase<R>::Desc::P_ON_UPPER :
-                  val += this->maxRowObj(i) * theLRbound[i];
-                  break;
-
-               case SPxBasisBase<R>::Desc::P_ON_LOWER :
-                  val += this->maxRowObj(i) * theURbound[i];
-                  break;
-
-               case SPxBasisBase<R>::Desc::P_FIXED :
-                  assert(EQ(theLRbound[i], theURbound[i]));
-                  val += this->maxRowObj(i) * theURbound[i];
-                  break;
-
-               default:
-                  break;
-               }
-            }
-         }
-      }
-      else
-      {
-         assert(rep() == ROW);
-         assert(type() == ENTER);
-
-         for(i = this->nCols() - 1; i >= 0; --i)
-         {
-            switch(ds.colStatus(i))
-            {
-            case SPxBasisBase<R>::Desc::D_ON_UPPER :
-               val += theUCbound[i] * this->lower(i);
-               break;
-
-            case SPxBasisBase<R>::Desc::D_ON_LOWER :
-               val += theLCbound[i] * this->upper(i);
-               break;
-
-            case SPxBasisBase<R>::Desc::D_ON_BOTH :
-               val += theLCbound[i] * this->upper(i);
-               val += theUCbound[i] * this->lower(i);
-               break;
-
-            default:
-               break;
-            }
-         }
-
-         for(i = this->nRows() - 1; i >= 0; --i)
-         {
-            switch(ds.rowStatus(i))
-            {
-            case SPxBasisBase<R>::Desc::D_ON_UPPER :
-               val += theURbound[i] * this->lhs(i);
-               break;
-
-            case SPxBasisBase<R>::Desc::D_ON_LOWER :
-               val += theLRbound[i] * this->rhs(i);
-               break;
-
-            case SPxBasisBase<R>::Desc::D_ON_BOTH :
-               val += theLRbound[i] * this->rhs(i);
-               val += theURbound[i] * this->lhs(i);
-               break;
-
-            default:
-               break;
-            }
-         }
-      }
-
-#ifdef ENABLE_ADDITIONAL_CHECKS
+  if (rep() == COLUMN) {
+    if (type() == LEAVE) {
+      for (i = this->nCols() - 1; i >= 0; --i) {
+        switch (ds.colStatus(i)) {
+        case SPxBasisBase<R>::Desc::P_ON_UPPER:
+          val += theUCbound[i] * SPxLPBase<R>::upper(i);
+          //@ val += maxObj(i) * SPxLPBase<R>::upper(i);
+          break;
+
+        case SPxBasisBase<R>::Desc::P_ON_LOWER:
+          val += theLCbound[i] * SPxLPBase<R>::lower(i);
+          //@ val += maxObj(i) * SPxLPBase<R>::lower(i);
+          break;
+
+        case SPxBasisBase<R>::Desc::P_FIXED:
+          assert(EQ(SPxLPBase<R>::lower(i), SPxLPBase<R>::upper(i)));
+          val += this->maxObj(i) * SPxLPBase<R>::lower(i);
+          break;
+
+        default:
+          break;
+        }
+      }
+
+      for (i = this->nRows() - 1; i >= 0; --i) {
+        switch (ds.rowStatus(i)) {
+        case SPxBasisBase<R>::Desc::P_ON_UPPER:
+          val += theLRbound[i] * SPxLPBase<R>::rhs(i);
+          break;
+
+        case SPxBasisBase<R>::Desc::P_ON_LOWER:
+          val += theURbound[i] * SPxLPBase<R>::lhs(i);
+          break;
+
+        case SPxBasisBase<R>::Desc::P_FIXED:
+          assert(EQ(SPxLPBase<R>::lhs(i), SPxLPBase<R>::rhs(i)));
+          val += this->maxRowObj(i) * SPxLPBase<R>::lhs(i);
+          break;
+
+        default:
+          break;
+        }
+      }
+    } else {
+      assert(type() == ENTER);
+
+      for (i = this->nCols() - 1; i >= 0; --i) {
+        switch (ds.colStatus(i)) {
+        case SPxBasisBase<R>::Desc::P_ON_UPPER:
+          val += this->maxObj(i) * theUCbound[i];
+          break;
+
+        case SPxBasisBase<R>::Desc::P_ON_LOWER:
+          val += this->maxObj(i) * theLCbound[i];
+          break;
+
+        case SPxBasisBase<R>::Desc::P_FIXED:
+          assert(EQ(theLCbound[i], theUCbound[i]));
+          val += this->maxObj(i) * theLCbound[i];
+          break;
+
+        default:
+          break;
+        }
+      }
+
+      for (i = this->nRows() - 1; i >= 0; --i) {
+        switch (ds.rowStatus(i)) {
+        case SPxBasisBase<R>::Desc::P_ON_UPPER:
+          val += this->maxRowObj(i) * theLRbound[i];
+          break;
+
+        case SPxBasisBase<R>::Desc::P_ON_LOWER:
+          val += this->maxRowObj(i) * theURbound[i];
+          break;
+
+        case SPxBasisBase<R>::Desc::P_FIXED:
+          assert(EQ(theLRbound[i], theURbound[i]));
+          val += this->maxRowObj(i) * theURbound[i];
+          break;
+
+        default:
+          break;
+        }
+      }
+    }
+  } else {
+    assert(rep() == ROW);
+    assert(type() == ENTER);
+
+    for (i = this->nCols() - 1; i >= 0; --i) {
+      switch (ds.colStatus(i)) {
+      case SPxBasisBase<R>::Desc::D_ON_UPPER:
+        val += theUCbound[i] * this->lower(i);
+        break;
 
-      if(m_nonbasicValueUpToDate && NE(m_nonbasicValue, val))
-      {
-         MSG_ERROR(std::cerr << "stored nonbasic value: " << m_nonbasicValue
-                   << ", correct nonbasic value: " << val
-                   << ", violation: " << val - m_nonbasicValue << std::endl;)
-         assert(EQrel(m_nonbasicValue, val, 1e-12));
-      }
+      case SPxBasisBase<R>::Desc::D_ON_LOWER:
+        val += theLCbound[i] * this->upper(i);
+        break;
 
-#endif
+      case SPxBasisBase<R>::Desc::D_ON_BOTH:
+        val += theLCbound[i] * this->upper(i);
+        val += theUCbound[i] * this->lower(i);
+        break;
 
-      if(!m_nonbasicValueUpToDate)
-      {
-         m_nonbasicValue = R(val);
-         m_nonbasicValueUpToDate = true;
+      default:
+        break;
       }
+    }
 
-      return val;
-   }
-
-   template <class R>
-   R SPxSolverBase<R>::value()
-   {
-      assert(isInitialized());
+    for (i = this->nRows() - 1; i >= 0; --i) {
+      switch (ds.rowStatus(i)) {
+      case SPxBasisBase<R>::Desc::D_ON_UPPER:
+        val += theURbound[i] * this->lhs(i);
+        break;
 
-      R x;
+      case SPxBasisBase<R>::Desc::D_ON_LOWER:
+        val += theLRbound[i] * this->rhs(i);
+        break;
 
-      // calling value() without having a suitable status is an error.
-      if(!isInitialized())
-         return R(infinity);
+      case SPxBasisBase<R>::Desc::D_ON_BOTH:
+        val += theLRbound[i] * this->rhs(i);
+        val += theURbound[i] * this->lhs(i);
+        break;
 
-      if(rep() == ROW)
-      {
-         if(type() == LEAVE)
-            x = int(SPxLPBase<R>::spxSense()) * (coPvec() *
-                                                 fRhs()); // the contribution of maxRowObj() is missing
-         else
-            x = int(SPxLPBase<R>::spxSense()) * (nonbasicValue() + (coPvec() * fRhs()));
+      default:
+        break;
       }
-      else
-         x = int(SPxLPBase<R>::spxSense()) * (nonbasicValue() + fVec() * coPrhs());
-
-      return x + this->objOffset();
-   }
+    }
+  }
 
-   template <class R>
-   bool SPxSolverBase<R>::updateNonbasicValue(R objChange)
-   {
-      if(m_nonbasicValueUpToDate)
-         m_nonbasicValue += objChange;
+#ifdef ENABLE_ADDITIONAL_CHECKS
 
-      MSG_DEBUG(std::cout
-                << "Iteration: " << this->iteration()
-                << ": updated objValue: " << objChange
-                << ", new value: " << m_nonbasicValue
-                << ", correct value: " << nonbasicValue()
-                << std::endl;
-               )
+  if (m_nonbasicValueUpToDate && NE(m_nonbasicValue, val)) {
+    MSG_ERROR(std::cerr << "stored nonbasic value: " << m_nonbasicValue
+                        << ", correct nonbasic value: " << val
+                        << ", violation: " << val - m_nonbasicValue
+                        << std::endl;)
+    assert(EQrel(m_nonbasicValue, val, 1e-12));
+  }
 
-      return m_nonbasicValueUpToDate;
-   }
+#endif
 
+  if (!m_nonbasicValueUpToDate) {
+    m_nonbasicValue = R(val);
+    m_nonbasicValueUpToDate = true;
+  }
 
+  return val;
+}
 
-   template <class R>
-   void SPxSolverBase<R>::setFeastol(R d)
-   {
+template <class R> R SPxSolverBase<R>::value() {
+  assert(isInitialized());
 
-      if(d <= 0.0)
-         throw SPxInterfaceException("XSOLVE30 Cannot set feastol less than or equal to zero.");
+  R x;
 
-      if(theRep == COLUMN)
-         m_entertol = d;
-      else
-         m_leavetol = d;
-   }
+  // calling value() without having a suitable status is an error.
+  if (!isInitialized())
+    return R(infinity);
 
-   template <class R>
-   void SPxSolverBase<R>::setOpttol(R d)
-   {
+  if (rep() == ROW) {
+    if (type() == LEAVE)
+      x = int(SPxLPBase<R>::spxSense()) *
+          (coPvec() * fRhs()); // the contribution of maxRowObj() is missing
+    else
+      x = int(SPxLPBase<R>::spxSense()) *
+          (nonbasicValue() + (coPvec() * fRhs()));
+  } else
+    x = int(SPxLPBase<R>::spxSense()) * (nonbasicValue() + fVec() * coPrhs());
 
-      if(d <= 0.0)
-         throw SPxInterfaceException("XSOLVE31 Cannot set opttol less than or equal to zero.");
+  return x + this->objOffset();
+}
 
-      if(theRep == COLUMN)
-         m_leavetol = d;
-      else
-         m_entertol = d;
-   }
+template <class R> bool SPxSolverBase<R>::updateNonbasicValue(R objChange) {
+  if (m_nonbasicValueUpToDate)
+    m_nonbasicValue += objChange;
 
-   template <class R>
-   void SPxSolverBase<R>::setDelta(R d)
-   {
+  MSG_DEBUG(std::cout << "Iteration: " << this->iteration()
+                      << ": updated objValue: " << objChange
+                      << ", new value: " << m_nonbasicValue
+                      << ", correct value: " << nonbasicValue() << std::endl;)
 
-      if(d <= 0.0)
-         throw SPxInterfaceException("XSOLVE32 Cannot set delta less than or equal to zero.");
+  return m_nonbasicValueUpToDate;
+}
 
-      m_entertol = d;
-      m_leavetol = d;
-   }
+template <class R> void SPxSolverBase<R>::setFeastol(R d) {
 
-   template <class R>
-   void SPxSolverBase<R>::hyperPricing(bool h)
-   {
-      hyperPricingEnter = h;
-      hyperPricingLeave = h;
+  if (d <= 0.0)
+    throw SPxInterfaceException(
+        "XSOLVE30 Cannot set feastol less than or equal to zero.");
 
-      if(h)
-      {
-         updateViols.setMax(dim());
-         updateViolsCo.setMax(coDim());
-      }
-   }
-
-   template <class R>
-   SPxSolverBase<R>::SPxSolverBase(
-      Type            p_type,
-      Representation  p_rep,
-      Timer::TYPE     ttype)
-      : theType(p_type)
-      , thePricing(FULL)
-      , theRep(p_rep)
-      , polishObj(POLISH_OFF)
-      , theTime(nullptr)
-      , timerType(ttype)
-      , theCumulativeTime(0.0)
-      , maxIters(-1)
-      , maxTime(R(infinity))
-      , nClckSkipsLeft(0)
-      , nCallsToTimelim(0)
-      , objLimit(R(infinity))
-      , m_status(UNKNOWN)
-      , m_nonbasicValue(0.0)
-      , m_nonbasicValueUpToDate(false)
-      , m_pricingViol(0.0)
-      , m_pricingViolUpToDate(false)
-      , m_pricingViolCo(0.0)
-      , m_pricingViolCoUpToDate(false)
-      , m_numViol(0)
-      , theShift(0)
-      , m_maxCycle(100)
-      , m_numCycle(0)
-      , initialized(false)
-      , solveVector2(0)
-      , solveVector3(0)
-      , coSolveVector2(0)
-      , coSolveVector3(0)
-      , freePricer(false)
-      , freeRatioTester(false)
-      , freeStarter(false)
-      , displayLine(0)
-      , displayFreq(200)
-      , sparsePricingFactor(SPARSITYFACTOR)
-      , getStartingDecompBasis(false)
-      , computeDegeneracy(false)
-      , degenCompIterOffset(0)
-      , fullPerturbation(false)
-      , printBasisMetric(0)
-      , unitVecs(0)
-      , primVec(0, Param::epsilon())
-      , dualVec(0, Param::epsilon())
-      , addVec(0, Param::epsilon())
-      , thepricer(0)
-      , theratiotester(0)
-      , thestarter(0)
-      , boundrange(0.0)
-      , siderange(0.0)
-      , objrange(0.0)
-      , infeasibilities(0)
-      , infeasibilitiesCo(0)
-      , isInfeasible(0)
-      , isInfeasibleCo(0)
-      , sparsePricingLeave(false)
-      , sparsePricingEnter(false)
-      , sparsePricingEnterCo(false)
-      , hyperPricingLeave(true)
-      , hyperPricingEnter(true)
-      , remainingRoundsLeave(0)
-      , remainingRoundsEnter(0)
-      , remainingRoundsEnterCo(0)
-      , weights(0)
-      , coWeights(0)
-      , weightsAreSetup(false)
-      , multSparseCalls(0)
-      , multFullCalls(0)
-      , multColwiseCalls(0)
-      , multUnsetupCalls(0)
-      , integerVariables(0)
-   {
-      theTime = TimerFactory::createTimer(timerType);
-
-      multTimeSparse = TimerFactory::createTimer(timerType);
-      multTimeFull = TimerFactory::createTimer(timerType);
-      multTimeColwise = TimerFactory::createTimer(timerType);
-      multTimeUnsetup = TimerFactory::createTimer(timerType);
-
-      setDelta(DEFAULT_BND_VIOL);
-
-      this->theLP = this;
-      initRep(p_rep);
-
-      // info: SPxBasisBase is not consistent in this moment.
-      //assert(SPxSolverBase<R>::isConsistent());
-   }
-
-   template <class R>
-   SPxSolverBase<R>::~SPxSolverBase()
-   {
-      assert(!freePricer || thepricer != 0);
-      assert(!freeRatioTester || theratiotester != 0);
-      assert(!freeStarter || thestarter != 0);
-
-      if(freePricer)
-      {
-         delete thepricer;
-         thepricer = 0;
-      }
+  if (theRep == COLUMN)
+    m_entertol = d;
+  else
+    m_leavetol = d;
+}
 
-      if(freeRatioTester)
-      {
-         delete theratiotester;
-         theratiotester = 0;
-      }
+template <class R> void SPxSolverBase<R>::setOpttol(R d) {
 
-      if(freeStarter)
-      {
-         delete thestarter;
-         thestarter = 0;
-      }
+  if (d <= 0.0)
+    throw SPxInterfaceException(
+        "XSOLVE31 Cannot set opttol less than or equal to zero.");
 
-      // free the timers
-      assert(theTime);
-      assert(multTimeSparse);
-      assert(multTimeFull);
-      assert(multTimeColwise);
-      assert(multTimeUnsetup);
-      theTime->~Timer();
-      multTimeSparse->~Timer();
-      multTimeFull->~Timer();
-      multTimeColwise->~Timer();
-      multTimeUnsetup->~Timer();
-      spx_free(theTime);
-      spx_free(multTimeSparse);
-      spx_free(multTimeFull);
-      spx_free(multTimeColwise);
-      spx_free(multTimeUnsetup);
-   }
-
-
-   template <class R>
-   SPxSolverBase<R>& SPxSolverBase<R>::operator=(const SPxSolverBase<R>& base)
-   {
-      if(this != &base)
-      {
-         SPxLPBase<R>::operator=(base);
-         SPxBasisBase<R>::operator=(base);
-         theType = base.theType;
-         thePricing = base.thePricing;
-         theRep = base.theRep;
-         polishObj = base.polishObj;
-         timerType = base.timerType;
-         maxIters = base.maxIters;
-         maxTime = base.maxTime;
-         objLimit = base.objLimit;
-         m_status = base.m_status;
-         m_nonbasicValue = base.m_nonbasicValue;
-         m_nonbasicValueUpToDate = base.m_nonbasicValueUpToDate;
-         m_pricingViol = base.m_pricingViol;
-         m_pricingViolUpToDate = base.m_pricingViolUpToDate;
-         m_pricingViolCo = base.m_pricingViolCo;
-         m_pricingViolCoUpToDate = base.m_pricingViolCoUpToDate;
-         m_numViol = base.m_numViol;
-         m_entertol = base.m_entertol;
-         m_leavetol = base.m_leavetol;
-         theShift = base.theShift;
-         lastShift = base.lastShift;
-         m_maxCycle = base.m_maxCycle;
-         m_numCycle = base.m_numCycle;
-         initialized = base.initialized;
-         instableLeaveNum = base.instableLeaveNum;
-         instableLeave = base.instableLeave;
-         instableLeaveVal = base.instableLeaveVal;
-         instableEnterId = base.instableEnterId;
-         instableEnter = base.instableEnter;
-         instableEnterVal = base.instableEnterVal;
-         displayLine = base.displayLine;
-         displayFreq = base.displayFreq;
-         sparsePricingFactor = base.sparsePricingFactor;
-         getStartingDecompBasis = base.getStartingDecompBasis;
-         computeDegeneracy = base.computeDegeneracy;
-         degenCompIterOffset = base.degenCompIterOffset;
-         decompIterationLimit = base.decompIterationLimit;
-         fullPerturbation = base.fullPerturbation;
-         printBasisMetric = base.printBasisMetric;
-         unitVecs = base.unitVecs;
-         primRhs = base.primRhs;
-         primVec = base.primVec;
-         dualRhs = base.dualRhs;
-         dualVec = base.dualVec;
-         addVec = base.addVec;
-         theURbound = base.theURbound;
-         theLRbound = base.theLRbound;
-         theUCbound = base.theUCbound;
-         theLCbound = base.theLCbound;
-         theUBbound = base.theUBbound;
-         theLBbound = base.theLBbound;
-         theCoTest = base.theCoTest;
-         theTest = base.theTest;
-         primalRay = base.primalRay;
-         dualFarkas = base.dualFarkas;
-         leaveCount = base.leaveCount;
-         enterCount = base.enterCount;
-         theCumulativeTime = base.theCumulativeTime;
-         primalCount = base.primalCount;
-         polishCount = base.polishCount;
-         boundflips = base.boundflips;
-         totalboundflips = base.totalboundflips;
-         enterCycles = base.enterCycles;
-         leaveCycles = base.leaveCycles;
-         enterDegenCand = base.enterDegenCand;
-         leaveDegenCand = base.leaveDegenCand;
-         primalDegenSum = base.primalDegenSum;
-         boundrange = base.boundrange;
-         siderange = base.siderange;
-         objrange = base.objrange;
-         infeasibilities = base.infeasibilities;
-         infeasibilitiesCo = base.infeasibilitiesCo;
-         isInfeasible = base.isInfeasible;
-         isInfeasibleCo = base.isInfeasibleCo;
-         sparsePricingLeave = base.sparsePricingLeave;
-         sparsePricingEnter = base.sparsePricingEnter;
-         sparsePricingEnterCo = base.sparsePricingEnterCo;
-         sparsePricingFactor = base.sparsePricingFactor;
-         hyperPricingLeave = base.hyperPricingLeave;
-         hyperPricingEnter = base.hyperPricingEnter;
-         remainingRoundsLeave = base.remainingRoundsLeave;
-         remainingRoundsEnter = base.remainingRoundsEnter;
-         remainingRoundsEnterCo = base.remainingRoundsEnterCo;
-         weights = base.weights;
-         coWeights = base.coWeights;
-         weightsAreSetup = base.weightsAreSetup;
-         multSparseCalls = base.multSparseCalls;
-         multFullCalls = base.multFullCalls;
-         multColwiseCalls = base.multColwiseCalls;
-         multUnsetupCalls = base.multUnsetupCalls;
-         spxout = base.spxout;
-         integerVariables = base.integerVariables;
-
-         if(base.theRep == COLUMN)
-         {
-            thevectors   = this->colSet();
-            thecovectors = this->rowSet();
-            theFrhs      = &primRhs;
-            theFvec      = &primVec;
-            theCoPrhs    = &dualRhs;
-            theCoPvec    = &dualVec;
-            thePvec      = &addVec;
-            theRPvec     = theCoPvec;
-            theCPvec     = thePvec;
-            theUbound    = &theUCbound;
-            theLbound    = &theLCbound;
-            theCoUbound  = &theURbound;
-            theCoLbound  = &theLRbound;
-         }
-         else
-         {
-            assert(base.theRep == ROW);
-
-            thevectors   = this->rowSet();
-            thecovectors = this->colSet();
-            theFrhs      = &dualRhs;
-            theFvec      = &dualVec;
-            theCoPrhs    = &primRhs;
-            theCoPvec    = &primVec;
-            thePvec      = &addVec;
-            theRPvec     = thePvec;
-            theCPvec     = theCoPvec;
-            theUbound    = &theURbound;
-            theLbound    = &theLRbound;
-            theCoUbound  = &theUCbound;
-            theCoLbound  = &theLCbound;
-         }
+  if (theRep == COLUMN)
+    m_leavetol = d;
+  else
+    m_entertol = d;
+}
 
-         SPxBasisBase<R>::theLP = this;
+template <class R> void SPxSolverBase<R>::setDelta(R d) {
 
-         assert(!freePricer || thepricer != 0);
-         assert(!freeRatioTester || theratiotester != 0);
-         assert(!freeStarter || thestarter != 0);
+  if (d <= 0.0)
+    throw SPxInterfaceException(
+        "XSOLVE32 Cannot set delta less than or equal to zero.");
 
-         // thepricer
-         if(freePricer)
-         {
-            delete thepricer;
-            thepricer = 0;
-         }
+  m_entertol = d;
+  m_leavetol = d;
+}
 
-         if(base.thepricer == 0)
-         {
-            thepricer = 0;
-            freePricer = false;
-         }
-         else
-         {
-            thepricer = base.thepricer->clone();
-            freePricer = true;
-            thepricer->load(this);
-         }
+template <class R> void SPxSolverBase<R>::hyperPricing(bool h) {
+  hyperPricingEnter = h;
+  hyperPricingLeave = h;
 
-         // theratiotester
-         if(freeRatioTester)
-         {
-            delete theratiotester;
-            theratiotester = 0;
-         }
-
-         if(base.theratiotester == 0)
-         {
-            theratiotester = 0;
-            freeRatioTester = false;
-         }
-         else
-         {
-            theratiotester = base.theratiotester->clone();
-            freeRatioTester = true;
-            theratiotester->load(this);
-         }
+  if (h) {
+    updateViols.setMax(dim());
+    updateViolsCo.setMax(coDim());
+  }
+}
 
-         // thestarter
-         if(freeStarter)
-         {
-            delete thestarter;
-            thestarter = 0;
-         }
+template <class R>
+SPxSolverBase<R>::SPxSolverBase(Type p_type, Representation p_rep,
+                                Timer::TYPE ttype)
+    : theType(p_type), thePricing(FULL), theRep(p_rep), polishObj(POLISH_OFF),
+      theTime(nullptr), timerType(ttype), theCumulativeTime(0.0), maxIters(-1),
+      maxTime(R(infinity)), nClckSkipsLeft(0), nCallsToTimelim(0),
+      objLimit(R(infinity)), m_status(UNKNOWN), m_nonbasicValue(0.0),
+      m_nonbasicValueUpToDate(false), m_pricingViol(0.0),
+      m_pricingViolUpToDate(false), m_pricingViolCo(0.0),
+      m_pricingViolCoUpToDate(false), m_numViol(0), theShift(0),
+      m_maxCycle(100), m_numCycle(0), initialized(false), solveVector2(0),
+      solveVector3(0), coSolveVector2(0), coSolveVector3(0), freePricer(false),
+      freeRatioTester(false), freeStarter(false), displayLine(0),
+      displayFreq(200), sparsePricingFactor(SPARSITYFACTOR),
+      getStartingDecompBasis(false), computeDegeneracy(false),
+      degenCompIterOffset(0), fullPerturbation(false), printBasisMetric(0),
+      unitVecs(0), primVec(0, Param::epsilon()), dualVec(0, Param::epsilon()),
+      addVec(0, Param::epsilon()), thepricer(0), theratiotester(0),
+      thestarter(0), boundrange(0.0), siderange(0.0), objrange(0.0),
+      infeasibilities(0), infeasibilitiesCo(0), isInfeasible(0),
+      isInfeasibleCo(0), sparsePricingLeave(false), sparsePricingEnter(false),
+      sparsePricingEnterCo(false), hyperPricingLeave(true),
+      hyperPricingEnter(true), remainingRoundsLeave(0), remainingRoundsEnter(0),
+      remainingRoundsEnterCo(0), weights(0), coWeights(0),
+      weightsAreSetup(false), multSparseCalls(0), multFullCalls(0),
+      multColwiseCalls(0), multUnsetupCalls(0), integerVariables(0) {
+  theTime = TimerFactory::createTimer(timerType);
+
+  multTimeSparse = TimerFactory::createTimer(timerType);
+  multTimeFull = TimerFactory::createTimer(timerType);
+  multTimeColwise = TimerFactory::createTimer(timerType);
+  multTimeUnsetup = TimerFactory::createTimer(timerType);
+
+  setDelta(DEFAULT_BND_VIOL);
+
+  this->theLP = this;
+  initRep(p_rep);
+
+  // info: SPxBasisBase is not consistent in this moment.
+  // assert(SPxSolverBase<R>::isConsistent());
+}
 
-         if(base.thestarter == 0)
-         {
-            thestarter = 0;
-            freeStarter = false;
-         }
-         else
-         {
-            thestarter = base.thestarter->clone();
-            freeStarter = true;
-         }
+template <class R> SPxSolverBase<R>::~SPxSolverBase() {
+  assert(!freePricer || thepricer != 0);
+  assert(!freeRatioTester || theratiotester != 0);
+  assert(!freeStarter || thestarter != 0);
+
+  if (freePricer) {
+    delete thepricer;
+    thepricer = 0;
+  }
+
+  if (freeRatioTester) {
+    delete theratiotester;
+    theratiotester = 0;
+  }
+
+  if (freeStarter) {
+    delete thestarter;
+    thestarter = 0;
+  }
+
+  // free the timers
+  assert(theTime);
+  assert(multTimeSparse);
+  assert(multTimeFull);
+  assert(multTimeColwise);
+  assert(multTimeUnsetup);
+  theTime->~Timer();
+  multTimeSparse->~Timer();
+  multTimeFull->~Timer();
+  multTimeColwise->~Timer();
+  multTimeUnsetup->~Timer();
+  spx_free(theTime);
+  spx_free(multTimeSparse);
+  spx_free(multTimeFull);
+  spx_free(multTimeColwise);
+  spx_free(multTimeUnsetup);
+}
 
-         assert(SPxSolverBase<R>::isConsistent());
-      }
+template <class R>
+SPxSolverBase<R> &SPxSolverBase<R>::operator=(const SPxSolverBase<R> &base) {
+  if (this != &base) {
+    SPxLPBase<R>::operator=(base);
+    SPxBasisBase<R>::operator=(base);
+    theType = base.theType;
+    thePricing = base.thePricing;
+    theRep = base.theRep;
+    polishObj = base.polishObj;
+    timerType = base.timerType;
+    maxIters = base.maxIters;
+    maxTime = base.maxTime;
+    objLimit = base.objLimit;
+    m_status = base.m_status;
+    m_nonbasicValue = base.m_nonbasicValue;
+    m_nonbasicValueUpToDate = base.m_nonbasicValueUpToDate;
+    m_pricingViol = base.m_pricingViol;
+    m_pricingViolUpToDate = base.m_pricingViolUpToDate;
+    m_pricingViolCo = base.m_pricingViolCo;
+    m_pricingViolCoUpToDate = base.m_pricingViolCoUpToDate;
+    m_numViol = base.m_numViol;
+    m_entertol = base.m_entertol;
+    m_leavetol = base.m_leavetol;
+    theShift = base.theShift;
+    lastShift = base.lastShift;
+    m_maxCycle = base.m_maxCycle;
+    m_numCycle = base.m_numCycle;
+    initialized = base.initialized;
+    instableLeaveNum = base.instableLeaveNum;
+    instableLeave = base.instableLeave;
+    instableLeaveVal = base.instableLeaveVal;
+    instableEnterId = base.instableEnterId;
+    instableEnter = base.instableEnter;
+    instableEnterVal = base.instableEnterVal;
+    displayLine = base.displayLine;
+    displayFreq = base.displayFreq;
+    sparsePricingFactor = base.sparsePricingFactor;
+    getStartingDecompBasis = base.getStartingDecompBasis;
+    computeDegeneracy = base.computeDegeneracy;
+    degenCompIterOffset = base.degenCompIterOffset;
+    decompIterationLimit = base.decompIterationLimit;
+    fullPerturbation = base.fullPerturbation;
+    printBasisMetric = base.printBasisMetric;
+    unitVecs = base.unitVecs;
+    primRhs = base.primRhs;
+    primVec = base.primVec;
+    dualRhs = base.dualRhs;
+    dualVec = base.dualVec;
+    addVec = base.addVec;
+    theURbound = base.theURbound;
+    theLRbound = base.theLRbound;
+    theUCbound = base.theUCbound;
+    theLCbound = base.theLCbound;
+    theUBbound = base.theUBbound;
+    theLBbound = base.theLBbound;
+    theCoTest = base.theCoTest;
+    theTest = base.theTest;
+    primalRay = base.primalRay;
+    dualFarkas = base.dualFarkas;
+    leaveCount = base.leaveCount;
+    enterCount = base.enterCount;
+    theCumulativeTime = base.theCumulativeTime;
+    primalCount = base.primalCount;
+    polishCount = base.polishCount;
+    boundflips = base.boundflips;
+    totalboundflips = base.totalboundflips;
+    enterCycles = base.enterCycles;
+    leaveCycles = base.leaveCycles;
+    enterDegenCand = base.enterDegenCand;
+    leaveDegenCand = base.leaveDegenCand;
+    primalDegenSum = base.primalDegenSum;
+    boundrange = base.boundrange;
+    siderange = base.siderange;
+    objrange = base.objrange;
+    infeasibilities = base.infeasibilities;
+    infeasibilitiesCo = base.infeasibilitiesCo;
+    isInfeasible = base.isInfeasible;
+    isInfeasibleCo = base.isInfeasibleCo;
+    sparsePricingLeave = base.sparsePricingLeave;
+    sparsePricingEnter = base.sparsePricingEnter;
+    sparsePricingEnterCo = base.sparsePricingEnterCo;
+    sparsePricingFactor = base.sparsePricingFactor;
+    hyperPricingLeave = base.hyperPricingLeave;
+    hyperPricingEnter = base.hyperPricingEnter;
+    remainingRoundsLeave = base.remainingRoundsLeave;
+    remainingRoundsEnter = base.remainingRoundsEnter;
+    remainingRoundsEnterCo = base.remainingRoundsEnterCo;
+    weights = base.weights;
+    coWeights = base.coWeights;
+    weightsAreSetup = base.weightsAreSetup;
+    multSparseCalls = base.multSparseCalls;
+    multFullCalls = base.multFullCalls;
+    multColwiseCalls = base.multColwiseCalls;
+    multUnsetupCalls = base.multUnsetupCalls;
+    spxout = base.spxout;
+    integerVariables = base.integerVariables;
+
+    if (base.theRep == COLUMN) {
+      thevectors = this->colSet();
+      thecovectors = this->rowSet();
+      theFrhs = &primRhs;
+      theFvec = &primVec;
+      theCoPrhs = &dualRhs;
+      theCoPvec = &dualVec;
+      thePvec = &addVec;
+      theRPvec = theCoPvec;
+      theCPvec = thePvec;
+      theUbound = &theUCbound;
+      theLbound = &theLCbound;
+      theCoUbound = &theURbound;
+      theCoLbound = &theLRbound;
+    } else {
+      assert(base.theRep == ROW);
+
+      thevectors = this->rowSet();
+      thecovectors = this->colSet();
+      theFrhs = &dualRhs;
+      theFvec = &dualVec;
+      theCoPrhs = &primRhs;
+      theCoPvec = &primVec;
+      thePvec = &addVec;
+      theRPvec = thePvec;
+      theCPvec = theCoPvec;
+      theUbound = &theURbound;
+      theLbound = &theLRbound;
+      theCoUbound = &theUCbound;
+      theCoLbound = &theLCbound;
+    }
+
+    SPxBasisBase<R>::theLP = this;
+
+    assert(!freePricer || thepricer != 0);
+    assert(!freeRatioTester || theratiotester != 0);
+    assert(!freeStarter || thestarter != 0);
+
+    // thepricer
+    if (freePricer) {
+      delete thepricer;
+      thepricer = 0;
+    }
 
-      return *this;
-   }
-
-
-   template <class R>
-   SPxSolverBase<R>::SPxSolverBase(const SPxSolverBase<R>& base)
-      : SPxLPBase<R> (base)
-      , SPxBasisBase<R>(this->basSe)
-      , theType(base.theType)
-      , thePricing(base.thePricing)
-      , theRep(base.theRep)
-      , polishObj(base.polishObj)
-      , timerType(base.timerType)
-      , theCumulativeTime(base.theCumulativeTime)
-      , maxIters(base.maxIters)
-      , maxTime(base.maxTime)
-      , nClckSkipsLeft(base.nClckSkipsLeft)
-      , nCallsToTimelim(base.nCallsToTimelim)
-      , objLimit(base.objLimit)
-      , m_status(base.m_status)
-      , m_nonbasicValue(base.m_nonbasicValue)
-      , m_nonbasicValueUpToDate(base.m_nonbasicValueUpToDate)
-      , m_pricingViol(base.m_pricingViol)
-      , m_pricingViolUpToDate(base.m_pricingViolUpToDate)
-      , m_pricingViolCo(base.m_pricingViolCo)
-      , m_pricingViolCoUpToDate(base.m_pricingViolCoUpToDate)
-      , m_numViol(base.m_numViol)
-      , m_entertol(base.m_entertol)
-      , m_leavetol(base.m_leavetol)
-      , theShift(base.theShift)
-      , lastShift(base.lastShift)
-      , m_maxCycle(base.m_maxCycle)
-      , m_numCycle(base.m_numCycle)
-      , initialized(base.initialized)
-      , solveVector2(0)
-      , solveVector2rhs(base.solveVector2rhs)
-      , solveVector3(0)
-      , solveVector3rhs(base.solveVector3rhs)
-      , coSolveVector2(0)
-      , coSolveVector2rhs(base.coSolveVector2rhs)
-      , coSolveVector3(0)
-      , coSolveVector3rhs(base.coSolveVector3rhs)
-      , instableLeaveNum(base.instableLeaveNum)
-      , instableLeave(base.instableLeave)
-      , instableLeaveVal(base.instableLeaveVal)
-      , instableEnterId(base.instableEnterId)
-      , instableEnter(base.instableEnter)
-      , instableEnterVal(base.instableEnterVal)
-      , displayLine(base.displayLine)
-      , displayFreq(base.displayFreq)
-      , sparsePricingFactor(base.sparsePricingFactor)
-      , getStartingDecompBasis(base.getStartingDecompBasis)
-      , computeDegeneracy(base.computeDegeneracy)
-      , degenCompIterOffset(base.degenCompIterOffset)
-      , decompIterationLimit(base.decompIterationLimit)
-      , fullPerturbation(base.fullPerturbation)
-      , printBasisMetric(base.printBasisMetric)
-      , unitVecs(base.unitVecs)
-      , primRhs(base.primRhs)
-      , primVec(base.primVec)
-      , dualRhs(base.dualRhs)
-      , dualVec(base.dualVec)
-      , addVec(base.addVec)
-      , theURbound(base.theURbound)
-      , theLRbound(base.theLRbound)
-      , theUCbound(base.theUCbound)
-      , theLCbound(base.theLCbound)
-      , theUBbound(base.theUBbound)
-      , theLBbound(base.theLBbound)
-      , theCoTest(base.theCoTest)
-      , theTest(base.theTest)
-      , primalRay(base.primalRay)
-      , dualFarkas(base.dualFarkas)
-      , leaveCount(base.leaveCount)
-      , enterCount(base.enterCount)
-      , primalCount(base.primalCount)
-      , polishCount(base.polishCount)
-      , boundflips(base.boundflips)
-      , totalboundflips(base.totalboundflips)
-      , enterCycles(base.enterCycles)
-      , leaveCycles(base.leaveCycles)
-      , enterDegenCand(base.enterDegenCand)
-      , leaveDegenCand(base.leaveDegenCand)
-      , primalDegenSum(base.primalDegenSum)
-      , dualDegenSum(base.dualDegenSum)
-      , boundrange(base.boundrange)
-      , siderange(base.siderange)
-      , objrange(base.objrange)
-      , infeasibilities(base.infeasibilities)
-      , infeasibilitiesCo(base.infeasibilitiesCo)
-      , isInfeasible(base.isInfeasible)
-      , isInfeasibleCo(base.isInfeasibleCo)
-      , sparsePricingLeave(base.sparsePricingLeave)
-      , sparsePricingEnter(base.sparsePricingEnter)
-      , sparsePricingEnterCo(base.sparsePricingEnterCo)
-      , hyperPricingLeave(base.hyperPricingLeave)
-      , hyperPricingEnter(base.hyperPricingEnter)
-      , remainingRoundsLeave(base.remainingRoundsLeave)
-      , remainingRoundsEnter(base.remainingRoundsEnter)
-      , remainingRoundsEnterCo(base.remainingRoundsEnterCo)
-      , weights(base.weights)
-      , coWeights(base.coWeights)
-      , weightsAreSetup(base.weightsAreSetup)
-      , multSparseCalls(base.multSparseCalls)
-      , multFullCalls(base.multFullCalls)
-      , multColwiseCalls(base.multColwiseCalls)
-      , multUnsetupCalls(base.multUnsetupCalls)
-      , spxout(base.spxout)
-      , integerVariables(base.integerVariables)
-   {
-      theTime = TimerFactory::createTimer(timerType);
-      multTimeSparse = TimerFactory::createTimer(timerType);
-      multTimeFull = TimerFactory::createTimer(timerType);
-      multTimeColwise = TimerFactory::createTimer(timerType);
-      multTimeUnsetup = TimerFactory::createTimer(timerType);
-
-      if(base.theRep == COLUMN)
-      {
-         thevectors   = this->colSet();
-         thecovectors = this->rowSet();
-         theFrhs      = &primRhs;
-         theFvec      = &primVec;
-         theCoPrhs    = &dualRhs;
-         theCoPvec    = &dualVec;
-         thePvec      = &addVec;
-         theRPvec     = theCoPvec;
-         theCPvec     = thePvec;
-         theUbound    = &theUCbound;
-         theLbound    = &theLCbound;
-         theCoUbound  = &theURbound;
-         theCoLbound  = &theLRbound;
-      }
-      else
-      {
-         assert(base.theRep == ROW);
-
-         thevectors   = this->rowSet();
-         thecovectors = this->colSet();
-         theFrhs      = &dualRhs;
-         theFvec      = &dualVec;
-         theCoPrhs    = &primRhs;
-         theCoPvec    = &primVec;
-         thePvec      = &addVec;
-         theRPvec     = thePvec;
-         theCPvec     = theCoPvec;
-         theUbound    = &theURbound;
-         theLbound    = &theLRbound;
-         theCoUbound  = &theUCbound;
-         theCoLbound  = &theLCbound;
-      }
+    if (base.thepricer == 0) {
+      thepricer = 0;
+      freePricer = false;
+    } else {
+      thepricer = base.thepricer->clone();
+      freePricer = true;
+      thepricer->load(this);
+    }
+
+    // theratiotester
+    if (freeRatioTester) {
+      delete theratiotester;
+      theratiotester = 0;
+    }
 
-      SPxBasisBase<R>::theLP = this;
+    if (base.theratiotester == 0) {
+      theratiotester = 0;
+      freeRatioTester = false;
+    } else {
+      theratiotester = base.theratiotester->clone();
+      freeRatioTester = true;
+      theratiotester->load(this);
+    }
+
+    // thestarter
+    if (freeStarter) {
+      delete thestarter;
+      thestarter = 0;
+    }
 
-      if(base.thepricer == 0)
-      {
-         thepricer = 0;
-         freePricer = false;
-      }
-      else
-      {
-         thepricer = base.thepricer->clone();
-         freePricer = true;
-         thepricer->clear();
-         thepricer->load(this);
-      }
+    if (base.thestarter == 0) {
+      thestarter = 0;
+      freeStarter = false;
+    } else {
+      thestarter = base.thestarter->clone();
+      freeStarter = true;
+    }
 
-      if(base.theratiotester == 0)
-      {
-         theratiotester = 0;
-         freeRatioTester = false;
-      }
-      else
-      {
-         theratiotester = base.theratiotester->clone();
-         freeRatioTester = true;
-         theratiotester->clear();
-         theratiotester->load(this);
-      }
+    assert(SPxSolverBase<R>::isConsistent());
+  }
 
-      if(base.thestarter == 0)
-      {
-         thestarter = 0;
-         freeStarter = false;
-      }
-      else
-      {
-         thestarter = base.thestarter->clone();
-         freeStarter = true;
-      }
+  return *this;
+}
 
-      assert(SPxSolverBase<R>::isConsistent());
-   }
+template <class R>
+SPxSolverBase<R>::SPxSolverBase(const SPxSolverBase<R> &base)
+    : SPxLPBase<R>(base), SPxBasisBase<R>(this->basSe), theType(base.theType),
+      thePricing(base.thePricing), theRep(base.theRep),
+      polishObj(base.polishObj), timerType(base.timerType),
+      theCumulativeTime(base.theCumulativeTime), maxIters(base.maxIters),
+      maxTime(base.maxTime), nClckSkipsLeft(base.nClckSkipsLeft),
+      nCallsToTimelim(base.nCallsToTimelim), objLimit(base.objLimit),
+      m_status(base.m_status), m_nonbasicValue(base.m_nonbasicValue),
+      m_nonbasicValueUpToDate(base.m_nonbasicValueUpToDate),
+      m_pricingViol(base.m_pricingViol),
+      m_pricingViolUpToDate(base.m_pricingViolUpToDate),
+      m_pricingViolCo(base.m_pricingViolCo),
+      m_pricingViolCoUpToDate(base.m_pricingViolCoUpToDate),
+      m_numViol(base.m_numViol), m_entertol(base.m_entertol),
+      m_leavetol(base.m_leavetol), theShift(base.theShift),
+      lastShift(base.lastShift), m_maxCycle(base.m_maxCycle),
+      m_numCycle(base.m_numCycle), initialized(base.initialized),
+      solveVector2(0), solveVector2rhs(base.solveVector2rhs), solveVector3(0),
+      solveVector3rhs(base.solveVector3rhs), coSolveVector2(0),
+      coSolveVector2rhs(base.coSolveVector2rhs), coSolveVector3(0),
+      coSolveVector3rhs(base.coSolveVector3rhs),
+      instableLeaveNum(base.instableLeaveNum),
+      instableLeave(base.instableLeave),
+      instableLeaveVal(base.instableLeaveVal),
+      instableEnterId(base.instableEnterId), instableEnter(base.instableEnter),
+      instableEnterVal(base.instableEnterVal), displayLine(base.displayLine),
+      displayFreq(base.displayFreq),
+      sparsePricingFactor(base.sparsePricingFactor),
+      getStartingDecompBasis(base.getStartingDecompBasis),
+      computeDegeneracy(base.computeDegeneracy),
+      degenCompIterOffset(base.degenCompIterOffset),
+      decompIterationLimit(base.decompIterationLimit),
+      fullPerturbation(base.fullPerturbation),
+      printBasisMetric(base.printBasisMetric), unitVecs(base.unitVecs),
+      primRhs(base.primRhs), primVec(base.primVec), dualRhs(base.dualRhs),
+      dualVec(base.dualVec), addVec(base.addVec), theURbound(base.theURbound),
+      theLRbound(base.theLRbound), theUCbound(base.theUCbound),
+      theLCbound(base.theLCbound), theUBbound(base.theUBbound),
+      theLBbound(base.theLBbound), theCoTest(base.theCoTest),
+      theTest(base.theTest), primalRay(base.primalRay),
+      dualFarkas(base.dualFarkas), leaveCount(base.leaveCount),
+      enterCount(base.enterCount), primalCount(base.primalCount),
+      polishCount(base.polishCount), boundflips(base.boundflips),
+      totalboundflips(base.totalboundflips), enterCycles(base.enterCycles),
+      leaveCycles(base.leaveCycles), enterDegenCand(base.enterDegenCand),
+      leaveDegenCand(base.leaveDegenCand), primalDegenSum(base.primalDegenSum),
+      dualDegenSum(base.dualDegenSum), boundrange(base.boundrange),
+      siderange(base.siderange), objrange(base.objrange),
+      infeasibilities(base.infeasibilities),
+      infeasibilitiesCo(base.infeasibilitiesCo),
+      isInfeasible(base.isInfeasible), isInfeasibleCo(base.isInfeasibleCo),
+      sparsePricingLeave(base.sparsePricingLeave),
+      sparsePricingEnter(base.sparsePricingEnter),
+      sparsePricingEnterCo(base.sparsePricingEnterCo),
+      hyperPricingLeave(base.hyperPricingLeave),
+      hyperPricingEnter(base.hyperPricingEnter),
+      remainingRoundsLeave(base.remainingRoundsLeave),
+      remainingRoundsEnter(base.remainingRoundsEnter),
+      remainingRoundsEnterCo(base.remainingRoundsEnterCo),
+      weights(base.weights), coWeights(base.coWeights),
+      weightsAreSetup(base.weightsAreSetup),
+      multSparseCalls(base.multSparseCalls), multFullCalls(base.multFullCalls),
+      multColwiseCalls(base.multColwiseCalls),
+      multUnsetupCalls(base.multUnsetupCalls), spxout(base.spxout),
+      integerVariables(base.integerVariables) {
+  theTime = TimerFactory::createTimer(timerType);
+  multTimeSparse = TimerFactory::createTimer(timerType);
+  multTimeFull = TimerFactory::createTimer(timerType);
+  multTimeColwise = TimerFactory::createTimer(timerType);
+  multTimeUnsetup = TimerFactory::createTimer(timerType);
+
+  if (base.theRep == COLUMN) {
+    thevectors = this->colSet();
+    thecovectors = this->rowSet();
+    theFrhs = &primRhs;
+    theFvec = &primVec;
+    theCoPrhs = &dualRhs;
+    theCoPvec = &dualVec;
+    thePvec = &addVec;
+    theRPvec = theCoPvec;
+    theCPvec = thePvec;
+    theUbound = &theUCbound;
+    theLbound = &theLCbound;
+    theCoUbound = &theURbound;
+    theCoLbound = &theLRbound;
+  } else {
+    assert(base.theRep == ROW);
+
+    thevectors = this->rowSet();
+    thecovectors = this->colSet();
+    theFrhs = &dualRhs;
+    theFvec = &dualVec;
+    theCoPrhs = &primRhs;
+    theCoPvec = &primVec;
+    thePvec = &addVec;
+    theRPvec = thePvec;
+    theCPvec = theCoPvec;
+    theUbound = &theURbound;
+    theLbound = &theLRbound;
+    theCoUbound = &theUCbound;
+    theCoLbound = &theLCbound;
+  }
+
+  SPxBasisBase<R>::theLP = this;
+
+  if (base.thepricer == 0) {
+    thepricer = 0;
+    freePricer = false;
+  } else {
+    thepricer = base.thepricer->clone();
+    freePricer = true;
+    thepricer->clear();
+    thepricer->load(this);
+  }
+
+  if (base.theratiotester == 0) {
+    theratiotester = 0;
+    freeRatioTester = false;
+  } else {
+    theratiotester = base.theratiotester->clone();
+    freeRatioTester = true;
+    theratiotester->clear();
+    theratiotester->load(this);
+  }
+
+  if (base.thestarter == 0) {
+    thestarter = 0;
+    freeStarter = false;
+  } else {
+    thestarter = base.thestarter->clone();
+    freeStarter = true;
+  }
+
+  assert(SPxSolverBase<R>::isConsistent());
+}
 
-   template <class R>
-   bool SPxSolverBase<R>::isConsistent() const
-   {
+template <class R> bool SPxSolverBase<R>::isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
 
-      if(epsilon() < 0)
-         return MSGinconsistent("SPxSolverBase");
-
-      if(primVec.delta().getEpsilon() != dualVec.delta().getEpsilon())
-         return MSGinconsistent("SPxSolverBase");
-
-      if(dualVec.delta().getEpsilon() != addVec.delta().getEpsilon())
-         return MSGinconsistent("SPxSolverBase");
-
-      if(unitVecs.size() < SPxLPBase<R>::nCols() || unitVecs.size() < SPxLPBase<R>::nRows())
-         return MSGinconsistent("SPxSolverBase");
-
-      if(initialized)
-      {
-         if(theFrhs->dim() != dim())
-            return MSGinconsistent("SPxSolverBase");
-
-         if(theFvec->dim() != dim())
-            return MSGinconsistent("SPxSolverBase");
-
-         if(theCoPrhs->dim() != dim())
-            return MSGinconsistent("SPxSolverBase");
-
-         if(thePvec->dim() != coDim())
-            return MSGinconsistent("SPxSolverBase");
-
-         if(theCoPvec->dim() != dim())
-            return MSGinconsistent("SPxSolverBase");
-
-         if(theTest.dim() != coDim())
-            return MSGinconsistent("SPxSolverBase");
-
-         if(theCoTest.dim() != dim())
-            return MSGinconsistent("SPxSolverBase");
-
-         if(theURbound.dim() != SPxLPBase<R>::nRows())
-            return MSGinconsistent("SPxSolverBase");
-
-         if(theLRbound.dim() != SPxLPBase<R>::nRows())
-            return MSGinconsistent("SPxSolverBase");
-
-         if(theUCbound.dim() != SPxLPBase<R>::nCols())
-            return MSGinconsistent("SPxSolverBase");
-
-         if(theLCbound.dim() != SPxLPBase<R>::nCols())
-            return MSGinconsistent("SPxSolverBase");
-
-         if(theUBbound.dim() != dim())
-            return MSGinconsistent("SPxSolverBase");
-
-         if(theLBbound.dim() != dim())
-            return MSGinconsistent("SPxSolverBase");
-      }
-
-      if(rep() == COLUMN)
-      {
-         if(thecovectors !=
-               reinterpret_cast<const SVSetBase<R> *>(static_cast<const LPRowSetBase<R>*>(this))
-               || thevectors !=
-               reinterpret_cast<const SVSetBase<R> *>(static_cast<const LPColSet*>(this))
-               || theFrhs != &primRhs ||
-               theFvec != &primVec ||
-               theCoPrhs != &dualRhs ||
-               theCoPvec != &dualVec ||
-               thePvec != &addVec ||
-               theRPvec != theCoPvec ||
-               theCPvec != thePvec ||
-               theUbound != &theUCbound ||
-               theLbound != &theLCbound ||
-               theCoUbound != &theURbound ||
-               theCoLbound != &theLRbound)
-            return MSGinconsistent("SPxSolverBase");
-      }
-      else
-      {
-         if(thecovectors
-               != reinterpret_cast<const SVSetBase<R> *>(static_cast<const LPColSet*>(this))
-               || thevectors
-               != reinterpret_cast<const SVSetBase<R> *>(static_cast<const LPRowSetBase<R>*>(this))
-               || theFrhs != &dualRhs ||
-               theFvec != &dualVec ||
-               theCoPrhs != &primRhs ||
-               theCoPvec != &primVec ||
-               thePvec != &addVec ||
-               theRPvec != thePvec ||
-               theCPvec != theCoPvec ||
-               theUbound != &theURbound ||
-               theLbound != &theLRbound ||
-               theCoUbound != &theUCbound ||
-               theCoLbound != &theLCbound)
-            return MSGinconsistent("SPxSolverBase");
-      }
-
-      return SPxLPBase<R>::isConsistent()
-             && primRhs.isConsistent()
-             && primVec.isConsistent()
-             && dualRhs.isConsistent()
-             && dualVec.isConsistent()
-             && addVec.isConsistent()
-             && theTest.isConsistent()
-             && theCoTest.isConsistent()
-             && theURbound.isConsistent()
-             && theLRbound.isConsistent()
-             && theUCbound.isConsistent()
-             && theLCbound.isConsistent()
-             && SPxBasisBase<R>::isConsistent()
-             ;
+  if (epsilon() < 0)
+    return MSGinconsistent("SPxSolverBase");
+
+  if (primVec.delta().getEpsilon() != dualVec.delta().getEpsilon())
+    return MSGinconsistent("SPxSolverBase");
+
+  if (dualVec.delta().getEpsilon() != addVec.delta().getEpsilon())
+    return MSGinconsistent("SPxSolverBase");
+
+  if (unitVecs.size() < SPxLPBase<R>::nCols() ||
+      unitVecs.size() < SPxLPBase<R>::nRows())
+    return MSGinconsistent("SPxSolverBase");
+
+  if (initialized) {
+    if (theFrhs->dim() != dim())
+      return MSGinconsistent("SPxSolverBase");
+
+    if (theFvec->dim() != dim())
+      return MSGinconsistent("SPxSolverBase");
+
+    if (theCoPrhs->dim() != dim())
+      return MSGinconsistent("SPxSolverBase");
+
+    if (thePvec->dim() != coDim())
+      return MSGinconsistent("SPxSolverBase");
+
+    if (theCoPvec->dim() != dim())
+      return MSGinconsistent("SPxSolverBase");
+
+    if (theTest.dim() != coDim())
+      return MSGinconsistent("SPxSolverBase");
+
+    if (theCoTest.dim() != dim())
+      return MSGinconsistent("SPxSolverBase");
+
+    if (theURbound.dim() != SPxLPBase<R>::nRows())
+      return MSGinconsistent("SPxSolverBase");
+
+    if (theLRbound.dim() != SPxLPBase<R>::nRows())
+      return MSGinconsistent("SPxSolverBase");
+
+    if (theUCbound.dim() != SPxLPBase<R>::nCols())
+      return MSGinconsistent("SPxSolverBase");
+
+    if (theLCbound.dim() != SPxLPBase<R>::nCols())
+      return MSGinconsistent("SPxSolverBase");
+
+    if (theUBbound.dim() != dim())
+      return MSGinconsistent("SPxSolverBase");
+
+    if (theLBbound.dim() != dim())
+      return MSGinconsistent("SPxSolverBase");
+  }
+
+  if (rep() == COLUMN) {
+    if (thecovectors != reinterpret_cast<const SVSetBase<R> *>(
+                            static_cast<const LPRowSetBase<R> *>(this)) ||
+        thevectors != reinterpret_cast<const SVSetBase<R> *>(
+                          static_cast<const LPColSet *>(this)) ||
+        theFrhs != &primRhs || theFvec != &primVec || theCoPrhs != &dualRhs ||
+        theCoPvec != &dualVec || thePvec != &addVec || theRPvec != theCoPvec ||
+        theCPvec != thePvec || theUbound != &theUCbound ||
+        theLbound != &theLCbound || theCoUbound != &theURbound ||
+        theCoLbound != &theLRbound)
+      return MSGinconsistent("SPxSolverBase");
+  } else {
+    if (thecovectors != reinterpret_cast<const SVSetBase<R> *>(
+                            static_cast<const LPColSet *>(this)) ||
+        thevectors != reinterpret_cast<const SVSetBase<R> *>(
+                          static_cast<const LPRowSetBase<R> *>(this)) ||
+        theFrhs != &dualRhs || theFvec != &dualVec || theCoPrhs != &primRhs ||
+        theCoPvec != &primVec || thePvec != &addVec || theRPvec != thePvec ||
+        theCPvec != theCoPvec || theUbound != &theURbound ||
+        theLbound != &theLRbound || theCoUbound != &theUCbound ||
+        theCoLbound != &theLCbound)
+      return MSGinconsistent("SPxSolverBase");
+  }
+
+  return SPxLPBase<R>::isConsistent() && primRhs.isConsistent() &&
+         primVec.isConsistent() && dualRhs.isConsistent() &&
+         dualVec.isConsistent() && addVec.isConsistent() &&
+         theTest.isConsistent() && theCoTest.isConsistent() &&
+         theURbound.isConsistent() && theLRbound.isConsistent() &&
+         theUCbound.isConsistent() && theLCbound.isConsistent() &&
+         SPxBasisBase<R>::isConsistent();
 #else
-      return true;
+  return true;
 #endif
-   }
-
-
-   template <class R>
-   void SPxSolverBase<R>::setTerminationTime(Real p_time)
-   {
-      if(p_time < 0.0)
-         p_time = 0.0;
-
-      maxTime = p_time;
-   }
-
-   template <class R>
-   Real SPxSolverBase<R>::terminationTime() const
-   {
-      return maxTime;
-   }
-
-   template <class R>
-   void SPxSolverBase<R>::setTerminationIter(int p_iteration)
-   {
-      if(p_iteration < 0)
-         p_iteration = -1;
-
-      maxIters = p_iteration;
-   }
-
-   template <class R>
-   int SPxSolverBase<R>::terminationIter() const
-   {
-      return maxIters;
-   }
-
-   // returns whether current time limit is reached; call to time() may be skipped unless \p forceCheck is true
-   template <class R>
-   bool SPxSolverBase<R>::isTimeLimitReached(const bool forceCheck)
-   {
-      // always update the number of calls, since the user might set a time limit later in the solving process
-      ++nCallsToTimelim;
-
-      // check if a time limit is actually set
-      if(maxTime >= R(infinity))
-         return false;
-
-      // check if the expensive system call to update the time should be skipped again
-      if(forceCheck || nCallsToTimelim < NINITCALLS ||  nClckSkipsLeft <= 0)
-      {
-         Real currtime = time();
-
-         if(currtime >= maxTime)
-            return true;
-
-         // determine the number of times the clock can be skipped again.
-         int nClckSkips = MAXNCLCKSKIPS;
-         Real avgtimeinterval = (currtime + cumulativeTime()) / (Real)(nCallsToTimelim);
-
-         // it would not be safe to skip the clock so many times since we are approaching the time limit
-         if(SAFETYFACTOR * (maxTime - currtime) / (avgtimeinterval + 1e-6) < nClckSkips)
-            nClckSkips = 0;
-
-         nClckSkipsLeft = nClckSkips;
-      }
-      else
-         --nClckSkipsLeft;
-
-      return false;
-   }
-
-
-   /**@todo A first version for the termination value is
-    *       implemented. Currently we check if no bound violations (shifting)
-    *       is present. It might be even possible to use this termination
-    *       value in case of bound violations (shifting) but in this case it
-    *       is quite difficult to determine if we already reached the limit.
-    */
-   template <class R>
-   void SPxSolverBase<R>::setTerminationValue(R p_value)
-   {
-      objLimit = p_value;
-   }
-
-   template <class R>
-   R SPxSolverBase<R>::terminationValue() const
-   {
-      return objLimit;
-   }
-
-   template <class R>
-   typename SPxSolverBase<R>::VarStatus
-   SPxSolverBase<R>::basisStatusToVarStatus(typename SPxBasisBase<R>::Desc::Status stat) const
-   {
-      VarStatus vstat;
-
-      switch(stat)
-      {
-      case SPxBasisBase<R>::Desc::P_ON_LOWER:
-         vstat = ON_LOWER;
-         break;
-
-      case SPxBasisBase<R>::Desc::P_ON_UPPER:
-         vstat = ON_UPPER;
-         break;
-
-      case SPxBasisBase<R>::Desc::P_FIXED:
-         vstat = FIXED;
-         break;
-
-      case SPxBasisBase<R>::Desc::P_FREE:
-         vstat = ZERO;
-         break;
-
-      case SPxBasisBase<R>::Desc::D_ON_UPPER:
-      case SPxBasisBase<R>::Desc::D_ON_LOWER:
-      case SPxBasisBase<R>::Desc::D_ON_BOTH:
-      case SPxBasisBase<R>::Desc::D_UNDEFINED:
-      case SPxBasisBase<R>::Desc::D_FREE:
-         vstat = BASIC;
-         break;
-
-      default:
-         MSG_ERROR(std::cerr << "ESOLVE26 ERROR: unknown basis status (" << static_cast<int>(stat) << ")"
-                   << std::endl;)
-         throw SPxInternalCodeException("XSOLVE22 This should never happen.");
-      }
-
-      return vstat;
-   }
-
-   template <class R>
-   typename SPxBasisBase<R>::Desc::Status
-   SPxSolverBase<R>::varStatusToBasisStatusRow(int row,
-         typename SPxSolverBase<R>::VarStatus stat) const
-   {
-      typename SPxBasisBase<R>::Desc::Status rstat;
-
-      switch(stat)
-      {
-      case FIXED :
-         assert(EQ(this->rhs(row), this->lhs(row), feastol()));
-         rstat = SPxBasisBase<R>::Desc::P_FIXED;
-         break;
-
-      case ON_UPPER :
-         assert(this->rhs(row) < R(infinity));
-         rstat = this->lhs(row) < this->rhs(row)
-                 ? SPxBasisBase<R>::Desc::P_ON_UPPER
-                 : SPxBasisBase<R>::Desc::P_FIXED;
-         break;
-
-      case ON_LOWER :
-         assert(this->lhs(row) > R(-infinity));
-         rstat = this->lhs(row) < this->rhs(row)
-                 ? SPxBasisBase<R>::Desc::P_ON_LOWER
-                 : SPxBasisBase<R>::Desc::P_FIXED;
-         break;
-
-      case ZERO :
-         /* A 'free' row (i.e., infinite lower & upper bounds) does not really make sense. The user
-          * might (think to) know better, e.g., when temporarily turning off a row. We therefore apply
-          * the same adjustment as in the column case in varStatusToBasisStatusCol(). */
-         rstat = SPxBasisBase<R>::Desc::P_FREE;
-         break;
-
-      case BASIC :
-         rstat = this->dualRowStatus(row);
-         break;
-
-      default:
-         MSG_ERROR(std::cerr << "ESOLVE27 ERROR: unknown VarStatus (" << int(stat) << ")"
-                   << std::endl;)
-         throw SPxInternalCodeException("XSOLVE23 This should never happen.");
-      }
-
-      return rstat;
-   }
-
-   template <class R>
-   typename SPxBasisBase<R>::Desc::Status
-   SPxSolverBase<R>::varStatusToBasisStatusCol(int col,
-         typename SPxSolverBase<R>::VarStatus stat) const
-   {
-      typename SPxBasisBase<R>::Desc::Status cstat;
-
-      switch(stat)
-      {
-      case FIXED :
-         if(this->upper(col) == this->lower(col))
-            cstat = SPxBasisBase<R>::Desc::P_FIXED;
-         else if(this->maxObj(col) > 0.0)
-            cstat = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         else
-            cstat = SPxBasisBase<R>::Desc::P_ON_LOWER;
-
-         break;
-
-      case ON_UPPER :
-         assert(this->upper(col) < R(infinity));
-         cstat = this->lower(col) < this->upper(col)
-                 ? SPxBasisBase<R>::Desc::P_ON_UPPER
-                 : SPxBasisBase<R>::Desc::P_FIXED;
-         break;
-
-      case ON_LOWER :
-         assert(this->lower(col) > R(-infinity));
-         cstat = this->lower(col) < this->upper(col)
-                 ? SPxBasisBase<R>::Desc::P_ON_LOWER
-                 : SPxBasisBase<R>::Desc::P_FIXED;
-         break;
-
-      case ZERO :
-
-         /* In this case the upper and lower bounds on the variable should be infinite. The bounds
-          * might, however, have changed and we try to recover from this by changing the status to
-          * 'resonable' settings. Since the status should be implicit free we still always set it
-          * to P_FREE to be consistent */
-         cstat = SPxBasisBase<R>::Desc::P_FREE;
-         break;
-
-      case BASIC :
-         cstat = this->dualColStatus(col);
-         break;
-
-      default:
-         MSG_ERROR(std::cerr << "ESOLVE28 ERROR: unknown VarStatus (" << int(stat) << ")"
-                   << std::endl;)
-         throw SPxInternalCodeException("XSOLVE24 This should never happen.");
-      }
-
-      return cstat;
-   }
-
-   template <class R>
-   typename SPxSolverBase<R>::VarStatus SPxSolverBase<R>::getBasisRowStatus(int row) const
-   {
-      assert(0 <= row && row < this->nRows());
-      return basisStatusToVarStatus(this->desc().rowStatus(row));
-   }
-
-   template <class R>
-   typename SPxSolverBase<R>::VarStatus SPxSolverBase<R>::getBasisColStatus(int col) const
-   {
-      assert(0 <= col && col < this->nCols());
-      return basisStatusToVarStatus(this->desc().colStatus(col));
-   }
-
-   template <class R>
-   typename SPxSolverBase<R>::Status SPxSolverBase<R>::getBasis(VarStatus row[], VarStatus col[],
-         const int rowsSize, const int colsSize) const
-   {
-      const typename SPxBasisBase<R>::Desc& d = this->desc();
-      int i;
-
-      assert(rowsSize < 0 || rowsSize >= this->nRows());
-      assert(colsSize < 0 || colsSize >= this->nCols());
-
-      if(col)
-         for(i = this->nCols() - 1; i >= 0; --i)
-            col[i] = basisStatusToVarStatus(d.colStatus(i));
+}
 
-      if(row)
-         for(i = this->nRows() - 1; i >= 0; --i)
-            row[i] = basisStatusToVarStatus(d.rowStatus(i));
+template <class R> void SPxSolverBase<R>::setTerminationTime(Real p_time) {
+  if (p_time < 0.0)
+    p_time = 0.0;
 
-      return status();
-   }
+  maxTime = p_time;
+}
 
-   template <class R>
-   bool SPxSolverBase<R>::isBasisValid(DataArray<VarStatus> p_rows, DataArray<VarStatus> p_cols)
-   {
+template <class R> Real SPxSolverBase<R>::terminationTime() const {
+  return maxTime;
+}
 
-      int basisdim;
+template <class R> void SPxSolverBase<R>::setTerminationIter(int p_iteration) {
+  if (p_iteration < 0)
+    p_iteration = -1;
 
-      if(p_rows.size() != this->nRows() || p_cols.size() != this->nCols())
-         return false;
+  maxIters = p_iteration;
+}
 
-      basisdim = 0;
+template <class R> int SPxSolverBase<R>::terminationIter() const {
+  return maxIters;
+}
 
-      for(int row = this->nRows() - 1; row >= 0; --row)
-      {
-         if(p_rows[row] == UNDEFINED)
-            return false;
-         // row is basic
-         else if(p_rows[row] == BASIC)
-         {
-            basisdim++;
-         }
-         // row is nonbasic
-         else
-         {
-            if((p_rows[row] == FIXED && this->lhs(row) != this->rhs(row))
-                  || (p_rows[row] == ON_UPPER && this->rhs(row) >= R(infinity))
-                  || (p_rows[row] == ON_LOWER && this->lhs(row) <= R(-infinity)))
-               return false;
-         }
-      }
+// returns whether current time limit is reached; call to time() may be skipped
+// unless \p forceCheck is true
+template <class R>
+bool SPxSolverBase<R>::isTimeLimitReached(const bool forceCheck) {
+  // always update the number of calls, since the user might set a time limit
+  // later in the solving process
+  ++nCallsToTimelim;
 
-      for(int col = this->nCols() - 1; col >= 0; --col)
-      {
-         if(p_cols[col] == UNDEFINED)
-            return false;
-         // col is basic
-         else if(p_cols[col] == BASIC)
-         {
-            basisdim++;
-         }
-         // col is nonbasic
-         else
-         {
-            if((p_cols[col] == FIXED && this->lower(col) != this->upper(col))
-                  || (p_cols[col] == ON_UPPER && this->upper(col) >= R(infinity))
-                  || (p_cols[col] == ON_LOWER && this->lower(col) <= R(-infinity)))
-               return false;
-         }
-      }
+  // check if a time limit is actually set
+  if (maxTime >= R(infinity))
+    return false;
 
-      if(basisdim != dim())
-         return false;
+  // check if the expensive system call to update the time should be skipped
+  // again
+  if (forceCheck || nCallsToTimelim < NINITCALLS || nClckSkipsLeft <= 0) {
+    Real currtime = time();
 
-      // basis valid
+    if (currtime >= maxTime)
       return true;
-   }
-
-   template <class R>
-   void SPxSolverBase<R>::setBasis(const VarStatus p_rows[], const VarStatus p_cols[])
-   {
-      if(SPxBasisBase<R>::status() == SPxBasisBase<R>::NO_PROBLEM)
-         SPxBasisBase<R>::load(this, false);
-
-      typename SPxBasisBase<R>::Desc ds = this->desc();
-      int i;
-
-      for(i = 0; i < this->nRows(); i++)
-         ds.rowStatus(i) = varStatusToBasisStatusRow(i, p_rows[i]);
-
-      for(i = 0; i < this->nCols(); i++)
-         ds.colStatus(i) = varStatusToBasisStatusCol(i, p_cols[i]);
-
-      loadBasis(ds);
-      forceRecompNonbasicValue();
-   }
-
-   // NOTE: This only works for the row representation. Need to update to account for column representation.
-   // The degenvec differs relative to the algorithm being used.
-   // For the primal simplex, degenvec is the primal solution values.
-   // For the dual simplex, the degenvec is the feasvec (ROW) and pVec (COLUMN).
-   template <class R>
-   R SPxSolverBase<R>::getDegeneracyLevel(VectorBase<R> degenvec)
-   {
-      int numDegenerate = 0;
-      R degeneracyLevel = 0;
-
-      // iterating over all columns in the basis matrix
-      // this identifies the basis indices and those that have a zero dual multiplier (rows) or zero reduced cost (cols).
-      if(rep() == ROW)
-      {
-         for(int i = 0; i < this->nCols();
-               ++i)   // @todo Check the use of numColsReal for the reduced problem.
-         {
-            // degeneracy in the dual simplex exists if there are rows with a zero dual multiplier or columns with a zero
-            // reduced costs. This requirement is regardless of the objective sense.
-            if(isZero(degenvec[i], feastol()))
-               numDegenerate++;
-         }
 
-         if(type() == ENTER)     // dual simplex
-            degeneracyLevel = R(numDegenerate) / this->nCols();
-         else                    // primal simplex
-         {
-            assert(type() == LEAVE);
-            R degenVars = (numDegenerate > (this->nCols() - this->nRows())) ? R(numDegenerate -
-                          (this->nCols() - this->nRows())) : 0.0;
-            degeneracyLevel = degenVars / this->nRows();
-         }
-      }
-      else
-      {
-         assert(rep() == COLUMN);
+    // determine the number of times the clock can be skipped again.
+    int nClckSkips = MAXNCLCKSKIPS;
+    Real avgtimeinterval =
+        (currtime + cumulativeTime()) / (Real)(nCallsToTimelim);
 
-         for(int i = 0; i < this->nCols(); i++)
-         {
-            if(type() == LEAVE)     // dual simplex
-            {
-               if(isZero(this->maxObj()[i] - degenvec[i], feastol()))
-                  numDegenerate++;
-            }
-            else                    // primal simplex
-            {
-               assert(type() == ENTER);
-
-               if(isZero(degenvec[i], feastol()))
-                  numDegenerate++;
-            }
-         }
+    // it would not be safe to skip the clock so many times since we are
+    // approaching the time limit
+    if (SAFETYFACTOR * (maxTime - currtime) / (avgtimeinterval + 1e-6) <
+        nClckSkips)
+      nClckSkips = 0;
 
+    nClckSkipsLeft = nClckSkips;
+  } else
+    --nClckSkipsLeft;
 
-         if(type() == LEAVE)     // dual simplex
-         {
-            R degenVars = this->nRows() > numDegenerate ? R(this->nRows() - numDegenerate) : 0.0;
-            degeneracyLevel = degenVars / this->nCols();
-         }
-         else                    // primal simplex
-         {
-            assert(type() == ENTER);
-            R degenVars = (numDegenerate > (this->nCols() - this->nRows())) ? R(numDegenerate -
-                          (this->nCols() - this->nRows())) : 0.0;
-            degeneracyLevel = degenVars / this->nRows();
-         }
-      }
-
-      return degeneracyLevel;
-   }
-
-   template <class R>
-   void SPxSolverBase<R>::getNdualNorms(int& nnormsRow, int& nnormsCol) const
-   {
-      nnormsRow = 0;
-      nnormsCol = 0;
-
-      if(weightsAreSetup)
-      {
-         if(type() == SPxSolverBase<R>::LEAVE && rep() == SPxSolverBase<R>::COLUMN)
-         {
-            nnormsRow = coWeights.dim();
-            nnormsCol = 0;
-
-            assert(nnormsRow == dim());
-         }
-         else if(type() == SPxSolverBase<R>::ENTER && rep() == SPxSolverBase<R>::ROW)
-         {
-            nnormsRow = weights.dim();
-            nnormsCol = coWeights.dim();
-
-            assert(nnormsRow == coDim());
-            assert(nnormsCol == dim());
-         }
-      }
-   }
-
-   template <class R>
-   bool SPxSolverBase<R>::getDualNorms(int& nnormsRow, int& nnormsCol, R * norms) const
-   {
-      nnormsRow = 0;
-      nnormsCol = 0;
-
-      if(!weightsAreSetup)
-         return false;
-
-      if(type() == SPxSolverBase<R>::LEAVE && rep() == SPxSolverBase<R>::COLUMN)
-      {
-         nnormsCol = 0;
-         nnormsRow = coWeights.dim();
-
-         assert(nnormsRow == dim());
-
-         for(int i = 0; i < nnormsRow; ++i)
-            norms[i] = coWeights[i];
-      }
-      else if(type() == SPxSolverBase<R>::ENTER && rep() == SPxSolverBase<R>::ROW)
-      {
-         nnormsRow = weights.dim();
-         nnormsCol = coWeights.dim();
-
-         assert(nnormsCol == dim());
-         assert(nnormsRow == coDim());
-
-         for(int i = 0; i < nnormsRow; ++i)
-            norms[i] = weights[i];
-
-         for(int i = 0; i < nnormsCol; ++i)
-            norms[nnormsRow + i] = coWeights[i];
-      }
-      else
-         return false;
+  return false;
+}
 
-      return true;
-   }
+/**@todo A first version for the termination value is
+ *       implemented. Currently we check if no bound violations (shifting)
+ *       is present. It might be even possible to use this termination
+ *       value in case of bound violations (shifting) but in this case it
+ *       is quite difficult to determine if we already reached the limit.
+ */
+template <class R> void SPxSolverBase<R>::setTerminationValue(R p_value) {
+  objLimit = p_value;
+}
 
-   template <class R>
-   bool SPxSolverBase<R>::setDualNorms(int nnormsRow, int nnormsCol, R * norms)
-   {
-      weightsAreSetup = false;
+template <class R> R SPxSolverBase<R>::terminationValue() const {
+  return objLimit;
+}
 
-      if(type() == SPxSolverBase<R>::LEAVE && rep() == SPxSolverBase<R>::COLUMN)
-      {
-         coWeights.reDim(dim(), false);
-         assert(coWeights.dim() >= nnormsRow);
+template <class R>
+typename SPxSolverBase<R>::VarStatus SPxSolverBase<R>::basisStatusToVarStatus(
+    typename SPxBasisBase<R>::Desc::Status stat) const {
+  VarStatus vstat;
+
+  switch (stat) {
+  case SPxBasisBase<R>::Desc::P_ON_LOWER:
+    vstat = ON_LOWER;
+    break;
+
+  case SPxBasisBase<R>::Desc::P_ON_UPPER:
+    vstat = ON_UPPER;
+    break;
+
+  case SPxBasisBase<R>::Desc::P_FIXED:
+    vstat = FIXED;
+    break;
+
+  case SPxBasisBase<R>::Desc::P_FREE:
+    vstat = ZERO;
+    break;
+
+  case SPxBasisBase<R>::Desc::D_ON_UPPER:
+  case SPxBasisBase<R>::Desc::D_ON_LOWER:
+  case SPxBasisBase<R>::Desc::D_ON_BOTH:
+  case SPxBasisBase<R>::Desc::D_UNDEFINED:
+  case SPxBasisBase<R>::Desc::D_FREE:
+    vstat = BASIC;
+    break;
+
+  default:
+    MSG_ERROR(std::cerr << "ESOLVE26 ERROR: unknown basis status ("
+                        << static_cast<int>(stat) << ")" << std::endl;)
+    throw SPxInternalCodeException("XSOLVE22 This should never happen.");
+  }
+
+  return vstat;
+}
 
-         for(int i = 0; i < nnormsRow; ++i)
-            coWeights[i] = norms[i];
+template <class R>
+typename SPxBasisBase<R>::Desc::Status
+SPxSolverBase<R>::varStatusToBasisStatusRow(
+    int row, typename SPxSolverBase<R>::VarStatus stat) const {
+  typename SPxBasisBase<R>::Desc::Status rstat;
+
+  switch (stat) {
+  case FIXED:
+    assert(EQ(this->rhs(row), this->lhs(row), feastol()));
+    rstat = SPxBasisBase<R>::Desc::P_FIXED;
+    break;
+
+  case ON_UPPER:
+    assert(this->rhs(row) < R(infinity));
+    rstat = this->lhs(row) < this->rhs(row) ? SPxBasisBase<R>::Desc::P_ON_UPPER
+                                            : SPxBasisBase<R>::Desc::P_FIXED;
+    break;
+
+  case ON_LOWER:
+    assert(this->lhs(row) > R(-infinity));
+    rstat = this->lhs(row) < this->rhs(row) ? SPxBasisBase<R>::Desc::P_ON_LOWER
+                                            : SPxBasisBase<R>::Desc::P_FIXED;
+    break;
+
+  case ZERO:
+    /* A 'free' row (i.e., infinite lower & upper bounds) does not really make
+     * sense. The user might (think to) know better, e.g., when temporarily
+     * turning off a row. We therefore apply the same adjustment as in the
+     * column case in varStatusToBasisStatusCol(). */
+    rstat = SPxBasisBase<R>::Desc::P_FREE;
+    break;
+
+  case BASIC:
+    rstat = this->dualRowStatus(row);
+    break;
+
+  default:
+    MSG_ERROR(std::cerr << "ESOLVE27 ERROR: unknown VarStatus (" << int(stat)
+                        << ")" << std::endl;)
+    throw SPxInternalCodeException("XSOLVE23 This should never happen.");
+  }
+
+  return rstat;
+}
 
-         weightsAreSetup = true;
-      }
-      else if(type() == SPxSolverBase<R>::ENTER && rep() == SPxSolverBase<R>::ROW)
-      {
-         weights.reDim(coDim(), false);
-         coWeights.reDim(dim(), false);
-         assert(weights.dim() >= nnormsRow);
-         assert(coWeights.dim() >= nnormsCol);
+template <class R>
+typename SPxBasisBase<R>::Desc::Status
+SPxSolverBase<R>::varStatusToBasisStatusCol(
+    int col, typename SPxSolverBase<R>::VarStatus stat) const {
+  typename SPxBasisBase<R>::Desc::Status cstat;
+
+  switch (stat) {
+  case FIXED:
+    if (this->upper(col) == this->lower(col))
+      cstat = SPxBasisBase<R>::Desc::P_FIXED;
+    else if (this->maxObj(col) > 0.0)
+      cstat = SPxBasisBase<R>::Desc::P_ON_UPPER;
+    else
+      cstat = SPxBasisBase<R>::Desc::P_ON_LOWER;
+
+    break;
+
+  case ON_UPPER:
+    assert(this->upper(col) < R(infinity));
+    cstat = this->lower(col) < this->upper(col)
+                ? SPxBasisBase<R>::Desc::P_ON_UPPER
+                : SPxBasisBase<R>::Desc::P_FIXED;
+    break;
+
+  case ON_LOWER:
+    assert(this->lower(col) > R(-infinity));
+    cstat = this->lower(col) < this->upper(col)
+                ? SPxBasisBase<R>::Desc::P_ON_LOWER
+                : SPxBasisBase<R>::Desc::P_FIXED;
+    break;
+
+  case ZERO:
+
+    /* In this case the upper and lower bounds on the variable should be
+     * infinite. The bounds might, however, have changed and we try to recover
+     * from this by changing the status to 'resonable' settings. Since the
+     * status should be implicit free we still always set it to P_FREE to be
+     * consistent */
+    cstat = SPxBasisBase<R>::Desc::P_FREE;
+    break;
+
+  case BASIC:
+    cstat = this->dualColStatus(col);
+    break;
+
+  default:
+    MSG_ERROR(std::cerr << "ESOLVE28 ERROR: unknown VarStatus (" << int(stat)
+                        << ")" << std::endl;)
+    throw SPxInternalCodeException("XSOLVE24 This should never happen.");
+  }
+
+  return cstat;
+}
 
-         for(int i = 0; i < nnormsRow; ++i)
-            weights[i] = norms[i];
+template <class R>
+typename SPxSolverBase<R>::VarStatus
+SPxSolverBase<R>::getBasisRowStatus(int row) const {
+  assert(0 <= row && row < this->nRows());
+  return basisStatusToVarStatus(this->desc().rowStatus(row));
+}
 
-         for(int i = 0; i < nnormsCol; ++i)
-            coWeights[i] = norms[nnormsRow + i];
+template <class R>
+typename SPxSolverBase<R>::VarStatus
+SPxSolverBase<R>::getBasisColStatus(int col) const {
+  assert(0 <= col && col < this->nCols());
+  return basisStatusToVarStatus(this->desc().colStatus(col));
+}
 
-         weightsAreSetup = true;
-      }
-      else
-         return false;
+template <class R>
+typename SPxSolverBase<R>::Status
+SPxSolverBase<R>::getBasis(VarStatus row[], VarStatus col[], const int rowsSize,
+                           const int colsSize) const {
+  const typename SPxBasisBase<R>::Desc &d = this->desc();
+  int i;
 
-      return true;
-   }
+  assert(rowsSize < 0 || rowsSize >= this->nRows());
+  assert(colsSize < 0 || colsSize >= this->nCols());
 
-   template <class R>
-   void SPxSolverBase<R>::setIntegralityInformation(int ncols, int* intInfo)
-   {
-      assert(ncols == this->nCols() || (ncols == 0 && intInfo == NULL));
+  if (col)
+    for (i = this->nCols() - 1; i >= 0; --i)
+      col[i] = basisStatusToVarStatus(d.colStatus(i));
 
-      integerVariables.reSize(ncols);
+  if (row)
+    for (i = this->nRows() - 1; i >= 0; --i)
+      row[i] = basisStatusToVarStatus(d.rowStatus(i));
 
-      for(int i = 0; i < ncols; ++i)
-      {
-         integerVariables[i] = intInfo[i];
-      }
-   }
+  return status();
+}
 
+template <class R>
+bool SPxSolverBase<R>::isBasisValid(DataArray<VarStatus> p_rows,
+                                    DataArray<VarStatus> p_cols) {
 
+  int basisdim;
 
-   //
-   // Auxiliary functions.
-   //
+  if (p_rows.size() != this->nRows() || p_cols.size() != this->nCols())
+    return false;
 
-   // Pretty-printing of variable status.
-   template <class R>
-   std::ostream& operator<<(std::ostream & os,
-                            const typename SPxSolverBase<R>::VarStatus & status)
-   {
-      switch(status)
-      {
-      case SPxSolverBase<R>::BASIC:
-         os << "BASIC";
-         break;
+  basisdim = 0;
 
-      case SPxSolverBase<R>::FIXED:
-         os << "FIXED";
-         break;
+  for (int row = this->nRows() - 1; row >= 0; --row) {
+    if (p_rows[row] == UNDEFINED)
+      return false;
+    // row is basic
+    else if (p_rows[row] == BASIC) {
+      basisdim++;
+    }
+    // row is nonbasic
+    else {
+      if ((p_rows[row] == FIXED && this->lhs(row) != this->rhs(row)) ||
+          (p_rows[row] == ON_UPPER && this->rhs(row) >= R(infinity)) ||
+          (p_rows[row] == ON_LOWER && this->lhs(row) <= R(-infinity)))
+        return false;
+    }
+  }
+
+  for (int col = this->nCols() - 1; col >= 0; --col) {
+    if (p_cols[col] == UNDEFINED)
+      return false;
+    // col is basic
+    else if (p_cols[col] == BASIC) {
+      basisdim++;
+    }
+    // col is nonbasic
+    else {
+      if ((p_cols[col] == FIXED && this->lower(col) != this->upper(col)) ||
+          (p_cols[col] == ON_UPPER && this->upper(col) >= R(infinity)) ||
+          (p_cols[col] == ON_LOWER && this->lower(col) <= R(-infinity)))
+        return false;
+    }
+  }
+
+  if (basisdim != dim())
+    return false;
+
+  // basis valid
+  return true;
+}
 
-      case SPxSolverBase<R>::ON_LOWER:
-         os << "ON_LOWER";
-         break;
+template <class R>
+void SPxSolverBase<R>::setBasis(const VarStatus p_rows[],
+                                const VarStatus p_cols[]) {
+  if (SPxBasisBase<R>::status() == SPxBasisBase<R>::NO_PROBLEM)
+    SPxBasisBase<R>::load(this, false);
 
-      case SPxSolverBase<R>::ON_UPPER:
-         os << "ON_UPPER";
-         break;
+  typename SPxBasisBase<R>::Desc ds = this->desc();
+  int i;
 
-      case SPxSolverBase<R>::ZERO:
-         os << "ZERO";
-         break;
+  for (i = 0; i < this->nRows(); i++)
+    ds.rowStatus(i) = varStatusToBasisStatusRow(i, p_rows[i]);
 
-      case SPxSolverBase<R>::UNDEFINED:
-         os << "UNDEFINED";
-         break;
+  for (i = 0; i < this->nCols(); i++)
+    ds.colStatus(i) = varStatusToBasisStatusCol(i, p_cols[i]);
 
-      default:
-         os << "?invalid?";
-         break;
-      }
+  loadBasis(ds);
+  forceRecompNonbasicValue();
+}
 
-      return os;
-   }
+// NOTE: This only works for the row representation. Need to update to account
+// for column representation. The degenvec differs relative to the algorithm
+// being used. For the primal simplex, degenvec is the primal solution values.
+// For the dual simplex, the degenvec is the feasvec (ROW) and pVec (COLUMN).
+template <class R>
+R SPxSolverBase<R>::getDegeneracyLevel(VectorBase<R> degenvec) {
+  int numDegenerate = 0;
+  R degeneracyLevel = 0;
+
+  // iterating over all columns in the basis matrix
+  // this identifies the basis indices and those that have a zero dual
+  // multiplier (rows) or zero reduced cost (cols).
+  if (rep() == ROW) {
+    for (int i = 0; i < this->nCols();
+         ++i) // @todo Check the use of numColsReal for the reduced problem.
+    {
+      // degeneracy in the dual simplex exists if there are rows with a zero
+      // dual multiplier or columns with a zero reduced costs. This requirement
+      // is regardless of the objective sense.
+      if (isZero(degenvec[i], feastol()))
+        numDegenerate++;
+    }
+
+    if (type() == ENTER) // dual simplex
+      degeneracyLevel = R(numDegenerate) / this->nCols();
+    else // primal simplex
+    {
+      assert(type() == LEAVE);
+      R degenVars = (numDegenerate > (this->nCols() - this->nRows()))
+                        ? R(numDegenerate - (this->nCols() - this->nRows()))
+                        : 0.0;
+      degeneracyLevel = degenVars / this->nRows();
+    }
+  } else {
+    assert(rep() == COLUMN);
+
+    for (int i = 0; i < this->nCols(); i++) {
+      if (type() == LEAVE) // dual simplex
+      {
+        if (isZero(this->maxObj()[i] - degenvec[i], feastol()))
+          numDegenerate++;
+      } else // primal simplex
+      {
+        assert(type() == ENTER);
+
+        if (isZero(degenvec[i], feastol()))
+          numDegenerate++;
+      }
+    }
+
+    if (type() == LEAVE) // dual simplex
+    {
+      R degenVars = this->nRows() > numDegenerate
+                        ? R(this->nRows() - numDegenerate)
+                        : 0.0;
+      degeneracyLevel = degenVars / this->nCols();
+    } else // primal simplex
+    {
+      assert(type() == ENTER);
+      R degenVars = (numDegenerate > (this->nCols() - this->nRows()))
+                        ? R(numDegenerate - (this->nCols() - this->nRows()))
+                        : 0.0;
+      degeneracyLevel = degenVars / this->nRows();
+    }
+  }
+
+  return degeneracyLevel;
+}
 
-   // Pretty-printing of solver status.
-   template <class R>
-   std::ostream& operator<<(std::ostream & os,
-                            const typename SPxSolverBase<R>::Status & status)
-   {
-      switch(status)
-      {
-      case SPxSolverBase<R>::ERROR:
-         os << "ERROR";
-         break;
+template <class R>
+void SPxSolverBase<R>::getNdualNorms(int &nnormsRow, int &nnormsCol) const {
+  nnormsRow = 0;
+  nnormsCol = 0;
+
+  if (weightsAreSetup) {
+    if (type() == SPxSolverBase<R>::LEAVE &&
+        rep() == SPxSolverBase<R>::COLUMN) {
+      nnormsRow = coWeights.dim();
+      nnormsCol = 0;
 
-      case SPxSolverBase<R>::NO_RATIOTESTER:
-         os << "NO_RATIOTESTER";
-         break;
+      assert(nnormsRow == dim());
+    } else if (type() == SPxSolverBase<R>::ENTER &&
+               rep() == SPxSolverBase<R>::ROW) {
+      nnormsRow = weights.dim();
+      nnormsCol = coWeights.dim();
 
-      case SPxSolverBase<R>::NO_PRICER:
-         os << "NO_PRICER";
-         break;
+      assert(nnormsRow == coDim());
+      assert(nnormsCol == dim());
+    }
+  }
+}
 
-      case SPxSolverBase<R>::NO_SOLVER:
-         os << "NO_SOLVER";
-         break;
+template <class R>
+bool SPxSolverBase<R>::getDualNorms(int &nnormsRow, int &nnormsCol,
+                                    R *norms) const {
+  nnormsRow = 0;
+  nnormsCol = 0;
 
-      case SPxSolverBase<R>::NOT_INIT:
-         os << "NOT_INIT";
-         break;
+  if (!weightsAreSetup)
+    return false;
 
-      case SPxSolverBase<R>::ABORT_CYCLING:
-         os << "ABORT_CYCLING";
-         break;
+  if (type() == SPxSolverBase<R>::LEAVE && rep() == SPxSolverBase<R>::COLUMN) {
+    nnormsCol = 0;
+    nnormsRow = coWeights.dim();
 
-      case SPxSolverBase<R>::ABORT_TIME:
-         os << "ABORT_TIME";
-         break;
+    assert(nnormsRow == dim());
 
-      case SPxSolverBase<R>::ABORT_ITER:
-         os << "ABORT_ITER";
-         break;
+    for (int i = 0; i < nnormsRow; ++i)
+      norms[i] = coWeights[i];
+  } else if (type() == SPxSolverBase<R>::ENTER &&
+             rep() == SPxSolverBase<R>::ROW) {
+    nnormsRow = weights.dim();
+    nnormsCol = coWeights.dim();
 
-      case SPxSolverBase<R>::ABORT_VALUE:
-         os << "ABORT_VALUE";
-         break;
+    assert(nnormsCol == dim());
+    assert(nnormsRow == coDim());
 
-      case SPxSolverBase<R>::SINGULAR:
-         os << "SINGULAR";
-         break;
+    for (int i = 0; i < nnormsRow; ++i)
+      norms[i] = weights[i];
 
-      case SPxSolverBase<R>::NO_PROBLEM:
-         os << "NO_PROBLEM";
-         break;
+    for (int i = 0; i < nnormsCol; ++i)
+      norms[nnormsRow + i] = coWeights[i];
+  } else
+    return false;
 
-      case SPxSolverBase<R>::REGULAR:
-         os << "REGULAR";
-         break;
+  return true;
+}
 
-      case SPxSolverBase<R>::RUNNING:
-         os << "RUNNING";
-         break;
+template <class R>
+bool SPxSolverBase<R>::setDualNorms(int nnormsRow, int nnormsCol, R *norms) {
+  weightsAreSetup = false;
 
-      case SPxSolverBase<R>::UNKNOWN:
-         os << "UNKNOWN";
-         break;
+  if (type() == SPxSolverBase<R>::LEAVE && rep() == SPxSolverBase<R>::COLUMN) {
+    coWeights.reDim(dim(), false);
+    assert(coWeights.dim() >= nnormsRow);
 
-      case SPxSolverBase<R>::OPTIMAL:
-         os << "OPTIMAL";
-         break;
+    for (int i = 0; i < nnormsRow; ++i)
+      coWeights[i] = norms[i];
 
-      case SPxSolverBase<R>::UNBOUNDED:
-         os << "UNBOUNDED";
-         break;
+    weightsAreSetup = true;
+  } else if (type() == SPxSolverBase<R>::ENTER &&
+             rep() == SPxSolverBase<R>::ROW) {
+    weights.reDim(coDim(), false);
+    coWeights.reDim(dim(), false);
+    assert(weights.dim() >= nnormsRow);
+    assert(coWeights.dim() >= nnormsCol);
 
-      case SPxSolverBase<R>::INFEASIBLE:
-         os << "INFEASIBLE";
-         break;
+    for (int i = 0; i < nnormsRow; ++i)
+      weights[i] = norms[i];
 
-      default:
-         os << "?other?";
-         break;
-      }
+    for (int i = 0; i < nnormsCol; ++i)
+      coWeights[i] = norms[nnormsRow + i];
 
-      return os;
-   }
+    weightsAreSetup = true;
+  } else
+    return false;
 
-   // Pretty-printing of algorithm.
-   template <class R>
-   std::ostream& operator<<(std::ostream & os,
-                            const typename SPxSolverBase<R>::Type & status)
-   {
-      switch(status)
-      {
-      case SPxSolverBase<R>::ENTER:
-         os << "ENTER";
-         break;
+  return true;
+}
 
-      case SPxSolverBase<R>::LEAVE:
-         os << "LEAVE";
-         break;
+template <class R>
+void SPxSolverBase<R>::setIntegralityInformation(int ncols, int *intInfo) {
+  assert(ncols == this->nCols() || (ncols == 0 && intInfo == NULL));
 
-      default:
-         os << "?other?";
-         break;
-      }
+  integerVariables.reSize(ncols);
 
-      return os;
-   }
+  for (int i = 0; i < ncols; ++i) {
+    integerVariables[i] = intInfo[i];
+  }
+}
 
-   // Pretty-printing of representation.
-   template <class R>
-   std::ostream& operator<<(std::ostream & os,
-                            const typename SPxSolverBase<R>::Representation & status)
-   {
-      switch(status)
-      {
-      case SPxSolverBase<R>::ROW:
-         os << "ROW";
-         break;
+//
+// Auxiliary functions.
+//
 
-      case SPxSolverBase<R>::COLUMN:
-         os << "COLUMN";
-         break;
+// Pretty-printing of variable status.
+template <class R>
+std::ostream &operator<<(std::ostream &os,
+                         const typename SPxSolverBase<R>::VarStatus &status) {
+  switch (status) {
+  case SPxSolverBase<R>::BASIC:
+    os << "BASIC";
+    break;
+
+  case SPxSolverBase<R>::FIXED:
+    os << "FIXED";
+    break;
+
+  case SPxSolverBase<R>::ON_LOWER:
+    os << "ON_LOWER";
+    break;
+
+  case SPxSolverBase<R>::ON_UPPER:
+    os << "ON_UPPER";
+    break;
+
+  case SPxSolverBase<R>::ZERO:
+    os << "ZERO";
+    break;
+
+  case SPxSolverBase<R>::UNDEFINED:
+    os << "UNDEFINED";
+    break;
+
+  default:
+    os << "?invalid?";
+    break;
+  }
+
+  return os;
+}
 
-      default:
-         os << "?other?";
-         break;
-      }
+// Pretty-printing of solver status.
+template <class R>
+std::ostream &operator<<(std::ostream &os,
+                         const typename SPxSolverBase<R>::Status &status) {
+  switch (status) {
+  case SPxSolverBase<R>::ERROR:
+    os << "ERROR";
+    break;
+
+  case SPxSolverBase<R>::NO_RATIOTESTER:
+    os << "NO_RATIOTESTER";
+    break;
+
+  case SPxSolverBase<R>::NO_PRICER:
+    os << "NO_PRICER";
+    break;
+
+  case SPxSolverBase<R>::NO_SOLVER:
+    os << "NO_SOLVER";
+    break;
+
+  case SPxSolverBase<R>::NOT_INIT:
+    os << "NOT_INIT";
+    break;
+
+  case SPxSolverBase<R>::ABORT_CYCLING:
+    os << "ABORT_CYCLING";
+    break;
+
+  case SPxSolverBase<R>::ABORT_TIME:
+    os << "ABORT_TIME";
+    break;
+
+  case SPxSolverBase<R>::ABORT_ITER:
+    os << "ABORT_ITER";
+    break;
+
+  case SPxSolverBase<R>::ABORT_VALUE:
+    os << "ABORT_VALUE";
+    break;
+
+  case SPxSolverBase<R>::SINGULAR:
+    os << "SINGULAR";
+    break;
+
+  case SPxSolverBase<R>::NO_PROBLEM:
+    os << "NO_PROBLEM";
+    break;
+
+  case SPxSolverBase<R>::REGULAR:
+    os << "REGULAR";
+    break;
+
+  case SPxSolverBase<R>::RUNNING:
+    os << "RUNNING";
+    break;
+
+  case SPxSolverBase<R>::UNKNOWN:
+    os << "UNKNOWN";
+    break;
+
+  case SPxSolverBase<R>::OPTIMAL:
+    os << "OPTIMAL";
+    break;
+
+  case SPxSolverBase<R>::UNBOUNDED:
+    os << "UNBOUNDED";
+    break;
+
+  case SPxSolverBase<R>::INFEASIBLE:
+    os << "INFEASIBLE";
+    break;
+
+  default:
+    os << "?other?";
+    break;
+  }
+
+  return os;
+}
 
-      return os;
-   }
+// Pretty-printing of algorithm.
+template <class R>
+std::ostream &operator<<(std::ostream &os,
+                         const typename SPxSolverBase<R>::Type &status) {
+  switch (status) {
+  case SPxSolverBase<R>::ENTER:
+    os << "ENTER";
+    break;
+
+  case SPxSolverBase<R>::LEAVE:
+    os << "LEAVE";
+    break;
+
+  default:
+    os << "?other?";
+    break;
+  }
+
+  return os;
+}
 
+// Pretty-printing of representation.
+template <class R>
+std::ostream &
+operator<<(std::ostream &os,
+           const typename SPxSolverBase<R>::Representation &status) {
+  switch (status) {
+  case SPxSolverBase<R>::ROW:
+    os << "ROW";
+    break;
+
+  case SPxSolverBase<R>::COLUMN:
+    os << "COLUMN";
+    break;
+
+  default:
+    os << "?other?";
+    break;
+  }
+
+  return os;
+}
 
 } // namespace soplex
diff --git a/src/soplex/spxstarter.hpp b/src/soplex/spxstarter.hpp
index 479503b..a8ad5ce 100644
--- a/src/soplex/spxstarter.hpp
+++ b/src/soplex/spxstarter.hpp
@@ -21,21 +21,19 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <assert.h>
 #include <iostream>
 
 #include "soplex/spxdefines.h"
 
-namespace soplex
-{
-template <class R>
-bool SPxStarter<R>::isConsistent() const
-{
+namespace soplex {
+template <class R> bool SPxStarter<R>::isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
-   MSG_ERROR(std::cerr << "ESTART95 Not yet implemented" << std::endl;)
+  MSG_ERROR(std::cerr << "ESTART95 Not yet implemented" << std::endl;)
 #endif
 
-   return true;
+  return true;
 }
 } // namespace soplex
diff --git a/src/soplex/spxsteeppr.hpp b/src/soplex/spxsteeppr.hpp
index 857cb70..f77f896 100644
--- a/src/soplex/spxsteeppr.hpp
+++ b/src/soplex/spxsteeppr.hpp
@@ -21,1132 +21,978 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
-//TODO may be faster to have a greater zero tolerance for sparse pricing vectors
-//     to reduce the number of nonzero entries, e.g. for workVec
+// TODO may be faster to have a greater zero tolerance for sparse pricing
+// vectors
+//      to reduce the number of nonzero entries, e.g. for workVec
 
 #include <assert.h>
 #include <iostream>
 
+#include "soplex/random.h"
 #include "soplex/spxdefines.h"
 #include "soplex/spxsteeppr.h"
-#include "soplex/random.h"
 
 #define STEEP_REFINETOL 2.0
 
-namespace soplex
-{
+namespace soplex {
 // #define EQ_PREF 1000
 
-template <class R>
-void SPxSteepPR<R>::clear()
-{
-   this->thesolver = 0;
-}
+template <class R> void SPxSteepPR<R>::clear() { this->thesolver = 0; }
 
-template <class R>
-void SPxSteepPR<R>::load(SPxSolverBase<R>* base)
-{
-   this->thesolver = base;
-
-   if(base)
-   {
-      workVec.clear();
-      workVec.reDim(base->dim());
-      workRhs.clear();
-      workRhs.reDim(base->dim());
-   }
+template <class R> void SPxSteepPR<R>::load(SPxSolverBase<R> *base) {
+  this->thesolver = base;
+
+  if (base) {
+    workVec.clear();
+    workVec.reDim(base->dim());
+    workRhs.clear();
+    workRhs.reDim(base->dim());
+  }
 }
 
 template <class R>
-void SPxSteepPR<R>::setType(typename SPxSolverBase<R>::Type type)
-{
-   workRhs.setEpsilon(this->thesolver->epsilon());
-
-   setupWeights(type);
-   workVec.clear();
-   workRhs.clear();
-   refined = false;
-
-   bestPrices.clear();
-   bestPrices.setMax(this->thesolver->dim());
-   prices.reSize(this->thesolver->dim());
-
-   if(type == SPxSolverBase<R>::ENTER)
-   {
-      bestPricesCo.clear();
-      bestPricesCo.setMax(this->thesolver->coDim());
-      pricesCo.reSize(this->thesolver->coDim());
-   }
+void SPxSteepPR<R>::setType(typename SPxSolverBase<R>::Type type) {
+  workRhs.setEpsilon(this->thesolver->epsilon());
+
+  setupWeights(type);
+  workVec.clear();
+  workRhs.clear();
+  refined = false;
+
+  bestPrices.clear();
+  bestPrices.setMax(this->thesolver->dim());
+  prices.reSize(this->thesolver->dim());
+
+  if (type == SPxSolverBase<R>::ENTER) {
+    bestPricesCo.clear();
+    bestPricesCo.setMax(this->thesolver->coDim());
+    pricesCo.reSize(this->thesolver->coDim());
+  }
 }
 
 template <class R>
-void SPxSteepPR<R>::setupWeights(typename SPxSolverBase<R>::Type type)
-{
-   int i;
-   int endDim = 0;
-   int endCoDim = 0;
-   VectorBase<R>& weights = this->thesolver->weights;
-   VectorBase<R>& coWeights = this->thesolver->coWeights;
-
-   if(setup == DEFAULT)
-   {
-      if(type == SPxSolverBase<R>::ENTER)
-      {
-         if(this->thesolver->weightsAreSetup)
-         {
-            // check for added/removed rows and adapt norms accordingly
-            if(coWeights.dim() < this->thesolver->dim())
-               endDim = coWeights.dim();
-            else
-               endDim = this->thesolver->dim();
-
-            if(weights.dim() < this->thesolver->coDim())
-               endCoDim = weights.dim();
-            else
-               endCoDim = this->thesolver->coDim();
-         }
-
-         coWeights.reDim(this->thesolver->dim(), false);
-
-         for(i = this->thesolver->dim() - 1; i >= endDim; --i)
-            coWeights[i] = 2.0;
-
-         weights.reDim(this->thesolver->coDim(), false);
-
-         for(i = this->thesolver->coDim() - 1; i >= endCoDim; --i)
-            weights[i] = 1.0;
-      }
-      else
-      {
-         assert(type == SPxSolverBase<R>::LEAVE);
-
-         if(this->thesolver->weightsAreSetup)
-         {
-            // check for added/removed rows and adapt norms accordingly
-            if(coWeights.dim() < this->thesolver->dim())
-               endDim = coWeights.dim();
-            else
-               endDim = this->thesolver->dim();
-         }
-
-         coWeights.reDim(this->thesolver->dim(), false);
-
-         for(i = this->thesolver->dim() - 1; i >= endDim; --i)
-            coWeights[i]   = 1.0;
-      }
-   }
-   else
-   {
-      MSG_INFO1((*this->thesolver->spxout),
-                (*this->thesolver->spxout) << " --- initializing steepest edge multipliers" << std::endl;)
-
-      if(type == SPxSolverBase<R>::ENTER)
-      {
-         coWeights.reDim(this->thesolver->dim(), false);
-
-         for(i = this->thesolver->dim() - 1; i >= endDim; --i)
-            coWeights[i] = 1.0;
-
-         weights.reDim(this->thesolver->coDim(), false);
-
-         for(i = this->thesolver->coDim() - 1; i >= endCoDim; --i)
-            weights[i] = 1.0 + this->thesolver->vector(i).length2();
-      }
-      else
-      {
-         assert(type == SPxSolverBase<R>::LEAVE);
-         coWeights.reDim(this->thesolver->dim(), false);
-         SSVectorBase<R>  tmp(this->thesolver->dim(), this->thesolver->epsilon());
-
-         for(i = this->thesolver->dim() - 1; i >= endDim && !this->thesolver->isTimeLimitReached(); --i)
-         {
-            this->thesolver->basis().coSolve(tmp, this->thesolver->unitVector(i));
-            coWeights[i] = tmp.length2();
-         }
-      }
-   }
-
-   this->thesolver->weightsAreSetup = true;
+void SPxSteepPR<R>::setupWeights(typename SPxSolverBase<R>::Type type) {
+  int i;
+  int endDim = 0;
+  int endCoDim = 0;
+  VectorBase<R> &weights = this->thesolver->weights;
+  VectorBase<R> &coWeights = this->thesolver->coWeights;
+
+  if (setup == DEFAULT) {
+    if (type == SPxSolverBase<R>::ENTER) {
+      if (this->thesolver->weightsAreSetup) {
+        // check for added/removed rows and adapt norms accordingly
+        if (coWeights.dim() < this->thesolver->dim())
+          endDim = coWeights.dim();
+        else
+          endDim = this->thesolver->dim();
+
+        if (weights.dim() < this->thesolver->coDim())
+          endCoDim = weights.dim();
+        else
+          endCoDim = this->thesolver->coDim();
+      }
+
+      coWeights.reDim(this->thesolver->dim(), false);
+
+      for (i = this->thesolver->dim() - 1; i >= endDim; --i)
+        coWeights[i] = 2.0;
+
+      weights.reDim(this->thesolver->coDim(), false);
+
+      for (i = this->thesolver->coDim() - 1; i >= endCoDim; --i)
+        weights[i] = 1.0;
+    } else {
+      assert(type == SPxSolverBase<R>::LEAVE);
+
+      if (this->thesolver->weightsAreSetup) {
+        // check for added/removed rows and adapt norms accordingly
+        if (coWeights.dim() < this->thesolver->dim())
+          endDim = coWeights.dim();
+        else
+          endDim = this->thesolver->dim();
+      }
+
+      coWeights.reDim(this->thesolver->dim(), false);
+
+      for (i = this->thesolver->dim() - 1; i >= endDim; --i)
+        coWeights[i] = 1.0;
+    }
+  } else {
+    MSG_INFO1((*this->thesolver->spxout),
+              (*this->thesolver->spxout)
+                  << " --- initializing steepest edge multipliers"
+                  << std::endl;)
+
+    if (type == SPxSolverBase<R>::ENTER) {
+      coWeights.reDim(this->thesolver->dim(), false);
+
+      for (i = this->thesolver->dim() - 1; i >= endDim; --i)
+        coWeights[i] = 1.0;
+
+      weights.reDim(this->thesolver->coDim(), false);
+
+      for (i = this->thesolver->coDim() - 1; i >= endCoDim; --i)
+        weights[i] = 1.0 + this->thesolver->vector(i).length2();
+    } else {
+      assert(type == SPxSolverBase<R>::LEAVE);
+      coWeights.reDim(this->thesolver->dim(), false);
+      SSVectorBase<R> tmp(this->thesolver->dim(), this->thesolver->epsilon());
+
+      for (i = this->thesolver->dim() - 1;
+           i >= endDim && !this->thesolver->isTimeLimitReached(); --i) {
+        this->thesolver->basis().coSolve(tmp, this->thesolver->unitVector(i));
+        coWeights[i] = tmp.length2();
+      }
+    }
+  }
+
+  this->thesolver->weightsAreSetup = true;
 }
 
 template <class R>
-void SPxSteepPR<R>::setRep(typename SPxSolverBase<R>::Representation)
-{
-   if(workVec.dim() != this->thesolver->dim())
-   {
-      VectorBase<R> tmp = this->thesolver->weights;
-      this->thesolver->weights = this->thesolver->coWeights;
-      this->thesolver->coWeights = tmp;
-
-      workVec.clear();
-      workVec.reDim(this->thesolver->dim());
-   }
+void SPxSteepPR<R>::setRep(typename SPxSolverBase<R>::Representation) {
+  if (workVec.dim() != this->thesolver->dim()) {
+    VectorBase<R> tmp = this->thesolver->weights;
+    this->thesolver->weights = this->thesolver->coWeights;
+    this->thesolver->coWeights = tmp;
+
+    workVec.clear();
+    workVec.reDim(this->thesolver->dim());
+  }
 }
 
-template <class R>
-void SPxSteepPR<R>::left4(int n, SPxId id)
-{
-   assert(this->thesolver->type() == SPxSolverBase<R>::LEAVE);
-
-   if(id.isValid())
-   {
-      R        delta         = 0.1 + 1.0 / this->thesolver->basis().iteration();
-      R*       coWeights_ptr = this->thesolver->coWeights.get_ptr();
-      const R* workVec_ptr   = workVec.get_const_ptr();
-      const R* rhoVec        = this->thesolver->fVec().delta().values();
-      R        rhov_1        = 1.0 / rhoVec[n];
-      R        beta_q        = this->thesolver->coPvec().delta().length2() * rhov_1 * rhov_1;
+template <class R> void SPxSteepPR<R>::left4(int n, SPxId id) {
+  assert(this->thesolver->type() == SPxSolverBase<R>::LEAVE);
+
+  if (id.isValid()) {
+    R delta = 0.1 + 1.0 / this->thesolver->basis().iteration();
+    R *coWeights_ptr = this->thesolver->coWeights.get_ptr();
+    const R *workVec_ptr = workVec.get_const_ptr();
+    const R *rhoVec = this->thesolver->fVec().delta().values();
+    R rhov_1 = 1.0 / rhoVec[n];
+    R beta_q = this->thesolver->coPvec().delta().length2() * rhov_1 * rhov_1;
 
 #ifndef NDEBUG
 
-      if(spxAbs(rhoVec[n]) < this->theeps * 0.5)
-      {
-         MSG_INFO3((*this->thesolver->spxout), (*this->thesolver->spxout) << "WSTEEP04: rhoVec = "
-                   << rhoVec[n] << " with smaller absolute value than 0.5*theeps = " << 0.5 * this->theeps <<
-                   std::endl;)
-      }
+    if (spxAbs(rhoVec[n]) < this->theeps * 0.5) {
+      MSG_INFO3((*this->thesolver->spxout),
+                (*this->thesolver->spxout)
+                    << "WSTEEP04: rhoVec = " << rhoVec[n]
+                    << " with smaller absolute value than 0.5*theeps = "
+                    << 0.5 * this->theeps << std::endl;)
+    }
 
 #endif
 
-      const IdxSet& rhoIdx = this->thesolver->fVec().idx();
-      int           len    = this->thesolver->fVec().idx().size();
+    const IdxSet &rhoIdx = this->thesolver->fVec().idx();
+    int len = this->thesolver->fVec().idx().size();
 
-      for(int i = 0; i < len; ++i)
-      {
-         int  j = rhoIdx.index(i);
-         coWeights_ptr[j] += rhoVec[j] * (beta_q * rhoVec[j] - 2.0 * rhov_1 * workVec_ptr[j]);
+    for (int i = 0; i < len; ++i) {
+      int j = rhoIdx.index(i);
+      coWeights_ptr[j] +=
+          rhoVec[j] * (beta_q * rhoVec[j] - 2.0 * rhov_1 * workVec_ptr[j]);
 
-         if(coWeights_ptr[j] < delta)
-            coWeights_ptr[j] = delta; // coWeights_ptr[j] = delta / (1+delta-x);
-         else if(coWeights_ptr[j] >= R(infinity))
-            coWeights_ptr[j] = 1.0 / this->theeps;
-      }
+      if (coWeights_ptr[j] < delta)
+        coWeights_ptr[j] = delta; // coWeights_ptr[j] = delta / (1+delta-x);
+      else if (coWeights_ptr[j] >= R(infinity))
+        coWeights_ptr[j] = 1.0 / this->theeps;
+    }
 
-      coWeights_ptr[n] = beta_q;
-   }
+    coWeights_ptr[n] = beta_q;
+  }
 }
 
-
-namespace steeppr
-{
-template <class R>
-R computePrice(R viol, R weight, R tol)
-{
-   if(weight < tol)
-      return viol * viol / tol;
-   else
-      return viol * viol / weight;
+namespace steeppr {
+template <class R> R computePrice(R viol, R weight, R tol) {
+  if (weight < tol)
+    return viol * viol / tol;
+  else
+    return viol * viol / weight;
 }
+} // namespace steeppr
+
+template <class R> int SPxSteepPR<R>::buildBestPriceVectorLeave(R feastol) {
+  int idx;
+  int nsorted;
+  R x;
+  const R *fTest = this->thesolver->fTest().get_const_ptr();
+  const R *cpen = this->thesolver->coWeights.get_const_ptr();
+  typename SPxPricer<R>::IdxElement price;
+  prices.clear();
+  bestPrices.clear();
+
+  // construct vector of all prices
+  for (int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->infeasibilities.index(i);
+    x = fTest[idx];
+
+    if (x < -feastol) {
+      // it might happen that we call the pricer with a tighter tolerance than
+      // what was used when computing the violations
+      this->thesolver->isInfeasible[idx] = this->VIOLATED;
+      price.val = steeppr::computePrice(x, cpen[idx], feastol);
+      price.idx = idx;
+      prices.append(price);
+    }
+  }
+
+  // set up structures for the quicksort implementation
+  this->compare.elements = prices.get_const_ptr();
+  // do a partial sort to move the best ones to the front
+  // TODO this can be done more efficiently, since we only need the indices
+  nsorted = SPxQuicksortPart(prices.get_ptr(), this->compare, 0, prices.size(),
+                             HYPERPRICINGSIZE);
+
+  // copy indices of best values to bestPrices
+  for (int i = 0; i < nsorted; ++i) {
+    bestPrices.addIdx(prices[i].idx);
+    this->thesolver->isInfeasible[prices[i].idx] = this->VIOLATED_AND_CHECKED;
+  }
+
+  if (nsorted > 0)
+    return prices[0].idx;
+  else
+    return -1;
 }
 
-template <class R>
-int SPxSteepPR<R>::buildBestPriceVectorLeave(R feastol)
-{
-   int idx;
-   int nsorted;
-   R x;
-   const R* fTest = this->thesolver->fTest().get_const_ptr();
-   const R* cpen = this->thesolver->coWeights.get_const_ptr();
-   typename SPxPricer<R>::IdxElement price;
-   prices.clear();
-   bestPrices.clear();
-
-   // construct vector of all prices
-   for(int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->infeasibilities.index(i);
-      x = fTest[idx];
-
-      if(x < -feastol)
-      {
-         // it might happen that we call the pricer with a tighter tolerance than what was used when computing the violations
-         this->thesolver->isInfeasible[idx] = this->VIOLATED;
-         price.val = steeppr::computePrice(x, cpen[idx], feastol);
-         price.idx = idx;
-         prices.append(price);
-      }
-   }
-
-   // set up structures for the quicksort implementation
-   this->compare.elements = prices.get_const_ptr();
-   // do a partial sort to move the best ones to the front
-   // TODO this can be done more efficiently, since we only need the indices
-   nsorted = SPxQuicksortPart(prices.get_ptr(), this->compare, 0, prices.size(), HYPERPRICINGSIZE);
-
-   // copy indices of best values to bestPrices
-   for(int i = 0; i < nsorted; ++i)
-   {
-      bestPrices.addIdx(prices[i].idx);
-      this->thesolver->isInfeasible[prices[i].idx] = this->VIOLATED_AND_CHECKED;
-   }
-
-   if(nsorted > 0)
-      return prices[0].idx;
-   else
-      return -1;
+template <class R> int SPxSteepPR<R>::selectLeave() {
+  assert(isConsistent());
+
+  int retid;
+
+  if (this->thesolver->hyperPricingLeave &&
+      this->thesolver->sparsePricingLeave) {
+    if (bestPrices.size() < 2 || this->thesolver->basis().lastUpdate() == 0) {
+      // call init method to build up price-vector and return index of largest
+      // price
+      retid = buildBestPriceVectorLeave(this->theeps);
+    } else
+      retid = selectLeaveHyper(this->theeps);
+  } else if (this->thesolver->sparsePricingLeave)
+    retid = selectLeaveSparse(this->theeps);
+  else
+    retid = selectLeaveX(this->theeps);
+
+  if (retid < 0 && !refined) {
+    refined = true;
+    MSG_INFO3((*this->thesolver->spxout),
+              (*this->thesolver->spxout)
+                  << "WSTEEP03 trying refinement step..\n";)
+    retid = selectLeaveX(this->theeps / STEEP_REFINETOL);
+  }
+
+  if (retid >= 0) {
+    assert(this->thesolver->coPvec().delta().isConsistent());
+    // coPvec().delta() might be not setup after the solve when it contains too
+    // many nonzeros. This is intended and forcing to keep the sparsity
+    // information leads to a slowdown
+    // TODO implement a dedicated solve method for unitvectors
+    this->thesolver->basis().coSolve(this->thesolver->coPvec().delta(),
+                                     this->thesolver->unitVector(retid));
+    assert(this->thesolver->coPvec().delta().isConsistent());
+    workRhs.setup_and_assign(this->thesolver->coPvec().delta());
+    this->thesolver->setup4solve(&workVec, &workRhs);
+  }
+
+  return retid;
 }
 
+template <class R> int SPxSteepPR<R>::selectLeaveX(R tol) {
+  const R *coWeights_ptr = this->thesolver->coWeights.get_const_ptr();
+  const R *fTest = this->thesolver->fTest().get_const_ptr();
+  R best = R(-infinity);
+  R x;
+  int lastIdx = -1;
 
-template <class R>
-int SPxSteepPR<R>::selectLeave()
-{
-   assert(isConsistent());
-
-   int retid;
-
-   if(this->thesolver->hyperPricingLeave && this->thesolver->sparsePricingLeave)
-   {
-      if(bestPrices.size() < 2 || this->thesolver->basis().lastUpdate() == 0)
-      {
-         // call init method to build up price-vector and return index of largest price
-         retid = buildBestPriceVectorLeave(this->theeps);
-      }
-      else
-         retid = selectLeaveHyper(this->theeps);
-   }
-   else if(this->thesolver->sparsePricingLeave)
-      retid = selectLeaveSparse(this->theeps);
-   else
-      retid = selectLeaveX(this->theeps);
-
-   if(retid < 0 && !refined)
-   {
-      refined = true;
-      MSG_INFO3((*this->thesolver->spxout),
-                (*this->thesolver->spxout) << "WSTEEP03 trying refinement step..\n";)
-      retid = selectLeaveX(this->theeps / STEEP_REFINETOL);
-   }
-
-   if(retid >= 0)
-   {
-      assert(this->thesolver->coPvec().delta().isConsistent());
-      // coPvec().delta() might be not setup after the solve when it contains too many nonzeros.
-      // This is intended and forcing to keep the sparsity information leads to a slowdown
-      // TODO implement a dedicated solve method for unitvectors
-      this->thesolver->basis().coSolve(this->thesolver->coPvec().delta(),
-                                       this->thesolver->unitVector(retid));
-      assert(this->thesolver->coPvec().delta().isConsistent());
-      workRhs.setup_and_assign(this->thesolver->coPvec().delta());
-      this->thesolver->setup4solve(&workVec, &workRhs);
-   }
-
-   return retid;
-}
+  for (int i = this->thesolver->dim() - 1; i >= 0; --i) {
+    x = fTest[i];
 
-template <class R>
-int SPxSteepPR<R>::selectLeaveX(R tol)
-{
-   const R* coWeights_ptr = this->thesolver->coWeights.get_const_ptr();
-   const R* fTest         = this->thesolver->fTest().get_const_ptr();
-   R best = R(-infinity);
-   R x;
-   int lastIdx = -1;
-
-   for(int i = this->thesolver->dim() - 1; i >= 0; --i)
-   {
-      x = fTest[i];
-
-      if(x < -tol)
-      {
-         x = steeppr::computePrice(x, coWeights_ptr[i], tol);
-
-         if(x > best)
-         {
-            best = x;
-            lastIdx = i;
-         }
+    if (x < -tol) {
+      x = steeppr::computePrice(x, coWeights_ptr[i], tol);
+
+      if (x > best) {
+        best = x;
+        lastIdx = i;
       }
-   }
+    }
+  }
 
-   return lastIdx;
+  return lastIdx;
 }
 
-template <class R>
-int SPxSteepPR<R>::selectLeaveSparse(R tol)
-{
-   const R* coWeights_ptr = this->thesolver->coWeights.get_const_ptr();
-   const R* fTest         = this->thesolver->fTest().get_const_ptr();
-   R best = R(-infinity);
-   R x;
-   int lastIdx = -1;
-   int idx;
-
-   for(int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->infeasibilities.index(i);
-      x = fTest[idx];
-
-      if(x < -tol)
-      {
-         x = steeppr::computePrice(x, coWeights_ptr[idx], tol);
-
-         if(x > best)
-         {
-            best = x;
-            lastIdx = idx;
-         }
-      }
-      else
-      {
-         this->thesolver->infeasibilities.remove(i);
-         assert(this->thesolver->isInfeasible[idx] == this->VIOLATED
-                || this->thesolver->isInfeasible[idx] == this->VIOLATED_AND_CHECKED);
-         this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
-      }
-   }
-
-   return lastIdx;
+template <class R> int SPxSteepPR<R>::selectLeaveSparse(R tol) {
+  const R *coWeights_ptr = this->thesolver->coWeights.get_const_ptr();
+  const R *fTest = this->thesolver->fTest().get_const_ptr();
+  R best = R(-infinity);
+  R x;
+  int lastIdx = -1;
+  int idx;
+
+  for (int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->infeasibilities.index(i);
+    x = fTest[idx];
+
+    if (x < -tol) {
+      x = steeppr::computePrice(x, coWeights_ptr[idx], tol);
+
+      if (x > best) {
+        best = x;
+        lastIdx = idx;
+      }
+    } else {
+      this->thesolver->infeasibilities.remove(i);
+      assert(this->thesolver->isInfeasible[idx] == this->VIOLATED ||
+             this->thesolver->isInfeasible[idx] == this->VIOLATED_AND_CHECKED);
+      this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
+    }
+  }
+
+  return lastIdx;
 }
 
-template <class R>
-int SPxSteepPR<R>::selectLeaveHyper(R tol)
-{
-   const R* coPen = this->thesolver->coWeights.get_const_ptr();
-   const R* fTest = this->thesolver->fTest().get_const_ptr();
-   R leastBest = -1;
-   R best = R(-infinity);
-   R x;
-   int bestIdx = -1;
-   int idx = 0;
-
-   // find the best price from the short candidate list
-   for(int i = bestPrices.size() - 1; i >= 0; --i)
-   {
-      idx = bestPrices.index(i);
+template <class R> int SPxSteepPR<R>::selectLeaveHyper(R tol) {
+  const R *coPen = this->thesolver->coWeights.get_const_ptr();
+  const R *fTest = this->thesolver->fTest().get_const_ptr();
+  R leastBest = -1;
+  R best = R(-infinity);
+  R x;
+  int bestIdx = -1;
+  int idx = 0;
+
+  // find the best price from the short candidate list
+  for (int i = bestPrices.size() - 1; i >= 0; --i) {
+    idx = bestPrices.index(i);
+    x = fTest[idx];
+
+    if (x < -tol) {
+      assert(this->thesolver->isInfeasible[idx] == this->VIOLATED ||
+             this->thesolver->isInfeasible[idx] == this->VIOLATED_AND_CHECKED);
+      x = steeppr::computePrice(x, coPen[idx], tol);
+
+      assert(x >= 0);
+
+      // update the best price of candidate list
+      if (x > best) {
+        best = x;
+        bestIdx = idx;
+      }
+
+      // update the smallest price of candidate list
+      if (x < leastBest || leastBest < 0)
+        leastBest = x;
+    } else {
+      bestPrices.remove(i);
+      this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
+    }
+  }
+
+  // scan the updated indices for a better price
+  for (int i = this->thesolver->updateViols.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->updateViols.index(i);
+
+    // is this index a candidate for bestPrices?
+    if (this->thesolver->isInfeasible[idx] == this->VIOLATED) {
       x = fTest[idx];
+      assert(x < -tol);
+      x = steeppr::computePrice(x, coPen[idx], tol);
 
-      if(x < -tol)
-      {
-         assert(this->thesolver->isInfeasible[idx] == this->VIOLATED
-                || this->thesolver->isInfeasible[idx] == this->VIOLATED_AND_CHECKED);
-         x = steeppr::computePrice(x, coPen[idx], tol);
-
-         assert(x >= 0);
+      if (x > leastBest) {
+        if (x > best) {
+          best = x;
+          bestIdx = idx;
+        }
 
-         // update the best price of candidate list
-         if(x > best)
-         {
-            best = x;
-            bestIdx = idx;
-         }
-
-         // update the smallest price of candidate list
-         if(x < leastBest || leastBest < 0)
-            leastBest = x;
-      }
-      else
-      {
-         bestPrices.remove(i);
-         this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
+        this->thesolver->isInfeasible[idx] = this->VIOLATED_AND_CHECKED;
+        bestPrices.addIdx(idx);
       }
-   }
-
-   // scan the updated indices for a better price
-   for(int i = this->thesolver->updateViols.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->updateViols.index(i);
-
-      // is this index a candidate for bestPrices?
-      if(this->thesolver->isInfeasible[idx] == this->VIOLATED)
-      {
-         x = fTest[idx];
-         assert(x < -tol);
-         x = steeppr::computePrice(x, coPen[idx], tol);
-
-         if(x > leastBest)
-         {
-            if(x > best)
-            {
-               best = x;
-               bestIdx = idx;
-            }
-
-            this->thesolver->isInfeasible[idx] = this->VIOLATED_AND_CHECKED;
-            bestPrices.addIdx(idx);
-         }
-      }
-   }
+    }
+  }
 
-   return bestIdx;
+  return bestIdx;
 }
 
 /* Entering Simplex
  */
+template <class R> void SPxSteepPR<R>::entered4(SPxId /* id */, int n) {
+  assert(this->thesolver->type() == SPxSolverBase<R>::ENTER);
+
+  if (n >= 0 && n < this->thesolver->dim()) {
+    R delta = 2 + 1.0 / this->thesolver->basis().iteration();
+    R *coWeights_ptr = this->thesolver->coWeights.get_ptr();
+    R *weights_ptr = this->thesolver->weights.get_ptr();
+    const R *workVec_ptr = workVec.get_const_ptr();
+    const R *pVec = this->thesolver->pVec().delta().values();
+    const IdxSet &pIdx = this->thesolver->pVec().idx();
+    const R *coPvec = this->thesolver->coPvec().delta().values();
+    const IdxSet &coPidx = this->thesolver->coPvec().idx();
+    R xi_p = 1 / this->thesolver->fVec().delta()[n];
+    int i, j;
+    R xi_ip;
+
+    assert(this->thesolver->fVec().delta()[n] > this->thesolver->epsilon() ||
+           this->thesolver->fVec().delta()[n] < -this->thesolver->epsilon());
+
+    for (j = coPidx.size() - 1; j >= 0; --j) {
+      i = coPidx.index(j);
+      xi_ip = xi_p * coPvec[i];
+      coWeights_ptr[i] += xi_ip * (xi_ip * pi_p - 2.0 * workVec_ptr[i]);
+
+      /*
+        if(coWeights_ptr[i] < 1)
+        coWeights_ptr[i] = 1 / (2-x);
+      */
+      if (coWeights_ptr[i] < delta)
+        coWeights_ptr[i] = delta;
+      // coWeights_ptr[i] = 1;
+      else if (coWeights_ptr[i] > R(infinity))
+        coWeights_ptr[i] = 1 / this->thesolver->epsilon();
+    }
+
+    for (j = pIdx.size() - 1; j >= 0; --j) {
+      i = pIdx.index(j);
+      xi_ip = xi_p * pVec[i];
+      weights_ptr[i] +=
+          xi_ip * (xi_ip * pi_p - 2.0 * (this->thesolver->vector(i) * workVec));
+
+      /*
+        if(weights_ptr[i] < 1)
+        weights_ptr[i] = 1 / (2-x);
+      */
+      if (weights_ptr[i] < delta)
+        weights_ptr[i] = delta;
+      // weights_ptr[i] = 1;
+      else if (weights_ptr[i] > R(infinity))
+        weights_ptr[i] = 1.0 / this->thesolver->epsilon();
+    }
+  }
+
+  /*@
+    if(this->thesolver->isId(id))
+    weights[   this->thesolver->number(id) ] *= 1.0001;
+    else if(this->thesolver->isCoId(id))
+    coWeights[ this->thesolver->number(id) ] *= 1.0001;
+  */
+}
+
 template <class R>
-void SPxSteepPR<R>::entered4(SPxId /* id */, int n)
-{
-   assert(this->thesolver->type() == SPxSolverBase<R>::ENTER);
-
-   if(n >= 0 && n < this->thesolver->dim())
-   {
-      R delta = 2 + 1.0 / this->thesolver->basis().iteration();
-      R* coWeights_ptr = this->thesolver->coWeights.get_ptr();
-      R* weights_ptr = this->thesolver->weights.get_ptr();
-      const R* workVec_ptr = workVec.get_const_ptr();
-      const R* pVec = this->thesolver->pVec().delta().values();
-      const IdxSet& pIdx = this->thesolver->pVec().idx();
-      const R* coPvec = this->thesolver->coPvec().delta().values();
-      const IdxSet& coPidx = this->thesolver->coPvec().idx();
-      R xi_p = 1 / this->thesolver->fVec().delta()[n];
-      int i, j;
-      R xi_ip;
-
-      assert(this->thesolver->fVec().delta()[n] > this->thesolver->epsilon()
-             || this->thesolver->fVec().delta()[n] < -this->thesolver->epsilon());
-
-      for(j = coPidx.size() - 1; j >= 0; --j)
-      {
-         i = coPidx.index(j);
-         xi_ip = xi_p * coPvec[i];
-         coWeights_ptr[i] += xi_ip * (xi_ip * pi_p - 2.0 * workVec_ptr[i]);
-
-         /*
-           if(coWeights_ptr[i] < 1)
-           coWeights_ptr[i] = 1 / (2-x);
-         */
-         if(coWeights_ptr[i] < delta)
-            coWeights_ptr[i] = delta;
-         // coWeights_ptr[i] = 1;
-         else if(coWeights_ptr[i] > R(infinity))
-            coWeights_ptr[i] = 1 / this->thesolver->epsilon();
-      }
+SPxId SPxSteepPR<R>::buildBestPriceVectorEnterDim(R &best, R feastol) {
+  const R *coTest = this->thesolver->coTest().get_const_ptr();
+  const R *coWeights_ptr = this->thesolver->coWeights.get_const_ptr();
+  int idx;
+  int nsorted;
+  R x;
+  typename SPxPricer<R>::IdxElement price;
+
+  prices.clear();
+  bestPrices.clear();
+
+  // construct vector of all prices
+  for (int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->infeasibilities.index(i);
+    x = coTest[idx];
+
+    if (x < -feastol) {
+      // it might happen that we call the pricer with a tighter tolerance than
+      // what was used when computing the violations
+      this->thesolver->isInfeasible[idx] = this->VIOLATED;
+      price.val = steeppr::computePrice(x, coWeights_ptr[idx], feastol);
+      price.idx = idx;
+      prices.append(price);
+    } else {
+      this->thesolver->infeasibilities.remove(i);
+      this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
+    }
+  }
+
+  // set up structures for the quicksort implementation
+  this->compare.elements = prices.get_const_ptr();
+  // do a partial sort to move the best ones to the front
+  // TODO this can be done more efficiently, since we only need the indices
+  nsorted = SPxQuicksortPart(prices.get_ptr(), this->compare, 0, prices.size(),
+                             HYPERPRICINGSIZE);
+
+  // copy indices of best values to bestPrices
+  for (int i = 0; i < nsorted; ++i) {
+    bestPrices.addIdx(prices[i].idx);
+    this->thesolver->isInfeasible[prices[i].idx] = this->VIOLATED_AND_CHECKED;
+  }
+
+  if (nsorted > 0) {
+    best = prices[0].val;
+    return this->thesolver->coId(prices[0].idx);
+  } else
+    return SPxId();
+}
 
-      for(j = pIdx.size() - 1; j >= 0; --j)
-      {
-         i = pIdx.index(j);
-         xi_ip = xi_p * pVec[i];
-         weights_ptr[i] += xi_ip * (xi_ip * pi_p - 2.0 * (this->thesolver->vector(i) * workVec));
-
-         /*
-           if(weights_ptr[i] < 1)
-           weights_ptr[i] = 1 / (2-x);
-         */
-         if(weights_ptr[i] < delta)
-            weights_ptr[i] = delta;
-         // weights_ptr[i] = 1;
-         else if(weights_ptr[i] > R(infinity))
-            weights_ptr[i] = 1.0 / this->thesolver->epsilon();
-      }
-   }
+template <class R>
+SPxId SPxSteepPR<R>::buildBestPriceVectorEnterCoDim(R &best, R feastol) {
+  const R *test = this->thesolver->test().get_const_ptr();
+  const R *weights_ptr = this->thesolver->weights.get_const_ptr();
+  int idx;
+  int nsorted;
+  R x;
+  typename SPxPricer<R>::IdxElement price;
+
+  pricesCo.clear();
+  bestPricesCo.clear();
+
+  // construct vector of all prices
+  for (int i = this->thesolver->infeasibilitiesCo.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->infeasibilitiesCo.index(i);
+    x = test[idx];
+
+    if (x < -feastol) {
+      // it might happen that we call the pricer with a tighter tolerance than
+      // what was used when computing the violations
+      this->thesolver->isInfeasibleCo[idx] = this->VIOLATED;
+      price.val = steeppr::computePrice(x, weights_ptr[idx], feastol);
+      price.idx = idx;
+      pricesCo.append(price);
+    } else {
+      this->thesolver->infeasibilitiesCo.remove(i);
+      this->thesolver->isInfeasibleCo[idx] = this->NOT_VIOLATED;
+    }
+  }
+
+  // set up structures for the quicksort implementation
+  this->compare.elements = pricesCo.get_const_ptr();
+  // do a partial sort to move the best ones to the front
+  // TODO this can be done more efficiently, since we only need the indices
+  nsorted = SPxQuicksortPart(pricesCo.get_ptr(), this->compare, 0,
+                             pricesCo.size(), HYPERPRICINGSIZE);
+
+  // copy indices of best values to bestPrices
+  for (int i = 0; i < nsorted; ++i) {
+    bestPricesCo.addIdx(pricesCo[i].idx);
+    this->thesolver->isInfeasibleCo[pricesCo[i].idx] =
+        this->VIOLATED_AND_CHECKED;
+  }
+
+  if (nsorted > 0) {
+    best = pricesCo[0].val;
+    return this->thesolver->id(pricesCo[0].idx);
+  } else
+    return SPxId();
+}
 
-   /*@
-     if(this->thesolver->isId(id))
-     weights[   this->thesolver->number(id) ] *= 1.0001;
-     else if(this->thesolver->isCoId(id))
-     coWeights[ this->thesolver->number(id) ] *= 1.0001;
-   */
+template <class R> SPxId SPxSteepPR<R>::selectEnter() {
+  assert(this->thesolver != 0);
+  SPxId enterId;
 
-}
+  enterId = selectEnterX(this->theeps);
 
+  if (!enterId.isValid() && !refined) {
+    refined = true;
+    MSG_INFO3((*this->thesolver->spxout),
+              (*this->thesolver->spxout)
+                  << "WSTEEP05 trying refinement step..\n";)
+    enterId = selectEnterX(this->theeps / STEEP_REFINETOL);
+  }
 
-template <class R>
-SPxId SPxSteepPR<R>::buildBestPriceVectorEnterDim(R& best, R feastol)
-{
-   const R* coTest        = this->thesolver->coTest().get_const_ptr();
-   const R* coWeights_ptr = this->thesolver->coWeights.get_const_ptr();
-   int idx;
-   int nsorted;
-   R x;
-   typename SPxPricer<R>::IdxElement price;
-
-   prices.clear();
-   bestPrices.clear();
-
-   // construct vector of all prices
-   for(int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->infeasibilities.index(i);
-      x = coTest[idx];
+  assert(isConsistent());
 
-      if(x < -feastol)
-      {
-         // it might happen that we call the pricer with a tighter tolerance than what was used when computing the violations
-         this->thesolver->isInfeasible[idx] = this->VIOLATED;
-         price.val = steeppr::computePrice(x, coWeights_ptr[idx], feastol);
-         price.idx = idx;
-         prices.append(price);
-      }
-      else
-      {
-         this->thesolver->infeasibilities.remove(i);
-         this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
-      }
-   }
-
-   // set up structures for the quicksort implementation
-   this->compare.elements = prices.get_const_ptr();
-   // do a partial sort to move the best ones to the front
-   // TODO this can be done more efficiently, since we only need the indices
-   nsorted = SPxQuicksortPart(prices.get_ptr(), this->compare, 0, prices.size(), HYPERPRICINGSIZE);
-
-   // copy indices of best values to bestPrices
-   for(int i = 0; i < nsorted; ++i)
-   {
-      bestPrices.addIdx(prices[i].idx);
-      this->thesolver->isInfeasible[prices[i].idx] = this->VIOLATED_AND_CHECKED;
-   }
-
-   if(nsorted > 0)
-   {
-      best = prices[0].val;
-      return this->thesolver->coId(prices[0].idx);
-   }
-   else
-      return SPxId();
-}
+  if (enterId.isValid()) {
+    SSVectorBase<R> &delta = this->thesolver->fVec().delta();
 
+    this->thesolver->basis().solve4update(delta,
+                                          this->thesolver->vector(enterId));
 
-template <class R>
-SPxId SPxSteepPR<R>::buildBestPriceVectorEnterCoDim(R& best, R feastol)
-{
-   const R* test        = this->thesolver->test().get_const_ptr();
-   const R* weights_ptr = this->thesolver->weights.get_const_ptr();
-   int idx;
-   int nsorted;
-   R x;
-   typename SPxPricer<R>::IdxElement price;
-
-   pricesCo.clear();
-   bestPricesCo.clear();
-
-   // construct vector of all prices
-   for(int i = this->thesolver->infeasibilitiesCo.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->infeasibilitiesCo.index(i);
-      x = test[idx];
+    workRhs.setup_and_assign(delta);
+    pi_p = 1 + delta.length2();
 
-      if(x < -feastol)
-      {
-         // it might happen that we call the pricer with a tighter tolerance than what was used when computing the violations
-         this->thesolver->isInfeasibleCo[idx] = this->VIOLATED;
-         price.val = steeppr::computePrice(x, weights_ptr[idx], feastol);
-         price.idx = idx;
-         pricesCo.append(price);
-      }
-      else
-      {
-         this->thesolver->infeasibilitiesCo.remove(i);
-         this->thesolver->isInfeasibleCo[idx] = this->NOT_VIOLATED;
-      }
-   }
-
-   // set up structures for the quicksort implementation
-   this->compare.elements = pricesCo.get_const_ptr();
-   // do a partial sort to move the best ones to the front
-   // TODO this can be done more efficiently, since we only need the indices
-   nsorted = SPxQuicksortPart(pricesCo.get_ptr(), this->compare, 0, pricesCo.size(), HYPERPRICINGSIZE);
-
-   // copy indices of best values to bestPrices
-   for(int i = 0; i < nsorted; ++i)
-   {
-      bestPricesCo.addIdx(pricesCo[i].idx);
-      this->thesolver->isInfeasibleCo[pricesCo[i].idx] = this->VIOLATED_AND_CHECKED;
-   }
-
-   if(nsorted > 0)
-   {
-      best = pricesCo[0].val;
-      return this->thesolver->id(pricesCo[0].idx);
-   }
-   else
-      return SPxId();
+    this->thesolver->setup4coSolve(&workVec, &workRhs);
+  }
+
+  return enterId;
 }
 
+template <class R> SPxId SPxSteepPR<R>::selectEnterX(R tol) {
+  SPxId enterId;
+  SPxId enterCoId;
+  R best;
+  R bestCo;
+
+  best = R(-infinity);
+  bestCo = R(-infinity);
+
+  if (this->thesolver->hyperPricingEnter && !refined) {
+    if (bestPrices.size() < 2 || this->thesolver->basis().lastUpdate() == 0)
+      enterCoId = (this->thesolver->sparsePricingEnter)
+                      ? buildBestPriceVectorEnterDim(best, tol)
+                      : selectEnterDenseDim(best, tol);
+    else
+      enterCoId = (this->thesolver->sparsePricingEnter)
+                      ? selectEnterHyperDim(best, tol)
+                      : selectEnterDenseDim(best, tol);
+
+    if (bestPricesCo.size() < 2 || this->thesolver->basis().lastUpdate() == 0)
+      enterId = (this->thesolver->sparsePricingEnterCo)
+                    ? buildBestPriceVectorEnterCoDim(bestCo, tol)
+                    : selectEnterDenseCoDim(bestCo, tol);
+    else
+      enterId = (this->thesolver->sparsePricingEnterCo)
+                    ? selectEnterHyperCoDim(bestCo, tol)
+                    : selectEnterDenseCoDim(bestCo, tol);
+  } else {
+    enterCoId = (this->thesolver->sparsePricingEnter && !refined)
+                    ? selectEnterSparseDim(best, tol)
+                    : selectEnterDenseDim(best, tol);
+    enterId = (this->thesolver->sparsePricingEnterCo && !refined)
+                  ? selectEnterSparseCoDim(bestCo, tol)
+                  : selectEnterDenseCoDim(bestCo, tol);
+  }
+
+  // prefer slack indices to reduce nonzeros in basis matrix
+  if (enterCoId.isValid() &&
+      (best > SPARSITY_TRADEOFF * bestCo || !enterId.isValid()))
+    return enterCoId;
+  else
+    return enterId;
+}
 
-template <class R>
-SPxId SPxSteepPR<R>::selectEnter()
-{
-   assert(this->thesolver != 0);
-   SPxId enterId;
+template <class R> SPxId SPxSteepPR<R>::selectEnterHyperDim(R &best, R tol) {
+  const R *coTest = this->thesolver->coTest().get_const_ptr();
+  const R *coWeights_ptr = this->thesolver->coWeights.get_const_ptr();
 
-   enterId = selectEnterX(this->theeps);
+  R leastBest = -1;
+  R x;
+  int enterIdx = -1;
+  int idx;
 
-   if(!enterId.isValid() && !refined)
-   {
-      refined = true;
-      MSG_INFO3((*this->thesolver->spxout),
-                (*this->thesolver->spxout) << "WSTEEP05 trying refinement step..\n";)
-      enterId = selectEnterX(this->theeps / STEEP_REFINETOL);
-   }
+  // find the best price from short candidate list
+  for (int i = bestPrices.size() - 1; i >= 0; --i) {
+    idx = bestPrices.index(i);
+    x = coTest[idx];
+
+    if (x < -tol) {
+      x = steeppr::computePrice(x, coWeights_ptr[idx], tol);
 
-   assert(isConsistent());
+      assert(x >= 0);
 
-   if(enterId.isValid())
-   {
-      SSVectorBase<R>& delta = this->thesolver->fVec().delta();
+      // update the best price of candidate list
+      if (x > best) {
+        best = x;
+        enterIdx = idx;
+      }
 
-      this->thesolver->basis().solve4update(delta, this->thesolver->vector(enterId));
+      // update the smallest price of candidate list
+      if (x < leastBest || leastBest < 0)
+        leastBest = x;
+    } else {
+      bestPrices.remove(i);
+      this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
+    }
+  }
 
-      workRhs.setup_and_assign(delta);
-      pi_p = 1 + delta.length2();
+  // scan the updated indices for a better price
+  for (int i = this->thesolver->updateViols.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->updateViols.index(i);
 
-      this->thesolver->setup4coSolve(&workVec, &workRhs);
-   }
+    // only look at indices that were not checked already
+    if (this->thesolver->isInfeasible[idx] == this->VIOLATED) {
+      x = coTest[idx];
 
-   return enterId;
-}
+      if (x < -tol) {
+        x = steeppr::computePrice(x, coWeights_ptr[idx], tol);
 
-template <class R>
-SPxId SPxSteepPR<R>::selectEnterX(R tol)
-{
-   SPxId enterId;
-   SPxId enterCoId;
-   R best;
-   R bestCo;
-
-   best = R(-infinity);
-   bestCo = R(-infinity);
-
-   if(this->thesolver->hyperPricingEnter && !refined)
-   {
-      if(bestPrices.size() < 2 || this->thesolver->basis().lastUpdate() == 0)
-         enterCoId = (this->thesolver->sparsePricingEnter) ? buildBestPriceVectorEnterDim(best,
-                     tol) : selectEnterDenseDim(best, tol);
-      else
-         enterCoId = (this->thesolver->sparsePricingEnter) ? selectEnterHyperDim(best,
-                     tol) : selectEnterDenseDim(best, tol);
-
-      if(bestPricesCo.size() < 2 || this->thesolver->basis().lastUpdate() == 0)
-         enterId = (this->thesolver->sparsePricingEnterCo) ? buildBestPriceVectorEnterCoDim(bestCo,
-                   tol) : selectEnterDenseCoDim(bestCo, tol);
-      else
-         enterId = (this->thesolver->sparsePricingEnterCo) ? selectEnterHyperCoDim(bestCo,
-                   tol) : selectEnterDenseCoDim(bestCo, tol);
-   }
-   else
-   {
-      enterCoId = (this->thesolver->sparsePricingEnter
-                   && !refined) ? selectEnterSparseDim(best, tol) : selectEnterDenseDim(best, tol);
-      enterId = (this->thesolver->sparsePricingEnterCo
-                 && !refined) ? selectEnterSparseCoDim(bestCo, tol) : selectEnterDenseCoDim(bestCo, tol);
-   }
-
-   // prefer slack indices to reduce nonzeros in basis matrix
-   if(enterCoId.isValid() && (best > SPARSITY_TRADEOFF * bestCo || !enterId.isValid()))
-      return enterCoId;
-   else
-      return enterId;
+        if (x > leastBest) {
+          if (x > best) {
+            best = x;
+            enterIdx = idx;
+          }
+
+          // put index into candidate list
+          this->thesolver->isInfeasible[idx] = this->VIOLATED_AND_CHECKED;
+          bestPrices.addIdx(idx);
+        }
+      } else {
+        this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
+      }
+    }
+  }
+
+  if (enterIdx >= 0)
+    return this->thesolver->coId(enterIdx);
+  else
+    return SPxId();
 }
 
+template <class R> SPxId SPxSteepPR<R>::selectEnterHyperCoDim(R &best, R tol) {
+  const R *test = this->thesolver->test().get_const_ptr();
+  const R *weights_ptr = this->thesolver->weights.get_const_ptr();
 
-template <class R>
-SPxId SPxSteepPR<R>::selectEnterHyperDim(R& best, R tol)
-{
-   const R* coTest        = this->thesolver->coTest().get_const_ptr();
-   const R* coWeights_ptr = this->thesolver->coWeights.get_const_ptr();
-
-   R leastBest = -1;
-   R x;
-   int enterIdx = -1;
-   int idx;
-
-   // find the best price from short candidate list
-   for(int i = bestPrices.size() - 1; i >= 0; --i)
-   {
-      idx = bestPrices.index(i);
-      x = coTest[idx];
+  R leastBest = -1;
+  R x;
+  int enterIdx = -1;
+  int idx;
 
-      if(x < -tol)
-      {
-         x = steeppr::computePrice(x, coWeights_ptr[idx], tol);
+  // find the best price from short candidate list
+  for (int i = bestPricesCo.size() - 1; i >= 0; --i) {
+    idx = bestPricesCo.index(i);
+    x = test[idx];
 
-         assert(x >= 0);
+    if (x < -tol) {
+      x = steeppr::computePrice(x, weights_ptr[idx], tol);
 
-         // update the best price of candidate list
-         if(x > best)
-         {
-            best = x;
-            enterIdx = idx;
-         }
+      assert(x >= 0);
 
-         // update the smallest price of candidate list
-         if(x < leastBest || leastBest < 0)
-            leastBest = x;
-      }
-      else
-      {
-         bestPrices.remove(i);
-         this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
-      }
-   }
-
-   // scan the updated indices for a better price
-   for(int i = this->thesolver->updateViols.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->updateViols.index(i);
-
-      // only look at indices that were not checked already
-      if(this->thesolver->isInfeasible[idx] == this->VIOLATED)
-      {
-         x = coTest[idx];
-
-         if(x < -tol)
-         {
-            x = steeppr::computePrice(x, coWeights_ptr[idx], tol);
-
-            if(x > leastBest)
-            {
-               if(x > best)
-               {
-                  best = x;
-                  enterIdx = idx;
-               }
-
-               // put index into candidate list
-               this->thesolver->isInfeasible[idx] = this->VIOLATED_AND_CHECKED;
-               bestPrices.addIdx(idx);
-            }
-         }
-         else
-         {
-            this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
-         }
+      // update the best price of candidate list
+      if (x > best) {
+        best = x;
+        enterIdx = idx;
       }
-   }
 
-   if(enterIdx >= 0)
-      return this->thesolver->coId(enterIdx);
-   else
-      return SPxId();
-}
+      // update the smallest price of candidate list
+      if (x < leastBest || leastBest < 0)
+        leastBest = x;
+    } else {
+      bestPricesCo.remove(i);
+      this->thesolver->isInfeasibleCo[idx] = this->NOT_VIOLATED;
+    }
+  }
 
+  // scan the updated indices for a better price
+  for (int i = this->thesolver->updateViolsCo.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->updateViolsCo.index(i);
 
-template <class R>
-SPxId SPxSteepPR<R>::selectEnterHyperCoDim(R& best, R tol)
-{
-   const R* test        = this->thesolver->test().get_const_ptr();
-   const R* weights_ptr = this->thesolver->weights.get_const_ptr();
-
-   R leastBest = -1;
-   R x;
-   int enterIdx = -1;
-   int idx;
-
-   // find the best price from short candidate list
-   for(int i = bestPricesCo.size() - 1; i >= 0; --i)
-   {
-      idx = bestPricesCo.index(i);
+    // only look at indices that were not checked already
+    if (this->thesolver->isInfeasibleCo[idx] == this->VIOLATED) {
       x = test[idx];
 
-      if(x < -tol)
-      {
-         x = steeppr::computePrice(x, weights_ptr[idx], tol);
+      if (x < -tol) {
+        x = steeppr::computePrice(x, weights_ptr[idx], tol);
 
-         assert(x >= 0);
-
-         // update the best price of candidate list
-         if(x > best)
-         {
+        if (x > leastBest) {
+          if (x > best) {
             best = x;
             enterIdx = idx;
-         }
+          }
+
+          // put index into candidate list
+          this->thesolver->isInfeasibleCo[idx] = this->VIOLATED_AND_CHECKED;
+          bestPricesCo.addIdx(idx);
+        }
+      } else {
+        this->thesolver->isInfeasibleCo[idx] = this->NOT_VIOLATED;
+      }
+    }
+  }
+
+  if (enterIdx >= 0)
+    return this->thesolver->id(enterIdx);
+  else
+    return SPxId();
+}
 
-         // update the smallest price of candidate list
-         if(x < leastBest || leastBest < 0)
-            leastBest = x;
-      }
-      else
-      {
-         bestPricesCo.remove(i);
-         this->thesolver->isInfeasibleCo[idx] = this->NOT_VIOLATED;
-      }
-   }
-
-   // scan the updated indices for a better price
-   for(int i = this->thesolver->updateViolsCo.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->updateViolsCo.index(i);
-
-      // only look at indices that were not checked already
-      if(this->thesolver->isInfeasibleCo[idx] == this->VIOLATED)
-      {
-         x = test[idx];
-
-         if(x < -tol)
-         {
-            x = steeppr::computePrice(x, weights_ptr[idx], tol);
-
-            if(x > leastBest)
-            {
-               if(x > best)
-               {
-                  best = x;
-                  enterIdx = idx;
-               }
-
-               // put index into candidate list
-               this->thesolver->isInfeasibleCo[idx] = this->VIOLATED_AND_CHECKED;
-               bestPricesCo.addIdx(idx);
-            }
-         }
-         else
-         {
-            this->thesolver->isInfeasibleCo[idx] = this->NOT_VIOLATED;
-         }
+template <class R> SPxId SPxSteepPR<R>::selectEnterSparseDim(R &best, R tol) {
+  SPxId enterId;
+  const R *coTest = this->thesolver->coTest().get_const_ptr();
+  const R *coWeights_ptr = this->thesolver->coWeights.get_const_ptr();
+
+  int idx;
+  R x;
+
+  for (int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->infeasibilities.index(i);
+    x = coTest[idx];
+
+    if (x < -tol) {
+      x = steeppr::computePrice(x, coWeights_ptr[idx], tol);
+
+      if (x > best) {
+        best = x;
+        enterId = this->thesolver->coId(idx);
       }
-   }
+    } else {
+      this->thesolver->infeasibilities.remove(i);
+      this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
+    }
+  }
 
-   if(enterIdx >= 0)
-      return this->thesolver->id(enterIdx);
-   else
-      return SPxId();
+  return enterId;
 }
 
+template <class R> SPxId SPxSteepPR<R>::selectEnterSparseCoDim(R &best, R tol) {
+  SPxId enterId;
+  const R *test = this->thesolver->test().get_const_ptr();
+  const R *weights_ptr = this->thesolver->weights.get_const_ptr();
 
-template <class R>
-SPxId SPxSteepPR<R>::selectEnterSparseDim(R& best, R tol)
-{
-   SPxId enterId;
-   const R* coTest        = this->thesolver->coTest().get_const_ptr();
-   const R* coWeights_ptr = this->thesolver->coWeights.get_const_ptr();
-
-   int idx;
-   R x;
-
-   for(int i = this->thesolver->infeasibilities.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->infeasibilities.index(i);
-      x = coTest[idx];
+  int idx;
+  R x;
 
-      if(x < -tol)
-      {
-         x = steeppr::computePrice(x, coWeights_ptr[idx], tol);
+  for (int i = this->thesolver->infeasibilitiesCo.size() - 1; i >= 0; --i) {
+    idx = this->thesolver->infeasibilitiesCo.index(i);
+    x = test[idx];
 
-         if(x > best)
-         {
-            best = x;
-            enterId = this->thesolver->coId(idx);
-         }
-      }
-      else
-      {
-         this->thesolver->infeasibilities.remove(i);
-         this->thesolver->isInfeasible[idx] = this->NOT_VIOLATED;
+    if (x < -tol) {
+      x = steeppr::computePrice(x, weights_ptr[idx], tol);
+
+      if (x > best) {
+        best = x;
+        enterId = this->thesolver->id(idx);
       }
-   }
+    } else {
+      this->thesolver->infeasibilitiesCo.remove(i);
+      this->thesolver->isInfeasibleCo[idx] = this->NOT_VIOLATED;
+    }
+  }
 
-   return enterId;
+  return enterId;
 }
 
-template <class R>
-SPxId SPxSteepPR<R>::selectEnterSparseCoDim(R& best, R tol)
-{
-   SPxId enterId;
-   const R* test          = this->thesolver->test().get_const_ptr();
-   const R* weights_ptr   = this->thesolver->weights.get_const_ptr();
-
-   int idx;
-   R x;
-
-   for(int i = this->thesolver->infeasibilitiesCo.size() - 1; i >= 0; --i)
-   {
-      idx = this->thesolver->infeasibilitiesCo.index(i);
-      x = test[idx];
+template <class R> SPxId SPxSteepPR<R>::selectEnterDenseDim(R &best, R tol) {
+  SPxId enterId;
+  const R *coTest = this->thesolver->coTest().get_const_ptr();
+  const R *coWeights_ptr = this->thesolver->coWeights.get_const_ptr();
 
-      if(x < -tol)
-      {
-         x = steeppr::computePrice(x, weights_ptr[idx], tol);
+  R x;
 
-         if(x > best)
-         {
-            best   = x;
-            enterId = this->thesolver->id(idx);
-         }
-      }
-      else
-      {
-         this->thesolver->infeasibilitiesCo.remove(i);
-         this->thesolver->isInfeasibleCo[idx] = this->NOT_VIOLATED;
+  for (int i = 0, end = this->thesolver->dim(); i < end; ++i) {
+    x = coTest[i];
+
+    if (x < -tol) {
+      x = steeppr::computePrice(x, coWeights_ptr[i], tol);
+
+      if (x > best) {
+        best = x;
+        enterId = this->thesolver->coId(i);
       }
-   }
+    }
+  }
 
-   return enterId;
+  return enterId;
 }
 
-template <class R>
-SPxId SPxSteepPR<R>::selectEnterDenseDim(R& best, R tol)
-{
-   SPxId enterId;
-   const R* coTest        = this->thesolver->coTest().get_const_ptr();
-   const R* coWeights_ptr = this->thesolver->coWeights.get_const_ptr();
+template <class R> SPxId SPxSteepPR<R>::selectEnterDenseCoDim(R &best, R tol) {
+  SPxId enterId;
+  const R *test = this->thesolver->test().get_const_ptr();
+  const R *weights_ptr = this->thesolver->weights.get_const_ptr();
 
-   R x;
+  R x;
 
-   for(int i = 0, end = this->thesolver->dim(); i < end; ++i)
-   {
-      x = coTest[i];
+  for (int i = 0, end = this->thesolver->coDim(); i < end; ++i) {
+    x = test[i];
 
-      if(x < -tol)
-      {
-         x = steeppr::computePrice(x, coWeights_ptr[i], tol);
+    if (x < -tol) {
+      x = steeppr::computePrice(x, weights_ptr[i], tol);
 
-         if(x > best)
-         {
-            best = x;
-            enterId = this->thesolver->coId(i);
-         }
+      if (x > best) {
+        best = x;
+        enterId = this->thesolver->id(i);
       }
-   }
+    }
+  }
 
-   return enterId;
+  return enterId;
 }
 
-template <class R>
-SPxId SPxSteepPR<R>::selectEnterDenseCoDim(R& best, R tol)
-{
-   SPxId enterId;
-   const R* test          = this->thesolver->test().get_const_ptr();
-   const R* weights_ptr   = this->thesolver->weights.get_const_ptr();
-
-   R x;
-
-   for(int i = 0, end = this->thesolver->coDim(); i < end; ++i)
-   {
-      x = test[i];
-
-      if(x < -tol)
-      {
-         x = steeppr::computePrice(x, weights_ptr[i], tol);
-
-         if(x > best)
-         {
-            best   = x;
-            enterId = this->thesolver->id(i);
-         }
-      }
-   }
+template <class R> void SPxSteepPR<R>::addedVecs(int n) {
+  VectorBase<R> &weights = this->thesolver->weights;
+  n = weights.dim();
+  weights.reDim(this->thesolver->coDim());
 
-   return enterId;
+  if (this->thesolver->type() == SPxSolverBase<R>::ENTER) {
+    for (; n < weights.dim(); ++n)
+      weights[n] = 2;
+  }
 }
 
+template <class R> void SPxSteepPR<R>::addedCoVecs(int n) {
+  VectorBase<R> &coWeights = this->thesolver->coWeights;
+  n = coWeights.dim();
+  workVec.reDim(this->thesolver->dim());
+  coWeights.reDim(this->thesolver->dim());
 
-template <class R>
-void SPxSteepPR<R>::addedVecs(int n)
-{
-   VectorBase<R>& weights = this->thesolver->weights;
-   n = weights.dim();
-   weights.reDim(this->thesolver->coDim());
-
-   if(this->thesolver->type() == SPxSolverBase<R>::ENTER)
-   {
-      for(; n < weights.dim(); ++n)
-         weights[n] = 2;
-   }
+  for (; n < coWeights.dim(); ++n)
+    coWeights[n] = 1;
 }
 
-template <class R>
-void SPxSteepPR<R>::addedCoVecs(int n)
-{
-   VectorBase<R>& coWeights = this->thesolver->coWeights;
-   n = coWeights.dim();
-   workVec.reDim(this->thesolver->dim());
-   coWeights.reDim(this->thesolver->dim());
-
-   for(; n < coWeights.dim(); ++n)
-      coWeights[n] = 1;
+template <class R> void SPxSteepPR<R>::removedVec(int i) {
+  assert(this->thesolver != 0);
+  VectorBase<R> &weights = this->thesolver->weights;
+  weights[i] = weights[weights.dim()];
+  weights.reDim(this->thesolver->coDim());
 }
 
-template <class R>
-void SPxSteepPR<R>::removedVec(int i)
-{
-   assert(this->thesolver != 0);
-   VectorBase<R>& weights = this->thesolver->weights;
-   weights[i] = weights[weights.dim()];
-   weights.reDim(this->thesolver->coDim());
-}
+template <class R> void SPxSteepPR<R>::removedVecs(const int perm[]) {
+  assert(this->thesolver != 0);
+  VectorBase<R> &weights = this->thesolver->weights;
 
-template <class R>
-void SPxSteepPR<R>::removedVecs(const int perm[])
-{
-   assert(this->thesolver != 0);
-   VectorBase<R>& weights = this->thesolver->weights;
-
-   if(this->thesolver->type() == SPxSolverBase<R>::ENTER)
-   {
-      int i;
-      int j = weights.dim();
-
-      for(i = 0; i < j; ++i)
-      {
-         if(perm[i] >= 0)
-            weights[perm[i]] = weights[i];
-      }
-   }
+  if (this->thesolver->type() == SPxSolverBase<R>::ENTER) {
+    int i;
+    int j = weights.dim();
 
-   weights.reDim(this->thesolver->coDim());
+    for (i = 0; i < j; ++i) {
+      if (perm[i] >= 0)
+        weights[perm[i]] = weights[i];
+    }
+  }
+
+  weights.reDim(this->thesolver->coDim());
 }
 
-template <class R>
-void SPxSteepPR<R>::removedCoVec(int i)
-{
-   assert(this->thesolver != 0);
-   VectorBase<R>& coWeights = this->thesolver->coWeights;
-   coWeights[i] = coWeights[coWeights.dim()];
-   coWeights.reDim(this->thesolver->dim());
+template <class R> void SPxSteepPR<R>::removedCoVec(int i) {
+  assert(this->thesolver != 0);
+  VectorBase<R> &coWeights = this->thesolver->coWeights;
+  coWeights[i] = coWeights[coWeights.dim()];
+  coWeights.reDim(this->thesolver->dim());
 }
 
-template <class R>
-void SPxSteepPR<R>::removedCoVecs(const int perm[])
-{
-   assert(this->thesolver != 0);
-   VectorBase<R>& coWeights = this->thesolver->coWeights;
-   int i;
-   int j = coWeights.dim();
-
-   for(i = 0; i < j; ++i)
-   {
-      if(perm[i] >= 0)
-         coWeights[perm[i]] = coWeights[i];
-   }
-
-   coWeights.reDim(this->thesolver->dim());
+template <class R> void SPxSteepPR<R>::removedCoVecs(const int perm[]) {
+  assert(this->thesolver != 0);
+  VectorBase<R> &coWeights = this->thesolver->coWeights;
+  int i;
+  int j = coWeights.dim();
+
+  for (i = 0; i < j; ++i) {
+    if (perm[i] >= 0)
+      coWeights[perm[i]] = coWeights[i];
+  }
+
+  coWeights.reDim(this->thesolver->dim());
 }
 
-template <class R>
-bool SPxSteepPR<R>::isConsistent() const
-{
+template <class R> bool SPxSteepPR<R>::isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
-   VectorBase<R>& w = this->thesolver->weights;
-   VectorBase<R>& coW = this->thesolver->coWeights;
-
-   if(this->thesolver != 0 && this->thesolver->type() == SPxSolverBase<R>::LEAVE && setup == EXACT)
-   {
-      int i;
-      SSVectorBase<R>  tmp(this->thesolver->dim(), this->thesolver->epsilon());
-      R x;
-
-      for(i = this->thesolver->dim() - 1; i >= 0; --i)
-      {
-         this->thesolver->basis().coSolve(tmp, this->thesolver->unitVector(i));
-         x = coW[i] - tmp.length2();
-
-         if(x > this->thesolver->leavetol() || -x > this->thesolver->leavetol())
-         {
-            MSG_ERROR(std::cerr << "ESTEEP03 x[" << i << "] = " << x << std::endl;)
-         }
-      }
-   }
+  VectorBase<R> &w = this->thesolver->weights;
+  VectorBase<R> &coW = this->thesolver->coWeights;
 
-   if(this->thesolver != 0 && this->thesolver->type() == SPxSolverBase<R>::ENTER)
-   {
-      int i;
+  if (this->thesolver != 0 &&
+      this->thesolver->type() == SPxSolverBase<R>::LEAVE && setup == EXACT) {
+    int i;
+    SSVectorBase<R> tmp(this->thesolver->dim(), this->thesolver->epsilon());
+    R x;
 
-      for(i = this->thesolver->dim() - 1; i >= 0; --i)
-      {
-         if(coW[i] < this->thesolver->epsilon())
-            return MSGinconsistent("SPxSteepPR");
-      }
+    for (i = this->thesolver->dim() - 1; i >= 0; --i) {
+      this->thesolver->basis().coSolve(tmp, this->thesolver->unitVector(i));
+      x = coW[i] - tmp.length2();
 
-      for(i = this->thesolver->coDim() - 1; i >= 0; --i)
-      {
-         if(w[i] < this->thesolver->epsilon())
-            return MSGinconsistent("SPxSteepPR");
+      if (x > this->thesolver->leavetol() || -x > this->thesolver->leavetol()) {
+        MSG_ERROR(std::cerr << "ESTEEP03 x[" << i << "] = " << x << std::endl;)
       }
-   }
+    }
+  }
+
+  if (this->thesolver != 0 &&
+      this->thesolver->type() == SPxSolverBase<R>::ENTER) {
+    int i;
+
+    for (i = this->thesolver->dim() - 1; i >= 0; --i) {
+      if (coW[i] < this->thesolver->epsilon())
+        return MSGinconsistent("SPxSteepPR");
+    }
+
+    for (i = this->thesolver->coDim() - 1; i >= 0; --i) {
+      if (w[i] < this->thesolver->epsilon())
+        return MSGinconsistent("SPxSteepPR");
+    }
+  }
 
 #endif
 
-   return true;
+  return true;
 }
 } // namespace soplex
diff --git a/src/soplex/spxsumst.hpp b/src/soplex/spxsumst.hpp
index cd3725c..c68ebff 100644
--- a/src/soplex/spxsumst.hpp
+++ b/src/soplex/spxsumst.hpp
@@ -21,77 +21,71 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <iostream>
 
 #include "soplex/spxdefines.h"
 #include "soplex/vector.h"
 
-namespace soplex
-{
-
-template <class R>
-void SPxSumST<R>::setupWeights(SPxSolverBase<R>& base)
-{
-   int count;
-   int i;
-   R x;
-   VectorBase<R> work, delta, rowLen;
-
-   assert(base.nRows() > 0);
-   assert(base.nCols() > 0);
-
-   rowLen.reDim(base.nRows(), true);
-   work.reDim(base.nCols(), true);
-   delta.reDim(base.nCols(), true);
-
-   R* wrk = work.get_ptr();
-   const R* lhs = base.lhs().get_const_ptr();
-   const R* rhs = base.rhs().get_const_ptr();
-   const R* up = base.upper().get_const_ptr();
-   const R* low = base.lower().get_const_ptr();
-
-   for(i = base.nRows(); --i >= 0;)
-   {
-      rowLen[i] = base.rowVector(i).length2();
-
-      if(lhs[i] > 0)
-         delta.multAdd(lhs[i] / rowLen[i], base.rowVector(i));
-      else if(rhs[i] < 0)
-         delta.multAdd(rhs[i] / rowLen[i], base.rowVector(i));
-   }
-
-   for(count = 0;; count++)
-   {
-      work += delta;
-
-      for(i = base.nCols(); --i >= 0;)
-      {
-         if(wrk[i] > up[i])
-            wrk[i] = up[i];
-
-         if(wrk[i] < low[i])
-            wrk[i] = low[i];
-      }
-
-      //      std::cout << -(work * base.maxObj()) << std::endl;
-      if(count >= 12)
-         break;
-
-      delta.clear();
-
-      for(i = base.nRows(); --i >= 0;)
-      {
-         x = base.rowVector(i) * work;
-
-         if(lhs[i] > x)
-            delta.multAdd((lhs[i] - x) / rowLen[i], base.rowVector(i));
-         else if(rhs[i] < x)
-            delta.multAdd((rhs[i] - x) / rowLen[i], base.rowVector(i));
-      }
-   }
-
-   this->primal(work);
-   SPxVectorST<R>::setupWeights(base);
+namespace soplex {
+
+template <class R> void SPxSumST<R>::setupWeights(SPxSolverBase<R> &base) {
+  int count;
+  int i;
+  R x;
+  VectorBase<R> work, delta, rowLen;
+
+  assert(base.nRows() > 0);
+  assert(base.nCols() > 0);
+
+  rowLen.reDim(base.nRows(), true);
+  work.reDim(base.nCols(), true);
+  delta.reDim(base.nCols(), true);
+
+  R *wrk = work.get_ptr();
+  const R *lhs = base.lhs().get_const_ptr();
+  const R *rhs = base.rhs().get_const_ptr();
+  const R *up = base.upper().get_const_ptr();
+  const R *low = base.lower().get_const_ptr();
+
+  for (i = base.nRows(); --i >= 0;) {
+    rowLen[i] = base.rowVector(i).length2();
+
+    if (lhs[i] > 0)
+      delta.multAdd(lhs[i] / rowLen[i], base.rowVector(i));
+    else if (rhs[i] < 0)
+      delta.multAdd(rhs[i] / rowLen[i], base.rowVector(i));
+  }
+
+  for (count = 0;; count++) {
+    work += delta;
+
+    for (i = base.nCols(); --i >= 0;) {
+      if (wrk[i] > up[i])
+        wrk[i] = up[i];
+
+      if (wrk[i] < low[i])
+        wrk[i] = low[i];
+    }
+
+    //      std::cout << -(work * base.maxObj()) << std::endl;
+    if (count >= 12)
+      break;
+
+    delta.clear();
+
+    for (i = base.nRows(); --i >= 0;) {
+      x = base.rowVector(i) * work;
+
+      if (lhs[i] > x)
+        delta.multAdd((lhs[i] - x) / rowLen[i], base.rowVector(i));
+      else if (rhs[i] < x)
+        delta.multAdd((rhs[i] - x) / rowLen[i], base.rowVector(i));
+    }
+  }
+
+  this->primal(work);
+  SPxVectorST<R>::setupWeights(base);
 }
 } // namespace soplex
diff --git a/src/soplex/spxvecs.hpp b/src/soplex/spxvecs.hpp
index a9f1923..1b0d276 100644
--- a/src/soplex/spxvecs.hpp
+++ b/src/soplex/spxvecs.hpp
@@ -21,256 +21,231 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <assert.h>
 #include <iostream>
 
+#include "soplex/exceptions.h"
 #include "soplex/spxdefines.h"
 #include "soplex/spxsolver.h"
-#include "soplex/exceptions.h"
 
-namespace soplex
-{
+namespace soplex {
 /** Initialize Vectors
 
     Computing the right hand side vector for the feasibility vector depends on
     the chosen representation and type of the basis.
 
-    In columnwise case, |theFvec| = \f$x_B = A_B^{-1} (- A_N x_N)\f$, where \f$x_N\f$
-    are either upper or lower bounds for the nonbasic variables (depending on
-    the variables |Status|). If these values remain unchanged throughout the
-    simplex algorithm, they may be taken directly from LP. However, in the
-    entering type algorith they are changed and, hence, retreived from the
-    column or row upper or lower bound vectors.
+    In columnwise case, |theFvec| = \f$x_B = A_B^{-1} (- A_N x_N)\f$, where
+   \f$x_N\f$ are either upper or lower bounds for the nonbasic variables
+   (depending on the variables |Status|). If these values remain unchanged
+   throughout the simplex algorithm, they may be taken directly from LP.
+   However, in the entering type algorith they are changed and, hence, retreived
+   from the column or row upper or lower bound vectors.
 
-    In rowwise case, |theFvec| = \f$\pi^T_B = (c^T - 0^T A_N) A_B^{-1}\f$. However,
-    this applies only to leaving type algorithm, where no bounds on dual
+    In rowwise case, |theFvec| = \f$\pi^T_B = (c^T - 0^T A_N) A_B^{-1}\f$.
+   However, this applies only to leaving type algorithm, where no bounds on dual
     variables are altered. In entering type algorithm they are changed and,
     hence, retreived from the column or row upper or lower bound vectors.
 */
-template <class R>
-void SPxSolverBase<R>::computeFrhs()
-{
+template <class R> void SPxSolverBase<R>::computeFrhs() {
 
-   if(rep() == COLUMN)
-   {
-      theFrhs->clear();
+  if (rep() == COLUMN) {
+    theFrhs->clear();
 
-      if(type() == LEAVE)
-      {
-         computeFrhsXtra();
+    if (type() == LEAVE) {
+      computeFrhsXtra();
 
-         for(int i = 0; i < this->nRows(); i++)
-         {
-            R x;
+      for (int i = 0; i < this->nRows(); i++) {
+        R x;
 
-            typename SPxBasisBase<R>::Desc::Status stat = this->desc().rowStatus(i);
+        typename SPxBasisBase<R>::Desc::Status stat = this->desc().rowStatus(i);
 
-            if(!isBasic(stat))
-            {
-               // coverity[switch_selector_expr_is_constant]
-               switch(stat)
-               {
-               // columnwise cases:
-               case SPxBasisBase<R>::Desc::P_FREE :
-                  continue;
+        if (!isBasic(stat)) {
+          // coverity[switch_selector_expr_is_constant]
+          switch (stat) {
+          // columnwise cases:
+          case SPxBasisBase<R>::Desc::P_FREE:
+            continue;
 
-               case(SPxBasisBase<R>::Desc::P_FIXED) :
-                  assert(EQ(this->lhs(i), this->rhs(i)));
+          case (SPxBasisBase<R>::Desc::P_FIXED):
+            assert(EQ(this->lhs(i), this->rhs(i)));
 
-               //lint -fallthrough
-               case SPxBasisBase<R>::Desc::P_ON_UPPER :
-                  x = this->rhs(i);
-                  break;
+          // lint -fallthrough
+          case SPxBasisBase<R>::Desc::P_ON_UPPER:
+            x = this->rhs(i);
+            break;
 
-               case SPxBasisBase<R>::Desc::P_ON_LOWER :
-                  x = this->lhs(i);
-                  break;
+          case SPxBasisBase<R>::Desc::P_ON_LOWER:
+            x = this->lhs(i);
+            break;
 
-               default:
-                  MSG_ERROR(std::cerr << "ESVECS01 ERROR: "
-                            << "inconsistent basis must not happen!"
-                            << std::endl;)
-                  throw SPxInternalCodeException("XSVECS01 This should never happen.");
-               }
-
-               assert(x < R(infinity));
-               assert(x > R(-infinity));
-               (*theFrhs)[i] += x;     // slack !
-            }
-         }
-      }
-      else
-      {
-         computeFrhs1(*theUbound, *theLbound);
-         computeFrhs2(*theCoUbound, *theCoLbound);
+          default:
+            MSG_ERROR(std::cerr << "ESVECS01 ERROR: "
+                                << "inconsistent basis must not happen!"
+                                << std::endl;)
+            throw SPxInternalCodeException(
+                "XSVECS01 This should never happen.");
+          }
+
+          assert(x < R(infinity));
+          assert(x > R(-infinity));
+          (*theFrhs)[i] += x; // slack !
+        }
       }
-   }
-   else
-   {
-      assert(rep() == ROW);
-
-      if(type() == ENTER)
-      {
-         theFrhs->clear();
-         computeFrhs1(*theUbound, *theLbound);
-         computeFrhs2(*theCoUbound, *theCoLbound);
-         *theFrhs += this->maxObj();
-      }
-      else
-      {
-         ///@todo put this into a separate method
-         *theFrhs = this->maxObj();
-         const typename SPxBasisBase<R>::Desc& ds = this->desc();
-
-         for(int i = 0; i < this->nRows(); ++i)
-         {
-            typename SPxBasisBase<R>::Desc::Status stat = ds.rowStatus(i);
-
-            if(!isBasic(stat))
-            {
-               R x;
-
-               switch(stat)
-               {
-               case SPxBasisBase<R>::Desc::D_FREE :
-                  continue;
-
-               case SPxBasisBase<R>::Desc::D_ON_UPPER :
-               case SPxBasisBase<R>::Desc::D_ON_LOWER :
-               case(SPxBasisBase<R>::Desc::D_ON_BOTH) :
-                  x = this->maxRowObj(i);
-                  break;
-
-               default:
-                  assert(this->lhs(i) <= R(-infinity) && this->rhs(i) >= R(infinity));
-                  x = 0.0;
-                  break;
-               }
-
-               assert(x < R(infinity));
-               assert(x > R(-infinity));
-               // assert(x == 0.0);
-
-               if(x != 0.0)
-                  theFrhs->multAdd(x, vector(i));
-            }
-         }
+    } else {
+      computeFrhs1(*theUbound, *theLbound);
+      computeFrhs2(*theCoUbound, *theCoLbound);
+    }
+  } else {
+    assert(rep() == ROW);
+
+    if (type() == ENTER) {
+      theFrhs->clear();
+      computeFrhs1(*theUbound, *theLbound);
+      computeFrhs2(*theCoUbound, *theCoLbound);
+      *theFrhs += this->maxObj();
+    } else {
+      ///@todo put this into a separate method
+      *theFrhs = this->maxObj();
+      const typename SPxBasisBase<R>::Desc &ds = this->desc();
+
+      for (int i = 0; i < this->nRows(); ++i) {
+        typename SPxBasisBase<R>::Desc::Status stat = ds.rowStatus(i);
+
+        if (!isBasic(stat)) {
+          R x;
+
+          switch (stat) {
+          case SPxBasisBase<R>::Desc::D_FREE:
+            continue;
+
+          case SPxBasisBase<R>::Desc::D_ON_UPPER:
+          case SPxBasisBase<R>::Desc::D_ON_LOWER:
+          case (SPxBasisBase<R>::Desc::D_ON_BOTH):
+            x = this->maxRowObj(i);
+            break;
+
+          default:
+            assert(this->lhs(i) <= R(-infinity) && this->rhs(i) >= R(infinity));
+            x = 0.0;
+            break;
+          }
+
+          assert(x < R(infinity));
+          assert(x > R(-infinity));
+          // assert(x == 0.0);
+
+          if (x != 0.0)
+            theFrhs->multAdd(x, vector(i));
+        }
       }
-   }
+    }
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::computeFrhsXtra()
-{
+template <class R> void SPxSolverBase<R>::computeFrhsXtra() {
 
-   assert(rep()  == COLUMN);
-   assert(type() == LEAVE);
+  assert(rep() == COLUMN);
+  assert(type() == LEAVE);
 
-   for(int i = 0; i < this->nCols(); ++i)
-   {
-      typename SPxBasisBase<R>::Desc::Status stat = this->desc().colStatus(i);
+  for (int i = 0; i < this->nCols(); ++i) {
+    typename SPxBasisBase<R>::Desc::Status stat = this->desc().colStatus(i);
 
-      if(!isBasic(stat))
-      {
-         R x;
+    if (!isBasic(stat)) {
+      R x;
 
-         // coverity[switch_selector_expr_is_constant]
-         switch(stat)
-         {
-         // columnwise cases:
-         case SPxBasisBase<R>::Desc::P_FREE :
-            continue;
+      // coverity[switch_selector_expr_is_constant]
+      switch (stat) {
+      // columnwise cases:
+      case SPxBasisBase<R>::Desc::P_FREE:
+        continue;
 
-         case(SPxBasisBase<R>::Desc::P_FIXED) :
-            assert(EQ(SPxLPBase<R>::lower(i), SPxLPBase<R>::upper(i)));
+      case (SPxBasisBase<R>::Desc::P_FIXED):
+        assert(EQ(SPxLPBase<R>::lower(i), SPxLPBase<R>::upper(i)));
 
-         //lint -fallthrough
-         case SPxBasisBase<R>::Desc::P_ON_UPPER :
-            x = SPxLPBase<R>::upper(i);
-            break;
+      // lint -fallthrough
+      case SPxBasisBase<R>::Desc::P_ON_UPPER:
+        x = SPxLPBase<R>::upper(i);
+        break;
 
-         case SPxBasisBase<R>::Desc::P_ON_LOWER :
-            x = SPxLPBase<R>::lower(i);
-            break;
+      case SPxBasisBase<R>::Desc::P_ON_LOWER:
+        x = SPxLPBase<R>::lower(i);
+        break;
 
-         default:
-            MSG_ERROR(std::cerr << "ESVECS02 ERROR: "
-                      << "inconsistent basis must not happen!"
-                      << std::endl;)
-            throw SPxInternalCodeException("XSVECS02 This should never happen.");
-         }
+      default:
+        MSG_ERROR(std::cerr << "ESVECS02 ERROR: "
+                            << "inconsistent basis must not happen!"
+                            << std::endl;)
+        throw SPxInternalCodeException("XSVECS02 This should never happen.");
+      }
 
-         assert(x < R(infinity));
-         assert(x > R(-infinity));
+      assert(x < R(infinity));
+      assert(x > R(-infinity));
 
-         if(x != 0.0)
-            theFrhs->multAdd(-x, vector(i));
-      }
-   }
+      if (x != 0.0)
+        theFrhs->multAdd(-x, vector(i));
+    }
+  }
 }
 
-
 /** This methods subtracts \f$A_N x_N\f$ or \f$\pi_N^T A_N\f$ from |theFrhs| as
-    specified by the |Status| of all nonbasic variables. The values of \f$x_N\f$ or
-    \f$\pi_N\f$ are taken from the passed arrays.
+    specified by the |Status| of all nonbasic variables. The values of \f$x_N\f$
+   or \f$\pi_N\f$ are taken from the passed arrays.
 */
 template <class R>
 void SPxSolverBase<R>::computeFrhs1(
-   const VectorBase<R>& ufb,    ///< upper feasibility bound for variables
-   const VectorBase<R>& lfb)    ///< lower feasibility bound for variables
+    const VectorBase<R> &ufb, ///< upper feasibility bound for variables
+    const VectorBase<R> &lfb) ///< lower feasibility bound for variables
 {
 
-   const typename SPxBasisBase<R>::Desc& ds = this->desc();
+  const typename SPxBasisBase<R>::Desc &ds = this->desc();
 
-   for(int i = 0; i < coDim(); ++i)
-   {
-      typename SPxBasisBase<R>::Desc::Status stat = ds.status(i);
+  for (int i = 0; i < coDim(); ++i) {
+    typename SPxBasisBase<R>::Desc::Status stat = ds.status(i);
 
-      if(!isBasic(stat))
-      {
-         R x;
+    if (!isBasic(stat)) {
+      R x;
 
-         // coverity[switch_selector_expr_is_constant]
-         switch(stat)
-         {
-         case SPxBasisBase<R>::Desc::D_FREE :
-         case SPxBasisBase<R>::Desc::D_UNDEFINED :
-         case SPxBasisBase<R>::Desc::P_FREE :
-            continue;
+      // coverity[switch_selector_expr_is_constant]
+      switch (stat) {
+      case SPxBasisBase<R>::Desc::D_FREE:
+      case SPxBasisBase<R>::Desc::D_UNDEFINED:
+      case SPxBasisBase<R>::Desc::P_FREE:
+        continue;
 
-         case SPxBasisBase<R>::Desc::P_ON_UPPER :
-         case SPxBasisBase<R>::Desc::D_ON_UPPER :
-            x = ufb[i];
-            break;
+      case SPxBasisBase<R>::Desc::P_ON_UPPER:
+      case SPxBasisBase<R>::Desc::D_ON_UPPER:
+        x = ufb[i];
+        break;
 
-         case SPxBasisBase<R>::Desc::P_ON_LOWER :
-         case SPxBasisBase<R>::Desc::D_ON_LOWER :
-            x = lfb[i];
-            break;
+      case SPxBasisBase<R>::Desc::P_ON_LOWER:
+      case SPxBasisBase<R>::Desc::D_ON_LOWER:
+        x = lfb[i];
+        break;
 
-         case(SPxBasisBase<R>::Desc::P_FIXED) :
-            assert(EQ(lfb[i], ufb[i]));
+      case (SPxBasisBase<R>::Desc::P_FIXED):
+        assert(EQ(lfb[i], ufb[i]));
 
-         //lint -fallthrough
-         case(SPxBasisBase<R>::Desc::D_ON_BOTH) :
-            x = lfb[i];
-            break;
+      // lint -fallthrough
+      case (SPxBasisBase<R>::Desc::D_ON_BOTH):
+        x = lfb[i];
+        break;
 
-         default:
-            MSG_ERROR(std::cerr << "ESVECS03 ERROR: "
-                      << "inconsistent basis must not happen!"
-                      << std::endl;)
-            throw SPxInternalCodeException("XSVECS04 This should never happen.");
-         }
+      default:
+        MSG_ERROR(std::cerr << "ESVECS03 ERROR: "
+                            << "inconsistent basis must not happen!"
+                            << std::endl;)
+        throw SPxInternalCodeException("XSVECS04 This should never happen.");
+      }
 
-         assert(x < R(infinity));
-         assert(x > R(-infinity));
+      assert(x < R(infinity));
+      assert(x > R(-infinity));
 
-         if(x != 0.0)
-            theFrhs->multAdd(-x, vector(i));
-      }
-   }
+      if (x != 0.0)
+        theFrhs->multAdd(-x, vector(i));
+    }
+  }
 }
 
 /** This methods subtracts \f$A_N x_N\f$ or \f$\pi_N^T A_N\f$ from |theFrhs| as
@@ -279,73 +254,69 @@ void SPxSolverBase<R>::computeFrhs1(
 */
 template <class R>
 void SPxSolverBase<R>::computeFrhs2(
-   VectorBase<R>& coufb,   ///< upper feasibility bound for covariables
-   VectorBase<R>& colfb)   ///< lower feasibility bound for covariables
+    VectorBase<R> &coufb, ///< upper feasibility bound for covariables
+    VectorBase<R> &colfb) ///< lower feasibility bound for covariables
 {
-   const typename SPxBasisBase<R>::Desc& ds = this->desc();
-
-   for(int i = 0; i < dim(); ++i)
-   {
-      typename SPxBasisBase<R>::Desc::Status stat = ds.coStatus(i);
-
-      if(!isBasic(stat))
-      {
-         R x;
-
-         // coverity[switch_selector_expr_is_constant]
-         switch(stat)
-         {
-         case SPxBasisBase<R>::Desc::D_FREE :
-         case SPxBasisBase<R>::Desc::D_UNDEFINED :
-         case SPxBasisBase<R>::Desc::P_FREE :
-            continue;
-
-         case SPxBasisBase<R>::Desc::P_ON_LOWER :            // negative slack bounds!
-         case SPxBasisBase<R>::Desc::D_ON_UPPER :
-            x = coufb[i];
-            break;
-
-         case SPxBasisBase<R>::Desc::P_ON_UPPER :            // negative slack bounds!
-         case SPxBasisBase<R>::Desc::D_ON_LOWER :
-            x = colfb[i];
-            break;
-
-         case SPxBasisBase<R>::Desc::P_FIXED :
-         case SPxBasisBase<R>::Desc::D_ON_BOTH :
-
-            if(colfb[i] != coufb[i])
-            {
-               MSG_WARNING((*this->spxout), (*this->spxout) << "WSVECS04 Frhs2[" << i << "]: " << static_cast<int>
-                           (stat) << " "
-                           << colfb[i] << " " << coufb[i]
-                           << " shouldn't be" << std::endl;)
-
-               if(isZero(colfb[i]) || isZero(coufb[i]))
-                  colfb[i] = coufb[i] = 0.0;
-               else
-               {
-                  R mid = (colfb[i] + coufb[i]) / 2.0;
-                  colfb[i] = coufb[i] = mid;
-               }
-            }
-
-            assert(EQ(colfb[i], coufb[i]));
-            x = colfb[i];
-            break;
-
-         default:
-            MSG_ERROR(std::cerr << "ESVECS05 ERROR: "
-                      << "inconsistent basis must not happen!"
-                      << std::endl;)
-            throw SPxInternalCodeException("XSVECS05 This should never happen.");
-         }
+  const typename SPxBasisBase<R>::Desc &ds = this->desc();
+
+  for (int i = 0; i < dim(); ++i) {
+    typename SPxBasisBase<R>::Desc::Status stat = ds.coStatus(i);
+
+    if (!isBasic(stat)) {
+      R x;
+
+      // coverity[switch_selector_expr_is_constant]
+      switch (stat) {
+      case SPxBasisBase<R>::Desc::D_FREE:
+      case SPxBasisBase<R>::Desc::D_UNDEFINED:
+      case SPxBasisBase<R>::Desc::P_FREE:
+        continue;
+
+      case SPxBasisBase<R>::Desc::P_ON_LOWER: // negative slack bounds!
+      case SPxBasisBase<R>::Desc::D_ON_UPPER:
+        x = coufb[i];
+        break;
+
+      case SPxBasisBase<R>::Desc::P_ON_UPPER: // negative slack bounds!
+      case SPxBasisBase<R>::Desc::D_ON_LOWER:
+        x = colfb[i];
+        break;
+
+      case SPxBasisBase<R>::Desc::P_FIXED:
+      case SPxBasisBase<R>::Desc::D_ON_BOTH:
+
+        if (colfb[i] != coufb[i]) {
+          MSG_WARNING((*this->spxout), (*this->spxout)
+                                           << "WSVECS04 Frhs2[" << i
+                                           << "]: " << static_cast<int>(stat)
+                                           << " " << colfb[i] << " " << coufb[i]
+                                           << " shouldn't be" << std::endl;)
+
+          if (isZero(colfb[i]) || isZero(coufb[i]))
+            colfb[i] = coufb[i] = 0.0;
+          else {
+            R mid = (colfb[i] + coufb[i]) / 2.0;
+            colfb[i] = coufb[i] = mid;
+          }
+        }
+
+        assert(EQ(colfb[i], coufb[i]));
+        x = colfb[i];
+        break;
+
+      default:
+        MSG_ERROR(std::cerr << "ESVECS05 ERROR: "
+                            << "inconsistent basis must not happen!"
+                            << std::endl;)
+        throw SPxInternalCodeException("XSVECS05 This should never happen.");
+      }
 
-         assert(x < R(infinity));
-         assert(x > R(-infinity));
+      assert(x < R(infinity));
+      assert(x > R(-infinity));
 
-         (*theFrhs)[i] -= x; // This is a slack, so no need to multiply a vector.
-      }
-   }
+      (*theFrhs)[i] -= x; // This is a slack, so no need to multiply a vector.
+    }
+  }
 }
 
 /** Computing the right hand side vector for |theCoPvec| depends on
@@ -367,235 +338,204 @@ void SPxSolverBase<R>::computeFrhs2(
     |...4Col(i,n)|, respectively. They do their job for the |i|-th basis
     variable, being the |n|-th row or column.
 */
-template <class R>
-void SPxSolverBase<R>::computeEnterCoPrhs4Row(int i, int n)
-{
-   assert(this->baseId(i).isSPxRowId());
-   assert(this->number(SPxRowId(this->baseId(i))) == n);
-
-   switch(this->desc().rowStatus(n))
-   {
-   // rowwise representation:
-   case SPxBasisBase<R>::Desc::P_FIXED :
-      assert(this->lhs(n) > R(-infinity));
-      assert(EQ(this->rhs(n), this->lhs(n)));
-
-   //lint -fallthrough
-   case SPxBasisBase<R>::Desc::P_ON_UPPER :
-      assert(rep() == ROW);
-      assert(this->rhs(n) < R(infinity));
-      (*theCoPrhs)[i] = this->rhs(n);
-      break;
-
-   case SPxBasisBase<R>::Desc::P_ON_LOWER :
-      assert(rep() == ROW);
-      assert(this->lhs(n) > R(-infinity));
-      (*theCoPrhs)[i] = this->lhs(n);
-      break;
-
-   // columnwise representation:
-   // slacks must be left 0!
-   default:
-      (*theCoPrhs)[i] = this->maxRowObj(n);
-      break;
-   }
+template <class R> void SPxSolverBase<R>::computeEnterCoPrhs4Row(int i, int n) {
+  assert(this->baseId(i).isSPxRowId());
+  assert(this->number(SPxRowId(this->baseId(i))) == n);
+
+  switch (this->desc().rowStatus(n)) {
+  // rowwise representation:
+  case SPxBasisBase<R>::Desc::P_FIXED:
+    assert(this->lhs(n) > R(-infinity));
+    assert(EQ(this->rhs(n), this->lhs(n)));
+
+  // lint -fallthrough
+  case SPxBasisBase<R>::Desc::P_ON_UPPER:
+    assert(rep() == ROW);
+    assert(this->rhs(n) < R(infinity));
+    (*theCoPrhs)[i] = this->rhs(n);
+    break;
+
+  case SPxBasisBase<R>::Desc::P_ON_LOWER:
+    assert(rep() == ROW);
+    assert(this->lhs(n) > R(-infinity));
+    (*theCoPrhs)[i] = this->lhs(n);
+    break;
+
+  // columnwise representation:
+  // slacks must be left 0!
+  default:
+    (*theCoPrhs)[i] = this->maxRowObj(n);
+    break;
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::computeEnterCoPrhs4Col(int i, int n)
-{
-   assert(this->baseId(i).isSPxColId());
-   assert(this->number(SPxColId(this->baseId(i))) == n);
-
-   switch(this->desc().colStatus(n))
-   {
-   // rowwise representation:
-   case SPxBasisBase<R>::Desc::P_FIXED :
-      assert(EQ(SPxLPBase<R>::upper(n), SPxLPBase<R>::lower(n)));
-      assert(SPxLPBase<R>::lower(n) > R(-infinity));
-
-   //lint -fallthrough
-   case SPxBasisBase<R>::Desc::P_ON_UPPER :
-      assert(rep() == ROW);
-      assert(SPxLPBase<R>::upper(n) < R(infinity));
-      (*theCoPrhs)[i] = SPxLPBase<R>::upper(n);
-      break;
-
-   case SPxBasisBase<R>::Desc::P_ON_LOWER :
-      assert(rep() == ROW);
-      assert(SPxLPBase<R>::lower(n) > R(-infinity));
-      (*theCoPrhs)[i] = SPxLPBase<R>::lower(n);
-      break;
-
-   // columnwise representation:
-   case SPxBasisBase<R>::Desc::D_UNDEFINED :
-   case SPxBasisBase<R>::Desc::D_ON_BOTH :
-   case SPxBasisBase<R>::Desc::D_ON_UPPER :
-   case SPxBasisBase<R>::Desc::D_ON_LOWER :
-   case SPxBasisBase<R>::Desc::D_FREE :
-      assert(rep() == COLUMN);
-      (*theCoPrhs)[i] = this->maxObj(n);
-      break;
-
-   default:             // variable left 0
-      (*theCoPrhs)[i] = 0;
-      break;
-   }
+template <class R> void SPxSolverBase<R>::computeEnterCoPrhs4Col(int i, int n) {
+  assert(this->baseId(i).isSPxColId());
+  assert(this->number(SPxColId(this->baseId(i))) == n);
+
+  switch (this->desc().colStatus(n)) {
+  // rowwise representation:
+  case SPxBasisBase<R>::Desc::P_FIXED:
+    assert(EQ(SPxLPBase<R>::upper(n), SPxLPBase<R>::lower(n)));
+    assert(SPxLPBase<R>::lower(n) > R(-infinity));
+
+  // lint -fallthrough
+  case SPxBasisBase<R>::Desc::P_ON_UPPER:
+    assert(rep() == ROW);
+    assert(SPxLPBase<R>::upper(n) < R(infinity));
+    (*theCoPrhs)[i] = SPxLPBase<R>::upper(n);
+    break;
+
+  case SPxBasisBase<R>::Desc::P_ON_LOWER:
+    assert(rep() == ROW);
+    assert(SPxLPBase<R>::lower(n) > R(-infinity));
+    (*theCoPrhs)[i] = SPxLPBase<R>::lower(n);
+    break;
+
+  // columnwise representation:
+  case SPxBasisBase<R>::Desc::D_UNDEFINED:
+  case SPxBasisBase<R>::Desc::D_ON_BOTH:
+  case SPxBasisBase<R>::Desc::D_ON_UPPER:
+  case SPxBasisBase<R>::Desc::D_ON_LOWER:
+  case SPxBasisBase<R>::Desc::D_FREE:
+    assert(rep() == COLUMN);
+    (*theCoPrhs)[i] = this->maxObj(n);
+    break;
+
+  default: // variable left 0
+    (*theCoPrhs)[i] = 0;
+    break;
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::computeEnterCoPrhs()
-{
-   assert(type() == ENTER);
+template <class R> void SPxSolverBase<R>::computeEnterCoPrhs() {
+  assert(type() == ENTER);
 
-   for(int i = dim() - 1; i >= 0; --i)
-   {
-      SPxId l_id = this->baseId(i);
+  for (int i = dim() - 1; i >= 0; --i) {
+    SPxId l_id = this->baseId(i);
 
-      if(l_id.isSPxRowId())
-         computeEnterCoPrhs4Row(i, this->number(SPxRowId(l_id)));
-      else
-         computeEnterCoPrhs4Col(i, this->number(SPxColId(l_id)));
-   }
+    if (l_id.isSPxRowId())
+      computeEnterCoPrhs4Row(i, this->number(SPxRowId(l_id)));
+    else
+      computeEnterCoPrhs4Col(i, this->number(SPxColId(l_id)));
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::computeLeaveCoPrhs4Row(int i, int n)
-{
-   assert(this->baseId(i).isSPxRowId());
-   assert(this->number(SPxRowId(this->baseId(i))) == n);
-
-   switch(this->desc().rowStatus(n))
-   {
-   case SPxBasisBase<R>::Desc::D_ON_BOTH :
-   case SPxBasisBase<R>::Desc::P_FIXED :
-      assert(theLRbound[n] > R(-infinity));
-      assert(EQ(theURbound[n], theLRbound[n]));
-
-   //lint -fallthrough
-   case SPxBasisBase<R>::Desc::D_ON_UPPER :
-   case SPxBasisBase<R>::Desc::P_ON_UPPER :
-      assert(theURbound[n] < R(infinity));
-      (*theCoPrhs)[i] = theURbound[n];
-      break;
-
-   case SPxBasisBase<R>::Desc::D_ON_LOWER :
-   case SPxBasisBase<R>::Desc::P_ON_LOWER :
-      assert(theLRbound[n] > R(-infinity));
-      (*theCoPrhs)[i] = theLRbound[n];
-      break;
-
-   default:
-      (*theCoPrhs)[i] = this->maxRowObj(n);
-      break;
-   }
+template <class R> void SPxSolverBase<R>::computeLeaveCoPrhs4Row(int i, int n) {
+  assert(this->baseId(i).isSPxRowId());
+  assert(this->number(SPxRowId(this->baseId(i))) == n);
+
+  switch (this->desc().rowStatus(n)) {
+  case SPxBasisBase<R>::Desc::D_ON_BOTH:
+  case SPxBasisBase<R>::Desc::P_FIXED:
+    assert(theLRbound[n] > R(-infinity));
+    assert(EQ(theURbound[n], theLRbound[n]));
+
+  // lint -fallthrough
+  case SPxBasisBase<R>::Desc::D_ON_UPPER:
+  case SPxBasisBase<R>::Desc::P_ON_UPPER:
+    assert(theURbound[n] < R(infinity));
+    (*theCoPrhs)[i] = theURbound[n];
+    break;
+
+  case SPxBasisBase<R>::Desc::D_ON_LOWER:
+  case SPxBasisBase<R>::Desc::P_ON_LOWER:
+    assert(theLRbound[n] > R(-infinity));
+    (*theCoPrhs)[i] = theLRbound[n];
+    break;
+
+  default:
+    (*theCoPrhs)[i] = this->maxRowObj(n);
+    break;
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::computeLeaveCoPrhs4Col(int i, int n)
-{
-   assert(this->baseId(i).isSPxColId());
-   assert(this->number(SPxColId(this->baseId(i))) == n);
-
-   switch(this->desc().colStatus(n))
-   {
-   case SPxBasisBase<R>::Desc::D_UNDEFINED :
-   case SPxBasisBase<R>::Desc::D_ON_BOTH :
-   case SPxBasisBase<R>::Desc::P_FIXED :
-      assert(theLCbound[n] > R(-infinity));
-      assert(EQ(theUCbound[n], theLCbound[n]));
-
-   //lint -fallthrough
-   case SPxBasisBase<R>::Desc::D_ON_LOWER :
-   case SPxBasisBase<R>::Desc::P_ON_UPPER :
-      assert(theUCbound[n] < R(infinity));
-      (*theCoPrhs)[i] = theUCbound[n];
-      break;
-
-   case SPxBasisBase<R>::Desc::D_ON_UPPER :
-   case SPxBasisBase<R>::Desc::P_ON_LOWER :
-      assert(theLCbound[n] > R(-infinity));
-      (*theCoPrhs)[i] = theLCbound[n];
-      break;
-
-   default:
-      (*theCoPrhs)[i] = this->maxObj(n);
-      //      (*theCoPrhs)[i] = 0;
-      break;
-   }
+template <class R> void SPxSolverBase<R>::computeLeaveCoPrhs4Col(int i, int n) {
+  assert(this->baseId(i).isSPxColId());
+  assert(this->number(SPxColId(this->baseId(i))) == n);
+
+  switch (this->desc().colStatus(n)) {
+  case SPxBasisBase<R>::Desc::D_UNDEFINED:
+  case SPxBasisBase<R>::Desc::D_ON_BOTH:
+  case SPxBasisBase<R>::Desc::P_FIXED:
+    assert(theLCbound[n] > R(-infinity));
+    assert(EQ(theUCbound[n], theLCbound[n]));
+
+  // lint -fallthrough
+  case SPxBasisBase<R>::Desc::D_ON_LOWER:
+  case SPxBasisBase<R>::Desc::P_ON_UPPER:
+    assert(theUCbound[n] < R(infinity));
+    (*theCoPrhs)[i] = theUCbound[n];
+    break;
+
+  case SPxBasisBase<R>::Desc::D_ON_UPPER:
+  case SPxBasisBase<R>::Desc::P_ON_LOWER:
+    assert(theLCbound[n] > R(-infinity));
+    (*theCoPrhs)[i] = theLCbound[n];
+    break;
+
+  default:
+    (*theCoPrhs)[i] = this->maxObj(n);
+    //      (*theCoPrhs)[i] = 0;
+    break;
+  }
 }
 
-template <class R>
-void SPxSolverBase<R>::computeLeaveCoPrhs()
-{
-   assert(type() == LEAVE);
+template <class R> void SPxSolverBase<R>::computeLeaveCoPrhs() {
+  assert(type() == LEAVE);
 
-   for(int i = dim() - 1; i >= 0; --i)
-   {
-      SPxId l_id = this->baseId(i);
+  for (int i = dim() - 1; i >= 0; --i) {
+    SPxId l_id = this->baseId(i);
 
-      if(l_id.isSPxRowId())
-         computeLeaveCoPrhs4Row(i, this->number(SPxRowId(l_id)));
-      else
-         computeLeaveCoPrhs4Col(i, this->number(SPxColId(l_id)));
-   }
+    if (l_id.isSPxRowId())
+      computeLeaveCoPrhs4Row(i, this->number(SPxRowId(l_id)));
+    else
+      computeLeaveCoPrhs4Col(i, this->number(SPxColId(l_id)));
+  }
 }
 
-
 /** When computing the copricing vector, we expect the pricing vector to be
     setup correctly. Then computing the copricing vector is nothing but
     computing all scalar products of the pricing vector with the vectors of the
     LPs constraint matrix.
 */
-template <class R>
-void SPxSolverBase<R>::computePvec()
-{
-   int i;
+template <class R> void SPxSolverBase<R>::computePvec() {
+  int i;
 
-   for(i = coDim() - 1; i >= 0; --i)
-      (*thePvec)[i] = vector(i) * (*theCoPvec);
+  for (i = coDim() - 1; i >= 0; --i)
+    (*thePvec)[i] = vector(i) * (*theCoPvec);
 }
 
-template <class R>
-void SPxSolverBase<R>::setupPupdate(void)
-{
-   SSVectorBase<R>& p = thePvec->delta();
-   SSVectorBase<R>& c = theCoPvec->delta();
-
-   if(c.isSetup())
-   {
-      if(c.size() < 0.95 * theCoPvec->dim())
-         p.assign2product4setup(*thecovectors, c,
-                                multTimeSparse, multTimeFull,
-                                multSparseCalls, multFullCalls);
-      else
-      {
-         multTimeColwise->start();
-         p.assign2product(c, *thevectors);
-         multTimeColwise->stop();
-         ++multColwiseCalls;
-      }
-   }
-   else
-   {
-      multTimeUnsetup->start();
-      p.assign2productAndSetup(*thecovectors, c);
-      multTimeUnsetup->stop();
-      ++multUnsetupCalls;
-   }
-
-   p.setup();
+template <class R> void SPxSolverBase<R>::setupPupdate(void) {
+  SSVectorBase<R> &p = thePvec->delta();
+  SSVectorBase<R> &c = theCoPvec->delta();
+
+  if (c.isSetup()) {
+    if (c.size() < 0.95 * theCoPvec->dim())
+      p.assign2product4setup(*thecovectors, c, multTimeSparse, multTimeFull,
+                             multSparseCalls, multFullCalls);
+    else {
+      multTimeColwise->start();
+      p.assign2product(c, *thevectors);
+      multTimeColwise->stop();
+      ++multColwiseCalls;
+    }
+  } else {
+    multTimeUnsetup->start();
+    p.assign2productAndSetup(*thecovectors, c);
+    multTimeUnsetup->stop();
+    ++multUnsetupCalls;
+  }
+
+  p.setup();
 }
 
-template <class R>
-void SPxSolverBase<R>::doPupdate(void)
-{
-   theCoPvec->update();
+template <class R> void SPxSolverBase<R>::doPupdate(void) {
+  theCoPvec->update();
 
-   if(pricing() == FULL)
-   {
-      // thePvec->delta().setup();
-      thePvec->update();
-   }
+  if (pricing() == FULL) {
+    // thePvec->delta().setup();
+    thePvec->update();
+  }
 }
 } // namespace soplex
diff --git a/src/soplex/spxvectorst.hpp b/src/soplex/spxvectorst.hpp
index 950a478..3a66d37 100644
--- a/src/soplex/spxvectorst.hpp
+++ b/src/soplex/spxvectorst.hpp
@@ -21,111 +21,94 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <assert.h>
 #include <iostream>
 
 #include "soplex/spxdefines.h"
 
-namespace soplex
-{
-
-template <class R>
-void SPxVectorST<R>::setupWeights(SPxSolverBase<R>& base)
-{
-   if(state == PVEC)
-   {
-      if(vec.dim() != base.nCols())
-      {
-         SPxWeightST<R>::setupWeights(base);
-         return;
-      }
+namespace soplex {
 
-      const VectorBase<R>& obj = base.maxObj();
-      R eps = base.epsilon();
-      R bias = 10000 * eps;
-      R x, y;
-      int i;
-
-      MSG_DEBUG(std::cout << "DVECST01 colWeight[]: ";)
-
-      for(i = base.nCols(); i--;)
-      {
-         x = vec[i] - base.SPxLPBase<R>::lower(i);
-         y = base.SPxLPBase<R>::upper(i) - vec[i];
-
-         if(x < y)
-         {
-            this->colWeight[i] = -x - bias * obj[i];
-            this->colUp[i] = 0;
-         }
-         else
-         {
-            this->colWeight[i] = -y + bias * obj[i];
-            this->colUp[i] = 1;
-         }
-
-         MSG_DEBUG(std::cout << this->colWeight[i] << " ";)
+template <class R> void SPxVectorST<R>::setupWeights(SPxSolverBase<R> &base) {
+  if (state == PVEC) {
+    if (vec.dim() != base.nCols()) {
+      SPxWeightST<R>::setupWeights(base);
+      return;
+    }
+
+    const VectorBase<R> &obj = base.maxObj();
+    R eps = base.epsilon();
+    R bias = 10000 * eps;
+    R x, y;
+    int i;
+
+    MSG_DEBUG(std::cout << "DVECST01 colWeight[]: ";)
+
+    for (i = base.nCols(); i--;) {
+      x = vec[i] - base.SPxLPBase<R>::lower(i);
+      y = base.SPxLPBase<R>::upper(i) - vec[i];
+
+      if (x < y) {
+        this->colWeight[i] = -x - bias * obj[i];
+        this->colUp[i] = 0;
+      } else {
+        this->colWeight[i] = -y + bias * obj[i];
+        this->colUp[i] = 1;
       }
 
-      MSG_DEBUG(std::cout << std::endl << std::endl;)
-
-      MSG_DEBUG(std::cout << "DVECST02 rowWeight[]: ";)
-
-      for(i = base.nRows(); i--;)
-      {
-         const SVectorBase<R>& row = base.rowVector(i);
-         y = vec * row;
-         x = (y - base.lhs(i));
-         y = (base.rhs(i) - y);
-
-         if(x < y)
-         {
-            this->rowWeight[i] = -x - eps * row.size() - bias * (obj * row);
-            this->rowRight[i] = 0;
-         }
-         else
-         {
-            this->rowWeight[i] = -y - eps * row.size() + bias * (obj * row);
-            this->rowRight[i] = 1;
-         }
-
-         MSG_DEBUG(std::cout << this->rowWeight[i] << " ";)
-      }
+      MSG_DEBUG(std::cout << this->colWeight[i] << " ";)
+    }
+
+    MSG_DEBUG(std::cout << std::endl << std::endl;)
+
+    MSG_DEBUG(std::cout << "DVECST02 rowWeight[]: ";)
 
-      MSG_DEBUG(std::cout << std::endl;)
-   }
+    for (i = base.nRows(); i--;) {
+      const SVectorBase<R> &row = base.rowVector(i);
+      y = vec * row;
+      x = (y - base.lhs(i));
+      y = (base.rhs(i) - y);
 
-   else if(state == DVEC)
-   {
-      if(vec.dim() != base.nRows())
-      {
-         SPxWeightST<R>::setupWeights(base);
-         return;
+      if (x < y) {
+        this->rowWeight[i] = -x - eps * row.size() - bias * (obj * row);
+        this->rowRight[i] = 0;
+      } else {
+        this->rowWeight[i] = -y - eps * row.size() + bias * (obj * row);
+        this->rowRight[i] = 1;
       }
 
-      R x, y, len;
-      int i, j;
+      MSG_DEBUG(std::cout << this->rowWeight[i] << " ";)
+    }
 
-      for(i = base.nRows(); i--;)
-         this->rowWeight[i] += spxAbs(vec[i]);
+    MSG_DEBUG(std::cout << std::endl;)
+  }
 
-      for(i = base.nCols(); i--;)
-      {
-         const SVectorBase<R>& col = base.colVector(i);
+  else if (state == DVEC) {
+    if (vec.dim() != base.nRows()) {
+      SPxWeightST<R>::setupWeights(base);
+      return;
+    }
+
+    R x, y, len;
+    int i, j;
+
+    for (i = base.nRows(); i--;)
+      this->rowWeight[i] += spxAbs(vec[i]);
 
-         for(y = len = 0, j = col.size(); j--;)
-         {
-            x = col.value(j);
-            y += vec[col.index(j)] * x;
-            len += x * x;
-         }
+    for (i = base.nCols(); i--;) {
+      const SVectorBase<R> &col = base.colVector(i);
 
-         if(len > 0)
-            this->colWeight[i] += spxAbs(y / len - base.maxObj(i));
+      for (y = len = 0, j = col.size(); j--;) {
+        x = col.value(j);
+        y += vec[col.index(j)] * x;
+        len += x * x;
       }
-   }
-   else
-      SPxWeightST<R>::setupWeights(base);
+
+      if (len > 0)
+        this->colWeight[i] += spxAbs(y / len - base.maxObj(i));
+    }
+  } else
+    SPxWeightST<R>::setupWeights(base);
 }
 } // namespace soplex
diff --git a/src/soplex/spxweightpr.hpp b/src/soplex/spxweightpr.hpp
index 7b17547..7e05c83 100644
--- a/src/soplex/spxweightpr.hpp
+++ b/src/soplex/spxweightpr.hpp
@@ -21,402 +21,332 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 #include <assert.h>
 
+#include "soplex/exceptions.h"
 #include "soplex/spxdefines.h"
 #include "soplex/spxweightpr.h"
-#include "soplex/exceptions.h"
 
-namespace soplex
-{
-template <class R>
-void SPxWeightPR<R>::computeLeavePenalty(int start, int end);
+namespace soplex {
+template <class R> void SPxWeightPR<R>::computeLeavePenalty(int start, int end);
 
-template <class R>
-bool SPxWeightPR<R>::isConsistent() const;
+template <class R> bool SPxWeightPR<R>::isConsistent() const;
 
 template <class R>
-void SPxWeightPR<R>::setRep(typename SPxSolverBase<R>::Representation rep)
-{
-   if(rep == SPxSolverBase<R>::ROW)
-   {
-      penalty = rPenalty.get_const_ptr();
-      coPenalty = cPenalty.get_const_ptr();
-   }
-   else
-   {
-      penalty = cPenalty.get_const_ptr();
-      coPenalty = rPenalty.get_const_ptr();
-   }
+void SPxWeightPR<R>::setRep(typename SPxSolverBase<R>::Representation rep) {
+  if (rep == SPxSolverBase<R>::ROW) {
+    penalty = rPenalty.get_const_ptr();
+    coPenalty = cPenalty.get_const_ptr();
+  } else {
+    penalty = cPenalty.get_const_ptr();
+    coPenalty = rPenalty.get_const_ptr();
+  }
 }
 
 template <class R>
-void SPxWeightPR<R>::setType(typename SPxSolverBase<R>::Type tp)
-{
-   if(this->thesolver && tp == SPxSolverBase<R>::LEAVE)
-   {
-      leavePenalty.reDim(this->thesolver->dim());
-      computeLeavePenalty(0, this->thesolver->dim());
-   }
+void SPxWeightPR<R>::setType(typename SPxSolverBase<R>::Type tp) {
+  if (this->thesolver && tp == SPxSolverBase<R>::LEAVE) {
+    leavePenalty.reDim(this->thesolver->dim());
+    computeLeavePenalty(0, this->thesolver->dim());
+  }
 }
 
 template <class R>
-void SPxWeightPR<R>::computeLeavePenalty(int start, int end)
-{
-   const SPxBasisBase<R>& basis = this->solver()->basis();
-
-   for(int i = start; i < end; ++i)
-   {
-      SPxId id = basis.baseId(i);
-
-      if(id.type() == SPxId::ROW_ID)
-         leavePenalty[i] = rPenalty[ this->thesolver->number(id) ];
-      else
-         leavePenalty[i] = cPenalty[ this->thesolver->number(id) ];
-   }
+void SPxWeightPR<R>::computeLeavePenalty(int start, int end) {
+  const SPxBasisBase<R> &basis = this->solver()->basis();
+
+  for (int i = start; i < end; ++i) {
+    SPxId id = basis.baseId(i);
+
+    if (id.type() == SPxId::ROW_ID)
+      leavePenalty[i] = rPenalty[this->thesolver->number(id)];
+    else
+      leavePenalty[i] = cPenalty[this->thesolver->number(id)];
+  }
 }
 
-template <class R>
-void SPxWeightPR<R>::computeRP(int start, int end)
-{
-   for(int i = start; i < end; ++i)
-   {
-      /**@todo TK04NOV98 here is a bug.
-       *       this->solver()->rowVector(i).length() could be zero, so
-       *       this->solver()->rowVector(i).length2() is also zero and we
-       *       get an arithmetic exception.
-       */
-      assert(this->solver()->rowVector(i).length() > 0);
-
-      rPenalty[i] = (this->solver()->rowVector(i) * this->solver()->maxObj()) * objlength
-                    / this->solver()->rowVector(i).length2();
-      ASSERT_WARN("WWGTPR01", rPenalty[i] > -1 - this->solver()->epsilon());
-   }
+template <class R> void SPxWeightPR<R>::computeRP(int start, int end) {
+  for (int i = start; i < end; ++i) {
+    /**@todo TK04NOV98 here is a bug.
+     *       this->solver()->rowVector(i).length() could be zero, so
+     *       this->solver()->rowVector(i).length2() is also zero and we
+     *       get an arithmetic exception.
+     */
+    assert(this->solver()->rowVector(i).length() > 0);
+
+    rPenalty[i] = (this->solver()->rowVector(i) * this->solver()->maxObj()) *
+                  objlength / this->solver()->rowVector(i).length2();
+    ASSERT_WARN("WWGTPR01", rPenalty[i] > -1 - this->solver()->epsilon());
+  }
 }
 
-template <class R>
-void SPxWeightPR<R>::computeCP(int start, int end)
-{
-   for(int i = start; i < end; ++i)
-   {
-      cPenalty[i] = this->solver()->maxObj(i) * objlength;
-      ASSERT_WARN("WWGTPR02", cPenalty[i] > -1 - this->solver()->epsilon());
-   }
+template <class R> void SPxWeightPR<R>::computeCP(int start, int end) {
+  for (int i = start; i < end; ++i) {
+    cPenalty[i] = this->solver()->maxObj(i) * objlength;
+    ASSERT_WARN("WWGTPR02", cPenalty[i] > -1 - this->solver()->epsilon());
+  }
 }
 
-template <class R>
-void SPxWeightPR<R>::load(SPxSolverBase<R>* base)
-{
-   this->thesolver = base;
+template <class R> void SPxWeightPR<R>::load(SPxSolverBase<R> *base) {
+  this->thesolver = base;
 
-   rPenalty.reDim(base->nRows());
-   cPenalty.reDim(base->nCols());
+  rPenalty.reDim(base->nRows());
+  cPenalty.reDim(base->nCols());
 
-   objlength = 1 / this->solver()->maxObj().length();
-   computeCP(0, base->nCols());
-   computeRP(0, base->nRows());
+  objlength = 1 / this->solver()->maxObj().length();
+  computeCP(0, base->nCols());
+  computeRP(0, base->nRows());
 }
 
-template <class R>
-int SPxWeightPR<R>::selectLeave()
-{
-   const R* test = this->thesolver->fTest().get_const_ptr();
-   R type = 1 - 2 * (this->thesolver->rep() == SPxSolverBase<R>::COLUMN ? 1 : 0);
-   R best = type * R(infinity);
-   int lastIdx = -1;
-   R x;
-   int i;
-
-   for(i = this->solver()->dim() - 1; i >= 0; --i)
-   {
-      x = test[i];
-
-      if(x < -this->theeps)
-      {
-         x *= leavePenalty[i];
-
-         if(type * (x - best) < 0.0)
-         {
-            best = x;
-            lastIdx = i;
-         }
+template <class R> int SPxWeightPR<R>::selectLeave() {
+  const R *test = this->thesolver->fTest().get_const_ptr();
+  R type = 1 - 2 * (this->thesolver->rep() == SPxSolverBase<R>::COLUMN ? 1 : 0);
+  R best = type * R(infinity);
+  int lastIdx = -1;
+  R x;
+  int i;
+
+  for (i = this->solver()->dim() - 1; i >= 0; --i) {
+    x = test[i];
+
+    if (x < -this->theeps) {
+      x *= leavePenalty[i];
+
+      if (type * (x - best) < 0.0) {
+        best = x;
+        lastIdx = i;
       }
-   }
+    }
+  }
 
-   assert(isConsistent());
-   return lastIdx;
+  assert(isConsistent());
+  return lastIdx;
 }
 
-template <class R>
-SPxId SPxWeightPR<R>::selectEnter()
-{
-   const VectorBase<R>& rTest = (this->solver()->rep() == SPxSolverBase<R>::ROW)
-                                ? this->solver()->test() : this->solver()->coTest();
-   const VectorBase<R>& cTest = (this->solver()->rep() == SPxSolverBase<R>::ROW)
-                                ? this->solver()->coTest() : this->solver()->test();
-   const typename SPxBasisBase<R>::Desc& ds = this->solver()->basis().desc();
-   R best = R(infinity);
-   SPxId lastId;
-   R x;
-   int i;
-
-   for(i = this->solver()->nRows() - 1; i >= 0; --i)
-   {
-      x = rTest[i];
-
-      if(x < -this->theeps)
-      {
-         x *= -x;
-
-         switch(ds.rowStatus(i))
-         {
-         case SPxBasisBase<R>::Desc::P_ON_LOWER :
-         case SPxBasisBase<R>::Desc::D_ON_LOWER :
-            x *= 1 + rPenalty[i];
-            break;
-
-         case SPxBasisBase<R>::Desc::P_ON_UPPER :
-         case SPxBasisBase<R>::Desc::D_ON_UPPER :
-            x *= 1 - rPenalty[i];
-            break;
-
-         case SPxBasisBase<R>::Desc::P_FREE :
-         case SPxBasisBase<R>::Desc::D_FREE :
-            return SPxId(this->solver()->rId(i));
-
-         case SPxBasisBase<R>::Desc::D_ON_BOTH :
-            if(this->solver()->pVec()[i] > this->solver()->upBound()[i])
-               x *= 1 + rPenalty[i];
-            else
-               x *= 1 - rPenalty[i];
-
-            break;
-
-         case SPxBasisBase<R>::Desc::D_UNDEFINED :
-         case SPxBasisBase<R>::Desc::P_FIXED :
-         default:
-            throw SPxInternalCodeException("XWGTPR01 This should never happen.");
-         }
-
-         if(x < best)
-         {
-            best = x;
-            lastId = this->solver()->rId(i);
-         }
+template <class R> SPxId SPxWeightPR<R>::selectEnter() {
+  const VectorBase<R> &rTest = (this->solver()->rep() == SPxSolverBase<R>::ROW)
+                                   ? this->solver()->test()
+                                   : this->solver()->coTest();
+  const VectorBase<R> &cTest = (this->solver()->rep() == SPxSolverBase<R>::ROW)
+                                   ? this->solver()->coTest()
+                                   : this->solver()->test();
+  const typename SPxBasisBase<R>::Desc &ds = this->solver()->basis().desc();
+  R best = R(infinity);
+  SPxId lastId;
+  R x;
+  int i;
+
+  for (i = this->solver()->nRows() - 1; i >= 0; --i) {
+    x = rTest[i];
+
+    if (x < -this->theeps) {
+      x *= -x;
+
+      switch (ds.rowStatus(i)) {
+      case SPxBasisBase<R>::Desc::P_ON_LOWER:
+      case SPxBasisBase<R>::Desc::D_ON_LOWER:
+        x *= 1 + rPenalty[i];
+        break;
+
+      case SPxBasisBase<R>::Desc::P_ON_UPPER:
+      case SPxBasisBase<R>::Desc::D_ON_UPPER:
+        x *= 1 - rPenalty[i];
+        break;
+
+      case SPxBasisBase<R>::Desc::P_FREE:
+      case SPxBasisBase<R>::Desc::D_FREE:
+        return SPxId(this->solver()->rId(i));
+
+      case SPxBasisBase<R>::Desc::D_ON_BOTH:
+        if (this->solver()->pVec()[i] > this->solver()->upBound()[i])
+          x *= 1 + rPenalty[i];
+        else
+          x *= 1 - rPenalty[i];
+
+        break;
+
+      case SPxBasisBase<R>::Desc::D_UNDEFINED:
+      case SPxBasisBase<R>::Desc::P_FIXED:
+      default:
+        throw SPxInternalCodeException("XWGTPR01 This should never happen.");
       }
-   }
-
-   for(i = this->solver()->nCols() - 1; i >= 0; --i)
-   {
-      x = cTest[i];
-
-      if(x < -this->theeps)
-      {
-         x *= -x;
-
-         switch(ds.colStatus(i))
-         {
-         case SPxBasisBase<R>::Desc::P_ON_LOWER :
-         case SPxBasisBase<R>::Desc::D_ON_LOWER :
-            x *= 1 + cPenalty[i];
-            break;
-
-         case SPxBasisBase<R>::Desc::P_ON_UPPER :
-         case SPxBasisBase<R>::Desc::D_ON_UPPER :
-            x *= 1 - cPenalty[i];
-            break;
-
-         case SPxBasisBase<R>::Desc::P_FREE :
-         case SPxBasisBase<R>::Desc::D_FREE :
-            return SPxId(this->solver()->cId(i));
-
-         case SPxBasisBase<R>::Desc::D_ON_BOTH :
-            if(this->solver()->coPvec()[i] > this->solver()->ucBound()[i])
-               x *= 1 + cPenalty[i];
-            else
-               x *= 1 - cPenalty[i];
-
-            break;
-
-         case SPxBasisBase<R>::Desc::P_FIXED :
-         case SPxBasisBase<R>::Desc::D_UNDEFINED :
-         default:
-            throw SPxInternalCodeException("XWGTPR02 This should never happen.");
-         }
-
-         if(x < best)
-         {
-            best = x;
-            lastId = this->solver()->cId(i);
-         }
+
+      if (x < best) {
+        best = x;
+        lastId = this->solver()->rId(i);
+      }
+    }
+  }
+
+  for (i = this->solver()->nCols() - 1; i >= 0; --i) {
+    x = cTest[i];
+
+    if (x < -this->theeps) {
+      x *= -x;
+
+      switch (ds.colStatus(i)) {
+      case SPxBasisBase<R>::Desc::P_ON_LOWER:
+      case SPxBasisBase<R>::Desc::D_ON_LOWER:
+        x *= 1 + cPenalty[i];
+        break;
+
+      case SPxBasisBase<R>::Desc::P_ON_UPPER:
+      case SPxBasisBase<R>::Desc::D_ON_UPPER:
+        x *= 1 - cPenalty[i];
+        break;
+
+      case SPxBasisBase<R>::Desc::P_FREE:
+      case SPxBasisBase<R>::Desc::D_FREE:
+        return SPxId(this->solver()->cId(i));
+
+      case SPxBasisBase<R>::Desc::D_ON_BOTH:
+        if (this->solver()->coPvec()[i] > this->solver()->ucBound()[i])
+          x *= 1 + cPenalty[i];
+        else
+          x *= 1 - cPenalty[i];
+
+        break;
+
+      case SPxBasisBase<R>::Desc::P_FIXED:
+      case SPxBasisBase<R>::Desc::D_UNDEFINED:
+      default:
+        throw SPxInternalCodeException("XWGTPR02 This should never happen.");
+      }
+
+      if (x < best) {
+        best = x;
+        lastId = this->solver()->cId(i);
       }
-   }
+    }
+  }
 
-   assert(isConsistent());
-   return lastId;
+  assert(isConsistent());
+  return lastId;
 }
 
-template <class R>
-void SPxWeightPR<R>::addedVecs(int)
-{
-   if(this->solver()->rep() == SPxSolverBase<R>::ROW)
-   {
-      int start = rPenalty.dim();
-      rPenalty.reDim(this->solver()->nRows());
-      computeRP(start, this->solver()->nRows());
-   }
-   else
-   {
-      int start = cPenalty.dim();
-      cPenalty.reDim(this->solver()->nCols());
-      computeCP(start, this->solver()->nCols());
-   }
-
-   if(this->solver()->type() == SPxSolverBase<R>::LEAVE)
-   {
-      int start = leavePenalty.dim();
-      leavePenalty.reDim(this->solver()->dim());
-      computeLeavePenalty(start, this->solver()->dim());
-   }
+template <class R> void SPxWeightPR<R>::addedVecs(int) {
+  if (this->solver()->rep() == SPxSolverBase<R>::ROW) {
+    int start = rPenalty.dim();
+    rPenalty.reDim(this->solver()->nRows());
+    computeRP(start, this->solver()->nRows());
+  } else {
+    int start = cPenalty.dim();
+    cPenalty.reDim(this->solver()->nCols());
+    computeCP(start, this->solver()->nCols());
+  }
+
+  if (this->solver()->type() == SPxSolverBase<R>::LEAVE) {
+    int start = leavePenalty.dim();
+    leavePenalty.reDim(this->solver()->dim());
+    computeLeavePenalty(start, this->solver()->dim());
+  }
 }
 
-template <class R>
-void SPxWeightPR<R>::addedCoVecs(int)
-{
-   if(this->solver()->rep() == SPxSolverBase<R>::COLUMN)
-   {
-      int start = rPenalty.dim();
-      rPenalty.reDim(this->solver()->nRows());
-      computeRP(start, this->solver()->nRows());
-   }
-   else
-   {
-      int start = cPenalty.dim();
-      cPenalty.reDim(this->solver()->nCols());
-      computeCP(start, this->solver()->nCols());
-   }
-
-   if(this->solver()->type() == SPxSolverBase<R>::LEAVE)
-   {
-      int start = leavePenalty.dim();
-      leavePenalty.reDim(this->solver()->dim());
-      computeLeavePenalty(start, this->solver()->dim());
-   }
+template <class R> void SPxWeightPR<R>::addedCoVecs(int) {
+  if (this->solver()->rep() == SPxSolverBase<R>::COLUMN) {
+    int start = rPenalty.dim();
+    rPenalty.reDim(this->solver()->nRows());
+    computeRP(start, this->solver()->nRows());
+  } else {
+    int start = cPenalty.dim();
+    cPenalty.reDim(this->solver()->nCols());
+    computeCP(start, this->solver()->nCols());
+  }
+
+  if (this->solver()->type() == SPxSolverBase<R>::LEAVE) {
+    int start = leavePenalty.dim();
+    leavePenalty.reDim(this->solver()->dim());
+    computeLeavePenalty(start, this->solver()->dim());
+  }
 }
 
-template <class R>
-void SPxWeightPR<R>::removedVec(int i)
-{
-   assert(this->solver() != 0);
-
-   if(this->solver()->rep() == SPxSolverBase<R>::ROW)
-   {
-      rPenalty[i] = rPenalty[rPenalty.dim()];
-      rPenalty.reDim(this->solver()->nRows());
-   }
-   else
-   {
-      cPenalty[i] = cPenalty[cPenalty.dim()];
-      cPenalty.reDim(this->solver()->nCols());
-   }
+template <class R> void SPxWeightPR<R>::removedVec(int i) {
+  assert(this->solver() != 0);
+
+  if (this->solver()->rep() == SPxSolverBase<R>::ROW) {
+    rPenalty[i] = rPenalty[rPenalty.dim()];
+    rPenalty.reDim(this->solver()->nRows());
+  } else {
+    cPenalty[i] = cPenalty[cPenalty.dim()];
+    cPenalty.reDim(this->solver()->nCols());
+  }
 }
 
-template <class R>
-void SPxWeightPR<R>::removedVecs(const int perm[])
-{
-   assert(this->solver() != 0);
-
-   if(this->solver()->rep() == SPxSolverBase<R>::ROW)
-   {
-      int j = rPenalty.dim();
-
-      for(int i = 0; i < j; ++i)
-      {
-         if(perm[i] >= 0)
-            rPenalty[perm[i]] = rPenalty[i];
-      }
+template <class R> void SPxWeightPR<R>::removedVecs(const int perm[]) {
+  assert(this->solver() != 0);
 
-      rPenalty.reDim(this->solver()->nRows());
-   }
-   else
-   {
-      int j = cPenalty.dim();
+  if (this->solver()->rep() == SPxSolverBase<R>::ROW) {
+    int j = rPenalty.dim();
 
-      for(int i = 0; i < j; ++i)
-      {
-         if(perm[i] >= 0)
-            cPenalty[perm[i]] = cPenalty[i];
-      }
+    for (int i = 0; i < j; ++i) {
+      if (perm[i] >= 0)
+        rPenalty[perm[i]] = rPenalty[i];
+    }
+
+    rPenalty.reDim(this->solver()->nRows());
+  } else {
+    int j = cPenalty.dim();
+
+    for (int i = 0; i < j; ++i) {
+      if (perm[i] >= 0)
+        cPenalty[perm[i]] = cPenalty[i];
+    }
 
-      cPenalty.reDim(this->solver()->nCols());
-   }
+    cPenalty.reDim(this->solver()->nCols());
+  }
 }
 
-template <class R>
-void SPxWeightPR<R>::removedCoVec(int i)
-{
-   assert(this->solver() != 0);
-
-   if(this->solver()->rep() == SPxSolverBase<R>::COLUMN)
-   {
-      rPenalty[i] = rPenalty[rPenalty.dim()];
-      rPenalty.reDim(this->solver()->nRows());
-   }
-   else
-   {
-      cPenalty[i] = cPenalty[cPenalty.dim()];
-      cPenalty.reDim(this->solver()->nCols());
-   }
+template <class R> void SPxWeightPR<R>::removedCoVec(int i) {
+  assert(this->solver() != 0);
+
+  if (this->solver()->rep() == SPxSolverBase<R>::COLUMN) {
+    rPenalty[i] = rPenalty[rPenalty.dim()];
+    rPenalty.reDim(this->solver()->nRows());
+  } else {
+    cPenalty[i] = cPenalty[cPenalty.dim()];
+    cPenalty.reDim(this->solver()->nCols());
+  }
 }
 
-template <class R>
-void SPxWeightPR<R>::removedCoVecs(const int perm[])
-{
-   assert(this->solver() != 0);
-
-   if(this->solver()->rep() == SPxSolverBase<R>::COLUMN)
-   {
-      int j = rPenalty.dim();
-
-      for(int i = 0; i < j; ++i)
-      {
-         if(perm[i] >= 0)
-            rPenalty[perm[i]] = rPenalty[i];
-      }
+template <class R> void SPxWeightPR<R>::removedCoVecs(const int perm[]) {
+  assert(this->solver() != 0);
 
-      rPenalty.reDim(this->solver()->nRows());
-   }
-   else
-   {
-      int j = cPenalty.dim();
+  if (this->solver()->rep() == SPxSolverBase<R>::COLUMN) {
+    int j = rPenalty.dim();
 
-      for(int i = 0; i < j; ++i)
-      {
-         if(perm[i] >= 0)
-            cPenalty[perm[i]] = cPenalty[i];
-      }
+    for (int i = 0; i < j; ++i) {
+      if (perm[i] >= 0)
+        rPenalty[perm[i]] = rPenalty[i];
+    }
+
+    rPenalty.reDim(this->solver()->nRows());
+  } else {
+    int j = cPenalty.dim();
 
-      cPenalty.reDim(this->solver()->nCols());
-   }
+    for (int i = 0; i < j; ++i) {
+      if (perm[i] >= 0)
+        cPenalty[perm[i]] = cPenalty[i];
+    }
+
+    cPenalty.reDim(this->solver()->nCols());
+  }
 }
 
-template <class R>
-bool SPxWeightPR<R>::isConsistent() const
-{
+template <class R> bool SPxWeightPR<R>::isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
 
-   if(this->solver() != 0)
-   {
-      if(rPenalty.dim() != this->solver()->nRows())
-         return MSGinconsistent("SPxWeightPR");
+  if (this->solver() != 0) {
+    if (rPenalty.dim() != this->solver()->nRows())
+      return MSGinconsistent("SPxWeightPR");
 
-      if(cPenalty.dim() != this->solver()->nCols())
-         return MSGinconsistent("SPxWeightPR");
-   }
+    if (cPenalty.dim() != this->solver()->nCols())
+      return MSGinconsistent("SPxWeightPR");
+  }
 
 #endif
 
-   return true;
+  return true;
 }
 } // namespace soplex
diff --git a/src/soplex/spxweightst.hpp b/src/soplex/spxweightst.hpp
index 5edfde8..0992c41 100644
--- a/src/soplex/spxweightst.hpp
+++ b/src/soplex/spxweightst.hpp
@@ -21,32 +21,27 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
-
+#pragma once
 
 #include <assert.h>
 #include <iostream>
 
+#include "soplex/sorter.h"
 #include "soplex/spxdefines.h"
 #include "soplex/svset.h"
-#include "soplex/sorter.h"
-
-namespace soplex
-{
-#define EPS     1e-6
-#define STABLE  1e-3    // the sparsest row/column may only have a pivot of size STABLE*maxEntry
 
+namespace soplex {
+#define EPS 1e-6
+#define STABLE                                                                 \
+  1e-3 // the sparsest row/column may only have a pivot of size STABLE*maxEntry
 
-template <class R>
-bool SPxWeightST<R>::isConsistent() const
-{
+template <class R> bool SPxWeightST<R>::isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
-   return rowWeight.isConsistent()
-          && colWeight.isConsistent()
-          && rowRight.isConsistent()
-          && colUp.isConsistent();
-   // && SPxStarter::isConsistent();   // not yet implemented
+  return rowWeight.isConsistent() && colWeight.isConsistent() &&
+         rowRight.isConsistent() && colUp.isConsistent();
+  // && SPxStarter::isConsistent();   // not yet implemented
 #else
-   return true;
+  return true;
 #endif
 }
 
@@ -69,94 +64,73 @@ bool SPxWeightST<R>::isConsistent() const
   respectively.
 */
 template <class R>
-void SPxWeightST<R>::setPrimalStatus(
-   typename SPxBasisBase<R>::Desc& desc,
-   const SPxSolverBase<R>& base,
-   const SPxId& id)
-{
-   if(id.isSPxRowId())
-   {
-      int n = base.number(SPxRowId(id));
-
-      if(base.rhs(n) >= R(infinity))
-      {
-         if(base.lhs(n) <= R(-infinity))
-            desc.rowStatus(n) = SPxBasisBase<R>::Desc::P_FREE;
-         else
-            desc.rowStatus(n) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-      }
+void SPxWeightST<R>::setPrimalStatus(typename SPxBasisBase<R>::Desc &desc,
+                                     const SPxSolverBase<R> &base,
+                                     const SPxId &id) {
+  if (id.isSPxRowId()) {
+    int n = base.number(SPxRowId(id));
+
+    if (base.rhs(n) >= R(infinity)) {
+      if (base.lhs(n) <= R(-infinity))
+        desc.rowStatus(n) = SPxBasisBase<R>::Desc::P_FREE;
       else
-      {
-         if(base.lhs(n) <= R(-infinity))
-            desc.rowStatus(n) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         else if(base.lhs(n) >= base.rhs(n) - base.epsilon())
-            desc.rowStatus(n) = SPxBasisBase<R>::Desc::P_FIXED;
-         else if(rowRight[n])
-            desc.rowStatus(n) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         else
-            desc.rowStatus(n) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-      }
-   }
-   else
-   {
-      int n = base.number(SPxColId(id));
-
-      if(base.SPxLPBase<R>::upper(n) >= R(infinity))
-      {
-         if(base.SPxLPBase<R>::lower(n) <= R(-infinity))
-            desc.colStatus(n) = SPxBasisBase<R>::Desc::P_FREE;
-         else
-            desc.colStatus(n) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-      }
+        desc.rowStatus(n) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+    } else {
+      if (base.lhs(n) <= R(-infinity))
+        desc.rowStatus(n) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      else if (base.lhs(n) >= base.rhs(n) - base.epsilon())
+        desc.rowStatus(n) = SPxBasisBase<R>::Desc::P_FIXED;
+      else if (rowRight[n])
+        desc.rowStatus(n) = SPxBasisBase<R>::Desc::P_ON_UPPER;
       else
-      {
-         if(base.SPxLPBase<R>::lower(n) <= R(-infinity))
-            desc.colStatus(n) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         else if(base.SPxLPBase<R>::lower(n) >= base.SPxLPBase<R>::upper(n) - base.epsilon())
-            desc.colStatus(n) = SPxBasisBase<R>::Desc::P_FIXED;
-         else if(colUp[n])
-            desc.colStatus(n) = SPxBasisBase<R>::Desc::P_ON_UPPER;
-         else
-            desc.colStatus(n) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-      }
-   }
+        desc.rowStatus(n) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+    }
+  } else {
+    int n = base.number(SPxColId(id));
+
+    if (base.SPxLPBase<R>::upper(n) >= R(infinity)) {
+      if (base.SPxLPBase<R>::lower(n) <= R(-infinity))
+        desc.colStatus(n) = SPxBasisBase<R>::Desc::P_FREE;
+      else
+        desc.colStatus(n) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+    } else {
+      if (base.SPxLPBase<R>::lower(n) <= R(-infinity))
+        desc.colStatus(n) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      else if (base.SPxLPBase<R>::lower(n) >=
+               base.SPxLPBase<R>::upper(n) - base.epsilon())
+        desc.colStatus(n) = SPxBasisBase<R>::Desc::P_FIXED;
+      else if (colUp[n])
+        desc.colStatus(n) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+      else
+        desc.colStatus(n) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+    }
+  }
 }
 
 // ----------------------------------------------------------------
 template <class R>
-static void setDualStatus(
-   typename SPxBasisBase<R>::Desc& desc,
-   const SPxSolverBase<R>& base,
-   const SPxId& id)
-{
-   if(id.isSPxRowId())
-   {
-      int n = base.number(SPxRowId(id));
-      desc.rowStatus(n) = base.basis().dualRowStatus(n);
-   }
-   else
-   {
-      int n = base.number(SPxColId(id));
-      desc.colStatus(n) = base.basis().dualColStatus(n);
-   }
+static void setDualStatus(typename SPxBasisBase<R>::Desc &desc,
+                          const SPxSolverBase<R> &base, const SPxId &id) {
+  if (id.isSPxRowId()) {
+    int n = base.number(SPxRowId(id));
+    desc.rowStatus(n) = base.basis().dualRowStatus(n);
+  } else {
+    int n = base.number(SPxColId(id));
+    desc.colStatus(n) = base.basis().dualColStatus(n);
+  }
 }
 // ----------------------------------------------------------------
 
 /// Compare class for row weights, used for sorting.
-template <typename T>
-struct Compare
-{
+template <typename T> struct Compare {
 public:
-   /// constructor
-   Compare() : weight(0) {}
-   //   const SPxSolverBase* base;     ///< the solver
-   const T*      weight;   ///< the weights to compare
-
-   /// compares the weights
-   T operator()(int i1, int i2) const
-   {
-      return weight[i1] - weight[i2];
-   }
+  /// constructor
+  Compare() : weight(0) {}
+  //   const SPxSolverBase* base;     ///< the solver
+  const T *weight; ///< the weights to compare
+
+  /// compares the weights
+  T operator()(int i1, int i2) const { return weight[i1] - weight[i2]; }
 };
 
 // ----------------------------------------------------------------
@@ -168,536 +142,438 @@ public:
    of both.
 */
 template <class R>
-static void initPrefs(
-   DataArray < SPxId >&      pref,
-   const SPxSolverBase<R>&       base,
-   const Array<R>& rowWeight,
-   const Array<R>& colWeight)
-{
-   DataArray<int> row(base.nRows());
-   DataArray<int> col(base.nCols());
-   int i;
-   int j;
-   int k;
+static void initPrefs(DataArray<SPxId> &pref, const SPxSolverBase<R> &base,
+                      const Array<R> &rowWeight, const Array<R> &colWeight) {
+  DataArray<int> row(base.nRows());
+  DataArray<int> col(base.nCols());
+  int i;
+  int j;
+  int k;
 
-   Compare<R> compare;
-   //   compare.base = &base;
+  Compare<R> compare;
+  //   compare.base = &base;
 
-   for(i = 0; i < base.nRows(); ++i)
-      row[i] = i;
+  for (i = 0; i < base.nRows(); ++i)
+    row[i] = i;
 
-   compare.weight = rowWeight.get_const_ptr();
+  compare.weight = rowWeight.get_const_ptr();
 
-   SPxQuicksort(row.get_ptr(), row.size(), compare); // Sort rows
+  SPxQuicksort(row.get_ptr(), row.size(), compare); // Sort rows
 
-   for(i = 0; i < base.nCols(); ++i)
-      col[i] = i;
+  for (i = 0; i < base.nCols(); ++i)
+    col[i] = i;
 
-   compare.weight = colWeight.get_const_ptr();
+  compare.weight = colWeight.get_const_ptr();
 
-   SPxQuicksort(col.get_ptr(), col.size(), compare); // Sort column
+  SPxQuicksort(col.get_ptr(), col.size(), compare); // Sort column
 
-   i = 0;
-   j = 0;
-   k = 0;
+  i = 0;
+  j = 0;
+  k = 0;
 
-   while(k < pref.size())            // merge sort
-   {
-      if(rowWeight[row[i]] < colWeight[col[j]])
-      {
-         pref[k++] = base.rId(row[i++]);
+  while (k < pref.size()) // merge sort
+  {
+    if (rowWeight[row[i]] < colWeight[col[j]]) {
+      pref[k++] = base.rId(row[i++]);
 
-         if(i >= base.nRows())
-            while(k < pref.size())
-               pref[k++] = base.cId(col[j++]);
-      }
-      else
-      {
-         pref[k++] = base.cId(col[j++]);
+      if (i >= base.nRows())
+        while (k < pref.size())
+          pref[k++] = base.cId(col[j++]);
+    } else {
+      pref[k++] = base.cId(col[j++]);
 
-         if(j >= base.nCols())
-            while(k < pref.size())
-               pref[k++] = base.rId(row[i++]);
-      }
-   }
+      if (j >= base.nCols())
+        while (k < pref.size())
+          pref[k++] = base.rId(row[i++]);
+    }
+  }
 
-   assert(i == base.nRows());
-   assert(j == base.nCols());
+  assert(i == base.nRows());
+  assert(j == base.nCols());
 }
 
 // ----------------------------------------------------------------
-template <class R>
-void SPxWeightST<R>::generate(SPxSolverBase<R>& base)
-{
-   SPxId tmpId;
-
-   forbidden.reSize(base.dim());
-   rowWeight.reSize(base.nRows());
-   colWeight.reSize(base.nCols());
-   rowRight.reSize(base.nRows());
-   colUp.reSize(base.nCols());
-
-   if(base.rep() == SPxSolverBase<R>::COLUMN)
-   {
-      weight   = &colWeight;
-      coWeight = &rowWeight;
-   }
-   else
-   {
-      weight   = &rowWeight;
-      coWeight = &colWeight;
-   }
-
-   assert(weight->size()   == base.coDim());
-   assert(coWeight->size() == base.dim());
-
-   setupWeights(base);
-
-   typename SPxBasisBase<R>::Desc desc(base);
-   //   desc.reSize(base.nRows(), base.nCols());
-
-   DataArray < SPxId > pref(base.nRows() + base.nCols());
-   initPrefs(pref, base, rowWeight, colWeight);
-
-   int i;
-   int stepi;
-   int j;
-   int sel;
-
-   for(i = 0; i < base.dim(); ++i)
-      forbidden[i] = 0;
-
-   if(base.rep() == SPxSolverBase<R>::COLUMN)
-   {
-      // in COLUMN rep we scan from beginning to end
-      i      = 0;
-      stepi = 1;
-   }
-   else
-   {
-      // in ROW rep we scan from end to beginning
-      i      = pref.size() - 1;
-      stepi = -1;
-   }
-
-   int  dim = base.dim();
-   R maxEntry = 0;
-
-   for(; i >= 0 && i < pref.size(); i += stepi)
-   {
-      tmpId              = pref[i];
-      const SVectorBase<R>& vec = base.vector(tmpId);
-      sel                = -1;
-
-      // column or row singleton ?
-      if(vec.size() == 1)
-      {
-         int idx = vec.index(0);
-
-         if(forbidden[idx] < 2)
-         {
-            sel  = idx;
-            dim += (forbidden[idx] > 0) ? 1 : 0;
-         }
+template <class R> void SPxWeightST<R>::generate(SPxSolverBase<R> &base) {
+  SPxId tmpId;
+
+  forbidden.reSize(base.dim());
+  rowWeight.reSize(base.nRows());
+  colWeight.reSize(base.nCols());
+  rowRight.reSize(base.nRows());
+  colUp.reSize(base.nCols());
+
+  if (base.rep() == SPxSolverBase<R>::COLUMN) {
+    weight = &colWeight;
+    coWeight = &rowWeight;
+  } else {
+    weight = &rowWeight;
+    coWeight = &colWeight;
+  }
+
+  assert(weight->size() == base.coDim());
+  assert(coWeight->size() == base.dim());
+
+  setupWeights(base);
+
+  typename SPxBasisBase<R>::Desc desc(base);
+  //   desc.reSize(base.nRows(), base.nCols());
+
+  DataArray<SPxId> pref(base.nRows() + base.nCols());
+  initPrefs(pref, base, rowWeight, colWeight);
+
+  int i;
+  int stepi;
+  int j;
+  int sel;
+
+  for (i = 0; i < base.dim(); ++i)
+    forbidden[i] = 0;
+
+  if (base.rep() == SPxSolverBase<R>::COLUMN) {
+    // in COLUMN rep we scan from beginning to end
+    i = 0;
+    stepi = 1;
+  } else {
+    // in ROW rep we scan from end to beginning
+    i = pref.size() - 1;
+    stepi = -1;
+  }
+
+  int dim = base.dim();
+  R maxEntry = 0;
+
+  for (; i >= 0 && i < pref.size(); i += stepi) {
+    tmpId = pref[i];
+    const SVectorBase<R> &vec = base.vector(tmpId);
+    sel = -1;
+
+    // column or row singleton ?
+    if (vec.size() == 1) {
+      int idx = vec.index(0);
+
+      if (forbidden[idx] < 2) {
+        sel = idx;
+        dim += (forbidden[idx] > 0) ? 1 : 0;
       }
-      else
-      {
-         maxEntry = vec.maxAbs();
-
-         // initialize the nonzero counter
-         int minRowEntries = base.nRows();
-
-         // find a stable index with a sparse row/column
-         for(j = vec.size(); --j >= 0;)
-         {
-            R x = vec.value(j);
-            int  k = vec.index(j);
-            int  nRowEntries = base.coVector(k).size();
-
-            if(!forbidden[k] && (spxAbs(x) > STABLE * maxEntry) && (nRowEntries < minRowEntries))
-            {
-               minRowEntries = nRowEntries;
-               sel  = k;
-            }
-         }
+    } else {
+      maxEntry = vec.maxAbs();
+
+      // initialize the nonzero counter
+      int minRowEntries = base.nRows();
+
+      // find a stable index with a sparse row/column
+      for (j = vec.size(); --j >= 0;) {
+        R x = vec.value(j);
+        int k = vec.index(j);
+        int nRowEntries = base.coVector(k).size();
+
+        if (!forbidden[k] && (spxAbs(x) > STABLE * maxEntry) &&
+            (nRowEntries < minRowEntries)) {
+          minRowEntries = nRowEntries;
+          sel = k;
+        }
       }
+    }
 
-      // we found a valid index
-      if(sel >= 0)
-      {
-         MSG_DEBUG(
-
-            if(pref[i].type() == SPxId::ROW_ID)
-            std::cout << "DWEIST01 r" << base.number(pref[i]);
-            else
-               std::cout << "DWEIST02 c" << base.number(pref[i]);
-            )
+    // we found a valid index
+    if (sel >= 0) {
+      MSG_DEBUG(
 
-               forbidden[sel] = 2;
+          if (pref[i].type() == SPxId::ROW_ID) std::cout
+              << "DWEIST01 r" << base.number(pref[i]);
+          else std::cout << "DWEIST02 c" << base.number(pref[i]);)
 
-         // put current column/row into basis
-         if(base.rep() == SPxSolverBase<R>::COLUMN)
-            setDualStatus(desc, base, pref[i]);
-         else
-            setPrimalStatus(desc, base, pref[i]);
+      forbidden[sel] = 2;
 
-         for(j = vec.size(); --j >= 0;)
-         {
-            R x = vec.value(j);
-            int  k = vec.index(j);
-
-            if(!forbidden[k] && (x > EPS * maxEntry || -x > EPS * maxEntry))
-            {
-               forbidden[k] = 1;
-               --dim;
-            }
-         }
-
-         if(--dim == 0)
-         {
-            //@ for(++i; i < pref.size(); ++i)
-            if(base.rep() == SPxSolverBase<R>::COLUMN)
-            {
-               // set all remaining indeces to nonbasic status
-               for(i += stepi; i >= 0 && i < pref.size(); i += stepi)
-                  setPrimalStatus(desc, base, pref[i]);
-
-               // fill up the basis wherever linear independence is assured
-               for(i = forbidden.size(); --i >= 0;)
-               {
-                  if(forbidden[i] < 2)
-                     setDualStatus(desc, base, base.coId(i));
-               }
-            }
-            else
-            {
-               for(i += stepi; i >= 0 && i < pref.size(); i += stepi)
-                  setDualStatus(desc, base, pref[i]);
-
-               for(i = forbidden.size(); --i >= 0;)
-               {
-                  if(forbidden[i] < 2)
-                     setPrimalStatus(desc, base, base.coId(i));
-               }
-            }
-
-            break;
-         }
-      }
-      // sel == -1
-      else if(base.rep() == SPxSolverBase<R>::COLUMN)
-         setPrimalStatus(desc, base, pref[i]);
+      // put current column/row into basis
+      if (base.rep() == SPxSolverBase<R>::COLUMN)
+        setDualStatus(desc, base, pref[i]);
       else
-         setDualStatus(desc, base, pref[i]);
-
-#ifndef NDEBUG
-      {
-         int n, m;
+        setPrimalStatus(desc, base, pref[i]);
 
-         for(n = 0, m = forbidden.size(); n < forbidden.size(); ++n)
-            m -= (forbidden[n] != 0) ? 1 : 0;
+      for (j = vec.size(); --j >= 0;) {
+        R x = vec.value(j);
+        int k = vec.index(j);
 
-         assert(m == dim);
+        if (!forbidden[k] && (x > EPS * maxEntry || -x > EPS * maxEntry)) {
+          forbidden[k] = 1;
+          --dim;
+        }
       }
-#endif  // NDEBUG
-   }
 
-   assert(dim == 0);
+      if (--dim == 0) {
+        //@ for(++i; i < pref.size(); ++i)
+        if (base.rep() == SPxSolverBase<R>::COLUMN) {
+          // set all remaining indeces to nonbasic status
+          for (i += stepi; i >= 0 && i < pref.size(); i += stepi)
+            setPrimalStatus(desc, base, pref[i]);
 
-   base.loadBasis(desc);
-#ifdef  TEST
-   base.init();
+          // fill up the basis wherever linear independence is assured
+          for (i = forbidden.size(); --i >= 0;) {
+            if (forbidden[i] < 2)
+              setDualStatus(desc, base, base.coId(i));
+          }
+        } else {
+          for (i += stepi; i >= 0 && i < pref.size(); i += stepi)
+            setDualStatus(desc, base, pref[i]);
 
-   int changed = 0;
-   const VectorBase<R>& pvec = base.pVec();
+          for (i = forbidden.size(); --i >= 0;) {
+            if (forbidden[i] < 2)
+              setPrimalStatus(desc, base, base.coId(i));
+          }
+        }
 
-   for(i = pvec.dim() - 1; i >= 0; --i)
-   {
-      if(desc.colStatus(i) == SPxBasisBase<R>::Desc::P_ON_UPPER
-            && base.lower(i) > R(-infinity) && pvec[i] > base.maxObj(i))
-      {
-         changed = 1;
-         desc.colStatus(i) = SPxBasisBase<R>::Desc::P_ON_LOWER;
-      }
-      else if(desc.colStatus(i) == SPxBasisBase<R>::Desc::P_ON_LOWER
-              && base.upper(i) < R(infinity) && pvec[i] < base.maxObj(i))
-      {
-         changed = 1;
-         desc.colStatus(i) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+        break;
       }
-   }
+    }
+    // sel == -1
+    else if (base.rep() == SPxSolverBase<R>::COLUMN)
+      setPrimalStatus(desc, base, pref[i]);
+    else
+      setDualStatus(desc, base, pref[i]);
 
-   if(changed)
-   {
-      std::cout << "changed basis\n";
-      base.loadBasis(desc);
-   }
-   else
-      std::cout << "nothing changed\n";
-
-#endif  // TEST
+#ifndef NDEBUG
+    {
+      int n, m;
+
+      for (n = 0, m = forbidden.size(); n < forbidden.size(); ++n)
+        m -= (forbidden[n] != 0) ? 1 : 0;
+
+      assert(m == dim);
+    }
+#endif // NDEBUG
+  }
+
+  assert(dim == 0);
+
+  base.loadBasis(desc);
+#ifdef TEST
+  base.init();
+
+  int changed = 0;
+  const VectorBase<R> &pvec = base.pVec();
+
+  for (i = pvec.dim() - 1; i >= 0; --i) {
+    if (desc.colStatus(i) == SPxBasisBase<R>::Desc::P_ON_UPPER &&
+        base.lower(i) > R(-infinity) && pvec[i] > base.maxObj(i)) {
+      changed = 1;
+      desc.colStatus(i) = SPxBasisBase<R>::Desc::P_ON_LOWER;
+    } else if (desc.colStatus(i) == SPxBasisBase<R>::Desc::P_ON_LOWER &&
+               base.upper(i) < R(infinity) && pvec[i] < base.maxObj(i)) {
+      changed = 1;
+      desc.colStatus(i) = SPxBasisBase<R>::Desc::P_ON_UPPER;
+    }
+  }
+
+  if (changed) {
+    std::cout << "changed basis\n";
+    base.loadBasis(desc);
+  } else
+    std::cout << "nothing changed\n";
+
+#endif // TEST
 }
 
 // ----------------------------------------------------------------
 
 /* Computation of Weights
  */
-template <class R>
-void SPxWeightST<R>::setupWeights(SPxSolverBase<R>& base)
-{
-   const VectorBase<R>& obj  = base.maxObj();
-   const VectorBase<R>& low  = base.lower();
-   const VectorBase<R>& up   = base.upper();
-   const VectorBase<R>& rhs  = base.rhs();
-   const VectorBase<R>& lhs  = base.lhs();
-   int    i;
-
-   R eps    = base.epsilon();
-   R maxabs = 1.0;
-
-   // find absolut biggest entry in bounds and left-/right hand side
-   for(i = 0; i < base.nCols(); i++)
-   {
-      if((up[i] < R(infinity)) && (spxAbs(up[i]) > maxabs))
-         maxabs = spxAbs(up[i]);
-
-      if((low[i] > R(-infinity)) && (spxAbs(low[i]) > maxabs))
-         maxabs = spxAbs(low[i]);
-   }
-
-   for(i = 0; i < base.nRows(); i++)
-   {
-      if((rhs[i] < R(infinity)) && (spxAbs(rhs[i]) > maxabs))
-         maxabs = spxAbs(rhs[i]);
-
-      if((lhs[i] > R(-infinity)) && (spxAbs(lhs[i]) > maxabs))
-         maxabs = spxAbs(lhs[i]);
-   }
-
-   /**@todo The comments are wrong. The first is for dual simplex and
-    *       the secound for primal one. Is anything else wrong?
-    *       Also the values are nearly the same for both cases.
-    *       Should this be ? Changed the values for
-    *       r_fixed to 0 because of maros-r7. It is not clear why
-    *       this makes a difference because all constraints in that
-    *       instance are of equality type.
-    *       Why is rowRight sometimes not set?
-    */
-   if(base.rep() * base.type() > 0)             // primal simplex
-   {
-      const R ax            = 1e-3 / obj.maxAbs();
-      const R bx            = 1.0 / maxabs;
-      const R nne           = ax / base.nRows();  // 1e-4 * ax;
-      const R c_fixed       = 1e+5;
-      const R r_fixed       = 0; // TK20010103: was 1e+4 (maros-r7)
-      const R c_dbl_bounded = 1e+1;
-      const R r_dbl_bounded = 0;
-      const R c_bounded     = 1e+1;
-      const R r_bounded     = 0;
-      const R c_free        = -1e+4;
-      const R r_free        = -1e+5;
-
-      for(i = base.nCols() - 1; i >= 0; i--)
-      {
-         R n = nne * (base.colVector(i).size() - 1); // very small value that is zero for col singletons
-         R x = ax * obj[i]; // this is at most 1e-3, probably a lot smaller
-         R u = bx * up [i]; // this is at most 1, probably a lot smaller
-         R l = bx * low[i]; // this is at most 1, probably a lot smaller
-
-         if(up[i] < R(infinity))
-         {
-            if(spxAbs(low[i] - up[i]) < eps)
-               colWeight[i] = c_fixed + n + spxAbs(x);
-            else if(low[i] > R(-infinity))
-            {
-               colWeight[i] = c_dbl_bounded + l - u + n;
-
-               l = spxAbs(l);
-               u = spxAbs(u);
-
-               if(u < l)
-               {
-                  colUp[i]      = true;
-                  colWeight[i] += x;
-               }
-               else
-               {
-                  colUp[i]      = false;
-                  colWeight[i] -= x;
-               }
-            }
-            else
-            {
-               colWeight[i] = c_bounded - u + x + n;
-               colUp[i]     = true;
-            }
-         }
-         else
-         {
-            if(low[i] > R(-infinity))
-            {
-               colWeight[i] = c_bounded + l + n - x;
-               colUp[i]     = false;
-            }
-            else
-            {
-               colWeight[i] = c_free + n - spxAbs(x);
-            }
-         }
+template <class R> void SPxWeightST<R>::setupWeights(SPxSolverBase<R> &base) {
+  const VectorBase<R> &obj = base.maxObj();
+  const VectorBase<R> &low = base.lower();
+  const VectorBase<R> &up = base.upper();
+  const VectorBase<R> &rhs = base.rhs();
+  const VectorBase<R> &lhs = base.lhs();
+  int i;
+
+  R eps = base.epsilon();
+  R maxabs = 1.0;
+
+  // find absolut biggest entry in bounds and left-/right hand side
+  for (i = 0; i < base.nCols(); i++) {
+    if ((up[i] < R(infinity)) && (spxAbs(up[i]) > maxabs))
+      maxabs = spxAbs(up[i]);
+
+    if ((low[i] > R(-infinity)) && (spxAbs(low[i]) > maxabs))
+      maxabs = spxAbs(low[i]);
+  }
+
+  for (i = 0; i < base.nRows(); i++) {
+    if ((rhs[i] < R(infinity)) && (spxAbs(rhs[i]) > maxabs))
+      maxabs = spxAbs(rhs[i]);
+
+    if ((lhs[i] > R(-infinity)) && (spxAbs(lhs[i]) > maxabs))
+      maxabs = spxAbs(lhs[i]);
+  }
+
+  /**@todo The comments are wrong. The first is for dual simplex and
+   *       the secound for primal one. Is anything else wrong?
+   *       Also the values are nearly the same for both cases.
+   *       Should this be ? Changed the values for
+   *       r_fixed to 0 because of maros-r7. It is not clear why
+   *       this makes a difference because all constraints in that
+   *       instance are of equality type.
+   *       Why is rowRight sometimes not set?
+   */
+  if (static_cast<int>(base.rep()) * base.type() > 0) // primal simplex
+  {
+    const R ax = 1e-3 / obj.maxAbs();
+    const R bx = 1.0 / maxabs;
+    const R nne = ax / base.nRows(); // 1e-4 * ax;
+    const R c_fixed = 1e+5;
+    const R r_fixed = 0; // TK20010103: was 1e+4 (maros-r7)
+    const R c_dbl_bounded = 1e+1;
+    const R r_dbl_bounded = 0;
+    const R c_bounded = 1e+1;
+    const R r_bounded = 0;
+    const R c_free = -1e+4;
+    const R r_free = -1e+5;
+
+    for (i = base.nCols() - 1; i >= 0; i--) {
+      R n = nne * (base.colVector(i).size() -
+                   1);   // very small value that is zero for col singletons
+      R x = ax * obj[i]; // this is at most 1e-3, probably a lot smaller
+      R u = bx * up[i];  // this is at most 1, probably a lot smaller
+      R l = bx * low[i]; // this is at most 1, probably a lot smaller
+
+      if (up[i] < R(infinity)) {
+        if (spxAbs(low[i] - up[i]) < eps)
+          colWeight[i] = c_fixed + n + spxAbs(x);
+        else if (low[i] > R(-infinity)) {
+          colWeight[i] = c_dbl_bounded + l - u + n;
+
+          l = spxAbs(l);
+          u = spxAbs(u);
+
+          if (u < l) {
+            colUp[i] = true;
+            colWeight[i] += x;
+          } else {
+            colUp[i] = false;
+            colWeight[i] -= x;
+          }
+        } else {
+          colWeight[i] = c_bounded - u + x + n;
+          colUp[i] = true;
+        }
+      } else {
+        if (low[i] > R(-infinity)) {
+          colWeight[i] = c_bounded + l + n - x;
+          colUp[i] = false;
+        } else {
+          colWeight[i] = c_free + n - spxAbs(x);
+        }
       }
-
-      for(i = base.nRows() - 1; i >= 0; i--)
-      {
-         if(rhs[i] < R(infinity))
-         {
-            if(spxAbs(lhs[i] - rhs[i]) < eps)
-            {
-               rowWeight[i] = r_fixed;
-            }
-            else if(lhs[i] > R(-infinity))
-            {
-               R u = bx * rhs[i];
-               R l = bx * lhs[i];
-
-               rowWeight[i] = r_dbl_bounded + l - u;
-               rowRight[i]  = spxAbs(u) < spxAbs(l);
-            }
-            else
-            {
-               rowWeight[i] = r_bounded - bx * rhs[i];
-               rowRight[i]  = true;
-            }
-         }
-         else
-         {
-            if(lhs[i] > R(-infinity))
-            {
-               rowWeight[i] = r_bounded + bx * lhs[i];
-               rowRight[i]  = false;
-            }
-            else
-            {
-               rowWeight[i] = r_free;
-            }
-         }
+    }
+
+    for (i = base.nRows() - 1; i >= 0; i--) {
+      if (rhs[i] < R(infinity)) {
+        if (spxAbs(lhs[i] - rhs[i]) < eps) {
+          rowWeight[i] = r_fixed;
+        } else if (lhs[i] > R(-infinity)) {
+          R u = bx * rhs[i];
+          R l = bx * lhs[i];
+
+          rowWeight[i] = r_dbl_bounded + l - u;
+          rowRight[i] = spxAbs(u) < spxAbs(l);
+        } else {
+          rowWeight[i] = r_bounded - bx * rhs[i];
+          rowRight[i] = true;
+        }
+      } else {
+        if (lhs[i] > R(-infinity)) {
+          rowWeight[i] = r_bounded + bx * lhs[i];
+          rowRight[i] = false;
+        } else {
+          rowWeight[i] = r_free;
+        }
       }
-   }
-   else
-   {
-      assert(base.rep() * base.type() < 0);           // dual simplex
-
-      const R ax            = 1.0  / obj.maxAbs();
-      const R bx            = 1e-2 / maxabs;
-      const R nne           = 1e-4 * bx;
-      const R c_fixed       = 1e+5;
-      const R r_fixed       = 1e+4;
-      const R c_dbl_bounded = 1;
-      const R r_dbl_bounded = 0;
-      const R c_bounded     = 0;
-      const R r_bounded     = 0;
-      const R c_free        = -1e+4;
-      const R r_free        = -1e+5;
-
-      for(i = base.nCols() - 1; i >= 0; i--)
-      {
-         R n = nne * (base.colVector(i).size() - 1);
-         R x = ax  * obj[i];
-         R u = bx  * up [i];
-         R l = bx  * low[i];
-
-         if(up[i] < R(infinity))
-         {
-            if(spxAbs(low[i] - up[i]) < eps)
-               colWeight[i] = c_fixed + n + spxAbs(x);
-            else if(low[i] > R(-infinity))
-            {
-               if(x > 0)
-               {
-                  colWeight[i] = c_dbl_bounded + x - u + n;
-                  colUp[i]     = true;
-               }
-               else
-               {
-                  colWeight[i] = c_dbl_bounded - x + l + n;
-                  colUp[i]     = false;
-               }
-            }
-            else
-            {
-               colWeight[i] = c_bounded - u + x + n;
-               colUp[i]     = true;
-            }
-         }
-         else
-         {
-            if(low[i] > R(-infinity))
-            {
-               colWeight[i] = c_bounded - x + l + n;
-               colUp[i]     = false;
-            }
-            else
-               colWeight[i] = c_free + n - spxAbs(x);
-         }
+    }
+  } else {
+    assert(static_cast<int>(base.rep()) * base.type() < 0); // dual simplex
+
+    const R ax = 1.0 / obj.maxAbs();
+    const R bx = 1e-2 / maxabs;
+    const R nne = 1e-4 * bx;
+    const R c_fixed = 1e+5;
+    const R r_fixed = 1e+4;
+    const R c_dbl_bounded = 1;
+    const R r_dbl_bounded = 0;
+    const R c_bounded = 0;
+    const R r_bounded = 0;
+    const R c_free = -1e+4;
+    const R r_free = -1e+5;
+
+    for (i = base.nCols() - 1; i >= 0; i--) {
+      R n = nne * (base.colVector(i).size() - 1);
+      R x = ax * obj[i];
+      R u = bx * up[i];
+      R l = bx * low[i];
+
+      if (up[i] < R(infinity)) {
+        if (spxAbs(low[i] - up[i]) < eps)
+          colWeight[i] = c_fixed + n + spxAbs(x);
+        else if (low[i] > R(-infinity)) {
+          if (x > 0) {
+            colWeight[i] = c_dbl_bounded + x - u + n;
+            colUp[i] = true;
+          } else {
+            colWeight[i] = c_dbl_bounded - x + l + n;
+            colUp[i] = false;
+          }
+        } else {
+          colWeight[i] = c_bounded - u + x + n;
+          colUp[i] = true;
+        }
+      } else {
+        if (low[i] > R(-infinity)) {
+          colWeight[i] = c_bounded - x + l + n;
+          colUp[i] = false;
+        } else
+          colWeight[i] = c_free + n - spxAbs(x);
       }
-
-      for(i = base.nRows() - 1; i >= 0; i--)
-      {
-         const R len1 = 1; // (base.rowVector(i).length() + base.epsilon());
-         R n    = 0;  // nne * (base.rowVector(i).size() - 1);
-         R u    = bx * len1 * rhs[i];
-         R l    = bx * len1 * lhs[i];
-         R x    = ax * len1 * (obj * base.rowVector(i));
-
-         if(rhs[i] < R(infinity))
-         {
-            if(spxAbs(lhs[i] - rhs[i]) < eps)
-               rowWeight[i] = r_fixed + n + spxAbs(x);
-            else if(lhs[i] > R(-infinity))
-            {
-               if(x > 0)
-               {
-                  rowWeight[i] = r_dbl_bounded + x - u + n;
-                  rowRight[i]  = true;
-               }
-               else
-               {
-                  rowWeight[i] = r_dbl_bounded - x + l + n;
-                  rowRight[i]  = false;
-               }
-            }
-            else
-            {
-               rowWeight[i] = r_bounded - u + n + x;
-               rowRight[i]  = true;
-            }
-         }
-         else
-         {
-            if(lhs[i] > R(-infinity))
-            {
-               rowWeight[i] = r_bounded + l + n - x;
-               rowRight[i]  = false;
-            }
-            else
-            {
-               rowWeight[i] = r_free + n - spxAbs(x);
-            }
-         }
+    }
+
+    for (i = base.nRows() - 1; i >= 0; i--) {
+      const R len1 = 1; // (base.rowVector(i).length() + base.epsilon());
+      R n = 0;          // nne * (base.rowVector(i).size() - 1);
+      R u = bx * len1 * rhs[i];
+      R l = bx * len1 * lhs[i];
+      R x = ax * len1 * (obj * base.rowVector(i));
+
+      if (rhs[i] < R(infinity)) {
+        if (spxAbs(lhs[i] - rhs[i]) < eps)
+          rowWeight[i] = r_fixed + n + spxAbs(x);
+        else if (lhs[i] > R(-infinity)) {
+          if (x > 0) {
+            rowWeight[i] = r_dbl_bounded + x - u + n;
+            rowRight[i] = true;
+          } else {
+            rowWeight[i] = r_dbl_bounded - x + l + n;
+            rowRight[i] = false;
+          }
+        } else {
+          rowWeight[i] = r_bounded - u + n + x;
+          rowRight[i] = true;
+        }
+      } else {
+        if (lhs[i] > R(-infinity)) {
+          rowWeight[i] = r_bounded + l + n - x;
+          rowRight[i] = false;
+        } else {
+          rowWeight[i] = r_free + n - spxAbs(x);
+        }
       }
-   }
-
-   MSG_DEBUG(
-   {
-      for(i = 0; i < base.nCols(); i++)
-         std::cout << "C i= " << i
-                   << " up= " << colUp[i]
-                   << " w= " << colWeight[i]
-                   << std::endl;
-      for(i = 0; i < base.nRows(); i++)
-         std::cout << "R i= " << i
-                   << " rr= " << rowRight[i]
-                   << " w= " << rowWeight[i]
-                   << std::endl;
-   })
+    }
+  }
+
+  MSG_DEBUG({
+    for (i = 0; i < base.nCols(); i++)
+      std::cout << "C i= " << i << " up= " << colUp[i] << " w= " << colWeight[i]
+                << std::endl;
+    for (i = 0; i < base.nRows(); i++)
+      std::cout << "R i= " << i << " rr= " << rowRight[i]
+                << " w= " << rowWeight[i] << std::endl;
+  })
 }
 } // namespace soplex
diff --git a/src/soplex/spxwritestate.hpp b/src/soplex/spxwritestate.hpp
index 7a0c1ea..86d536e 100644
--- a/src/soplex/spxwritestate.hpp
+++ b/src/soplex/spxwritestate.hpp
@@ -21,95 +21,94 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
-#include <iostream>
 #include <fstream>
-#include <string.h>
+#include <iostream>
 #include <sstream>
+#include <string.h>
 
+#include "soplex/slinsolver.h"
+#include "soplex/slufactor.h"
 #include "soplex/spxdefines.h"
-#include "soplex/spxsolver.h"
 #include "soplex/spxpricer.h"
 #include "soplex/spxratiotester.h"
+#include "soplex/spxsolver.h"
 #include "soplex/spxstarter.h"
-#include "soplex/slinsolver.h"
-#include "soplex/slufactor.h"
 
-namespace soplex
-{
+namespace soplex {
 template <class R>
-bool SPxSolverBase<R>::writeState(
-   const char*    filename,
-   const NameSet* rowNames,
-   const NameSet* colNames,
-   const bool cpxFormat
-) const
-{
-
-   std::string ofname;
-   std::ofstream ofs;
-
-   // write parameter settings
-   ofname = std::string(filename) + ".set";
-   ofs.open(ofname.c_str());
-
-   if(!ofs)
-      return false;
-
-   ofs << "# SoPlex version " << SOPLEX_VERSION / 100
-       << "." << (SOPLEX_VERSION / 10) % 10
-       << "." << SOPLEX_VERSION % 10
-       << "." << SOPLEX_SUBVERSION << std::endl << std::endl;
-   ofs << "# run SoPlex as follows:" << std::endl;
-   ofs << "# bin/soplex --loadset=spxcheck.set --readbas=spxcheck.bas spxcheck.mps\n" << std::endl;
-   ofs << "int:representation = " << (rep() == SPxSolverBase<R>::COLUMN ? "1" : "2") << std::endl;
-   ofs << "int:factor_update_max = " << basis().getMaxUpdates() << std::endl;
-   ofs << "int:pricer = ";
-
-   if(!strcmp(pricer()->getName(), "Auto"))
-      ofs << " 0" << std::endl;
-   else if(!strcmp(pricer()->getName(), "Dantzig"))
-      ofs << "1" << std::endl;
-   else if(!strcmp(pricer()->getName(), "ParMult"))
-      ofs << "2" << std::endl;
-   else if(!strcmp(pricer()->getName(), "Devex"))
-      ofs << "3" << std::endl;
-   else if(!strcmp(pricer()->getName(), "Steep"))
-      ofs << "4" << std::endl;
-   else if(!strcmp(pricer()->getName(), "SteepEx"))
-      ofs << "5" << std::endl;
-
-   ofs << "int:ratiotester = ";
-
-   if(!strcmp(ratiotester()->getName(), "Default"))
-      ofs << "0" << std::endl;
-   else if(!strcmp(ratiotester()->getName(), "Harris"))
-      ofs << "1" << std::endl;
-   else if(!strcmp(ratiotester()->getName(), "Fast"))
-      ofs << "2" << std::endl;
-   else if(!strcmp(ratiotester()->getName(), "Bound Flipping"))
-      ofs << "3" << std::endl;
-
-   ofs << "real:feastol = " << feastol() << std::endl;
-   ofs << "real:opttol = " << opttol() << std::endl;
-   ofs << "real:epsilon_zero = " << epsilon() << std::endl;
-   ofs << "real:infty = " << infinity << std::endl;
-   ofs << "uint:random_seed = " << random.getSeed() << std::endl;
-   ofs.close();
-
-   // write LP
-   ofname = std::string(filename) + ".mps";
-   ofs.open(ofname.c_str());
-
-   if(!ofs)
-      return false;
-
-   this->writeMPS(ofs, rowNames, colNames, NULL);
-   ofs.close();
-
-   // write basis
-   ofname = std::string(filename) + ".bas";
-   return writeBasisFile(ofname.c_str(), rowNames, colNames, cpxFormat);
+bool SPxSolverBase<R>::writeState(const char *filename, const NameSet *rowNames,
+                                  const NameSet *colNames,
+                                  const bool cpxFormat) const {
+
+  std::string ofname;
+  std::ofstream ofs;
+
+  // write parameter settings
+  ofname = std::string(filename) + ".set";
+  ofs.open(ofname.c_str());
+
+  if (!ofs)
+    return false;
+
+  ofs << "# SoPlex version " << SOPLEX_VERSION / 100 << "."
+      << (SOPLEX_VERSION / 10) % 10 << "." << SOPLEX_VERSION % 10 << "."
+      << SOPLEX_SUBVERSION << std::endl
+      << std::endl;
+  ofs << "# run SoPlex as follows:" << std::endl;
+  ofs << "# bin/soplex --loadset=spxcheck.set --readbas=spxcheck.bas "
+         "spxcheck.mps\n"
+      << std::endl;
+  ofs << "int:representation = "
+      << (rep() == SPxSolverBase<R>::COLUMN ? "1" : "2") << std::endl;
+  ofs << "int:factor_update_max = " << basis().getMaxUpdates() << std::endl;
+  ofs << "int:pricer = ";
+
+  if (!strcmp(pricer()->getName(), "Auto"))
+    ofs << " 0" << std::endl;
+  else if (!strcmp(pricer()->getName(), "Dantzig"))
+    ofs << "1" << std::endl;
+  else if (!strcmp(pricer()->getName(), "ParMult"))
+    ofs << "2" << std::endl;
+  else if (!strcmp(pricer()->getName(), "Devex"))
+    ofs << "3" << std::endl;
+  else if (!strcmp(pricer()->getName(), "Steep"))
+    ofs << "4" << std::endl;
+  else if (!strcmp(pricer()->getName(), "SteepEx"))
+    ofs << "5" << std::endl;
+
+  ofs << "int:ratiotester = ";
+
+  if (!strcmp(ratiotester()->getName(), "Default"))
+    ofs << "0" << std::endl;
+  else if (!strcmp(ratiotester()->getName(), "Harris"))
+    ofs << "1" << std::endl;
+  else if (!strcmp(ratiotester()->getName(), "Fast"))
+    ofs << "2" << std::endl;
+  else if (!strcmp(ratiotester()->getName(), "Bound Flipping"))
+    ofs << "3" << std::endl;
+
+  ofs << "real:feastol = " << feastol() << std::endl;
+  ofs << "real:opttol = " << opttol() << std::endl;
+  ofs << "real:epsilon_zero = " << epsilon() << std::endl;
+  ofs << "real:infty = " << infinity << std::endl;
+  ofs << "uint:random_seed = " << random.getSeed() << std::endl;
+  ofs.close();
+
+  // write LP
+  ofname = std::string(filename) + ".mps";
+  ofs.open(ofname.c_str());
+
+  if (!ofs)
+    return false;
+
+  this->writeMPS(ofs, rowNames, colNames, NULL);
+  ofs.close();
+
+  // write basis
+  ofname = std::string(filename) + ".bas";
+  return writeBasisFile(ofname.c_str(), rowNames, colNames, cpxFormat);
 }
 
 } // namespace soplex
diff --git a/src/soplex/ssvectorbase.h b/src/soplex/ssvectorbase.h
index 08418bb..470be9e 100644
--- a/src/soplex/ssvectorbase.h
+++ b/src/soplex/ssvectorbase.h
@@ -22,7 +22,6 @@
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
-
 /**@file  ssvectorbase.h
  * @brief Semi sparse vector.
  */
@@ -31,892 +30,758 @@
 
 #include <assert.h>
 
-#include "soplex/spxdefines.h"
-#include "soplex/vectorbase.h"
 #include "soplex/idxset.h"
 #include "soplex/spxalloc.h"
-#include "soplex/timer.h"
+#include "soplex/spxdefines.h"
 #include "soplex/stablesum.h"
+#include "soplex/timer.h"
+#include "soplex/vectorbase.h"
 
-namespace soplex
-{
-template < class R > class SVectorBase;
-template < class R > class SVSetBase;
+namespace soplex {
+template <class R> class SVectorBase;
+template <class R> class SVSetBase;
 
 /**@brief   Semi sparse vector.
  * @ingroup Algebra
  *
- *  This class implements semi-sparse vectors.  Such are #VectorBase%s where the indices of its nonzero elements can be
- *  stored in an extra IdxSet.  Only elements with absolute value > #epsilon are considered to be nonzero.  Since really
- *  storing the nonzeros is not always convenient, an SSVectorBase provides two different stati: setup and not setup.
- *  An SSVectorBase being setup means that the nonzero indices are available, otherwise an SSVectorBase is just an
- *  ordinary VectorBase with an empty IdxSet.  Note that due to arithmetic operation, zeros can slip in, i.e., it is
- *  only guaranteed that at least every non-zero is in the IdxSet.
+ *  This class implements semi-sparse vectors.  Such are #VectorBase%s where the
+ * indices of its nonzero elements can be stored in an extra IdxSet.  Only
+ * elements with absolute value > #epsilon are considered to be nonzero.  Since
+ * really storing the nonzeros is not always convenient, an SSVectorBase
+ * provides two different stati: setup and not setup. An SSVectorBase being
+ * setup means that the nonzero indices are available, otherwise an SSVectorBase
+ * is just an ordinary VectorBase with an empty IdxSet.  Note that due to
+ * arithmetic operation, zeros can slip in, i.e., it is only guaranteed that at
+ * least every non-zero is in the IdxSet.
  */
-template < class R >
-class SSVectorBase : public VectorBase<R>, protected IdxSet
-{
+template <class R> class SSVectorBase : public VectorBase<R>, protected IdxSet {
 private:
+  friend class VectorBase<R>;
+  template <class S> friend class DSVectorBase;
 
-   friend class VectorBase<R>;
-   template < class S > friend class DSVectorBase;
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Data */
+  ///@{
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Data */
-   ///@{
+  /// Is the SSVectorBase set up?
+  bool setupStatus;
 
-   /// Is the SSVectorBase set up?
-   bool setupStatus;
+  /// A value x with |x| < epsilon is considered zero.
+  R epsilon;
 
-   /// A value x with |x| < epsilon is considered zero.
-   R epsilon;
+  /// Allocates enough space to accommodate \p newmax values.
+  void setMax(int newmax) {
+    assert(idx != 0);
+    assert(newmax != 0);
+    assert(newmax >= IdxSet::size());
 
-   /// Allocates enough space to accommodate \p newmax values.
-   void setMax(int newmax)
-   {
-      assert(idx != 0);
-      assert(newmax != 0);
-      assert(newmax >= IdxSet::size());
+    len = newmax;
+    spx_realloc(idx, len);
+  }
 
-      len = newmax;
-      spx_realloc(idx, len);
-   }
-
-   ///@}
+  ///@}
 
 public:
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Status of an SSVectorBase
+   *
+   *  An SSVectorBase can be set up or not. In case it is set up, its IdxSet
+   * correctly contains all indices of nonzero elements of the SSVectorBase.
+   * Otherwise, it does not contain any useful data. Whether or not an
+   * SSVectorBase is setup can be determined with the method \ref
+   * soplex::SSVectorBase::isSetup() "isSetup()".
+   *
+   *  There are three methods for directly affecting the setup status of an
+   * SSVectorBase:
+   *
+   *  - unSetup():    This method sets the status to ``not setup''.
+   *
+   *  - setup():      This method initializes the IdxSet to the SSVectorBase's
+   * nonzero indices and sets the status to
+   *                  ``setup''.
+   *
+   *  - forceSetup(): This method sets the status to ``setup'' without verifying
+   * that the IdxSet correctly contains all nonzero indices. It may be used when
+   * the nonzero indices have been computed externally.
+   */
+  ///@{
+
+  /// Only used in slufactor.hpp.
+  R *get_ptr() { return VectorBase<R>::get_ptr(); }
+  /// Returns the non-zero epsilon used.
+  R getEpsilon() const { return epsilon; }
+
+  /// Changes the non-zero epsilon, invalidating the setup. */
+  void setEpsilon(R eps) {
+    if (eps != epsilon) {
+      epsilon = eps;
+      setupStatus = false;
+    }
+  }
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Status of an SSVectorBase
-    *
-    *  An SSVectorBase can be set up or not. In case it is set up, its IdxSet correctly contains all indices of nonzero
-    *  elements of the SSVectorBase.  Otherwise, it does not contain any useful data. Whether or not an SSVectorBase is
-    *  setup can be determined with the method \ref soplex::SSVectorBase::isSetup() "isSetup()".
-    *
-    *  There are three methods for directly affecting the setup status of an SSVectorBase:
-    *
-    *  - unSetup():    This method sets the status to ``not setup''.
-    *
-    *  - setup():      This method initializes the IdxSet to the SSVectorBase's nonzero indices and sets the status to
-    *                  ``setup''.
-    *
-    *  - forceSetup(): This method sets the status to ``setup'' without verifying that the IdxSet correctly contains all
-    *                  nonzero indices. It may be used when the nonzero indices have been computed externally.
-    */
-   ///@{
-
-   /// Only used in slufactor.hpp.
-   R* get_ptr()
-   {
-      return VectorBase<R>::get_ptr();
-   }
-   /// Returns the non-zero epsilon used.
-   R getEpsilon() const
-   {
-      return epsilon;
-   }
-
-   /// Changes the non-zero epsilon, invalidating the setup. */
-   void setEpsilon(R eps)
-   {
-      if(eps != epsilon)
-      {
-         epsilon = eps;
-         setupStatus = false;
-      }
-   }
+  /// Returns setup status.
+  bool isSetup() const { return setupStatus; }
 
-   /// Returns setup status.
-   bool isSetup() const
-   {
-      return setupStatus;
-   }
+  /// Makes SSVectorBase not setup.
+  void unSetup() { setupStatus = false; }
 
-   /// Makes SSVectorBase not setup.
-   void unSetup()
-   {
-      setupStatus = false;
-   }
-
-   /// Initializes nonzero indices for elements with absolute values above #epsilon and sets all other elements to 0.
-   void setup()
-   {
-      if(!isSetup())
-      {
-         IdxSet::clear();
-
-         int d = dim();
-         num = 0;
-
-         for(int i = 0; i < d; ++i)
-         {
-            if(VectorBase<R>::val[i] != R(0))
-            {
-               if(spxAbs(VectorBase<R>::val[i]) <= epsilon)
-                  VectorBase<R>::val[i] = R(0);
-               else
-               {
-                  idx[num] = i;
-                  num++;
-               }
-            }
-         }
-
-         setupStatus = true;
-
-         assert(isConsistent());
-      }
-   }
+  /// Initializes nonzero indices for elements with absolute values above
+  /// #epsilon and sets all other elements to 0.
+  void setup() {
+    if (!isSetup()) {
+      IdxSet::clear();
 
-   /// Forces setup status.
-   void forceSetup()
-   {
-      setupStatus = true;
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Methods for setup SSVectorBases */
-   ///@{
-
-   /// Returns index of the \p n 'th nonzero element.
-   int index(int n) const
-   {
-      assert(isSetup());
-
-      return IdxSet::index(n);
-   }
-
-   /// Returns value of the \p n 'th nonzero element.
-   R value(int n) const
-   {
-      assert(isSetup());
-      assert(n >= 0 && n < size());
-
-      return VectorBase<R>::val[idx[n]];
-   }
-
-   /// Finds the position of index \p i in the #IdxSet, or -1 if \p i doesn't exist.
-   int pos(int i) const
-   {
-      assert(isSetup());
-
-      return IdxSet::pos(i);
-   }
-
-   /// Returns the number of nonzeros.
-   int size() const
-   {
-      assert(isSetup());
-
-      return IdxSet::size();
-   }
-
-   /// Adds nonzero (\p i, \p x) to SSVectorBase.
-   /** No nonzero with index \p i must exist in the SSVectorBase. */
-   void add(int i, R x)
-   {
-      assert(VectorBase<R>::val[i] == R(0));
-      assert(pos(i) < 0);
-
-      addIdx(i);
-      VectorBase<R>::val[i] = x;
-   }
-
-   /// Sets \p i 'th element to \p x.
-   void setValue(int i, R x)
-   {
-      assert(i >= 0);
-      assert(i < VectorBase<R>::dim());
-
-      if(isSetup())
-      {
-         int n = pos(i);
-
-         if(n < 0)
-         {
-            if(spxAbs(x) > epsilon)
-               IdxSet::add(1, &i);
-         }
-         else if(x == R(0))
-            clearNum(n);
+      int d = dim();
+      num = 0;
+
+      for (int i = 0; i < d; ++i) {
+        if (VectorBase<R>::val[i] != R(0)) {
+          if (spxAbs(VectorBase<R>::val[i]) <= epsilon)
+            VectorBase<R>::val[i] = R(0);
+          else {
+            idx[num] = i;
+            num++;
+          }
+        }
       }
 
-      VectorBase<R>::val[i] = x;
+      setupStatus = true;
 
       assert(isConsistent());
-   }
+    }
+  }
 
-   /// Scale \p i 'th element by a
-   void scaleValue(int i, int scaleExp)
-   {
-      assert(i >= 0);
-      assert(i < VectorBase<R>::dim());
+  /// Forces setup status.
+  void forceSetup() { setupStatus = true; }
 
-      VectorBase<R>::val[i] = spxLdexp(VectorBase<R>::val[i], scaleExp);
+  ///@}
 
-      assert(isConsistent());
-   }
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Methods for setup SSVectorBases */
+  ///@{
 
-   /// Clears element \p i.
-   void clearIdx(int i)
-   {
-      if(isSetup())
-      {
-         int n = pos(i);
+  /// Returns index of the \p n 'th nonzero element.
+  int index(int n) const {
+    assert(isSetup());
 
-         if(n >= 0)
-            remove(n);
-      }
+    return IdxSet::index(n);
+  }
 
-      VectorBase<R>::val[i] = 0;
+  /// Returns value of the \p n 'th nonzero element.
+  R value(int n) const {
+    assert(isSetup());
+    assert(n >= 0 && n < size());
 
-      assert(isConsistent());
-   }
+    return VectorBase<R>::val[idx[n]];
+  }
 
-   /// Sets \p n 'th nonzero element to 0 (index \p n must exist).
-   void clearNum(int n)
-   {
-      assert(isSetup());
-      assert(index(n) >= 0);
+  /// Finds the position of index \p i in the #IdxSet, or -1 if \p i doesn't
+  /// exist.
+  int pos(int i) const {
+    assert(isSetup());
 
-      VectorBase<R>::val[index(n)] = 0;
-      remove(n);
+    return IdxSet::pos(i);
+  }
 
-      assert(isConsistent());
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Methods independent of the Status */
-   ///@{
-
-   /// Returns \p i 'th value.
-   R operator[](int i) const
-   {
-      return VectorBase<R>::val[i];
-   }
-
-   /// Returns array indices.
-   const int* indexMem() const
-   {
-      return idx;
-   }
-
-   /// Returns array values.
-   const R* values() const
-   {
-      return VectorBase<R>::val.data();
-   }
-
-   /// Returns indices.
-   const IdxSet& indices() const
-   {
-      return *this;
-   }
-
-   /// Returns array indices.
-   int* altIndexMem()
-   {
-      unSetup();
-      return idx;
-   }
-
-   /// Returns array values.
-   R* altValues()
-   {
-      unSetup();
-      return VectorBase<R>::val.data();
-   }
-
-   /// Returns indices.
-   IdxSet& altIndices()
-   {
-      unSetup();
-      return *this;
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Arithmetic operations */
-   ///@{
-
-   /// Addition.
-   template < class S >
-   SSVectorBase<R>& operator+=(const VectorBase<S>& vec)
-   {
-      VectorBase<S>::operator+=(vec);
-
-      if(isSetup())
-      {
-         setupStatus = false;
-         setup();
-      }
+  /// Returns the number of nonzeros.
+  int size() const {
+    assert(isSetup());
 
-      return *this;
-   }
+    return IdxSet::size();
+  }
 
-   /// Addition.
-   template < class S >
-   SSVectorBase<R>& operator+=(const SVectorBase<S>& vec);
+  /// Adds nonzero (\p i, \p x) to SSVectorBase.
+  /** No nonzero with index \p i must exist in the SSVectorBase. */
+  void add(int i, R x) {
+    assert(VectorBase<R>::val[i] == R(0));
+    assert(pos(i) < 0);
 
-   /// Addition.
-   template < class S >
-   SSVectorBase<R>& operator+=(const SSVectorBase<S>& vec)
-   {
-      assert(vec.isSetup());
+    addIdx(i);
+    VectorBase<R>::val[i] = x;
+  }
 
-      for(int i = vec.size() - 1; i >= 0; --i)
-         VectorBase<R>::val[vec.index(i)] += vec.value(i);
+  /// Sets \p i 'th element to \p x.
+  void setValue(int i, R x) {
+    assert(i >= 0);
+    assert(i < VectorBase<R>::dim());
 
-      if(isSetup())
-      {
-         setupStatus = false;
-         setup();
-      }
+    if (isSetup()) {
+      int n = pos(i);
 
-      return *this;
-   }
+      if (n < 0) {
+        if (spxAbs(x) > epsilon)
+          IdxSet::add(1, &i);
+      } else if (x == R(0))
+        clearNum(n);
+    }
 
-   /// Subtraction.
-   template < class S >
-   SSVectorBase<R>& operator-=(const VectorBase<S>& vec)
-   {
-      VectorBase<R>::operator-=(vec);
+    VectorBase<R>::val[i] = x;
 
-      if(isSetup())
-      {
-         setupStatus = false;
-         setup();
-      }
+    assert(isConsistent());
+  }
 
-      return *this;
-   }
-
-   /// Subtraction.
-   template < class S >
-   SSVectorBase<R>& operator-=(const SVectorBase<S>& vec);
-
-   /// Subtraction.
-   template < class S >
-   SSVectorBase<R>& operator-=(const SSVectorBase<S>& vec)
-   {
-      if(vec.isSetup())
-      {
-         for(int i = vec.size() - 1; i >= 0; --i)
-            VectorBase<R>::val[vec.index(i)] -= vec.value(i);
-      }
-      else
-         VectorBase<R>::operator-=(VectorBase<S>(vec));
+  /// Scale \p i 'th element by a
+  void scaleValue(int i, int scaleExp) {
+    assert(i >= 0);
+    assert(i < VectorBase<R>::dim());
 
-      if(isSetup())
-      {
-         setupStatus = false;
-         setup();
-      }
+    VectorBase<R>::val[i] = spxLdexp(VectorBase<R>::val[i], scaleExp);
 
-      return *this;
-   }
+    assert(isConsistent());
+  }
 
-   /// Scaling.
-   template < class S >
-   SSVectorBase<R>& operator*=(S x)
-   {
-      assert(isSetup());
-      assert(x != S(0));
+  /// Clears element \p i.
+  void clearIdx(int i) {
+    if (isSetup()) {
+      int n = pos(i);
 
-      for(int i = size() - 1; i >= 0; --i)
-         VectorBase<R>::val[index(i)] *= x;
+      if (n >= 0)
+        remove(n);
+    }
 
-      assert(isConsistent());
+    VectorBase<R>::val[i] = 0;
 
-      return *this;
-   }
+    assert(isConsistent());
+  }
 
-   // Inner product.
-   template < class S >
-   R operator*(const SSVectorBase<S>& w)
-   {
+  /// Sets \p n 'th nonzero element to 0 (index \p n must exist).
+  void clearNum(int n) {
+    assert(isSetup());
+    assert(index(n) >= 0);
+
+    VectorBase<R>::val[index(n)] = 0;
+    remove(n);
+
+    assert(isConsistent());
+  }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Methods independent of the Status */
+  ///@{
+
+  /// Returns \p i 'th value.
+  R operator[](int i) const { return VectorBase<R>::val[i]; }
+
+  /// Returns array indices.
+  const int *indexMem() const { return idx; }
+
+  /// Returns array values.
+  const R *values() const { return VectorBase<R>::val.data(); }
+
+  /// Returns indices.
+  const IdxSet &indices() const { return *this; }
+
+  /// Returns array indices.
+  int *altIndexMem() {
+    unSetup();
+    return idx;
+  }
+
+  /// Returns array values.
+  R *altValues() {
+    unSetup();
+    return VectorBase<R>::val.data();
+  }
+
+  /// Returns indices.
+  IdxSet &altIndices() {
+    unSetup();
+    return *this;
+  }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Arithmetic operations */
+  ///@{
+
+  /// Addition.
+  template <class S> SSVectorBase<R> &operator+=(const VectorBase<S> &vec) {
+    VectorBase<S>::operator+=(vec);
+
+    if (isSetup()) {
+      setupStatus = false;
       setup();
+    }
 
-      StableSum<R> x;
-      int i = size() - 1;
-      int j = w.size() - 1;
-
-      // both *this and w non-zero vectors?
-      if(i >= 0 && j >= 0)
-      {
-         int vi = index(i);
-         int wj = w.index(j);
-
-         while(i != 0 && j != 0)
-         {
-            if(vi == wj)
-            {
-               x += VectorBase<R>::val[vi] * R(w.val[wj]);
-               vi = index(--i);
-               wj = w.index(--j);
-            }
-            else if(vi > wj)
-               vi = index(--i);
-            else
-               wj = w.index(--j);
-         }
-
-         /* check remaining indices */
-
-         while(i != 0 && vi != wj)
-            vi = index(--i);
-
-         while(j != 0 && vi != wj)
-            wj = w.index(--j);
-
-         if(vi == wj)
-            x += VectorBase<R>::val[vi] * R(w.val[wj]);
-      }
+    return *this;
+  }
+
+  /// Addition.
+  template <class S> SSVectorBase<R> &operator+=(const SVectorBase<S> &vec);
 
-      return x;
-   }
+  /// Addition.
+  template <class S> SSVectorBase<R> &operator+=(const SSVectorBase<S> &vec) {
+    assert(vec.isSetup());
 
-   /// Addition of a scaled vector.
-   ///@todo SSVectorBase::multAdd() should be rewritten without pointer arithmetic.
-   template < class S, class T >
-   SSVectorBase<R>& multAdd(S xx, const SVectorBase<T>& vec);
+    for (int i = vec.size() - 1; i >= 0; --i)
+      VectorBase<R>::val[vec.index(i)] += vec.value(i);
 
-   /// Addition of a scaled vector.
-   template < class S, class T >
-   SSVectorBase<R>& multAdd(S x, const VectorBase<T>& vec)
-   {
-      VectorBase<R>::multAdd(x, vec);
+    if (isSetup()) {
+      setupStatus = false;
+      setup();
+    }
+
+    return *this;
+  }
 
-      if(isSetup())
-      {
-         setupStatus = false;
-         setup();
+  /// Subtraction.
+  template <class S> SSVectorBase<R> &operator-=(const VectorBase<S> &vec) {
+    VectorBase<R>::operator-=(vec);
+
+    if (isSetup()) {
+      setupStatus = false;
+      setup();
+    }
+
+    return *this;
+  }
+
+  /// Subtraction.
+  template <class S> SSVectorBase<R> &operator-=(const SVectorBase<S> &vec);
+
+  /// Subtraction.
+  template <class S> SSVectorBase<R> &operator-=(const SSVectorBase<S> &vec) {
+    if (vec.isSetup()) {
+      for (int i = vec.size() - 1; i >= 0; --i)
+        VectorBase<R>::val[vec.index(i)] -= vec.value(i);
+    } else
+      VectorBase<R>::operator-=(VectorBase<S>(vec));
+
+    if (isSetup()) {
+      setupStatus = false;
+      setup();
+    }
+
+    return *this;
+  }
+
+  /// Scaling.
+  template <class S> SSVectorBase<R> &operator*=(S x) {
+    assert(isSetup());
+    assert(x != S(0));
+
+    for (int i = size() - 1; i >= 0; --i)
+      VectorBase<R>::val[index(i)] *= x;
+
+    assert(isConsistent());
+
+    return *this;
+  }
+
+  // Inner product.
+  template <class S> R operator*(const SSVectorBase<S> &w) {
+    setup();
+
+    StableSum<R> x;
+    int i = size() - 1;
+    int j = w.size() - 1;
+
+    // both *this and w non-zero vectors?
+    if (i >= 0 && j >= 0) {
+      int vi = index(i);
+      int wj = w.index(j);
+
+      while (i != 0 && j != 0) {
+        if (vi == wj) {
+          x += VectorBase<R>::val[vi] * R(w.val[wj]);
+          vi = index(--i);
+          wj = w.index(--j);
+        } else if (vi > wj)
+          vi = index(--i);
+        else
+          wj = w.index(--j);
       }
 
-      return *this;
-   }
+      /* check remaining indices */
 
-   /// Assigns pair wise vector product to SSVectorBase.
-   template < class S, class T >
-   SSVectorBase<R>& assignPWproduct4setup(const SSVectorBase<S>& x, const SSVectorBase<T>& y);
+      while (i != 0 && vi != wj)
+        vi = index(--i);
 
-   /// Assigns \f$x^T \cdot A\f$ to SSVectorBase.
-   template < class S, class T >
-   SSVectorBase<R>& assign2product(const SSVectorBase<S>& x, const SVSetBase<T>& A);
+      while (j != 0 && vi != wj)
+        wj = w.index(--j);
 
-   /// Assigns SSVectorBase to \f$A \cdot x\f$ for a setup \p x.
-   template < class S, class T >
-   SSVectorBase<R>& assign2product4setup(const SVSetBase<S>& A, const SSVectorBase<T>& x,
-                                         Timer* timeSparse, Timer* timeFull, int& nCallsSparse, int& nCallsFull);
+      if (vi == wj)
+        x += VectorBase<R>::val[vi] * R(w.val[wj]);
+    }
 
-public:
+    return x;
+  }
 
-   /// Assigns SSVectorBase to \f$A \cdot x\f$ thereby setting up \p x.
-   template < class S, class T >
-   SSVectorBase<R>& assign2productAndSetup(const SVSetBase<S>& A, SSVectorBase<T>& x);
+  /// Addition of a scaled vector.
+  ///@todo SSVectorBase::multAdd() should be rewritten without pointer
+  /// arithmetic.
+  template <class S, class T>
+  SSVectorBase<R> &multAdd(S xx, const SVectorBase<T> &vec);
 
-   /// Maximum absolute value, i.e., infinity norm.
-   R maxAbs() const
-   {
-      if(isSetup())
-      {
-         R maxabs = 0;
+  /// Addition of a scaled vector.
+  template <class S, class T>
+  SSVectorBase<R> &multAdd(S x, const VectorBase<T> &vec) {
+    VectorBase<R>::multAdd(x, vec);
 
-         for(int i = 0; i < num; ++i)
-         {
-            R x = spxAbs(VectorBase<R>::val[idx[i]]);
+    if (isSetup()) {
+      setupStatus = false;
+      setup();
+    }
 
-            if(x > maxabs)
-               maxabs = x;
-         }
+    return *this;
+  }
 
-         return maxabs;
-      }
-      else
-         return VectorBase<R>::maxAbs();
-   }
-
-   /// Squared euclidian norm.
-   R length2() const
-   {
-      R x = 0;
-
-      if(isSetup())
-      {
-         for(int i = 0; i < num; ++i)
-            x += VectorBase<R>::val[idx[i]] * VectorBase<R>::val[idx[i]];
-      }
-      else
-         x = VectorBase<R>::length2();
-
-      return x;
-   }
-
-   /// Floating point approximation of euclidian norm (without any approximation guarantee).
-   R length() const
-   {
-      return spxSqrt(R(length2()));
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Miscellaneous */
-   ///@{
-
-   /// Dimension of VectorBase.
-   int dim() const
-   {
-      return VectorBase<R>::dim();
-   }
-
-   /// Resets dimension to \p newdim.
-   void reDim(int newdim)
-   {
-      for(int i = IdxSet::size() - 1; i >= 0; --i)
-      {
-         if(index(i) >= newdim)
-            remove(i);
-      }
+  /// Assigns pair wise vector product to SSVectorBase.
+  template <class S, class T>
+  SSVectorBase<R> &assignPWproduct4setup(const SSVectorBase<S> &x,
+                                         const SSVectorBase<T> &y);
 
-      VectorBase<R>::reDim(newdim);
-      setMax(VectorBase<R>::memSize() + 1);
+  /// Assigns \f$x^T \cdot A\f$ to SSVectorBase.
+  template <class S, class T>
+  SSVectorBase<R> &assign2product(const SSVectorBase<S> &x,
+                                  const SVSetBase<T> &A);
 
-      assert(isConsistent());
-   }
-
-   /// Sets number of nonzeros (thereby unSetup SSVectorBase).
-   void setSize(int n)
-   {
-      assert(n >= 0);
-      assert(n <= IdxSet::max());
-
-      unSetup();
-      num = n;
-   }
-
-   /// Resets memory consumption to \p newsize.
-   void reMem(int newsize)
-   {
-      VectorBase<R>::reSize(newsize);
-      assert(isConsistent());
+  /// Assigns SSVectorBase to \f$A \cdot x\f$ for a setup \p x.
+  template <class S, class T>
+  SSVectorBase<R> &assign2product4setup(const SVSetBase<S> &A,
+                                        const SSVectorBase<T> &x,
+                                        Timer *timeSparse, Timer *timeFull,
+                                        int &nCallsSparse, int &nCallsFull);
+
+public:
+  /// Assigns SSVectorBase to \f$A \cdot x\f$ thereby setting up \p x.
+  template <class S, class T>
+  SSVectorBase<R> &assign2productAndSetup(const SVSetBase<S> &A,
+                                          SSVectorBase<T> &x);
+
+  /// Maximum absolute value, i.e., infinity norm.
+  R maxAbs() const {
+    if (isSetup()) {
+      R maxabs = 0;
 
-      setMax(VectorBase<R>::memSize() + 1);
-   }
+      for (int i = 0; i < num; ++i) {
+        R x = spxAbs(VectorBase<R>::val[idx[i]]);
 
-   /// Clears vector.
-   void clear()
-   {
-      if(isSetup())
-      {
-         for(int i = 0; i < num; ++i)
-            VectorBase<R>::val[idx[i]] = 0;
+        if (x > maxabs)
+          maxabs = x;
       }
-      else
-         VectorBase<R>::clear();
 
-      IdxSet::clear();
-      setupStatus = true;
+      return maxabs;
+    } else
+      return VectorBase<R>::maxAbs();
+  }
+
+  /// Squared euclidian norm.
+  R length2() const {
+    R x = 0;
+
+    if (isSetup()) {
+      for (int i = 0; i < num; ++i)
+        x += VectorBase<R>::val[idx[i]] * VectorBase<R>::val[idx[i]];
+    } else
+      x = VectorBase<R>::length2();
+
+    return x;
+  }
+
+  /// Floating point approximation of euclidian norm (without any approximation
+  /// guarantee).
+  R length() const { return spxSqrt(R(length2())); }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Miscellaneous */
+  ///@{
+
+  /// Dimension of VectorBase.
+  int dim() const { return VectorBase<R>::dim(); }
+
+  /// Resets dimension to \p newdim.
+  void reDim(int newdim) {
+    for (int i = IdxSet::size() - 1; i >= 0; --i) {
+      if (index(i) >= newdim)
+        remove(i);
+    }
+
+    VectorBase<R>::reDim(newdim);
+    setMax(VectorBase<R>::memSize() + 1);
+
+    assert(isConsistent());
+  }
+
+  /// Sets number of nonzeros (thereby unSetup SSVectorBase).
+  void setSize(int n) {
+    assert(n >= 0);
+    assert(n <= IdxSet::max());
+
+    unSetup();
+    num = n;
+  }
+
+  /// Resets memory consumption to \p newsize.
+  void reMem(int newsize) {
+    VectorBase<R>::reSize(newsize);
+    assert(isConsistent());
+
+    setMax(VectorBase<R>::memSize() + 1);
+  }
+
+  /// Clears vector.
+  void clear() {
+    if (isSetup()) {
+      for (int i = 0; i < num; ++i)
+        VectorBase<R>::val[idx[i]] = 0;
+    } else
+      VectorBase<R>::clear();
 
-      assert(isConsistent());
-   }
+    IdxSet::clear();
+    setupStatus = true;
 
-   /// consistency check.
-   bool isConsistent() const
-   {
+    assert(isConsistent());
+  }
+
+  /// consistency check.
+  bool isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
 
-      if(VectorBase<R>::dim() > IdxSet::max())
-         return MSGinconsistent("SSVectorBase");
+    if (VectorBase<R>::dim() > IdxSet::max())
+      return MSGinconsistent("SSVectorBase");
 
-      if(VectorBase<R>::dim() < IdxSet::dim())
-         return MSGinconsistent("SSVectorBase");
+    if (VectorBase<R>::dim() < IdxSet::dim())
+      return MSGinconsistent("SSVectorBase");
 
-      if(isSetup())
-      {
-         for(int i = 0; i < VectorBase<R>::dim(); ++i)
-         {
-            int j = pos(i);
+    if (isSetup()) {
+      for (int i = 0; i < VectorBase<R>::dim(); ++i) {
+        int j = pos(i);
 
-            if(j < 0 && spxAbs(VectorBase<R>::val[i]) > 0)
-            {
-               MSG_ERROR(std::cerr << "ESSVEC01 i = " << i
-                         << "\tidx = " << j
-                         << "\tval = " << std::setprecision(16) << VectorBase<R>::val[i]
-                         << std::endl;)
+        if (j < 0 && spxAbs(VectorBase<R>::val[i]) > 0) {
+          MSG_ERROR(std::cerr << "ESSVEC01 i = " << i << "\tidx = " << j
+                              << "\tval = " << std::setprecision(16)
+                              << VectorBase<R>::val[i] << std::endl;)
 
-               return MSGinconsistent("SSVectorBase");
-            }
-         }
+          return MSGinconsistent("SSVectorBase");
+        }
       }
+    }
 
-      return VectorBase<R>::isConsistent() && IdxSet::isConsistent();
+    return VectorBase<R>::isConsistent() && IdxSet::isConsistent();
 #else
-      return true;
+    return true;
 #endif
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Constructors / Destructors */
-   ///@{
-
-   /// Default constructor.
-   explicit SSVectorBase<R>(int p_dim, R p_eps = Param::epsilon())
-      : VectorBase<R>(p_dim)
-      , IdxSet()
-      , setupStatus(true)
-      , epsilon(p_eps)
-   {
-      len = (p_dim < 1) ? 1 : p_dim;
-      spx_alloc(idx, len);
-      VectorBase<R>::clear();
+  }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Constructors / Destructors */
+  ///@{
+
+  /// Default constructor.
+  explicit SSVectorBase<R>(int p_dim, R p_eps = Param::epsilon())
+      : VectorBase<R>(p_dim), IdxSet(), setupStatus(true), epsilon(p_eps) {
+    len = (p_dim < 1) ? 1 : p_dim;
+    spx_alloc(idx, len);
+    VectorBase<R>::clear();
+
+    assert(isConsistent());
+  }
+
+  /// Copy constructor.
+  template <class S>
+  SSVectorBase(const SSVectorBase<S> &vec)
+      : VectorBase<R>(vec), IdxSet(), setupStatus(vec.setupStatus),
+        epsilon(vec.epsilon) {
+    len = (vec.dim() < 1) ? 1 : vec.dim();
+    spx_alloc(idx, len);
+    IdxSet::operator=(vec);
+
+    assert(isConsistent());
+  }
+
+  /// Copy constructor.
+  /** The redundancy with the copy constructor below is necessary since
+   * otherwise the compiler doesn't realize that it could use the more general
+   * one with S = R and generates a shallow copy constructor.
+   */
+  SSVectorBase(const SSVectorBase<R> &vec)
+      : VectorBase<R>(vec), IdxSet(), setupStatus(vec.setupStatus),
+        epsilon(vec.epsilon) {
+    len = (vec.dim() < 1) ? 1 : vec.dim();
+    spx_alloc(idx, len);
+    IdxSet::operator=(vec);
+
+    assert(isConsistent());
+  }
+
+  /// Constructs nonsetup copy of \p vec.
+  template <class S>
+  explicit SSVectorBase(const VectorBase<S> &vec, R eps = Param::epsilon())
+      : VectorBase<R>(vec), IdxSet(), setupStatus(false), epsilon(eps) {
+    len = (vec.dim() < 1) ? 1 : vec.dim();
+    spx_alloc(idx, len);
+
+    assert(isConsistent());
+  }
+
+  /// Sets up \p rhs vector, and assigns it.
+  template <class S> void setup_and_assign(SSVectorBase<S> &rhs) {
+    clear();
+    epsilon = rhs.epsilon;
+    setMax(rhs.max());
+    VectorBase<R>::reDim(rhs.dim());
+
+    if (rhs.isSetup()) {
+      IdxSet::operator=(rhs);
+
+      for (int i = size() - 1; i >= 0; --i) {
+        int j = index(i);
+        VectorBase<R>::val[j] = rhs.val[j];
+      }
+    } else {
+      int d = rhs.dim();
+      num = 0;
+
+      for (int i = 0; i < d; ++i) {
+        if (rhs.val[i] != 0) {
+          if (spxAbs(rhs.val[i]) > epsilon) {
+            rhs.idx[num] = i;
+            idx[num] = i;
+            VectorBase<R>::val[i] = rhs.val[i];
+            num++;
+          } else
+            rhs.val[i] = 0;
+        }
+      }
 
-      assert(isConsistent());
-   }
-
-   /// Copy constructor.
-   template < class S >
-   SSVectorBase<R>(const SSVectorBase<S>& vec)
-      : VectorBase<R>(vec)
-      , IdxSet()
-      , setupStatus(vec.setupStatus)
-      , epsilon(vec.epsilon)
-   {
-      len = (vec.dim() < 1) ? 1 : vec.dim();
-      spx_alloc(idx, len);
-      IdxSet::operator=(vec);
+      rhs.num = num;
+      rhs.setupStatus = true;
+    }
 
-      assert(isConsistent());
-   }
-
-   /// Copy constructor.
-   /** The redundancy with the copy constructor below is necessary since otherwise the compiler doesn't realize that it
-    *  could use the more general one with S = R and generates a shallow copy constructor.
-    */
-   SSVectorBase<R>(const SSVectorBase<R>& vec)
-      : VectorBase<R>(vec)
-      , IdxSet()
-      , setupStatus(vec.setupStatus)
-      , epsilon(vec.epsilon)
-   {
-      len = (vec.dim() < 1) ? 1 : vec.dim();
-      spx_alloc(idx, len);
-      IdxSet::operator=(vec);
+    setupStatus = true;
 
-      assert(isConsistent());
-   }
-
-   /// Constructs nonsetup copy of \p vec.
-   template < class S >
-   explicit SSVectorBase<R>(const VectorBase<S>& vec, R eps = Param::epsilon())
-      : VectorBase<R>(vec)
-      , IdxSet()
-      , setupStatus(false)
-      , epsilon(eps)
-   {
-      len = (vec.dim() < 1) ? 1 : vec.dim();
-      spx_alloc(idx, len);
+    assert(rhs.isConsistent());
+    assert(isConsistent());
+  }
 
-      assert(isConsistent());
-   }
+  /// Assigns only the elements of \p rhs.
+  template <class S> SSVectorBase<R> &assign(const SVectorBase<S> &rhs);
+
+  /// Assignment operator.
+  template <class S> SSVectorBase<R> &operator=(const SSVectorBase<S> &rhs) {
+    assert(rhs.isConsistent());
 
-   /// Sets up \p rhs vector, and assigns it.
-   template < class S >
-   void setup_and_assign(SSVectorBase<S>& rhs)
-   {
+    if (this != &rhs) {
       clear();
       epsilon = rhs.epsilon;
       setMax(rhs.max());
       VectorBase<R>::reDim(rhs.dim());
 
-      if(rhs.isSetup())
-      {
-         IdxSet::operator=(rhs);
-
-         for(int i = size() - 1; i >= 0; --i)
-         {
-            int j  = index(i);
-            VectorBase<R>::val[j] = rhs.val[j];
-         }
-      }
-      else
-      {
-         int d = rhs.dim();
-         num = 0;
-
-         for(int i = 0; i < d; ++i)
-         {
-            if(rhs.val[i] != 0)
-            {
-               if(spxAbs(rhs.val[i]) > epsilon)
-               {
-                  rhs.idx[num] = i;
-                  idx[num] = i;
-                  VectorBase<R>::val[i] = rhs.val[i];
-                  num++;
-               }
-               else
-                  rhs.val[i] = 0;
-            }
-         }
-
-         rhs.num = num;
-         rhs.setupStatus = true;
+      if (rhs.isSetup()) {
+        IdxSet::operator=(rhs);
+
+        for (int i = size() - 1; i >= 0; --i) {
+          int j = index(i);
+          VectorBase<R>::val[j] = rhs.val[j];
+        }
+      } else {
+        int d = rhs.dim();
+        num = 0;
+
+        for (int i = 0; i < d; ++i) {
+          if (spxAbs(rhs.val[i]) > epsilon) {
+            VectorBase<R>::val[i] = rhs.val[i];
+            idx[num] = i;
+            num++;
+          }
+        }
       }
 
       setupStatus = true;
+    }
 
-      assert(rhs.isConsistent());
-      assert(isConsistent());
-   }
-
-   /// Assigns only the elements of \p rhs.
-   template < class S >
-   SSVectorBase<R>& assign(const SVectorBase<S>& rhs);
-
-   /// Assignment operator.
-   template < class S >
-   SSVectorBase<R>& operator=(const SSVectorBase<S>& rhs)
-   {
-      assert(rhs.isConsistent());
-
-      if(this != &rhs)
-      {
-         clear();
-         epsilon = rhs.epsilon;
-         setMax(rhs.max());
-         VectorBase<R>::reDim(rhs.dim());
-
-         if(rhs.isSetup())
-         {
-            IdxSet::operator=(rhs);
-
-            for(int i = size() - 1; i >= 0; --i)
-            {
-               int j = index(i);
-               VectorBase<R>::val[j] = rhs.val[j];
-            }
-         }
-         else
-         {
-            int d = rhs.dim();
-            num = 0;
-
-            for(int i = 0; i < d; ++i)
-            {
-               if(spxAbs(rhs.val[i]) > epsilon)
-               {
-                  VectorBase<R>::val[i] = rhs.val[i];
-                  idx[num] = i;
-                  num++;
-               }
-            }
-         }
-
-         setupStatus = true;
-      }
-
-      assert(isConsistent());
-
-      return *this;
-   }
-
-   /// Assignment operator.
-   SSVectorBase<R>& operator=(const SSVectorBase<R>& rhs)
-   {
-      assert(rhs.isConsistent());
-
-      if(this != &rhs)
-      {
-         clear();
-         epsilon = rhs.epsilon;
-         setMax(rhs.max());
-         VectorBase<R>::reDim(rhs.dim());
-
-         if(rhs.isSetup())
-         {
-            IdxSet::operator=(rhs);
-
-            for(int i = size() - 1; i >= 0; --i)
-            {
-               int j = index(i);
-               VectorBase<R>::val[j] = rhs.val[j];
-            }
-         }
-         else
-         {
-            num = 0;
-
-            for(int i = 0; i < rhs.dim(); ++i)
-            {
-               if(spxAbs(rhs.val[i]) > epsilon)
-               {
-                  VectorBase<R>::val[i] = rhs.val[i];
-                  idx[num] = i;
-                  num++;
-               }
-            }
-         }
-
-         setupStatus = true;
-      }
+    assert(isConsistent());
 
-      assert(isConsistent());
+    return *this;
+  }
 
-      return *this;
-   }
+  /// Assignment operator.
+  SSVectorBase<R> &operator=(const SSVectorBase<R> &rhs) {
+    assert(rhs.isConsistent());
 
-   /// Assignment operator.
-   template < class S >
-   SSVectorBase<R>& operator=(const SVectorBase<S>& rhs);
+    if (this != &rhs) {
+      clear();
+      epsilon = rhs.epsilon;
+      setMax(rhs.max());
+      VectorBase<R>::reDim(rhs.dim());
 
-   /// Assignment operator.
-   template < class S >
-   SSVectorBase<R>& operator=(const VectorBase<S>& rhs)
-   {
-      unSetup();
-      VectorBase<R>::operator=(rhs);
+      if (rhs.isSetup()) {
+        IdxSet::operator=(rhs);
+
+        for (int i = size() - 1; i >= 0; --i) {
+          int j = index(i);
+          VectorBase<R>::val[j] = rhs.val[j];
+        }
+      } else {
+        num = 0;
+
+        for (int i = 0; i < rhs.dim(); ++i) {
+          if (spxAbs(rhs.val[i]) > epsilon) {
+            VectorBase<R>::val[i] = rhs.val[i];
+            idx[num] = i;
+            num++;
+          }
+        }
+      }
 
-      assert(isConsistent());
+      setupStatus = true;
+    }
 
-      return *this;
-   }
+    assert(isConsistent());
 
-   /// destructor
-   ~SSVectorBase<R>()
-   {
-      if(idx)
-         spx_free(idx);
-   }
+    return *this;
+  }
 
-   ///@}
+  /// Assignment operator.
+  template <class S> SSVectorBase<R> &operator=(const SVectorBase<S> &rhs);
 
-private:
+  /// Assignment operator.
+  template <class S> SSVectorBase<R> &operator=(const VectorBase<S> &rhs) {
+    unSetup();
+    VectorBase<R>::operator=(rhs);
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Private helpers */
-   ///@{
+    assert(isConsistent());
 
-   /// Assignment helper.
-   template < class S, class T >
-   SSVectorBase<R>& assign2product1(const SVSetBase<S>& A, const SSVectorBase<T>& x);
+    return *this;
+  }
 
-   /// Assignment helper.
-   template < class S, class T >
-   SSVectorBase<R>& assign2productShort(const SVSetBase<S>& A, const SSVectorBase<T>& x);
+  /// destructor
+  ~SSVectorBase() {
+    if (idx)
+      spx_free(idx);
+  }
 
-   /// Assignment helper.
-   template < class S, class T >
-   SSVectorBase<R>& assign2productFull(const SVSetBase<S>& A, const SSVectorBase<T>& x);
+  ///@}
 
-   ///@}
+private:
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Private helpers */
+  ///@{
+
+  /// Assignment helper.
+  template <class S, class T>
+  SSVectorBase<R> &assign2product1(const SVSetBase<S> &A,
+                                   const SSVectorBase<T> &x);
+
+  /// Assignment helper.
+  template <class S, class T>
+  SSVectorBase<R> &assign2productShort(const SVSetBase<S> &A,
+                                       const SSVectorBase<T> &x);
+
+  /// Assignment helper.
+  template <class S, class T>
+  SSVectorBase<R> &assign2productFull(const SVSetBase<S> &A,
+                                      const SSVectorBase<T> &x);
+
+  ///@}
 };
 
 } // namespace soplex
diff --git a/src/soplex/statistics.hpp b/src/soplex/statistics.hpp
index ddc005f..ecda064 100644
--- a/src/soplex/statistics.hpp
+++ b/src/soplex/statistics.hpp
@@ -21,336 +21,342 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
-#include <iostream>
 #include <assert.h>
+#include <iostream>
 
 #include "soplex/timerfactory.h"
 
-namespace soplex
-{
+namespace soplex {
 /// default constructor
-template <class R>
-SoPlexBase<R>::Statistics::Statistics(Timer::TYPE ttype)
-{
-   timerType = ttype;
-   readingTime = TimerFactory::createTimer(timerType);
-   solvingTime = TimerFactory::createTimer(timerType);
-   preprocessingTime = TimerFactory::createTimer(timerType);
-   simplexTime = TimerFactory::createTimer(timerType);
-   syncTime = TimerFactory::createTimer(timerType);
-   transformTime = TimerFactory::createTimer(timerType);
-   rationalTime = TimerFactory::createTimer(timerType);
-   reconstructionTime = TimerFactory::createTimer(timerType);
-   clearAllData();
+template <class R> SoPlexBase<R>::Statistics::Statistics(Timer::TYPE ttype) {
+  timerType = ttype;
+  readingTime = TimerFactory::createTimer(timerType);
+  solvingTime = TimerFactory::createTimer(timerType);
+  preprocessingTime = TimerFactory::createTimer(timerType);
+  simplexTime = TimerFactory::createTimer(timerType);
+  syncTime = TimerFactory::createTimer(timerType);
+  transformTime = TimerFactory::createTimer(timerType);
+  rationalTime = TimerFactory::createTimer(timerType);
+  reconstructionTime = TimerFactory::createTimer(timerType);
+  clearAllData();
 }
 
 /// copy constructor
 template <class R>
-SoPlexBase<R>::Statistics::Statistics(const Statistics& base)
-{
-   timerType = base.timerType;
-   readingTime = TimerFactory::createTimer(timerType);
-   solvingTime = TimerFactory::createTimer(timerType);
-   preprocessingTime = TimerFactory::createTimer(timerType);
-   simplexTime = TimerFactory::createTimer(timerType);
-   syncTime = TimerFactory::createTimer(timerType);
-   transformTime = TimerFactory::createTimer(timerType);
-   rationalTime = TimerFactory::createTimer(timerType);
-   reconstructionTime = TimerFactory::createTimer(timerType);
-   clearAllData();
+SoPlexBase<R>::Statistics::Statistics(const Statistics &base) {
+  timerType = base.timerType;
+  readingTime = TimerFactory::createTimer(timerType);
+  solvingTime = TimerFactory::createTimer(timerType);
+  preprocessingTime = TimerFactory::createTimer(timerType);
+  simplexTime = TimerFactory::createTimer(timerType);
+  syncTime = TimerFactory::createTimer(timerType);
+  transformTime = TimerFactory::createTimer(timerType);
+  rationalTime = TimerFactory::createTimer(timerType);
+  reconstructionTime = TimerFactory::createTimer(timerType);
+  clearAllData();
 }
 
 /// assignment operator
 template <class R>
-typename SoPlexBase<R>::Statistics& SoPlexBase<R>::Statistics::operator=(const Statistics& rhs)
-{
-   *readingTime = *(rhs.readingTime);
-   *solvingTime = *(rhs.solvingTime);
-   *preprocessingTime = *(rhs.preprocessingTime);
-   *simplexTime = *(rhs.simplexTime);
-   *syncTime = *(rhs.syncTime);
-   *transformTime = *(rhs.transformTime);
-   *rationalTime = *(rhs.rationalTime);
-   *reconstructionTime = *(rhs.reconstructionTime);
-   timerType = rhs.timerType;
-   multTimeSparse = rhs.multTimeSparse;
-   multTimeFull = rhs.multTimeFull;
-   multTimeColwise = rhs.multTimeColwise;
-   multTimeUnsetup = rhs.multTimeUnsetup;
-   multSparseCalls = rhs.multSparseCalls;
-   multFullCalls = rhs.multFullCalls;
-   multColwiseCalls = rhs.multColwiseCalls;
-   multUnsetupCalls = rhs.multUnsetupCalls;
-   luFactorizationTimeReal = rhs.luFactorizationTimeReal;
-   luSolveTimeReal = rhs.luSolveTimeReal;
-   luFactorizationTimeRational = rhs.luFactorizationTimeRational;
-   luSolveTimeRational = rhs.luSolveTimeRational;
-   iterations = rhs.iterations;
-   iterationsPrimal = rhs.iterationsPrimal;
-   iterationsFromBasis = rhs.iterationsFromBasis;
-   boundflips = rhs.boundflips;
-   luFactorizationsReal = rhs.luFactorizationsReal;
-   luSolvesReal = rhs.luSolvesReal;
-   luFactorizationsRational = rhs.luFactorizationsRational;
-   rationalReconstructions = rhs.rationalReconstructions;
-   refinements = rhs.refinements;
-   stallRefinements = rhs.stallRefinements;
-   pivotRefinements = rhs.pivotRefinements;
-   feasRefinements = rhs.feasRefinements;
-   unbdRefinements = rhs.unbdRefinements;
-
-   return *this;
+typename SoPlexBase<R>::Statistics &
+SoPlexBase<R>::Statistics::operator=(const Statistics &rhs) {
+  *readingTime = *(rhs.readingTime);
+  *solvingTime = *(rhs.solvingTime);
+  *preprocessingTime = *(rhs.preprocessingTime);
+  *simplexTime = *(rhs.simplexTime);
+  *syncTime = *(rhs.syncTime);
+  *transformTime = *(rhs.transformTime);
+  *rationalTime = *(rhs.rationalTime);
+  *reconstructionTime = *(rhs.reconstructionTime);
+  timerType = rhs.timerType;
+  multTimeSparse = rhs.multTimeSparse;
+  multTimeFull = rhs.multTimeFull;
+  multTimeColwise = rhs.multTimeColwise;
+  multTimeUnsetup = rhs.multTimeUnsetup;
+  multSparseCalls = rhs.multSparseCalls;
+  multFullCalls = rhs.multFullCalls;
+  multColwiseCalls = rhs.multColwiseCalls;
+  multUnsetupCalls = rhs.multUnsetupCalls;
+  luFactorizationTimeReal = rhs.luFactorizationTimeReal;
+  luSolveTimeReal = rhs.luSolveTimeReal;
+  luFactorizationTimeRational = rhs.luFactorizationTimeRational;
+  luSolveTimeRational = rhs.luSolveTimeRational;
+  iterations = rhs.iterations;
+  iterationsPrimal = rhs.iterationsPrimal;
+  iterationsFromBasis = rhs.iterationsFromBasis;
+  boundflips = rhs.boundflips;
+  luFactorizationsReal = rhs.luFactorizationsReal;
+  luSolvesReal = rhs.luSolvesReal;
+  luFactorizationsRational = rhs.luFactorizationsRational;
+  rationalReconstructions = rhs.rationalReconstructions;
+  refinements = rhs.refinements;
+  stallRefinements = rhs.stallRefinements;
+  pivotRefinements = rhs.pivotRefinements;
+  feasRefinements = rhs.feasRefinements;
+  unbdRefinements = rhs.unbdRefinements;
+
+  return *this;
 }
 
 /// clears all statistics
-template <class R>
-void SoPlexBase<R>::Statistics::clearAllData()
-{
-   readingTime->reset();
-   clearSolvingData();
+template <class R> void SoPlexBase<R>::Statistics::clearAllData() {
+  readingTime->reset();
+  clearSolvingData();
 }
 
 /// clears statistics on solving process
-template <class R>
-void SoPlexBase<R>::Statistics::clearSolvingData()
-{
-   solvingTime->reset();
-   preprocessingTime->reset();
-   simplexTime->reset();
-   syncTime->reset();
-   transformTime->reset();
-   rationalTime->reset();
-   reconstructionTime->reset();
-   multTimeSparse = 0.0;
-   multTimeFull = 0.0;
-   multTimeColwise = 0.0;
-   multTimeUnsetup = 0.0;
-   multSparseCalls = 0;
-   multFullCalls = 0;
-   multColwiseCalls = 0;
-   multUnsetupCalls = 0;
-   luFactorizationTimeReal = 0.0;
-   luSolveTimeReal = 0.0;
-   luFactorizationTimeRational = 0.0;
-   luSolveTimeRational = 0.0;
-   iterations = 0;
-   iterationsPrimal = 0;
-   iterationsFromBasis = 0;
-   iterationsPolish = 0;
-   boundflips = 0;
-   luFactorizationsReal = 0;
-   luSolvesReal = 0;
-   luFactorizationsRational = 0;
-   rationalReconstructions = 0;
-   refinements = 0;
-   stallRefinements = 0;
-   pivotRefinements = 0;
-   feasRefinements = 0;
-   unbdRefinements = 0;
-
-   callsReducedProb = 0;
-   iterationsInit = 0;
-   iterationsRedProb = 0;
-   iterationsCompProb = 0;
-   numRedProbRows = 0;
-   numRedProbCols = 0;
-   degenPivotsPrimal = 0;
-   degenPivotsDual = 0;
-   degenPivotCandPrimal = 0;
-   degenPivotCandDual = 0;
-   sumDualDegen = 0;
-   sumPrimalDegen = 0;
-   decompBasisCondNum = 0;
-   totalBoundViol = 0;
-   totalRowViol = 0;
-   maxBoundViol = 0;
-   maxRowViol = 0;
-   redProbStatus = 0;
-   compProbStatus = 0;
-   finalCompObj = 0;
-   finalBasisCondition = 0;
+template <class R> void SoPlexBase<R>::Statistics::clearSolvingData() {
+  solvingTime->reset();
+  preprocessingTime->reset();
+  simplexTime->reset();
+  syncTime->reset();
+  transformTime->reset();
+  rationalTime->reset();
+  reconstructionTime->reset();
+  multTimeSparse = 0.0;
+  multTimeFull = 0.0;
+  multTimeColwise = 0.0;
+  multTimeUnsetup = 0.0;
+  multSparseCalls = 0;
+  multFullCalls = 0;
+  multColwiseCalls = 0;
+  multUnsetupCalls = 0;
+  luFactorizationTimeReal = 0.0;
+  luSolveTimeReal = 0.0;
+  luFactorizationTimeRational = 0.0;
+  luSolveTimeRational = 0.0;
+  iterations = 0;
+  iterationsPrimal = 0;
+  iterationsFromBasis = 0;
+  iterationsPolish = 0;
+  boundflips = 0;
+  luFactorizationsReal = 0;
+  luSolvesReal = 0;
+  luFactorizationsRational = 0;
+  rationalReconstructions = 0;
+  refinements = 0;
+  stallRefinements = 0;
+  pivotRefinements = 0;
+  feasRefinements = 0;
+  unbdRefinements = 0;
+
+  callsReducedProb = 0;
+  iterationsInit = 0;
+  iterationsRedProb = 0;
+  iterationsCompProb = 0;
+  numRedProbRows = 0;
+  numRedProbCols = 0;
+  degenPivotsPrimal = 0;
+  degenPivotsDual = 0;
+  degenPivotCandPrimal = 0;
+  degenPivotCandDual = 0;
+  sumDualDegen = 0;
+  sumPrimalDegen = 0;
+  decompBasisCondNum = 0;
+  totalBoundViol = 0;
+  totalRowViol = 0;
+  maxBoundViol = 0;
+  maxRowViol = 0;
+  redProbStatus = 0;
+  compProbStatus = 0;
+  finalCompObj = 0;
+  finalBasisCondition = 0;
 }
 
 /// prints statistics
-template <class R>
-void SoPlexBase<R>::Statistics::print(std::ostream& os)
-{
-   Real solTime = solvingTime->time();
-   Real totTime = readingTime->time() + solTime;
-   Real otherTime = solTime - syncTime->time() - transformTime->time() - preprocessingTime->time() -
-                    simplexTime->time() - rationalTime->time();
-
-   R avgPrimalDegeneracy = iterationsPrimal > 0 ? sumPrimalDegen / iterationsPrimal : 0.0;
-   R avgDualDegeneracy = (iterations - iterationsPrimal) > 0 ?
-                         (sumDualDegen / (iterations - iterationsPrimal)) : 0.0;
+template <class R> void SoPlexBase<R>::Statistics::print(std::ostream &os) {
+  Real solTime = solvingTime->time();
+  Real totTime = readingTime->time() + solTime;
+  Real otherTime = solTime - syncTime->time() - transformTime->time() -
+                   preprocessingTime->time() - simplexTime->time() -
+                   rationalTime->time();
 
-   SPxOut::setFixed(os, 2);
+  R avgPrimalDegeneracy =
+      iterationsPrimal > 0 ? sumPrimalDegen / iterationsPrimal : 0.0;
+  R avgDualDegeneracy = (iterations - iterationsPrimal) > 0
+                            ? (sumDualDegen / (iterations - iterationsPrimal))
+                            : 0.0;
 
-   os << "Total time          : " << totTime << "\n"
-      << "  Reading           : " << readingTime->time() << "\n"
-      << "  Solving           : " << solTime << "\n"
-      << "  Preprocessing     : " << preprocessingTime->time();
+  SPxOut::setFixed(os, 2);
 
-   if(solTime > 0)
-      os << " (" << 100 * (preprocessingTime->time() / solTime) << "% of solving time)";
+  os << "Total time          : " << totTime << "\n"
+     << "  Reading           : " << readingTime->time() << "\n"
+     << "  Solving           : " << solTime << "\n"
+     << "  Preprocessing     : " << preprocessingTime->time();
 
-   os << "\n  Simplex           : " << simplexTime->time();
+  if (solTime > 0)
+    os << " (" << 100 * (preprocessingTime->time() / solTime)
+       << "% of solving time)";
 
-   if(solTime > 0)
-      os << " (" << 100 * (simplexTime->time() / solTime) << "% of solving time)";
+  os << "\n  Simplex           : " << simplexTime->time();
 
-   os << "\n  Synchronization   : " << syncTime->time();
+  if (solTime > 0)
+    os << " (" << 100 * (simplexTime->time() / solTime) << "% of solving time)";
 
-   if(solTime > 0)
-      os << " (" << 100 * (syncTime->time() / solTime) << "% of solving time)";
+  os << "\n  Synchronization   : " << syncTime->time();
 
-   os << "\n  Transformation    : " << transformTime->time();
+  if (solTime > 0)
+    os << " (" << 100 * (syncTime->time() / solTime) << "% of solving time)";
 
-   if(solTime > 0)
-      os << " (" << 100 * transformTime->time() / solTime << "% of solving time)";
+  os << "\n  Transformation    : " << transformTime->time();
 
-   os << "\n  Rational          : " << rationalTime->time();
+  if (solTime > 0)
+    os << " (" << 100 * transformTime->time() / solTime << "% of solving time)";
 
-   if(solTime > 0)
-      os << " (" << 100 * rationalTime->time() / solTime << "% of solving time)";
+  os << "\n  Rational          : " << rationalTime->time();
 
-   os << "\n  Other             : " << otherTime;
+  if (solTime > 0)
+    os << " (" << 100 * rationalTime->time() / solTime << "% of solving time)";
 
-   if(solTime > 0)
-      os << " (" << 100 * otherTime / solTime << "% of solving time)";
+  os << "\n  Other             : " << otherTime;
 
-   os << "\nRefinements         : " << refinements << "\n"
-      << "  Stalling          : " << stallRefinements << "\n"
-      << "  Pivoting          : " << pivotRefinements << "\n"
-      << "  Feasibility       : " << feasRefinements << "\n"
-      << "  Unboundedness     : " << unbdRefinements << "\n";
+  if (solTime > 0)
+    os << " (" << 100 * otherTime / solTime << "% of solving time)";
 
-   os << "Iterations          : " << iterations << "\n"
-      << "  From scratch      : " << iterations - iterationsFromBasis;
+  os << "\nRefinements         : " << refinements << "\n"
+     << "  Stalling          : " << stallRefinements << "\n"
+     << "  Pivoting          : " << pivotRefinements << "\n"
+     << "  Feasibility       : " << feasRefinements << "\n"
+     << "  Unboundedness     : " << unbdRefinements << "\n";
 
-   if(iterations > 0)
-      os << " (" << 100 * double((iterations - iterationsFromBasis)) / double(iterations) << "%)";
+  os << "Iterations          : " << iterations << "\n"
+     << "  From scratch      : " << iterations - iterationsFromBasis;
 
-   os << "\n  From basis        : " << iterationsFromBasis;
+  if (iterations > 0)
+    os << " ("
+       << 100 * double((iterations - iterationsFromBasis)) / double(iterations)
+       << "%)";
 
-   if(iterations > 0)
-      os << " (" << 100 * double(iterationsFromBasis) / double(iterations) << "%)";
+  os << "\n  From basis        : " << iterationsFromBasis;
 
-   os << "\n  Primal            : " << iterationsPrimal;
+  if (iterations > 0)
+    os << " (" << 100 * double(iterationsFromBasis) / double(iterations)
+       << "%)";
 
-   if(iterations > 0)
-      os << " (" << 100 * double(iterationsPrimal) / double(iterations) << "%)";
+  os << "\n  Primal            : " << iterationsPrimal;
 
-   os << "\n  Dual              : " << iterations - iterationsPrimal - iterationsPolish;
+  if (iterations > 0)
+    os << " (" << 100 * double(iterationsPrimal) / double(iterations) << "%)";
 
-   if(iterations > 0)
-      os << " (" << 100 * double((iterations - iterationsPrimal)) / double(iterations) << "%)";
+  os << "\n  Dual              : "
+     << iterations - iterationsPrimal - iterationsPolish;
 
-   os << "\n  Bound flips       : " << boundflips;
-   os << "\n  Sol. polishing    : " << iterationsPolish;
+  if (iterations > 0)
+    os << " ("
+       << 100 * double((iterations - iterationsPrimal)) / double(iterations)
+       << "%)";
 
-   os << "\nLU factorizations   : " << luFactorizationsReal << "\n"
-      << "  Factor. frequency : ";
+  os << "\n  Bound flips       : " << boundflips;
+  os << "\n  Sol. polishing    : " << iterationsPolish;
 
-   if(luFactorizationsReal > 0)
-      os << double(iterations) / double(luFactorizationsReal) << " iterations per factorization\n";
-   else
-      os << "-\n";
+  os << "\nLU factorizations   : " << luFactorizationsReal << "\n"
+     << "  Factor. frequency : ";
 
-   os << "  Factor. time      : " << luFactorizationTimeReal << "\n";
+  if (luFactorizationsReal > 0)
+    os << double(iterations) / double(luFactorizationsReal)
+       << " iterations per factorization\n";
+  else
+    os << "-\n";
 
-   os << "LU solves           : " << luSolvesReal << "\n"
-      << "  Solve frequency   : ";
+  os << "  Factor. time      : " << luFactorizationTimeReal << "\n";
 
-   if(iterations > 0)
-      os << double(luSolvesReal) / double(iterations) << " solves per iteration\n";
-   else
-      os << "-\n";
+  os << "LU solves           : " << luSolvesReal << "\n"
+     << "  Solve frequency   : ";
 
-   os << "  Solve time        : " << luSolveTimeReal << "\n";
+  if (iterations > 0)
+    os << double(luSolvesReal) / double(iterations)
+       << " solves per iteration\n";
+  else
+    os << "-\n";
 
-   os << "Matrix-Vector ops   : \n"
-      << "  Sparse    time    : " << multTimeSparse;
+  os << "  Solve time        : " << luSolveTimeReal << "\n";
 
-   if(solTime > 0)
-      os << " (" << 100 * (multTimeSparse / solTime) << "% of solving time)";
+  os << "Matrix-Vector ops   : \n"
+     << "  Sparse    time    : " << multTimeSparse;
 
-   os << "\n            calls   : " << multSparseCalls;
-   os << " (" << 100 * (multSparseCalls / (0.01 + iterations)) << "% of iterations)";
-   os << "\n  Full      time    : " << multTimeFull;
+  if (solTime > 0)
+    os << " (" << 100 * (multTimeSparse / solTime) << "% of solving time)";
 
-   if(solTime > 0)
-      os << " (" << 100 * (multTimeFull / solTime) << "% of solving time)";
+  os << "\n            calls   : " << multSparseCalls;
+  os << " (" << 100 * (multSparseCalls / (0.01 + iterations))
+     << "% of iterations)";
+  os << "\n  Full      time    : " << multTimeFull;
 
-   os << "\n            calls   : " << multFullCalls;
-   os << " (" << 100 * (multFullCalls / (0.01 + iterations)) << "% of iterations)";
-   os << "\n  Colwise   time    : " << multTimeColwise;
+  if (solTime > 0)
+    os << " (" << 100 * (multTimeFull / solTime) << "% of solving time)";
 
-   if(solTime > 0)
-      os << " (" << 100 * (multTimeColwise / solTime) << "% of solving time)";
+  os << "\n            calls   : " << multFullCalls;
+  os << " (" << 100 * (multFullCalls / (0.01 + iterations))
+     << "% of iterations)";
+  os << "\n  Colwise   time    : " << multTimeColwise;
 
-   os << "\n            calls   : " << multColwiseCalls;
-   os << " (" << 100 * (multColwiseCalls / (0.01 + iterations)) << "% of iterations)";
-   os << "\n  Unsetup   time    : " << multTimeUnsetup;
+  if (solTime > 0)
+    os << " (" << 100 * (multTimeColwise / solTime) << "% of solving time)";
 
-   if(solTime > 0)
-      os << " (" << 100 * (multTimeUnsetup / solTime) << "% of solving time)";
+  os << "\n            calls   : " << multColwiseCalls;
+  os << " (" << 100 * (multColwiseCalls / (0.01 + iterations))
+     << "% of iterations)";
+  os << "\n  Unsetup   time    : " << multTimeUnsetup;
 
-   os << "\n            calls   : " << multUnsetupCalls;
-   os << " (" << 100 * (multUnsetupCalls / (0.01 + iterations)) << "% of iterations)";
-   os << "\n";
+  if (solTime > 0)
+    os << " (" << 100 * (multTimeUnsetup / solTime) << "% of solving time)";
 
-   os << "Rat. factorizations : " << luFactorizationsRational << "\n"
-      << "  Rat. factor. time : " << luFactorizationTimeRational << "\n"
-      << "  Rat. solve time   : " << luSolveTimeRational << "\n";
+  os << "\n            calls   : " << multUnsetupCalls;
+  os << " (" << 100 * (multUnsetupCalls / (0.01 + iterations))
+     << "% of iterations)";
+  os << "\n";
 
-   os << "Rat. reconstructions: " << rationalReconstructions << "\n"
-      << "  Rat. rec. time    : " << reconstructionTime->time() << "\n";
+  os << "Rat. factorizations : " << luFactorizationsRational << "\n"
+     << "  Rat. factor. time : " << luFactorizationTimeRational << "\n"
+     << "  Rat. solve time   : " << luSolveTimeRational << "\n";
 
-   os << "Degeneracy          : \n";
-   os << "  Primal Pivots     : " << degenPivotsPrimal << "\n";
-   os << "  Dual Pivots       : " << degenPivotsDual << "\n";
-   os << "  Primal Candidates : " << degenPivotCandPrimal << "\n";
-   os << "  Dual Candidates   : " << degenPivotCandDual << "\n";
-   os << "  Average Primal    : " << avgPrimalDegeneracy << "\n";
-   os << "  Average Dual      : " << avgDualDegeneracy << "\n";
+  os << "Rat. reconstructions: " << rationalReconstructions << "\n"
+     << "  Rat. rec. time    : " << reconstructionTime->time() << "\n";
 
-   if(iterationsInit > 0)
-   {
-      os << "Algorithm Iterations: " << callsReducedProb << "\n";
-      os << "Decomp. Iterations  : \n";
-      os << "  Total             : " << iterationsInit + iterationsRedProb << "\n";
-      os << "  Initial           : " << iterationsInit << "\n";
-      os << "  Reduced Problem   : " << iterationsRedProb << "\n";
-      os << "  Comp. Problem     : " << iterationsCompProb << "\n";
-      os << "Red. Problem Size   : \n";
-      os << "  Rows              : " << numRedProbRows << "\n";
-      os << "  Columns           : " << numRedProbCols << "\n";
+  os << "Degeneracy          : \n";
+  os << "  Primal Pivots     : " << degenPivotsPrimal << "\n";
+  os << "  Dual Pivots       : " << degenPivotsDual << "\n";
+  os << "  Primal Candidates : " << degenPivotCandPrimal << "\n";
+  os << "  Dual Candidates   : " << degenPivotCandDual << "\n";
+  os << "  Average Primal    : " << avgPrimalDegeneracy << "\n";
+  os << "  Average Dual      : " << avgDualDegeneracy << "\n";
 
-      SPxOut::setScientific(os, 16);
+  if (iterationsInit > 0) {
+    os << "Algorithm Iterations: " << callsReducedProb << "\n";
+    os << "Decomp. Iterations  : \n";
+    os << "  Total             : " << iterationsInit + iterationsRedProb
+       << "\n";
+    os << "  Initial           : " << iterationsInit << "\n";
+    os << "  Reduced Problem   : " << iterationsRedProb << "\n";
+    os << "  Comp. Problem     : " << iterationsCompProb << "\n";
+    os << "Red. Problem Size   : \n";
+    os << "  Rows              : " << numRedProbRows << "\n";
+    os << "  Columns           : " << numRedProbCols << "\n";
 
-      os << "Decomp. Basis Cond. : " << decompBasisCondNum << "\n";
-      os << "Decomp Violations   : \n";
-      os << "  Sum Bound         : " << totalBoundViol << "\n";
-      os << "  Sum Row           : " << totalRowViol << "\n";
-      os << "  Max Bound         : " << maxBoundViol << "\n";
-      os << "  Max Row           : " << maxRowViol << "\n";
+    SPxOut::setScientific(os, 16);
 
-      SPxOut::setFixed(os, 2);
+    os << "Decomp. Basis Cond. : " << decompBasisCondNum << "\n";
+    os << "Decomp Violations   : \n";
+    os << "  Sum Bound         : " << totalBoundViol << "\n";
+    os << "  Sum Row           : " << totalRowViol << "\n";
+    os << "  Max Bound         : " << maxBoundViol << "\n";
+    os << "  Max Row           : " << maxRowViol << "\n";
 
-      os << "Red. Problem Status : " << redProbStatus << "\n";
-      os << "Comp. Problem Status: " << compProbStatus << "\n";
+    SPxOut::setFixed(os, 2);
 
-      SPxOut::setScientific(os, 16);
+    os << "Red. Problem Status : " << redProbStatus << "\n";
+    os << "Comp. Problem Status: " << compProbStatus << "\n";
 
-      os << "Comp. Problem Obj.  : " << finalCompObj << "\n";
-   }
+    SPxOut::setScientific(os, 16);
 
-   SPxOut::setScientific(os);
+    os << "Comp. Problem Obj.  : " << finalCompObj << "\n";
+  }
 
-   os << "Numerics            :\n";
-   os << "  Condition Number  : " << finalBasisCondition << "\n";
+  SPxOut::setScientific(os);
 
+  os << "Numerics            :\n";
+  os << "  Condition Number  : " << finalBasisCondition << "\n";
 }
 } // namespace soplex
diff --git a/src/soplex/svectorbase.h b/src/soplex/svectorbase.h
index 4fa44dc..bfb03ea 100644
--- a/src/soplex/svectorbase.h
+++ b/src/soplex/svectorbase.h
@@ -28,81 +28,69 @@
 #ifndef _SVECTORBASE_H_
 #define _SVECTORBASE_H_
 
-#include <iostream>
+#include "soplex/stablesum.h"
 #include <assert.h>
-#include <math.h>
 #include <cmath>
-#include "soplex/stablesum.h"
+#include <iostream>
+#include <math.h>
 
-namespace soplex
-{
-template < class R > class VectorBase;
-template < class R > class SSVectorBase;
+namespace soplex {
+template <class R> class VectorBase;
+template <class R> class SSVectorBase;
 
 /// Sparse vector nonzero element.
-/** SVectorBase keeps its nonzeros in an array of Nonzero%s providing members for saving the index and value.
+/** SVectorBase keeps its nonzeros in an array of Nonzero%s providing members
+ * for saving the index and value.
  */
-template < class R >
-class Nonzero
-{
+template <class R> class Nonzero {
 public:
+  R val;   ///< Value of nonzero element.
+  int idx; ///< Index of nonzero element.
 
-   R val;        ///< Value of nonzero element.
-   int idx;      ///< Index of nonzero element.
-
-   template < class S >
-   Nonzero<R>& operator=(const Nonzero<S>& vec)
-   {
-      // todo: is the cast really necessary? Previous code worked without a cast
-      val = (R) vec.val;
-      idx = vec.idx;
-      return *this;
-   }
-
-   template < class S >
-   Nonzero<R>(const Nonzero<S>& vec)
-      : val(vec.val)
-      , idx(vec.idx)
-   {
-   }
-
-   Nonzero<R>()
-      : val()
-      , idx(0)
-   {
-   }
-};
+  template <class S> Nonzero<R> &operator=(const Nonzero<S> &vec) {
+    // todo: is the cast really necessary? Previous code worked without a cast
+    val = (R)vec.val;
+    idx = vec.idx;
+    return *this;
+  }
 
+  template <class S>
+  Nonzero(const Nonzero<S> &vec) : val(vec.val), idx(vec.idx) {}
 
+  Nonzero() : val(), idx(0) {}
+};
 
 // specialized assignment operator
 template <>
-template < class S >
-Nonzero<Real>& Nonzero<Real>::operator=(const Nonzero<S>& vec)
-{
-   val = Real(vec.val);
-   idx = vec.idx;
-   return *this;
+template <class S>
+Nonzero<Real> &Nonzero<Real>::operator=(const Nonzero<S> &vec) {
+  val = Real(vec.val);
+  idx = vec.idx;
+  return *this;
 }
 
-
 /**@brief   Sparse vectors.
  * @ingroup Algebra
  *
- *  Class SVectorBase provides packed sparse vectors. Such are a sparse vectors, with a storage scheme that keeps all
- *  data in one contiguous block of memory.  This is best suited for using them for parallel computing on a distributed
+ *  Class SVectorBase provides packed sparse vectors. Such are a sparse vectors,
+ * with a storage scheme that keeps all data in one contiguous block of memory.
+ * This is best suited for using them for parallel computing on a distributed
  *  memory multiprocessor.
  *
- *  SVectorBase does not provide any memory management (this will be done by class DSVectorBase). This means, that the
- *  constructor of SVectorBase expects memory where to save the nonzeros. Further, adding nonzeros to an SVectorBase may
- *  fail if no more memory is available for saving them (see also DSVectorBase).
+ *  SVectorBase does not provide any memory management (this will be done by
+ * class DSVectorBase). This means, that the constructor of SVectorBase expects
+ * memory where to save the nonzeros. Further, adding nonzeros to an SVectorBase
+ * may fail if no more memory is available for saving them (see also
+ * DSVectorBase).
  *
- *  When nonzeros are added to an SVectorBase, they are appended to the set of nonzeros, i.e., they recieve numbers
- *  size(), size()+1 ... . An SVectorBase can hold atmost max() nonzeros, where max() is given in the constructor.  When
- *  removing nonzeros, the remaining nonzeros are renumbered. However, only the numbers greater than the number of the
- *  first removed nonzero are affected.
+ *  When nonzeros are added to an SVectorBase, they are appended to the set of
+ * nonzeros, i.e., they recieve numbers size(), size()+1 ... . An SVectorBase
+ * can hold atmost max() nonzeros, where max() is given in the constructor. When
+ *  removing nonzeros, the remaining nonzeros are renumbered. However, only the
+ * numbers greater than the number of the first removed nonzero are affected.
  *
- *  The following mathematical operations are provided by class SVectorBase (SVectorBase \p a, \p b, \p c; R \p x):
+ *  The following mathematical operations are provided by class SVectorBase
+ * (SVectorBase \p a, \p b, \p c; R \p x):
  *
  *  <TABLE>
  *  <TR><TD>Operation</TD><TD>Description   </TD><TD></TD>&nbsp;</TR>
@@ -119,799 +107,693 @@ Nonzero<Real>& Nonzero<Real>::operator=(const Nonzero<S>& vec)
  *      <TD>\c a.length2() == \f$a^2\f$ </TD></TR>
  *  </TABLE>
  *
- *  Operators \c += and \c -= should be used with caution, since no efficient implementation is available. One should
- *  think of assigning the left handside vector to a dense VectorBase first and perform the addition on it. The same
+ *  Operators \c += and \c -= should be used with caution, since no efficient
+ * implementation is available. One should think of assigning the left handside
+ * vector to a dense VectorBase first and perform the addition on it. The same
  *  applies to the scalar product \c *.
  *
- *  There are two numberings of the nonzeros of an SVectorBase. First, an SVectorBase is supposed to act like a linear
- *  algebra VectorBase. An \em index refers to this view of an SVectorBase: operator[]() is provided which returns the
- *  value at the given index of the vector, i.e., 0 for all indices which are not in the set of nonzeros.  The other view
- *  of SVectorBase%s is that of a set of nonzeros. The nonzeros are numbered from 0 to size()-1.  The methods index(int
- *  n) and value(int n) allow to access the index and value of the \p n 'th nonzero.  \p n is referred to as the \em
- *  number of a nonzero.
+ *  There are two numberings of the nonzeros of an SVectorBase. First, an
+ * SVectorBase is supposed to act like a linear algebra VectorBase. An \em index
+ * refers to this view of an SVectorBase: operator[]() is provided which returns
+ * the value at the given index of the vector, i.e., 0 for all indices which are
+ * not in the set of nonzeros.  The other view of SVectorBase%s is that of a set
+ * of nonzeros. The nonzeros are numbered from 0 to size()-1.  The methods
+ * index(int n) and value(int n) allow to access the index and value of the \p n
+ * 'th nonzero.  \p n is referred to as the \em number of a nonzero.
  *
- *  @todo SVectorBase should get a new implementation.  There maybe a lot of memory lost due to padding the Nonzero
- *        structure. A better idea seems to be class SVectorBase { int size; int used; int* idx; R* val; }; which for
- *        several reasons could be faster or slower.  If SVectorBase is changed, also DSVectorBase and SVSet have to be
- *        modified.
+ *  @todo SVectorBase should get a new implementation.  There maybe a lot of
+ * memory lost due to padding the Nonzero structure. A better idea seems to be
+ * class SVectorBase { int size; int used; int* idx; R* val; }; which for
+ *        several reasons could be faster or slower.  If SVectorBase is changed,
+ * also DSVectorBase and SVSet have to be modified.
  */
-template < class R >
-class SVectorBase
-{
-   template < class S > friend class SVectorBase;
+template <class R> class SVectorBase {
+  template <class S> friend class SVectorBase;
 
 private:
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Data */
+  ///@{
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Data */
-   ///@{
+  Nonzero<R> *m_elem;
+  int memsize;
+  int memused;
 
-   Nonzero<R>* m_elem;
-   int memsize;
-   int memused;
-
-   ///@}
+  ///@}
 
 public:
-
-   typedef Nonzero<R> Element;
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Access */
-   ///@{
-
-   /// Number of used indices.
-   int size() const
-   {
-      assert(m_elem != 0 || memused == 0);
-      return memused;
-   }
-
-   /// Maximal number of indices.
-   int max() const
-   {
-      assert(m_elem != 0 || memused == 0);
-      return memsize;
-   }
-
-   /// Dimension of the vector defined as maximal index + 1
-   int dim() const
-   {
-      const Nonzero<R>* e = m_elem;
-      int d = -1;
+  typedef Nonzero<R> Element;
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Access */
+  ///@{
+
+  /// Number of used indices.
+  int size() const {
+    assert(m_elem != 0 || memused == 0);
+    return memused;
+  }
+
+  /// Maximal number of indices.
+  int max() const {
+    assert(m_elem != 0 || memused == 0);
+    return memsize;
+  }
+
+  /// Dimension of the vector defined as maximal index + 1
+  int dim() const {
+    const Nonzero<R> *e = m_elem;
+    int d = -1;
+    int n = size();
+
+    while (n--) {
+      d = (d > e->idx) ? d : e->idx;
+      e++;
+    }
+
+    return d + 1;
+  }
+
+  /// Position of index \p i.
+  /** @return Finds the position of the first index \p i in the index set. If no
+   * such index \p i is found, -1 is returned. Otherwise, index(pos(i)) == i
+   * holds.
+   */
+  int pos(int i) const {
+    if (m_elem != 0) {
       int n = size();
 
-      while(n--)
-      {
-         d = (d > e->idx) ? d : e->idx;
-         e++;
+      for (int p = 0; p < n; ++p) {
+        if (m_elem[p].idx == i) {
+          assert(index(p) == i);
+          return p;
+        }
       }
+    }
 
-      return d + 1;
-   }
-
-   /// Position of index \p i.
-   /** @return Finds the position of the first index \p i in the index set. If no such index \p i is found,
-    *          -1 is returned. Otherwise, index(pos(i)) == i holds.
-    */
-   int pos(int i) const
-   {
-      if(m_elem != 0)
-      {
-         int n = size();
-
-         for(int p = 0; p < n; ++p)
-         {
-            if(m_elem[p].idx == i)
-            {
-               assert(index(p) == i);
-               return p;
-            }
-         }
-      }
+    return -1;
+  }
 
-      return -1;
-   }
+  /// Value to index \p i.
+  R operator[](int i) const {
+    int n = pos(i);
 
-   /// Value to index \p i.
-   R operator[](int i) const
-   {
-      int n = pos(i);
+    if (n >= 0)
+      return m_elem[n].val;
 
-      if(n >= 0)
-         return m_elem[n].val;
+    return 0;
+  }
 
-      return 0;
-   }
+  /// Reference to the \p n 'th nonzero element.
+  Nonzero<R> &element(int n) {
+    assert(n >= 0);
+    assert(n < max());
 
-   /// Reference to the \p n 'th nonzero element.
-   Nonzero<R>& element(int n)
-   {
-      assert(n >= 0);
-      assert(n < max());
+    return m_elem[n];
+  }
 
-      return m_elem[n];
-   }
+  /// The \p n 'th nonzero element.
+  const Nonzero<R> &element(int n) const {
+    assert(n >= 0);
+    assert(n < size());
 
-   /// The \p n 'th nonzero element.
-   const Nonzero<R>& element(int n) const
-   {
-      assert(n >= 0);
-      assert(n < size());
+    return m_elem[n];
+  }
 
-      return m_elem[n];
-   }
+  /// Reference to index of \p n 'th nonzero.
+  int &index(int n) {
+    assert(n >= 0);
+    assert(n < size());
 
-   /// Reference to index of \p n 'th nonzero.
-   int& index(int n)
-   {
-      assert(n >= 0);
-      assert(n < size());
+    return m_elem[n].idx;
+  }
 
-      return m_elem[n].idx;
-   }
+  /// Index of \p n 'th nonzero.
+  int index(int n) const {
+    assert(n >= 0);
+    assert(n < size());
 
-   /// Index of \p n 'th nonzero.
-   int index(int n) const
-   {
-      assert(n >= 0);
-      assert(n < size());
+    return m_elem[n].idx;
+  }
 
-      return m_elem[n].idx;
-   }
+  /// Reference to value of \p n 'th nonzero.
+  R &value(int n) {
+    assert(n >= 0);
+    assert(n < size());
 
-   /// Reference to value of \p n 'th nonzero.
-   R& value(int n)
-   {
-      assert(n >= 0);
-      assert(n < size());
+    return m_elem[n].val;
+  }
 
-      return m_elem[n].val;
-   }
+  /// Value of \p n 'th nonzero.
+  const R &value(int n) const {
+    assert(n >= 0);
+    assert(n < size());
 
-   /// Value of \p n 'th nonzero.
-   const R& value(int n) const
-   {
-      assert(n >= 0);
-      assert(n < size());
+    return m_elem[n].val;
+  }
 
-      return m_elem[n].val;
-   }
+  /// Append one nonzero \p (i,v).
+  void add(int i, const R &v) {
+    assert(m_elem != 0);
+    assert(size() < max());
 
-   /// Append one nonzero \p (i,v).
-   void add(int i, const R& v)
-   {
-      assert(m_elem != 0);
-      assert(size() < max());
+    if (v != 0.0) {
+      int n = size();
 
-      if(v != 0.0)
-      {
-         int n = size();
+      m_elem[n].idx = i;
+      m_elem[n].val = v;
+      set_size(n + 1);
 
-         m_elem[n].idx = i;
-         m_elem[n].val = v;
-         set_size(n + 1);
+      assert(size() <= max());
+    }
+  }
 
-         assert(size() <= max());
-      }
-   }
+  /// Append one uninitialized nonzero.
+  void add(int i) {
+    assert(m_elem != 0);
+    assert(size() < max());
 
-   /// Append one uninitialized nonzero.
-   void add(int i)
-   {
-      assert(m_elem != 0);
-      assert(size() < max());
+    int n = size();
 
-      int n = size();
+    m_elem[n].idx = i;
+    set_size(n + 1);
 
-      m_elem[n].idx = i;
-      set_size(n + 1);
+    assert(size() <= max());
+  }
 
-      assert(size() <= max());
-   }
-
-   /// Append nonzeros of \p sv.
-   void add(const SVectorBase& sv)
-   {
-      add(sv.size(), sv.m_elem);
-   }
-
-   /// Append \p n nonzeros.
-   void add(int n, const int i[], const R v[])
-   {
-      assert(n + size() <= max());
-
-      if(n <= 0)
-         return;
-
-      int newnnz = 0;
-
-      Nonzero<R>* e = m_elem + size();
-
-      while(n--)
-      {
-         if(*v != 0.0)
-         {
-            assert(e != nullptr);
-            e->idx = *i;
-            e->val = *v;
-            e++;
-            ++newnnz;
-         }
-
-         i++;
-         v++;
+  /// Append nonzeros of \p sv.
+  void add(const SVectorBase &sv) { add(sv.size(), sv.m_elem); }
+
+  /// Append \p n nonzeros.
+  void add(int n, const int i[], const R v[]) {
+    assert(n + size() <= max());
+
+    if (n <= 0)
+      return;
+
+    int newnnz = 0;
+
+    Nonzero<R> *e = m_elem + size();
+
+    while (n--) {
+      if (*v != 0.0) {
+        assert(e != nullptr);
+        e->idx = *i;
+        e->val = *v;
+        e++;
+        ++newnnz;
       }
 
-      set_size(size() + newnnz);
-   }
+      i++;
+      v++;
+    }
 
-   /// Append \p n nonzeros.
-   template < class S >
-   void add(int n, const int i[], const S v[])
-   {
-      assert(n + size() <= max());
+    set_size(size() + newnnz);
+  }
 
-      if(n <= 0)
-         return;
+  /// Append \p n nonzeros.
+  template <class S> void add(int n, const int i[], const S v[]) {
+    assert(n + size() <= max());
 
-      int newnnz = 0;
+    if (n <= 0)
+      return;
 
-      Nonzero<R>* e = m_elem + size();
+    int newnnz = 0;
 
-      while(n--)
-      {
-         if(*v != R(0.0))
-         {
-            e->idx = *i;
-            e->val = *v;
-            e++;
-            ++newnnz;
-         }
+    Nonzero<R> *e = m_elem + size();
 
-         i++;
-         v++;
+    while (n--) {
+      if (*v != R(0.0)) {
+        e->idx = *i;
+        e->val = *v;
+        e++;
+        ++newnnz;
       }
 
-      set_size(size() + newnnz);
-   }
+      i++;
+      v++;
+    }
 
-   /// Append \p n nonzeros.
-   void add(int n, const Nonzero<R> e[])
-   {
-      assert(n + size() <= max());
+    set_size(size() + newnnz);
+  }
 
-      if(n <= 0)
-         return;
+  /// Append \p n nonzeros.
+  void add(int n, const Nonzero<R> e[]) {
+    assert(n + size() <= max());
 
-      int newnnz = 0;
+    if (n <= 0)
+      return;
 
-      Nonzero<R>* ee = m_elem + size();
+    int newnnz = 0;
 
-      while(n--)
-      {
-         if(e->val != 0.0)
-         {
-            *ee++ = *e;
-            ++newnnz;
-         }
+    Nonzero<R> *ee = m_elem + size();
 
-         e++;
+    while (n--) {
+      if (e->val != 0.0) {
+        *ee++ = *e;
+        ++newnnz;
       }
 
-      set_size(size() + newnnz);
-   }
+      e++;
+    }
 
-   /// Remove nonzeros \p n thru \p m.
-   void remove(int n, int m)
-   {
-      assert(n <= m);
-      assert(m < size());
-      assert(n >= 0);
+    set_size(size() + newnnz);
+  }
 
-      ++m;
+  /// Remove nonzeros \p n thru \p m.
+  void remove(int n, int m) {
+    assert(n <= m);
+    assert(m < size());
+    assert(n >= 0);
 
-      int cpy = m - n;
-      cpy = (size() - m >= cpy) ? cpy : size() - m;
+    ++m;
 
-      Nonzero<R>* e = &m_elem[size() - 1];
-      Nonzero<R>* r = &m_elem[n];
+    int cpy = m - n;
+    cpy = (size() - m >= cpy) ? cpy : size() - m;
 
-      set_size(size() - cpy);
+    Nonzero<R> *e = &m_elem[size() - 1];
+    Nonzero<R> *r = &m_elem[n];
 
-      do
-      {
-         *r++ = *e--;
-      }
-      while(--cpy);
-   }
-
-   /// Remove \p n 'th nonzero.
-   void remove(int n)
-   {
-      assert(n >= 0);
-      assert(n < size());
-
-      int newsize = size() - 1;
-      set_size(newsize);
-
-      if(n < newsize)
-         m_elem[n] = m_elem[newsize];
-   }
-
-   /// Remove all indices.
-   void clear()
-   {
-      set_size(0);
-   }
-
-   /// Sort nonzeros to increasing indices.
-   void sort()
-   {
-      if(m_elem != 0)
-      {
-         Nonzero<R> dummy;
-         Nonzero<R>* w;
-         Nonzero<R>* l;
-         Nonzero<R>* s = &(m_elem[0]);
-         Nonzero<R>* e = s + size();
-
-         for(l = s, w = s + 1; w < e; l = w, ++w)
-         {
-            if(l->idx > w->idx)
-            {
-               dummy = *w;
-
-               do
-               {
-                  l[1] = *l;
-
-                  if(l-- == s)
-                     break;
-               }
-               while(l->idx > dummy.idx);
-
-               l[1] = dummy;
-            }
-         }
-      }
-   }
+    set_size(size() - cpy);
 
-   ///@}
+    do {
+      *r++ = *e--;
+    } while (--cpy);
+  }
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Arithmetic operations */
-   ///@{
+  /// Remove \p n 'th nonzero.
+  void remove(int n) {
+    assert(n >= 0);
+    assert(n < size());
 
-   /// Maximum absolute value, i.e., infinity norm.
-   R maxAbs() const
-   {
-      R maxi = 0;
+    int newsize = size() - 1;
+    set_size(newsize);
 
-      for(int i = size() - 1; i >= 0; --i)
-      {
-         if(spxAbs(m_elem[i].val) > maxi)
-            maxi = spxAbs(m_elem[i].val);
-      }
+    if (n < newsize)
+      m_elem[n] = m_elem[newsize];
+  }
+
+  /// Remove all indices.
+  void clear() { set_size(0); }
 
-      assert(maxi >= 0);
+  /// Sort nonzeros to increasing indices.
+  void sort() {
+    if (m_elem != 0) {
+      Nonzero<R> dummy;
+      Nonzero<R> *w;
+      Nonzero<R> *l;
+      Nonzero<R> *s = &(m_elem[0]);
+      Nonzero<R> *e = s + size();
 
-      return maxi;
-   }
+      for (l = s, w = s + 1; w < e; l = w, ++w) {
+        if (l->idx > w->idx) {
+          dummy = *w;
 
-   /// Minimum absolute value.
-   R minAbs() const
-   {
-      R mini = R(infinity);
+          do {
+            l[1] = *l;
 
-      for(int i = size() - 1; i >= 0; --i)
-      {
-         if(spxAbs(m_elem[i].val) < mini)
-            mini = spxAbs(m_elem[i].val);
+            if (l-- == s)
+              break;
+          } while (l->idx > dummy.idx);
+
+          l[1] = dummy;
+        }
       }
+    }
+  }
 
-      assert(mini >= 0);
+  ///@}
 
-      return mini;
-   }
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Arithmetic operations */
+  ///@{
 
-   /// Floating point approximation of euclidian norm (without any approximation guarantee).
-   R length() const
-   {
-      return std::sqrt(R(length2()));
-   }
+  /// Maximum absolute value, i.e., infinity norm.
+  R maxAbs() const {
+    R maxi = 0;
 
-   /// Squared norm.
-   R length2() const
-   {
-      R x = 0;
-      int n = size();
-      const Nonzero<R>* e = m_elem;
+    for (int i = size() - 1; i >= 0; --i) {
+      if (spxAbs(m_elem[i].val) > maxi)
+        maxi = spxAbs(m_elem[i].val);
+    }
 
-      while(n--)
-      {
-         x += e->val * e->val;
-         e++;
-      }
+    assert(maxi >= 0);
 
-      return x;
-   }
+    return maxi;
+  }
 
-   /// Scaling.
-   SVectorBase<R>& operator*=(const R& x)
-   {
-      int n = size();
-      Nonzero<R>* e = m_elem;
+  /// Minimum absolute value.
+  R minAbs() const {
+    R mini = R(infinity);
 
-      assert(x != 0);
+    for (int i = size() - 1; i >= 0; --i) {
+      if (spxAbs(m_elem[i].val) < mini)
+        mini = spxAbs(m_elem[i].val);
+    }
 
-      while(n--)
-      {
-         e->val *= x;
-         e++;
-      }
+    assert(mini >= 0);
 
-      return *this;
-   }
+    return mini;
+  }
 
-   /// Inner product.
-   R operator*(const VectorBase<R>& w) const;
+  /// Floating point approximation of euclidian norm (without any approximation
+  /// guarantee).
+  R length() const { return std::sqrt(R(length2())); }
 
-   /// inner product for sparse vectors
-   template < class S >
-   R operator*(const SVectorBase<S>& w) const
-   {
-      StableSum<R> x;
-      int n = size();
-      int m = w.size();
-
-      if(n == 0 || m == 0)
-         return x;
-
-      int i = 0;
-      int j = 0;
-      Element* e = m_elem;
-      typename SVectorBase<S>::Element wj = w.element(j);
-
-      while(true)
-      {
-         if(e->idx == wj.idx)
-         {
-            x += e->val * wj.val;
-            i++;
-            j++;
-
-            if(i == n || j == m)
-               break;
-
-            e++;
-            wj = w.element(j);
-         }
-         else if(e->idx < wj.idx)
-         {
-            i++;
-
-            if(i == n)
-               break;
-
-            e++;
-         }
-         else
-         {
-            j++;
-
-            if(j == m)
-               break;
-
-            wj = w.element(j);
-         }
-      }
+  /// Squared norm.
+  R length2() const {
+    R x = 0;
+    int n = size();
+    const Nonzero<R> *e = m_elem;
+
+    while (n--) {
+      x += e->val * e->val;
+      e++;
+    }
+
+    return x;
+  }
+
+  /// Scaling.
+  SVectorBase<R> &operator*=(const R &x) {
+    int n = size();
+    Nonzero<R> *e = m_elem;
+
+    assert(x != 0);
+
+    while (n--) {
+      e->val *= x;
+      e++;
+    }
+
+    return *this;
+  }
 
+  /// Inner product.
+  R operator*(const VectorBase<R> &w) const;
+
+  /// inner product for sparse vectors
+  template <class S> R operator*(const SVectorBase<S> &w) const {
+    StableSum<R> x;
+    int n = size();
+    int m = w.size();
+
+    if (n == 0 || m == 0)
       return x;
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Constructions, destruction, and assignment */
-   ///@{
-
-   /// Default constructor.
-   /** The constructor expects one memory block where to store the nonzero elements. This must be passed to the
-    *  constructor, where the \em number of Nonzero%s needs that fit into the memory must be given and a pointer to the
-    *  beginning of the memory block. Once this memory has been passed, it shall not be modified until the SVectorBase
-    *  is no longer used.
-    */
-   explicit SVectorBase<R>(int n = 0, Nonzero<R>* p_mem = 0)
-   {
-      setMem(n, p_mem);
-   }
-
-   SVectorBase<R>(const SVectorBase<R>& sv) = default;
-
-   /// Assignment operator.
-   template < class S >
-   SVectorBase<R>& operator=(const VectorBase<S>& vec);
-
-   /// Assignment operator.
-   SVectorBase<R>& operator=(const SVectorBase<R>& sv)
-   {
-      if(this != &sv)
-      {
-         assert(max() >= sv.size());
-
-         int i = sv.size();
-         int nnz = 0;
-         Nonzero<R>* e = m_elem;
-         const Nonzero<R>* s = sv.m_elem;
-
-         while(i--)
-         {
-            assert(e != 0);
-
-            if(s->val != 0.0)
-            {
-               *e++ = *s;
-               ++nnz;
-            }
-
-            ++s;
-         }
-
-         set_size(nnz);
+
+    int i = 0;
+    int j = 0;
+    Element *e = m_elem;
+    typename SVectorBase<S>::Element wj = w.element(j);
+
+    while (true) {
+      if (e->idx == wj.idx) {
+        x += e->val * wj.val;
+        i++;
+        j++;
+
+        if (i == n || j == m)
+          break;
+
+        e++;
+        wj = w.element(j);
+      } else if (e->idx < wj.idx) {
+        i++;
+
+        if (i == n)
+          break;
+
+        e++;
+      } else {
+        j++;
+
+        if (j == m)
+          break;
+
+        wj = w.element(j);
       }
+    }
+
+    return x;
+  }
+
+  ///@}
 
-      return *this;
-   }
-
-   /// move assignement operator.
-   SVectorBase<R>& operator=(const SVectorBase<R>&& sv)
-   {
-      if(this != &sv)
-      {
-         this->m_elem = sv.m_elem;
-         this->memsize = sv.memsize;
-         this->memused = sv.memused;
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Constructions, destruction, and assignment */
+  ///@{
+
+  /// Default constructor.
+  /** The constructor expects one memory block where to store the nonzero
+   * elements. This must be passed to the constructor, where the \em number of
+   * Nonzero%s needs that fit into the memory must be given and a pointer to the
+   *  beginning of the memory block. Once this memory has been passed, it shall
+   * not be modified until the SVectorBase is no longer used.
+   */
+  explicit SVectorBase(int n = 0, Nonzero<R> *p_mem = 0) { setMem(n, p_mem); }
+
+  SVectorBase(const SVectorBase<R> &sv) = default;
+
+  /// Assignment operator.
+  template <class S> SVectorBase<R> &operator=(const VectorBase<S> &vec);
+
+  /// Assignment operator.
+  SVectorBase<R> &operator=(const SVectorBase<R> &sv) {
+    if (this != &sv) {
+      assert(max() >= sv.size());
+
+      int i = sv.size();
+      int nnz = 0;
+      Nonzero<R> *e = m_elem;
+      const Nonzero<R> *s = sv.m_elem;
+
+      while (i--) {
+        assert(e != 0);
+
+        if (s->val != 0.0) {
+          *e++ = *s;
+          ++nnz;
+        }
+
+        ++s;
       }
 
-      return *this;
-   }
+      set_size(nnz);
+    }
+
+    return *this;
+  }
 
-   /// Assignment operator.
-   template < class S >
-   SVectorBase<R>& operator=(const SVectorBase<S>& sv)
-   {
-      if(this != (const SVectorBase<R>*)(&sv))
-      {
-         assert(max() >= sv.size());
+  /// move assignement operator.
+  SVectorBase<R> &operator=(const SVectorBase<R> &&sv) {
+    if (this != &sv) {
+      this->m_elem = sv.m_elem;
+      this->memsize = sv.memsize;
+      this->memused = sv.memused;
+    }
 
-         int i = sv.size();
-         int nnz = 0;
-         Nonzero<R>* e = m_elem;
-         const Nonzero<S>* s = sv.m_elem;
+    return *this;
+  }
 
-         while(i--)
-         {
-            assert(e != 0);
+  /// Assignment operator.
+  template <class S> SVectorBase<R> &operator=(const SVectorBase<S> &sv) {
+    if (this != (const SVectorBase<R> *)(&sv)) {
+      assert(max() >= sv.size());
 
-            if(s->val != 0.0)
-            {
-               *e++ = *s;
-               ++nnz;
-            }
+      int i = sv.size();
+      int nnz = 0;
+      Nonzero<R> *e = m_elem;
+      const Nonzero<S> *s = sv.m_elem;
 
-            ++s;
-         }
+      while (i--) {
+        assert(e != 0);
 
-         set_size(nnz);
+        if (s->val != 0.0) {
+          *e++ = *s;
+          ++nnz;
+        }
+
+        ++s;
       }
 
-      return *this;
-   }
+      set_size(nnz);
+    }
 
-   /// scale and assign
-   SVectorBase<Real>& scaleAssign(int scaleExp, const SVectorBase<Real>& sv)
-   {
-      if(this != &sv)
-      {
-         assert(max() >= sv.size());
+    return *this;
+  }
 
-         for(int i = 0; i < sv.size(); ++i)
-         {
-            m_elem[i].val = spxLdexp(sv.value(i), scaleExp);
-            m_elem[i].idx = sv.index(i);
-         }
+  /// scale and assign
+  SVectorBase<Real> &scaleAssign(int scaleExp, const SVectorBase<Real> &sv) {
+    if (this != &sv) {
+      assert(max() >= sv.size());
 
-         assert(isConsistent());
+      for (int i = 0; i < sv.size(); ++i) {
+        m_elem[i].val = spxLdexp(sv.value(i), scaleExp);
+        m_elem[i].idx = sv.index(i);
       }
 
-      return *this;
-   }
-
-   /// scale and assign
-   SVectorBase<Real>& scaleAssign(const int* scaleExp, const SVectorBase<Real>& sv,
-                                  bool negateExp = false)
-   {
-      if(this != &sv)
-      {
-         assert(max() >= sv.size());
-
-         if(negateExp)
-         {
-            for(int i = 0; i < sv.size(); ++i)
-            {
-               m_elem[i].val = spxLdexp(sv.value(i), -scaleExp[sv.index(i)]);
-               m_elem[i].idx = sv.index(i);
-            }
-         }
-         else
-         {
-            for(int i = 0; i < sv.size(); ++i)
-            {
-               m_elem[i].val = spxLdexp(sv.value(i), scaleExp[sv.index(i)]);
-               m_elem[i].idx = sv.index(i);
-            }
-         }
-
-         assert(isConsistent());
+      assert(isConsistent());
+    }
+
+    return *this;
+  }
+
+  /// scale and assign
+  SVectorBase<Real> &scaleAssign(const int *scaleExp,
+                                 const SVectorBase<Real> &sv,
+                                 bool negateExp = false) {
+    if (this != &sv) {
+      assert(max() >= sv.size());
+
+      if (negateExp) {
+        for (int i = 0; i < sv.size(); ++i) {
+          m_elem[i].val = spxLdexp(sv.value(i), -scaleExp[sv.index(i)]);
+          m_elem[i].idx = sv.index(i);
+        }
+      } else {
+        for (int i = 0; i < sv.size(); ++i) {
+          m_elem[i].val = spxLdexp(sv.value(i), scaleExp[sv.index(i)]);
+          m_elem[i].idx = sv.index(i);
+        }
       }
 
-      return *this;
-   }
+      assert(isConsistent());
+    }
 
+    return *this;
+  }
 
-   /// Assignment operator.
-   template < class S >
-   SVectorBase<R>& assignArray(const S* rowValues, const int* rowIndices, int rowSize)
-   {
-      assert(max() >= rowSize);
+  /// Assignment operator.
+  template <class S>
+  SVectorBase<R> &assignArray(const S *rowValues, const int *rowIndices,
+                              int rowSize) {
+    assert(max() >= rowSize);
 
-      int i;
+    int i;
 
-      for(i = 0; i < rowSize && i < max(); i++)
-      {
-         m_elem[i].val = rowValues[i];
-         m_elem[i].idx = rowIndices[i];
-      }
+    for (i = 0; i < rowSize && i < max(); i++) {
+      m_elem[i].val = rowValues[i];
+      m_elem[i].idx = rowIndices[i];
+    }
+
+    set_size(i);
 
-      set_size(i);
-
-      return *this;
-   }
-
-   /// Assignment operator.
-   template < class S >
-   SVectorBase<R>& operator=(const SSVectorBase<S>& sv);
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Memory */
-   ///@{
-
-   /// get pointer to internal memory.
-   Nonzero<R>* mem() const
-   {
-      return m_elem;
-   }
-
-   /// Set size of the vector.
-   void set_size(int s)
-   {
-      assert(m_elem != 0 || s == 0);
-      memused = s;
-   }
-
-   /// Set the maximum number of nonzeros in the vector.
-   void set_max(int m)
-   {
-      assert(m_elem != 0 || m == 0);
-      memsize = m;
-   }
-
-   /// Set the memory area where the nonzeros will be stored.
-   void setMem(int n, Nonzero<R>* elmem)
-   {
-      assert(n >= 0);
-      assert(n == 0 || elmem != 0);
-
-      m_elem = elmem;
-      set_size(0);
-      set_max(n);
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Utilities */
-   ///@{
-
-   /// Consistency check.
-   bool isConsistent() const
-   {
+    return *this;
+  }
+
+  /// Assignment operator.
+  template <class S> SVectorBase<R> &operator=(const SSVectorBase<S> &sv);
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Memory */
+  ///@{
+
+  /// get pointer to internal memory.
+  Nonzero<R> *mem() const { return m_elem; }
+
+  /// Set size of the vector.
+  void set_size(int s) {
+    assert(m_elem != 0 || s == 0);
+    memused = s;
+  }
+
+  /// Set the maximum number of nonzeros in the vector.
+  void set_max(int m) {
+    assert(m_elem != 0 || m == 0);
+    memsize = m;
+  }
+
+  /// Set the memory area where the nonzeros will be stored.
+  void setMem(int n, Nonzero<R> *elmem) {
+    assert(n >= 0);
+    assert(n == 0 || elmem != 0);
+
+    m_elem = elmem;
+    set_size(0);
+    set_max(n);
+  }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Utilities */
+  ///@{
+
+  /// Consistency check.
+  bool isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
 
-      if(m_elem != 0)
-      {
-         const int my_size = size();
-         const int my_max = max();
+    if (m_elem != 0) {
+      const int my_size = size();
+      const int my_max = max();
 
-         if(my_size < 0 || my_max < 0 || my_size > my_max)
-            return MSGinconsistent("SVectorBase");
+      if (my_size < 0 || my_max < 0 || my_size > my_max)
+        return MSGinconsistent("SVectorBase");
 
-         for(int i = 1; i < my_size; ++i)
-         {
-            for(int j = 0; j < i; ++j)
-            {
-               // allow trailing zeros
-               if(m_elem[i].idx == m_elem[j].idx && m_elem[i].val != 0)
-                  return MSGinconsistent("SVectorBase");
-            }
-         }
+      for (int i = 1; i < my_size; ++i) {
+        for (int j = 0; j < i; ++j) {
+          // allow trailing zeros
+          if (m_elem[i].idx == m_elem[j].idx && m_elem[i].val != 0)
+            return MSGinconsistent("SVectorBase");
+        }
       }
+    }
 
 #endif
 
-      return true;
-   }
+    return true;
+  }
 
-   ///@}
+  ///@}
 };
 
-
-
 /// specialization for inner product for sparse vectors
 template <>
-template < class S >
-Real SVectorBase<Real>::operator*(const SVectorBase<S>& w) const
-{
-   StableSum<Real> x;
-   int n = size();
-   int m = w.size();
-
-   if(n == 0 || m == 0)
-      return Real(0);
-
-   int i = 0;
-   int j = 0;
-   SVectorBase<Real>::Element* e = m_elem;
-   typename SVectorBase<S>::Element wj = w.element(j);
-
-   while(true)
-   {
-      if(e->idx == wj.idx)
-      {
-         x += e->val * Real(wj.val);
-         i++;
-         j++;
-
-         if(i == n || j == m)
-            break;
-
-         e++;
-         wj = w.element(j);
-      }
-      else if(e->idx < wj.idx)
-      {
-         i++;
+template <class S>
+Real SVectorBase<Real>::operator*(const SVectorBase<S> &w) const {
+  StableSum<Real> x;
+  int n = size();
+  int m = w.size();
 
-         if(i == n)
-            break;
+  if (n == 0 || m == 0)
+    return Real(0);
 
-         e++;
-      }
-      else
-      {
-         j++;
+  int i = 0;
+  int j = 0;
+  SVectorBase<Real>::Element *e = m_elem;
+  typename SVectorBase<S>::Element wj = w.element(j);
 
-         if(j == m)
-            break;
+  while (true) {
+    if (e->idx == wj.idx) {
+      x += e->val * Real(wj.val);
+      i++;
+      j++;
 
-         wj = w.element(j);
-      }
-   }
+      if (i == n || j == m)
+        break;
+
+      e++;
+      wj = w.element(j);
+    } else if (e->idx < wj.idx) {
+      i++;
+
+      if (i == n)
+        break;
+
+      e++;
+    } else {
+      j++;
+
+      if (j == m)
+        break;
+
+      wj = w.element(j);
+    }
+  }
 
-   return x;
+  return x;
 }
 
 } // namespace soplex
diff --git a/src/soplex/svsetbase.h b/src/soplex/svsetbase.h
index c38152f..5ddc1ee 100644
--- a/src/soplex/svsetbase.h
+++ b/src/soplex/svsetbase.h
@@ -29,7 +29,8 @@
 #ifndef _SVSETBASE_H_
 #define _SVSETBASE_H_
 
-/* undefine SOPLEX_DEBUG flag from including files; if SOPLEX_DEBUG should be defined in this file, do so below */
+/* undefine SOPLEX_DEBUG flag from including files; if SOPLEX_DEBUG should be
+ * defined in this file, do so below */
 #ifdef SOPLEX_DEBUG
 #define SOPLEX_DEBUG_SVSETBASE
 #undef SOPLEX_DEBUG
@@ -37,1057 +38,969 @@
 
 #include <assert.h>
 
-#include "soplex/spxdefines.h"
-#include "soplex/svectorbase.h"
 #include "soplex/classarray.h"
-#include "soplex/dataset.h"
 #include "soplex/classset.h"
 #include "soplex/datakey.h"
+#include "soplex/dataset.h"
 #include "soplex/idlist.h"
+#include "soplex/spxdefines.h"
+#include "soplex/svectorbase.h"
 
-namespace soplex
-{
+namespace soplex {
 /**@brief   Sparse vector set.
  * @ingroup Algebra
  *
- *   Class SVSetBase provides a set of sparse vectors SVectorBase. All SVectorBase%s in an SVSetBase share one big
- *   memory block for their nonzeros. This memory is referred to as the \em nonzero \em memory. The SVectorBase%s
- *   themselves are saved in another memory block referred to as the \em vector \em memory. Both memory blocks will grow
- *   automatically if required, when adding more SVectorBase%s to the set or enlarging SVectorBase%s within the set. For
- *   controlling memory consumption, methods are provided to inquire and reset the size of the memory blocks used for
- *   vectors and nonzeros.
+ *   Class SVSetBase provides a set of sparse vectors SVectorBase. All
+ * SVectorBase%s in an SVSetBase share one big memory block for their nonzeros.
+ * This memory is referred to as the \em nonzero \em memory. The SVectorBase%s
+ *   themselves are saved in another memory block referred to as the \em vector
+ * \em memory. Both memory blocks will grow automatically if required, when
+ * adding more SVectorBase%s to the set or enlarging SVectorBase%s within the
+ * set. For controlling memory consumption, methods are provided to inquire and
+ * reset the size of the memory blocks used for vectors and nonzeros.
  *
- *   SVectorBase%s in an SVSetBase are numbered from 0 thru num()-1. They can be accessed using the index
- *   operator[](). When removing SVectorBase%s of a SVSetBase the remaining ones will be renumbered. However, all
- *   SVectorBase with a smaller number than the lowest number of the removed SVectorBase%s will remain unchanged.
+ *   SVectorBase%s in an SVSetBase are numbered from 0 thru num()-1. They can be
+ * accessed using the index operator[](). When removing SVectorBase%s of a
+ * SVSetBase the remaining ones will be renumbered. However, all SVectorBase
+ * with a smaller number than the lowest number of the removed SVectorBase%s
+ * will remain unchanged.
  *
- *   For providing a uniform access to SVectorBase%s in a %set even if others are removed or added, SVSetBase assigns a
- *   DataKey to each SVectorBase in the %set. Such a DataKey remains unchanged as long as the corresponding SVectorBase
- *   is in the SVSetBase, no matter what other SVectorBase%s are added to or removed from the SVSetBase. Methods are
- *   provided for getting the DataKey to a SVectorBase or its number and vice versa.  Further, each add() method for
- *   enlarging an SVSetBase is provided with two signatures. One of them returns the DataKey%s assigned to the
- *   SVectorBase%s added to the SVSetBase.
+ *   For providing a uniform access to SVectorBase%s in a %set even if others
+ * are removed or added, SVSetBase assigns a DataKey to each SVectorBase in the
+ * %set. Such a DataKey remains unchanged as long as the corresponding
+ * SVectorBase is in the SVSetBase, no matter what other SVectorBase%s are added
+ * to or removed from the SVSetBase. Methods are provided for getting the
+ * DataKey to a SVectorBase or its number and vice versa.  Further, each add()
+ * method for enlarging an SVSetBase is provided with two signatures. One of
+ * them returns the DataKey%s assigned to the SVectorBase%s added to the
+ * SVSetBase.
  */
-template < class R >
-class SVSetBase : protected ClassArray < Nonzero<R> >
-{
-   template < class S > friend class SVSetBase;
+template <class R> class SVSetBase : protected ClassArray<Nonzero<R>> {
+  template <class S> friend class SVSetBase;
 
 private:
-
-   typedef ClassArray < Nonzero<R> > SVSetBaseArray;
-
-   /**@class DLPSV
-    * @brief SVectorBase with prev/next pointers
-    * @todo  Check whether SVSetBase::DLPSV can be implemented as IdElement<SVectorBase>
-    *
-    *  The management of the SVectorBase%s is implemented by a DataSet<DLPSV>, the keys used externally are DataKey%s.
-    *
-    *  The management of nonzeros is done by a Real linked list IdList<DLPSV>, where the SVectorBase%s are kept in the
-    *  order in which their indices occurr in the Array. The SVectorBase%s are kept without holes: If one is removed or
-    *  moved to the end, the SVectorBase preceeding it obtains the space for all the nonzeros that previously belonged
-    *  to the (re-)moved one.  However, the nonzeros in use are uneffected by this.
-    */
-   class DLPSV : public SVectorBase<R>
-   {
-   private:
-
-      // ---------------------------------------------------------------------------------------------------------------
-      /**@name Data */
-      ///@{
-
-      DLPSV* thenext; ///< next SVectorBase
-      DLPSV* theprev; ///< previous SVectorBase
-
-      ///@}
-
-   public:
-
-      // ---------------------------------------------------------------------------------------------------------------
-      /**@name Construction / destruction */
-      ///@{
-
-      /// Default constructor.
-      DLPSV()
-         : SVectorBase<R>()
-      {}
-
-      /// Copy constructor.
-      DLPSV(const DLPSV& copy)
-         : SVectorBase<R>(copy)
-      {}
-
-      DLPSV(DLPSV&& copy)
-         : SVectorBase<R>(copy)
-      {}
-
-      DLPSV& operator=(DLPSV&& rhs)
-      {
-         SVectorBase<R>::operator=(std::move(rhs));
-
-         if(this != & rhs)
-         {
-            this->thenext = rhs.thenext;
-            this->theprev = rhs.theprev;
-         }
-
-         return *this;
+  typedef ClassArray<Nonzero<R>> SVSetBaseArray;
+
+  /**@class DLPSV
+   * @brief SVectorBase with prev/next pointers
+   * @todo  Check whether SVSetBase::DLPSV can be implemented as
+   * IdElement<SVectorBase>
+   *
+   *  The management of the SVectorBase%s is implemented by a DataSet<DLPSV>,
+   * the keys used externally are DataKey%s.
+   *
+   *  The management of nonzeros is done by a Real linked list IdList<DLPSV>,
+   * where the SVectorBase%s are kept in the order in which their indices occurr
+   * in the Array. The SVectorBase%s are kept without holes: If one is removed
+   * or moved to the end, the SVectorBase preceeding it obtains the space for
+   * all the nonzeros that previously belonged to the (re-)moved one.  However,
+   * the nonzeros in use are uneffected by this.
+   */
+  class DLPSV : public SVectorBase<R> {
+  private:
+    // ---------------------------------------------------------------------------------------------------------------
+    /**@name Data */
+    ///@{
+
+    DLPSV *thenext; ///< next SVectorBase
+    DLPSV *theprev; ///< previous SVectorBase
+
+    ///@}
+
+  public:
+    // ---------------------------------------------------------------------------------------------------------------
+    /**@name Construction / destruction */
+    ///@{
+
+    /// Default constructor.
+    DLPSV() : SVectorBase<R>() {}
+
+    /// Copy constructor.
+    DLPSV(const DLPSV &copy) : SVectorBase<R>(copy) {}
+
+    DLPSV(DLPSV &&copy) : SVectorBase<R>(copy) {}
+
+    DLPSV &operator=(DLPSV &&rhs) {
+      SVectorBase<R>::operator=(std::move(rhs));
+
+      if (this != &rhs) {
+        this->thenext = rhs.thenext;
+        this->theprev = rhs.theprev;
       }
-      ///@}
 
-      // ---------------------------------------------------------------------------------------------------------------
-      /**@name Successor / predecessor */
-      ///@{
+      return *this;
+    }
+    ///@}
 
-      /// Next SVectorBase.
-      DLPSV*& next()
-      {
-         return thenext;
-      }
+    // ---------------------------------------------------------------------------------------------------------------
+    /**@name Successor / predecessor */
+    ///@{
 
-      /// Next SVectorBase.
-      DLPSV* const& next() const
-      {
-         return thenext;
-      }
+    /// Next SVectorBase.
+    DLPSV *&next() { return thenext; }
 
-      /// Previous SVectorBase.
-      DLPSV* const& prev() const
-      {
-         return theprev;
-      }
+    /// Next SVectorBase.
+    DLPSV *const &next() const { return thenext; }
 
-      /// Previous SVectorBase.
-      DLPSV*& prev()
-      {
-         return theprev;
-      }
+    /// Previous SVectorBase.
+    DLPSV *const &prev() const { return theprev; }
+
+    /// Previous SVectorBase.
+    DLPSV *&prev() { return theprev; }
 
-      ///@}
-   };
+    ///@}
+  };
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Data */
-   ///@{
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Data */
+  ///@{
 
-   ClassSet < DLPSV > set;  ///< %set of SVectorBase%s
-   IdList < DLPSV > list;  ///< doubly linked list for non-zero management
-   int unusedMem;  ///< an estimate of the unused memory (the difference of max() and size() summed up over all vectors) due to deleteVec() and xtend()
-   int numUnusedMemUpdates;  ///< counter for how often unusedMem has been updated since last exact value
+  ClassSet<DLPSV> set; ///< %set of SVectorBase%s
+  IdList<DLPSV> list;  ///< doubly linked list for non-zero management
+  int unusedMem; ///< an estimate of the unused memory (the difference of max()
+                 ///< and size() summed up over all vectors) due to deleteVec()
+                 ///< and xtend()
+  int numUnusedMemUpdates; ///< counter for how often unusedMem has been updated
+                           ///< since last exact value
 
-   ///@}
+  ///@}
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Control Parameters */
-   ///@{
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Control Parameters */
+  ///@{
 
-   double factor;          ///< sparse vector memory enlargment factor
+  double factor; ///< sparse vector memory enlargment factor
 
-   ///@}
+  ///@}
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Helpers */
-   ///@{
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Helpers */
+  ///@{
 
-   /// count size of unused memory exactly
-   void countUnusedMem()
-   {
+  /// count size of unused memory exactly
+  void countUnusedMem() {
 #ifdef SOPLEX_DEBUG
-      MSG_DEBUG(std::cout << "counting unused memory (unusedMem = " << unusedMem <<
-                ", numUnusedMemUpdates = " << numUnusedMemUpdates << ", this = " << (void*)this << ")\n");
+    MSG_DEBUG(std::cout << "counting unused memory (unusedMem = " << unusedMem
+                        << ", numUnusedMemUpdates = " << numUnusedMemUpdates
+                        << ", this = " << (void *)this << ")\n");
 #endif
 
-      unusedMem = memSize();
+    unusedMem = memSize();
 
-      for(DLPSV* ps = list.first(); ps; ps = list.next(ps))
-         unusedMem -= ps->size();
+    for (DLPSV *ps = list.first(); ps; ps = list.next(ps))
+      unusedMem -= ps->size();
 
-      numUnusedMemUpdates = 0;
+    numUnusedMemUpdates = 0;
 
 #ifdef SOPLEX_DEBUG
-      MSG_DEBUG(std::cout << "               --> NEW: unusedMem = " << unusedMem << "\n");
+    MSG_DEBUG(std::cout << "               --> NEW: unusedMem = " << unusedMem
+                        << "\n");
 #endif
-   }
-
-   /// update estimation of unused memory
-   void updateUnusedMemEstimation(int change)
-   {
-      unusedMem += change;
-      numUnusedMemUpdates++;
-
-      if(unusedMem < 0 || unusedMem > memSize() || numUnusedMemUpdates >= 1000000)
-         countUnusedMem();
-   }
-
-   /// Provides enough vector memory for \p n more SVectorBase%s.
-   void ensurePSVec(int n)
-   {
-      if(num() + n > max())
-      {
-         assert(factor > 1);
-
-         reMax(int(factor * max()) + 8 + n);
-      }
-   }
-
-   /// Provides enough nonzero memory for \p n more Nonzero%s.
-   void ensureMem(int n, bool shortenLast = true)
-   {
-      if(memSize() + n <= memMax())
-         return;
-
-      if(list.last() && shortenLast)
-      {
-         // get last vector and compute its unused memory
-         DLPSV* ps = list.last();
-         int unusedPsMem = ps->max() - ps->size();
-         assert(unusedPsMem >= 0);
-
-         // return vector's unused memory to common memory
-         SVSetBaseArray::removeLast(unusedPsMem);
-         ps->set_max(ps->size());
-
-         // decrease counter of unused memory
+  }
+
+  /// update estimation of unused memory
+  void updateUnusedMemEstimation(int change) {
+    unusedMem += change;
+    numUnusedMemUpdates++;
+
+    if (unusedMem < 0 || unusedMem > memSize() ||
+        numUnusedMemUpdates >= 1000000)
+      countUnusedMem();
+  }
+
+  /// Provides enough vector memory for \p n more SVectorBase%s.
+  void ensurePSVec(int n) {
+    if (num() + n > max()) {
+      assert(factor > 1);
+
+      reMax(int(factor * max()) + 8 + n);
+    }
+  }
+
+  /// Provides enough nonzero memory for \p n more Nonzero%s.
+  void ensureMem(int n, bool shortenLast = true) {
+    if (memSize() + n <= memMax())
+      return;
+
+    if (list.last() && shortenLast) {
+      // get last vector and compute its unused memory
+      DLPSV *ps = list.last();
+      int unusedPsMem = ps->max() - ps->size();
+      assert(unusedPsMem >= 0);
+
+      // return vector's unused memory to common memory
+      SVSetBaseArray::removeLast(unusedPsMem);
+      ps->set_max(ps->size());
+
+      // decrease counter of unused memory
 #ifdef SOPLEX_DEBUG
-         MSG_DEBUG(std::cout << "ensureMem, this = " << (void*)this << ": updateUnusedMemEstimation -= " <<
-                   unusedPsMem << "\n");
+      MSG_DEBUG(std::cout << "ensureMem, this = " << (void *)this
+                          << ": updateUnusedMemEstimation -= " << unusedPsMem
+                          << "\n");
 #endif
-         updateUnusedMemEstimation(-unusedPsMem);
-      }
+      updateUnusedMemEstimation(-unusedPsMem);
+    }
 
-      // if the missing memory can be acquired by packing the memory, we prefer this to allocating new memory
-      int missingMem = (memSize() + n - memMax());
+    // if the missing memory can be acquired by packing the memory, we prefer
+    // this to allocating new memory
+    int missingMem = (memSize() + n - memMax());
 
-      ///@todo use an independent parameter "memwastefactor" here
-      if(missingMem > 0 && missingMem <= unusedMem
-            && unusedMem > (SVSetBaseArray::memFactor - 1.0) * memMax())
-         memPack();
+    ///@todo use an independent parameter "memwastefactor" here
+    if (missingMem > 0 && missingMem <= unusedMem &&
+        unusedMem > (SVSetBaseArray::memFactor - 1.0) * memMax())
+      memPack();
 
-      // if the unused memory was overestimated and packing did not help, we need to reallocate
-      if(memSize() + n > memMax())
-      {
-         int newMax = int(SVSetBaseArray::memFactor * memMax());
+    // if the unused memory was overestimated and packing did not help, we need
+    // to reallocate
+    if (memSize() + n > memMax()) {
+      int newMax = int(SVSetBaseArray::memFactor * memMax());
 
-         if(memSize() + n > newMax)
-            newMax = memSize() + n;
+      if (memSize() + n > newMax)
+        newMax = memSize() + n;
 
-         memRemax(newMax);
-      }
-   }
+      memRemax(newMax);
+    }
+  }
 
-   /// Deleting a vector from the data array and the list.
-   void deleteVec(DLPSV* ps)
-   {
-      /* delete last entries */
-      if(ps == list.last())
-      {
-         SVSetBaseArray::removeLast(ps->max());
+  /// Deleting a vector from the data array and the list.
+  void deleteVec(DLPSV *ps) {
+    /* delete last entries */
+    if (ps == list.last()) {
+      SVSetBaseArray::removeLast(ps->max());
 
-         // decrease counter of unused memory
+      // decrease counter of unused memory
 #ifdef SOPLEX_DEBUG
-         MSG_DEBUG(std::cout << "deleteVec (1), this = " << (void*)this << ": updateUnusedMemEstimation -= "
-                   << ps->max() - ps->size() << "\n");
+      MSG_DEBUG(std::cout << "deleteVec (1), this = " << (void *)this
+                          << ": updateUnusedMemEstimation -= "
+                          << ps->max() - ps->size() << "\n");
 #endif
-         updateUnusedMemEstimation(ps->size() - ps->max());
-      }
-      /* merge space of predecessor with position which will be deleted, therefore we do not need to delete any memory
-       * or do an expensive memory reallocation
-       */
-      else if(ps != list.first())
-      {
-         SVectorBase<R>* prev = ps->prev();
-         int sz = prev->size();
-
-         prev->setMem(prev->max() + ps->max(), prev->mem());
-         prev->set_size(sz);
-
-         // increase counter of unused memory
+      updateUnusedMemEstimation(ps->size() - ps->max());
+    }
+    /* merge space of predecessor with position which will be deleted, therefore
+     * we do not need to delete any memory or do an expensive memory
+     * reallocation
+     */
+    else if (ps != list.first()) {
+      SVectorBase<R> *prev = ps->prev();
+      int sz = prev->size();
+
+      prev->setMem(prev->max() + ps->max(), prev->mem());
+      prev->set_size(sz);
+
+      // increase counter of unused memory
 #ifdef SOPLEX_DEBUG
-         MSG_DEBUG(std::cout << "deleteVec (2), this = " << (void*)this << ": updateUnusedMemEstimation += "
-                   << ps->size() << "\n");
+      MSG_DEBUG(std::cout << "deleteVec (2), this = " << (void *)this
+                          << ": updateUnusedMemEstimation += " << ps->size()
+                          << "\n");
 #endif
-         updateUnusedMemEstimation(ps->size());
-      }
-      /* simply remove the front entries; we do not shift the second vector to the front, because we count the unused
-       * memory exactly and rely on the automatic call of memPack()
-       */
-      else
-      {
-         // increase counter of unused memory
+      updateUnusedMemEstimation(ps->size());
+    }
+    /* simply remove the front entries; we do not shift the second vector to the
+     * front, because we count the unused memory exactly and rely on the
+     * automatic call of memPack()
+     */
+    else {
+      // increase counter of unused memory
 #ifdef SOPLEX_DEBUG
-         MSG_DEBUG(std::cout << "deleteVec (3), this = " << (void*)this << ": updateUnusedMemEstimation += "
-                   << ps->size() << "\n");
+      MSG_DEBUG(std::cout << "deleteVec (3), this = " << (void *)this
+                          << ": updateUnusedMemEstimation += " << ps->size()
+                          << "\n");
 #endif
-         updateUnusedMemEstimation(ps->size());
-      }
+      updateUnusedMemEstimation(ps->size());
+    }
 
-      list.remove(ps);
-   }
+    list.remove(ps);
+  }
 
-   ///@}
+  ///@}
 
 public:
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Extension */
-   ///@{
-
-   /// Adds \p svec to the %set.
-   /** This includes copying its nonzeros to the sets nonzero memory and creating an additional SVectorBase entry in
-    *  vector memory. If neccessary, the memory blocks are enlarged appropriately.
-    */
-   void add(const SVectorBase<R>& svec)
-   {
-      // create empty vector
-      ensurePSVec(1);
-      SVectorBase<R>* new_svec = create(svec.size());
-
-      // assign values
-      *new_svec = svec;
-   }
-
-   /// Adds \p svec to SVSetBase.
-   /** Adds SVectorBase \p svec to the %set. This includes copying its nonzeros to the sets nonzero memory and creating
-    *  an additional SVectorBase entry in vector memory. If neccessary, the memory blocks are enlarged appropriately.
-    *
-    *  @return \p nkey contains the DataKey, that the SVSetBase has assosicated to the new SVectorBase.
-    */
-   void add(DataKey& nkey, const SVectorBase<R>& svec)
-   {
-      // create empty vector
-      ensurePSVec(1);
-      SVectorBase<R>* new_svec = create(nkey, svec.size());
-
-      // assign values
-      *new_svec = svec;
-   }
-
-   /// Adds \p svec to SVSetBase.
-   /** Adds SVectorBase \p svec to the %set. This includes copying its nonzeros to the sets nonzero memory and creating
-    *  an additional SVectorBase entry in vector memory. If neccessary, the memory blocks are enlarged appropriately.
-    *
-    *  @return \p nkey contains the DataKey, that the SVSetBase has assosicated to the new SVectorBase.
-    */
-   template < class S >
-   void add(DataKey& nkey, const S* rowValues, const int* rowIndices, int rowSize)
-   {
-      assert(rowSize <= 0 || rowIndices != 0);
-      assert(rowSize <= 0 || rowValues != 0);
-
-      // create empty vector
-      ensurePSVec(1);
-      SVectorBase<R>* new_svec = create(nkey, rowSize);
-
-      // assign values
-      if(rowSize > 0)
-         new_svec->assignArray(rowValues, rowIndices, rowSize);
-   }
-
-   /// Adds all \p n SVectorBase%s in the array \p svec to the %set.
-   /** @pre \p svec must hold at least \p n entries.
-    */
-   void add(const SVectorBase<R> svec[], int n)
-   {
-      assert(n >= 0);
-
-      int i;
-      int len;
-
-      for(i = len = 0; i < n; ++i)
-         len += svec[i].size();
-
-      ensurePSVec(n);
-      ensureMem(len);
-
-      for(i = 0; i < n; ++i)
-         *create(svec[i].size()) = svec[i];
-   }
-
-   /// Adds n SVectorBase%s to SVSetBase.
-   /** Adds all \p n SVectorBase%s in the array \p svec to the %set.
-    *
-    *  @return \p nkey contains the DataKey%s, that the SVSetBase has assosicated to the new SVectorBase%s.
-    *
-    *  @pre \p nkey must be large enough to fit \p n DataKey%s.
-    */
-   void add(DataKey nkey[], const SVectorBase<R> svec[], int n)
-   {
-      add(svec, n);
-
-      for(int i = num() - 1; --n; --i)
-         nkey[n] = key(i);
-   }
-
-   /// Adds all SVectorBase%s in \p pset to SVSetBase.
-   template < class S >
-   void add(const SVSetBase<S>& pset)
-   {
-      int i;
-      int n;
-      int len;
-
-      n = pset.num();
-
-      for(i = len = 0; i < n; ++i)
-         len += pset[i].size();
-
-      ensurePSVec(n);
-      ensureMem(len);
-
-      for(i = 0; i < n; ++i)
-         *create(pset[i].size()) = pset[i];
-   }
-
-   /// Adds all SVectorBase%s of \p pset to SVSetBase.
-   /** Adds all \p n SVectorBase%s in the \p pset to an SVSetBase.
-    *
-    * @return \p nkey contains the DataKey%s, that the SVSetBase has assosicated to the new SVectorBase%s.
-    *
-    * @pre \p nkey must be large enough to fit \p pset.num() DataKey%s.
-    */
-   template < class S >
-   void add(DataKey nkey[], const SVSetBase<S>& pset)
-   {
-      add(pset);
-
-      int i = num();
-      int n = pset.num();
-
-      while(n > 0)
-         nkey[--n] = key(--i);
-   }
-
-   /// Creates new SVectorBase in %set.
-   /** The new SVectorBase will be ready to fit at least \p idxmax nonzeros.
-    */
-   SVectorBase<R>* create(int idxmax = 0)
-   {
-      DLPSV* ps;
-
-      if(idxmax < 0)
-         idxmax = 0;
-
-      if(memSize() == 0 && idxmax <= 0)
-         idxmax = 1;
-
-      ensureMem(idxmax);
-
-      // resize the data array
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Extension */
+  ///@{
+
+  /// Adds \p svec to the %set.
+  /** This includes copying its nonzeros to the sets nonzero memory and creating
+   * an additional SVectorBase entry in vector memory. If neccessary, the memory
+   * blocks are enlarged appropriately.
+   */
+  void add(const SVectorBase<R> &svec) {
+    // create empty vector
+    ensurePSVec(1);
+    SVectorBase<R> *new_svec = create(svec.size());
+
+    // assign values
+    *new_svec = svec;
+  }
+
+  /// Adds \p svec to SVSetBase.
+  /** Adds SVectorBase \p svec to the %set. This includes copying its nonzeros
+   * to the sets nonzero memory and creating an additional SVectorBase entry in
+   * vector memory. If neccessary, the memory blocks are enlarged appropriately.
+   *
+   *  @return \p nkey contains the DataKey, that the SVSetBase has assosicated
+   * to the new SVectorBase.
+   */
+  void add(DataKey &nkey, const SVectorBase<R> &svec) {
+    // create empty vector
+    ensurePSVec(1);
+    SVectorBase<R> *new_svec = create(nkey, svec.size());
+
+    // assign values
+    *new_svec = svec;
+  }
+
+  /// Adds \p svec to SVSetBase.
+  /** Adds SVectorBase \p svec to the %set. This includes copying its nonzeros
+   * to the sets nonzero memory and creating an additional SVectorBase entry in
+   * vector memory. If neccessary, the memory blocks are enlarged appropriately.
+   *
+   *  @return \p nkey contains the DataKey, that the SVSetBase has assosicated
+   * to the new SVectorBase.
+   */
+  template <class S>
+  void add(DataKey &nkey, const S *rowValues, const int *rowIndices,
+           int rowSize) {
+    assert(rowSize <= 0 || rowIndices != 0);
+    assert(rowSize <= 0 || rowValues != 0);
+
+    // create empty vector
+    ensurePSVec(1);
+    SVectorBase<R> *new_svec = create(nkey, rowSize);
+
+    // assign values
+    if (rowSize > 0)
+      new_svec->assignArray(rowValues, rowIndices, rowSize);
+  }
+
+  /// Adds all \p n SVectorBase%s in the array \p svec to the %set.
+  /** @pre \p svec must hold at least \p n entries.
+   */
+  void add(const SVectorBase<R> svec[], int n) {
+    assert(n >= 0);
+
+    int i;
+    int len;
+
+    for (i = len = 0; i < n; ++i)
+      len += svec[i].size();
+
+    ensurePSVec(n);
+    ensureMem(len);
+
+    for (i = 0; i < n; ++i)
+      *create(svec[i].size()) = svec[i];
+  }
+
+  /// Adds n SVectorBase%s to SVSetBase.
+  /** Adds all \p n SVectorBase%s in the array \p svec to the %set.
+   *
+   *  @return \p nkey contains the DataKey%s, that the SVSetBase has assosicated
+   * to the new SVectorBase%s.
+   *
+   *  @pre \p nkey must be large enough to fit \p n DataKey%s.
+   */
+  void add(DataKey nkey[], const SVectorBase<R> svec[], int n) {
+    add(svec, n);
+
+    for (int i = num() - 1; --n; --i)
+      nkey[n] = key(i);
+  }
+
+  /// Adds all SVectorBase%s in \p pset to SVSetBase.
+  template <class S> void add(const SVSetBase<S> &pset) {
+    int i;
+    int n;
+    int len;
+
+    n = pset.num();
+
+    for (i = len = 0; i < n; ++i)
+      len += pset[i].size();
+
+    ensurePSVec(n);
+    ensureMem(len);
+
+    for (i = 0; i < n; ++i)
+      *create(pset[i].size()) = pset[i];
+  }
+
+  /// Adds all SVectorBase%s of \p pset to SVSetBase.
+  /** Adds all \p n SVectorBase%s in the \p pset to an SVSetBase.
+   *
+   * @return \p nkey contains the DataKey%s, that the SVSetBase has assosicated
+   * to the new SVectorBase%s.
+   *
+   * @pre \p nkey must be large enough to fit \p pset.num() DataKey%s.
+   */
+  template <class S> void add(DataKey nkey[], const SVSetBase<S> &pset) {
+    add(pset);
+
+    int i = num();
+    int n = pset.num();
+
+    while (n > 0)
+      nkey[--n] = key(--i);
+  }
+
+  /// Creates new SVectorBase in %set.
+  /** The new SVectorBase will be ready to fit at least \p idxmax nonzeros.
+   */
+  SVectorBase<R> *create(int idxmax = 0) {
+    DLPSV *ps;
+
+    if (idxmax < 0)
+      idxmax = 0;
+
+    if (memSize() == 0 && idxmax <= 0)
+      idxmax = 1;
+
+    ensureMem(idxmax);
+
+    // resize the data array
 #ifndef NDEBUG
-      Nonzero<R>* olddata = SVSetBaseArray::data;
-      SVSetBaseArray::reSize(memSize() + idxmax);
-      assert(olddata == SVSetBaseArray::data);
+    Nonzero<R> *olddata = SVSetBaseArray::data;
+    SVSetBaseArray::reSize(memSize() + idxmax);
+    assert(olddata == SVSetBaseArray::data);
 #else
-      SVSetBaseArray::reSize(memSize() + idxmax);
+    SVSetBaseArray::reSize(memSize() + idxmax);
 #endif
 
-      ensurePSVec(1);
-      ps = set.create();
-      list.append(ps);
-
-      ps->setMem(idxmax, &SVSetBaseArray::last() - idxmax + 1);
-
-      return ps;
-   }
-
-   /// Creates new SVectorBase in %set.
-   /** The new SVectorBase will be ready to fit at least \p idxmax nonzeros.
-    *
-    * @return \p nkey contains the DataKey associated to the new SVectorBase.
-    */
-   SVectorBase<R>* create(DataKey& nkey, int idxmax = -1)
-   {
-      SVectorBase<R>* ps = create(idxmax);
-
-      nkey = key(num() - 1);
-
-      return ps;
-   }
-
-   /// Extends \p svec to fit \p newmax nonzeros.
-   /** @pre \p svec must be an SVectorBase of the SVSetBase.
-    */
-   void xtend(SVectorBase<R>& svec, int newmax)
-   {
-      if(svec.max() < newmax)
-      {
-         assert(has(&svec));
-
-         DLPSV* ps = static_cast<DLPSV*>(&svec);
-         int sz = ps->size();
-
-         if(ps == list.last())
-         {
-            // because we want to extend the last vector we must not shrink its max memory usage
-            // in order to ensure the missing memory
-            ensureMem(newmax - ps->max(), false);
+    ensurePSVec(1);
+    ps = set.create();
+    list.append(ps);
+
+    ps->setMem(idxmax, &SVSetBaseArray::last() - idxmax + 1);
+
+    return ps;
+  }
+
+  /// Creates new SVectorBase in %set.
+  /** The new SVectorBase will be ready to fit at least \p idxmax nonzeros.
+   *
+   * @return \p nkey contains the DataKey associated to the new SVectorBase.
+   */
+  SVectorBase<R> *create(DataKey &nkey, int idxmax = -1) {
+    SVectorBase<R> *ps = create(idxmax);
+
+    nkey = key(num() - 1);
+
+    return ps;
+  }
+
+  /// Extends \p svec to fit \p newmax nonzeros.
+  /** @pre \p svec must be an SVectorBase of the SVSetBase.
+   */
+  void xtend(SVectorBase<R> &svec, int newmax) {
+    if (svec.max() < newmax) {
+      assert(has(&svec));
+
+      DLPSV *ps = static_cast<DLPSV *>(&svec);
+      int sz = ps->size();
+
+      if (ps == list.last()) {
+        // because we want to extend the last vector we must not shrink its max
+        // memory usage in order to ensure the missing memory
+        ensureMem(newmax - ps->max(), false);
 #ifndef NDEBUG
-            Nonzero<R>* olddata = SVSetBaseArray::data;
-            SVSetBaseArray::insert(memSize(), newmax - ps->max());
-            assert(olddata == SVSetBaseArray::data);
+        Nonzero<R> *olddata = SVSetBaseArray::data;
+        SVSetBaseArray::insert(memSize(), newmax - ps->max());
+        assert(olddata == SVSetBaseArray::data);
 #else
-            SVSetBaseArray::insert(memSize(), newmax - ps->max());
+        SVSetBaseArray::insert(memSize(), newmax - ps->max());
 #endif
 
-            // decrease counter of unused memory (assume that new entries will be used)
+        // decrease counter of unused memory (assume that new entries will be
+        // used)
 #ifdef SOPLEX_DEBUG
-            MSG_DEBUG(std::cout << "xtend (1), this = " << (void*)this << ": updateUnusedMemEstimation -= " <<
-                      ps->max() - sz << "\n");
+        MSG_DEBUG(std::cout << "xtend (1), this = " << (void *)this
+                            << ": updateUnusedMemEstimation -= "
+                            << ps->max() - sz << "\n");
 #endif
-            updateUnusedMemEstimation(sz - ps->max());
+        updateUnusedMemEstimation(sz - ps->max());
 
-            ps->setMem(newmax, ps->mem());
-            ps->set_size(sz);
-         }
-         else
-         {
-            ensureMem(newmax);
-            SVectorBase<R> newps(0, 0);
+        ps->setMem(newmax, ps->mem());
+        ps->set_size(sz);
+      } else {
+        ensureMem(newmax);
+        SVectorBase<R> newps(0, 0);
 
-            if(SVSetBaseArray::size() > 0)
-               newps.setMem(newmax, &SVSetBaseArray::last() + 1);
-            else
-               newps.setMem(newmax, SVSetBaseArray::get_ptr());
+        if (SVSetBaseArray::size() > 0)
+          newps.setMem(newmax, &SVSetBaseArray::last() + 1);
+        else
+          newps.setMem(newmax, SVSetBaseArray::get_ptr());
 
 #ifndef NDEBUG
-            Nonzero<R>* olddata = SVSetBaseArray::data;
-            SVSetBaseArray::insert(memSize(), newmax);
-            assert(olddata == SVSetBaseArray::data);
+        Nonzero<R> *olddata = SVSetBaseArray::data;
+        SVSetBaseArray::insert(memSize(), newmax);
+        assert(olddata == SVSetBaseArray::data);
 #else
-            SVSetBaseArray::insert(memSize(), newmax);
+        SVSetBaseArray::insert(memSize(), newmax);
 #endif
 
-            newps = svec;
+        newps = svec;
 
-            if(ps != list.first())
-            {
-               SVectorBase<R>* prev = ps->prev();
-               int prevsz = prev->size();
-               prev->setMem(prev->max() + ps->max(), prev->mem());
-               prev->set_size(prevsz);
-            }
+        if (ps != list.first()) {
+          SVectorBase<R> *prev = ps->prev();
+          int prevsz = prev->size();
+          prev->setMem(prev->max() + ps->max(), prev->mem());
+          prev->set_size(prevsz);
+        }
 
-            // increase counter of unused memory (assume that new entries will be used)
+        // increase counter of unused memory (assume that new entries will be
+        // used)
 #ifdef SOPLEX_DEBUG
-            MSG_DEBUG(std::cout << "xtend (2), this = " << (void*)this << ": updateUnusedMemEstimation += " <<
-                      ps->size() << "\n");
+        MSG_DEBUG(std::cout << "xtend (2), this = " << (void *)this
+                            << ": updateUnusedMemEstimation += " << ps->size()
+                            << "\n");
 #endif
-            updateUnusedMemEstimation(ps->size());
+        updateUnusedMemEstimation(ps->size());
 
-            list.remove(ps);
-            list.append(ps);
+        list.remove(ps);
+        list.append(ps);
 
-            ps->setMem(newmax, newps.mem());
-            ps->set_size(sz);
-         }
+        ps->setMem(newmax, newps.mem());
+        ps->set_size(sz);
       }
-   }
-
-   /// Adds nonzero (\p idx, \p val) to \p svec of this SVSetBase.
-   /** Adds one nonzero (\p idx, \p val) to SVectorBase \p svec in the SVSetBase.  If \p svec is not large enough to
-    *  hold the additional nonzero, it will be automatically enlarged within the %set.
-    *
-    *  @pre \p svec must be an SVectorBase of the SVSetBase.
-    */
-   void add2(SVectorBase<R>& svec, int idx, R val)
-   {
-      xtend(svec, svec.size() + 1);
-      svec.add(idx, val);
-   }
-
-   /// Adds \p n nonzeros to \p svec of this SVSetBase.
-   /** Adds \p n nonzeros to SVectorBase \p svec in the SVSetBase. If \p svec is not large enough to hold the additional
-    *  nonzeros, it will be automatically enlarged within the %set.
-    *
-    * @pre \p svec must be an SVectorBase of the SVSetBase.
-    */
-   void add2(SVectorBase<R>& svec, int n, const int idx[], const R val[])
-   {
-      xtend(svec, svec.size() + n);
-      svec.add(n, idx, val);
-   }
-
-   /// Adds \p n nonzeros to \p svec of this SVSetBase.
-   /** Adds \p n nonzeros to SVectorBase \p svec in the SVSetBase. If \p svec is not large enough to hold the additional
-    *  nonzeros, it will be automatically enlarged within the %set.
-    *
-    * @pre \p svec must be an SVectorBase of the SVSetBase.
-    */
-   template < class S >
-   void add2(SVectorBase<R>& svec, int n, const int idx[], const S val[])
-   {
-      xtend(svec, svec.size() + n);
-      svec.add(n, idx, val);
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Shrinking */
-   ///@{
-
-   /// Removes the vector with key \p removekey from the %set.
-   /** @pre \p removekey must be a key from SVSetBase
-    */
-   void remove(const DataKey& removekey)
-   {
-      deleteVec(&set[removekey]);
-      set.remove(removekey);
-   }
-
-   /// Removes the vector with number \p removenum from the %set.
-   /** @pre \p removenum must be a valid vector number from SVSetBase
-    */
-   void remove(int removenum)
-   {
-      remove(key(removenum));
-   }
-
-   /// Removes one SVectorBase from %set.
-   /** @pre \p svec must be from SVSetBase
-    */
-   void remove(const SVectorBase<R>* svec)
-   {
-      remove(key(svec));
-   }
-
-   /// Removes multiple elements.
-   /** Removes all SVectorBase%s for the SVSetBase with an index \c i such that \p perm[i] < 0. Upon completion, \p
-    *  perm[i] >= 0 indicates the new index where the \c i 'th SVectorBase has been moved to due to this removal.
-    *
-    *  @pre \p perm must point to an array of at least num() integers.
-    */
-   void remove(int perm[])
-   {
-      int j = num();
-
-      /* due to performance reasons we use a backwards loop to delete entries, because it could result instead of only
-       * decreasing the number of elements j times in memmoving the whole array j times
-       */
-      for(int i = j - 1; i >= 0; --i)
-      {
-         if(perm[i] < 0)
-         {
-            deleteVec(&set[i]);
-         }
+    }
+  }
+
+  /// Adds nonzero (\p idx, \p val) to \p svec of this SVSetBase.
+  /** Adds one nonzero (\p idx, \p val) to SVectorBase \p svec in the SVSetBase.
+   * If \p svec is not large enough to hold the additional nonzero, it will be
+   * automatically enlarged within the %set.
+   *
+   *  @pre \p svec must be an SVectorBase of the SVSetBase.
+   */
+  void add2(SVectorBase<R> &svec, int idx, R val) {
+    xtend(svec, svec.size() + 1);
+    svec.add(idx, val);
+  }
+
+  /// Adds \p n nonzeros to \p svec of this SVSetBase.
+  /** Adds \p n nonzeros to SVectorBase \p svec in the SVSetBase. If \p svec is
+   * not large enough to hold the additional nonzeros, it will be automatically
+   * enlarged within the %set.
+   *
+   * @pre \p svec must be an SVectorBase of the SVSetBase.
+   */
+  void add2(SVectorBase<R> &svec, int n, const int idx[], const R val[]) {
+    xtend(svec, svec.size() + n);
+    svec.add(n, idx, val);
+  }
+
+  /// Adds \p n nonzeros to \p svec of this SVSetBase.
+  /** Adds \p n nonzeros to SVectorBase \p svec in the SVSetBase. If \p svec is
+   * not large enough to hold the additional nonzeros, it will be automatically
+   * enlarged within the %set.
+   *
+   * @pre \p svec must be an SVectorBase of the SVSetBase.
+   */
+  template <class S>
+  void add2(SVectorBase<R> &svec, int n, const int idx[], const S val[]) {
+    xtend(svec, svec.size() + n);
+    svec.add(n, idx, val);
+  }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Shrinking */
+  ///@{
+
+  /// Removes the vector with key \p removekey from the %set.
+  /** @pre \p removekey must be a key from SVSetBase
+   */
+  void remove(const DataKey &removekey) {
+    deleteVec(&set[removekey]);
+    set.remove(removekey);
+  }
+
+  /// Removes the vector with number \p removenum from the %set.
+  /** @pre \p removenum must be a valid vector number from SVSetBase
+   */
+  void remove(int removenum) { remove(key(removenum)); }
+
+  /// Removes one SVectorBase from %set.
+  /** @pre \p svec must be from SVSetBase
+   */
+  void remove(const SVectorBase<R> *svec) { remove(key(svec)); }
+
+  /// Removes multiple elements.
+  /** Removes all SVectorBase%s for the SVSetBase with an index \c i such that
+   * \p perm[i] < 0. Upon completion, \p perm[i] >= 0 indicates the new index
+   * where the \c i 'th SVectorBase has been moved to due to this removal.
+   *
+   *  @pre \p perm must point to an array of at least num() integers.
+   */
+  void remove(int perm[]) {
+    int j = num();
+
+    /* due to performance reasons we use a backwards loop to delete entries,
+     * because it could result instead of only decreasing the number of elements
+     * j times in memmoving the whole array j times
+     */
+    for (int i = j - 1; i >= 0; --i) {
+      if (perm[i] < 0) {
+        deleteVec(&set[i]);
       }
+    }
+
+    set.remove(perm);
+  }
+
+  /// Removes \p n SVectorBase%s from %set.
+  /** @pre \p keys must be at least of size \p n and valid keys
+   */
+  void remove(const DataKey keys[], int n) {
+    DataArray<int> perm(num());
+    remove(keys, n, perm.get_ptr());
+  }
+
+  /// Removes \p n SVectorBase%s from %set.
+  /** @pre \p nums must be at least of size \p n and valid vector numbers
+   */
+  void remove(const int nums[], int n) {
+    DataArray<int> perm(num());
+    remove(nums, n, perm.get_ptr());
+  }
+
+  ///
+  void remove(const DataKey keys[], int n, int *perm) {
+    for (int i = num() - 1; i >= 0; --i)
+      perm[i] = i;
+
+    while (n--)
+      perm[number(*keys++)] = -1;
+
+    remove(perm);
+  }
+
+  /** Removes \p n SVectorBase%s from %set.
+   * @pre    \p nums must be at least of size \p n
+   * @pre    \p perm must be at least of size num()
+   * @return \p perm is the permutations resulting from this removal: \p perm[i]
+   * < 0 indicates that the element to index \p i has been removed. Otherwise,
+   * \p perm[i] is the new index of the element with index \p i before the
+   * removal.
+   */
+  void remove(const int nums[], int n, int *perm) {
+    for (int i = num() - 1; i >= 0; --i)
+      perm[i] = i;
 
-      set.remove(perm);
-   }
-
-   /// Removes \p n SVectorBase%s from %set.
-   /** @pre \p keys must be at least of size \p n and valid keys
-    */
-   void remove(const DataKey keys[], int n)
-   {
-      DataArray < int > perm(num());
-      remove(keys, n, perm.get_ptr());
-   }
-
-   /// Removes \p n SVectorBase%s from %set.
-   /** @pre \p nums must be at least of size \p n and valid vector numbers
-    */
-   void remove(const int nums[], int n)
-   {
-      DataArray < int > perm(num());
-      remove(nums, n, perm.get_ptr());
-   }
-
-   ///
-   void remove(const DataKey keys[], int n, int* perm)
-   {
-      for(int i = num() - 1; i >= 0; --i)
-         perm[i] = i;
-
-      while(n--)
-         perm[number(*keys++)] = -1;
-
-      remove(perm);
-   }
-
-   /** Removes \p n SVectorBase%s from %set.
-    * @pre    \p nums must be at least of size \p n
-    * @pre    \p perm must be at least of size num()
-    * @return \p perm is the permutations resulting from this removal: \p perm[i] < 0 indicates
-    *   that the element to index \p i has been removed. Otherwise, \p perm[i] is the new
-    *   index of the element with index \p i before the removal.
-    */
-   void remove(const int nums[], int n, int* perm)
-   {
-      for(int i = num() - 1; i >= 0; --i)
-         perm[i] = i;
-
-      while(n--)
-         perm[*nums++] = -1;
-
-      remove(perm);
-   }
-
-   /// Removes all SVectorBase%s from %set.
-   void clear(int minNewSize = -1)
-   {
-      SVSetBaseArray::clear();
-
-      if(minNewSize <= 0)
-      {
-         if(SVSetBaseArray::max() > 10000)
-            SVSetBaseArray::reMax(10000);
-      }
-      else
-      {
-         if(SVSetBaseArray::max() > minNewSize + 10000)
-            SVSetBaseArray::reMax(minNewSize);
-      }
+    while (n--)
+      perm[*nums++] = -1;
 
-      set.clear();
-      list.clear();
-      unusedMem = 0;
-      numUnusedMemUpdates = 0;
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Access */
-   ///@{
-
-   /// Gets SVectorBase by number, writeable.
-   SVectorBase<R>& operator[](int n)
-   {
-      return set[n];
-   }
-
-   /// Gets SVectorBase by number.
-   const SVectorBase<R>& operator[](int n) const
-   {
-      return set[n];
-   }
-
-   /// Gets SVectorBase by DataKey, writeable.
-   SVectorBase<R>& operator[](const DataKey& k)
-   {
-      return set[k];
-   }
-
-   /// Gets SVectorBase by DataKey.
-   const SVectorBase<R>& operator[](const DataKey& k) const
-   {
-      return set[k];
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Inquiry */
-   ///@{
-
-   /// Current number of SVectorBase%s.
-   int num() const
-   {
-      return set.num();
-   }
-
-   /// Current maximum number of SVectorBase%s.
-   int max() const
-   {
-      return set.max();
-   }
-
-   /// Gets DataKey of vector number.
-   DataKey key(int n) const
-   {
-      return set.key(n);
-   }
-
-   /// Gets DataKey of SVectorBase.
-   DataKey key(const SVectorBase<R>* svec) const
-   {
-      return set.key(static_cast<const DLPSV*>(svec));
-   }
-
-   /// Gets vector number of DataKey.
-   int number(const DataKey& k) const
-   {
-      return set.number(k);
-   }
-
-   /// Gets vector number of SVectorBase.
-   int number(const SVectorBase<R>* svec) const
-   {
-      return set.number(static_cast<const DLPSV*>(svec));
-   }
-
-   /// True iff SVSetBase contains a SVectorBase for DataKey \p k.
-   bool has(const DataKey& k) const
-   {
-      return set.has(k);
-   }
-
-   /// True iff SVSetBase contains a SVectorBase for vector number n.
-   bool has(int n) const
-   {
-      return set.has(n);
-   }
-
-   /// Is an SVectorBase in the %set?
-   bool has(const SVectorBase<R>* svec) const
-   {
-      return set.has(static_cast<const DLPSV*>(svec));
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Memory Management */
-   ///@{
-
-   /// Used nonzero memory.
-   int memSize() const
-   {
-      return SVSetBaseArray::size();
-   }
-
-   /// Length of nonzero memory.
-   int memMax() const
-   {
-      return SVSetBaseArray::max();
-   }
-
-   /// Reset length of nonzero memory.
-   void memRemax(int newmax)
-   {
-      ptrdiff_t delta = SVSetBaseArray::reMax(newmax);
-
-      if(delta != 0)
-      {
+    remove(perm);
+  }
+
+  /// Removes all SVectorBase%s from %set.
+  void clear(int minNewSize = -1) {
+    SVSetBaseArray::clear();
+
+    if (minNewSize <= 0) {
+      if (SVSetBaseArray::max() > 10000)
+        SVSetBaseArray::reMax(10000);
+    } else {
+      if (SVSetBaseArray::max() > minNewSize + 10000)
+        SVSetBaseArray::reMax(minNewSize);
+    }
+
+    set.clear();
+    list.clear();
+    unusedMem = 0;
+    numUnusedMemUpdates = 0;
+  }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Access */
+  ///@{
+
+  /// Gets SVectorBase by number, writeable.
+  SVectorBase<R> &operator[](int n) { return set[n]; }
+
+  /// Gets SVectorBase by number.
+  const SVectorBase<R> &operator[](int n) const { return set[n]; }
+
+  /// Gets SVectorBase by DataKey, writeable.
+  SVectorBase<R> &operator[](const DataKey &k) { return set[k]; }
+
+  /// Gets SVectorBase by DataKey.
+  const SVectorBase<R> &operator[](const DataKey &k) const { return set[k]; }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Inquiry */
+  ///@{
+
+  /// Current number of SVectorBase%s.
+  int num() const { return set.num(); }
+
+  /// Current maximum number of SVectorBase%s.
+  int max() const { return set.max(); }
+
+  /// Gets DataKey of vector number.
+  DataKey key(int n) const { return set.key(n); }
+
+  /// Gets DataKey of SVectorBase.
+  DataKey key(const SVectorBase<R> *svec) const {
+    return set.key(static_cast<const DLPSV *>(svec));
+  }
+
+  /// Gets vector number of DataKey.
+  int number(const DataKey &k) const { return set.number(k); }
+
+  /// Gets vector number of SVectorBase.
+  int number(const SVectorBase<R> *svec) const {
+    return set.number(static_cast<const DLPSV *>(svec));
+  }
+
+  /// True iff SVSetBase contains a SVectorBase for DataKey \p k.
+  bool has(const DataKey &k) const { return set.has(k); }
+
+  /// True iff SVSetBase contains a SVectorBase for vector number n.
+  bool has(int n) const { return set.has(n); }
+
+  /// Is an SVectorBase in the %set?
+  bool has(const SVectorBase<R> *svec) const {
+    return set.has(static_cast<const DLPSV *>(svec));
+  }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Memory Management */
+  ///@{
+
+  /// Used nonzero memory.
+  int memSize() const { return SVSetBaseArray::size(); }
+
+  /// Length of nonzero memory.
+  int memMax() const { return SVSetBaseArray::max(); }
+
+  /// Reset length of nonzero memory.
+  void memRemax(int newmax) {
+    ptrdiff_t delta = SVSetBaseArray::reMax(newmax);
+
+    if (delta != 0) {
 #ifdef SOPLEX_DEBUG
-         MSG_DEBUG(std::cout << "counting unused memory (unusedMem = " << unusedMem <<
-                   ", numUnusedMemUpdates = " << numUnusedMemUpdates << ", this = " << (void*)this << ")\n");
+      MSG_DEBUG(std::cout << "counting unused memory (unusedMem = " << unusedMem
+                          << ", numUnusedMemUpdates = " << numUnusedMemUpdates
+                          << ", this = " << (void *)this << ")\n");
 #endif
 
-         int used = 0;
+      int used = 0;
 
-         for(DLPSV* ps = list.first(); ps; ps = list.next(ps))
-         {
-            // get new shifted nonzero memory of the SVectorBase
-            Nonzero<R>* newmem = reinterpret_cast<Nonzero<R>*>(reinterpret_cast<char*>(ps->mem()) + delta);
+      for (DLPSV *ps = list.first(); ps; ps = list.next(ps)) {
+        // get new shifted nonzero memory of the SVectorBase
+        Nonzero<R> *newmem = reinterpret_cast<Nonzero<R> *>(
+            reinterpret_cast<char *>(ps->mem()) + delta);
 
-            // get the size and maximum capacity of the SVectorBase
-            int sz = ps->size();
-            int l_max = ps->max();
-            assert(l_max >= sz);
+        // get the size and maximum capacity of the SVectorBase
+        int sz = ps->size();
+        int l_max = ps->max();
+        assert(l_max >= sz);
 
-            // set new nonzero memory
-            ps->setMem(l_max, newmem);
-            ps->set_size(sz);
+        // set new nonzero memory
+        ps->setMem(l_max, newmem);
+        ps->set_size(sz);
 
-            // count used memory
-            used += sz;
-         }
+        // count used memory
+        used += sz;
+      }
 
-         // update estimation of unused memory to exact value
-         unusedMem = memSize() - used;
-         numUnusedMemUpdates = 0;
+      // update estimation of unused memory to exact value
+      unusedMem = memSize() - used;
+      numUnusedMemUpdates = 0;
 
 #ifdef SOPLEX_DEBUG
-         MSG_DEBUG(std::cout << "               --> NEW: unusedMem = " << unusedMem << " after memRemax(" <<
-                   newmax << ")\n");
+      MSG_DEBUG(std::cout << "               --> NEW: unusedMem = " << unusedMem
+                          << " after memRemax(" << newmax << ")\n");
 #endif
-      }
-   }
-
-   /// Garbage collection in nonzero memory.
-   /** Pack the svectors together as tightly as possible. This removes all additional unused memory, i.e., size = max
-    *  for every svector after the call.
-    *
-    *  Note: do *not* call isConsistent() here, because the following might happen: In SPxLP::doAddRows(const LPRowSet&
-    *  p_set), when adding rows, the sizes of the vectors for the columns of the LP are increased (without yet filling
-    *  in the data) to recieve the additional entries. This is done by calling xtend() above. xtend() in turn might call
-    *  this method, which checks the yet unfilled positions, i.e., isConsistent() is likely to fail. In general,
-    *  isConsistent() should not be called within this class, but in classes further up in the hierarchy.
-    */
-   void memPack()
-   {
-      DLPSV* ps;
-      int used;
-      int j;
-
-      for(used = 0, ps = list.first(); ps; ps = list.next(ps))
-      {
-         const int sz = ps->size();
-
-         if(ps->mem() != &this->SVSetBaseArray::operator[](used))
-         {
-            // cannot use memcpy, because the memory might overlap
-            for(j = 0; j < sz; ++j)
-               this->SVSetBaseArray::operator[](used + j) = ps->mem()[j];
-
-            ps->setMem(sz, &this->SVSetBaseArray::operator[](used));
-            ps->set_size(sz);
-         }
-         else
-            ps->set_max(sz);
-
-         used += sz;
-      }
+    }
+  }
+
+  /// Garbage collection in nonzero memory.
+  /** Pack the svectors together as tightly as possible. This removes all
+   * additional unused memory, i.e., size = max for every svector after the
+   * call.
+   *
+   *  Note: do *not* call isConsistent() here, because the following might
+   * happen: In SPxLP::doAddRows(const LPRowSet& p_set), when adding rows, the
+   * sizes of the vectors for the columns of the LP are increased (without yet
+   * filling in the data) to recieve the additional entries. This is done by
+   * calling xtend() above. xtend() in turn might call this method, which checks
+   * the yet unfilled positions, i.e., isConsistent() is likely to fail. In
+   * general, isConsistent() should not be called within this class, but in
+   * classes further up in the hierarchy.
+   */
+  void memPack() {
+    DLPSV *ps;
+    int used;
+    int j;
+
+    for (used = 0, ps = list.first(); ps; ps = list.next(ps)) {
+      const int sz = ps->size();
+
+      if (ps->mem() != &this->SVSetBaseArray::operator[](used)) {
+        // cannot use memcpy, because the memory might overlap
+        for (j = 0; j < sz; ++j)
+          this->SVSetBaseArray::operator[](used + j) = ps->mem()[j];
+
+        ps->setMem(sz, &this->SVSetBaseArray::operator[](used));
+        ps->set_size(sz);
+      } else
+        ps->set_max(sz);
+
+      used += sz;
+    }
 
 #ifdef SOPLEX_DEBUG
-      MSG_DEBUG(std::cout << "counting unused memory (unusedMem = " << unusedMem <<
-                ", numUnusedMemUpdates = " << numUnusedMemUpdates << ", this = " << (void*)this << ")\n");
-      MSG_DEBUG(std::cout << "               --> NEW: unusedMem = " << memSize() - used <<
-                ", zero after memPack() at memMax() = " << memMax() << "\n");
+    MSG_DEBUG(std::cout << "counting unused memory (unusedMem = " << unusedMem
+                        << ", numUnusedMemUpdates = " << numUnusedMemUpdates
+                        << ", this = " << (void *)this << ")\n");
+    MSG_DEBUG(std::cout << "               --> NEW: unusedMem = "
+                        << memSize() - used
+                        << ", zero after memPack() at memMax() = " << memMax()
+                        << "\n");
 #endif
 #ifndef NDEBUG
-      Nonzero<R>* olddata = SVSetBaseArray::data;
-      SVSetBaseArray::reSize(used);
-      assert(olddata == SVSetBaseArray::data);
+    Nonzero<R> *olddata = SVSetBaseArray::data;
+    SVSetBaseArray::reSize(used);
+    assert(olddata == SVSetBaseArray::data);
 #else
-      SVSetBaseArray::reSize(used);
+    SVSetBaseArray::reSize(used);
 #endif
 
-      unusedMem = 0;
-      numUnusedMemUpdates = 0;
-   }
+    unusedMem = 0;
+    numUnusedMemUpdates = 0;
+  }
 
-   ///@}
+  ///@}
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Miscellaneous */
-   ///@{
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Miscellaneous */
+  ///@{
 
-   /// Resets maximum number of SVectorBase%s.
-   void reMax(int newmax = 0)
-   {
-      list.move(set.reMax(newmax));
-   }
+  /// Resets maximum number of SVectorBase%s.
+  void reMax(int newmax = 0) { list.move(set.reMax(newmax)); }
 
-   /// Consistency check.
-   bool isConsistent() const
-   {
+  /// Consistency check.
+  bool isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
-      DLPSV* ps;
-      DLPSV* next;
+    DLPSV *ps;
+    DLPSV *next;
 
-      for(ps = list.first(); ps; ps = next)
-      {
-         if(!ps->isConsistent())
-            return MSGinconsistent("SVSetBase");
+    for (ps = list.first(); ps; ps = next) {
+      if (!ps->isConsistent())
+        return MSGinconsistent("SVSetBase");
 
-         if(ps->mem() > &SVSetBaseArray::last())
-            return MSGinconsistent("SVSetBase");
+      if (ps->mem() > &SVSetBaseArray::last())
+        return MSGinconsistent("SVSetBase");
 
-         next = list.next(ps);
+      next = list.next(ps);
 
-         if(next && ps->mem() + ps->max() != next->mem())
-            return MSGinconsistent("SVSetBase");
-      }
+      if (next && ps->mem() + ps->max() != next->mem())
+        return MSGinconsistent("SVSetBase");
+    }
 
-      return SVSetBaseArray::isConsistent() && set.isConsistent() && list.isConsistent();
+    return SVSetBaseArray::isConsistent() && set.isConsistent() &&
+           list.isConsistent();
 #else
-      return true;
+    return true;
 #endif
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Constructors / destructors */
-   ///@{
-
-   /// Default constructor.
-   explicit
-   SVSetBase<R>(int pmax = -1, int pmemmax = -1, double pfac = 1.1, double pmemFac = 1.2)
-      : SVSetBaseArray(0, (pmemmax > 0) ? pmemmax : 8 * ((pmax > 0) ? pmax : 8), pmemFac)
-      , set((pmax > 0) ? pmax : 8)
-      , unusedMem(0)
-      , numUnusedMemUpdates(0)
-      , factor(pfac)
-   {
-      assert(isConsistent());
-   }
-
-   /// Destructor
-   virtual ~SVSetBase<R>()
-   {}
-
-   /// Assignment operator.
-   SVSetBase<R>& operator=(const SVSetBase<R>& rhs)
-   {
-      if(this != &rhs)
-      {
-         clear(rhs.size());
-
-         if(rhs.size() > 0)
-         {
-            SVSetBaseArray::operator=(rhs);
-            set = rhs.set;
-
-            DLPSV* ps;
-            DLPSV* newps;
-
-            void* delta0 = &(*(static_cast<SVSetBaseArray*>(this)))[0];
-            void* delta1 = &(*(static_cast<SVSetBaseArray*>(const_cast<SVSetBase<R>*>(&rhs))))[0];
-            ptrdiff_t delta = reinterpret_cast<char*>(delta0) - reinterpret_cast<char*>(delta1);
-
-            for(ps = rhs.list.first(); ps; ps = rhs.list.next(ps))
-            {
-               newps = &set[rhs.number(ps)];
-               list.append(newps);
-               newps->setMem(ps->max(),
-                             reinterpret_cast<Nonzero<R>*>(reinterpret_cast<char*>(ps->mem()) + delta));
-               newps->set_size(ps->size());
-            }
-         }
+  }
+
+  ///@}
+
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Constructors / destructors */
+  ///@{
+
+  /// Default constructor.
+  explicit SVSetBase(int pmax = -1, int pmemmax = -1, double pfac = 1.1,
+                     double pmemFac = 1.2)
+      : SVSetBaseArray(0, (pmemmax > 0) ? pmemmax : 8 * ((pmax > 0) ? pmax : 8),
+                       pmemFac),
+        set((pmax > 0) ? pmax : 8), unusedMem(0), numUnusedMemUpdates(0),
+        factor(pfac) {
+    assert(isConsistent());
+  }
+
+  /// Destructor
+  virtual ~SVSetBase() {}
+
+  /// Assignment operator.
+  SVSetBase<R> &operator=(const SVSetBase<R> &rhs) {
+    if (this != &rhs) {
+      clear(rhs.size());
+
+      if (rhs.size() > 0) {
+        SVSetBaseArray::operator=(rhs);
+        set = rhs.set;
+
+        DLPSV *ps;
+        DLPSV *newps;
+
+        void *delta0 = &(*(static_cast<SVSetBaseArray *>(this)))[0];
+        void *delta1 = &(*(static_cast<SVSetBaseArray *>(
+            const_cast<SVSetBase<R> *>(&rhs))))[0];
+        ptrdiff_t delta =
+            reinterpret_cast<char *>(delta0) - reinterpret_cast<char *>(delta1);
+
+        for (ps = rhs.list.first(); ps; ps = rhs.list.next(ps)) {
+          newps = &set[rhs.number(ps)];
+          list.append(newps);
+          newps->setMem(ps->max(),
+                        reinterpret_cast<Nonzero<R> *>(
+                            reinterpret_cast<char *>(ps->mem()) + delta));
+          newps->set_size(ps->size());
+        }
       }
+    }
 
-      assert(isConsistent());
+    assert(isConsistent());
 
-      return *this;
-   }
-
-   /// Assignment operator.
-   template < class S >
-   SVSetBase<R>& operator=(const SVSetBase<S>& rhs)
-   {
-      if(this != (const SVSetBase<R>*)(&rhs))
-      {
-         clear(rhs.size());
-
-         if(rhs.size() > 0)
-            this->add(rhs);
-      }
+    return *this;
+  }
 
-      assert(isConsistent());
+  /// Assignment operator.
+  template <class S> SVSetBase<R> &operator=(const SVSetBase<S> &rhs) {
+    if (this != (const SVSetBase<R> *)(&rhs)) {
+      clear(rhs.size());
 
-      return *this;
-   }
-
-   /// Copy constructor.
-   SVSetBase<R>(const SVSetBase<R>& old)
-      : SVSetBaseArray()
-      , unusedMem(old.unusedMem)
-      , numUnusedMemUpdates(old.numUnusedMemUpdates)
-      , factor(old.factor)
-   {
-      *this = old;
-
-      assert(SVSetBase::isConsistent());
-   }
-
-   /// Copy constructor.
-   template < class S >
-   SVSetBase<R>(const SVSetBase<S>& old)
-      : SVSetBaseArray()
-      , unusedMem(old.unusedMem)
-      , numUnusedMemUpdates(old.numUnusedMemUpdates)
-      , factor(old.factor)
-   {
-      *this = old;
-
-      assert(SVSetBase::isConsistent());
-   }
-
-   ///@}
+      if (rhs.size() > 0)
+        this->add(rhs);
+    }
+
+    assert(isConsistent());
+
+    return *this;
+  }
+
+  /// Copy constructor.
+  SVSetBase(const SVSetBase<R> &old)
+      : SVSetBaseArray(), unusedMem(old.unusedMem),
+        numUnusedMemUpdates(old.numUnusedMemUpdates), factor(old.factor) {
+    *this = old;
+
+    assert(SVSetBase::isConsistent());
+  }
+
+  /// Copy constructor.
+  template <class S>
+  SVSetBase(const SVSetBase<S> &old)
+      : SVSetBaseArray(), unusedMem(old.unusedMem),
+        numUnusedMemUpdates(old.numUnusedMemUpdates), factor(old.factor) {
+    *this = old;
+
+    assert(SVSetBase::isConsistent());
+  }
+
+  ///@}
 };
 
 } // namespace soplex
diff --git a/src/soplex/testsoplex.hpp b/src/soplex/testsoplex.hpp
index 7969c93..3debab1 100644
--- a/src/soplex/testsoplex.hpp
+++ b/src/soplex/testsoplex.hpp
@@ -21,256 +21,244 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
-#include <iostream>
 #include <assert.h>
+#include <iostream>
 
 #include "soplex.h"
 #include "soplex/statistics.h"
 
-namespace soplex
-{
+namespace soplex {
 /// check scaling of LP
 template <class R>
-void SoPlexBase<R>::_checkScaling(SPxLPBase<R>* origLP) const
-{
-   MSG_INFO1(spxout, spxout << "DEBUG: checking correctness of scaled LP" << std::endl;)
-   assert(_realLP->nCols() == origLP->nCols());
-   assert(_realLP->nRows() == origLP->nRows());
-   assert(_realLP->isScaled() && !origLP->isScaled());
-   bool correct = true;
-
-   MSG_INFO1(spxout, spxout << "DEBUG: checking rows..." << std::endl;)
-
-   for(int i = 0; i < origLP->nRows(); ++i)
-   {
-      assert(EQ(origLP->lhs(i), _realLP->lhsUnscaled(i)));
-      assert(EQ(origLP->rhs(i), _realLP->rhsUnscaled(i)));
-
-      DSVectorBase<R> row;
-      _realLP->getRowVectorUnscaled(i, row);
-
-      assert(origLP->rowVector(i).size() == row.size());
-
-      for(int j = 0; j < row.size(); ++j)
-      {
-         if(NE(row.value(j), origLP->rowVector(i).value(j)))
-         {
-            MSG_INFO1(spxout, spxout << "DEBUG: scaling error in row " << i << ", col " << j
-                      << ": orig " << origLP->rowVector(i).value(j)
-                      << ", unscaled: " << row.value(j) << std::endl;)
-            correct = false;
-         }
+void SoPlexBase<R>::_checkScaling(SPxLPBase<R> *origLP) const {
+  MSG_INFO1(spxout,
+            spxout << "DEBUG: checking correctness of scaled LP" << std::endl;)
+  assert(_realLP->nCols() == origLP->nCols());
+  assert(_realLP->nRows() == origLP->nRows());
+  assert(_realLP->isScaled() && !origLP->isScaled());
+  bool correct = true;
+
+  MSG_INFO1(spxout, spxout << "DEBUG: checking rows..." << std::endl;)
+
+  for (int i = 0; i < origLP->nRows(); ++i) {
+    assert(EQ(origLP->lhs(i), _realLP->lhsUnscaled(i)));
+    assert(EQ(origLP->rhs(i), _realLP->rhsUnscaled(i)));
+
+    DSVectorBase<R> row;
+    _realLP->getRowVectorUnscaled(i, row);
+
+    assert(origLP->rowVector(i).size() == row.size());
+
+    for (int j = 0; j < row.size(); ++j) {
+      if (NE(row.value(j), origLP->rowVector(i).value(j))) {
+        MSG_INFO1(spxout, spxout
+                              << "DEBUG: scaling error in row " << i << ", col "
+                              << j << ": orig " << origLP->rowVector(i).value(j)
+                              << ", unscaled: " << row.value(j) << std::endl;)
+        correct = false;
       }
-   }
-
-   MSG_INFO1(spxout, spxout << "DEBUG: checking cols..." << std::endl;)
-
-   for(int i = 0; i < origLP->nCols(); ++i)
-   {
-      assert(EQ(origLP->lower(i), _realLP->lowerUnscaled(i)));
-      assert(EQ(origLP->upper(i), _realLP->upperUnscaled(i)));
-      assert(EQ(origLP->obj(i), _realLP->objUnscaled(i)));
-
-      DSVectorBase<R> col;
-      _realLP->getColVectorUnscaled(i, col);
-
-      assert(origLP->colVector(i).size() == col.size());
-
-      for(int j = 0; j < col.size(); ++j)
-      {
-         if(NE(col.value(j), origLP->colVector(i).value(j), _solver.feastol()))
-         {
-            MSG_INFO1(spxout, spxout << "DEBUG: scaling error in col " << i << ", row " << j
-                      << ": orig " << origLP->colVector(i).value(j)
-                      << ", unscaled: " << col.value(j) << std::endl;)
-            correct = false;
-         }
-      }
-   }
+    }
+  }
 
-   if(!correct)
-   {
-      MSG_INFO1(spxout, spxout << "DEBUG: scaling check failed" << std::endl;)
-   }
+  MSG_INFO1(spxout, spxout << "DEBUG: checking cols..." << std::endl;)
 
-   assert(correct);
-}
+  for (int i = 0; i < origLP->nCols(); ++i) {
+    assert(EQ(origLP->lower(i), _realLP->lowerUnscaled(i)));
+    assert(EQ(origLP->upper(i), _realLP->upperUnscaled(i)));
+    assert(EQ(origLP->obj(i), _realLP->objUnscaled(i)));
 
+    DSVectorBase<R> col;
+    _realLP->getColVectorUnscaled(i, col);
 
-template <class R>
-void SoPlexBase<R>::_checkBasisScaling()
-{
-   if(_status != SPxSolverBase<R>::OPTIMAL)
-   {
-      MSG_INFO1(spxout, spxout << "DEBUG: skipping test on non optimal bases\n");
-      return;
-   }
-
-   assert(&_solver == _realLP);
-   VectorBase<R>** binvcol = 0;
-   VectorBase<R>** binvrow = 0;
-   int* inds = 0;
-   int basisdim = _solver.nRows(); // do all operations with regard to the column basis
-   bool colrep = (_solver.rep() == SPxSolverBase<R>::COLUMN);
-   spx_alloc(binvcol, basisdim);
-   spx_alloc(binvrow, basisdim);
-   spx_alloc(inds, basisdim);
-
-   if(colrep)
-   {
-      MSG_INFO1(spxout, spxout << "DEBUG: computing columns of inverted basis matrix\n";)
+    assert(origLP->colVector(i).size() == col.size());
 
-      // collect columns of the basis inverse
-      for(int i = 0; i < basisdim; ++i)
-      {
-         binvcol[i] = new VectorBase<R>(basisdim);
-         binvcol[i]->clear();
-         assert(getBasisInverseColReal(i, binvcol[i]->get_ptr(), 0, 0, true));
-      }
-   }
-
-   MSG_INFO1(spxout, spxout << "DEBUG: computing rows of inverted basis matrix\n";)
-
-   // collect rows of the basis inverse
-   for(int i = 0; i < basisdim; ++i)
-   {
-      binvrow[i] = new VectorBase<R>(basisdim);
-      binvrow[i]->clear();
-      assert(getBasisInverseRowReal(i, binvrow[i]->get_ptr(), 0, 0, true));
-   }
-
-   if(colrep)
-   {
-      MSG_INFO1(spxout, spxout <<
-                "DEBUG: checking columns for identity after multiplying with basis matrix\n";)
-
-      // multiply with (unscaled) basis matrix and check result (should be unitvecs)
-      for(int i = 0; i < basisdim; ++i)
-      {
-         VectorBase<R> result(*binvcol[i]);
-         assert(multBasis(result.get_ptr(), true));
-         R sumerror = 0.0;
-
-         for(int j = 0; j < basisdim; ++j)
-         {
-            R error = 0.0;
-
-            if(j != i)
-               error = spxAbs(result[j]);
-            else
-               error = spxAbs(result[j] - 1.0);
-
-            if(error > _solver.feastol())
-               MSG_INFO1(spxout, spxout << "ERROR: col " << i << " " << j << ", " << result[j] << std::endl);
-
-            sumerror += error;
-         }
-
-         assert(_solver.rep() == SPxSolverBase<R>::ROW || sumerror < _solver.feastol());
+    for (int j = 0; j < col.size(); ++j) {
+      if (NE(col.value(j), origLP->colVector(i).value(j), _solver.feastol())) {
+        MSG_INFO1(spxout, spxout
+                              << "DEBUG: scaling error in col " << i << ", row "
+                              << j << ": orig " << origLP->colVector(i).value(j)
+                              << ", unscaled: " << col.value(j) << std::endl;)
+        correct = false;
       }
-   }
+    }
+  }
 
-   MSG_INFO1(spxout, spxout <<
-             "DEBUG: checking rows for identity after multiplying with basis matrix\n";)
+  if (!correct) {
+    MSG_INFO1(spxout, spxout << "DEBUG: scaling check failed" << std::endl;)
+  }
 
-   for(int i = 0; i < basisdim; ++i)
-   {
-      VectorBase<R> result(*binvrow[i]);
-      assert(multBasisTranspose(result.get_ptr(), true));
+  assert(correct);
+}
+
+template <class R> void SoPlexBase<R>::_checkBasisScaling() {
+  if (_status != SPxSolverBase<R>::OPTIMAL) {
+    MSG_INFO1(spxout, spxout << "DEBUG: skipping test on non optimal bases\n");
+    return;
+  }
+
+  assert(&_solver == _realLP);
+  VectorBase<R> **binvcol = 0;
+  VectorBase<R> **binvrow = 0;
+  int *inds = 0;
+  int basisdim =
+      _solver.nRows(); // do all operations with regard to the column basis
+  bool colrep = (_solver.rep() == SPxSolverBase<R>::COLUMN);
+  spx_alloc(binvcol, basisdim);
+  spx_alloc(binvrow, basisdim);
+  spx_alloc(inds, basisdim);
+
+  if (colrep) {
+    MSG_INFO1(spxout,
+              spxout << "DEBUG: computing columns of inverted basis matrix\n";)
+
+    // collect columns of the basis inverse
+    for (int i = 0; i < basisdim; ++i) {
+      binvcol[i] = new VectorBase<R>(basisdim);
+      binvcol[i]->clear();
+      assert(getBasisInverseColReal(i, binvcol[i]->get_ptr(), 0, 0, true));
+    }
+  }
+
+  MSG_INFO1(spxout,
+            spxout << "DEBUG: computing rows of inverted basis matrix\n";)
+
+  // collect rows of the basis inverse
+  for (int i = 0; i < basisdim; ++i) {
+    binvrow[i] = new VectorBase<R>(basisdim);
+    binvrow[i]->clear();
+    assert(getBasisInverseRowReal(i, binvrow[i]->get_ptr(), 0, 0, true));
+  }
+
+  if (colrep) {
+    MSG_INFO1(spxout, spxout << "DEBUG: checking columns for identity after "
+                                "multiplying with basis matrix\n";)
+
+    // multiply with (unscaled) basis matrix and check result (should be
+    // unitvecs)
+    for (int i = 0; i < basisdim; ++i) {
+      VectorBase<R> result(*binvcol[i]);
+      assert(multBasis(result.get_ptr(), true));
       R sumerror = 0.0;
 
-      for(int j = 0; j < basisdim; ++j)
-      {
-         R error = 0.0;
+      for (int j = 0; j < basisdim; ++j) {
+        R error = 0.0;
 
-         if(j != i)
-            error = spxAbs(result[j]);
-         else
-            error = spxAbs(result[j] - 1.0);
+        if (j != i)
+          error = spxAbs(result[j]);
+        else
+          error = spxAbs(result[j] - 1.0);
 
-         if(error > _solver.feastol())
-            MSG_INFO1(spxout, spxout << "ERROR: row " << i << " " << j << ", " << result[j] << std::endl);
+        if (error > _solver.feastol())
+          MSG_INFO1(spxout, spxout << "ERROR: col " << i << " " << j << ", "
+                                   << result[j] << std::endl);
 
-         sumerror += error;
+        sumerror += error;
       }
 
-      assert(sumerror < _solver.feastol());
-   }
-
-   if(_solver.isScaled())
-   {
-      MSG_INFO1(spxout, spxout << "DEBUG: unscaling LP\n";)
-      //         _solver.setRep(SPxSolverBase<R>::COLUMN);
-      _solver.unscaleLPandReloadBasis();
-      //         _solver.setBasis(_basisStatusRows.get_ptr(), _basisStatusCols.get_ptr());
-      //         _solver.solve();
-
-      VectorBase<R>** binvcol2 = 0;
-      VectorBase<R>** binvrow2 = 0;
-      spx_alloc(binvcol2, basisdim);
-      spx_alloc(binvrow2, basisdim);
-
-      if(colrep)
-      {
-         MSG_INFO1(spxout, spxout << "DEBUG: computing columns of inverted basis matrix again\n";)
-
-         // collect columns of the basis inverse
-         for(int i = 0; i < basisdim; ++i)
-         {
-            binvcol2[i] = new VectorBase<R>(basisdim);
-            binvcol2[i]->clear();
-            assert(getBasisInverseColReal(i, binvcol2[i]->get_ptr(), 0, 0, false));
-         }
-      }
+      assert(_solver.rep() == SPxSolverBase<R>::ROW ||
+             sumerror < _solver.feastol());
+    }
+  }
+
+  MSG_INFO1(spxout, spxout << "DEBUG: checking rows for identity after "
+                              "multiplying with basis matrix\n";)
+
+  for (int i = 0; i < basisdim; ++i) {
+    VectorBase<R> result(*binvrow[i]);
+    assert(multBasisTranspose(result.get_ptr(), true));
+    R sumerror = 0.0;
+
+    for (int j = 0; j < basisdim; ++j) {
+      R error = 0.0;
 
-      MSG_INFO1(spxout, spxout << "DEBUG: computing rows of inverted basis matrix again\n";)
+      if (j != i)
+        error = spxAbs(result[j]);
+      else
+        error = spxAbs(result[j] - 1.0);
 
-      // collect rows of the basis inverse
-      for(int i = 0; i < basisdim; ++i)
-      {
-         binvrow2[i] = new VectorBase<R>(basisdim);
-         binvrow2[i]->clear();
-         assert(getBasisInverseRowReal(i, binvrow2[i]->get_ptr(), 0, 0, false));
+      if (error > _solver.feastol())
+        MSG_INFO1(spxout, spxout << "ERROR: row " << i << " " << j << ", "
+                                 << result[j] << std::endl);
+
+      sumerror += error;
+    }
+
+    assert(sumerror < _solver.feastol());
+  }
+
+  if (_solver.isScaled()) {
+    MSG_INFO1(spxout, spxout << "DEBUG: unscaling LP\n";)
+    //         _solver.setRep(SPxSolverBase<R>::COLUMN);
+    _solver.unscaleLPandReloadBasis();
+    //         _solver.setBasis(_basisStatusRows.get_ptr(),
+    //         _basisStatusCols.get_ptr()); _solver.solve();
+
+    VectorBase<R> **binvcol2 = 0;
+    VectorBase<R> **binvrow2 = 0;
+    spx_alloc(binvcol2, basisdim);
+    spx_alloc(binvrow2, basisdim);
+
+    if (colrep) {
+      MSG_INFO1(
+          spxout,
+          spxout
+              << "DEBUG: computing columns of inverted basis matrix again\n";)
+
+      // collect columns of the basis inverse
+      for (int i = 0; i < basisdim; ++i) {
+        binvcol2[i] = new VectorBase<R>(basisdim);
+        binvcol2[i]->clear();
+        assert(getBasisInverseColReal(i, binvcol2[i]->get_ptr(), 0, 0, false));
       }
+    }
 
-      MSG_INFO1(spxout, spxout <<
-                "DEBUG: checking rows and columns of scaled/unscaled inverted of basis matrix\n";)
-
-      for(int i = 0; i < basisdim; ++i)
-      {
-         R sumerror = 0.0;
-
-         for(int j = 0; j < basisdim; ++j)
-         {
-            if(colrep)
-            {
-               if(NE((*binvcol[i])[j], (*binvcol2[i])[j], _solver.feastol()))
-               {
-                  MSG_INFO1(spxout, spxout << "ERROR: col " << i << " " << j << ", " << (*binvcol[i])[j] << " " <<
-                            (*binvcol2[i])[j] << std::endl);
-                  sumerror += spxAbs((*binvcol[i])[j] - (*binvcol2[i])[j]);
-               }
-            }
-
-            if(NE((*binvrow[i])[j], (*binvrow2[i])[j], _solver.feastol()))
-            {
-               MSG_INFO1(spxout, spxout << "ERROR: row " << i << " " << j << ", " << (*binvrow[i])[j] /
-                         (*binvrow2[i])[j] << std::endl);
-               sumerror += spxAbs((*binvrow[i])[j] - (*binvrow2[i])[j]);
-            }
-         }
-
-         assert(sumerror < _solver.feastol());
+    MSG_INFO1(
+        spxout,
+        spxout << "DEBUG: computing rows of inverted basis matrix again\n";)
+
+    // collect rows of the basis inverse
+    for (int i = 0; i < basisdim; ++i) {
+      binvrow2[i] = new VectorBase<R>(basisdim);
+      binvrow2[i]->clear();
+      assert(getBasisInverseRowReal(i, binvrow2[i]->get_ptr(), 0, 0, false));
+    }
+
+    MSG_INFO1(spxout, spxout << "DEBUG: checking rows and columns of "
+                                "scaled/unscaled inverted of basis matrix\n";)
+
+    for (int i = 0; i < basisdim; ++i) {
+      R sumerror = 0.0;
+
+      for (int j = 0; j < basisdim; ++j) {
+        if (colrep) {
+          if (NE((*binvcol[i])[j], (*binvcol2[i])[j], _solver.feastol())) {
+            MSG_INFO1(spxout, spxout << "ERROR: col " << i << " " << j << ", "
+                                     << (*binvcol[i])[j] << " "
+                                     << (*binvcol2[i])[j] << std::endl);
+            sumerror += spxAbs((*binvcol[i])[j] - (*binvcol2[i])[j]);
+          }
+        }
+
+        if (NE((*binvrow[i])[j], (*binvrow2[i])[j], _solver.feastol())) {
+          MSG_INFO1(spxout, spxout << "ERROR: row " << i << " " << j << ", "
+                                   << (*binvrow[i])[j] / (*binvrow2[i])[j]
+                                   << std::endl);
+          sumerror += spxAbs((*binvrow[i])[j] - (*binvrow2[i])[j]);
+        }
       }
 
-      spx_free(binvcol2);
-      spx_free(binvrow2);
-   }
+      assert(sumerror < _solver.feastol());
+    }
+
+    spx_free(binvcol2);
+    spx_free(binvrow2);
+  }
 
-   spx_free(inds);
-   spx_free(binvrow);
-   spx_free(binvcol);
+  spx_free(inds);
+  spx_free(binvrow);
+  spx_free(binvcol);
 }
 
 } // namespace soplex
diff --git a/src/soplex/unitvectorbase.h b/src/soplex/unitvectorbase.h
index 61a0e09..f64d40d 100644
--- a/src/soplex/unitvectorbase.h
+++ b/src/soplex/unitvectorbase.h
@@ -29,13 +29,11 @@
 #ifndef _UNITVECTORBASE_H_
 #define _UNITVECTORBASE_H_
 
-#include <assert.h>
 #include "soplex/spxdefines.h"
 #include "soplex/svectorbase.h"
+#include <assert.h>
 
-namespace soplex
-{
-
+namespace soplex {
 
 /**@brief   Sparse vector \f$e_i\f$.
    @ingroup Algebra
@@ -43,110 +41,96 @@ namespace soplex
    A UnitVectorBase is an SVectorBase that can take only one nonzero value with
    value 1 but arbitrary index.
 
-   \todo Several SVectorBase modification methods are still accessible for UnitVector.
-   They might be used to change the vector.
+   \todo Several SVectorBase modification methods are still accessible for
+   UnitVector. They might be used to change the vector.
 
-   \todo UnitVectorBase memory management must be changed when SVectorBase is redesigned.
+   \todo UnitVectorBase memory management must be changed when SVectorBase is
+   redesigned.
 */
 
-template < class R >
-class UnitVectorBase : public SVectorBase<R>
-{
+template <class R> class UnitVectorBase : public SVectorBase<R> {
 private:
+  //------------------------------------
+  /**@name Data */
+  ///@{
+  typename SVectorBase<R>::Element themem; ///< memory for sparse vector entry
+  ///@}
 
-   //------------------------------------
-   /**@name Data */
-   ///@{
-   typename SVectorBase<R>::Element themem;  ///< memory for sparse vector entry
-   ///@}
-
-   using SVectorBase<R>::mem;
+  using SVectorBase<R>::mem;
 
-   using SVectorBase<R>::size;
+  using SVectorBase<R>::size;
 
-   using SVectorBase<R>::max;
+  using SVectorBase<R>::max;
 
 public:
-
-   //------------------------------------
-   /**@name Access */
-   ///@{
-   /// returns value = 1
-   /**\pre \c n must be 0.
-    */
-   /* ARGSUSED n */
-   R value(int n) const
-   {
-      assert(n == 0);
-      return 1;
-   }
-   ///@}
-
-   //------------------------------------
-   /**@name Constructors / destructors */
-   ///@{
-   /// construct \c i 'th unit vector.
-   explicit
-   UnitVectorBase<R>(int i = 0)
-      : SVectorBase<R>(1, &themem)
-   {
-      // coverity[callee_ptr_arith]
-      SVectorBase<R>::add(i, 1.0);
-
-      assert(isConsistent());
-   }
-   ///  copy constructor
-   UnitVectorBase<R>(const UnitVectorBase<R>& rhs)
-      : SVectorBase<R>(1, &themem)
-   {
+  //------------------------------------
+  /**@name Access */
+  ///@{
+  /// returns value = 1
+  /**\pre \c n must be 0.
+   */
+  /* ARGSUSED n */
+  R value(int n) const {
+    assert(n == 0);
+    return 1;
+  }
+  ///@}
+
+  //------------------------------------
+  /**@name Constructors / destructors */
+  ///@{
+  /// construct \c i 'th unit vector.
+  explicit UnitVectorBase(int i = 0) : SVectorBase<R>(1, &themem) {
+    // coverity[callee_ptr_arith]
+    SVectorBase<R>::add(i, 1.0);
+
+    assert(isConsistent());
+  }
+  ///  copy constructor
+  UnitVectorBase(const UnitVectorBase<R> &rhs) : SVectorBase<R>(1, &themem) {
+    themem = rhs.themem;
+    this->set_size(1);
+
+    assert(isConsistent());
+  }
+  /// assignment
+  UnitVectorBase<R> &operator=(const UnitVectorBase<R> &rhs) {
+    if (this != &rhs) {
       themem = rhs.themem;
       this->set_size(1);
 
       assert(isConsistent());
-   }
-   /// assignment
-   UnitVectorBase<R>& operator=(const UnitVectorBase<R>& rhs)
-   {
-      if(this != &rhs)
-      {
-         themem = rhs.themem;
-         this->set_size(1);
-
-         assert(isConsistent());
-      }
-
-      return *this;
-   }
-   /// destructor
-   ~UnitVectorBase<R>()
-   {}
-   ///@}
-
-   //------------------------------------
-   /**@name Miscellaneous */
-   ///@{
-   /// consistency check
-   bool isConsistent() const
-   {
+    }
+
+    return *this;
+  }
+  /// destructor
+  ~UnitVectorBase() {}
+  ///@}
+
+  //------------------------------------
+  /**@name Miscellaneous */
+  ///@{
+  /// consistency check
+  bool isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
 
-      if(mem() != &themem)
-         return MSGinconsistent("UnitVectorBase");
+    if (mem() != &themem)
+      return MSGinconsistent("UnitVectorBase");
 
-      if(size() != 1)
-         return MSGinconsistent("UnitVectorBase");
+    if (size() != 1)
+      return MSGinconsistent("UnitVectorBase");
 
-      if(max() != 1)
-         return MSGinconsistent("UnitVectorBase");
+    if (max() != 1)
+      return MSGinconsistent("UnitVectorBase");
 
-      return SVectorBase<R>::isConsistent();
+    return SVectorBase<R>::isConsistent();
 #else
-      return true;
+    return true;
 #endif
-   }
-   ///@}
+  }
+  ///@}
 };
 
-
 } // namespace soplex
 #endif // _UNITVECTORBASE_H_
diff --git a/src/soplex/updatevector.h b/src/soplex/updatevector.h
index 40101eb..c681383 100644
--- a/src/soplex/updatevector.h
+++ b/src/soplex/updatevector.h
@@ -31,21 +31,19 @@
 
 #include <assert.h>
 
-
 #include "soplex/spxdefines.h"
 #include "soplex/ssvector.h"
 
-namespace soplex
-{
+namespace soplex {
 
 /**@brief   Dense Vector with semi-sparse Vector for updates
    @ingroup Algebra
 
     In many algorithms vectors are updated in every iteration, by
-    adding a multiple of another VectorBase<R> to it, i.e., given a VectorBase<R> \c
-    x, a scalar \f$\alpha\f$ and another VectorBase<R> \f$\delta\f$, the
-    update to \c x constists of substituting it by \f$x \leftarrow x +
-    \alpha\cdot\delta\f$.
+    adding a multiple of another VectorBase<R> to it, i.e., given a
+   VectorBase<R> \c x, a scalar \f$\alpha\f$ and another VectorBase<R>
+   \f$\delta\f$, the update to \c x constists of substituting it by \f$x
+   \leftarrow x + \alpha\cdot\delta\f$.
 
     While the update itself can easily be expressed with methods of
     the class VectorBase<R>, it is often desirable to save the last update
@@ -58,128 +56,96 @@ namespace soplex
     sparse updates, by providing an IdxSet idx() containing the
     nonzero indices of \f$\delta\f$.
 */
-template <class R>
-class UpdateVector : public VectorBase<R>
-{
+template <class R> class UpdateVector : public VectorBase<R> {
 private:
-
-   //------------------------------------
-   /**@name Data */
-   ///@{
-   R     theval;      ///< update multiplicator
-   SSVectorBase<R> thedelta;    ///< update vector
-   ///@}
+  //------------------------------------
+  /**@name Data */
+  ///@{
+  R theval;                 ///< update multiplicator
+  SSVectorBase<R> thedelta; ///< update vector
+                            ///@}
 
 public:
-
-   //------------------------------------
-   /**@name Constructors / destructors */
-   ///@{
-   /// default constructor.
-   explicit
-   UpdateVector<R>(int p_dim /*=0*/, R p_eps /*=1e-16*/)
-      : VectorBase<R> (p_dim)
-      , theval(0)
-      , thedelta(p_dim, p_eps)
-   {
-      assert(isConsistent());
-   }
-   ///
-   ~UpdateVector<R>()
-   {}
-   /// copy constructor
-   UpdateVector<R>(const UpdateVector<R>&);
-   /// assignment from VectorBase<R>
-   UpdateVector<R>& operator=(const VectorBase<R>& rhs)
-   {
-      if(this != & rhs)
-         VectorBase<R>::operator=(rhs);
-
-      assert(isConsistent());
-
-      return *this;
-   }
-
-   /// assignment
-   UpdateVector<R>& operator=(const UpdateVector<R>& rhs);
-   ///@}
-
-   //------------------------------------
-   /**@name Access */
-   ///@{
-   /// update multiplicator \f$\alpha\f$, writeable
-   R& value()
-   {
-      return theval;
-   }
-   /// update multiplicator \f$\alpha\f$
-   R value() const
-   {
-      return theval;
-   }
-
-   /// update VectorBase<R> \f$\delta\f$, writeable
-   SSVectorBase<R>& delta()
-   {
-      return thedelta;
-   }
-   /// update VectorBase<R> \f$\delta\f$
-   const SSVectorBase<R>& delta() const
-   {
-      return thedelta;
-   }
-
-   /// nonzero indices of update VectorBase<R> \f$\delta\f$
-   const IdxSet& idx() const
-   {
-      return thedelta.indices();
-   }
-   ///@}
-
-   //------------------------------------
-   /**@name Modification */
-   ///@{
-   /// Perform the update
-   /**  Add \c value() * \c delta() to the UpdateVector<R>. Only the indices
-    *  in idx() are affected. For all other indices, delta() is asumed
-    *  to be 0.
-    */
-   void update()
-   {
-      this->multAdd(theval, thedelta);
-   }
-
-   /// clear VectorBase<R> and update vector
-   void clear()
-   {
-      VectorBase<R>::clear();
-      clearUpdate();
-   }
-
-   /// clear \f$\delta\f$, \f$\alpha\f$
-   void clearUpdate()
-   {
-      thedelta.clear();
-      theval = 0;
-   }
-
-   /// reset dimension
-   void reDim(int newdim)
-   {
-      VectorBase<R>::reDim(newdim);
-      thedelta.reDim(newdim);
-   }
-   ///@}
-
-   //------------------------------------
-   /**@name Consistency check */
-   ///@{
-   ///
-   bool isConsistent() const;
-   ///@}
+  //------------------------------------
+  /**@name Constructors / destructors */
+  ///@{
+  /// default constructor.
+  explicit UpdateVector(int p_dim /*=0*/, R p_eps /*=1e-16*/)
+      : VectorBase<R>(p_dim), theval(0), thedelta(p_dim, p_eps) {
+    assert(isConsistent());
+  }
+  ///
+  ~UpdateVector() {}
+  /// copy constructor
+  UpdateVector(const UpdateVector<R> &);
+  /// assignment from VectorBase<R>
+  UpdateVector<R> &operator=(const VectorBase<R> &rhs) {
+    if (this != &rhs)
+      VectorBase<R>::operator=(rhs);
+
+    assert(isConsistent());
+
+    return *this;
+  }
+
+  /// assignment
+  UpdateVector<R> &operator=(const UpdateVector<R> &rhs);
+  ///@}
+
+  //------------------------------------
+  /**@name Access */
+  ///@{
+  /// update multiplicator \f$\alpha\f$, writeable
+  R &value() { return theval; }
+  /// update multiplicator \f$\alpha\f$
+  R value() const { return theval; }
+
+  /// update VectorBase<R> \f$\delta\f$, writeable
+  SSVectorBase<R> &delta() { return thedelta; }
+  /// update VectorBase<R> \f$\delta\f$
+  const SSVectorBase<R> &delta() const { return thedelta; }
+
+  /// nonzero indices of update VectorBase<R> \f$\delta\f$
+  const IdxSet &idx() const { return thedelta.indices(); }
+  ///@}
+
+  //------------------------------------
+  /**@name Modification */
+  ///@{
+  /// Perform the update
+  /**  Add \c value() * \c delta() to the UpdateVector<R>. Only the indices
+   *  in idx() are affected. For all other indices, delta() is asumed
+   *  to be 0.
+   */
+  void update() { this->multAdd(theval, thedelta); }
+
+  /// clear VectorBase<R> and update vector
+  void clear() {
+    VectorBase<R>::clear();
+    clearUpdate();
+  }
+
+  /// clear \f$\delta\f$, \f$\alpha\f$
+  void clearUpdate() {
+    thedelta.clear();
+    theval = 0;
+  }
+
+  /// reset dimension
+  void reDim(int newdim) {
+    VectorBase<R>::reDim(newdim);
+    thedelta.reDim(newdim);
+  }
+  ///@}
+
+  //------------------------------------
+  /**@name Consistency check */
+  ///@{
+  ///
+  bool isConsistent() const;
+  ///@}
 };
 
-
 } // namespace soplex
 
 // General templated functions
diff --git a/src/soplex/updatevector.hpp b/src/soplex/updatevector.hpp
index abb162a..19982b5 100644
--- a/src/soplex/updatevector.hpp
+++ b/src/soplex/updatevector.hpp
@@ -21,45 +21,38 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
-namespace soplex
-{
+namespace soplex {
 
 template <class R>
-UpdateVector<R>& UpdateVector<R>::operator=(const UpdateVector<R>& rhs)
-{
-   if(this != &rhs)
-   {
-      theval   = rhs.theval;
-      thedelta = rhs.thedelta;
-      VectorBase<R>::operator=(rhs);
+UpdateVector<R> &UpdateVector<R>::operator=(const UpdateVector<R> &rhs) {
+  if (this != &rhs) {
+    theval = rhs.theval;
+    thedelta = rhs.thedelta;
+    VectorBase<R>::operator=(rhs);
 
-      assert(UpdateVector<R>::isConsistent());
-   }
+    assert(UpdateVector<R>::isConsistent());
+  }
 
-   return *this;
+  return *this;
 }
 
 template <class R>
-UpdateVector<R>::UpdateVector(const UpdateVector<R>& base)
-   : VectorBase<R>(base)
-   , theval(base.theval)
-   , thedelta(base.thedelta)
-{
-   assert(UpdateVector<R>::isConsistent());
+UpdateVector<R>::UpdateVector(const UpdateVector<R> &base)
+    : VectorBase<R>(base), theval(base.theval), thedelta(base.thedelta) {
+  assert(UpdateVector<R>::isConsistent());
 }
 
-template <class R>
-bool UpdateVector<R>::isConsistent() const
-{
+template <class R> bool UpdateVector<R>::isConsistent() const {
 #ifdef ENABLE_CONSISTENCY_CHECKS
 
-   if(this->dim() != thedelta.dim())
-      return MSGinconsistent("UpdateVector");
+  if (this->dim() != thedelta.dim())
+    return MSGinconsistent("UpdateVector");
 
-   return VectorBase<R>::isConsistent() && thedelta.isConsistent();
+  return VectorBase<R>::isConsistent() && thedelta.isConsistent();
 #else
-   return true;
+  return true;
 #endif
 }
 } // namespace soplex
diff --git a/src/soplex/validation.hpp b/src/soplex/validation.hpp
index c618734..2bd892f 100644
--- a/src/soplex/validation.hpp
+++ b/src/soplex/validation.hpp
@@ -21,158 +21,135 @@
 /*  along with SoPlex; see the file LICENSE. If not email to soplex@zib.de.  */
 /*                                                                           */
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#pragma once
 
 /**@file  validation.hpp
  * @brief Validation object for soplex solutions
  */
 
-namespace soplex
-{
+namespace soplex {
 
 template <class R>
-bool Validation<R>::updateExternalSolution(const std::string& solution)
-{
-   validate = true;
-   validatesolution = solution;
-
-   if(solution == "+infinity")
-   {
-      return true;
-   }
-   else if(solution == "-infinity")
-   {
-      return true;
-   }
-   else
-   {
-      char* tailptr;
-      strtod(solution.c_str(), &tailptr);
-
-      if(*tailptr)
-      {
-         //conversion failed because the input wasn't a number
-         return false;
-      }
-   }
-
-   return true;
-}
+bool Validation<R>::updateExternalSolution(const std::string &solution) {
+  validate = true;
+  validatesolution = solution;
+
+  if (solution == "+infinity") {
+    return true;
+  } else if (solution == "-infinity") {
+    return true;
+  } else {
+    char *tailptr;
+    strtod(solution.c_str(), &tailptr);
+
+    if (*tailptr) {
+      // conversion failed because the input wasn't a number
+      return false;
+    }
+  }
 
+  return true;
+}
 
 /// updates the tolerance used for validation
 template <class R>
-bool Validation<R>::updateValidationTolerance(const std::string& tolerance)
-{
-   char* tailptr;
-   validatetolerance = strtod(tolerance.c_str(), &tailptr);
-
-   if(*tailptr)
-   {
-      //conversion failed because the input wasn't a number
-      return false;
-   }
+bool Validation<R>::updateValidationTolerance(const std::string &tolerance) {
+  char *tailptr;
+  validatetolerance = strtod(tolerance.c_str(), &tailptr);
+
+  if (*tailptr) {
+    // conversion failed because the input wasn't a number
+    return false;
+  }
 
-   return true;
+  return true;
 }
 
 template <class R>
-void Validation<R>::validateSolveReal(SoPlexBase<R>& soplex)
-{
-   bool passedValidation = true;
-   std::string reason = "";
-   R objViolation = 0.0;
-   R maxBoundViolation = 0.0;
-   R maxRowViolation = 0.0;
-   R maxRedCostViolation = 0.0;
-   R maxDualViolation = 0.0;
-   R sumBoundViolation = 0.0;
-   R sumRowViolation = 0.0;
-   R sumRedCostViolation = 0.0;
-   R sumDualViolation = 0.0;
-   R sol;
-
-   std::ostream& os = soplex.spxout.getStream(SPxOut::INFO1);
-
-   if(validatesolution == "+infinity")
-   {
-      sol = soplex.realParam(SoPlexBase<R>::INFTY);
-   }
-   else if(validatesolution == "-infinity")
-   {
-      sol = -soplex.realParam(SoPlexBase<R>::INFTY);
-   }
-   else
-   {
-      sol = atof(validatesolution.c_str());
-   }
-
-   objViolation = spxAbs(sol - soplex.objValueReal());
-
-   // skip check in case presolving detected infeasibility/unboundedness
-   if(SPxSolverBase<R>::INForUNBD == soplex.status() &&
-         (sol == soplex.realParam(SoPlexBase<R>::INFTY)
-          || sol == -soplex.realParam(SoPlexBase<R>::INFTY)))
-      objViolation = 0.0;
-
-   if(! EQ(objViolation, R(0.0), validatetolerance))
-   {
+void Validation<R>::validateSolveReal(SoPlexBase<R> &soplex) {
+  bool passedValidation = true;
+  std::string reason = "";
+  R objViolation = 0.0;
+  R maxBoundViolation = 0.0;
+  R maxRowViolation = 0.0;
+  R maxRedCostViolation = 0.0;
+  R maxDualViolation = 0.0;
+  R sumBoundViolation = 0.0;
+  R sumRowViolation = 0.0;
+  R sumRedCostViolation = 0.0;
+  R sumDualViolation = 0.0;
+  R sol;
+
+  std::ostream &os = soplex.spxout.getStream(SPxOut::INFO1);
+
+  if (validatesolution == "+infinity") {
+    sol = soplex.realParam(SoPlexBase<R>::INFTY);
+  } else if (validatesolution == "-infinity") {
+    sol = -soplex.realParam(SoPlexBase<R>::INFTY);
+  } else {
+    sol = atof(validatesolution.c_str());
+  }
+
+  objViolation = spxAbs(sol - soplex.objValueReal());
+
+  // skip check in case presolving detected infeasibility/unboundedness
+  if (SPxSolverBase<R>::INForUNBD == soplex.status() &&
+      (sol == soplex.realParam(SoPlexBase<R>::INFTY) ||
+       sol == -soplex.realParam(SoPlexBase<R>::INFTY)))
+    objViolation = 0.0;
+
+  if (!EQ(objViolation, R(0.0), validatetolerance)) {
+    passedValidation = false;
+    reason += "Objective Violation; ";
+  }
+
+  if (SPxSolverBase<R>::OPTIMAL == soplex.status()) {
+    soplex.getBoundViolation(maxBoundViolation, sumBoundViolation);
+    soplex.getRowViolation(maxRowViolation, sumRowViolation);
+    soplex.getRedCostViolation(maxRedCostViolation, sumRedCostViolation);
+    soplex.getDualViolation(maxDualViolation, sumDualViolation);
+
+    if (!LE(maxBoundViolation, validatetolerance)) {
+      passedValidation = false;
+      reason += "Bound Violation; ";
+    }
+
+    if (!LE(maxRowViolation, validatetolerance)) {
+      passedValidation = false;
+      reason += "Row Violation; ";
+    }
+
+    if (!LE(maxRedCostViolation, validatetolerance)) {
+      passedValidation = false;
+      reason += "Reduced Cost Violation; ";
+    }
+
+    if (!LE(maxDualViolation, validatetolerance)) {
       passedValidation = false;
-      reason += "Objective Violation; ";
-   }
-
-   if(SPxSolverBase<R>::OPTIMAL == soplex.status())
-   {
-      soplex.getBoundViolation(maxBoundViolation, sumBoundViolation);
-      soplex.getRowViolation(maxRowViolation, sumRowViolation);
-      soplex.getRedCostViolation(maxRedCostViolation, sumRedCostViolation);
-      soplex.getDualViolation(maxDualViolation, sumDualViolation);
-
-      if(! LE(maxBoundViolation, validatetolerance))
-      {
-         passedValidation = false;
-         reason += "Bound Violation; ";
-      }
-
-      if(! LE(maxRowViolation, validatetolerance))
-      {
-         passedValidation = false;
-         reason += "Row Violation; ";
-      }
-
-      if(! LE(maxRedCostViolation, validatetolerance))
-      {
-         passedValidation = false;
-         reason += "Reduced Cost Violation; ";
-      }
-
-      if(! LE(maxDualViolation, validatetolerance))
-      {
-         passedValidation = false;
-         reason += "Dual Violation; ";
-      }
-   }
-
-   os << "\n";
-   os << "Validation          :";
-
-   if(passedValidation)
-      os << " Success\n";
-   else
-   {
-      reason[reason.length() - 2] = ']';
-      os << " Fail [" + reason + "\n";
-   }
-
-   os << "   Objective        : " << std::scientific << std::setprecision(
-         8) << objViolation << std::fixed << "\n";
-   os << "   Bound            : " << std::scientific << std::setprecision(
-         8) << maxBoundViolation << std::fixed << "\n";
-   os << "   Row              : " << std::scientific << std::setprecision(
-         8) << maxRowViolation << std::fixed << "\n";
-   os << "   Reduced Cost     : " << std::scientific << std::setprecision(
-         8) << maxRedCostViolation << std::fixed << "\n";
-   os << "   Dual             : " << std::scientific << std::setprecision(
-         8) << maxDualViolation << std::fixed << "\n";
+      reason += "Dual Violation; ";
+    }
+  }
+
+  os << "\n";
+  os << "Validation          :";
+
+  if (passedValidation)
+    os << " Success\n";
+  else {
+    reason[reason.length() - 2] = ']';
+    os << " Fail [" + reason + "\n";
+  }
+
+  os << "   Objective        : " << std::scientific << std::setprecision(8)
+     << objViolation << std::fixed << "\n";
+  os << "   Bound            : " << std::scientific << std::setprecision(8)
+     << maxBoundViolation << std::fixed << "\n";
+  os << "   Row              : " << std::scientific << std::setprecision(8)
+     << maxRowViolation << std::fixed << "\n";
+  os << "   Reduced Cost     : " << std::scientific << std::setprecision(8)
+     << maxRedCostViolation << std::fixed << "\n";
+  os << "   Dual             : " << std::scientific << std::setprecision(8)
+     << maxDualViolation << std::fixed << "\n";
 }
 
 } // namespace soplex
diff --git a/src/soplex/vectorbase.h b/src/soplex/vectorbase.h
index c1a04c5..c442f8e 100644
--- a/src/soplex/vectorbase.h
+++ b/src/soplex/vectorbase.h
@@ -28,35 +28,37 @@
 #ifndef _VECTORBASE_H_
 #define _VECTORBASE_H_
 
+#include "algorithm"
+#include "vector"
 #include <assert.h>
-#include <string.h>
-#include <math.h>
 #include <iostream>
-#include "vector"
-#include "algorithm"
+#include <math.h>
+#include <string.h>
 
+#include "soplex/rational.h"
 #include "soplex/spxdefines.h"
 #include "soplex/stablesum.h"
-#include "soplex/rational.h"
 
-namespace soplex
-{
-template < class R > class SVectorBase;
-template < class R > class SSVectorBase;
+namespace soplex {
+template <class R> class SVectorBase;
+template <class R> class SSVectorBase;
 
 /**@brief   Dense vector.
  * @ingroup Algebra
  *
- *  Class VectorBase provides dense linear algebra vectors. Internally, VectorBase wraps std::vector.
+ *  Class VectorBase provides dense linear algebra vectors. Internally,
+ * VectorBase wraps std::vector.
  *
- *  After construction, the values of a VectorBase can be accessed with the subscript operator[]().  Safety is provided by
- *  qchecking of array bound when accessing elements with the subscript operator[]() (only when compiled without \c
- *  -DNDEBUG).
+ *  After construction, the values of a VectorBase can be accessed with the
+ * subscript operator[]().  Safety is provided by qchecking of array bound when
+ * accessing elements with the subscript operator[]() (only when compiled
+ * without \c -DNDEBUG).
  *
- *  A VectorBase is distinguished from a simple array of %Reals or %Rationals by providing a set of mathematical
- *  operations.
+ *  A VectorBase is distinguished from a simple array of %Reals or %Rationals by
+ * providing a set of mathematical operations.
  *
- *  The following mathematical operations are provided by class VectorBase (VectorBase \p a, \p b; R \p x):
+ *  The following mathematical operations are provided by class VectorBase
+ * (VectorBase \p a, \p b; R \p x):
  *
  *  <TABLE>
  *  <TR><TD>Operation</TD><TD>Description   </TD><TD></TD>&nbsp;</TR>
@@ -78,573 +80,465 @@ template < class R > class SSVectorBase;
  *      <TD> \c a +=  \c x * \c b </TD></TR>
  *  </TABLE>
  *
- *  When using any of these operations, the vectors involved must be of the same dimension.  Also an SVectorBase \c b is
- *  allowed if it does not contain nonzeros with index greater than the dimension of \c a.q
+ *  When using any of these operations, the vectors involved must be of the same
+ * dimension.  Also an SVectorBase \c b is allowed if it does not contain
+ * nonzeros with index greater than the dimension of \c a.q
  */
-template < class R >
-class VectorBase
-{
-
-   // VectorBase is a friend of VectorBase of different template type. This is so
-   // that we can do conversions.
-   template <typename S>
-   friend class VectorBase;
+template <class R> class VectorBase {
 
+  // VectorBase is a friend of VectorBase of different template type. This is so
+  // that we can do conversions.
+  template <typename S> friend class VectorBase;
 
 protected:
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Data */
+  ///@{
 
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Data */
-   ///@{
+  /// Values of vector.
+  std::vector<R> val;
 
-   /// Values of vector.
-   std::vector<R> val;
-
-   ///@}
+  ///@}
 
 public:
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Construction and assignment */
-   ///@{
-
-   /// Constructor.
-   /** There is no default constructor since the storage for a VectorBase must be provided externally.  Storage must be
-    *  passed as a memory block val at construction. It must be large enough to fit at least dimen values.
-    */
-
-   // Default constructor
-   VectorBase<R>()
-   {
-      // Default constructor
-      ;
-   }
-
-   // Construct from pointer, copies the values into the VectorBase
-   VectorBase<R>(int dimen, R* p_val)
-   {
-      val.assign(p_val, p_val + dimen);
-   }
-
-   // do not convert int to empty vectorbase
-   explicit VectorBase<R>(int p_dimen)
-   {
-      val.resize(p_dimen);
-   }
-
-   // Constructing an element (usually involving casting Real to Rational and
-   // vice versa.)
-   template <typename S>
-   VectorBase<R>(const VectorBase<S>& vec)
-   {
-      this->operator=(vec);
-   }
-
-   // The move constructor
-   VectorBase<R>(const VectorBase<R>&& vec)noexcept: val(std::move(vec.val))
-   {
-   }
-
-   // Copy constructor
-   VectorBase<R>(const VectorBase<R>& vec): val(vec.val)
-   {
-   }
-
-
-   /// Assignment operator.
-   // Supports assignment from a Rational vector to Real and vice versa
-   template < class S >
-   VectorBase<R>& operator=(const VectorBase<S>& vec)
-   {
-      if((VectorBase<S>*)this != &vec)
-      {
-         val.clear();
-         val.reserve(vec.dim());
-
-         for(auto& v : vec.val)
-         {
-            val.push_back(R(v));
-         }
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Construction and assignment */
+  ///@{
+
+  /// Constructor.
+  /** There is no default constructor since the storage for a VectorBase must be
+   * provided externally.  Storage must be passed as a memory block val at
+   * construction. It must be large enough to fit at least dimen values.
+   */
+
+  // Default constructor
+  VectorBase() {
+    // Default constructor
+    // ;
+  }
+
+  // Construct from pointer, copies the values into the VectorBase
+  VectorBase(int dimen, R *p_val) { val.assign(p_val, p_val + dimen); }
+
+  // do not convert int to empty vectorbase
+  explicit VectorBase(int p_dimen) { val.resize(p_dimen); }
+
+  // Constructing an element (usually involving casting Real to Rational and
+  // vice versa.)
+  template <typename S> VectorBase(const VectorBase<S> &vec) {
+    this->operator=(vec);
+  }
+
+  // The move constructor
+  VectorBase(const VectorBase<R> &&vec) noexcept : val(std::move(vec.val)) {}
+
+  // Copy constructor
+  VectorBase(const VectorBase<R> &vec) : val(vec.val) {}
+
+  /// Assignment operator.
+  // Supports assignment from a Rational vector to Real and vice versa
+  template <class S> VectorBase<R> &operator=(const VectorBase<S> &vec) {
+    if ((VectorBase<S> *)this != &vec) {
+      val.clear();
+      val.reserve(vec.dim());
+
+      for (auto &v : vec.val) {
+        val.push_back(R(v));
       }
+    }
 
-      return *this;
-   }
+    return *this;
+  }
 
-   /// Assignment operator.
-   VectorBase<R>& operator=(const VectorBase<R>& vec)
-   {
-      if(this != &vec)
-      {
-         val.reserve(vec.dim());
+  /// Assignment operator.
+  VectorBase<R> &operator=(const VectorBase<R> &vec) {
+    if (this != &vec) {
+      val.reserve(vec.dim());
 
-         val = vec.val;
-      }
+      val = vec.val;
+    }
 
-      return *this;
-   }
+    return *this;
+  }
 
-   /// Move assignment operator
-   VectorBase<R>& operator=(const VectorBase<R>&& vec)
-   {
-      val = std::move(vec.val);
-      return *this;
-   }
+  /// Move assignment operator
+  VectorBase<R> &operator=(const VectorBase<R> &&vec) {
+    val = std::move(vec.val);
+    return *this;
+  }
 
-   /// scale and assign
-   VectorBase<R>& scaleAssign(int scaleExp, const VectorBase<R>& vec)
-   {
-      if(this != &vec)
-      {
-         assert(dim() == vec.dim());
+  /// scale and assign
+  VectorBase<R> &scaleAssign(int scaleExp, const VectorBase<R> &vec) {
+    if (this != &vec) {
+      assert(dim() == vec.dim());
+
+      auto dimen = dim();
+
+      for (decltype(dimen) i = 0; i < dimen; i++)
+        val[i] = spxLdexp(vec[i], scaleExp);
+    }
+
+    return *this;
+  }
+
+  /// scale and assign
+  VectorBase<R> &scaleAssign(const int *scaleExp, const VectorBase<R> &vec,
+                             bool negateExp = false) {
+    if (this != &vec) {
+      assert(dim() == vec.dim());
 
-         auto dimen = dim();
+      if (negateExp) {
+        auto dimen = dim();
 
-         for(decltype(dimen) i = 0 ; i < dimen; i++)
-            val[i] = spxLdexp(vec[i], scaleExp);
+        for (decltype(dimen) i = 0; i < dimen; i++)
+          val[i] = spxLdexp(vec[i], -scaleExp[i]);
+      } else {
+        auto dimen = dim();
 
+        for (decltype(dimen) i = 0; i < dimen; i++)
+          val[i] = spxLdexp(vec[i], scaleExp[i]);
       }
+    }
 
-      return *this;
-   }
+    return *this;
+  }
 
-   /// scale and assign
-   VectorBase<R>& scaleAssign(const int* scaleExp, const VectorBase<R>& vec, bool negateExp = false)
-   {
-      if(this != &vec)
-      {
-         assert(dim() == vec.dim());
+  /// Assignment operator.
+  /** Assigning an SVectorBase to a VectorBase using operator=() will set all
+   * values to 0 except the nonzeros of \p vec. This is diffent in method
+   * assign().
+   */
+  template <class S> VectorBase<R> &operator=(const SVectorBase<S> &vec);
 
-         if(negateExp)
-         {
-            auto dimen = dim();
+  /// Assignment operator.
+  /** Assigning an SSVectorBase to a VectorBase using operator=() will set all
+   * values to 0 except the nonzeros of \p vec.  This is diffent in method
+   * assign().
+   */
+  /**@todo do we need this also in non-template version, because SSVectorBase
+   * can be automatically cast to VectorBase? */
+  template <class S> VectorBase<R> &operator=(const SSVectorBase<S> &vec);
 
-            for(decltype(dimen) i = 0; i < dimen; i++)
-               val[i] = spxLdexp(vec[i], -scaleExp[i]);
-         }
-         else
-         {
-            auto dimen = dim();
+  /// Assign values of \p vec.
+  /** Assigns all nonzeros of \p vec to the vector.  All other values remain
+   * unchanged. */
+  template <class S> VectorBase<R> &assign(const SVectorBase<S> &vec);
 
-            for(decltype(dimen) i = 0; i < dimen; i++)
-               val[i] = spxLdexp(vec[i], scaleExp[i]);
-         }
+  /// Assign values of \p vec.
+  /** Assigns all nonzeros of \p vec to the vector.  All other values remain
+   * unchanged. */
+  template <class S> VectorBase<R> &assign(const SSVectorBase<S> &vec);
 
-      }
+  ///@}
 
-      return *this;
-   }
-
-
-   /// Assignment operator.
-   /** Assigning an SVectorBase to a VectorBase using operator=() will set all values to 0 except the nonzeros of \p vec.
-    *  This is diffent in method assign().
-    */
-   template < class S >
-   VectorBase<R>& operator=(const SVectorBase<S>& vec);
-
-   /// Assignment operator.
-   /** Assigning an SSVectorBase to a VectorBase using operator=() will set all values to 0 except the nonzeros of \p
-    *  vec.  This is diffent in method assign().
-    */
-   /**@todo do we need this also in non-template version, because SSVectorBase can be automatically cast to VectorBase? */
-   template < class S >
-   VectorBase<R>& operator=(const SSVectorBase<S>& vec);
-
-   /// Assign values of \p vec.
-   /** Assigns all nonzeros of \p vec to the vector.  All other values remain unchanged. */
-   template < class S >
-   VectorBase<R>& assign(const SVectorBase<S>& vec);
-
-   /// Assign values of \p vec.
-   /** Assigns all nonzeros of \p vec to the vector.  All other values remain unchanged. */
-   template < class S >
-   VectorBase<R>& assign(const SSVectorBase<S>& vec);
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Access */
-   ///@{
-
-   /// Dimension of vector.
-   int dim() const
-   {
-      return int(val.size());
-   }
-
-   /// Return \p n 'th value by reference.
-   R& operator[](int n)
-   {
-      assert(n >= 0 && n < dim());
-      return val[n];
-   }
-
-   /// Return \p n 'th value.
-   const R& operator[](int n) const
-   {
-      assert(n >= 0 && n < dim());
-      return val[n];
-   }
-
-   /// Equality operator.
-   friend bool operator==(const VectorBase<R>& vec1, const VectorBase<R>& vec2)
-   {
-      return (vec1.val == vec2.val);
-   }
-
-   /// Return underlying std::vector.
-   const std::vector<R>& vec()
-   {
-      return val;
-   }
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Arithmetic operations */
-   ///@{
-
-   /// Set vector to contain all-zeros (keeping the same length)
-   void clear()
-   {
-      for(auto& v : val)
-         v = 0;
-   }
-
-   /// Addition.
-   template < class S >
-   VectorBase<R>& operator+=(const VectorBase<S>& vec)
-   {
-      assert(dim() == vec.dim());
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Access */
+  ///@{
 
-      auto dimen = dim();
+  /// Dimension of vector.
+  int dim() const { return int(val.size()); }
 
-      for(decltype(dimen) i = 0; i < dimen; i++)
-         val[i] += vec[i];
+  /// Return \p n 'th value by reference.
+  R &operator[](int n) {
+    assert(n >= 0 && n < dim());
+    return val[n];
+  }
 
-      return *this;
-   }
+  /// Return \p n 'th value.
+  const R &operator[](int n) const {
+    assert(n >= 0 && n < dim());
+    return val[n];
+  }
 
-   /// Addition.
-   template < class S >
-   VectorBase<R>& operator+=(const SVectorBase<S>& vec);
+  /// Equality operator.
+  friend bool operator==(const VectorBase<R> &vec1, const VectorBase<R> &vec2) {
+    return (vec1.val == vec2.val);
+  }
 
-   /// Addition.
-   template < class S >
-   VectorBase<R>& operator+=(const SSVectorBase<S>& vec);
+  /// Return underlying std::vector.
+  const std::vector<R> &vec() { return val; }
 
-   /// Subtraction.
-   template < class S >
-   VectorBase<R>& operator-=(const VectorBase<S>& vec)
-   {
-      assert(dim() == vec.dim());
+  ///@}
 
-      auto dimen = dim();
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Arithmetic operations */
+  ///@{
 
-      for(decltype(dimen) i = 0; i < dimen; i++)
-         val[i] -= vec[i];
+  /// Set vector to contain all-zeros (keeping the same length)
+  void clear() {
+    for (auto &v : val)
+      v = 0;
+  }
 
-      return *this;
-   }
+  /// Addition.
+  template <class S> VectorBase<R> &operator+=(const VectorBase<S> &vec) {
+    assert(dim() == vec.dim());
 
-   /// Subtraction.
-   template < class S >
-   VectorBase<R>& operator-=(const SVectorBase<S>& vec);
+    auto dimen = dim();
 
-   /// Subtraction.
-   template < class S >
-   VectorBase<R>& operator-=(const SSVectorBase<S>& vec);
+    for (decltype(dimen) i = 0; i < dimen; i++)
+      val[i] += vec[i];
 
-   /// Scaling.
-   template < class S >
-   VectorBase<R>& operator*=(const S& x)
-   {
+    return *this;
+  }
 
-      auto dimen = dim();
+  /// Addition.
+  template <class S> VectorBase<R> &operator+=(const SVectorBase<S> &vec);
 
-      for(decltype(dimen) i = 0; i < dimen; i++)
-         val[i] *= x;
+  /// Addition.
+  template <class S> VectorBase<R> &operator+=(const SSVectorBase<S> &vec);
 
-      return *this;
-   }
+  /// Subtraction.
+  template <class S> VectorBase<R> &operator-=(const VectorBase<S> &vec) {
+    assert(dim() == vec.dim());
 
-   /// Division.
-   template < class S >
-   VectorBase<R>& operator/=(const S& x)
-   {
-      assert(x != 0);
+    auto dimen = dim();
 
-      auto dimen = dim();
+    for (decltype(dimen) i = 0; i < dimen; i++)
+      val[i] -= vec[i];
 
-      for(decltype(dimen) i = 0; i < dimen; i++)
-         val[i] /= x;
+    return *this;
+  }
 
-      return *this;
-   }
+  /// Subtraction.
+  template <class S> VectorBase<R> &operator-=(const SVectorBase<S> &vec);
 
-   /// Inner product.
-   R operator*(const VectorBase<R>& vec) const
-   {
-      StableSum<R> x;
+  /// Subtraction.
+  template <class S> VectorBase<R> &operator-=(const SSVectorBase<S> &vec);
 
-      auto dimen = dim();
+  /// Scaling.
+  template <class S> VectorBase<R> &operator*=(const S &x) {
 
-      for(decltype(dimen) i = 0; i < dimen; i++)
-         x += val[i] * vec.val[i];
+    auto dimen = dim();
 
-      return x;
-   }
+    for (decltype(dimen) i = 0; i < dimen; i++)
+      val[i] *= x;
 
-   /// Inner product.
-   R operator*(const SVectorBase<R>& vec) const;
+    return *this;
+  }
 
-   /// Inner product.
-   R operator*(const SSVectorBase<R>& vec) const;
+  /// Division.
+  template <class S> VectorBase<R> &operator/=(const S &x) {
+    assert(x != 0);
 
-   /// Maximum absolute value, i.e., infinity norm.
-   R maxAbs() const
-   {
-      assert(dim() > 0);
+    auto dimen = dim();
 
-      // A helper function for the std::max_element. Because we compare the absolute value.
-      auto absCmpr = [](R a, R b)
-      {
-         return (spxAbs(a) < spxAbs(b));
-      };
+    for (decltype(dimen) i = 0; i < dimen; i++)
+      val[i] /= x;
 
-      auto maxReference = std::max_element(val.begin(), val.end(), absCmpr);
+    return *this;
+  }
 
-      R maxi = spxAbs(*maxReference);
+  /// Inner product.
+  R operator*(const VectorBase<R> &vec) const {
+    StableSum<R> x;
 
-      assert(maxi >= 0.0);
+    auto dimen = dim();
 
-      return maxi;
-   }
+    for (decltype(dimen) i = 0; i < dimen; i++)
+      x += val[i] * vec.val[i];
 
-   /// Minimum absolute value.
-   R minAbs() const
-   {
-      assert(dim() > 0);
+    return x;
+  }
 
-      // A helper function for the std::min_element. Because we compare the absolute value.
-      auto absCmpr = [](R a, R b)
-      {
-         return (spxAbs(a) < spxAbs(b));
-      };
+  /// Inner product.
+  R operator*(const SVectorBase<R> &vec) const;
 
-      auto minReference = std::min_element(val.begin(), val.end(), absCmpr);
+  /// Inner product.
+  R operator*(const SSVectorBase<R> &vec) const;
 
-      R mini = spxAbs(*minReference);
+  /// Maximum absolute value, i.e., infinity norm.
+  R maxAbs() const {
+    assert(dim() > 0);
 
-      assert(mini >= 0.0);
+    // A helper function for the std::max_element. Because we compare the
+    // absolute value.
+    auto absCmpr = [](R a, R b) { return (spxAbs(a) < spxAbs(b)); };
 
-      return mini;
-   }
+    auto maxReference = std::max_element(val.begin(), val.end(), absCmpr);
 
-   /// Floating point approximation of euclidian norm (without any approximation guarantee).
-   R length() const
-   {
-      return spxSqrt(length2());
-   }
+    R maxi = spxAbs(*maxReference);
 
-   /// Squared norm.
-   R length2() const
-   {
-      return (*this) * (*this);
-   }
+    assert(maxi >= 0.0);
 
-   /// Addition of scaled vector.
-   template < class S, class T >
-   VectorBase<R>& multAdd(const S& x, const VectorBase<T>& vec)
-   {
-      assert(vec.dim() == dim());
+    return maxi;
+  }
 
-      auto dimen = dim();
+  /// Minimum absolute value.
+  R minAbs() const {
+    assert(dim() > 0);
 
-      for(decltype(dimen) i = 0; i < dimen; i++)
-         val[i] += x * vec.val[i];
-
-      return *this;
-   }
-
-   /// Addition of scaled vector.
-   template < class S, class T >
-   VectorBase<R>& multAdd(const S& x, const SVectorBase<T>& vec);
-
-   /// Subtraction of scaled vector.
-   template < class S, class T >
-   VectorBase<R>& multSub(const S& x, const SVectorBase<T>& vec);
-
-   /// Addition of scaled vector.
-   template < class S, class T >
-   VectorBase<R>& multAdd(const S& x, const SSVectorBase<T>& vec);
-
-   ///@}
-
-   // ------------------------------------------------------------------------------------------------------------------
-   /**@name Utilities */
-   ///@{
-
-   /// Conversion to C-style pointer.
-   /** This function serves for using a VectorBase in an C-style function. It returns a pointer to the first value of
-    *  the array.
-    *
-    *  @todo check whether this non-const c-style access should indeed be public
-    */
-   R* get_ptr()
-   {
-      return val.data();
-   }
-
-   /// Conversion to C-style pointer.
-   /** This function serves for using a VectorBase in an C-style function. It returns a pointer to the first value of
-    *  the array.
-    */
-   const R* get_const_ptr() const
-   {
-      return val.data();
-   }
-
-   // Provides access to the iterators of std::vector<R> val
-   typename std::vector<R>::const_iterator begin() const
-   {
-      return val.begin();
-   }
-
-   typename std::vector<R>::iterator begin()
-   {
-      return val.begin();
-   }
-
-   // Provides access to the iterators of std::vector<R> val
-   typename std::vector<R>::const_iterator end() const
-   {
-      return val.end();
-   }
-
-   typename std::vector<R>::iterator end()
-   {
-      return val.end();
-   }
-
-   // Functions from VectorBase
-
-   // This used to be VectorBase's way of having std::vector's capacity. This
-   // represents the maximum number of elements the std::vector can have without,
-   // needing any more resizing. Bigger than size, mostly.
-   int memSize() const
-   {
-      return int(val.capacity());
-   }
-
-   /// Resets \ref soplex::VectorBase "VectorBase"'s dimension to \p newdim.
-   void reDim(int newdim, const bool setZero = true)
-   {
-      if(setZero && newdim > dim())
-      {
-         // Inserts 0 to the rest of the vectors.
-         //
-         // TODO: Is this important after the change of raw pointers to
-         // std::vector. This is just a waste of operations, I think.
-         val.insert(val.end(), newdim - VectorBase<R>::dim(), 0);
-      }
-      else
-      {
-         val.resize(newdim);
-      }
+    // A helper function for the std::min_element. Because we compare the
+    // absolute value.
+    auto absCmpr = [](R a, R b) { return (spxAbs(a) < spxAbs(b)); };
 
-   }
+    auto minReference = std::min_element(val.begin(), val.end(), absCmpr);
 
+    R mini = spxAbs(*minReference);
 
-   /// Resets \ref soplex::VectorBase "VectorBase"'s memory size to \p newsize.
-   void reSize(int newsize)
-   {
-      assert(newsize > VectorBase<R>::dim());
+    assert(mini >= 0.0);
 
-      // Problem: This is not a conventional resize for std::vector. This only
-      // updates the capacity, i.e., by pushing elements to the vector after this,
-      // there will not be any (internal) resizes.
-      val.reserve(newsize);
-   }
+    return mini;
+  }
 
-   // For operations such as vec1 - vec2
-   const VectorBase<R> operator-(const VectorBase<R>& vec) const
-   {
-      assert(vec.dim() == dim());
-      VectorBase<R> res;
-      res.val.reserve(dim());
+  /// Floating point approximation of euclidian norm (without any approximation
+  /// guarantee).
+  R length() const { return spxSqrt(length2()); }
 
-      auto dimen = dim();
+  /// Squared norm.
+  R length2() const { return (*this) * (*this); }
 
-      for(decltype(dimen) i = 0; i < dimen; i++)
-      {
-         res.val.push_back(val[i] - vec[i]);
-      }
+  /// Addition of scaled vector.
+  template <class S, class T>
+  VectorBase<R> &multAdd(const S &x, const VectorBase<T> &vec) {
+    assert(vec.dim() == dim());
 
-      return res;
-   }
+    auto dimen = dim();
 
-   // Addition
-   const VectorBase<R> operator+(const VectorBase<R>& v) const
-   {
-      assert(v.dim() == dim());
-      VectorBase<R> res;
-      res.val.reserve(dim());
+    for (decltype(dimen) i = 0; i < dimen; i++)
+      val[i] += x * vec.val[i];
 
-      auto dimen = dim();
+    return *this;
+  }
 
-      for(decltype(dimen) i = 0; i < dimen; i++)
-      {
-         res.val.push_back(val[i] + v[i]);
-      }
+  /// Addition of scaled vector.
+  template <class S, class T>
+  VectorBase<R> &multAdd(const S &x, const SVectorBase<T> &vec);
 
-      return res;
-   }
+  /// Subtraction of scaled vector.
+  template <class S, class T>
+  VectorBase<R> &multSub(const S &x, const SVectorBase<T> &vec);
 
-   // The negation operator. e.g. -vec1;
-   friend VectorBase<R> operator-(const VectorBase<R>& vec)
-   {
-      VectorBase<R> res;
+  /// Addition of scaled vector.
+  template <class S, class T>
+  VectorBase<R> &multAdd(const S &x, const SSVectorBase<T> &vec);
 
-      res.val.reserve(vec.dim());
+  ///@}
 
-      for(auto& v : vec.val)
-      {
-         res.val.push_back(-(v));
-      }
+  // ------------------------------------------------------------------------------------------------------------------
+  /**@name Utilities */
+  ///@{
+
+  /// Conversion to C-style pointer.
+  /** This function serves for using a VectorBase in an C-style function. It
+   * returns a pointer to the first value of the array.
+   *
+   *  @todo check whether this non-const c-style access should indeed be public
+   */
+  R *get_ptr() { return val.data(); }
+
+  /// Conversion to C-style pointer.
+  /** This function serves for using a VectorBase in an C-style function. It
+   * returns a pointer to the first value of the array.
+   */
+  const R *get_const_ptr() const { return val.data(); }
+
+  // Provides access to the iterators of std::vector<R> val
+  typename std::vector<R>::const_iterator begin() const { return val.begin(); }
 
-      return res;
-   }
+  typename std::vector<R>::iterator begin() { return val.begin(); }
 
+  // Provides access to the iterators of std::vector<R> val
+  typename std::vector<R>::const_iterator end() const { return val.end(); }
 
-   ///@}
-   /// Consistency check.
-   bool isConsistent() const
-   {
-      return true;
-   }
+  typename std::vector<R>::iterator end() { return val.end(); }
 
+  // Functions from VectorBase
+
+  // This used to be VectorBase's way of having std::vector's capacity. This
+  // represents the maximum number of elements the std::vector can have without,
+  // needing any more resizing. Bigger than size, mostly.
+  int memSize() const { return int(val.capacity()); }
+
+  /// Resets \ref soplex::VectorBase "VectorBase"'s dimension to \p newdim.
+  void reDim(int newdim, const bool setZero = true) {
+    if (setZero && newdim > dim()) {
+      // Inserts 0 to the rest of the vectors.
+      //
+      // TODO: Is this important after the change of raw pointers to
+      // std::vector. This is just a waste of operations, I think.
+      val.insert(val.end(), newdim - VectorBase<R>::dim(), 0);
+    } else {
+      val.resize(newdim);
+    }
+  }
+
+  /// Resets \ref soplex::VectorBase "VectorBase"'s memory size to \p newsize.
+  void reSize(int newsize) {
+    assert(newsize > VectorBase<R>::dim());
+
+    // Problem: This is not a conventional resize for std::vector. This only
+    // updates the capacity, i.e., by pushing elements to the vector after this,
+    // there will not be any (internal) resizes.
+    val.reserve(newsize);
+  }
+
+  // For operations such as vec1 - vec2
+  const VectorBase<R> operator-(const VectorBase<R> &vec) const {
+    assert(vec.dim() == dim());
+    VectorBase<R> res;
+    res.val.reserve(dim());
+
+    auto dimen = dim();
+
+    for (decltype(dimen) i = 0; i < dimen; i++) {
+      res.val.push_back(val[i] - vec[i]);
+    }
+
+    return res;
+  }
+
+  // Addition
+  const VectorBase<R> operator+(const VectorBase<R> &v) const {
+    assert(v.dim() == dim());
+    VectorBase<R> res;
+    res.val.reserve(dim());
+
+    auto dimen = dim();
+
+    for (decltype(dimen) i = 0; i < dimen; i++) {
+      res.val.push_back(val[i] + v[i]);
+    }
+
+    return res;
+  }
+
+  // The negation operator. e.g. -vec1;
+  friend VectorBase<R> operator-(const VectorBase<R> &vec) {
+    VectorBase<R> res;
+
+    res.val.reserve(vec.dim());
+
+    for (auto &v : vec.val) {
+      res.val.push_back(-(v));
+    }
+
+    return res;
+  }
+
+  ///@}
+  /// Consistency check.
+  bool isConsistent() const { return true; }
 };
 
 /// Inner product.
-template<>
-inline
-Rational VectorBase<Rational>::operator*(const VectorBase<Rational>& vec) const
-{
-   assert(vec.dim() == dim());
+template <>
+inline Rational
+VectorBase<Rational>::operator*(const VectorBase<Rational> &vec) const {
+  assert(vec.dim() == dim());
 
-   if(dim() <= 0 || vec.dim() <= 0)
-      return Rational();
+  if (dim() <= 0 || vec.dim() <= 0)
+    return Rational();
 
-   Rational x = val[0];
-   x *= vec.val[0];
+  Rational x = val[0];
+  x *= vec.val[0];
 
-   auto dimen = dim();
+  auto dimen = dim();
 
-   for(decltype(dimen) i = 1; i < dimen; i++)
-      x += val[i] * vec.val[i];
+  for (decltype(dimen) i = 1; i < dimen; i++)
+    x += val[i] * vec.val[i];
 
-   return x;
+  return x;
 }
 
 } // namespace soplex
-- 
2.41.0

